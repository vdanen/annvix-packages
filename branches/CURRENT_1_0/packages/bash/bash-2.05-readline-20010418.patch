diff -urN -x CVS bash-2.05/lib/readline/bind.c bash205/lib/readline/bind.c
--- bash-2.05/lib/readline/bind.c	Tue Mar  6 00:10:07 2001
+++ bash205/lib/readline/bind.c	Mon Apr 16 14:45:41 2001
@@ -25,6 +25,16 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+#  include <limits.h>
+# endif
+#endif
+
 #include <stdio.h>
 #include <sys/types.h>
 #include <fcntl.h>
@@ -1257,6 +1267,9 @@
 #if defined (VISIBLE_STATS)
   { "visible-stats",		&rl_visible_stats,		0 },
 #endif /* VISIBLE_STATS */
+#if defined (HANDLE_MULTIBYTE)
+  { "byte-oriented",            &rl_byte_oriented,              0},
+#endif /* HANDLE_MULTIBYTE  */
   { (char *)NULL, (int *)NULL }
 };
 
diff -urN -x CVS bash-2.05/lib/readline/complete.c bash205/lib/readline/complete.c
--- bash-2.05/lib/readline/complete.c	Wed Feb 14 21:47:18 2001
+++ bash205/lib/readline/complete.c	Mon Apr 16 14:45:41 2001
@@ -25,6 +25,21 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+#  include <limits.h>
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 #include <sys/types.h>
 #include <fcntl.h>
 #if defined (HAVE_SYS_FILE_H)
@@ -41,6 +56,10 @@
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
 #include <stdio.h>
 
 #include <errno.h>
@@ -584,7 +603,11 @@
       /* We didn't find an unclosed quoted substring upon which to do
          completion, so use the word break characters to find the
          substring on which to complete. */
+#if defined (HANDLE_MULTIBYTE)
+      while (rl_point = _rl_find_previous_char_started_byte (rl_line_buffer,rl_point))
+#else
       while (--rl_point)
+#endif /* HANDLE_MULTIBYTE */
 	{
 	  scan = rl_line_buffer[rl_point];
 
@@ -756,6 +779,10 @@
 {
   register int i, c1, c2, si;
   int low;		/* Count of max-matched characters. */
+#if defined (HANDLE_MULTIBYTE)
+  mbstate_t ps1;
+  mbstate_t ps2;
+#endif  
 
   /* If only one match, just use that.  Otherwise, compare each
      member of the list with the next, finding out where they
@@ -769,12 +796,37 @@
 
   for (i = 1, low = 100000; i < matches; i++)
     {
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+          memset(&ps1,0,sizeof(mbstate_t));
+          memset(&ps2,0,sizeof(mbstate_t));
+        }
+#endif
       if (_rl_completion_case_fold)
 	{
 	  for (si = 0;
 	       (c1 = _rl_to_lower(match_list[i][si])) &&
 	       (c2 = _rl_to_lower(match_list[i + 1][si]));
 	       si++)
+#if defined (HANDLE_MULTIBYTE)
+	    if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	      {
+		int v;
+                wchar_t wc1;
+                wchar_t wc2;
+                v = mbrtowc(&wc1,match_list[i]+si,strlen(match_list[i]+si),&ps1);
+                mbrtowc(&wc2,match_list[i+1]+si,strlen(match_list[i+1]+si),&ps2);
+
+                wc1 = towlower(wc1);
+                wc2 = towlower(wc2);
+                if ( wc1 != wc2 )
+		  break;
+		else if (v > 1)
+		  si += v-1;
+	      }
+	    else
+#endif /* HANDLE_MULTIBYTE */
 	    if (c1 != c2)
 	      break;
 	}
@@ -784,6 +836,18 @@
 	       (c1 = match_list[i][si]) &&
 	       (c2 = match_list[i + 1][si]);
 	       si++)
+#if defined (HANDLE_MULTIBYTE)
+	    if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	      {
+		int v;
+                mbstate_t ps_back = ps1;
+		if (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))
+		  break;
+		else if ((v = _rl_get_char_len (&match_list[i][si],&ps_back)) > 1)
+		  si += v-1;
+	      }
+	    else
+#endif /* HANDLE_MULTIBYTE */
 	    if (c1 != c2)
 	      break;
 	}
diff -urN -x CVS bash-2.05/lib/readline/display.c bash205/lib/readline/display.c
--- bash-2.05/lib/readline/display.c	Sat Feb  3 03:25:10 2001
+++ bash205/lib/readline/display.c	Mon Apr 16 14:45:41 2001
@@ -25,6 +25,30 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+#  include <limits.h>
+# endif
+#endif
+
+#ifdef HANDLE_MULTIBYTE
+# if defined(MB_LEN_MAX) && (MB_LEN_MAX < 16)
+#  undef MB_LEN_MAX
+#  define MB_LEN_MAX 16
+# elif !defined(MB_LEN_MAX)
+#  define MB_LEN_MAX 16
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 #include <sys/types.h>
 
 #if defined (HAVE_UNISTD_H)
@@ -67,6 +91,9 @@
 static void delete_chars __P((int));
 static void insert_some_chars __P((char *, int));
 static void cr __P((void));
+#if defined (HANDLE_MULTIBYTE)
+static int _rl_col_width __P((char *, int, int));
+#endif
 
 static int *inv_lbreaks, *vis_lbreaks;
 static int inv_lbsize, vis_lbsize;
@@ -372,6 +399,12 @@
   int c_pos, inv_botlin, lb_botlin, lb_linenum;
   int newlines, lpos, temp;
   char *prompt_this_line;
+#if defined(HANDLE_MULTIBYTE)
+  wchar_t wc;
+  size_t wc_bytes;
+  int wc_width;
+  mbstate_t ps;
+#endif  
 
   if (!readline_echoing_p)
     return;
@@ -523,10 +556,48 @@
      It maintains an array of line breaks for display (inv_lbreaks).
      This handles expanding tabs for display and displaying meta characters. */
   lb_linenum = 0;
+#if defined (HANDLE_MULTIBYTE)
+  in = 0;
+  if(!rl_byte_oriented)
+    {
+      memset(&ps,0,sizeof(mbstate_t));
+      wc_bytes = mbrtowc(&wc,rl_line_buffer,rl_end,&ps);
+    }
+  else
+    wc_bytes = 1;
+  while(in<rl_end)
+#else  
   for (in = 0; in < rl_end; in++)
+#endif      
     {
       c = (unsigned char)rl_line_buffer[in];
 
+#if defined (HANDLE_MULTIBYTE)
+      if(!rl_byte_oriented)
+        {
+          if( (size_t)(-1) == wc_bytes || (size_t)(-2) == wc_bytes)
+            {
+              /* bytes sequence is invalid or shorted. 
+                 assume that a first byte represent a character */
+              wc_bytes = 1;
+              /* assume that a character occupy a single column */
+              wc_width = 1;
+              memset(&ps,0,sizeof(mbstate_t));
+            }
+          else if ( (size_t)(0) == wc_bytes)
+            /* found '\0' character */
+            break;
+          else
+            {
+              temp = wcwidth(wc);
+              if(temp < 0)
+                wc_width = 1;
+              else
+                wc_width = temp;
+            }
+        }
+#endif
+      
       if (out + 8 >= line_size)		/* XXX - 8 for \t */
 	{
 	  line_size *= 2;
@@ -540,8 +611,11 @@
 	  c_pos = out;
 	  lb_linenum = newlines;
 	}
-
+#if defined (HANDLE_MULTIBYTE)
+      if (META_CHAR (c) && !_rl_output_meta_chars)
+#else      
       if (META_CHAR (c))
+#endif        
 	{
 	  if (_rl_output_meta_chars == 0)
 	    {
@@ -610,9 +684,51 @@
 	}
       else
 	{
+
+#if defined (HANDLE_MULTIBYTE)
+          if(!rl_byte_oriented)
+            {
+              int i;
+          
+              if( _rl_screenwidth < lpos + wc_width )
+                for(i=lpos;i<_rl_screenwidth;i++)
+                  {
+                    line[out++] = ' ';
+                    CHECK_LPOS();
+                  }
+              if (in == rl_point)
+                {
+                  c_pos = out;
+                  lb_linenum = newlines;
+                }
+              for(i=in;i<in+wc_bytes;i++)
+                {
+                  line[out++] = rl_line_buffer[i];
+                }
+              for(i=0;i<wc_width;i++)
+                CHECK_LPOS();
+            }
+          else
+            {
+              line[out++] = c;
+              CHECK_LPOS();
+            }
+#else
 	  line[out++] = c;
 	  CHECK_LPOS();
+#endif          
 	}
+#if defined (HANDLE_MULTIBYTE)
+      if(!rl_byte_oriented)
+        {
+          in += wc_bytes;
+          wc_bytes = mbrtowc(&wc,rl_line_buffer+in,rl_end-in,&ps);
+        }
+      else
+        {
+          in++;
+        }
+#endif      
     }
   line[out] = '\0';
   if (c_pos < 0)
@@ -650,7 +766,13 @@
 	     only display a screenful.  We should display the last screen,
 	     not the first.  */
 	  if (out >= _rl_screenchars)
-	    out = _rl_screenchars - 1;
+#if defined (HANDLE_MULTIBYTE)
+            if(!rl_byte_oriented)
+              out = _rl_find_previous_char_started_byte(line,_rl_screenchars);
+            else
+#endif            
+              out = _rl_screenchars - 1;
+
 
 	  /* The first line is at character position 0 in the buffer.  The
 	     second and subsequent lines start at inv_lbreaks[N], offset by
@@ -900,12 +1022,19 @@
   register char *ofd, *ols, *oe, *nfd, *nls, *ne;
   int temp, lendiff, wsatend, od, nd;
   int current_invis_chars;
+#if defined (HANDLE_MULTIBYTE)
+  int col_lendiff, col_temp;
+#endif  
 
   /* If we're at the right edge of a terminal that supports xn, we're
      ready to wrap around, so do so.  This fixes problems with knowing
      the exact cursor position and cut-and-paste with certain terminal
      emulators.  In this calculation, TEMP is the physical screen
      position of the cursor. */
+#if defined(HANDLE_MULTIBYTE)
+  if(MB_CUR_MAX == 1 || rl_byte_oriented)
+    {
+#endif  
   temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
   if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
       && _rl_last_v_pos == current_line - 1)
@@ -919,8 +1048,19 @@
       if (old[0] && new[0])
 	old[0] = new[0];
     }
+#if defined(HANDLE_MULTIBYTE)
+    }
+#endif  
       
   /* Find first difference. */
+#if defined (HANDLE_MULTIBYTE)
+  if(!rl_byte_oriented)
+    {
+      ofd = old;
+      nfd = new;
+    }
+  else
+#endif
   for (ofd = old, nfd = new;
        (ofd - old < omax) && *ofd && (*ofd == *nfd);
        ofd++, nfd++)
@@ -936,6 +1076,15 @@
   if (ofd == oe && nfd == ne)
     return;
 
+#if defined (HANDLE_MULTIBYTE)
+  if(!rl_byte_oriented)
+    {
+      nls = ne;
+      ols = oe;
+    }
+  else
+    {
+#endif  
   wsatend = 1;			/* flag for trailing whitespace */
   ols = oe - 1;			/* find last same */
   nls = ne - 1;
@@ -959,6 +1108,9 @@
       if (*nls)
 	nls++;
     }
+#if defined (HANDLE_MULTIBYTE)
+    }
+#endif  
 
   /* count of invisible characters in the current invisible line. */
   current_invis_chars = W_OFFSET (current_line, wrap_offset);
@@ -1000,17 +1152,39 @@
 
   /* if (len (new) > len (old)) */
   lendiff = (nls - nfd) - (ols - ofd);
+#if defined (HANDLE_MULTIBYTE)
+  if(!rl_byte_oriented)
+    col_lendiff = _rl_col_width(new,nls-new,nfd-new) -
+      _rl_col_width(old,ols-old,ofd-old);
+  else
+    col_lendiff = lendiff;
+#endif
 
   /* If we are changing the number of invisible characters in a line, and
      the spot of first difference is before the end of the invisible chars,
      lendiff needs to be adjusted. */
   if (current_line == 0 && !_rl_horizontal_scroll_mode &&
       current_invis_chars != visible_wrap_offset)
+#if defined (HANDLE_MULTIBYTE)
+    {
+      lendiff += visible_wrap_offset - current_invis_chars;
+      col_lendiff += visible_wrap_offset - current_invis_chars;
+    }
+#else    
     lendiff += visible_wrap_offset - current_invis_chars;
+#endif  
 
   /* Insert (diff (len (old), len (new)) ch. */
   temp = ne - nfd;
+#if defined (HANDLE_MULTIBYTE)
+  if(!rl_byte_oriented)
+    col_temp = _rl_col_width(new,ne-new,nfd-new);
+  else
+    col_temp = temp;
+  if(col_lendiff > 0)
+#else  
   if (lendiff > 0)
+#endif    
     {
       /* Non-zero if we're increasing the number of lines. */
       int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
@@ -1018,7 +1192,13 @@
 	 use the terminal's capabilities.  If we're growing the number
 	 of lines, make sure we actually cause the new line to wrap
 	 around on auto-wrapping terminals. */
+#if defined(HANDLE_MULTIBYTE)
+      if (_rl_terminal_can_insert &&
+          ((2 * col_temp) >= col_lendiff || _rl_term_IC) &&
+          (!_rl_term_autowrap || !gl))
+#else
       if (_rl_terminal_can_insert && ((2 * temp) >= lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
+#endif        
 	{
 	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
 	     _rl_horizontal_scroll_mode == 1, inserting the characters with
@@ -1066,7 +1246,11 @@
   else				/* Delete characters from line. */
     {
       /* If possible and inexpensive to use terminal deletion, then do so. */
+#if defined (HANDLE_MULTIBYTE)
+      if (_rl_term_dc && (2 * temp) >= -lendiff && rl_byte_oriented)
+#else      
       if (_rl_term_dc && (2 * temp) >= -lendiff)
+#endif        
 	{
 	  /* If all we're doing is erasing the invisible characters in the
 	     prompt string, don't bother.  It screws up the assumptions
@@ -1094,13 +1278,30 @@
 	      _rl_output_some_chars (nfd, temp);
 	      _rl_last_c_pos += temp;
 	    }
-	  lendiff = (oe - old) - (ne - new);
+#if defined(HANDLE_MULTIBYTE)
+          lendiff = (oe - old) - (ne - new);
+          if(!rl_byte_oriented)
+            col_lendiff = _rl_col_width(old,0,oe-old) -
+              _rl_col_width(new,0,ne-new) ;
+          else
+            col_lendiff = lendiff;
+          if(col_lendiff)
+#else          
 	  if (lendiff)
+#endif              
 	    {	  
 	      if (_rl_term_autowrap && current_line < inv_botlin)
-		space_to_eol (lendiff);
+#if defined (HANDLE_MULTIBYTE)
+                  space_to_eol (col_lendiff);
+#else              
+                  space_to_eol (lendiff);
+#endif
 	      else
-		_rl_clear_to_eol (lendiff);
+#if defined (HANDLE_MULTIBYTE)
+                  _rl_clear_to_eol (col_lendiff);
+#else              
+                  _rl_clear_to_eol (lendiff);
+#endif
 	    }
 	}
     }
@@ -1231,17 +1432,53 @@
 	 data is underneath the cursor. */
 #if defined (HACK_TERMCAP_MOTION)
       if (_rl_term_forward_char)
-	for (i = _rl_last_c_pos; i < new; i++)
-	  tputs (_rl_term_forward_char, 1, _rl_output_character_function);
+# if deinfed (HANDLE_MULTIBYTE)
+        if(!rl_byte_oriented)
+          {
+            int width = _rl_col_width(data,_rl_last_c_pos,new);
+            for(i=0;i<width;i++)
+              tputs (_rl_term_forward_char, 1, _rl_output_character_function);
+          }
+        else
+# endif /* HANDLE_MULTIBYTE */     
+          for (i = _rl_last_c_pos; i < new; i++)
+            tputs (_rl_term_forward_char, 1, _rl_output_character_function);
       else
-	for (i = _rl_last_c_pos; i < new; i++)
-	  putc (data[i], rl_outstream);
+# if defined (HANDLE_MULTIBYTE)
+        if(!rl_byte_oriented)
+          {
+            tputs (_rl_term_cr, 1, _rl_output_character_function);
+            for (i = 0; i < new; i++)
+              putc (data[i], rl_outstream);
+          }
+        else
+# endif /* HANDLE_MULTIBYTE */
+          for (i = _rl_last_c_pos; i < new; i++)
+            putc (data[i], rl_outstream);
 #else
-      for (i = _rl_last_c_pos; i < new; i++)
-	putc (data[i], rl_outstream);
+# if defined (HANDLE_MULTIBYTE)
+      if(!rl_byte_oriented)
+        {
+          tputs (_rl_term_cr, 1, _rl_output_character_function);
+          for (i = 0; i < new; i++)
+            putc (data[i], rl_outstream);
+        }
+      else
+# endif /* HANDLE_MULTIBYTE */
+        for (i = _rl_last_c_pos; i < new; i++)
+          putc (data[i], rl_outstream);
 #endif /* HACK_TERMCAP_MOTION */
     }
   else if (_rl_last_c_pos > new)
+#if defined (HANDLE_MULTIBYTE)
+    if(!rl_byte_oriented)
+      {
+        tputs (_rl_term_cr, 1, _rl_output_character_function);
+        for (i = 0; i < new; i++)
+          putc (data[i], rl_outstream);
+      }
+    else
+#endif    
     _rl_backspace (_rl_last_c_pos - new);
   _rl_last_c_pos = new;
 }
@@ -1738,3 +1975,90 @@
 
   return ret;
 }
+#if defined(HANDLE_MULTIBYTE)
+/* This calculate a number of columns of specified string between
+   "start" and "end".  In case of that the string could be statefull
+   encoding, we have to scan from beginning of the string.*/
+static int
+_rl_col_width(str,start,end)
+     char *str;
+     int start,end;
+{
+  wchar_t wc;
+  mbstate_t ps = {0};
+  int tmp;
+  int point = 0;
+  int width, max;
+
+  if(end <= start)
+    return 0;
+
+  max = end;
+  
+  while(point < start)
+    {
+      tmp = mbrtowc(NULL, str+point,max,&ps);
+      if((size_t)(tmp) == -1 || (size_t)(tmp) == -2)
+        {
+          /* in this case, bytes are invalid or shorted to compose
+             multibyte char, so assume that the first byte represents
+             a single character anyway. */
+          point++;
+          max--;
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else if( tmp == 0)
+        /* found '\0' char */
+        break;
+      else
+        {
+          point += tmp;
+          max -= tmp;
+        }
+    }
+
+  /* if start is not pointed character started byte, then
+     the point will be larger than start.  In case of this,
+     assume that byte diff of point - start is columns */
+  width = point - start;
+
+  while(point < end)
+    {
+      tmp = mbrtowc(&wc, str+point,max,&ps);
+      if((size_t)(tmp) == -1 || (size_t)(tmp) == -2)
+        {
+          /* in this case, bytes are invalid or shorted to compose
+             multibyte char, so assume that the first byte represents
+             a single character anyway. */
+          point++;
+          max--;
+          /* and assume that the byte occupy a column.*/
+          width++; 
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else if( tmp == 0)
+        /* found '\0' char */
+        break;
+      else
+        {
+          point += tmp;
+          max -= tmp;
+          tmp = wcwidth(wc);
+          if( tmp < 0)
+            /* is this happen? but in case of this,
+               assume that this character occupy a single column */
+            width++;
+          else
+            width+=tmp;
+        }
+    }
+
+  width += (point - end);
+
+  return width;
+}
+#endif
diff -urN -x CVS bash-2.05/lib/readline/emacs_keymap.c bash205/lib/readline/emacs_keymap.c
--- bash-2.05/lib/readline/emacs_keymap.c	Tue Oct 31 02:01:50 2000
+++ bash205/lib/readline/emacs_keymap.c	Mon Apr 16 14:45:41 2001
@@ -26,6 +26,20 @@
 
 #include "readline.h"
 
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+#  include <limits.h>
+# endif
+#endif
+
 /* An array of function pointers, one for each possible key.
    If the type byte is ISKMAP, then the pointer is the address of
    a keymap. */
@@ -35,11 +49,19 @@
   /* Control keys. */
   { ISFUNC, rl_set_mark },			/* Control-@ */
   { ISFUNC, rl_beg_of_line },			/* Control-a */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_backward_char },                 /* Control-b */
+#else  
   { ISFUNC, rl_backward },			/* Control-b */
+#endif  
   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
   { ISFUNC, rl_delete },			/* Control-d */
   { ISFUNC, rl_end_of_line },			/* Control-e */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_forward_char },                  /* Control-f */
+#else
   { ISFUNC, rl_forward },			/* Control-f */
+#endif  
   { ISFUNC, rl_abort },				/* Control-g */
   { ISFUNC, rl_rubout },			/* Control-h */
   { ISFUNC, rl_complete },			/* Control-i */
diff -urN -x CVS bash-2.05/lib/readline/funmap.c bash205/lib/readline/funmap.c
--- bash-2.05/lib/readline/funmap.c	Thu Nov  9 02:38:13 2000
+++ bash205/lib/readline/funmap.c	Mon Apr 16 14:45:41 2001
@@ -25,6 +25,16 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+#  include <limits.h>
+# endif
+#endif
+
 #if !defined (BUFSIZ)
 #include <stdio.h>
 #endif /* BUFSIZ */
@@ -60,7 +70,12 @@
   { "abort", rl_abort },
   { "accept-line", rl_newline },
   { "arrow-key-prefix", rl_arrow_keys },
+#if defined(HANDLE_MULTIBYTE)
+  { "backward-byte", rl_backward },
+  { "backward-char", rl_backward_char },
+#else  
   { "backward-char", rl_backward },
+#endif  
   { "backward-delete-char", rl_rubout },
   { "backward-kill-line", rl_backward_kill_line },
   { "backward-kill-word", rl_backward_kill_word },
@@ -91,7 +106,12 @@
   { "end-of-line", rl_end_of_line },
   { "exchange-point-and-mark", rl_exchange_point_and_mark },
   { "forward-backward-delete-char", rl_rubout_or_delete },
+#if defined(HANDLE_MULTIBYTE)
+  { "forward-byte", rl_forward },
+  { "forward-char", rl_forward_char },
+#else  
   { "forward-char", rl_forward },
+#endif  
   { "forward-search-history", rl_forward_search_history },
   { "forward-word", rl_forward_word },
   { "history-search-backward", rl_history_search_backward },
diff -urN -x CVS bash-2.05/lib/readline/histexpand.c bash205/lib/readline/histexpand.c
--- bash-2.05/lib/readline/histexpand.c	Wed Mar  7 04:09:25 2001
+++ bash205/lib/readline/histexpand.c	Mon Apr 16 14:45:41 2001
@@ -26,6 +26,20 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE      1
+#  if MB_LEN_MAX < 16
+#   undef MB_LEN_MAX
+#   define MB_LEN_MAX 16
+#  endif
+extern int rl_byte_oriented;
+# endif
+#endif
+
 #include <stdio.h>
 
 #if defined (HAVE_STDLIB_H)
@@ -34,6 +48,10 @@
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
 #if defined (HAVE_UNISTD_H)
 #  ifndef _MINIX
 #    include <sys/types.h>
@@ -58,6 +76,7 @@
 
 typedef int _hist_search_func_t __P((const char *, int));
 
+
 static char error_pointer;
 
 static char *subst_lhs;
@@ -204,6 +223,21 @@
 
   /* Only a closing `?' or a newline delimit a substring search string. */
   for (local_index = i; c = string[i]; i++)
+#if defined (HANDLE_MULTIBYTE)
+    if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+      {
+	int v;
+        mbstate_t ps;
+        memset(&ps,0,sizeof(mbstate_t));
+        _rl_adjust_point(string,i,&ps);
+	if ((v = _rl_get_char_len (&string[i],&ps)) > 1)
+	  {
+	    i += v-1;
+	    continue;
+	  }
+      }
+    else
+#endif /* HANDLE_MULTIBYTE */
     if ((!substring_okay && (whitespace (c) || c == ':' ||
 	(history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
 	string[i] == delimiting_quote)) ||
@@ -406,10 +440,29 @@
 {
   register int si, i, j, k;
   char *s = (char *) NULL;
+#if defined (HANDLE_MULTIBYTE)
+  mbstate_t ps;
+#endif  
 
   i = *iptr;
 
+#if defined (HANDLE_MULTIBYTE)
+  memset(&ps,0,sizeof(mbstate_t));
+  _rl_adjust_point(str,i,&ps);
+#endif  
+  
   for (si = i; str[si] && str[si] != delimiter; si++)
+#if defined (HANDLE_MULTIBYTE)
+    if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+      {
+	int v;
+	if ((v = _rl_get_char_len (&str[si],&ps)) > 1)
+	  si += v-1;
+	else if (str[si] == '\\' && str[si + 1] == delimiter)
+	  si++;
+      }
+    else
+#endif /* HANDLE_MULTIBYTE */
     if (str[si] == '\\' && str[si + 1] == delimiter)
       si++;
 
@@ -484,6 +537,10 @@
   int substitute_globally, want_quotes, print_only;
   char *event, *temp, *result, *tstr, *t, c, *word_spec;
   int result_len;
+#if defined (HANDLE_MULTIBYTE)
+  mbstate_t ps;
+  memset(&ps,0,sizeof(mbstate_t));
+#endif  
 
   result = xmalloc (result_len = 128);
 
@@ -514,6 +571,15 @@
 	 quote, then this expansion takes place inside of the
 	 quoted string.  If we have to search for some text ("!foo"),
 	 allow the delimiter to end the search string. */
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+	  int c = string[_rl_find_previous_char_started_byte (string, i)];
+	  if (i - 1 && (c == '\'' || c == '"'))
+	    quoted_search_delimiter = c;
+        }
+      else
+#endif /* HANDLE_MULTIBYTE */
       if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
 	quoted_search_delimiter = string[i - 1];
       event = get_history_event (string, &i, quoted_search_delimiter);
@@ -634,6 +700,17 @@
 	    if (c == 's')
 	      {
 		if (i + 2 < (int)strlen (string))
+#if defined (HANDLE_MULTIBYTE)
+		  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+		    {
+                      _rl_adjust_point(&string,i+2,&ps);
+		      if (_rl_get_char_len (&string[i + 2],&ps) > 1)
+			delimiter = 0;
+		      else
+			delimiter = string[i + 2];
+		    }
+		  else
+#endif /* HANDLE_MULTIBYTE */
 		  delimiter = string[i + 2];
 		else
 		  break;	/* no search delimiter */
@@ -819,6 +896,10 @@
   int result_len;
   char *result;
 
+#if defined (HANDLE_MULTIBYTE)
+  char mb[MB_LEN_MAX];
+#endif /* HANDLE_MULTIBYTE */
+
   /* Used when adding the string. */
   char *temp;
 
@@ -861,6 +942,10 @@
     }
   else
     {
+#if defined (HANDLE_MULTIBYTE)
+      mbstate_t ps;
+      memset(&ps,0,sizeof(mbstate_t));
+#endif /* HANDLE_MULTIBYTE */
       string = hstring;
       /* If not quick substitution, still maybe have to do expansion. */
 
@@ -868,6 +953,17 @@
 	 is NOT an expansion. */
       for (i = 0; string[i]; i++)
 	{
+#if defined (HANDLE_MULTIBYTE)
+	  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	    {
+	      int v;
+	      if ((v = _rl_get_char_len (&string[i],&ps)) > 1)
+		{
+		  i += v-1;
+		  continue;
+		}
+	    }
+#endif /* HANDLE_MULTIBYTE */
 	  cc = string[i + 1];
 	  /* The history_comment_char, if set, appearing that the beginning
 	     of a word signifies that the rest of the line should not have
@@ -931,6 +1027,31 @@
 	  ADD_CHAR (tchar);
 	  continue;
 	}
+
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+	  int k, c;
+          mbstate_t ps;
+
+	  c = tchar;
+	  memset (mb, 0, sizeof (mb));
+	  for (k = 0; k < MB_LEN_MAX; k++)
+            {
+	      mb[k] = (char)c;
+              memset (&ps,0,sizeof(mbstate_t));
+	      if (_rl_get_char_len (mb,&ps) == -2)
+		  c = string[++i];
+	      else
+		break;
+            }
+	  if (strlen (mb) > 1)
+	    {
+	      ADD_STRING (mb);
+	      break;
+	    }
+        }
+#endif /* HANDLE_MULTIBYTE */
 
       if (tchar == history_expansion_char)
 	tchar = -3;
diff -urN -x CVS bash-2.05/lib/readline/isearch.c bash205/lib/readline/isearch.c
--- bash-2.05/lib/readline/isearch.c	Wed Feb 14 21:37:01 2001
+++ bash205/lib/readline/isearch.c	Tue Apr 17 10:49:50 2001
@@ -30,6 +30,19 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE      1
+#  if MB_LEN_MAX < 16
+#   undef MB_LEN_MAX
+#   define MB_LEN_MAX 16
+#  endif
+# endif
+#endif
+
 #include <sys/types.h>
 
 #include <stdio.h>
@@ -44,6 +57,10 @@
 #  include "ansi_stdlib.h"
 #endif
 
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
 #include "rldefs.h"
 #include "readline.h"
 #include "history.h"
@@ -163,6 +180,9 @@
   register int i;
   int orig_point, orig_line, last_found_line;
   int c, found, failed, sline_len;
+#if defined (HANDLE_MULTIBYTE)
+  char mb[MB_LEN_MAX];
+#endif /* HANDLE_MULTIBYTE */
 
   /* The line currently being searched. */
   char *sline;
@@ -241,6 +261,27 @@
       RL_SETSTATE(RL_STATE_MOREINPUT);
       c = rl_read_key ();
       RL_UNSETSTATE(RL_STATE_MOREINPUT);
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+        int j;
+          mbstate_t ps;
+          memset (mb, 0, sizeof (mb));
+        for (j = 0; j < MB_LEN_MAX; j++)
+            {
+            mb[j] = (char)c;
+              memset (&ps,0,sizeof(mbstate_t));
+            if (_rl_get_char_len (mb,&ps) == -2)
+              {
+                RL_SETSTATE(RL_STATE_MOREINPUT);
+                c = rl_read_key ();
+                RL_UNSETSTATE(RL_STATE_MOREINPUT);
+              }
+            else
+              break;
+            }
+        }
+#endif /* HANDLE_MULTIBYTE */
 
       if (_rl_keymap[c].type == ISFUNC)
 	{
@@ -276,6 +317,17 @@
 	  break;
 	}
 
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	{
+	  if (c >= 0 && strlen (mb)==1 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT) && c != CTRL ('G'))
+	    {
+	      rl_execute_next (c);
+	      break;
+	    }
+	}
+      else
+#endif /* HANDLE_MULTIBYTE */
       if (c >= 0 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT) && c != CTRL ('G'))
 	{
 	  /* This sets rl_pending_input to c; it will be picked up the next
@@ -337,6 +389,15 @@
 	      search_string_size += 128;
 	      search_string = xrealloc (search_string, search_string_size);
 	    }
+#if defined (HANDLE_MULTIBYTE)
+	  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	    {
+	      int j;
+	      for (j=0; j<strlen (mb); j++)
+		search_string[search_string_index++] = mb[j];
+	    }
+	  else 
+#endif /* HANDLE_MULTIBYTE */
 	  search_string[search_string_index++] = c;
 	  search_string[search_string_index] = '\0';
 	  break;
diff -urN -x CVS bash-2.05/lib/readline/readline.c bash205/lib/readline/readline.c
--- bash-2.05/lib/readline/readline.c	Tue Apr  3 04:56:20 2001
+++ bash205/lib/readline/readline.c	Mon Apr 16 14:45:41 2001
@@ -26,6 +26,22 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+#  include <limits.h>
+int rl_byte_oriented = 0;
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 #include <sys/types.h>
 #include "posixstat.h"
 #include <fcntl.h>
@@ -43,6 +59,10 @@
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
 #if defined (HAVE_LOCALE_H)
 #  include <locale.h>
 #endif
@@ -776,8 +796,21 @@
   if (!f || f == rl_do_lowercase_version)
     {
        _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
+#if defined(HANDLE_MULTIBYTE)
+       if(MB_CUR_MAX == 1 || rl_byte_oriented)
+         {
+           _rl_bind_if_unbound ("\033[0B", rl_backward);
+           _rl_bind_if_unbound ("\033[0C", rl_forward);
+         }
+       else
+         {
+           _rl_bind_if_unbound ("\033[0B", rl_backward_char);
+           _rl_bind_if_unbound ("\033[0C", rl_forward_char);
+         }
+#else       
        _rl_bind_if_unbound ("\033[0B", rl_backward);
        _rl_bind_if_unbound ("\033[0C", rl_forward);
+#endif       
        _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
     }
 #endif
@@ -787,8 +820,21 @@
     {
       _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
       _rl_bind_if_unbound ("\033[B", rl_get_next_history);
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX == 1 || rl_byte_oriented)
+        {
+          _rl_bind_if_unbound ("\033[C", rl_forward);
+          _rl_bind_if_unbound ("\033[D", rl_backward);
+        }
+      else
+        {
+          _rl_bind_if_unbound ("\033[C", rl_forward_char);
+          _rl_bind_if_unbound ("\033[D", rl_backward_char);
+        }
+#else      
       _rl_bind_if_unbound ("\033[C", rl_forward);
       _rl_bind_if_unbound ("\033[D", rl_backward);
+#endif
     }
 
   f = rl_function_of_keyseq ("\033OA", _rl_keymap, (int *)NULL);
@@ -796,8 +842,21 @@
     {
       _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
       _rl_bind_if_unbound ("\033OB", rl_get_next_history);
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX == 1 || rl_byte_oriented)
+        {
+          _rl_bind_if_unbound ("\033OC", rl_forward);
+          _rl_bind_if_unbound ("\033OD", rl_backward);
+        }
+      else
+        {
+          _rl_bind_if_unbound ("\033OC", rl_forward_char);
+          _rl_bind_if_unbound ("\033OD", rl_backward_char);
+        }
+#else      
       _rl_bind_if_unbound ("\033OC", rl_forward);
       _rl_bind_if_unbound ("\033OD", rl_backward);
+#endif      
     }
 }
 
@@ -1091,8 +1150,78 @@
    I.e., you will have to update the data base for rl_redisplay, and you
    might as well let rl_redisplay do that job. */
 
+#if defined(HANDLE_MULTIBYTE)
 /* Move forward COUNT characters. */
 int
+rl_forward_char (count, key)
+     int count, key;
+{
+  if (MB_CUR_MAX == 1 || rl_byte_oriented)
+    return rl_forward(count,key);
+  
+  if (count < 0)
+      rl_backward_char (-count, key);
+  else if (count > 0)
+    {
+      int point = _rl_find_next_char_started_byte(rl_point,count);
+
+#if defined (VI_MODE)
+      if(rl_end <= point && (rl_editing_mode == vi_mode))
+        point = _rl_find_previous_char_started_byte(the_line,rl_end);
+#endif
+
+      if(rl_point == point)
+        ding();
+      
+      rl_point = point;
+
+      if (rl_end < 0)
+        rl_end = 0;
+      
+    }
+  return 0;
+}
+
+/* Move backward COUNT characters. */
+int
+rl_backward_char (count, key)
+     int count, key;
+{
+  if (MB_CUR_MAX == 1 || rl_byte_oriented)
+    return rl_backward(count,key);
+
+  if (count < 0)
+    rl_forward_char (-count, key);
+  else if (count > 0)
+    {
+      if (rl_point < count)
+	{
+	  rl_point = 0;
+	  ding ();
+	}
+      else
+        {
+          int point = rl_point;
+          while(count > 0 && point > 0)
+            {
+              point = _rl_find_previous_char_started_byte(the_line,point);
+              count--;
+            }
+          if(0 < count)
+            {
+              rl_point = 0;
+              ding();
+            }
+          else
+            rl_point = point;
+        }
+    }
+  return 0;
+}
+#endif
+
+/* Move forward COUNT bytes. */
+int
 rl_forward (count, key)
      int count, key;
 {
@@ -1122,7 +1251,7 @@
   return 0;
 }
 
-/* Move backward COUNT characters. */
+/* Move backward COUNT bytes. */
 int
 rl_backward (count, key)
      int count, key;
@@ -1309,11 +1438,21 @@
       break;
 
     case 'C':
-      rl_forward (count, ch);
+#if defined(HANDLE_MULTIBYTE)
+      if(!rl_byte_oriented)
+        rl_forward_char (count, ch);
+      else
+#endif      
+        rl_forward (count, ch);
       break;
 
     case 'D':
-      rl_backward (count, ch);
+#if defined(HANDLE_MULTIBYTE)
+      if(!rl_byte_oriented)
+        rl_backward_char (count, ch);
+      else
+#endif
+        rl_backward (count, ch);
       break;
 
     default:
@@ -1329,6 +1468,19 @@
 /*								    */
 /* **************************************************************** */
 
+#ifdef HANDLE_MULTIBYTE
+# if defined(MB_LEN_MAX) && (MB_LEN_MAX < 16)
+#  undef MB_LEN_MAX
+#  define MB_LEN_MAX 16
+# elif !defined(MB_LEN_MAX)
+#  define MB_LEN_MAX 16
+# endif
+
+static char pending_bytes[MB_LEN_MAX];
+static int pending_bytes_length = 0;
+static mbstate_t ps = {0};
+#endif
+
 /* Insert the character C at the current location, moving point forward. */
 int
 rl_insert (count, c)
@@ -1336,29 +1488,131 @@
 {
   register int i;
   char *string;
-
+#ifdef HANDLE_MULTIBYTE
+  char incoming[MB_LEN_MAX + 1];
+  int incoming_length = 0;
+  mbstate_t ps_back;
+  static int stored_count = 0;
+#endif
+  
   if (count <= 0)
     return 0;
 
+#ifdef HANDLE_MULTIBYTE
+  if(MB_CUR_MAX == 1 || rl_byte_oriented)
+    {
+      incoming[0] = c;
+      incoming[1] = '\0';
+      incoming_length = 1;
+    }
+  else
+    {
+      wchar_t wc;
+      size_t ret;
+
+      if(stored_count <= 0)
+        stored_count = count;
+      else
+        count = stored_count;
+
+      ps_back = ps;
+      pending_bytes[pending_bytes_length++] = c;
+      ret = mbrtowc(&wc,pending_bytes,pending_bytes_length,&ps);
+
+      if( (size_t)(-2) == ret )
+        {
+          /* bytes are too short to compose character.
+             try to wait for a next byte */
+          /* restore the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          ps = ps_back;
+          return 1;
+        }
+      else if( (size_t)(-1) == ret )
+        {
+        /* invalid byte order for the current locale.
+           treat first byte as single character */
+          incoming[0] = pending_bytes[0];
+          incoming[1] = '\0';
+          incoming_length = 1;
+          pending_bytes_length--;
+          memmove(pending_bytes,pending_bytes+1,pending_bytes_length);
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else if ( (size_t)(0) == ret)
+        {
+          /* found '\0' character */
+          incoming[0] = '\0';
+          incoming_length = 0;
+          pending_bytes_length--;
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else
+        {
+          /* succeeded to compose multibyte char */
+          memcpy(incoming,pending_bytes,pending_bytes_length);
+          incoming[pending_bytes_length] = '\0';
+          incoming_length = pending_bytes_length;
+          pending_bytes_length = 0;
+        }
+        
+    }
+#endif /* HANDLE_MULTIBYTE */
   /* If we can optimize, then do it.  But don't let people crash
      readline because of extra large arguments. */
   if (count > 1 && count <= 1024)
     {
+#ifdef HANDLE_MULTIBYTE
+      string = xmalloc(1 + count*incoming_length);
+
+      i=0;
+      while(i < count*incoming_length)
+        {
+          strncpy(string+i,incoming,incoming_length);
+          i+=incoming_length;
+        }
+      incoming_length = 0;
+      stored_count = 0;
+#else      
       string = xmalloc (1 + count);
 
       for (i = 0; i < count; i++)
 	string[i] = c;
-
+#endif
       string[i] = '\0';
       rl_insert_text (string);
       free (string);
-
       return 0;
     }
 
   if (count > 1024)
     {
       int decreaser;
+#ifdef HANDLE_MULTIBYTE
+      string = xmalloc(1 + 1024*incoming_length);
+
+      i=0;
+      while(i < 1024*incoming_length)
+        {
+          strncpy(string+i,incoming,incoming_length);
+          i+=incoming_length;
+        }
+
+      while (count)
+	{
+	  decreaser = (count > 1024 ? 1024 : count);
+	  string[decreaser*incoming_length] = '\0';
+	  rl_insert_text (string);
+	  count -= decreaser;
+	}
+      free(string);
+      incoming_length = 0;
+      stored_count = 0;
+#else      
       char str[1024+1];
 
       for (i = 0; i < 1024; i++)
@@ -1371,25 +1625,37 @@
 	  rl_insert_text (str);
 	  count -= decreaser;
 	}
-
+#endif      
       return 0;
     }
 
-  /* We are inserting a single character.
-     If there is pending input, then make a string of all of the
-     pending characters that are bound to rl_insert, and insert
-     them all. */
-  if (_rl_any_typein ())
-    _rl_insert_typein (c);
+#ifdef HANDLE_MULTIBYTE
+  if(MB_CUR_MAX == 1 || rl_byte_oriented)
+    {
+#endif
+      /* We are inserting a single character.
+         If there is pending input, then make a string of all of the
+         pending characters that are bound to rl_insert, and insert
+         them all. */
+      if (_rl_any_typein ())
+        _rl_insert_typein (c);
+      else
+        {
+          /* Inserting a single character. */
+          char str[2];
+          
+          str[1] = '\0';
+          str[0] = c;
+          rl_insert_text (str);
+        }
+#ifdef HANDLE_MULTIBYTE      
+    }
   else
     {
-      /* Inserting a single character. */
-      char str[2];
-
-      str[1] = '\0';
-      str[0] = c;
-      rl_insert_text (str);
+      rl_insert_text(incoming);
+      stored_count = 0;
     }
+#endif  
   return 0;
 }
 
@@ -1482,13 +1748,35 @@
   if (count > 1 || rl_explicit_arg)
     {
       int orig_point = rl_point;
-      rl_backward (count, key);
+#if defined(HANDLE_MULTIBYTE)
+      if(!rl_byte_oriented)
+        rl_backward_char (count, key);
+      else
+#endif
+        rl_backward (count, key);
       rl_kill_text (orig_point, rl_point);
     }
   else
     {
-      int c = the_line[--rl_point];
-      rl_delete_text (rl_point, rl_point + 1);
+#if defined(HANDLE_MULTIBYTE)
+      int c;
+      if(MB_CUR_MAX == 1 || rl_byte_oriented)
+        {
+          c = the_line[--rl_point];
+#else
+          int c = the_line[--rl_point];
+#endif   
+          rl_delete_text (rl_point, rl_point + 1);
+#if defined(HANDLE_MULTIBYTE)
+        }
+      else
+        {
+          int orig_point = rl_point;
+          rl_point = _rl_find_previous_char_started_byte(the_line,rl_point);
+          c = the_line[rl_point];
+          rl_delete_text(rl_point,orig_point);
+        }
+#endif   
 
       if (rl_point == rl_end && isprint (c) && _rl_last_c_pos)
 	{
@@ -1518,13 +1806,25 @@
   if (count > 1 || rl_explicit_arg)
     {
       int orig_point = rl_point;
-      rl_forward (count, key);
+#if defined(HANDLE_MULTIBYTE)
+      if(!rl_byte_oriented)
+        rl_forward_char (count,key);
+      else
+#endif 
+        rl_forward (count, key);
       rl_kill_text (orig_point, rl_point);
       rl_point = orig_point;
       return 0;
     }
   else
-    return (rl_delete_text (rl_point, rl_point + 1));
+#if defined(HANDLE_MULTIBYTE)
+    if(!rl_byte_oriented)
+      return (rl_delete_text (rl_point,
+                              _rl_find_next_char_started_byte(rl_point,1)));
+    else
+#endif 
+      return (rl_delete_text (rl_point, rl_point + 1));
+
 }
 
 /* Delete the character under the cursor, unless the insertion
@@ -1751,7 +2051,14 @@
 rl_transpose_chars (count, key)
      int count, key;
 {
+#ifdef HANDLE_MULTIBYTE
+  char dummy[MB_LEN_MAX + 1];
+  int i;
+  int prev_point;
+  int char_length;
+#else  
   char dummy[2];
+#endif  
 
   if (!count)
     return 0;
@@ -1766,17 +2073,47 @@
 
   if (rl_point == rl_end)
     {
+#ifdef HANDLE_MULTIBYTE      
+      if(!rl_byte_oriented)
+        rl_point = _rl_find_previous_char_started_byte(the_line,rl_point);
+      else
+#endif        
       --rl_point;
       count = 1;
     }
+#ifdef HANDLE_MULTIBYTE      
+  if(!rl_byte_oriented)
+    {
+      prev_point = rl_point;
+      rl_point = _rl_find_previous_char_started_byte(the_line,rl_point);
+    }
+  else
+#endif        
   rl_point--;
 
+#ifdef HANDLE_MULTIBYTE
+  char_length = prev_point - rl_point;
+  for(i=0;i<char_length;i++)
+    {
+      dummy[i] = the_line[rl_point+i];
+    }
+  dummy[i] = '\0';
+#else  
   dummy[0] = the_line[rl_point];
   dummy[1] = '\0';
+#endif  
 
+#ifdef HANDLE_MULTIBYTE
+  rl_delete_text (rl_point, rl_point + char_length);
+#else  
   rl_delete_text (rl_point, rl_point + 1);
+#endif  
 
+#ifdef HANDLE_MULTIBYTE
+  rl_point = _rl_find_next_char_started_byte(rl_point,count);
+#else  
   rl_point += count;
+#endif  
   _rl_fix_point (0);
   rl_insert_text (dummy);
 
diff -urN -x CVS bash-2.05/lib/readline/readline.h bash205/lib/readline/readline.h
--- bash-2.05/lib/readline/readline.h	Thu Feb 15 06:27:54 2001
+++ bash205/lib/readline/readline.h	Mon Apr 16 14:45:41 2001
@@ -86,6 +86,8 @@
 extern int rl_refresh_line __P((int, int));
 extern int rl_clear_screen __P((int, int));
 extern int rl_arrow_keys __P((int, int));
+extern int rl_forward_char __P((int, int));
+extern int rl_backward_char __P((int, int));
 
 /* Bindable commands for inserting and deleting text. */
 extern int rl_insert __P((int, int));
diff -urN -x CVS bash-2.05/lib/readline/rlprivate.h bash205/lib/readline/rlprivate.h
--- bash-2.05/lib/readline/rlprivate.h	Wed Feb 14 21:43:14 2001
+++ bash205/lib/readline/rlprivate.h	Mon Apr 16 14:45:41 2001
@@ -55,6 +55,9 @@
 extern int rl_visible_prompt_length;
 extern int readline_echoing_p;
 extern int rl_key_sequence_length;
+#if defined (HANDLE_MULTIBYTE)
+extern int rl_byte_oriented;
+#endif /* HANDLE_MULTIBYTE */
 
 /* display.c */
 extern int rl_display_fixed;
@@ -88,6 +91,14 @@
 
 /* util.c */
 extern char *_rl_savestring __P((const char *));
+#if defined (HANDLE_MULTIBYTE)
+extern int _rl_find_next_char_started_byte __P((int, int));
+extern int _rl_find_previous_char_started_byte __P((char *, int));
+extern int _rl_adjust_point __P((char *, int, mbstate_t *));
+extern int _rl_get_char_len __P((char *,mbstate_t *));
+extern int _rl_compare_chars __P((char *,int,mbstate_t *,
+                                  char *,int,mbstate_t *));
+#endif
 
 /*************************************************************************
  *									 *
diff -urN -x CVS bash-2.05/lib/readline/search.c bash205/lib/readline/search.c
--- bash-2.05/lib/readline/search.c	Fri Nov  3 03:13:25 2000
+++ bash205/lib/readline/search.c	Tue Apr 17 10:49:50 2001
@@ -26,6 +26,19 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE      1
+#  if MB_LEN_MAX < 16
+#   undef MB_LEN_MAX
+#   define MB_LEN_MAX 16
+#  endif
+# endif
+#endif
+
 #include <sys/types.h>
 #include <stdio.h>
 
@@ -39,6 +52,10 @@
 #  include "ansi_stdlib.h"
 #endif
 
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
 #include "rldefs.h"
 #include "readline.h"
 #include "history.h"
@@ -177,6 +194,9 @@
 {
   int saved_point, c;
   char *p;
+#if defined (HANDLE_MULTIBYTE)
+  char mb[MB_LEN_MAX];
+#endif /* HANDLE_MULTIBYTE */
 
   rl_maybe_save_line ();
   saved_point = rl_point;
@@ -198,6 +218,28 @@
       RL_SETSTATE(RL_STATE_MOREINPUT);
       c = rl_read_key ();
       RL_UNSETSTATE(RL_STATE_MOREINPUT);
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+        int j;
+          mbstate_t ps;
+        memset (mb, 0, sizeof (mb));
+        for (j = 0; j < MB_LEN_MAX; j++)
+            {
+            mb[j] = (char)c;
+              memset (&ps,0,sizeof(mbstate_t));
+            if (_rl_get_char_len (mb,&ps) == -2)
+              {
+                /* Read again for multibyte character */
+                RL_SETSTATE(RL_STATE_MOREINPUT);
+                c = rl_read_key ();
+                RL_UNSETSTATE(RL_STATE_MOREINPUT);
+              }
+            else
+              break;
+            }
+        }
+#endif /* HANDLE_MULTIBYTE */
 
       if (c == 0)
 	break;
@@ -239,6 +281,12 @@
 	  SEARCH_RETURN;
 
 	default:
+#if defined (HANDLE_MULTIBYTE)
+	  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	      /* Use rl_insert_text() instead of rl_insert() */
+	      rl_insert_text (mb);
+	  else 
+#endif /* HANDLE_MULTIBYTE */
 	  rl_insert (1, c);
 	  break;
 	}
diff -urN -x CVS bash-2.05/lib/readline/util.c bash205/lib/readline/util.c
--- bash-2.05/lib/readline/util.c	Wed Feb 14 21:43:19 2001
+++ bash205/lib/readline/util.c	Mon Apr 16 14:45:41 2001
@@ -25,6 +25,21 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+#  include <limits.h>
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 #include <sys/types.h>
 #include <fcntl.h>
 #include "posixjmp.h"
@@ -232,6 +247,10 @@
      const char *string1, *string2;
 {
   register const char *scan;
+#if defined (HANDLE_MULTIBYTE)
+  mbstate_t ps;
+  memset(&ps,0,sizeof(mbstate_t));
+#endif /* HANDLE_MULTIBYTE */
 
   for (; *string1; string1++)
     {
@@ -240,6 +259,16 @@
 	  if (*string1 == *scan)
 	    return ((char *)string1);
 	}
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+          int i, v;
+
+          if ((v = _rl_get_char_len (string1,&ps)) > 1)
+            for (i = 1; i < v; i++)
+              string1++;
+        }
+#endif /* HANDLE_MULTIBYTE */
     }
   return ((char *)NULL);
 }
@@ -368,3 +397,177 @@
 {
   return (strcpy (xmalloc (1 + (int)strlen (s)), (s)));
 }
+
+#if defined(HANDLE_MULTIBYTE)
+int
+_rl_find_next_char_started_byte(int seed, int count)
+{
+  int tmp = 0;
+  mbstate_t ps;
+  int point = 0;
+
+  memset(&ps,0,sizeof(mbstate_t));
+  if (seed < 0)
+    seed = 0;
+  if (count <= 0)
+    return seed;
+
+  point = seed + _rl_adjust_point(rl_line_buffer,seed,&ps);
+  /* if this is true, means that seed was not pointed character
+     started byte.  So correct the point and consume count */
+  if(seed < point)
+    count --;
+  
+  while(0 < count && point < rl_end)
+    {
+      tmp =_rl_get_char_len (rl_line_buffer+point,&ps);
+      if(tmp < 0 )
+        point++;
+      else if( tmp == 0)
+        /* found '\0' char */
+        break;
+      else
+        point += tmp;
+      count--;
+    }
+
+  return point;
+}
+/* find previous character started byte point of the specified seed.
+   finded point will be "point <= seed */
+int
+_rl_find_previous_char_started_byte(string,seed)
+     char *string;
+     int seed;
+{
+  mbstate_t ps;
+  int prev = 0;
+  int point = 0;
+  int length = 0;
+  size_t tmp;
+
+  memset(&ps,0,sizeof(mbstate_t));
+  length = strlen(string) ;
+  
+  if(seed < 0)
+    return 0;
+  else if(length < seed)
+    return length;
+
+  while(point < seed)
+    {
+      prev = point;
+      tmp = mbrtowc(NULL, string+point,length-point,&ps);
+      if((size_t)(tmp) == -1 || (size_t)(tmp) == -2)
+        {
+          /* in this case, bytes are invalid or shorted to compose
+             multibyte char, so assume that the first byte represents
+             a single character anyway. */
+          tmp = 1;
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else if (tmp == 0)
+        /* found '\0' char.  Is this happen?*/
+        break;
+
+      point += tmp;
+    }
+  
+  return prev;
+}
+/* return the number of bytes parsed from the multibyte sequence starting
+   at src, if a non-L'\0' wide character was recognized. It returns 0, 
+   if a L'\0' wide character was recognized. It  returns (size_t)(-1), 
+   if an invalid multibyte sequence was encountered. It returns (size_t)(-2) 
+   if it couldn't parse a complete  multibyte character.  */
+int
+_rl_get_char_len (src,ps)
+     char *src;
+     mbstate_t *ps;
+{
+  size_t tmp;
+
+  tmp = mbrtowc (NULL, (const char*) src, (size_t) strlen(src), ps);
+  if(tmp == (size_t)(-2) )
+    {
+      /* shorted to compose multibyte char */
+      memset (ps, 0, sizeof(mbstate_t));
+      return -2;
+    }
+  else if (tmp == (size_t)(-1))
+    {
+      /* invalid to compose multibyte char */
+      /* initialize the conversion state */
+      memset (ps, 0, sizeof(mbstate_t));
+      return -1;
+    }
+  else if (tmp == (size_t)(0))
+    return 0;
+  else
+    return (int)tmp;
+}
+/* compare the specified two characters. If their two characters matched,
+   return 1. Otherwise return 0. */
+int
+_rl_compare_chars (buf1, pos1, ps1, buf2, pos2, ps2)
+     char *buf1, *buf2;
+     mbstate_t *ps1, *ps2;
+     int pos1, pos2;
+{
+  int i, w1, w2;
+
+  if ((w1 = _rl_get_char_len (&buf1[pos1],ps1)) <= 0 || 
+	(w2 = _rl_get_char_len (&buf2[pos2],ps2)) <= 0 ||
+	(w1 != w2) ||
+	(buf1[pos1] != buf2[pos2]))
+    return 0;
+
+  for (i = 1; i < w1; i++)
+    if (buf1[pos1+i] != buf2[pos2+i])
+      return 0;
+
+  return 1;
+}
+/* adjust pointed byte and find mbstate of the point of string.
+   adjusted point will be point <= adjusted_point, and returns
+   differences of the byte(adjusted_point - point).
+   if point is invalied (point < 0 || more than string length),
+   it returns -1 */
+int
+_rl_adjust_point(string, point, ps)
+     char *string;
+     int point;
+     mbstate_t *ps;
+{
+  size_t tmp = 0;
+  int length;
+  int pos = 0;
+
+  length = strlen(string);
+  if (point < 0)
+    return -1;
+  if (length < point)
+    return -1;
+  
+  while(pos < point)
+    {
+      tmp = mbrtowc(NULL, string+pos,length-pos,ps);
+      if((size_t)(tmp) == -1 || (size_t)(tmp) == -2)
+        {
+          /* in this case, bytes are invalid or shorted to compose
+             multibyte char, so assume that the first byte represents
+             a single character anyway. */
+          pos++;
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(ps,0,sizeof(mbstate_t));
+        }
+      else
+        pos += tmp;
+    }
+
+  return (pos - point);
+}
+#endif
diff -urN -x CVS bash-2.05/lib/readline/vi_keymap.c bash205/lib/readline/vi_keymap.c
--- bash-2.05/lib/readline/vi_keymap.c	Tue Oct 31 01:55:52 2000
+++ bash205/lib/readline/vi_keymap.c	Mon Apr 16 14:45:41 2001
@@ -26,6 +26,20 @@
 
 #include "readline.h"
 
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE
+#  include <limits.h>
+# endif
+#endif
+
 #if 0
 extern KEYMAP_ENTRY_ARRAY vi_escape_keymap;
 #endif
@@ -41,7 +55,11 @@
   { ISFUNC, rl_emacs_editing_mode },		/* Control-e */
   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
   { ISFUNC, rl_abort },				/* Control-g */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_backward_char },                 /* Control-h */
+#else
   { ISFUNC, rl_backward },			/* Control-h */
+#endif
   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
   { ISFUNC, rl_newline },			/* Control-j */
   { ISFUNC, rl_kill_line },			/* Control-k */
@@ -150,11 +168,19 @@
   { ISFUNC, rl_vi_end_word },			/* e */
   { ISFUNC, rl_vi_char_search },		/* f */
   { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_backward_char },                 /* h */
+#else  
   { ISFUNC, rl_backward },			/* h */
+#endif  
   { ISFUNC, rl_vi_insertion_mode },		/* i */
   { ISFUNC, rl_get_next_history },		/* j */
   { ISFUNC, rl_get_previous_history },		/* k */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_forward_char },                  /* l */
+#else  
   { ISFUNC, rl_forward },			/* l */
+#endif  
   { ISFUNC, rl_vi_set_mark },			/* m */
   { ISFUNC, rl_vi_search_again },		/* n */
   { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
diff -urN -x CVS bash-2.05/lib/readline/vi_mode.c bash205/lib/readline/vi_mode.c
--- bash-2.05/lib/readline/vi_mode.c	Thu Nov  9 01:47:02 2000
+++ bash205/lib/readline/vi_mode.c	Tue Apr 17 10:49:50 2001
@@ -35,6 +35,21 @@
 #  include <config.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+#  include <limits.h>
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 #include <sys/types.h>
 
 #if defined (HAVE_STDLIB_H)
@@ -43,6 +58,10 @@
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
 #if defined (HAVE_UNISTD_H)
 #  include <unistd.h>
 #endif
@@ -557,7 +576,21 @@
      int count, key;
 {
   if (rl_point < rl_end)
+#if defined(HANDLE_MULTIBYTE)
+    {
+      if(MB_CUR_MAX == 1 || rl_byte_oriented)
+        rl_point++;
+      else
+        {
+          int point = rl_point;
+          rl_forward_char(1,key);
+          if(point == rl_point)
+            rl_point = rl_end;
+        }
+    }
+#else      
     rl_point++;
+#endif  
   rl_vi_insertion_mode (1, key);
   return (0);
 }
@@ -650,7 +683,11 @@
      int count, key;
 {
   if (rl_point > 0)
+#if defined(HANDLE_MULTIBYTE)
+    rl_backward_char(1,key);
+#else    
     rl_backward (1, key);
+#endif  
 
   _rl_keymap = vi_movement_keymap;
   _rl_vi_done_inserting ();
@@ -677,6 +714,46 @@
   if (rl_point >= rl_end)
     return (0);
 
+#if defined (HANDLE_MULTIBYTE)
+  if (!rl_byte_oriented)
+    {
+      wchar_t wc;
+      char mb[MB_LEN_MAX];
+      mbstate_t ps;
+
+      memset(&ps,0,sizeof(mbstate_t));
+      if( _rl_adjust_point(rl_line_buffer,rl_point,&ps) > 0)
+        count--;
+      while (count-- && rl_point < rl_end)
+        {
+          mbrtowc(&wc,rl_line_buffer+rl_point,rl_end-rl_point,&ps);
+          if (iswupper(wc))
+            wc = towlower(wc);
+          else if (iswlower(wc))
+            wc = towupper(wc);
+          else
+            {
+              /* Just skip over characters neither upper nor lower case. */
+              rl_forward_char (1, c);
+              continue;
+            }
+          
+          /* Vi is kind of strange here. */
+          if (wc)
+            {
+              wctomb(mb,wc);
+              rl_begin_undo_group ();
+              rl_delete (1, c);
+              rl_insert_text (mb);
+              rl_end_undo_group ();
+              rl_vi_check ();
+            }
+          else
+            rl_forward_char (1, c);
+        }
+    }
+  else
+#endif  
   while (count-- && rl_point < rl_end)
     {
       if (_rl_uppercase_p (rl_line_buffer[rl_point]))
@@ -710,10 +787,18 @@
      int count, key;
 {
   if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))
+#if defined(HANDLE_MULTIBYTE)
+    rl_point = _rl_find_next_char_started_byte(rl_point,1);
+#else
     rl_point++;
+#endif    
 
   rl_yank (1, key);
+#if defined(HANDLE_MULTIBYTE)
+  rl_backward_char (1, key);
+#else  
   rl_backward (1, key);
+#endif  
   return (0);
 }
 
@@ -721,7 +806,12 @@
 rl_vi_check ()
 {
   if (rl_point && rl_point == rl_end)
-    rl_point--;
+#if defined(HANDLE_MULTIBYTE)
+    if(!rl_byte_oriented)
+      rl_point = _rl_find_previous_char_started_byte(rl_line_buffer,rl_point);
+    else
+#endif      
+      rl_point--;
   return (0);
 }
 
@@ -1000,8 +1090,13 @@
       rl_ding ();
       return -1;
     }
+#if defined(HANDLE_MULTIBYTE)
+  if(!rl_byte_oriented)
+    end = _rl_find_next_char_started_byte(rl_point,count);
+  else
+#endif
+    end = rl_point + count;
 
-  end = rl_point + count;
 
   if (end >= rl_end)
     end = rl_end;
@@ -1009,7 +1104,12 @@
   rl_kill_text (rl_point, end);
   
   if (rl_point > 0 && rl_point == rl_end)
-    rl_backward (1, key);
+#if defined(HANDLE_MULTIBYTE)
+    if(!rl_byte_oriented)
+      rl_backward_char (1, key);
+    else
+#endif    
+      rl_backward (1, key);
   return (0);
 }
 
@@ -1085,7 +1185,12 @@
     {
       while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
 	     rl_point < rl_end - 1)
-	rl_forward (1, key);
+#if defined(HANDLE_MULTIBYTE)
+        if(!rl_byte_oriented)
+          rl_forward_char (1, key);
+        else
+#endif          
+          rl_forward (1, key);
 
       if (brack <= 0)
 	{
@@ -1099,9 +1204,25 @@
 
   if (brack < 0)
     {
+#if defined(HANDLE_MULTIBYTE)
+      int tmp;
+#endif      
       while (count)
 	{
+#if defined(HANDLE_MULTIBYTE)
+          tmp = pos;
+          if(MB_CUR_MAX == 1 || rl_byte_oriented)
+            pos--;
+          else
+            {
+              pos = _rl_find_previous_char_started_byte(rl_line_buffer,pos);
+              if (tmp == pos) /* pos was already 0.*/
+                pos--; 
+            }
+          if ( pos >= 0 )
+#else          
 	  if (--pos >= 0)
+#endif              
 	    {
 	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
 	      if (b == -brack)
@@ -1120,7 +1241,15 @@
     {			/* brack > 0 */
       while (count)
 	{
+#if defined(HANDLE_MULTIBYTE)
+          if (MB_CUR_MAX == 1 || rl_byte_oriented)
+            pos++;
+          else
+            pos = _rl_find_next_char_started_byte(pos,1);
+          if ( pos < rl_end)
+#else          
 	  if (++pos < rl_end)
+#endif            
 	    {
 	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
 	      if (b == -brack)
@@ -1178,9 +1307,25 @@
       rl_begin_undo_group ();
 
       rl_delete (1, c);
-      rl_insert (1, c);
+#if defined(HANDLE_MULTIBYTE)
+      if(!rl_byte_oriented)
+        while(rl_insert(1,c))
+          {
+            RL_SETSTATE(RL_STATE_MOREINPUT);
+            c = rl_read_key();
+            RL_UNSETSTATE(RL_STATE_MOREINPUT);
+          }
+      else
+#else      
+        rl_insert (1, c);
+#endif      
       if (count == 0)
-	rl_backward (1, c);
+#if defined(HANDLE_MULTIBYTE)
+        if(!rl_byte_oriented)
+          rl_backward_char(1,c);
+        else
+#endif        
+          rl_backward (1, c);
 
       rl_end_undo_group ();
     }
@@ -1273,7 +1418,12 @@
 	vi_replace_count--;
 
       if (rl_point == s)
-	rl_backward (1, key);
+#if defined(HANDLE_MULTIBYTE)
+        if(!rl_byte_oriented)
+          rl_backward_char (1,key);
+        else
+#endif          
+          rl_backward (1, key);
     }
 
   if (vi_replace_count == 0 && _rl_vi_doing_insert)
@@ -1396,5 +1546,4 @@
   rl_point = vi_mark_chars[ch];
   return 0;
 }
-
 #endif /* VI_MODE */
