--- linux-2.4.22/fs/jbd/transaction.c.as11.orig	2003-08-28 02:43:35.000000000 +0200
+++ linux-2.4.22/fs/jbd/transaction.c	2003-08-28 02:43:38.000000000 +0200
@@ -56,7 +56,11 @@ static transaction_t * get_transaction (
 	transaction->t_journal = journal;
 	transaction->t_state = T_RUNNING;
 	transaction->t_tid = journal->j_transaction_sequence++;
-	transaction->t_expires = jiffies + journal->j_commit_interval;
+	/*
+	 * have to do it here, otherwise changed age_buffers since boot
+	 * wont have any effect
+	 */
+	transaction->t_expires = jiffies + get_buffer_flushtime();
 	INIT_LIST_HEAD(&transaction->t_jcb);
 
 	/* Set up the commit timer for the new transaction. */
--- linux-2.4.22/fs/buffer.c.as11.orig	2003-08-28 02:43:38.000000000 +0200
+++ linux-2.4.22/fs/buffer.c	2003-08-28 02:43:38.000000000 +0200
@@ -90,6 +90,13 @@ static int grow_buffers(kdev_t dev, unsi
 static int osync_buffers_list(struct list_head *);
 static void __refile_buffer(struct buffer_head *);
 
+/*
+ * A global sysctl-controlled flag which puts the machine into "laptop mode"
+ */
+int laptop_mode;
+
+static DECLARE_WAIT_QUEUE_HEAD(kupdate_wait);
+
 /* This is used by some architectures to estimate available memory. */
 atomic_t buffermem_pages = ATOMIC_INIT(0);
 
@@ -1026,7 +1033,7 @@ static int bdflush_stop(void)
 	dirty *= 100;
 	dirty_limit = tot * bdf_prm.b_un.nfract_stop_bdflush;
 
-	if (dirty > dirty_limit)
+	if ((!laptop_mode || suspend_task) && dirty > dirty_limit)
 		return 0;
 	return 1;
 }
@@ -1077,6 +1084,8 @@ void __mark_buffer_dirty(struct buffer_h
 void mark_buffer_dirty(struct buffer_head *bh)
 {
 	if (!atomic_set_buffer_dirty(bh)) {
+		if (block_dump)
+			printk("%s: dirtied buffer\n", current->comm);
 		__mark_dirty(bh);
 		balance_dirty();
 	}
@@ -1088,6 +1097,13 @@ void set_buffer_flushtime(struct buffer_
 }
 EXPORT_SYMBOL(set_buffer_flushtime);
 
+unsigned long get_buffer_flushtime(void)
+{
+	return bdf_prm.b_un.age_buffer;
+}
+EXPORT_SYMBOL(get_buffer_flushtime);
+
+
 /*
  * A buffer may need to be moved from one buffer list to another
  * (e.g. in case it is not shared any more). Handle this.
@@ -2897,6 +2913,12 @@ void wakeup_bdflush(void)
 	wake_up_interruptible(&bdflush_wait);
 }
 
+void wakeup_kupdate(void)
+{
+	if (waitqueue_active(&kupdate_wait))
+		wake_up(&kupdate_wait);
+}
+
 /* 
  * Here we attempt to write back old buffers.  We also try to flush inodes 
  * and supers as well, since this function is essentially "update", and 
@@ -2917,7 +2939,9 @@ static int sync_old_buffers(void)
 
 		spin_lock(&lru_list_lock);
 		bh = lru_list[BUF_DIRTY];
-		if (!bh || time_before(jiffies, bh->b_flushtime))
+		if (!bh)
+			break;
+		if (time_before(jiffies, bh->b_flushtime) && (!laptop_mode || suspend_task))
 			break;
 		if (current->flags & PF_FREEZE)
 			break;
@@ -3071,6 +3095,10 @@ int kupdate(void *startup)
 	complete((struct completion *)startup);
 
 	for (;;) {
+		DECLARE_WAITQUEUE(wait, tsk);
+
+		add_wait_queue(&kupdate_wait, &wait);
+
 		/* update interval */
 		interval = bdf_prm.b_un.interval;
 		if (unlikely(current->flags & PF_FREEZE))
@@ -3083,6 +3111,7 @@ int kupdate(void *startup)
 			tsk->state = TASK_STOPPED;
 			schedule(); /* wait for SIGCONT */
 		}
+		remove_wait_queue(&kupdate_wait, &wait);
 		/* check for sigstop */
 		if (signal_pending(tsk)) {
 			int stopped = 0;
@@ -3100,6 +3129,8 @@ int kupdate(void *startup)
 		printk(KERN_DEBUG "kupdate() activated...\n");
 #endif
 		sync_old_buffers();
+		if ((laptop_mode) && (!suspend_task))
+			fsync_dev(NODEV);
 		run_task_queue(&tq_disk);
 	}
 }
--- linux-2.4.22/kernel/sysctl.c.as11.orig	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/kernel/sysctl.c	2003-08-28 02:43:38.000000000 +0200
@@ -51,6 +51,8 @@ extern int sysrq_enabled;
 extern int core_uses_pid;
 extern char core_pattern[];
 extern int cad_pid;
+extern int laptop_mode;
+extern int block_dump;
 
 /* this is needed for the proc_dointvec_minmax for [fs_]overflow UID and GID */
 static int maxolduid = 65535;
@@ -290,6 +292,10 @@ static ctl_table vm_table[] = {
 	&vm_max_readahead,sizeof(int), 0644, NULL, &proc_dointvec},
 	{VM_MAX_MAP_COUNT, "max_map_count",
 	 &max_map_count, sizeof(int), 0644, NULL, &proc_dointvec},
+	{VM_LAPTOP_MODE, "laptop_mode",
+	 &laptop_mode, sizeof(int), 0644, NULL, &proc_dointvec},
+	{VM_BLOCK_DUMP, "block_dump",
+	 &block_dump, sizeof(int), 0644, NULL, &proc_dointvec},
 	{0}
 };
 
--- linux-2.4.22/mm/filemap.c.as11.orig	2003-08-28 02:43:38.000000000 +0200
+++ linux-2.4.22/mm/filemap.c	2003-08-28 02:43:38.000000000 +0200
@@ -169,6 +169,8 @@ void set_page_dirty(struct page *page)
 
 			if (mapping && mapping->host)
 				mark_inode_dirty_pages(mapping->host);
+			if (block_dump)
+				printk("%s: dirtied page\n", current->comm);
 		}
 	}
 }
--- linux-2.4.22/include/linux/fs.h.as11.orig	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/linux/fs.h	2003-08-28 02:43:38.000000000 +0200
@@ -1255,6 +1255,7 @@ static inline void mark_buffer_dirty_ino
 }
 
 extern void set_buffer_flushtime(struct buffer_head *);
+extern unsigned long get_buffer_flushtime(void);
 extern void balance_dirty(void);
 extern int check_disk_change(kdev_t);
 extern int invalidate_inodes(struct super_block *);
@@ -1445,8 +1446,10 @@ static inline struct buffer_head * sb_ge
 	return get_hash_table(sb->s_dev, block, sb->s_blocksize);
 }
 extern void wakeup_bdflush(void);
+extern void wakeup_kupdate(void);
 extern void put_unused_buffer_head(struct buffer_head * bh);
 extern struct buffer_head * get_unused_buffer_head(int async);
+extern int block_dump;
 
 extern int brw_page(int, struct page *, kdev_t, int [], int);
 
--- linux-2.4.22/include/linux/sysctl.h.as11.orig	2003-08-28 02:43:38.000000000 +0200
+++ linux-2.4.22/include/linux/sysctl.h	2003-08-28 03:02:11.000000000 +0200
@@ -147,6 +147,8 @@ enum
 	VM_MAX_MAP_COUNT=11,	/* int: Maximum number of active map areas */
 	VM_MIN_READAHEAD=12,    /* Min file readahead */
 	VM_MAX_READAHEAD=13,    /* Max file readahead */
+	VM_LAPTOP_MODE=14,	/* vm laptop mode */
+	VM_BLOCK_DUMP=15,	/* dump data read/write and dirtying */
 	VM_PAGEBUF=17,		/* struct: Control pagebuf parameters */
 };
 
--- linux-2.4.22/drivers/block/ll_rw_blk.c.as11.orig	2003-08-28 02:43:37.000000000 +0200
+++ linux-2.4.22/drivers/block/ll_rw_blk.c	2003-08-28 02:43:38.000000000 +0200
@@ -122,6 +122,10 @@ int * max_sectors[MAX_BLKDEV];
 unsigned long blk_max_low_pfn, blk_max_pfn;
 int blk_nohighio = 0;
 
+int block_dump = 0;
+
+static struct timer_list writeback_timer;
+
 static inline int get_max_sectors(kdev_t dev)
 {
 	if (!max_sectors[MAJOR(dev)])
@@ -1310,6 +1314,9 @@ void submit_bh(int rw, struct buffer_hea
 			kstat.pgpgin += count;
 			break;
 	}
+
+	if (block_dump)
+		printk("%s: %s block %lu/%u on %s\n", current->comm, rw == WRITE ? "WRITE" : "READ", bh->b_rsector, count, kdevname(bh->b_rdev));
 }
 
 /**
@@ -1421,6 +1428,11 @@ sorry:
 extern int stram_device_init (void);
 #endif
 
+static void blk_writeback_timer(unsigned long data)
+{
+	wakeup_bdflush();
+	wakeup_kupdate();
+}
 
 /**
  * end_that_request_first - end I/O on one buffer.
@@ -1477,10 +1489,18 @@ int end_that_request_first (struct reque
 	return 0;
 }
 
+extern int laptop_mode;
+
 void end_that_request_last(struct request *req)
 {
 	struct completion *waiting = req->waiting;
 
+	/*
+	 * schedule the writeout of pending dirty data when the disk is idle
+	 */
+	if (laptop_mode && req->cmd == READ)
+		mod_timer(&writeback_timer, jiffies + 5 * HZ);
+
 	req_finished_io(req);
 	blkdev_release_request(req);
 	if (waiting)
@@ -1508,6 +1528,9 @@ int __init blk_dev_init(void)
 	blk_max_low_pfn = max_low_pfn - 1;
 	blk_max_pfn = max_pfn - 1;
 
+	init_timer(&writeback_timer);
+	writeback_timer.function = blk_writeback_timer;
+
 #ifdef CONFIG_AMIGA_Z2RAM
 	z2_init();
 #endif
