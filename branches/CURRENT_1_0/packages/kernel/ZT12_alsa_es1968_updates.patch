diff -Nurp -X /Data/dontdiff -X /Data/dontdiff2 patched/sound/pci/es1968.c patched/sound.cvs/pci/es1968.c
--- patched/sound/pci/es1968.c	2003-07-17 18:21:53.000000000 +0300
+++ patched/sound.cvs/pci/es1968.c	2003-08-14 14:05:38.000000000 +0300
@@ -439,7 +439,8 @@ MODULE_PARM_SYNTAX(use_pm, SNDRV_ENABLED
 
 
 /* capture mixing buffer size */
-#define ESM_MIXBUF_SIZE		512
+#define ESM_MEM_ALIGN		0x1000
+#define ESM_MIXBUF_SIZE		0x400
 
 #define ESM_MODE_PLAY		0
 #define ESM_MODE_CAPTURE	1
@@ -583,9 +584,8 @@ struct snd_es1968 {
 
 	/* Maestro Stuff */
 	u16 maestro_map[32];
-	atomic_t bobclient;	/* active timer instancs */
+	int bobclient;		/* active timer instancs */
 	int bob_freq;		/* timer frequency */
-	spinlock_t bob_lock;
 	struct semaphore memory_mutex;	/* memory lock */
 
 	/* APU states */
@@ -884,13 +884,11 @@ static void snd_es1968_bob_start(es1968_
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
+/* call with substream spinlock */
 static void snd_es1968_bob_inc(es1968_t *chip, int freq)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&chip->bob_lock, flags);
-	atomic_inc(&chip->bobclient);
-	if (atomic_read(&chip->bobclient) == 1) {
+	chip->bobclient++;
+	if (chip->bobclient == 1) {
 		chip->bob_freq = freq;
 		snd_es1968_bob_start(chip);
 	} else if (chip->bob_freq < freq) {
@@ -898,35 +896,29 @@ static void snd_es1968_bob_inc(es1968_t 
 		chip->bob_freq = freq;
 		snd_es1968_bob_start(chip);
 	}
-	spin_unlock_irqrestore(&chip->bob_lock, flags);
 }
 
+/* call with substream spinlock */
 static void snd_es1968_bob_dec(es1968_t *chip)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&chip->bob_lock, flags);
-	atomic_dec(&chip->bobclient);
-	if (atomic_read(&chip->bobclient) <= 0)
+	chip->bobclient--;
+	if (chip->bobclient <= 0)
 		snd_es1968_bob_stop(chip);
 	else if (chip->bob_freq > ESM_BOB_FREQ) {
 		/* check reduction of timer frequency */
 		struct list_head *p;
 		int max_freq = ESM_BOB_FREQ;
-		spin_lock(&chip->substream_lock);
 		list_for_each(p, &chip->substream_list) {
 			esschan_t *es = list_entry(p, esschan_t, list);
 			if (max_freq < es->bob_freq)
 				max_freq = es->bob_freq;
 		}
-		spin_unlock(&chip->substream_lock);
 		if (max_freq != chip->bob_freq) {
 			snd_es1968_bob_stop(chip);
 			chip->bob_freq = max_freq;
 			snd_es1968_bob_start(chip);
 		}
 	}
-	spin_unlock_irqrestore(&chip->bob_lock, flags);
 }
 
 static int
@@ -986,19 +978,15 @@ static void snd_es1968_apu_set_freq(es19
 /* spin lock held */
 inline static void snd_es1968_trigger_apu(es1968_t *esm, int apu, int mode)
 {
-	/* dma on, no envelopes, filter to all 1s) */
-	__apu_set_register(esm, apu, 0, 0x400f | mode);
+	/* set the APU mode */
+	__apu_set_register(esm, apu, 0,
+			   (__apu_get_register(esm, apu, 0) & 0xff0f) |
+			   (mode << 4));
 }
 
 static void snd_es1968_pcm_start(es1968_t *chip, esschan_t *es)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&chip->reg_lock, flags);
-	if (es->running) {
-		spin_unlock_irqrestore(&chip->reg_lock, flags);
-		return;
-	}
+	spin_lock(&chip->reg_lock);
 	__apu_set_register(chip, es->apu[0], 5, es->base[0]);
 	snd_es1968_trigger_apu(chip, es->apu[0], es->apu_mode[0]);
 	if (es->mode == ESM_MODE_CAPTURE) {
@@ -1013,27 +1001,19 @@ static void snd_es1968_pcm_start(es1968_
 			snd_es1968_trigger_apu(chip, es->apu[3], es->apu_mode[3]);
 		}
 	}
-	es->running = 1;
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	spin_unlock(&chip->reg_lock);
 }
 
 static void snd_es1968_pcm_stop(es1968_t *chip, esschan_t *es)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&chip->reg_lock, flags);
-	if (! es->running) {
-		spin_unlock_irqrestore(&chip->reg_lock, flags);
-		return;
-	}
+	spin_lock(&chip->reg_lock);
 	snd_es1968_trigger_apu(chip, es->apu[0], 0);
 	snd_es1968_trigger_apu(chip, es->apu[1], 0);
 	if (es->mode == ESM_MODE_CAPTURE) {
 		snd_es1968_trigger_apu(chip, es->apu[2], 0);
 		snd_es1968_trigger_apu(chip, es->apu[3], 0);
 	}
-	es->running = 0;
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	spin_unlock(&chip->reg_lock);
 }
 
 /* set the wavecache control reg */
@@ -1115,12 +1095,12 @@ static void snd_es1968_playback_setup(es
 		/* clear routing stuff */
 		apu_set_register(chip, apu, 11, 0x0000);
 		/* dma on, no envelopes, filter to all 1s) */
-		// apu_set_register(chip, apu, 0, 0x400F);
+		apu_set_register(chip, apu, 0, 0x400F);
 
 		if (es->fmt & ESS_FMT_16BIT)
-			es->apu_mode[channel] = 0x10;	/* 16bit mono */
+			es->apu_mode[channel] = ESM_APU_16BITLINEAR;
 		else
-			es->apu_mode[channel] = 0x30;	/* 8bit mono */
+			es->apu_mode[channel] = ESM_APU_8BITLINEAR;
 
 		if (es->fmt & ESS_FMT_STEREO) {
 			/* set panning: left or right */
@@ -1130,7 +1110,7 @@ static void snd_es1968_playback_setup(es
 			   and not the APU Regs 4-5. */
 			apu_set_register(chip, apu, 10,
 					 0x8F00 | (channel ? 0 : 0x10));
-			es->apu_mode[channel] += 0x10;	/* stereo */
+			es->apu_mode[channel] += 1;	/* stereo */
 		} else
 			apu_set_register(chip, apu, 10, 0x8F08);
 	}
@@ -1160,119 +1140,91 @@ static void snd_es1968_playback_setup(es
 	snd_es1968_apu_set_freq(chip, es->apu[1], freq);
 }
 
+
+static void init_capture_apu(es1968_t *chip, esschan_t *es, int channel,
+			     unsigned int pa, unsigned int bsize,
+			     int mode, int route)
+{
+	int i, apu = es->apu[channel];
+
+	es->apu_mode[channel] = mode;
+
+	/* set the wavecache control reg */
+	snd_es1968_program_wavecache(chip, es, channel, pa, 1);
+
+	/* Offset to PCMBAR */
+	pa -= chip->dma.addr;
+	pa >>= 1;	/* words */
+
+	/* base offset of dma calcs when reading the pointer
+	   on this left one */
+	es->base[channel] = pa & 0xFFFF;
+	pa |= 0x00400000;	/* bit 22 -> System RAM */
+
+	/* Begin loading the APU */
+	for (i = 0; i < 16; i++)
+		apu_set_register(chip, apu, i, 0x0000);
+
+	/* need to enable subgroups.. and we should probably
+	   have different groups for different /dev/dsps..  */
+	apu_set_register(chip, apu, 2, 0x8);
+
+	/* Load the buffer into the wave engine */
+	apu_set_register(chip, apu, 4, ((pa >> 16) & 0xFF) << 8);
+	apu_set_register(chip, apu, 5, pa & 0xFFFF);
+	apu_set_register(chip, apu, 6, (pa + bsize) & 0xFFFF);
+	apu_set_register(chip, apu, 7, bsize);
+	/* clear effects/env.. */
+	apu_set_register(chip, apu, 8, 0x00F0);
+	/* amplitude now?  sure.  why not.  */
+	apu_set_register(chip, apu, 9, 0x0000);
+	/* set filter tune, radius, polar pan */
+	apu_set_register(chip, apu, 10, 0x8F08);
+	/* route input */
+	apu_set_register(chip, apu, 11, route);
+	/* dma on, no envelopes, filter to all 1s) */
+	apu_set_register(chip, apu, 0, 0x400F);
+}
+
 static void snd_es1968_capture_setup(es1968_t *chip, esschan_t *es,
 				     snd_pcm_runtime_t *runtime)
 {
-	int apu_step = 2;
-	int channel, apu;
-	int i, size;
+	int size;
 	u32 freq;
 	unsigned long flags;
 
 	size = es->dma_size >> es->wav_shift;
 
-	/* we're given the full size of the buffer, but
-	   in stereo each channel will only use its half */
-	if (es->fmt & ESS_FMT_STEREO)
-		apu_step = 1;
-
 	/* APU assignments:
 	   0 = mono/left SRC
 	   1 = right SRC
 	   2 = mono/left Input Mixer
-	   3 = right Input Mixer */
-	for (channel = 0; channel < 4; channel += apu_step) {
-		int bsize, route;
-		u32 pa;
-
-		apu = es->apu[channel];
-
-		/* data seems to flow from the codec, through an apu into
-		   the 'mixbuf' bit of page, then through the SRC apu
-		   and out to the real 'buffer'.  ok.  sure.  */
-
-		if (channel & 2) {
-			/* ok, we're an input mixer going from adc
-			   through the mixbuf to the other apus */
-
-			if (!(channel & 0x01)) {
-				pa = es->mixbuf->addr;
-			} else {
-				pa = es->mixbuf->addr + ESM_MIXBUF_SIZE / 2;
-			}
-
-			/* we source from a 'magic' apu */
-			bsize = ESM_MIXBUF_SIZE / 4; /* half of this channels alloc, in words */
-			/* parallel in crap, see maestro reg 0xC [8-11] */
-			route = 0x14 + channel - 2;
-			es->apu_mode[channel] = 0x90;	/* Input Mixer */
-		} else {
-			/* we're a rate converter taking
-			   input from the input apus and outputing it to
-			   system memory */
-			if (!(channel & 0x01))
-				pa = es->memory->addr;
-			else
-				pa = es->memory->addr + size * 2; /* size is in word */
-
-			es->apu_mode[channel] = 0xB0;	/* Sample Rate Converter */
-
-			bsize = size;
-			/* get input from inputing apu */
-			route = es->apu[channel + 2];
-		}
-
-		/* set the wavecache control reg */
-		snd_es1968_program_wavecache(chip, es, channel, pa, 1);
-
-		/* Offset to PCMBAR */
-		pa -= chip->dma.addr;
-		pa >>= 1;	/* words */
-
-		/* base offset of dma calcs when reading the pointer
-		   on this left one */
-		es->base[channel] = pa & 0xFFFF;
-
-		pa |= 0x00400000;	/* bit 22 -> System RAM */
-                
-                /* Begin loading the APU */
-		for (i = 0; i < 16; i++)
-			apu_set_register(chip, apu, i, 0x0000);
-
-		/* need to enable subgroups.. and we should probably
-		   have different groups for different /dev/dsps..  */
-		apu_set_register(chip, apu, 2, 0x8);
-
-		/* Load the buffer into the wave engine */
-		apu_set_register(chip, apu, 4, ((pa >> 16) & 0xFF) << 8);
-		/* XXX reg is little endian.. */
-		apu_set_register(chip, apu, 5, pa & 0xFFFF);
-		apu_set_register(chip, apu, 6, (pa + bsize) & 0xFFFF);
-		apu_set_register(chip, apu, 7, bsize);
-#if 0
-		if (es->fmt & ESS_FMT_STEREO) /* ??? really ??? */
-			apu_set_register(chip, apu, 7, bsize - 1);
-#endif
-
-		/* clear effects/env.. */
-		apu_set_register(chip, apu, 8, 0x00F0);
-		/* amplitude now?  sure.  why not.  */
-		apu_set_register(chip, apu, 9, 0x0000);
-		/* set filter tune, radius, polar pan */
-		apu_set_register(chip, apu, 10, 0x8F08);
-		/* route input */
-		apu_set_register(chip, apu, 11, route);
-		/* dma on, no envelopes, filter to all 1s) */
-		// apu_set_register(chip, apu, 0, 0x400F);
+	   3 = right Input Mixer
+	*/
+	/* data seems to flow from the codec, through an apu into
+	   the 'mixbuf' bit of page, then through the SRC apu
+	   and out to the real 'buffer'.  ok.  sure.  */
+
+	/* input mixer (left/mono) */
+	/* parallel in crap, see maestro reg 0xC [8-11] */
+	init_capture_apu(chip, es, 2,
+			 es->mixbuf->addr, ESM_MIXBUF_SIZE/4, /* in words */
+			 ESM_APU_INPUTMIXER, 0x14);
+	/* SRC (left/mono); get input from inputing apu */
+	init_capture_apu(chip, es, 0, es->memory->addr, size,
+			 ESM_APU_SRCONVERTOR, es->apu[2]);
+	if (es->fmt & ESS_FMT_STEREO) {
+		/* input mixer (right) */
+		init_capture_apu(chip, es, 3,
+				 es->mixbuf->addr + ESM_MIXBUF_SIZE/2,
+				 ESM_MIXBUF_SIZE/4, /* in words */
+				 ESM_APU_INPUTMIXER, 0x15);
+		/* SRC (right) */
+		init_capture_apu(chip, es, 1,
+				 es->memory->addr + size*2, size,
+				 ESM_APU_SRCONVERTOR, es->apu[3]);
 	}
 
-	spin_lock_irqsave(&chip->reg_lock, flags);
-	/* clear WP interrupts */
-	outw(1, chip->io_port + 0x04);
-	/* enable WP ints */
-	outw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
-
 	freq = runtime->rate;
 	/* Sample Rate conversion APUs don't like 0x10000 for their rate */
 	if (freq > 47999)
@@ -1290,6 +1242,13 @@ static void snd_es1968_capture_setup(es1
 	freq = 0x10000;
 	snd_es1968_apu_set_freq(chip, es->apu[2], freq);
 	snd_es1968_apu_set_freq(chip, es->apu[3], freq);
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	/* clear WP interrupts */
+	outw(1, chip->io_port + 0x04);
+	/* enable WP ints */
+	outw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
 /*******************
@@ -1334,30 +1293,28 @@ static int snd_es1968_pcm_trigger(snd_pc
 	esschan_t *es = snd_magic_cast(esschan_t, substream->runtime->private_data, return -ENXIO);
 	unsigned long flags;
 
+	spin_lock_irqsave(&chip->substream_lock, flags);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 		if (es->running)
-			return 0;
+			break;
 		snd_es1968_bob_inc(chip, es->bob_freq);
 		es->count = 0;
 		es->hwptr = 0;
 		snd_es1968_pcm_start(chip, es);
-		spin_lock_irqsave(&chip->substream_lock, flags);
-		list_add(&es->list, &chip->substream_list);
-		spin_unlock_irqrestore(&chip->substream_lock, flags);
+		es->running = 1;
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 		if (! es->running)
-			return 0;
+			break;
 		snd_es1968_pcm_stop(chip, es);
-		spin_lock_irqsave(&chip->substream_lock, flags);
-		list_del(&es->list);
-		spin_unlock_irqrestore(&chip->substream_lock, flags);
+		es->running = 0;
 		snd_es1968_bob_dec(chip);
 		break;
 	}
+	spin_unlock_irqrestore(&chip->substream_lock, flags);
 	return 0;
 }
 
@@ -1444,6 +1401,7 @@ static esm_memory_t *snd_es1968_new_memo
 	esm_memory_t *buf;
 	struct list_head *p;
 	
+	size = ((size + ESM_MEM_ALIGN - 1) / ESM_MEM_ALIGN) * ESM_MEM_ALIGN;
 	down(&chip->memory_mutex);
 	list_for_each(p, &chip->buf_list) {
 		buf = list_entry(p, esm_memory_t, list);
@@ -1542,10 +1500,10 @@ snd_es1968_init_dmabuf(es1968_t *chip)
 		snd_es1968_free_dmabuf(chip);
 		return -ENOMEM;
 	}
-	memset(chip->dma.area, 0, 512);
-	chunk->buf = chip->dma.area + 512;
-	chunk->addr = chip->dma.addr + 512;
-	chunk->size = chip->dma.bytes - 512;
+	memset(chip->dma.area, 0, ESM_MEM_ALIGN);
+	chunk->buf = chip->dma.area + ESM_MEM_ALIGN;
+	chunk->addr = chip->dma.addr + ESM_MEM_ALIGN;
+	chunk->size = chip->dma.bytes - ESM_MEM_ALIGN;
 	chunk->empty = 1;
 	list_add(&chunk->list, &chip->buf_list);
 
@@ -1634,6 +1592,7 @@ static int snd_es1968_playback_open(snd_
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	esschan_t *es;
 	int apu1;
+	unsigned long flags;
 
 	/* search 2 APUs */
 	apu1 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_PLAY);
@@ -1653,44 +1612,29 @@ static int snd_es1968_playback_open(snd_
 	es->running = 0;
 	es->substream = substream;
 	es->mode = ESM_MODE_PLAY;
-	INIT_LIST_HEAD(&es->list);
 
 	runtime->private_data = es;
 	runtime->hw = snd_es1968_playback;
 	runtime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =
 		calc_available_memory_size(chip);
+#if 0
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				   1024);
+#endif
+	spin_lock_irqsave(&chip->substream_lock, flags);
+	list_add(&es->list, &chip->substream_list);
+	spin_unlock_irqrestore(&chip->substream_lock, flags);
 
 	return 0;
 }
 
-static int snd_es1968_capture_copy(snd_pcm_substream_t *substream,
-				   int channel, snd_pcm_uframes_t pos,
-				   void *buf, snd_pcm_uframes_t count)
-{
-	//es1968_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	esschan_t *es = snd_magic_cast(esschan_t, runtime->private_data, return -ENXIO);
-	char *src = runtime->dma_area;
-
-	if (runtime->channels == 1)
-		return copy_to_user(buf, src + pos, count) ? -EFAULT : 0;
-	else {
-		count /= 2;
-		pos /= 2;
-		if (copy_to_user(buf, src + pos, count))
-			return -EFAULT;
-		if (copy_to_user(buf + count, src + pos + es->dma_size/2, count))
-			return -EFAULT;
-		return 0;
-	}
-}
-
 static int snd_es1968_capture_open(snd_pcm_substream_t *substream)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	es1968_t *chip = snd_pcm_substream_chip(substream);
 	esschan_t *es;
 	int apu1, apu2;
+	unsigned long flags;
 
 	apu1 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_CAPTURE);
 	if (apu1 < 0)
@@ -1719,7 +1663,6 @@ static int snd_es1968_capture_open(snd_p
 	es->running = 0;
 	es->substream = substream;
 	es->mode = ESM_MODE_CAPTURE;
-	INIT_LIST_HEAD(&es->list);
 
 	/* get mixbuffer */
 	if ((es->mixbuf = snd_es1968_new_memory(chip, ESM_MIXBUF_SIZE)) == NULL) {
@@ -1728,11 +1671,19 @@ static int snd_es1968_capture_open(snd_p
 		snd_magic_kfree(es);
                 return -ENOMEM;
         }
+	memset(es->mixbuf->buf, 0, ESM_MIXBUF_SIZE);
 
 	runtime->private_data = es;
 	runtime->hw = snd_es1968_capture;
 	runtime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =
-		calc_available_memory_size(chip) - 1024;
+		calc_available_memory_size(chip) - 1024; /* keep MIXBUF size */
+#if 0
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				   1024);
+#endif
+	spin_lock_irqsave(&chip->substream_lock, flags);
+	list_add(&es->list, &chip->substream_list);
+	spin_unlock_irqrestore(&chip->substream_lock, flags);
 
 	return 0;
 }
@@ -1741,9 +1692,14 @@ static int snd_es1968_playback_close(snd
 {
 	es1968_t *chip = snd_pcm_substream_chip(substream);
 	esschan_t *es;
+	unsigned long flags;
+
 	if (substream->runtime->private_data == NULL)
 		return 0;
 	es = snd_magic_cast(esschan_t, substream->runtime->private_data, return -ENXIO);
+	spin_lock_irqsave(&chip->substream_lock, flags);
+	list_del(&es->list);
+	spin_unlock_irqrestore(&chip->substream_lock, flags);
 	snd_es1968_free_apu_pair(chip, es->apu[0]);
 	snd_magic_kfree(es);
 
@@ -1754,9 +1710,14 @@ static int snd_es1968_capture_close(snd_
 {
 	es1968_t *chip = snd_pcm_substream_chip(substream);
 	esschan_t *es;
+	unsigned long flags;
+
 	if (substream->runtime->private_data == NULL)
 		return 0;
 	es = snd_magic_cast(esschan_t, substream->runtime->private_data, return -ENXIO);
+	spin_lock_irqsave(&chip->substream_lock, flags);
+	list_del(&es->list);
+	spin_unlock_irqrestore(&chip->substream_lock, flags);
 	snd_es1968_free_memory(chip, es->mixbuf);
 	snd_es1968_free_apu_pair(chip, es->apu[0]);
 	snd_es1968_free_apu_pair(chip, es->apu[2]);
@@ -1785,7 +1746,6 @@ static snd_pcm_ops_t snd_es1968_capture_
 	.prepare =	snd_es1968_pcm_prepare,
 	.trigger =	snd_es1968_pcm_trigger,
 	.pointer =	snd_es1968_pcm_pointer,
-	.copy =		snd_es1968_capture_copy,
 };
 
 
@@ -1827,6 +1787,7 @@ static void __devinit es1968_measure_clo
 	for (i = 0; i < 16; i++)
 		apu_set_register(chip, apu, i, 0x0000);
 
+	apu_set_register(chip, apu, 0, 0x400f);
 	apu_set_register(chip, apu, 4, ((pa >> 16) & 0xff) << 8);
 	apu_set_register(chip, apu, 5, pa & 0xffff);
 	apu_set_register(chip, apu, 6, (pa + CLOCK_MEASURE_BUFSIZE/2) & 0xffff);
@@ -1844,7 +1805,7 @@ static void __devinit es1968_measure_clo
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	__apu_set_register(chip, apu, 5, pa & 0xffff);
-	snd_es1968_trigger_apu(chip, apu, 0x10); /* 16bit mono */
+	snd_es1968_trigger_apu(chip, apu, ESM_APU_16BITLINEAR);
 	do_gettimeofday(&start_time);
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 #if 0
@@ -2035,14 +1996,12 @@ static irqreturn_t snd_es1968_interrupt(
 	}
 
 	if (event & ESM_SOUND_IRQ) {
-		struct list_head *p, *n;
+		struct list_head *p;
 		spin_lock(&chip->substream_lock);
-		/* we need to use list_for_each_safe here since the substream
-		 * can be deleted in period_elapsed().
-		 */
-		list_for_each_safe(p, n, &chip->substream_list) {
+		list_for_each(p, &chip->substream_list) {
 			esschan_t *es = list_entry(p, esschan_t, list);
-			snd_es1968_update_pcm(chip, es);
+			if (es->running)
+				snd_es1968_update_pcm(chip, es);
 		}
 		spin_unlock(&chip->substream_lock);
 	}
@@ -2467,7 +2426,7 @@ static void es1968_resume(es1968_t *chip
 	snd_ac97_resume(chip->ac97);
 
 	/* start timer again */
-	if (atomic_read(&chip->bobclient))
+	if (chip->bobclient)
 		snd_es1968_bob_start(chip);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
@@ -2532,6 +2491,18 @@ static int snd_es1968_dev_free(snd_devic
 	return snd_es1968_free(chip);
 }
 
+struct pm_whitelist {
+	unsigned short type;	/* chip type */
+	unsigned short vendor;	/* subsystem vendor id */
+};
+
+static struct pm_whitelist whitelist[] __devinitdata = {
+	{ TYPE_MAESTRO2E, 0x1028 },
+	{ TYPE_MAESTRO2E, 0x103c },
+	{ TYPE_MAESTRO2E, 0x1179 },
+	{ TYPE_MAESTRO2E, 0x14c0 },	/* HP omnibook 4150 */
+};
+
 static int __devinit snd_es1968_create(snd_card_t * card,
 				       struct pci_dev *pci,
 				       int total_bufsize,
@@ -2567,7 +2538,6 @@ static int __devinit snd_es1968_create(s
 	chip->type = chip_type;
 	spin_lock_init(&chip->reg_lock);
 	spin_lock_init(&chip->substream_lock);
-	spin_lock_init(&chip->bob_lock);
 	INIT_LIST_HEAD(&chip->buf_list);
 	INIT_LIST_HEAD(&chip->substream_list);
 	init_MUTEX(&chip->memory_mutex);
@@ -2581,14 +2551,14 @@ static int __devinit snd_es1968_create(s
 
 	chip->io_port = pci_resource_start(pci, 0);
 	if ((chip->res_io_port = request_region(chip->io_port, 0x100, "ESS Maestro")) == NULL) {
-		snd_es1968_free(chip);
 		snd_printk("unable to grab region 0x%lx-0x%lx\n", chip->io_port, chip->io_port + 0x100 - 1);
+		snd_es1968_free(chip);
 		return -EBUSY;
 	}
 	if (request_irq(pci->irq, snd_es1968_interrupt, SA_INTERRUPT|SA_SHIRQ,
 			"ESS Maestro", (void*)chip)) {
-		snd_es1968_free(chip);
 		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_es1968_free(chip);
 		return -EBUSY;
 	}
 	chip->irq = pci->irq;
@@ -2601,18 +2571,22 @@ static int __devinit snd_es1968_create(s
 	for (i = 0; i < NR_APUS; i++)
 		chip->apu[i] = ESM_APU_FREE;
 
-	atomic_set(&chip->bobclient, 0);
-
 	/* just to be sure */
 	pci_set_master(pci);
 
 	if (do_pm > 1) {
-		/* disable power-management if not maestro2e or
-		 * if not on the whitelist
-		 */
+		/* disable power-management if not on the whitelist */
 		unsigned short vend;
 		pci_read_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);
-		if (chip->type != TYPE_MAESTRO2E || (vend != 0x1028 && vend != 0x1179)) {
+		for (i = 0; i < (int)ARRAY_SIZE(whitelist); i++) {
+			if (chip->type == whitelist[i].type &&
+			    vend == whitelist[i].vendor) {
+				do_pm = 1;
+				break;
+			}
+		}
+		if (do_pm > 1) {
+			/* not matched; disabling pm */
 			printk(KERN_INFO "es1968: not attempting power management.\n");
 			do_pm = 0;
 		}
@@ -2852,7 +2826,8 @@ module_exit(alsa_card_es1968_exit)
 			 total_bufsize,
 			 pcm_substreams_p,
 			 pcm_substreams_c,
-			 clock
+			 clock,
+			 use_pm
 */
 
 static int __init alsa_card_es1968_setup(char *str)
@@ -2867,7 +2842,8 @@ static int __init alsa_card_es1968_setup
 	       get_option(&str,&total_bufsize[nr_dev]) == 2 &&
 	       get_option(&str,&pcm_substreams_p[nr_dev]) == 2 &&
 	       get_option(&str,&pcm_substreams_c[nr_dev]) == 2 &&
-	       get_option(&str,&clock[nr_dev]) == 2);
+	       get_option(&str,&clock[nr_dev]) == 2 &&
+	       get_option(&str,&use_pm[nr_dev]) == 2);
 	nr_dev++;
 	return 1;
 }
