--- linux-2.4.19/arch/x86_64/mm/fault.c.x86_64-aa-mm	2003-02-24 04:29:47.000000000 -0500
+++ linux-2.4.19/arch/x86_64/mm/fault.c	2003-02-24 05:12:32.000000000 -0500
@@ -100,7 +100,7 @@ asmlinkage void do_page_fault(struct pt_
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
-	struct vm_area_struct * vma;
+	struct vm_area_struct * vma, *prev_vma;
 	unsigned long address;
 	unsigned long fixup;
 	int write;
@@ -161,7 +161,8 @@ again:
 		if (address + 128 < regs->rsp)
 			goto bad_area;
 	}
-	if (expand_stack(vma, address, NULL))
+	find_vma_prev(current->mm, address, &prev_vma);
+	if (expand_stack(vma, address, prev_vma))
 		goto bad_area;
 /*
  * Ok, we have a good vm_area for this memory access, so
