diff -urN --exclude-from=/home/mitica/quintela/config/misc/dontdiff linux-orig/drivers/scsi/qla1280.c linux/drivers/scsi/qla1280.c
--- linux-orig/drivers/scsi/qla1280.c	Fri Nov 23 13:05:47 2001
+++ linux/drivers/scsi/qla1280.c	Fri Nov 23 13:08:17 2001
@@ -1,4 +1,4 @@
-/********************************************************************************
+/******************************************************************************
 *                  QLOGIC LINUX SOFTWARE
 *
 * QLogic  QLA1280 (Ultra2)  and  QLA12160 (Ultra3) SCSI driver
@@ -14,11 +14,74 @@
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
-**
+*
 ******************************************************************************/
-#define QLA1280_VERSION      "3.23 Beta"
-/****************************************************************************
+#define QLA1280_VERSION      "3.23.10 Beta"
+/******************************************************************************
     Revision History:
+    Rev  3.23.10 Beta October 1, 2001, Jes Sorensen
+	- Do no typecast short * to long * in QL1280BoardTbl, this
+	  broke miserably on big endian boxes
+    Rev  3.23.9 Beta September 30, 2001, Jes Sorensen
+	- Remove pre 2.2 hack for checking for reentrance in interrupt handler
+	- Make data types used to receive from SCSI_{BUS,TCN,LUN}_32
+	  unsigned int to match the types from struct scsi_cmnd
+    Rev  3.23.8 Beta September 29, 2001, Jes Sorensen
+	- Remove bogus timer_t typedef from qla1280.h
+	- Remove obsolete pre 2.2 PCI setup code, use proper #define's
+	  for PCI_ values, call pci_set_master()
+	- Fix memleak of qla1280_buffer on module unload
+	- Only compile module parsing code #ifdef MODULE - should be
+	  changed to use individual MODULE_PARM's later
+	- Remove dummy_buffer that was never modified nor printed
+	- ENTER()/LEAVE() are noops unless QL_DEBUG_LEVEL_3, hence remove
+	  #ifdef QL_DEBUG_LEVEL_3/#endif around ENTER()/LEAVE() calls
+	- Remove \r from print statements, this is Linux, not DOS
+	- Remove obsolete QLA1280_{SCSILU,INTR,RING}_{LOCK,UNLOCK}
+	  dummy macros
+	- Remove C++ compile hack in header file as Linux driver are not
+	  supposed to be compiled as C++
+	- Kill MS_64BITS macro as it makes the code more readable
+	- Remove unnecessary flags.in_interrupts bit
+    Rev  3.23.7 Beta August 20, 2001, Jes Sorensen
+	- Dont' check for set flags on q->q_flag one by one in qla1280_next()
+        - Check whether the interrupt was generated by the QLA1280 before
+          doing any processing
+	- qla1280_status_entry(): Only zero out part of sense_buffer that
+	  is not being copied into
+	- Remove more superflouous typecasts
+	- qla1280_32bit_start_scsi() replace home-brew memcpy() with memcpy()
+    Rev  3.23.6 Beta August 20, 2001, Tony Luck, Intel
+        - Don't walk the entire list in qla1280_putq_t() just to directly
+	  grab the pointer to the last element afterwards
+    Rev  3.23.5 Beta August 9, 2001, Jes Sorensen
+	- Don't use SA_INTERRUPT, it's use is deprecated for this kinda driver
+    Rev  3.23.4 Beta August 8, 2001, Jes Sorensen
+	- Set dev->max_sectors to 1024
+    Rev  3.23.3 Beta August 6, 2001, Jes Sorensen
+	- Provide compat macros for pci_enable_device(), pci_find_subsys()
+	  and scsi_set_pci_device()
+	- Call scsi_set_pci_device() for all devices
+	- Reduce size of kernel version dependant device probe code
+	- Move duplicate probe/init code to seperate function
+	- Handle error if qla1280_mem_alloc() fails
+	- Kill OFFSET() macro and use Linux's PCI definitions instead
+        - Kill private structure defining PCI config space (struct config_reg)
+	- Only allocate I/O port region if not in MMIO mode
+	- Remove duplicate (unused) sanity check of sife of srb_t
+    Rev  3.23.2 Beta August 6, 2001, Jes Sorensen
+	- Change home-brew memset() implementations to use memset()
+        - Remove all references to COMTRACE() - accessing a PC's COM2 serial
+          port directly is not legal under Linux.
+    Rev  3.23.1 Beta April 24, 2001, Jes Sorensen
+        - Remove pre 2.2 kernel support
+        - clean up 64 bit DMA setting to use 2.4 API (provide backwards compat)
+        - Fix MMIO access to use readl/writel instead of directly
+          dereferencing pointers
+        - Nuke MSDOS debugging code
+        - Change true/false data types to int from uint8_t
+        - Use int for counters instead of uint8_t etc.
+        - Clean up size & byte order conversion macro usage
     Rev  3.23 Beta January 11, 2001 BN Qlogic
         - Added check of device_id when handling non 
           QLA12160s during detect().
@@ -132,15 +195,8 @@
 
 
 #include <linux/config.h>       
-#ifdef MODULE
 #include <linux/module.h>
-#endif
 
-#include <stdarg.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/segment.h>
-#include <asm/byteorder.h>
 #include <linux/version.h>
 #include <linux/types.h>
 #include <linux/string.h>
@@ -154,18 +210,22 @@
 #include <linux/proc_fs.h>
 #include <linux/blk.h>
 #include <linux/tqueue.h>
+#include <linux/stat.h>
+#include <linux/slab.h> 
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/segment.h>
+#include <asm/byteorder.h>
+
 #ifndef KERNEL_VERSION
 #  define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
 #endif
- 
+
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
 #include <linux/pci_ids.h>
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-#include <linux/tasks.h>
-# include <linux/bios32.h>
-#endif
 #include "sd.h"
 #include "scsi.h"
 #include "hosts.h"
@@ -174,14 +234,13 @@
 #include "ql12160_fw.h"   /* ISP RISC codes */
 #include "ql1280_fw.h"
 
-#include <linux/stat.h>
-#include <linux/slab.h> 
 
 /*
  * Compile time Options: 
  *            0 - Disable and 1 - Enable 
  */
 #define  QL1280_TARGET_MODE_SUPPORT    0   /* Target mode support */
+#define  QL1280_LUN_SUPPORT            0
 #define  WATCHDOGTIMER                 0
 #define  MEMORY_MAPPED_IO              0
 #define  DEBUG_QLA1280_INTR            0
@@ -196,74 +255,84 @@
 #define  QLA1280_PROFILE               1   /* 3.20 */ 
 #define  DEBUG_QLA1280                 0
 
-#define	BZERO(ptr, amt)		memset(ptr, 0, amt)
-#define	BCOPY(src, dst, amt)	memcpy(dst, src, amt)
-#define	KMALLOC(siz)	kmalloc((siz), GFP_ATOMIC)
-#define	KMFREE(ip,siz)	kfree((ip))
-#define	SYS_DELAY(x)		udelay(x);barrier()
-#define QLA1280_DELAY(sec)  mdelay(sec * 1000)
+
+#if (BITS_PER_LONG == 64) || defined CONFIG_HIGHMEM
+#define QLA_64BIT_PTR	1
+#endif
 
 /* 3.16 */
-#if  BITS_PER_LONG > 32
-#define pci_dma_lo32(a) (a & 0xffffffff)
-#define pci_dma_hi32(a) ((a >> 32) & 0xffffffff)
+#ifdef QLA_64BIT_PTR
+#define pci_dma_lo32(a)		(a & 0xffffffff)
+#define pci_dma_hi32(a)		(a >> 32)
 #else
-#define pci_dma_lo32(a) (a & 0xffffffff)
-#define pci_dma_hi32(a) 0
+#define pci_dma_lo32(a)		(a & 0xffffffff)
+#define pci_dma_hi32(a)		0
 #endif
 
-#define  VIRT_TO_BUS(a)  virt_to_bus(((void *)a))
 
-#if  BITS_PER_LONG <= 32
-#define  VIRT_TO_BUS_LOW(a) (uint32_t)virt_to_bus(((void *)a))
-#define  VIRT_TO_BUS_HIGH(a) (uint32_t)(0x0)
-#else
-#define  VIRT_TO_BUS_LOW(a) (uint32_t)(0xffffffff & virt_to_bus((void *)(a)))
-#define  VIRT_TO_BUS_HIGH(a) (uint32_t)(0xffffffff & (virt_to_bus((void *)(a))>>32))
+#define NVRAM_DELAY()		udelay(500) /* 2 microsecond delay */
+
+#define CACHE_FLUSH(a)		RD_REG_WORD(a)
+#define INVALID_HANDLE		(MAX_OUTSTANDING_COMMANDS + 1)
+
+
+/*
+ * Compat macros
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
+#define pci_set_dma_mask(dev, mask)		dev->dma_mask = mask;
+#define pci_present()				pcibios_present()
+#define pci_enable_device(pdev)			0
+#define pci_find_subsys(id, dev, sid, sdev, pdev) pci_find_device(id,dev,pdev)
+#define scsi_set_pci_device(host, pdev)
 #endif
 
 
-#define STATIC     
-#define NVRAM_DELAY() udelay(500) /* 2 microsecond delay */
-void qla1280_device_queue_depth(scsi_qla_host_t *, Scsi_Device *);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+typedef unsigned long dma_addr_t;
 
-#define  CACHE_FLUSH(a) (RD_REG_WORD(a))
-#define  INVALID_HANDLE    (MAX_OUTSTANDING_COMMANDS+1)
+static inline void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
+					 dma_addr_t *dma_handle)
+{
+	void *virt_ptr;
 
-#define  MSW(x)          (uint16_t)((uint32_t)(x) >> 16)
-#define  LSW(x)          (uint16_t)(x)
-#define  MSB(x)          (uint8_t)((uint16_t)(x) >> 8)
-#define  LSB(x)          (uint8_t)(x)
+	virt_ptr = kmalloc(size, GFP_KERNEL);
+	if (!virt_ptr)
+		return NULL;
+	*dma_handle = virt_to_bus(virt_ptr);
+	return virt_ptr;
+}
+#define pci_free_consistent(cookie, size, ptr, dma_ptr)	kfree(ptr)
+#define pci_map_single(cookie, address, size, dir)	virt_to_bus(address)
+#define pci_map_sg(cookie, scatter, ents, dir)		ents
+#define pci_unmap_single(cookie, address, size, dir)
+#define pci_unmap_sg(cookie, scatter, ents, dir)
 
-#if  BITS_PER_LONG <= 32
-#define  LS_64BITS(x) (uint32_t)((unsigned long) x)
-#define  MS_64BITS(x) (uint32_t)((unsigned long) 0x0)
-#else
-#define  LS_64BITS(x) (uint32_t)(0xffffffff & ((unsigned long)x))
-#define  MS_64BITS(x) (uint32_t)(0xffffffff & (((unsigned long)x)>>32) )
+#define pci_resource_start(dev, i)			dev->base_address[i]
 #endif
 
+
 /*
  *  QLogic Driver Support Function Prototypes.
  */
-STATIC void   qla1280_done(scsi_qla_host_t *, srb_t **, srb_t **);
-STATIC void   qla1280_next(scsi_qla_host_t *, scsi_lu_t *, uint8_t);
-STATIC void   qla1280_putq_t(scsi_lu_t *, srb_t *);
-STATIC void   qla1280_done_q_put(srb_t *, srb_t **, srb_t **);
-STATIC void qla1280_select_queue_depth(struct Scsi_Host *, Scsi_Device *);
+static void qla1280_done(scsi_qla_host_t *, srb_t **, srb_t **);
+static void qla1280_next(scsi_qla_host_t *, scsi_lu_t *, uint8_t);
+static void qla1280_putq_t(scsi_lu_t *, srb_t *);
+static void qla1280_done_q_put(srb_t *, srb_t **, srb_t **);
+static void qla1280_device_queue_depth(scsi_qla_host_t *, Scsi_Device *);
+static void qla1280_select_queue_depth(struct Scsi_Host *, Scsi_Device *);
 #if  STOP_ON_ERROR 
 static void qla1280_panic(char *, struct Scsi_Host *host);
 #endif
-void qla1280_print_scsi_cmd(Scsi_Cmnd *cmd);
-STATIC void qla1280_abort_queue_single(scsi_qla_host_t *,uint32_t,uint32_t,uint32_t,uint32_t);
+static void qla1280_abort_queue_single(scsi_qla_host_t *, uint32_t,
+				       uint32_t, uint32_t, uint32_t);
 
-STATIC int qla1280_return_status( sts_entry_t *sts, Scsi_Cmnd       *cp);
-STATIC void qla1280_removeq(scsi_lu_t *q, srb_t *sp);
-STATIC void qla1280_mem_free(scsi_qla_host_t *ha);
+static int qla1280_return_status(sts_entry_t *sts, Scsi_Cmnd *cp);
+static void qla1280_removeq(scsi_lu_t *q, srb_t *sp);
+static void qla1280_mem_free(scsi_qla_host_t *ha);
 void qla1280_do_dpc(void *p);
-static char	*qla1280_get_token(char *, char *);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
-STATIC inline void mdelay(int);
+#ifdef MODULE
+static char *qla1280_get_token(char *, char *);
 #endif
 static inline void qla1280_enable_intrs(scsi_qla_host_t *);
 static inline void qla1280_disable_intrs(scsi_qla_host_t *);
@@ -271,83 +340,85 @@
 /*
  *  QLogic ISP1280 Hardware Support Function Prototypes.
  */
-STATIC uint8_t   qla1280_initialize_adapter(struct scsi_qla_host   *ha);
-STATIC uint8_t   qla1280_enable_tgt(scsi_qla_host_t *, uint8_t);
-STATIC uint8_t   qla1280_isp_firmware(scsi_qla_host_t *);
-STATIC uint8_t   qla1280_pci_config(scsi_qla_host_t *);
-STATIC uint8_t   qla1280_chip_diag(scsi_qla_host_t *);
-STATIC uint8_t   qla1280_setup_chip(scsi_qla_host_t *);
-STATIC uint8_t   qla1280_init_rings(scsi_qla_host_t *);
-STATIC uint8_t   qla1280_nvram_config(scsi_qla_host_t *);
-STATIC uint8_t   qla1280_mailbox_command(scsi_qla_host_t *, uint8_t, uint16_t *);
-STATIC uint8_t   qla1280_bus_reset(scsi_qla_host_t *, uint8_t);
-STATIC uint8_t   qla1280_device_reset(scsi_qla_host_t *, uint8_t, uint32_t);
-STATIC uint8_t   qla1280_abort_device(scsi_qla_host_t *, uint8_t, uint32_t, uint32_t);
-STATIC uint8_t   qla1280_abort_command(scsi_qla_host_t *, srb_t *),
-                 qla1280_64bit_start_scsi(scsi_qla_host_t *, srb_t *),
-                 qla1280_32bit_start_scsi(scsi_qla_host_t *, srb_t *),
-                 qla1280_abort_isp(scsi_qla_host_t *);
-STATIC void      qla1280_nv_write(scsi_qla_host_t *, uint16_t),
-                 qla1280_nv_delay(scsi_qla_host_t *),
-                 qla1280_poll(scsi_qla_host_t *),
-                 qla1280_reset_adapter(scsi_qla_host_t *),
-                 qla1280_marker(scsi_qla_host_t *, uint8_t, uint32_t, uint32_t, uint8_t),
-                 qla1280_isp_cmd(scsi_qla_host_t *),
-                 qla1280_isr(scsi_qla_host_t *, srb_t **, srb_t **),
-                 qla1280_rst_aen(scsi_qla_host_t *),
-                 qla1280_status_entry(scsi_qla_host_t *, sts_entry_t *, srb_t **,
-                                      srb_t **),
-                 qla1280_error_entry(scsi_qla_host_t *, response_t *, srb_t **,
-                                     srb_t **),
-                 qla1280_restart_queues(scsi_qla_host_t *),
-                 qla1280_abort_queues(scsi_qla_host_t *);
-STATIC uint16_t  qla1280_get_nvram_word(scsi_qla_host_t *, uint32_t),
-                 qla1280_nvram_request(scsi_qla_host_t *, uint32_t),
-                 qla1280_debounce_register(volatile uint16_t *);
-STATIC request_t *qla1280_req_pkt(scsi_qla_host_t *);
-int  qla1280_check_for_dead_scsi_bus(scsi_qla_host_t *ha, srb_t *sp);
-STATIC uint8_t qla1280_mem_alloc(scsi_qla_host_t *ha);
-STATIC uint8_t  qla1280_register_with_Linux(scsi_qla_host_t *ha, uint8_t maxchannels);
+static int qla1280_initialize_adapter(struct scsi_qla_host *ha);
+static int qla1280_enable_tgt(scsi_qla_host_t *, uint8_t);
+static int qla1280_isp_firmware(scsi_qla_host_t *);
+static int qla1280_pci_config(scsi_qla_host_t *);
+static int qla1280_chip_diag(scsi_qla_host_t *);
+static int qla1280_setup_chip(scsi_qla_host_t *);
+static int qla1280_init_rings(scsi_qla_host_t *);
+static int qla1280_nvram_config(scsi_qla_host_t *);
+static int qla1280_mailbox_command(scsi_qla_host_t *, uint8_t, uint16_t *);
+static int qla1280_bus_reset(scsi_qla_host_t *, u8);
+static int qla1280_device_reset(scsi_qla_host_t *, uint8_t, uint32_t);
+static int qla1280_abort_device(scsi_qla_host_t *, u8, u32, u32);
+static int qla1280_abort_command(scsi_qla_host_t *, srb_t *);
+static int qla1280_abort_isp(scsi_qla_host_t *);
+static int qla1280_64bit_start_scsi(scsi_qla_host_t *, srb_t *);
+static int qla1280_32bit_start_scsi(scsi_qla_host_t *, srb_t *);
+static void qla1280_nv_write(scsi_qla_host_t *, uint16_t);
+static void qla1280_poll(scsi_qla_host_t *);
+static void qla1280_reset_adapter(scsi_qla_host_t *);
+static void qla1280_marker(scsi_qla_host_t *, u8, u32, u32, u8);
+static void qla1280_isp_cmd(scsi_qla_host_t *);
+static void qla1280_isr(scsi_qla_host_t *, srb_t **, srb_t **);
+static void qla1280_rst_aen(scsi_qla_host_t *);
+static void qla1280_status_entry(scsi_qla_host_t *, sts_entry_t *,
+                                 srb_t **, srb_t **);
+static void qla1280_error_entry(scsi_qla_host_t *, response_t *,
+                                srb_t **, srb_t **);
+static void qla1280_restart_queues(scsi_qla_host_t *);
+static void qla1280_abort_queues(scsi_qla_host_t *);
+static uint16_t  qla1280_get_nvram_word(scsi_qla_host_t *, uint32_t);
+static uint16_t	 qla1280_nvram_request(scsi_qla_host_t *, uint32_t);
+static uint16_t	 qla1280_debounce_register(volatile uint16_t *);
+static request_t *qla1280_req_pkt(scsi_qla_host_t *);
+static int	 qla1280_check_for_dead_scsi_bus(scsi_qla_host_t *ha,
+						srb_t *sp);
+static int	 qla1280_mem_alloc(scsi_qla_host_t *ha);
+static int	 qla1280_register_with_Linux(scsi_qla_host_t *ha,
+                                             unsigned int maxchannels);
+
+static int	 qla12160_set_target_parameters(scsi_qla_host_t *, uint32_t,
+						uint32_t, uint32_t,
+						nvram160_t *);
+static void	 qla12160_get_target_parameters(scsi_qla_host_t *, uint32_t,
+						uint32_t, uint32_t);
 
-STATIC uint8_t qla12160_set_target_parameters(scsi_qla_host_t *, uint32_t, uint32_t, uint32_t, nvram160_t *);
-STATIC void qla12160_get_target_parameters(scsi_qla_host_t *, uint32_t, uint32_t, uint32_t);
+#if QL1280_LUN_SUPPORT
+static void      qla1280_enable_lun(scsi_qla_host_t *, uint8_t, uint32_t);
+#endif
 
 #if QL1280_TARGET_MODE_SUPPORT
-STATIC void      qla1280_enable_lun(scsi_qla_host_t *, uint8_t, uint32_t),
-                 qla1280_notify_ack(scsi_qla_host_t *, notify_entry_t *),
-                 qla1280_immed_notify(scsi_qla_host_t *, notify_entry_t *),
-                 qla1280_accept_io(scsi_qla_host_t *, ctio_ret_entry_t *),
-                 qla1280_64bit_continue_io(scsi_qla_host_t *, 
-                                 atio_entry_t *, uint32_t,
-                                 paddr32_t *),
-                 qla1280_32bit_continue_io(scsi_qla_host_t *, 
-                                 atio_entry_t *, uint32_t,
-                                 paddr32_t *),
-                 qla1280_atio_entry(scsi_qla_host_t *, atio_entry_t *),
-                 qla1280_notify_entry(scsi_qla_host_t *, notify_entry_t *);
+static void      qla1280_notify_ack(scsi_qla_host_t *, notify_entry_t *);
+static void      qla1280_immed_notify(scsi_qla_host_t *, notify_entry_t *);
+static void      qla1280_accept_io(scsi_qla_host_t *, ctio_ret_entry_t *);
+static void      qla1280_64bit_continue_io(scsi_qla_host_t *, atio_entry_t *,
+					   uint32_t, paddr32_t *);
+static void      qla1280_32bit_continue_io(scsi_qla_host_t *, atio_entry_t *,
+					   uint32_t, paddr32_t *);
+static void      qla1280_atio_entry(scsi_qla_host_t *, atio_entry_t *);
+static void      qla1280_notify_entry(scsi_qla_host_t *, notify_entry_t *);
 #endif  /* QLA1280_TARGET_MODE_SUPPORT */
 
+#if DEBUG_QLA1280
+static void	qla1280_print(char *);
+static void	qla1280_output_number(uint32_t, int);
+static int ql_debug_print = 1;
+#endif
+
 #ifdef QL_DEBUG_ROUTINES
 /*
  *  Driver Debug Function Prototypes.
  */
-STATIC uint8_t  qla1280_getbyte(uint8_t *);
-STATIC uint16_t qla1280_getword(uint16_t *);
-STATIC uint32_t qla1280_getdword(uint32_t *);
-STATIC void     qla1280_putbyte(uint8_t *, uint8_t),
-                qla1280_putword(uint16_t *, uint16_t),
-                qla1280_putdword(uint32_t *, uint32_t),
-                qla1280_print(caddr_t),
-                qla1280_output_number(uint32_t, uint8_t),
-                qla1280_putc(uint8_t),
-                qla1280_dump_buffer(caddr_t, uint32_t);
-
-char          debug_buff[80];
-#if  DEBUG_QLA1280 
-STATIC uint8_t ql_debug_print = 1;
-#else
-STATIC uint8_t ql_debug_print = 0;
-#endif
+static u8 qla1280_getbyte(u8 *);
+static u16 qla1280_getword(u16 *);
+static u32 qla1280_getdword(u32 *);
+static void qla1280_putbyte(u8 *, u8);
+static void qla1280_putword(u16 *, u8);
+static void qla1280_putdword(u32 *, u32);
+static void qla1280_dump_buffer(char *, u32);
+static void qla1280_print_scsi_cmd(Scsi_Cmnd *cmd);
 #endif
 
 /*
@@ -355,19 +426,10 @@
  */
 #ifdef MODULE
 static char *options = NULL;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,18)
 
 /* insmod qla1280 options=verbose" */
 MODULE_PARM(options, "s");  
 #endif
-/*
- * Just in case someone uses commas to separate items on the insmod
- * command line, we define a dummy buffer here to avoid having insmod
- * write wild stuff into our code segment
- */
-static char dummy_buffer[60] = "Please don't add commas in your insmod command!!\n";
-
-#endif
 
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
@@ -411,56 +473,68 @@
 /*****************************************/
 /*   ISP Boards supported by this driver */
 /*****************************************/
-#define QLA1280_VENDOR_ID   0x1077
-#define QLA1080_DEVICE_ID   0x1080
-#define QLA1240_DEVICE_ID   0x1240
-#define QLA1280_DEVICE_ID   0x1280
-#define QLA12160_DEVICE_ID  0x1216
-#define QLA10160_DEVICE_ID  0x1016
-#define NUM_OF_ISP_DEVICES        6
+#define QLA1280_VENDOR_ID	0x1077
+#define QLA1080_DEVICE_ID	0x1080
+#define QLA1240_DEVICE_ID	0x1240
+#define QLA1280_DEVICE_ID	0x1280
+#define QLA12160_DEVICE_ID	0x1216
+#define QLA10160_DEVICE_ID	0x1016
+#define NUM_OF_ISP_DEVICES	6
 
 typedef struct _qlaboards 
 {
-   unsigned char   bdName[9];       /* Board ID String */
-   unsigned long   device_id;       /* Device PCI ID   */
-   int   numPorts;                  /* Number of SCSI ports */
-   unsigned short   *fwcode;        /* pointer to FW array         */
-   unsigned long    *fwlen;         /* number of words in array    */
-   unsigned short   *fwstart;       /* start address for F/W       */
-   unsigned char   *fwver;          /* Ptr to F/W version array    */
+   unsigned char    bdName[9];		/* Board ID String */
+   unsigned long    device_id;		/* Device PCI ID   */
+   int              numPorts;		/* Number of SCSI ports */
+   unsigned short   *fwcode;		/* pointer to FW array         */
+   unsigned short   *fwlen;		/* number of words in array    */
+   unsigned short   *fwstart;		/* start address for F/W       */
+   unsigned char    *fwver;		/* Ptr to F/W version array    */
 } qla_boards_t;
 
 struct _qlaboards   QL1280BoardTbl[NUM_OF_ISP_DEVICES] = 
 {
    /* Name ,  Board PCI Device ID,         Number of ports */
   {"QLA12160 ", QLA12160_DEVICE_ID,          2,      
-               &fw12160i_code01[0],  (unsigned long *)&fw12160i_length01,&fw12160i_addr01, &fw12160i_version_str[0] },       
+		&fw12160i_code01[0],  &fw12160i_length01,
+   		&fw12160i_addr01, &fw12160i_version_str[0] },       
   {"QLA1080 ", QLA1080_DEVICE_ID,           1,        
-               &fw1280ei_code01[0],  (unsigned long *)&fw1280ei_length01,&fw1280ei_addr01, &fw1280ei_version_str[0] },       
+		&fw1280ei_code01[0],  &fw1280ei_length01,
+		&fw1280ei_addr01, &fw1280ei_version_str[0] },       
   {"QLA1240 ", QLA1240_DEVICE_ID,           2,       
-               &fw1280ei_code01[0],  (unsigned long *)&fw1280ei_length01,&fw1280ei_addr01, &fw1280ei_version_str[0] },       
+		&fw1280ei_code01[0],  &fw1280ei_length01,
+		&fw1280ei_addr01, &fw1280ei_version_str[0] },       
   {"QLA1280 ", QLA1280_DEVICE_ID,           2,      
-               &fw1280ei_code01[0],  (unsigned long *)&fw1280ei_length01,&fw1280ei_addr01, &fw1280ei_version_str[0] },       
+		&fw1280ei_code01[0],  &fw1280ei_length01,
+		&fw1280ei_addr01, &fw1280ei_version_str[0] },       
   {"QLA10160 ", QLA10160_DEVICE_ID,          1,      
-               &fw12160i_code01[0],  (unsigned long *)&fw12160i_length01,&fw12160i_addr01, &fw12160i_version_str[0] },       
+		&fw12160i_code01[0],  &fw12160i_length01,
+		&fw12160i_addr01, &fw12160i_version_str[0] },       
   {"        ",                 0,           0}
 };
 
-static unsigned long qla1280_verbose = 1L;
+static int qla1280_verbose = 1;
 static scsi_qla_host_t *qla1280_hostlist = NULL;
 #if QLA1280_PROFILE
 static int qla1280_buffer_size = 0;
 static char *qla1280_buffer = NULL;
 #endif
 
+#if  DEBUG_QLA1280  
+char          debug_buff[80];
+#define DEBUG(x)	x
+#else
+#define DEBUG(x)
+#endif
+
 #ifdef QL_DEBUG_LEVEL_3 
-#define ENTER(x)	sprintf(debug_buff,"qla1280 : Entering %s()\n\r", x); \
+#define ENTER(x)	sprintf(debug_buff,"qla1280 : Entering %s()\n", x); \
                         qla1280_print(debug_buff);
-#define LEAVE(x)	sprintf(debug_buff,"qla1280 : Leaving %s()\n\r", x); \
+#define LEAVE(x)	sprintf(debug_buff,"qla1280 : Leaving %s()\n", x); \
                         qla1280_print(debug_buff);
-#define ENTER_INTR(x)	sprintf(debug_buff,"qla1280 : Entering %s()\n\r", x); \
+#define ENTER_INTR(x)	sprintf(debug_buff,"qla1280 : Entering %s()\n", x); \
                         qla1280_print(debug_buff);
-#define LEAVE_INTR(x)	sprintf(debug_buff,"qla1280 : Leaving %s()\n\r", x); \
+#define LEAVE_INTR(x)	sprintf(debug_buff,"qla1280 : Leaving %s()\n", x); \
                         qla1280_print(debug_buff);
 #define DEBUG3(x)	x
 #else
@@ -471,15 +545,6 @@
 #define DEBUG3(x)
 #endif
 
-#if  DEBUG_QLA1280  
-#define COMTRACE(x)
-/* #define COMTRACE(x)     qla1280_putc(x); */
-#define DEBUG(x)	x
-#else
-#define DEBUG(x)
-#define COMTRACE(x)
-#endif
-
 #ifdef QL_DEBUG_LEVEL_2 
 #define DEBUG2(x)	x
 #else
@@ -487,12 +552,6 @@
 #endif
 #define DEBUG5(x)
 
-#if (BITS_PER_LONG==64)
-#   define OFFSET(w)   (((uint64_t) &w) & 0xFF)   /* 256 byte offsets */
-#else
-#   define OFFSET(w)   (((uint32_t) &w) & 0xFF)   /* 256 byte offsets */
-#endif
-
 #define SCSI_BUS_32(scp)   ((scp)->channel)
 #define SCSI_TCN_32(scp)    ((scp)->target)
 #define SCSI_LUN_32(scp)    ((scp)->lun)
@@ -538,141 +597,229 @@
   int   len = 0;
   qla_boards_t   *bdp; 
   uint32_t        b, t, l;
-  uint8_t  *temp;
   host = NULL;
 
     /* Find the host that was specified */
-    for( ha=qla1280_hostlist; (ha != NULL) && ha->host->host_no != hostno; ha=ha->next )
-    ;
+  for( ha=qla1280_hostlist; (ha != NULL) && ha->host->host_no != hostno; ha=ha->next )
+      ;
 
-    /* if host wasn't found then exit */
-    if( !ha ) {
-        size = sprintf(buffer, "Can't find adapter for host number %d\n", hostno);
-        if( size > length ) {
-      return (size);
-        } else {
-            return (0);
-    }
+  /* if host wasn't found then exit */
+  if(!ha) {
+      size = sprintf(buffer, "Can't find adapter for host number %d\n", hostno);
+      if( size > length ) {
+	  return size;
+      } else {
+	  return 0;
+      }
   }
 
   host = ha->host;
 
-    if( inout == TRUE ) /* Has data been written to the file? */
-  {
-        printk("qla1280_proc: has data been written to the file. \n");
-        return (qla1280_set_info(buffer, length, host));
+  if(inout == TRUE) { /* Has data been written to the file? */
+      printk("qla1280_proc: has data been written to the file.\n");
+      return qla1280_set_info(buffer, length, host);
   }
   
   /* 
    * if our old buffer is the right size use it otherwise 
    * allocate a new one.
    */
-    size = 4096;  /* get a page */
-    if( qla1280_buffer_size != size ) {
-    /* deallocate this buffer and get a new one */
-        if( qla1280_buffer != NULL ) {
-      kfree(qla1280_buffer);
-      qla1280_buffer_size = 0;
-    }
-    qla1280_buffer = kmalloc(size, GFP_KERNEL);
+  if(qla1280_buffer_size != PAGE_SIZE) {
+      /* deallocate this buffer and get a new one */
+      if(qla1280_buffer != NULL) {
+	  free_page((unsigned long)qla1280_buffer);
+	  qla1280_buffer_size = 0;
+      }
+      qla1280_buffer = (char *)get_free_page(GFP_KERNEL);
   }
-    if( qla1280_buffer == NULL ) {
-    size = sprintf(buffer, "qla1280 - kmalloc error at line %d\n",
-        __LINE__);
-    return size;
+  if(qla1280_buffer == NULL) {
+      size = sprintf(buffer, "qla1280 - kmalloc error at line %d\n", __LINE__);
+      return size;
   }
-    /* save the size of our buffer */
-  qla1280_buffer_size = size;
+  /* save the size of our buffer */
+  qla1280_buffer_size = PAGE_SIZE;
 
   /* 3.20 clear the buffer we use for proc display */
-  temp = qla1280_buffer;
-  for (b=0 ; b < size; b++)     *(temp+b) = 0; 
+  memset(qla1280_buffer, 0, PAGE_SIZE);
 
-    /* start building the print buffer */ 
-    bdp = &QL1280BoardTbl[ha->devnum];
-    size =  sprintf(PROC_BUF,
-            "QLogic PCI to SCSI Adapter for ISP 1280/12160:\n"
-            "        Firmware version: %2d.%02d.%02d, Driver version %s\n",                bdp->fwver[0], bdp->fwver[1], bdp->fwver[2], QLA1280_VERSION);
-
-    len += size;
-
-    size = sprintf(PROC_BUF, "SCSI Host Adapter Information: %s\n", bdp->bdName);
-    len += size;
-    size = sprintf(PROC_BUF, "Request Queue = 0x%lx, Response Queue = 0x%lx\n",
-                        (unsigned long) ha->request_dma,
-                        (unsigned long) ha->response_dma);
-    len += size;
-    size = sprintf(PROC_BUF, "Request Queue count= 0x%x, Response Queue count= 0x%x\n",
-                        REQUEST_ENTRY_CNT,
-                        RESPONSE_ENTRY_CNT);
-    len += size; 
-    size = sprintf(PROC_BUF, "Number of pending commands = 0x%lx\n", ha->actthreads);
-    len += size;
-    size = sprintf(PROC_BUF, "Number of queued commands = 0x%lx\n", ha->qthreads);
-    len += size;
-    size = sprintf(PROC_BUF, "Number of free request entries = %d\n",ha->req_q_cnt);
-    len += size;
-    size = sprintf(PROC_BUF, "\n");                                             /* 1       */
-    len += size;
+  /* start building the print buffer */ 
+  bdp = &QL1280BoardTbl[ha->devnum];
+  size =  sprintf(PROC_BUF,
+		  "QLogic PCI to SCSI Adapter for ISP 1280/12160:\n"
+		  "        Firmware version: %2d.%02d.%02d, Driver version %s\n",                bdp->fwver[0], bdp->fwver[1], bdp->fwver[2], QLA1280_VERSION);
+
+  len += size;
+
+  size = sprintf(PROC_BUF, "SCSI Host Adapter Information: %s\n", bdp->bdName);
+  len += size;
+  size = sprintf(PROC_BUF, "Request Queue = 0x%p, Response Queue = 0x%p\n",
+		 (void *)ha->request_dma, (void *)ha->response_dma);
+  len += size;
+  size = sprintf(PROC_BUF, "Request Queue count= 0x%x, Response Queue count= 0x%x\n",
+		 REQUEST_ENTRY_CNT, RESPONSE_ENTRY_CNT);
+  len += size; 
+  size = sprintf(PROC_BUF, "Number of pending commands = 0x%lx\n", ha->actthreads);
+  len += size;
+  size = sprintf(PROC_BUF, "Number of queued commands = 0x%lx\n", ha->qthreads);
+  len += size;
+  size = sprintf(PROC_BUF, "Number of free request entries = %d\n",ha->req_q_cnt);
+  len += size;
+  size = sprintf(PROC_BUF, "\n");                                             /* 1       */
+  len += size;
                         
-    size = sprintf(PROC_BUF, "SCSI device Information:\n");
-    len += size; 
+  size = sprintf(PROC_BUF, "SCSI device Information:\n");
+  len += size; 
   /* scan for all equipment stats */ 
-	for (b = 0; b < MAX_BUSES; b++) 
-	for (t = 0; t < MAX_TARGETS; t++) {
-        for( l = 0; l < MAX_LUNS; l++ ) {
-           up = (scsi_lu_t *) LU_Q(ha, b, t, l);
-           if( up == NULL ) 
-           continue;
-           /* unused device/lun */
-           if( up->io_cnt == 0 || up->io_cnt < 2 )
-           continue;
-      /* total reads since boot */
-      /* total writes since boot */
-      /* total requests since boot  */
-           size = sprintf(PROC_BUF, "(%2d:%2d:%2d): Total reqs %ld,",b,t,l,up->io_cnt);
-           len += size;
-      /* current number of pending requests */
-           size = sprintf(PROC_BUF, " Pend reqs %d,",up->q_outcnt);
-           len += size;
+  for (b = 0; b < MAX_BUSES; b++) 
+      for (t = 0; t < MAX_TARGETS; t++) {
+	  for(l = 0; l < MAX_LUNS; l++) {
+	      up = (scsi_lu_t *) LU_Q(ha, b, t, l);
+	      if(up == NULL) 
+		  continue;
+	      /* unused device/lun */
+	      if(up->io_cnt == 0 || up->io_cnt < 2)
+		  continue;
+	      /* total reads since boot */
+	      /* total writes since boot */
+	      /* total requests since boot  */
+	      size = sprintf(PROC_BUF, "(%2d:%2d:%2d): Total reqs %ld,",b,t,l,up->io_cnt);
+	      len += size;
+	      /* current number of pending requests */
+	      size = sprintf(PROC_BUF, " Pend reqs %d,",up->q_outcnt);
+	      len += size;
 #if 0
-      /* avg response time */
-           size = sprintf(PROC_BUF, " Avg resp time %ld%%,",(up->resp_time/up->io_cnt)*100);
-           len += size;
-      
-      /* avg active time */
-           size = sprintf(PROC_BUF, " Avg active time %ld%%\n",(up->act_time/up->io_cnt)*100);
-#else
-           size = sprintf(PROC_BUF, "\n");
-#endif
-           len += size; 
-        }
-        if( len >= qla1280_buffer_size ) 
-          break;
-  }
+	      /* avg response time */
+	      size = sprintf(PROC_BUF, " Avg resp time %ld%%,",(up->resp_time/up->io_cnt)*100);
+	      len += size;
+
+	      /* avg active time */
+	      size = sprintf(PROC_BUF, " Avg active time %ld%%\n",(up->act_time/up->io_cnt)*100);
+#else
+	      size = sprintf(PROC_BUF, "\n");
+#endif
+	      len += size; 
+	  }
+	  if(len >= qla1280_buffer_size) 
+	      break;
+      }
 
-    if( len >= qla1280_buffer_size ) {
-    printk(KERN_WARNING "qla1280: Overflow buffer in qla1280_proc.c\n");
+  if(len >= qla1280_buffer_size) {
+      printk(KERN_WARNING "qla1280: Overflow buffer in qla1280_proc.c\n");
   }
 
-    if( offset > len - 1 ) {
-    kfree(qla1280_buffer);
-    qla1280_buffer = NULL;
-    qla1280_buffer_size = length = 0;
-    *start = NULL;
-    } else {
-    *start = &qla1280_buffer[offset];   /* Start of wanted data */
-        if( len - offset < length ) {
-            length = len - offset;
-    }
+  if(offset > len - 1) {
+      free_page((unsigned long)qla1280_buffer);
+      qla1280_buffer = NULL;
+      qla1280_buffer_size = length = 0;
+      *start = NULL;
+  } else {
+      *start = &qla1280_buffer[offset];   /* Start of wanted data */
+      if(len - offset < length) {
+	  length = len - offset;
+      }
   }
-    return (length);
+  return length;
 #else
-    return (0);
+  return 0;
 #endif
+}
 
+/**************************************************************************
+ * qla1280_do_device_init
+ *    This routine will register the device with the SCSI subsystem,
+ *    initialize the host adapter structure and call the device init
+ *    routines.
+ *
+ * Input:
+ *     pdev      - pointer to struct pci_dev for adapter
+ *     template  - pointer to SCSI template
+ *     devnum    - the device number
+ *     bdp       - pointer to struct _qlaboards
+ *     num_hosts - the host number
+ *
+ * Returns:
+ *  host - pointer to SCSI host structure
+ **************************************************************************/
+struct Scsi_Host *qla1280_do_device_init(struct pci_dev *pdev, 
+                                         Scsi_Host_Template *template,
+                                         int devnum, struct _qlaboards* bdp,
+                                         int num_hosts)
+{
+    struct Scsi_Host *host;
+    scsi_qla_host_t *ha;
+    device_reg_t *reg;
+
+    printk("qla1x160: Initializing ISP12160 on PCI bus %i, dev %i\n",
+           pdev->bus->number, PCI_SLOT(pdev->devfn));
+
+    host = scsi_register(template, sizeof(scsi_qla_host_t));
+    if (!host) { 
+        printk(KERN_WARNING "qla1280: Failed to register host, aborting.\n");
+        goto error;
+    }
+
+    scsi_set_pci_device(host, pdev);
+    ha = (scsi_qla_host_t *) host->hostdata;
+    /* Clear our data area */
+    memset(ha, 0, sizeof(scsi_qla_host_t));
+    /* Sanitize the information from PCI BIOS.  */
+    host->irq = pdev->irq;
+    ha->pci_bus = pdev->bus->number;
+    ha->pci_device_fn = pdev->devfn;
+    ha->pdev = pdev;
+    ha->device_id = bdp->device_id;
+    ha->devnum = devnum;	/* specifies microcode load address */
+
+    if(qla1280_mem_alloc(ha)) {
+        printk(KERN_INFO "qla1x160: Failed to get memory\n");
+        goto error;
+    }
+
+    ha->ports = bdp->numPorts; 
+    /* following needed for all cases of OS versions */
+    ha->host = host;
+    ha->host_no = host->host_no;
+
+    /* load the F/W, read paramaters, and init the H/W */
+    ha->instance = num_hosts;
+    if (qla1280_initialize_adapter(ha)) {
+        printk(KERN_INFO"qla1x160:Failed to initialize adapter\n");
+        goto error_mem_alloced;
+    }
+    host->max_channel = bdp->numPorts-1; 
+
+    /* Register our resources with Linux */
+    if( qla1280_register_with_Linux(ha, bdp->numPorts-1) ) {
+        printk(KERN_INFO "qla1x160: Failed to register resources\n");
+        goto error_mem_alloced;
+    }
+
+    reg = ha->iobase;
+    /* Disable ISP interrupts. */
+    qla1280_disable_intrs(ha);
+    /* Insure mailbox registers are free. */
+    WRT_REG_WORD(&reg->semaphore, 0);
+    WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
+    WRT_REG_WORD(&reg->host_cmd, HC_CLR_HOST_INT);
+
+    /* Enable chip interrupts. */
+    qla1280_enable_intrs(ha);
+    /* Insert new entry into the list of adapters */
+    ha->next = NULL;
+
+    return host;
+
+ error_mem_alloced:
+    qla1280_mem_free(ha);
+
+ error:
+    if (host) {
+        scsi_unregister(host);
+    }
+    return NULL;
 }
 
+
 /**************************************************************************
  * qla1280_detect
  *    This routine will probe for Qlogic 1280 SCSI host adapters.
@@ -690,42 +837,24 @@
 int
 qla1280_detect(Scsi_Host_Template *template)
 {
-    int num_hosts = 0;
+    struct pci_dev *pdev = NULL;
     struct Scsi_Host *host;
     scsi_qla_host_t *ha, *cur_ha;
     struct _qlaboards  *bdp;
-    int i,j;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-    unsigned short subsys;
-#endif
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,1,95)
-    unsigned int piobase;
-    unsigned char pci_bus, pci_devfn, pci_irq;
-    config_reg_t   *cfgp = 0;
-#endif
-    device_reg_t   *reg;
-    char   *cp;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
-    struct pci_dev *pdev = NULL;
-#else
-    int index;
-#endif
+    uint16_t subsys_vendor, subsys_device;
+    int num_hosts = 0;
+    int devnum = 0;
+
 #ifndef PCI_VENDOR_ID_AMI
 #define PCI_VENDOR_ID_AMI               0x101e
 #endif
 
     ENTER("qla1280_detect");
 
-    if (sizeof(srb_t) > sizeof(Scsi_Pointer) )
-      printk("qla1280_detect: [WARNING] srb_t Must Be Redefined");
-
-#ifdef CHECKSRBSIZE
-    if (sizeof(srb_t) > sizeof(Scsi_Pointer) )
-    {
-      printk("qla1280_detect:  srb_t Must Be Redefined - its too big");
-      return 0;
+    if (sizeof(srb_t) > sizeof(Scsi_Pointer)) {
+        printk("qla1280_detect: [WARNING] srb_t Must Be Redefined");
+        return 0;
     }
-#endif
 
 #ifdef MODULE
 	DEBUG(sprintf(debug_buff,"DEBUG: qla1280_detect starts at address = %p\n",qla1280_detect);)
@@ -744,20 +873,16 @@
     */
     if(options)
         qla1280_setup(options, NULL);
-    if(dummy_buffer[0] != 'P')
-        printk(KERN_WARNING "qla1280: Please read the file /usr/src/linux/drivers"
-                "/scsi/README.qla1280\n"
-                "qla1280: to see the proper way to specify options to the qla1280 "
-                "module\n"
-                "qla1280: Specifically, don't use any commas when passing arguments to\n"
-                "qla1280: insmod or else it might trash certain memory areas.\n");
+    printk(KERN_WARNING "qla1280: Please read the file /usr/src/linux/drivers"
+	   "/scsi/README.qla1280\n"
+	   "qla1280: to see the proper way to specify options to the qla1280 "
+	   "module\n"
+	   "qla1280: Specifically, don't use any commas when passing "
+	   "arguments to\n"
+	   "qla1280: insmod or else it might trash certain memory areas.\n");
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-    if ((int) !pcibios_present())
-#else
     if (!pci_present())
-#endif
     {
 	printk("scsi: PCI not present\n");
 	return 0;
@@ -771,229 +896,88 @@
     template->proc_name = "qla1280";
 #endif
 
-        /* 3.20 */
-        /* First Initialize QLA12160 on PCI Bus 1 Dev 2 */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
-        while ((pdev = pci_find_subsys(QLA1280_VENDOR_ID,
-                               bdp->device_id,  /* QLA12160 first in list */ 
-                               PCI_ANY_ID, 
-                               PCI_ANY_ID,pdev))) {
-
-                /* find QLA12160 device on PCI bus=1 slot=2 */
-                if ((pdev->bus->number     != 1)   ||
-                    (PCI_SLOT(pdev->devfn) != 2))  continue;
-
-                if (pci_enable_device(pdev)) goto find_devices;
-                printk("qla1x160: Initializing ISP12160 on PCI Bus 1, Dev 2\n");
-		host = scsi_register(template, sizeof(scsi_qla_host_t));
-                if (!host) { 
-			printk(KERN_WARNING "qla1280: Failed to register host, aborting.\n");
-                        return 0;
-                }
-		scsi_set_pci_device(host, pdev);
-		ha = (scsi_qla_host_t *) host->hostdata;
-		/* Clear our data area */
-		for( j =0, cp = (char *)ha;  j < sizeof(scsi_qla_host_t); j++)
-			*cp++ = 0;
-		/* Sanitize the information from PCI BIOS.  */
-		host->irq = pdev->irq;
-		host->io_port = pci_resource_start(pdev, 0);
-		ha->pci_bus = pdev->bus->number;
-		ha->pci_device_fn = pdev->devfn;
-		ha->pdev = pdev;
-		ha->device_id = bdp->device_id; /* QLA12160 first in list */
-    
-                ha->devnum = 0; // This priority ISP12160 is always devnum zero
-		if( qla1280_mem_alloc(ha) ) {
-  	          printk(KERN_INFO "qla1x160: Failed to get memory\n");
-		}                
-                ha->ports = bdp->numPorts; 
-                /* following needed for all cases of OS versions */
-                host->io_port &= PCI_BASE_ADDRESS_IO_MASK; 
-                ha->iobase = (device_reg_t *) host->io_port;
-                ha->host = host;
-                ha->host_no = host->host_no;
-                /* 3.20 zero out /proc/scsi/qla1280 counters */
-                ha->actthreads = 0;
-                ha->qthreads = 0;
-                ha->isr_count = 0; 
-
-                /* load the F/W, read paramaters, and init the H/W */
-                ha->instance = num_hosts;
-                if (qla1280_initialize_adapter(ha))
-                {
-                   printk(KERN_INFO "qla1x160: Failed to initialize QLA12160 on PCI Bus 1 Dev 2 \n");
-                   qla1280_mem_free(ha);
-                   scsi_unregister(host);
-                   goto find_devices;
-                }                
-                host->max_channel = bdp->numPorts-1; 
-		/* Register our resources with Linux */
-		if( qla1280_register_with_Linux(ha, bdp->numPorts-1) ) {
-		  printk(KERN_INFO "qla1x160: Failed to register resources for QLA12160 on PCI Bus 1 Dev 2\n");
-		  qla1280_mem_free(ha);
-		  scsi_unregister(host);
-		  goto find_devices;
-		}
-                reg = ha->iobase;
-                /* Disable ISP interrupts. */
-		qla1280_disable_intrs(ha);
-                /* Insure mailbox registers are free. */
-                WRT_REG_WORD(&reg->semaphore, 0);
-                WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
-                WRT_REG_WORD(&reg->host_cmd, HC_CLR_HOST_INT);
-
-                /* Enable chip interrupts. */
-		qla1280_enable_intrs(ha);
-                /* Insert new entry into the list of adapters */
-                ha->next = NULL;
-                /* this preferred device will always be the first one found */
-                cur_ha = qla1280_hostlist = ha;
-                num_hosts++;
+    /* 3.20 */
+    /* First Initialize QLA12160 on PCI Bus 1 Dev 2 */
+    while ((pdev = pci_find_subsys(QLA1280_VENDOR_ID,
+                                   bdp->device_id,/* QLA12160 first in list */ 
+                                   PCI_ANY_ID, PCI_ANY_ID, pdev))) {
+
+        /* find QLA12160 device on PCI bus=1 slot=2 */
+        if ((pdev->bus->number     != 1)   ||
+            (PCI_SLOT(pdev->devfn) != 2))
+            continue;
+
+        /* Bypass all AMI SUBSYS VENDOR IDs */
+        if (pdev->subsystem_vendor == PCI_VENDOR_ID_AMI) {
+            printk("qla1x160: Skip AMI SubSys Vendor ID Chip\n");
+            continue;
         }
-#endif
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
- find_devices:
-#endif
+        if (pci_enable_device(pdev))
+            goto find_devices;
 
-        pdev = NULL;
-	/* Try and find each different type of adapter we support */
-	for(i=0;bdp->device_id != 0 && i < NUM_OF_ISP_DEVICES;i++,bdp++) {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
-                /* PCI_SUBSYSTEM_IDS supported */ 
-		while ((pdev = pci_find_subsys(QLA1280_VENDOR_ID,
-			bdp->device_id, PCI_ANY_ID, PCI_ANY_ID, pdev) )) {
- 			if (pci_enable_device(pdev)) continue;
-#else
-		while ((pdev = pci_find_device(QLA1280_VENDOR_ID,
-			bdp->device_id, pdev ) ))  {
-#endif /* 2,3,18 */
-#else  /* less than 2,1,95 */  
-		while (!(pcibios_find_device(QLA1280_VENDOR_ID,
-			bdp->device_id,
-			index++, &pci_bus, &pci_devfn)) )  {
-#endif /* 2,1,95 */ 
-                /* found a adapter */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
-		  /* If it's an AMI SubSys Vendor ID adapter, skip it. */
-                  if (pdev->subsystem_vendor == PCI_VENDOR_ID_AMI) 
-                    { 
-                      printk("qla1x160: Skip AMI SubSys Vendor ID Chip\n");
-                      continue;
-                    }
+        host = qla1280_do_device_init(pdev, template, devnum, bdp, num_hosts);
+        if (!host)
+          continue;
+        ha = (scsi_qla_host_t *) host->hostdata;
+
+        /* this preferred device will always be the first one found */
+        cur_ha = qla1280_hostlist = ha;
+        num_hosts++;
+    }
 
-                  /* 3.20 and 3.23 */
-		  /* skip QLA12160 already initialized on PCI Bus 1 Dev 2 */
-                  /* since we already initialized and presented it */
-                  if ((bdp->device_id        == QLA12160_DEVICE_ID) &&
-                      (pdev->bus->number     == 1)   &&
-                      (PCI_SLOT(pdev->devfn) == 2))  continue;
-
- 		  printk("qla1x160: Supported Device Found VID=%x DID=%x SSVID=%x SSDID=%x\n",
-			pdev->vendor, pdev->device,
-			pdev->subsystem_vendor, pdev->subsystem_device); 
+ find_devices:
 
+    pdev = NULL;
+    /* Try and find each different type of adapter we support */
+    for(devnum = 0; bdp->device_id != 0 && devnum < NUM_OF_ISP_DEVICES;
+        devnum++, bdp++) {
+        /* PCI_SUBSYSTEM_IDS supported */ 
+        while ((pdev = pci_find_subsys(QLA1280_VENDOR_ID, bdp->device_id,
+                                       PCI_ANY_ID, PCI_ANY_ID, pdev) )) {
+            if (pci_enable_device(pdev))
+                continue;
+            /* found an adapter */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+            subsys_vendor = pdev->subsystem_vendor;
+            subsys_device = pdev->subsystem_device;
 #else
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
-                  printk("qla1x160: Supported Device Found\n");
-		  pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID,
-                                       &subsys);
-		  /* Bypass all AMI SUBSYS VENDOR IDs */
-                  if (subsys == PCI_VENDOR_ID_AMI) 
-                    { 
-                      printk("qla1x160: Skip AMI SubSys Vendor ID  Chip\n");
-                      continue;
-                    }
-#endif /* 2,1,95 */
+            pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID,&subsys_vendor);
+            pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &subsys_device);
 #endif /* 2,3,18 */
-		host = scsi_register(template, sizeof(scsi_qla_host_t));
-		ha = (scsi_qla_host_t *) host->hostdata;
-		/* Clear our data area */
-		for( j =0, cp = (char *)ha;  j < sizeof(scsi_qla_host_t); j++)
-			*cp++ = 0;
-		/* Sanitize the information from PCI BIOS.  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
-		host->irq = pdev->irq;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-                host->io_port = (unsigned int) pdev->base_address[0];
-#else
-		host->io_port = pci_resource_start(pdev, 0);
-#endif
-		ha->pci_bus = pdev->bus->number;
-		ha->pci_device_fn = pdev->devfn;
-		ha->pdev = pdev;
-#else
-		pcibios_read_config_byte(pci_bus, pci_devfn, OFFSET(cfgp->interrupt_line), &pci_irq);
-		pcibios_read_config_dword(pci_bus, pci_devfn, OFFSET(cfgp->base_port), &piobase);
-		host->irq = pci_irq;
-		host->io_port = (unsigned int) piobase;
-		host->io_port &= PCI_BASE_ADDRESS_IO_MASK;
-		ha->pci_bus = pci_bus;
-		ha->pci_device_fn = pci_devfn;
-#endif
-		ha->device_id = bdp->device_id;
-                ha->devnum = i; // specifies microcode load address
-
-		if( qla1280_mem_alloc(ha) ) {
-  	          printk(KERN_INFO "qla1x160: Failed to get memory\n");
-		}
-                
-                ha->ports = bdp->numPorts; 
-                /* following needed for all cases of OS versions */
-                host->io_port &= PCI_BASE_ADDRESS_IO_MASK; 
-                ha->iobase = (device_reg_t *) host->io_port;
-                ha->host = host;
-                ha->host_no = host->host_no;
-
-                /* load the F/W, read paramaters, and init the H/W */
-                ha->instance = num_hosts;
-                if (qla1280_initialize_adapter(ha))
-                {
-                   printk(KERN_INFO "qla1x160:Failed to initialize adapter\n");
-                   qla1280_mem_free(ha);
-                   scsi_unregister(host);
-                   continue;
-                }
-                
-                host->max_channel = bdp->numPorts-1; 
-		/* Register our resources with Linux */
-		if( qla1280_register_with_Linux(ha, bdp->numPorts-1) ) {
-		  printk(KERN_INFO "qla1x160: Failed to register resources\n");
-		  qla1280_mem_free(ha);
-		  scsi_unregister(host);
-		  continue;
-		}
+            /* skip QLA12160 already initialized on PCI Bus 1 Dev 2 */
+            /* since we already initialized and presented it */
+            if ((bdp->device_id        == QLA12160_DEVICE_ID) &&
+                (pdev->bus->number     == 1)   &&
+                (PCI_SLOT(pdev->devfn) == 2))
+                continue;
+
+            /* Bypass all AMI SUBSYS VENDOR IDs */
+            if (subsys_vendor == PCI_VENDOR_ID_AMI) {
+                printk("qla1x160: Skip AMI SubSys Vendor ID Chip\n");
+                continue;
+            }
+            printk("qla1x160: Supported Device Found VID=%x DID=%x "
+                   "SSVID=%x SSDID=%x\n",pdev->vendor, pdev->device,
+                   subsys_vendor, subsys_device); 
+
+            host = qla1280_do_device_init(pdev, template, devnum, bdp,
+                                          num_hosts);
+            if (!host)
+                continue;
+            ha = (scsi_qla_host_t *) host->hostdata;
 
-                reg = ha->iobase;
-                /* Disable ISP interrupts. */
-		qla1280_disable_intrs(ha);
-
-                /* Insure mailbox registers are free. */
-                WRT_REG_WORD(&reg->semaphore, 0);
-                WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
-                WRT_REG_WORD(&reg->host_cmd, HC_CLR_HOST_INT);
-
-                /* Enable chip interrupts. */
-		qla1280_enable_intrs(ha);
-               
-                /* Insert new entry into the list of adapters */
-                ha->next = NULL;
-                if( qla1280_hostlist == NULL )
-                {
-                    cur_ha = qla1280_hostlist = ha;
-                }
-                else
-                {
-                    cur_ha = qla1280_hostlist;
-                    while( cur_ha->next != NULL )
-                        cur_ha = cur_ha->next;
-                    cur_ha->next = ha;
-                }
-                num_hosts++;
-            }  /* end of WHILE */
-        } /* end of FOR */
+            if(qla1280_hostlist == NULL) {
+                cur_ha = qla1280_hostlist = ha;
+            } else {
+                cur_ha = qla1280_hostlist;
+                while(cur_ha->next != NULL)
+                    cur_ha = cur_ha->next;
+                cur_ha->next = ha;
+            }
+            num_hosts++;
+        }  /* end of WHILE */
+    } /* end of FOR */
 
     LEAVE("qla1280_detect");
     return num_hosts; 
@@ -1014,50 +998,55 @@
 *  0 - Sucessfully reserved resources.
 *  1 - Failed to reserved a resource.
 **************************************************************************/
-STATIC uint8_t  qla1280_register_with_Linux(scsi_qla_host_t *ha, uint8_t maxchannels)
+static int qla1280_register_with_Linux(scsi_qla_host_t *ha,
+                                       unsigned int maxchannels)
 {
+    struct Scsi_Host *host = ha->host;
 
-	struct Scsi_Host *host = ha->host;
-
-	host->can_queue = 0xfffff;  /* unlimited  */
-	host->cmd_per_lun = 1;
-       host->select_queue_depths = qla1280_select_queue_depth;
+    host->can_queue = 0xfffff;  /* unlimited  */
+    host->cmd_per_lun = 1;
+    host->select_queue_depths = qla1280_select_queue_depth;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-        host->base = (unsigned char *) ha->mmpbase;
+    host->base = (unsigned char *) ha->mmpbase;
 #else
-        host->base = (u_long) ha->mmpbase;
+    host->base = (unsigned long) ha->mmpbase;
+#endif
+    host->max_channel = maxchannels; 
+    host->max_lun = MAX_LUNS-1; 
+    host->unique_id = ha->instance;
+    host->max_id = MAX_TARGETS; 
+    host->unique_id = ha->instance;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,7)
+    host->max_sectors = 1024;
 #endif
-	host->max_channel = maxchannels; 
-       host->max_lun = MAX_LUNS-1; 
-	host->unique_id = ha->instance;
-       host->max_id = MAX_TARGETS; 
-       host->unique_id = ha->instance;
-
-	/* set our host ID  (need to do something about our two IDs) */
-       host->this_id = ha->bus_settings[0].id;
-       /* Register the IRQ with Linux (sharable) */
-       if ( request_irq(host->irq, qla1280_intr_handler, SA_INTERRUPT| SA_SHIRQ, "qla1280", ha))
-       {
-          printk("qla1280 : Failed to reserved interrupt %d already in use\n", host->irq);
-          qla1280_mem_free(ha);
-          scsi_unregister(host);
-	     return 1;
-       }
 
-       /* Register the I/O space with Linux */
-       if (check_region(host->io_port, 0xff))
-       {
-           printk("qla1280 : Failed to reserved i/o region 0x%04lx-0x%04lx already in use\n",
-              host->io_port, host->io_port + 0xff);
-           free_irq(host->irq, NULL);
-           qla1280_mem_free(ha);
-           scsi_unregister(host);
-	     return 1;
-       }
+    /* set our host ID  (need to do something about our two IDs) */
+    host->this_id = ha->bus_settings[0].id;
+    /* Register the IRQ with Linux (sharable) */
+    if (request_irq(host->irq, qla1280_intr_handler, SA_SHIRQ, "qla1280", ha))
+    {
+      printk("qla1280 : Failed to reserve interrupt %d already in use\n", host->irq);
+      qla1280_mem_free(ha);
+      scsi_unregister(host);
+      return 1;
+    }
 
-       request_region(host->io_port, 0xff, "qla1280");
+#if !MEMORY_MAPPED_IO
+    /* Register the I/O space with Linux */
+    if (check_region(host->io_port, 0xff))
+    {
+      printk("qla1280 : Failed to reserved i/o region 0x%04lx-0x%04lx already"
+             " in use\n", host->io_port, host->io_port + 0xff);
+      free_irq(host->irq, NULL);
+      qla1280_mem_free(ha);
+      scsi_unregister(host);
+      return 1;
+    }
 
-	return 0;
+    request_region(host->io_port, 0xff, "qla1280");
+#endif
+
+    return 0;
 }
 
 
@@ -1083,24 +1072,19 @@
     if(host->irq)
         free_irq(host->irq, ha);
 
-    /* release io space registers  */
-    if( host->io_port )
-        release_region(host->io_port, 0xff);
-
 #if MEMORY_MAPPED_IO
     if(ha->mmpbase)
-    {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
-        vfree((void *) (((unsigned long) ha->mmpbase) & PAGE_MASK));
-#else
         iounmap((void *) (((unsigned long) ha->mmpbase) & PAGE_MASK));
-#endif
-    }
+#else
+    /* release io space registers  */
+    if( host->io_port )
+        release_region(host->io_port, 0xff);
 #endif /* MEMORY_MAPPED_IO */
+
     qla1280_mem_free(ha);
 
     ENTER("qla1280_release");
-    return(0);
+    return 0;
 }
 
 /**************************************************************************
@@ -1110,22 +1094,23 @@
 const char *
 qla1280_info(struct Scsi_Host *host)
 {
-    static char qla1280_buffer[125];
+    static char qla1280_scsi_name_buffer[125];
     char *bp;
     scsi_qla_host_t *ha;
     qla_boards_t   *bdp; 
 
-    bp = &qla1280_buffer[0];
+    bp = &qla1280_scsi_name_buffer[0];
     ha = (scsi_qla_host_t *)host->hostdata;
     bdp = &QL1280BoardTbl[ha->devnum];
-    memset(bp, 0, sizeof(qla1280_buffer));
+    memset(bp, 0, sizeof(qla1280_scsi_name_buffer));
     sprintf(bp,
             "QLogic %s PCI to SCSI Host Adapter: bus %d device %d irq %d\n"
             "       Firmware version: %2d.%02d.%02d, Driver version %s",
-            (char *)&bdp->bdName[0], ha->pci_bus, (ha->pci_device_fn & 0xf8) >> 3, host->irq,
+            (char *)&bdp->bdName[0], ha->pci_bus,
+	    (ha->pci_device_fn & 0xf8) >> 3, host->irq,
             bdp->fwver[0],bdp->fwver[1],bdp->fwver[2],
             QLA1280_VERSION);
-    return(bp);
+    return bp;
 }
 
 /**************************************************************************
@@ -1144,23 +1129,20 @@
 {
     scsi_qla_host_t *ha;
     srb_t  *sp;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
     struct Scsi_Host *host;
-    uint32_t        b, t, l;
+    unsigned int b, t, l;
     scsi_lu_t       *q;
     u_long          handle;
 
     /*ENTER("qla1280_queuecommand");
-      COMTRACE('C')*/ 
+      */
 
     host = cmd->host;
     ha = (scsi_qla_host_t *) host->hostdata;
 
     /* send command to adapter */
     sp = (srb_t *) CMD_SP(cmd);
-    sp->cmd =  cmd;
+    sp->cmd = cmd;
     cmd->scsi_done = fn;
     if (cmd->flags == 0)  /* new command */
     {
@@ -1175,18 +1157,16 @@
     l = SCSI_LUN_32(cmd);
     if((q = LU_Q(ha, b, t, l)) == NULL )
     {
-        DRIVER_LOCK
-        if( (q = (scsi_lu_t *)KMALLOC(sizeof(struct scsi_lu))) )
+        if( (q = (scsi_lu_t *)kmalloc(sizeof(struct scsi_lu), GFP_ATOMIC)))
         {
            LU_Q(ha, b, t, l) = q;
-           BZERO(q,sizeof(struct scsi_lu));
-           DEBUG(sprintf(debug_buff,"Allocate new device queue 0x%x\n\r",q));
+           memset(q, 0, sizeof(struct scsi_lu));
+           DEBUG(sprintf(debug_buff,"Allocate new device queue 0x%p\n",(void *)q));
            DEBUG(qla1280_print(debug_buff));
-           DRIVER_UNLOCK
         }
         else
         {
-            CMD_RESULT(cmd) = (int) (DID_BUS_BUSY << 16);
+            CMD_RESULT(cmd) = DID_BUS_BUSY << 16;
             qla1280_done_q_put(sp, &ha->done_q_first, &ha->done_q_last);
 /* 3.22 */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0) /* 3.22 */
@@ -1195,7 +1175,6 @@
             schedule_task(&ha->run_qla_bh); /* 3.22 */
 #endif /* 3.22 */
             ha->flags.dpc_sched = TRUE;
-            DRIVER_UNLOCK
             return(0);
         }
     }
@@ -1207,21 +1186,18 @@
     /* add the command to our queue */
     ha->qthreads++;
     qla1280_putq_t(q,sp);
-    
+
     DEBUG(sprintf(debug_buff,
-     "qla1280_QC: t=%x CDB=%x I/OSize=0x%x haQueueCount=0x%x\n\r",
+     "qla1280_QC: t=%x CDB=%x I/OSize=0x%x haQueueCount=0x%lx\n",
      t,cmd->cmnd[0],CMD_XFRLEN(cmd),ha->qthreads));
     DEBUG(qla1280_print(debug_buff));
 
     /* send command to adapter */
-    DRIVER_LOCK
-        if (q->q_outcnt == 0)
-            qla1280_restart_queues(ha);
-    DRIVER_UNLOCK
-    
-    
+    if (q->q_outcnt == 0)
+      qla1280_restart_queues(ha);
+
     /*LEAVE("qla1280_queuecommand");*/
-    return (0);
+    return 0;
 }
 
 /**************************************************************************
@@ -1233,78 +1209,83 @@
 {
     scsi_qla_host_t *ha;
     srb_t  *sp;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
     struct Scsi_Host *host;
-    uint32_t        b, t, l;
+    unsigned int b, t, l;
     scsi_lu_t       *q;
     int return_status = SCSI_ABORT_SUCCESS;
     int found = 0;
     int i;
-    u_long     handle;
-    u_short    data;
+    unsigned char *handle;
+    u16 data;
 
     ENTER("qla1280_abort");
-    COMTRACE('A')
     ha = (scsi_qla_host_t *) cmd->host->hostdata;
     host = cmd->host;
-    DRIVER_LOCK
 
     /* Get the SCSI request ptr */
     sp = (srb_t *) CMD_SP(cmd);
-    handle = (u_long) CMD_HANDLE(cmd);
+    handle = CMD_HANDLE(cmd);
     if (qla1280_verbose)
-        printk("scsi(%d): ABORT Command=0x%lx, handle=0x%lx\n",(int)ha->host_no,(long)cmd,handle);
+        printk("scsi(%li): ABORT Command=0x%p, handle=0x%p\n",
+               ha->host_no, (void *)cmd, (void *)handle);
 
     /* Check for pending interrupts. */
-    if( handle == 0L )
+    if (handle == NULL)
     {
-    COMTRACE('a')
-        /* we never got this command */
-        printk(KERN_INFO "qla1280: Aborting a NULL handle\n");
-        DRIVER_UNLOCK
-                return(SCSI_ABORT_NOT_RUNNING);  /* no action - we don't have command */
+      /* we never got this command */
+      printk(KERN_INFO "qla1280: Aborting a NULL handle\n");
+      return SCSI_ABORT_NOT_RUNNING;  /* no action - we don't have command */
     }
     data = qla1280_debounce_register(&ha->iobase->istatus);
-    if( !(ha->flags.in_isr) && (data & RISC_INT) )
-    {
+    /*
+     * The io_request_lock is held when the reset handler is called, hence
+     * the interrupt handler cannot be running in parallel as it also
+     * grabs the lock. No reason to play funny games with set_bit() in order
+     * to test for interrupt handler entry as the driver used to do here.
+     * /Jes
+     */
+    if (data & RISC_INT) {
         /* put any pending command in done queue */
-        qla1280_isr(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+        qla1280_isr(ha, (srb_t **)&ha->done_q_first,
+		    (srb_t **)&ha->done_q_last);
     }
 
-    handle = (u_long) CMD_HANDLE(cmd);
+    /*
+     * This seems unnecessary, it's not used below! / Jes
+     */
+#ifdef UNUSED
+    handle = CMD_HANDLE(cmd);
+#endif
 
     /* Generate LU queue on bus, target, LUN */
     b = SCSI_BUS_32(cmd);
     t = SCSI_TCN_32(cmd);
     l = SCSI_LUN_32(cmd);
-    if((q = LU_Q(ha, b, t, l)) == NULL )
+    if((q = LU_Q(ha, b, t, l)) == NULL)
     {
-    COMTRACE('a')
-        /* No lun queue -- command must not be active */
-        DRIVER_UNLOCK
-        printk(KERN_WARNING "qla1280 (%d:%d:%d): No LUN queue for the specified device\n",(int)b,(int)t,(int)l);
-        return(SCSI_ABORT_NOT_RUNNING);  /* no action - we don't have command */
+	/* No lun queue -- command must not be active */
+	printk(KERN_WARNING "qla1280 (%d:%d:%d): No LUN queue for the "
+	       "specified device\n", (int)b, (int)t, (int)l);
+	return SCSI_ABORT_NOT_RUNNING; /* no action - we don't have command */
     }
 
 #if AUTO_ESCALATE_ABORT
-    if ( (sp->flags & SRB_ABORTED) )
+    if ((sp->flags & SRB_ABORTED))
     {
-        DRIVER_UNLOCK
-        DEBUG(qla1280_print("qla1280_abort: Abort escalayted - returning SCSI_ABORT_SNOOZE.\n\r"));
-        return(SCSI_ABORT_SNOOZE);
+        DEBUG(qla1280_print("qla1280_abort: Abort escalayted - returning "
+			    "SCSI_ABORT_SNOOZE.\n"));
+        return SCSI_ABORT_SNOOZE;
     }
 #endif
 
-    if ( (sp->flags & SRB_ABORT_PENDING) )
+    if ((sp->flags & SRB_ABORT_PENDING))
     {
-    COMTRACE('a')
-        DRIVER_UNLOCK
-        if( qla1280_verbose  )
-            printk("scsi(): Command has a pending abort message - ABORT_PENDING.\n");
-        DEBUG(qla1280_print("qla1280: Command has a pending abort message - ABORT_PENDING.\n\r"));
-        return(SCSI_ABORT_PENDING);
+      if(qla1280_verbose)
+        printk("scsi(): Command has a pending abort message - ABORT_"
+	       "PENDING.\n");
+        DEBUG(qla1280_print("qla1280: Command has a pending abort message"
+			    " - ABORT_PENDING.\n"));
+        return SCSI_ABORT_PENDING;
     }
 
 #if  STOP_ON_ABORT 
@@ -1318,12 +1299,12 @@
     * but; since our sp contains the cmd ptr, we can just remove it from our
     * LUN queue.
     */
-    if( !(sp->flags&SRB_SENT) )
+    if(!(sp->flags & SRB_SENT))
     { 
         found++;
         if( qla1280_verbose  )
             printk("scsi(): Command returned from queue aborted.\n");
-        DEBUG(qla1280_print("qla1280: Command returned from queue aborted.\n\r"));
+        DEBUG(qla1280_print("qla1280: Command returned from queue aborted.\n"));
         /* Remove srb from SCSI LU queue. */
         qla1280_removeq(q, sp);
         sp->flags |=  SRB_ABORTED;
@@ -1338,7 +1319,7 @@
             if( sp == ha->outstanding_cmds[i] )
             {
                 found++;
-                DEBUG(qla1280_print("qla1280: RISC aborting command.\n\r"));
+                DEBUG(qla1280_print("qla1280: RISC aborting command.\n"));
                 qla1280_abort_command(ha,sp);
                 return_status = SCSI_ABORT_PENDING;
                 break;
@@ -1349,24 +1330,21 @@
 #if  STOP_ON_ABORT 
     qla1280_panic("qla1280_abort",ha->host);
 #endif
-    if ( found == 0 )
+    if (found == 0)
         return_status = SCSI_ABORT_NOT_RUNNING;  /* no action - we don't have command */
 
-    DEBUG(sprintf(debug_buff, "qla1280_abort: Aborted status returned = 0x%x.\n\r",return_status));
+    DEBUG(sprintf(debug_buff, "qla1280_abort: Aborted status returned = 0x%x.\n",return_status));
     DEBUG(qla1280_print(debug_buff));
 
-    if( ha->done_q_first )
+    if (ha->done_q_first)
        qla1280_done(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
-    if ( found )
-    {
+    if (found) {
         qla1280_restart_queues(ha);
     }
     ha->flags.in_abort = FALSE;
-    DRIVER_UNLOCK
 
     LEAVE("qla1280_abort");
-    COMTRACE('a')
-    return(return_status);
+    return return_status;
 }
 
 /**************************************************************************
@@ -1392,35 +1370,31 @@
 qla1280_reset(Scsi_Cmnd *cmd, unsigned int flags)
 {
     scsi_qla_host_t *ha;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
-    uint32_t        b, t, l;
-    srb_t  *sp;
+    unsigned int b, t, l;
+    srb_t *sp;
     typedef enum
     {
         ABORT_DEVICE = 1, 
-                DEVICE_RESET = 2, 
-                BUS_RESET    = 3, 
-                ADAPTER_RESET= 4,
-                RESET_DELAYED= 5,
-                FAIL         = 6
+	DEVICE_RESET = 2, 
+	BUS_RESET    = 3, 
+	ADAPTER_RESET= 4,
+	RESET_DELAYED= 5,
+	FAIL         = 6
     } action_t;
-    action_t     action = ADAPTER_RESET;
-    u_short    data;
-    scsi_lu_t       *q;
+    action_t action = ADAPTER_RESET;
+    u16 data;
+    scsi_lu_t *q;
     int result;
 
 
     ENTER("qla1280_reset");
-    COMTRACE('R')
     if (qla1280_verbose)
-        printk("scsi(): Resetting Cmnd=0x%lx, Handle=0x%lx, flags=0x%x\n",(long)cmd,(long)CMD_HANDLE(cmd),flags);
-    if ( cmd == NULL )
-    {
+        printk("scsi(): Resetting Cmnd=0x%lx, Handle=0x%lx, flags=0x%x\n",
+	       (long)cmd,(long)CMD_HANDLE(cmd),flags);
+    if (cmd == NULL) {
         printk(KERN_WARNING "(scsi?:?:?:?) Reset called with NULL Scsi_Cmnd "
                 "pointer, failing.\n");
-        return(SCSI_RESET_SNOOZE);
+        return SCSI_RESET_SNOOZE;
     }
     ha = (scsi_qla_host_t *) cmd->host->hostdata;
     sp = (srb_t *) CMD_SP(cmd);
@@ -1429,36 +1403,38 @@
     qla1280_panic("qla1280_reset",ha->host);
 #endif 
 
-    DRIVER_LOCK
     /* Check for pending interrupts. */
     data = qla1280_debounce_register(&ha->iobase->istatus);
-    if( !(ha->flags.in_isr) && (data & RISC_INT) )
-    {
-        qla1280_isr(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
-    }
-    DRIVER_UNLOCK
+    /*
+     * The io_request_lock is held when the reset handler is called, hence
+     * the interrupt handler cannot be running in parallel as it also
+     * grabs the lock. /Jes
+     */
+    if (data & RISC_INT)
+	qla1280_isr(ha, (srb_t **)&ha->done_q_first,
+		    (srb_t **)&ha->done_q_last);
 
     /*
-    * Determine the suggested action that the mid-level driver wants
-    * us to perform.
-    */
-    if( CMD_HANDLE(cmd) == (unsigned char *) 0  )
+     * Determine the suggested action that the mid-level driver wants
+     * us to perform.
+     */
+    if (CMD_HANDLE(cmd) == NULL)
     {
-        /* 
-        * if mid-level driver called reset with a orphan SCSI_Cmnd 
-        * (i.e. a command that's not pending ), so perform the 
-        * function specified.
-        */
+       /* 
+	* if mid-level driver called reset with a orphan SCSI_Cmnd 
+	* (i.e. a command that's not pending ), so perform the 
+	* function specified.
+	*/
         if( (flags & SCSI_RESET_SUGGEST_HOST_RESET) )
             action = ADAPTER_RESET;
         else 
             action = BUS_RESET;
     }
     else
-    { /* 
-        * Mid-level driver has called reset with this SCSI_Cmnd and 
-        * its pending.
-        */
+    {  /* 
+	* Mid-level driver has called reset with this SCSI_Cmnd and 
+	* its pending.
+	*/
         if( flags & SCSI_RESET_SUGGEST_HOST_RESET )
             action = ADAPTER_RESET;
         else if( flags & SCSI_RESET_SUGGEST_BUS_RESET )
@@ -1473,15 +1449,17 @@
     q = LU_Q(ha, b, t, l);
 
 #if AUTO_ESCALATE_RESET
-    if ( (action & DEVICE_RESET) && (q->q_flag & QLA1280_QRESET) )
+    if ((action & DEVICE_RESET) && (q->q_flag & QLA1280_QRESET))
     {
         printk(KERN_INFO "qla1280(%d): Bus device reset already sent to " "device, escalating.\n", (int)ha->host_no);
         action = BUS_RESET;
     }
-    if ( (action & DEVICE_RESET) && (sp->flags & SRB_ABORT_PENDING) )
+    if ((action & DEVICE_RESET) && (sp->flags & SRB_ABORT_PENDING))
     {
-        printk(KERN_INFO "qla1280(%d):Have already attempted to reach " "device with abort device\n", (int)ha->host_no);
-        printk(KERN_INFO "qla1280(%d):message, will escalate to BUS " "RESET.\n",(int) ha->host_no);
+        printk(KERN_INFO "qla1280(%d):Have already attempted to reach "
+	       "device with abort device\n", (int)ha->host_no);
+        printk(KERN_INFO "qla1280(%d):message, will escalate to BUS "
+	       "RESET.\n", (int)ha->host_no);
         action = BUS_RESET;
     }
 #endif
@@ -1490,11 +1468,10 @@
     *  By this point, we want to already know what we are going to do,
     *  so we only need to perform the course of action.
     */
-    DRIVER_LOCK
     result = SCSI_RESET_ERROR;
     switch (action)
     {
-        case FAIL:
+	case FAIL:
             break;
 
         case RESET_DELAYED:
@@ -1504,64 +1481,71 @@
         case ABORT_DEVICE:
             ha->flags.in_reset = TRUE;
             if (qla1280_verbose)
-                printk(KERN_INFO "scsi(%d:%d:%d:%d): Queueing abort device command.\n", (int)ha->host_no,(int)b,(int)t,(int)l); 
-            qla1280_abort_queue_single(ha,b,t,l,DID_ABORT);
-            if( qla1280_abort_device(ha, b, t, l) == 0)
+                printk(KERN_INFO "scsi(%d:%d:%d:%d): Queueing abort device "
+		       "command.\n", (int)ha->host_no,(int)b,(int)t,(int)l); 
+            qla1280_abort_queue_single(ha, b, t, l, DID_ABORT);
+            if (qla1280_abort_device(ha, b, t, l) == 0)
                 result = SCSI_RESET_PENDING;
             break;
 
         case DEVICE_RESET:
             if (qla1280_verbose)
-                printk(KERN_INFO "scsi(%d:%d:%d:%d): Queueing device reset command.\n",(int) ha->host_no,(int)b,(int)t,(int)l); 
+                printk(KERN_INFO "scsi(%d:%d:%d:%d): Queueing device reset "
+		       "command.\n", (int)ha->host_no,
+		       (int)b, (int)t, (int)l); 
             ha->flags.in_reset = TRUE;
             for (l = 0; l < MAX_LUNS; l++)
-                qla1280_abort_queue_single(ha,b,t,l,DID_ABORT);
-            if( qla1280_device_reset(ha, b, t) == 0 ) 
+                qla1280_abort_queue_single(ha, b, t, l, DID_ABORT);
+            if (qla1280_device_reset(ha, b, t) == 0)
                 result = SCSI_RESET_PENDING;
             q->q_flag |= QLA1280_QRESET;
             break;
 
-        case BUS_RESET:
+	case BUS_RESET:
                 if (qla1280_verbose)
-                    printk(KERN_INFO "qla1280(%d:%d:%d:%d): Issuing BUS DEVICE RESET.\n",(int) ha->host_no,(int)b,(int)t,(int)l); 
+                    printk(KERN_INFO "qla1280(%d:%d:%d:%d): Issuing BUS "
+			   "DEVICE RESET.\n", (int)ha->host_no,
+			   (int)b, (int)t, (int)l); 
             ha->flags.in_reset = TRUE;
             for (t = 0; t < MAX_TARGETS; t++)
                 for (l = 0; l < MAX_LUNS; l++)
-                    qla1280_abort_queue_single(ha,b,t,l,DID_RESET);
-                qla1280_bus_reset(ha, b);
-                /*
-                * The bus reset routine returns all the outstanding commands back
-                * with "DID_RESET" in the status field after a short delay
-                * by the firmware. If the mid-level time out the SCSI reset before
-                * our delay we may need to ignore it.
-                */
-                /* result = SCSI_RESET_PENDING | SCSI_RESET_BUS_RESET; */
-                result = SCSI_RESET_SUCCESS | SCSI_RESET_BUS_RESET;
-                mdelay(4 * 1000); barrier();
-                if( flags & SCSI_RESET_SYNCHRONOUS )
-                {
-                  CMD_RESULT(cmd) = (int) (DID_BUS_BUSY << 16);
-                  (*(cmd)->scsi_done)(cmd); 
-                }
-                /* ha->reset_start = jiffies; */
-                break;
+                    qla1280_abort_queue_single(ha, b, t, l, DID_RESET);
+	    qla1280_bus_reset(ha, b);
+	    /*
+	     * The bus reset routine returns all the outstanding commands back
+	     * with "DID_RESET" in the status field after a short delay
+	     * by the firmware. If the mid-level time out the SCSI reset before
+	     * our delay we may need to ignore it.
+	     */
+	    /* result = SCSI_RESET_PENDING | SCSI_RESET_BUS_RESET; */
+	    result = SCSI_RESET_SUCCESS | SCSI_RESET_BUS_RESET;
+	    mdelay(4 * 1000);
+	    barrier();
+	    if(flags & SCSI_RESET_SYNCHRONOUS) {
+		CMD_RESULT(cmd) = DID_BUS_BUSY << 16;
+		(*(cmd)->scsi_done)(cmd); 
+	    }
+	    /* ha->reset_start = jiffies; */
+	    break;
+
+	case ADAPTER_RESET:
+	default:
+	    if (qla1280_verbose) {
+		printk(KERN_INFO "scsi(%d:%d:%d:%d): Issued an ADAPTER "
+		       "RESET.\n", (int)ha->host_no, (int)b, (int)t, (int)l); 
+		printk(KERN_INFO "scsi(%d:%d:%d:%d): I/O processing will "
+		       "continue automatically.\n",
+		       (int)ha->host_no, (int)b, (int)t, (int)l); 
+	    }
+	    ha->flags.reset_active = TRUE;
+	    /* 
+	     * We restarted all of the commands automatically, so the 
+	     * mid-level code can expect completions momentitarily.
+	     */
+	    if(qla1280_abort_isp(ha) == 0)
+		result = SCSI_RESET_SUCCESS | SCSI_RESET_HOST_RESET;
 
-            case ADAPTER_RESET:
-            default:
-                if (qla1280_verbose)
-                {
-                    printk(KERN_INFO "scsi(%d:%d:%d:%d): Issued an ADAPTER RESET.\n",(int) ha->host_no,(int)b,(int)t,(int)l); 
-                    printk(KERN_INFO "scsi(%d:%d:%d:%d): I/O processing will continue automatically.\n",(int) ha->host_no,(int)b,(int)t,(int)l); 
-                }
-                ha->flags.reset_active = TRUE;
-                /* 
-                * We restarted all of the commands automatically, so the mid-level code can expect 
-                * completions momentitarily.
-                */
-                if( qla1280_abort_isp(ha) == 0 )
-                    result = SCSI_RESET_SUCCESS | SCSI_RESET_HOST_RESET;
-
-                        ha->flags.reset_active = FALSE;
+	    ha->flags.reset_active = FALSE;
     }
 
     if( ha->done_q_first ) 
@@ -1569,12 +1553,10 @@
     qla1280_restart_queues(ha);
     ha->flags.in_reset = FALSE;
     
-DRIVER_UNLOCK
     DEBUG(printk("RESET returning %d\n", result)); 
 
-    COMTRACE('r')
     LEAVE("qla1280_reset");
-    return( result );
+    return result;
 }
 
 /**************************************************************************
@@ -1586,7 +1568,7 @@
 {
     int heads, sectors, cylinders;
 
-            heads = 64;
+    heads = 64;
     sectors = 32;
     cylinders = disk->capacity / (heads * sectors);
     if (cylinders > 1024)
@@ -1602,7 +1584,7 @@
     geom[1] = sectors;
     geom[2] = cylinders;
 
-    return (0);
+    return 0;
 }
 /**************************************************************************
  * qla1280_intr_handler
@@ -1610,97 +1592,45 @@
  **************************************************************************/
 void qla1280_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
     scsi_qla_host_t *ha;
-    u_short    data;
     device_reg_t *reg;
+    unsigned long cpu_flags;
+    u16 data;
 
     ENTER_INTR("qla1280_intr_handler");
-    COMTRACE('I')
     ha = (scsi_qla_host_t *) dev_id;
-    if(!ha)
-    {
+    if(!ha) {
         printk(KERN_INFO "scsi(): Interrupt with NULL host ptr\n");
-        COMTRACE('X')
         return;
     }
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,95)
     spin_lock_irqsave(&io_request_lock, cpu_flags);
-    if(test_and_set_bit(QLA1280_IN_ISR_BIT, &ha->flags))
-    {
-        COMTRACE('X')
-        spin_unlock_irqrestore(&io_request_lock, cpu_flags);
-        return;
-    }
-    ha->isr_count++;
-    reg = ha->iobase;
-     /* disable our interrupt. */
-    WRT_REG_WORD(&reg->ictrl, 0); 
-    data = qla1280_debounce_register(&reg->istatus);
-    /* Check for pending interrupts. */
-    if ( !(data & RISC_INT) )
-    {
-        /* spurious interrupts can happen legally */
-        DEBUG(printk("scsi(%d): Spurious interrupt - ignoring\n",(int)ha->host_no));
-        COMTRACE('X')
-    }
-    else
-      qla1280_isr(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
-    if (ha->done_q_first)
-        qla1280_done(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
-
-    clear_bit(QLA1280_IN_ISR_BIT, &ha->flags);
-    spin_unlock_irqrestore(&io_request_lock, cpu_flags);
-#else  /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95) */
 
-    if( test_bit(QLA1280_IN_ISR_BIT, (int *)&ha->flags) )
-    {
-          COMTRACE('X')
-          printk(KERN_INFO "scsi(%d): Already in interrupt - returning \n", (int)ha->host_no);
-          spin_unlock_irqrestore(&io_request_lock, cpu_flags);
-          return;
-    }
-    set_bit(QLA1280_IN_ISR_BIT, (int *)&ha->flags);
     ha->isr_count++;
     reg = ha->iobase;
-     /* disable our interrupt. */
-    WRT_REG_WORD(&reg->ictrl, 0); 
+
+    WRT_REG_WORD(&reg->ictrl, 0);     /* disable our interrupt. */
 
     data = qla1280_debounce_register(&reg->istatus);
     /* Check for pending interrupts. */
-    if ( !(data & RISC_INT) )
-    {
+    if (data & RISC_INT) {
+	qla1280_isr(ha, (srb_t **)&ha->done_q_first,
+		    (srb_t **)&ha->done_q_last);
+    } else {
         /* spurious interrupts can happen legally */
-        DEBUG(printk("scsi(%d): Spurious interrupt - ignoring\n",(int)ha->host_no));
-        COMTRACE('X')
+        DEBUG(printk("scsi(%d): Spurious interrupt - ignoring\n",
+		     (int)ha->host_no));
     }
-    else
-     qla1280_isr(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
 
-    /* if no work to do then call the SCSI mid-level right away */
-    if( ha->done_q_first )
-        qla1280_done(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+    if (ha->done_q_first)
+        qla1280_done(ha, (srb_t **)&ha->done_q_first,
+		     (srb_t **)&ha->done_q_last);
 
-    /* Schedule the DPC routine */
-    if (ha->flags.isp_abort_needed || ha->flags.reset_marker ||
-            ha->done_q_first        )
-        {
-            ha->run_qla_bh.data = (void *) ha;
-            ha->run_qla_bh.routine = qla1280_do_dpc; 
+    spin_unlock_irqrestore(&io_request_lock, cpu_flags);
 
-             COMTRACE('P') 
-            queue_task_irq(&ha->run_qla_bh,&tq_scheduler); 
-            ha->flags.dpc_sched = TRUE;
-        }
-        clear_bit(QLA1280_IN_ISR_BIT, (int *)&ha->flags);
-#endif
      /* enable our interrupt. */
-        WRT_REG_WORD(&reg->ictrl, ISP_EN_INT + ISP_EN_RISC);
+    WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT | ISP_EN_RISC));
 
-        COMTRACE('i')  
-        LEAVE_INTR("qla1280_intr_handler");
+    LEAVE_INTR("qla1280_intr_handler");
 }
 
 /**************************************************************************
@@ -1718,14 +1648,10 @@
 void qla1280_do_dpc(void *p)
 {
     scsi_qla_host_t *ha = (scsi_qla_host_t *) p;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
+    unsigned long cpu_flags;
 
-    COMTRACE('p')  
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
     spin_lock_irqsave(&io_request_lock, cpu_flags);
-#endif
+
     if (ha->flags.isp_abort_needed)
         qla1280_abort_isp(ha);
 
@@ -1735,9 +1661,8 @@
     if (ha->done_q_first)
         qla1280_done(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
     ha->flags.dpc_sched = FALSE;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+
     spin_unlock_irqrestore(&io_request_lock, cpu_flags);
-#endif
 }
 
 /**************************************************************************
@@ -1751,7 +1676,7 @@
  *   as the default queue depth.  Otherwise, we use either 4 or 8 as the
  *   default queue depth (dependent on the number of hardware SCBs).
  **************************************************************************/
-STATIC void qla1280_device_queue_depth(scsi_qla_host_t *p, Scsi_Device *device)
+static void qla1280_device_queue_depth(scsi_qla_host_t *p, Scsi_Device *device)
 {
     int default_depth = 3;
     int bus = device->channel;
@@ -1767,8 +1692,8 @@
         device->queue_depth = p->bus_settings[bus].hiwat; 
         /* device->queue_depth = 20; */
         printk(KERN_INFO "scsi(%d:%d:%d:%d): Enabled tagged queuing, queue depth %d.\n",
-                (int)p->host_no, device->channel, device->id,
-                device->lun, device->queue_depth);
+	       (int)p->host_no, device->channel, device->id,
+	       device->lun, device->queue_depth);
     }
     qla12160_get_target_parameters(p, bus, target, device->lun);
 
@@ -1781,7 +1706,7 @@
  *   host adapter.  We use a queue depth of 2 for devices that do not
  *   support tagged queueing.
  **************************************************************************/
-STATIC void
+static void
 qla1280_select_queue_depth(struct Scsi_Host *host, Scsi_Device *scsi_devs)
 {
     Scsi_Device *device;
@@ -1800,22 +1725,6 @@
 ** Driver Support Routines  **
 **--------------------------*/
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
-/*
- * mdelay
- *      Delay in milliseconds 
- *
- * Input:
- *      milliseconds  = delay 
- */
-STATIC inline void mdelay(int milliseconds)
-{
-    int i;
-
-    for(i=0; i<milliseconds; i++)
-        udelay(1000);
-}
-#endif
 
 /*
  * qla1280_done
@@ -1826,22 +1735,16 @@
  *      done_q_first = done queue first pointer.
  *      done_q_last  = done queue last pointer.
  */
-STATIC void
+static void
 qla1280_done(scsi_qla_host_t *ha, srb_t **done_q_first, srb_t **done_q_last)
 {
     srb_t           *sp;
     scsi_lu_t       *q;
-    uint32_t        b, t, l;
-    Scsi_Cmnd  *cmd;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
+    unsigned int bus, target, lun;
+    Scsi_Cmnd *cmd;
 
     ENTER("qla1280_done");
-    COMTRACE('D') 
 
-    DRIVER_LOCK 
     while (*done_q_first !=  NULL)
     {
         /* remove command from done list */
@@ -1852,31 +1755,31 @@
             (*done_q_first)->s_prev = NULL;
 
         cmd = sp->cmd;
-        b = SCSI_BUS_32(cmd);
-        t = SCSI_TCN_32(cmd);
-        l = SCSI_LUN_32(cmd);
-        q = LU_Q(ha, b, t, l);
+        bus = SCSI_BUS_32(cmd);
+        target = SCSI_TCN_32(cmd);
+        lun = SCSI_LUN_32(cmd);
+        q = LU_Q(ha, bus, target, lun);
 
         /* Decrement outstanding commands on device. */
         if (q->q_outcnt)
             q->q_outcnt--;
-        if (q->q_outcnt < ha->bus_settings[b].hiwat)
+        if (q->q_outcnt < ha->bus_settings[bus].hiwat)
         {
             q->q_flag &= ~QLA1280_QBUSY;
         }
         
         q->io_cnt++;
-        if( sp->dir & BIT_5 )
-         q->r_cnt++;
+        if(sp->dir & BIT_5)
+	    q->r_cnt++;
         else
-         q->w_cnt++;
+	    q->w_cnt++;
 
-        switch ( (CMD_RESULT(cmd)>>16))
+        switch ((CMD_RESULT(cmd)>>16))
         {
             case DID_RESET:
                 q->q_flag &= ~QLA1280_QRESET;
                 /* Issue marker command. */
-                qla1280_marker(ha, b, t, 0, MK_SYNC_ID); 
+                qla1280_marker(ha, bus, target, 0, MK_SYNC_ID); 
                 break;
             case DID_ABORT:
                 sp->flags &= ~SRB_ABORT_PENDING;
@@ -1887,12 +1790,12 @@
             default:
                 break;
         }
+
         /* 3.13   64 and 32 bit */
         /* Release memory used for this I/O */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
         if (cmd->use_sg) {
             DEBUG(sprintf(debug_buff,
-            "S/G unmap_sg cmd=%x\n\r",cmd);)
+            "S/G unmap_sg cmd=%p\n",(void *)cmd);)
             DEBUG(qla1280_print(debug_buff));
             pci_unmap_sg(ha->pdev, cmd->request_buffer,
                          cmd->use_sg,
@@ -1900,7 +1803,7 @@
         }
         else if (cmd->request_bufflen) {
           /*DEBUG(sprintf(debug_buff,
-                 "No S/G unmap_single cmd=%x saved_dma_handle=%lx\n\r",
+                 "No S/G unmap_single cmd=%x saved_dma_handle=%lx\n",
                   cmd,sp->saved_dma_handle);)
                   DEBUG(qla1280_print(debug_buff);)*/
 
@@ -1908,32 +1811,26 @@
                                   cmd->request_bufflen,
                                   scsi_to_pci_dma_dir(cmd->sc_data_direction));
        }
-#endif 
+
         /* Call the mid-level driver interrupt handler */
-        CMD_HANDLE(sp->cmd) = (unsigned char *) 0;
+        CMD_HANDLE(sp->cmd) = NULL;
         ha->actthreads--;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-        sti(); 
-        (*(cmd)->scsi_done)(cmd);
-        cli(); 
-#else
+
         (*(cmd)->scsi_done)(cmd);
-#endif
-        qla1280_next(ha, q, b);
+
+        qla1280_next(ha, q, bus);
     }
-    DRIVER_UNLOCK 
-    COMTRACE('d') 
     LEAVE("qla1280_done");
 }
 
 /*
  * Translates a ISP error to a Linux SCSI error
  */
-STATIC int qla1280_return_status( sts_entry_t *sts, Scsi_Cmnd       *cp)
+static int qla1280_return_status( sts_entry_t *sts, Scsi_Cmnd       *cp)
 {
     int host_status = DID_ERROR;
 #if DEBUG_QLA1280_INTR
-    STATIC char *reason[] =
+    static char *reason[] =
     {
         "DID_OK",
                 "DID_NO_CONNECT",
@@ -1987,9 +1884,8 @@
 #ifdef QL_DEBUG_LEVEL_2 
             printk("Data overrun 0x%x\n",(int)sts->residual_length);
             qla1280_print(
-                        "\n\rqla1280_isr: response packet data\n\r");
-                        qla1280_dump_buffer((caddr_t)sts,
-                        RESPONSE_ENTRY_SIZE); 
+                        "\nqla1280_isr: response packet data\n");
+                        qla1280_dump_buffer((char *)sts, RESPONSE_ENTRY_SIZE); 
 #endif
             host_status = DID_ERROR;
             break;
@@ -2008,7 +1904,7 @@
     }
 
 #if DEBUG_QLA1280_INTR
-    sprintf(debug_buff, "qla1280 ISP status: host status (%s) scsi status %x\n\r", reason[host_status], sts->scsi_status);
+    sprintf(debug_buff, "qla1280 ISP status: host status (%s) scsi status %x\n", reason[host_status], sts->scsi_status);
     qla1280_print(debug_buff);
 #endif
 
@@ -2026,18 +1922,13 @@
  *      done_q_first = done queue first pointer.
  *      done_q_last  = done queue last pointer.
  */
-STATIC void
+static void
 qla1280_done_q_put(srb_t *sp, srb_t **done_q_first, srb_t **done_q_last)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_put_done_q");
-#endif
+
     /* Place block on done queue */
-    DRIVER_LOCK
-            sp->s_next = NULL;
+    sp->s_next = NULL;
     sp->s_prev = *done_q_last;
     if (!*done_q_first)
         *done_q_first = sp;
@@ -2045,10 +1936,7 @@
         (*done_q_last)->s_next = sp;
     *done_q_last = sp;
 
-    DRIVER_UNLOCK
-#ifdef QL_DEBUG_LEVEL_3
-            LEAVE("qla1280_put_done_q");
-#endif
+    LEAVE("qla1280_put_done_q");
 }
 
 /*
@@ -2064,28 +1952,24 @@
  * Output:
  *      Releases SCSI_LU_Q upon exit.
  */
-STATIC void
+static void
 qla1280_next(scsi_qla_host_t *ha, scsi_lu_t *q, uint8_t b)
 {
     srb_t   *sp;
-    uint32_t cnt;
-    uint8_t status;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
+    int cnt, status;
 
     ENTER("qla1280_next");
 
-    DRIVER_LOCK
-    while ( ((sp = q->q_first) != NULL) &&     /* we have a queue pending */
-        !(q->q_flag &  QLA1280_QBUSY) &&      /* device not busy */
-        !ha->flags.abort_isp_active &&      /* not resetting the adapter */
-        !(q->q_flag & QLA1280_QSUSP) )      /* device not suspended */
+    while (((sp = q->q_first) != NULL) &&	/* we have a queue pending */
+				           	/* device not busy/suspended */
+           !(q->q_flag & (QLA1280_QBUSY | QLA1280_QSUSP)) &&
+           !ha->flags.abort_isp_active)		/* not resetting the adapter */
     {
         /* Remove srb from SCSI LU queue. */
         qla1280_removeq(q, sp);
 
-        DEBUG(sprintf(debug_buff,"starting request 0x%p<-(0x%p)\n\r",q,sp));
+        DEBUG(sprintf(debug_buff,"starting request 0x%p<-(0x%p)\n",
+                      (void *)q, (void *)sp));
         DEBUG(qla1280_print(debug_buff));
         {
             /* Set busy flag if reached high water mark. */
@@ -2104,13 +1988,10 @@
             {
                 if (q->q_outcnt == 1)
                 {
-                    /* Release SCSI LU queue specific lock */
-                    QLA1280_SCSILU_UNLOCK(q);
-
                     /* Wait for 30 sec for command to be accepted. */
                     for (cnt = 6000000; cnt; cnt--)
                     {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+#if QLA_64BIT_PTR
                         if (ha->flags.enable_64bit_addressing)
                             status = qla1280_64bit_start_scsi(ha, sp);
                         else
@@ -2125,7 +2006,7 @@
                         /* Go check for pending interrupts. */
                         qla1280_poll(ha);
 
-                        SYS_DELAY(5);  /* 10 */
+                        udelay(5);  /* 10 */
                     }
                     if (!cnt)
                     {
@@ -2137,27 +2018,14 @@
                         if (sp->flags & SRB_WATCHDOG)
                             qla1280_timeout_remove(ha, sp);
 #endif
-                        COMTRACE('M') 
-                        CMD_HANDLE(sp->cmd) = (unsigned char *) 0;
+                        CMD_HANDLE(sp->cmd) = NULL;
 
                         /* Call the mid-level driver interrupt handler */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-                        sti(); 
                         (*(sp->cmd)->scsi_done)(sp->cmd);
-                        cli(); 
-#else
-                        (*(sp->cmd)->scsi_done)(sp->cmd);
-#endif
-
-                        /* Acquire LU queue specific lock */
-                        QLA1280_SCSILU_LOCK(q);
 
                         if (q->q_outcnt)
                             q->q_outcnt--;
                     }
-                    else
-                        /* Acquire LU queue specific lock */
-                        QLA1280_SCSILU_LOCK(q);
                 }
                 else
                 {   /* Place request back on top of device queue. */
@@ -2172,10 +2040,6 @@
             }
         }
     }
-   DRIVER_UNLOCK
-
-    /* Release SCSI LU queue specific lock */
-    QLA1280_SCSILU_UNLOCK(q);
 
     LEAVE("qla1280_next");
 }
@@ -2189,19 +2053,13 @@
  *      sp = srb pointer.
  *      SCSI_LU_Q lock must be already obtained.
  */
-STATIC void
+static void
 qla1280_putq_t(scsi_lu_t *q, srb_t *sp)
 {
-    srb_t *srb_p;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
-
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_putq_t");
-#endif
-    DRIVER_LOCK
-    DEBUG(sprintf(debug_buff,"Adding to device q=0x%p<-(0x%p)sp\n\r",q,sp));
+
+    DEBUG(sprintf(debug_buff,"Adding to device q=0x%p<-(0x%p)sp\n",
+                  (void *)q, (void *)sp));
     DEBUG(qla1280_print(debug_buff));
     sp->s_next = NULL;
     if (!q->q_first)                  /* If queue empty */
@@ -2212,32 +2070,12 @@
     }
     else
     {      
-        srb_p = q->q_first;
-        while (srb_p )
-            srb_p = srb_p->s_next;
-
-        if (srb_p)
-        {
-            sp->s_prev = srb_p->s_prev;
-            if (srb_p->s_prev)
-                srb_p->s_prev->s_next = sp;
-            else
-                q->q_first = sp;
-            srb_p->s_prev = sp;
-            sp->s_next = srb_p;
-        }
-        else
-        {
-            sp->s_prev = q->q_last;
-            q->q_last->s_next = sp;
-            q->q_last = sp;
-        }
+        sp->s_prev = q->q_last;
+        q->q_last->s_next = sp;
+        q->q_last = sp;
     }
 
-    DRIVER_UNLOCK
-#ifdef QL_DEBUG_LEVEL_3
-            LEAVE("qla1280_putq_t");
-#endif
+    LEAVE("qla1280_putq_t");
 }
 
 /*
@@ -2250,16 +2088,13 @@
  *      sp = srb pointer.
  *      SCSI_LU_Q lock must be already obtained.
  */
-STATIC void
+static void
 qla1280_removeq(scsi_lu_t *q, srb_t *sp)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
-    DEBUG(sprintf(debug_buff,"Removing from device_q (0x%p)->(0x%p)\n\r",q,sp));
+    DEBUG(sprintf(debug_buff,"Removing from device_q (0x%p)->(0x%p)\n",
+                  (void *)q, (void *)sp));
     DEBUG(qla1280_print(debug_buff));
-    DRIVER_LOCK
-            if (sp->s_prev)
+    if (sp->s_prev)
     {
         if ((sp->s_prev->s_next = sp->s_next) != NULL)
             sp->s_next->s_prev = sp->s_prev;
@@ -2270,7 +2105,6 @@
         q->q_last = NULL;
     else
         q->q_first->s_prev = NULL;
-    DRIVER_UNLOCK
 }
 
 /*
@@ -2281,49 +2115,38 @@
 *      0  = success.
 *      1  = failure.
 */
-STATIC uint8_t
+static int
 qla1280_mem_alloc(scsi_qla_host_t *ha)
 {
+	int status = 1;
+        dma_addr_t dma_handle;
 
-	uint8_t   status = 1;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
-        dma_addr_t     dma_handle;
-#endif
-
-#ifdef QL_DEBUG_LEVEL_3
 	ENTER("qla1280_mem_alloc");
-#endif
 
         /* 3.13 */
         /* get consistent memory allocated for request and response rings */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-	ha->request_ring = &ha->req[0];
-	ha->request_dma = VIRT_TO_BUS(&ha->req[0]);
-	ha->response_ring = &ha->res[0];
-	ha->response_dma = VIRT_TO_BUS(&ha->res[0]);
-	status = 0;
-#else
         ha->request_ring  = pci_alloc_consistent(ha->pdev,
                                ((REQUEST_ENTRY_CNT+1)*(sizeof(request_t))),
                                &dma_handle);
+        if (!ha->request_ring)
+            goto error;
         ha->request_dma    = dma_handle;
         ha->response_ring  = pci_alloc_consistent(ha->pdev,
                                ((RESPONSE_ENTRY_CNT+1)*(sizeof(response_t))),
                                &dma_handle);
+        if (!ha->request_ring)
+            goto error;
         ha->response_dma   = dma_handle;
         status = 0; 
-#endif 
 
-	if(status) {
+ error:
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+	if(status) {
 		qla1280_print("qla1280_mem_alloc: **** FAILED ****\n");
-#endif
 	}
-#ifdef QL_DEBUG_LEVEL_3
-	else
-		LEAVE("qla1280_mem_alloc");
 #endif
-	return(status);
+	LEAVE("qla1280_mem_alloc");
+	return status;
 }
 
 /*
@@ -2333,7 +2156,7 @@
  * Input:
  *      ha = adapter block pointer.
  */
-STATIC void
+static void
 qla1280_mem_free(scsi_qla_host_t *ha)
 {
     scsi_lu_t *q;
@@ -2349,22 +2172,29 @@
             for (t = 0; t < MAX_TARGETS; t++)
                 for (l = 0; l < MAX_LUNS; l++)
                     if (LU_Q(ha, b, t, l) != NULL && LU_Q(ha, b, t, l) != q)
-                        KMFREE(LU_Q(ha, b, t, l),sizeof(struct scsi_lu));
-                    KMFREE(q, sizeof(struct scsi_lu));
+                        kfree(LU_Q(ha, b, t, l));
+                    kfree(q);
         }
         for( b =0; b < MAX_EQ; b++ )
-            ha->dev[b] =  (scsi_lu_t  *)NULL;
+            ha->dev[b] =  NULL;
     }
 
     /* 3.13 */
     /* free consistent memory allocated for request and response rings */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
-    pci_free_consistent(ha->pdev, ((REQUEST_ENTRY_CNT+1)*(sizeof(request_t))),
-                        ha->request_ring, ha->request_dma);
-
-    pci_free_consistent(ha->pdev,((RESPONSE_ENTRY_CNT+1)*(sizeof(response_t))),
-    ha->response_ring, ha->response_dma); 
-#endif 
+    if (ha->request_ring)
+        pci_free_consistent(ha->pdev,
+                            ((REQUEST_ENTRY_CNT+1)*(sizeof(request_t))),
+                            ha->request_ring, ha->request_dma);
+
+    if (ha->response_ring)
+        pci_free_consistent(ha->pdev,
+                            ((RESPONSE_ENTRY_CNT+1)*(sizeof(response_t))),
+                            ha->response_ring, ha->response_dma); 
+
+    if (qla1280_buffer) {
+	free_page((unsigned long)qla1280_buffer);
+	qla1280_buffer = NULL;
+    }
 
     LEAVE("qlc1280_mem_free");
 }
@@ -2386,23 +2216,21 @@
  * Returns:
  *      None      
  */
-    static inline void qla1280_enable_intrs(scsi_qla_host_t *ha) {
-        device_reg_t *reg;
+static inline void qla1280_enable_intrs(scsi_qla_host_t *ha) {
+  device_reg_t *reg;
 
-        reg = ha->iobase;
-        ha->flags.interrupts_on = 1;
-        /* enable risc and host interrupts */
-        WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT+ ISP_EN_RISC));
-    }
+  reg = ha->iobase;
+  /* enable risc and host interrupts */
+  WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT | ISP_EN_RISC));
+}
 
-    static inline void qla1280_disable_intrs(scsi_qla_host_t *ha) {
-        device_reg_t *reg;
+static inline void qla1280_disable_intrs(scsi_qla_host_t *ha) {
+  device_reg_t *reg;
 
-        reg = ha->iobase;
-        ha->flags.interrupts_on = 0;
-        /* disable risc and host interrupts */
-        WRT_REG_WORD(&reg->ictrl, 0);
-    }
+  reg = ha->iobase;
+  /* disable risc and host interrupts */
+  WRT_REG_WORD(&reg->ictrl, 0);
+}
 
 /*
  * qla1280_initialize_adapter
@@ -2414,17 +2242,15 @@
  * Returns:
  *      0 = success
  */
-STATIC uint8_t
+static int
 qla1280_initialize_adapter(scsi_qla_host_t *ha)
 {
     device_reg_t *reg;
-    uint8_t      status;
-    /* uint8_t      cnt; */
-    uint8_t      b;
+    int	status;
+    /* int      cnt; */
+    uint8_t      bus;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_initialize_adapter");
-#endif
 
     /* Clear adapter flags. */
     ha->flags.online = FALSE;
@@ -2461,6 +2287,8 @@
                 status = qla1280_setup_chip(ha); 
             }
         }
+        else
+          printk("initialize: isp_firmware() failed!\n");
 
         if (!status)
         {
@@ -2473,38 +2301,38 @@
                 !qla1280_init_rings(ha))
             {
                 /* Issue SCSI reset. */
-                for (b = 0; b < ha->ports; b++)
-                    if (!ha->bus_settings[b].disable_scsi_reset)
+                for (bus = 0; bus < ha->ports; bus++)
+                    if (!ha->bus_settings[bus].disable_scsi_reset)
                     {
                       /* dg 03/13 if we can't reset twice then bus is dead */
-                        if( qla1280_bus_reset(ha, b) )
-                           if( qla1280_bus_reset(ha, b) )
+                        if( qla1280_bus_reset(ha, bus) )
+                           if( qla1280_bus_reset(ha, bus) )
                            {
-                               ha->bus_settings[b].scsi_bus_dead = TRUE;
-                            }
+                               ha->bus_settings[bus].scsi_bus_dead = TRUE;
+			   }
                     }
 
                     do
                     {
                         /* Issue marker command. */
                         ha->flags.reset_marker = FALSE;
-                        for (b = 0; b < ha->ports; b++)
+                        for (bus = 0; bus < ha->ports; bus++)
                         {
-                            ha->bus_settings[b].reset_marker = FALSE;
-                            qla1280_marker(ha, b, 0, 0, MK_SYNC_ALL);
+                            ha->bus_settings[bus].reset_marker = FALSE;
+                            qla1280_marker(ha, bus, 0, 0, MK_SYNC_ALL);
                         }
                     }while (ha->flags.reset_marker);
 
                     ha->flags.online = TRUE;
 
                     /* Enable host adapter target mode. */
-                    for (b = 0; b < ha->ports; b++)
+                    for (bus = 0; bus < ha->ports; bus++)
                     {
-                        if (!(status = qla1280_enable_tgt(ha, b)))
+                        if (!(status = qla1280_enable_tgt(ha, bus)))
                         {
                             /* for (cnt = 0; cnt < MAX_LUNS; cnt++)
                             {
-                                qla1280_enable_lun(ha, b, cnt);
+                                qla1280_enable_lun(ha, bus, cnt);
                                  qla1280_poll(ha);
                             }*/
                         }
@@ -2516,16 +2344,15 @@
                 status = 1;
         }
     }
+    else
+      printk("initialize: pci probe failed!\n");
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
-        qla1280_print("qla1280_initialize_adapter: **** FAILED ****\n\r");
-#endif
-#ifdef QL_DEBUG_LEVEL_3
-    else
-        LEAVE("qla1280_initialize_adapter");
+        qla1280_print("qla1280_initialize_adapter: **** FAILED ****\n");
 #endif
-    return(status);
+    LEAVE("qla1280_initialize_adapter");
+    return status;
 }
 
 /*
@@ -2539,14 +2366,14 @@
  * Returns:
  *      0 = success.
  */
-STATIC uint8_t
+static int
 qla1280_enable_tgt(scsi_qla_host_t *ha, uint8_t b)
 {
-    uint8_t     status = 0;
+    int status = 0;
     /*  uint16_t    mb[MAILBOX_REGISTER_COUNT]; */
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_enable_tgt: entered\n\r");
+    qla1280_print("qla1280_enable_tgt: entered\n");
 #endif
 
     /* Enable target mode. */
@@ -2558,11 +2385,11 @@
     */
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
-        qla1280_print("qla1280_enable_tgt: **** FAILED ****\n\r");
+        qla1280_print("qla1280_enable_tgt: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_enable_tgt: exiting normally\n\r");
+        qla1280_print("qla1280_enable_tgt: exiting normally\n");
 #endif
     return(status);
 }
@@ -2578,14 +2405,14 @@
  * Returns:
  *      0 = firmware does not need to be loaded.
  */
-STATIC uint8_t
+static int
 qla1280_isp_firmware(scsi_qla_host_t *ha)
 {
     nvram_t     *nv    = (nvram_t *)ha->response_ring; 
     uint16_t    *wptr;
+    int		status = 0;    /* dg 2/27 always loads RISC */
+    int		cnt;
     uint8_t     chksum;
-    uint8_t     cnt;
-    uint8_t     status = 0;    /* dg 2/27 always loads RISC */
     uint16_t    mb[MAILBOX_REGISTER_COUNT];
 
     ENTER("qla1280_isp_firmware");
@@ -2604,7 +2431,7 @@
     DEBUG(printk("qla1280_isp_firmware: Completed Reading NVRAM\n"));
 
 #if defined(QL_DEBUG_LEVEL_3)
-    sprintf(debug_buff,"qla1280_isp_firmware: NVRAM Magic ID= %c %c %c\n\r",(char *) nv->id[0],nv->id[1],nv->id[2]);
+    sprintf(debug_buff,"qla1280_isp_firmware: NVRAM Magic ID= %c %c %c\n",(char *) nv->id[0],nv->id[1],nv->id[2]);
     qla1280_print(debug_buff);
 #endif
 
@@ -2621,18 +2448,18 @@
     if (ha->flags.disable_risc_code_load)
     {
 #if defined(QL_DEBUG_LEVEL_3)
-        qla1280_print("qla1280_isp_firmware: Telling RISC to verify checksum of loaded BIOS code.\n\r");
+        qla1280_print("qla1280_isp_firmware: Telling RISC to verify checksum of loaded BIOS code.\n");
 #endif
         /* Verify checksum of loaded RISC code. */
         mb[0] = MBC_VERIFY_CHECKSUM;
         /* mb[1] = ql12_risc_code_addr01; */
-        mb[1] = *QL1280BoardTbl[ha->devnum].fwstart;  
+        mb[1] = *QL1280BoardTbl[ha->devnum].fwstart;
 
         if (!(status = qla1280_mailbox_command(ha, BIT_1|BIT_0, &mb[0])))
         {
             /* Start firmware execution. */
 #if defined(QL_DEBUG_LEVEL_3)
-            qla1280_print("qla1280_isp_firmware: Startng F/W execution.\n\r");
+            qla1280_print("qla1280_isp_firmware: Startng F/W execution.\n");
 #endif
             mb[0] = MBC_EXECUTE_FIRMWARE;
             /* mb[1] = ql12_risc_code_addr01; */
@@ -2646,15 +2473,15 @@
     {
         DEBUG(printk("qla1280: NVRAM configured to load RISC load.\n"));
         status = 1;
-     }
+    }
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
         qla1280_print(
-                "qla1280_isp_firmware: **** Load RISC code ****\n\r");
+                "qla1280_isp_firmware: **** Load RISC code ****\n");
 #endif
     LEAVE("qla1280_isp_firmware");
-    return(status);
+    return status;
 }
 
 /*
@@ -2667,35 +2494,29 @@
  * Returns:
  *      0 = success.
  */
-STATIC uint8_t
+static int
 qla1280_pci_config(scsi_qla_host_t *ha)
 {
-    uint8_t      status = 1;
 #if MEMORY_MAPPED_IO
-    uint32_t  page_offset, base;
-    uint32_t   mmapbase;
-#endif
-    uint16_t     buf_wd;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-    uint32_t     command;
-    config_reg_t *creg = 0;
+    uint32_t page_offset, base;
+    uint32_t mmapbase;
 #endif
-
+    uint16_t buf_wd;
+    int status = 1;
 
     ENTER("qla1280_pci_config");
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+    pci_set_master(ha->pdev);
     /*
      * Set Bus Master Enable, Memory Address Space Enable and
      * reset any error bits, in the command register.
      */
     pci_read_config_word(ha->pdev, PCI_COMMAND, &buf_wd);
-    buf_wd &= ~0x7;
 #if MEMORY_MAPPED_IO
     DEBUG(printk("qla1280: MEMORY MAPPED IO is enabled.\n"));
-    buf_wd |= BIT_2 + BIT_1 + BIT_0;
+    buf_wd |= PCI_COMMAND_MEMORY + PCI_COMMAND_IO;
 #else
-    buf_wd |= BIT_2 + BIT_0;
+    buf_wd |= PCI_COMMAND_IO;
 #endif
     pci_write_config_word(ha->pdev, PCI_COMMAND, buf_wd);
     /*
@@ -2704,6 +2525,11 @@
     pci_read_config_word(ha->pdev, PCI_ROM_ADDRESS, &buf_wd);
     buf_wd &= ~PCI_ROM_ADDRESS_ENABLE;
     pci_write_config_word(ha->pdev, PCI_ROM_ADDRESS, buf_wd);
+
+    ha->host->io_port = pci_resource_start(ha->pdev, 0);
+    ha->host->io_port &= PCI_BASE_ADDRESS_IO_MASK; 
+    ha->iobase = (device_reg_t *) ha->host->io_port;
+
 #if MEMORY_MAPPED_IO
     /*
      * Get memory mapped I/O address. 
@@ -2720,8 +2546,7 @@
      * Get virtual address for I/O registers.
      */
     ha->mmpbase = ioremap_nocache(base, page_offset + 256);
-    if( ha->mmpbase )
-    {
+    if(ha->mmpbase) {
         ha->mmpbase += page_offset;
         /* ha->iobase = ha->mmpbase; */
         status = 0;
@@ -2730,62 +2555,6 @@
     status = 0;
 #endif /* MEMORY_MAPPED_IO */
 
-#else /*LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18) */
-
-    /* Get command register. */
-    if (pcibios_read_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->command), &buf_wd) == PCIBIOS_SUCCESSFUL)
-    {
-        command = buf_wd;
-        /*
-        * Set Bus Master Enable, Memory Address Space Enable and
-        * reset any error bits.
-        */
-        buf_wd &= ~0x7;
-#if MEMORY_MAPPED_IO
-        DEBUG(printk("qla1280: MEMORY MAPPED IO is enabled.\n"));
-        buf_wd |= BIT_2 + BIT_1 + BIT_0;
-#else
-        buf_wd |= BIT_2 + BIT_0;
-#endif
-        if( pcibios_write_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->command), buf_wd) )
-        {
-            printk(KERN_WARNING "qla1280: Could not write config word.\n");
-        }
-        /* Get expansion ROM address. */
-        if (pcibios_read_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->expansion_rom), &buf_wd) == PCIBIOS_SUCCESSFUL)
-        {
-            /* Reset expansion ROM address decode enable. */
-            buf_wd &= ~BIT_0;
-            if (pcibios_write_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->expansion_rom), buf_wd) == PCIBIOS_SUCCESSFUL)
-            {
-#if MEMORY_MAPPED_IO
-                /* Get memory mapped I/O address. */
-                pcibios_read_config_dword(ha->pci_bus, ha->pci_device_fn,OFFSET(cfgp->mem_base_addr), &mmapbase);
-                mmapbase &= PCI_BASE_ADDRESS_MEM_MASK;
-
-                /* Find proper memory chunk for memory map I/O reg. */
-                base = mmapbase & PAGE_MASK;
-                page_offset = mmapbase - base;
-                /* Get virtual address for I/O registers. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
-                ha->mmpbase = ioremap_nocache(base, page_offset + 256);
-#else
-                ha->mmpbase = vremap(base,page_offset + 256);
-#endif
-                if( ha->mmpbase )
-                {
-                    ha->mmpbase += page_offset;
-                    /* ha->iobase = ha->mmpbase; */
-                    status = 0;
-                }
-#else /* MEMORY_MAPPED_IO */
-                status = 0;
-#endif /* MEMORY_MAPPED_IO */
-            }
-        }
-    }
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18) */
-
     LEAVE("qla1280_pci_config");
     return(status);
 }
@@ -2800,17 +2569,17 @@
  * Returns:
  *      0 = success.
  */
-STATIC uint8_t
+static int
 qla1280_chip_diag(scsi_qla_host_t *ha)
 {
+    uint16_t     mb[MAILBOX_REGISTER_COUNT];
     device_reg_t *reg   = ha->iobase;
-    uint8_t      status = 0;
+    int		 status = 0;
+    int		 cnt;
     uint16_t     data;
-    uint32_t     cnt;
-    uint16_t     mb[MAILBOX_REGISTER_COUNT];
 
 #ifdef QL_DEBUG_LEVEL_3
-    sprintf(debug_buff, "qla1280_chip_diag: testing device at 0x%p \n\r",&reg->id_l);
+    sprintf(debug_buff, "qla1280_chip_diag: testing device at 0x%p \n",&reg->id_l);
     qla1280_print(debug_buff);
 #endif
 
@@ -2819,14 +2588,14 @@
     data = qla1280_debounce_register(&reg->ictrl);
     for (cnt = 6000000; cnt && data & ISP_RESET; cnt--)
     {
-        SYS_DELAY(5);
+        udelay(5);
         data = RD_REG_WORD(&reg->ictrl);
     }
     if (cnt)
     {
         /* Reset register not cleared by chip reset. */
 #if defined(QL_DEBUG_LEVEL_3)
-        qla1280_print("qla1280_chip_diag: reset register cleared by chip reset\n\r");
+        qla1280_print("qla1280_chip_diag: reset register cleared by chip reset\n");
 #endif
         WRT_REG_WORD(&reg->cfg_1, 0);
 
@@ -2838,7 +2607,7 @@
         data = qla1280_debounce_register(&reg->mailbox0);
         for (cnt = 6000000; cnt && data == MBS_BUSY; cnt--)
         {
-            SYS_DELAY(5);
+            udelay(5);
             data = RD_REG_WORD(&reg->mailbox0);
         }
 
@@ -2846,7 +2615,7 @@
         {
             /* Check product ID of chip */
 #if defined(QL_DEBUG_LEVEL_3)
-            qla1280_print("qla1280_chip_diag: Checking product ID of chip\n\r");
+            qla1280_print("qla1280_chip_diag: Checking product ID of chip\n");
 #endif
             if (RD_REG_WORD(&reg->mailbox1) != PROD_ID_1 ||
                 (RD_REG_WORD(&reg->mailbox2) != PROD_ID_2 &&
@@ -2896,11 +2665,11 @@
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
-        qla1280_print("qla1280_chip_diag: **** FAILED ****\n\r");
+        qla1280_print("qla1280_chip_diag: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_chip_diag: exiting normally\n\r");
+        qla1280_print("qla1280_chip_diag: exiting normally\n");
 #endif
     return(status);
 }
@@ -2916,61 +2685,46 @@
  *      0 = success.
  */
 #define DUMP_IT_BACK 0   /* for debug of RISC loading */
-STATIC uint8_t
+static int
 qla1280_setup_chip(scsi_qla_host_t *ha)
 {
-    uint8_t      status = 0;
+    int		 status = 0;
     uint16_t     risc_address;
     uint16_t     *risc_code_address;
-    long         risc_code_size;
+    int          risc_code_size;
     uint16_t     mb[MAILBOX_REGISTER_COUNT];
-    uint16_t     cnt;
+    uint16_t	 cnt;
     int          num;
 #if DUMP_IT_BACK
     int     i;
     uint8_t *sp;
     uint8_t    *tbuf;
-#if BITS_PER_LONG > 32
+#ifdef QLA_64BIT_PTR
     dma_addr_t     p_tbuf;
 #else
     uint32_t   p_tbuf;
 #endif
 #endif
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_setup_chip");
-#endif
 
     /* 3.13 */
 #if DUMP_IT_BACK
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-    if( (tbuf = (uint8_t *)KMALLOC(8000) ) == NULL )
-    {
-        printk("setup_chip: couldn't alloacte memory\n");
-        return(1);
-    }
-    p_tbuf =  VIRT_TO_BUS(tbuf);
-#else
     /* get consistent memory allocated for setup_chip */
     tbuf   = pci_alloc_consistent(ha->pdev, 8000, &p_tbuf);
 #endif
-#endif
 
     /* Load RISC code. */
-    /* 
-    risc_address      = ql12_risc_code_addr01;
-    risc_code_address = &ql12_risc_code01[0];
-    risc_code_size    = ql12_risc_code_length01;
-    */
     risc_address = *QL1280BoardTbl[ha->devnum].fwstart;  
     risc_code_address = QL1280BoardTbl[ha->devnum].fwcode;  
-    risc_code_size    = (long)(*QL1280BoardTbl[ha->devnum].fwlen & 0xffff);  
+    risc_code_size    = (int)*QL1280BoardTbl[ha->devnum].fwlen;
 
     DEBUG(printk("qla1280_setup_chip: DMA RISC code (%d) words\n",
          (int)risc_code_size));
     DEBUG(sprintf(debug_buff,
-       "qla1280_setup_chip: DMA RISC code (%d) words\n\r",risc_code_size);)
+       "qla1280_setup_chip: DMA RISC code (%li) words\n",risc_code_size);)
     DEBUG(qla1280_print(debug_buff));
+
     num =0;
     while (risc_code_size > 0 && !status)
     {
@@ -2980,22 +2734,21 @@
             cnt = risc_code_size;
 
         DEBUG(sprintf(debug_buff,
-         "qla1280_setup_chip:  loading risc @ =(0x%p),%d,%d(0x%x).\n\r",
-          risc_code_address,cnt,num,risc_address);)
+         "qla1280_setup_chip:  loading risc @ =(0x%p),%d,%d(0x%x).\n",
+          (void *)risc_code_address, cnt, num, risc_address);)
         DEBUG(qla1280_print(debug_buff));
-        BCOPY((caddr_t) risc_code_address,(caddr_t) ha->request_ring,
-              (cnt <<1));
+        memcpy(ha->request_ring, risc_code_address, (cnt <<1));
 
-        flush_cache_all(); 
+        flush_cache_all();
 
         mb[0] = MBC_LOAD_RAM; 
         mb[1] = risc_address;
         mb[4] = cnt;
-        mb[3] = (uint16_t)  ha->request_dma & 0xffff;
-        mb[2] = (uint16_t) (ha->request_dma >> 16) & 0xffff;
-        mb[7] = (uint16_t) (MS_64BITS(ha->request_dma) & 0xffff);
-        mb[6] = (uint16_t) (MS_64BITS(ha->request_dma) >> 16) & 0xffff;
-        DEBUG(printk("qla1280_setup_chip: op=%d  0x%p = 0x%4x,0x%4x,0x%4x,0x%4x\n",mb[0],ha->request_dma,mb[6],mb[7],mb[2],mb[3]));
+        mb[3] = ha->request_dma & 0xffff;
+        mb[2] = (ha->request_dma >> 16) & 0xffff;
+        mb[7] = (ha->request_dma >> 32) & 0xffff;
+        mb[6] = ha->request_dma >> 48;
+        DEBUG(printk("qla1280_setup_chip: op=%d  0x%p = 0x%4x,0x%4x,0x%4x,0x%4x\n",mb[0],(void *)ha->request_dma,mb[6],mb[7],mb[2],mb[3]));
         if( (status = qla1280_mailbox_command(ha, BIT_4|BIT_3|BIT_2|BIT_1|BIT_0,
             &mb[0]))  )
         {
@@ -3016,7 +2769,7 @@
         {
             printk("Failed to dump partial segment of f/w\n");
             DEBUG(sprintf(debug_buff,
-               "setup_chip: Failed to dump partial segment of f/w\n\r");)
+               "setup_chip: Failed to dump partial segment of f/w\n");)
             DEBUG(qla1280_print(debug_buff));
             break;
         }
@@ -3028,7 +2781,7 @@
                printk("qla1280_setup_chip: FW compare error @ byte(0x%x) loop#=%x\n",i,num);
                printk("setup_chip: FWbyte=%x  FWfromChip=%x\n",sp[i],tbuf[i]); 
                DEBUG(sprintf(debug_buff,
-                "qla1280_setup_chip: FW compare error @ byte(0x%x) loop#=%x\n\r",i);)
+                "qla1280_setup_chip: FW compare error @ byte(0x%x) loop#=%x\n",i);)
                DEBUG(qla1280_print(debug_buff);)
                /*break;*/
             }
@@ -3051,7 +2804,7 @@
         if (!(status = qla1280_mailbox_command(ha, BIT_1|BIT_0, &mb[0])))
         {
             /* Start firmware execution. */
-            DEBUG(qla1280_print("qla1280_setup_chip: start firmware running.\n\r");)
+            DEBUG(qla1280_print("qla1280_setup_chip: start firmware running.\n");)
             mb[0] = MBC_EXECUTE_FIRMWARE;
             mb[1] = *QL1280BoardTbl[ha->devnum].fwstart;  
             qla1280_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
@@ -3062,23 +2815,16 @@
 
     /* 3.13 */
 #if DUMP_IT_BACK
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-    KMFREE(tbuf,8000);
-#else
     /* free consistent memory allocated for setup_chip */
     pci_free_consistent(ha->pdev, 8000, tbuf, p_tbuf);
 #endif
-#endif
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
-        qla1280_print("qla1280_setup_chip: **** FAILED ****\n\r");
-#endif
-#ifdef QL_DEBUG_LEVEL_3
-    else
-        LEAVE("qla1280_setup_chip");
+        qla1280_print("qla1280_setup_chip: **** FAILED ****\n");
 #endif
-    return(status);
+    LEAVE("qla1280_setup_chip");
+    return status;
 }
 
 /*
@@ -3094,16 +2840,15 @@
  * Returns:
  *      0 = success.
  */
-STATIC uint8_t
+static int
 qla1280_init_rings(scsi_qla_host_t *ha)
 {
-    uint8_t     status = 0;
-    uint16_t    cnt;
     uint16_t    mb[MAILBOX_REGISTER_COUNT];
+    int		status = 0;
+    int		cnt;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_init_rings");
-#endif
+
     /* Clear outstanding commands array. */
     for (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++)
         ha->outstanding_cmds[cnt] = 0;
@@ -3115,11 +2860,11 @@
     /* mb[0] = MBC_INIT_REQUEST_QUEUE; */
     mb[0] = MBC_INIT_REQUEST_QUEUE_A64;
     mb[1] = REQUEST_ENTRY_CNT;
-    mb[3] = (uint16_t)LS_64BITS(ha->request_dma);
-    mb[2] = (uint16_t)( LS_64BITS(ha->request_dma) >> 16);
+    mb[3] = ha->request_dma & 0xffff;
+    mb[2] = (ha->request_dma >> 16) & 0xffff;
     mb[4] = 0;
-    mb[7] = (uint16_t)MS_64BITS(ha->request_dma);
-    mb[6] = (uint16_t)( MS_64BITS(ha->request_dma) >> 16);
+    mb[7] = (ha->request_dma >> 32) & 0xffff;
+    mb[6] = ha->request_dma >> 48;
     if (!(status = qla1280_mailbox_command(ha,
         BIT_7|BIT_6|BIT_4|BIT_3|BIT_2|BIT_1|BIT_0,
         &mb[0])))
@@ -3130,11 +2875,11 @@
         /* mb[0] = MBC_INIT_RESPONSE_QUEUE; */
         mb[0] = MBC_INIT_RESPONSE_QUEUE_A64;
         mb[1] = RESPONSE_ENTRY_CNT;
-        mb[3] = (uint16_t)LS_64BITS(ha->response_dma);
-        mb[2] = (uint16_t)(LS_64BITS(ha->response_dma) >> 16);
+        mb[3] = ha->response_dma & 0xffff;
+        mb[2] = (ha->response_dma >> 16) & 0xffff;
         mb[5] = 0;
-        mb[7] = (uint16_t)MS_64BITS(ha->response_dma);
-        mb[6] = (uint16_t)(MS_64BITS(ha->response_dma) >> 16);
+        mb[7] = (ha->response_dma >> 32) & 0xffff;
+        mb[6] = ha->response_dma >> 48;
         status = qla1280_mailbox_command(ha,
                 BIT_7|BIT_6|BIT_5|BIT_3|BIT_2|BIT_1|BIT_0,
                 &mb[0]);
@@ -3142,13 +2887,11 @@
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
-        qla1280_print("qla1280_init_rings: **** FAILED ****\n\r");
+        qla1280_print("qla1280_init_rings: **** FAILED ****\n");
 #endif
-#ifdef QL_DEBUG_LEVEL_3
-    else
-        LEAVE("qla1280_init_rings");
-#endif
-    return(status);
+
+    LEAVE("qla1280_init_rings");
+    return status;
 }
 
 /*
@@ -3164,21 +2907,21 @@
  * Returns:
  *      0 = success.
  */
-STATIC uint8_t
+static int
 qla1280_nvram_config(scsi_qla_host_t *ha)
 {
     device_reg_t *reg   = ha->iobase;
     nvram_t      *nv    = (nvram_t *)ha->response_ring; 
-    uint8_t      status = 0;
+    int		 status = 0;
+    int		 cnt;
     uint32_t     b, t, l;
     uint16_t     *wptr;
     uint16_t     mb[MAILBOX_REGISTER_COUNT];
-    uint8_t      cnt;
     uint8_t      chksum;
     uint32_t     nvsize;
 
 #if defined(QL_DEBUG_ROUTINES) && !defined(QL_DEBUG_LEVEL_4)
-    uint8_t      saved_print_status = ql_debug_print;
+    int		 saved_print_status = ql_debug_print;
 #endif
     ENTER("qla1280_nvram_config");
 #if defined(QL_DEBUG_ROUTINES) && !defined(QL_DEBUG_LEVEL_4)
@@ -3217,15 +2960,12 @@
         DEBUG(printk("checksum=0x%x, Id=%c, version=0x%x\n",chksum,nv->id[0],nv->version));
 #if defined(QL_DEBUG_LEVEL_3)
         /* ql_debug_print = 1;
-        qla1280_dump_buffer((caddr_t)ha->response_ring, REQUEST_ENTRY_SIZE);
+        qla1280_dump_buffer((char *)ha->response_ring, REQUEST_ENTRY_SIZE);
         ql_debug_print = 0; */
 #endif
-                wptr = (uint16_t *)ha->response_ring;
-        for (cnt = 0; cnt < sizeof(nvram_t)/2; cnt++)
-            *wptr++ = 0;
+        memset(ha->response_ring, 0, sizeof(nvram_t));
 #endif
 
-
         /* nv->cntr_flags_1.disable_loading_risc_code = 1; */
         nv->firmware_feature.w = BIT_0;
         nv->termination.f.scsi_bus_0_control = 3;
@@ -3268,74 +3008,74 @@
     }
 #if  DEBUG_PRINT_NVRAM
     ql_debug_print = 1;
-    sprintf(debug_buff,"qla1280 : initiator scsi id bus[0]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : initiator scsi id bus[0]=%d\n",
             nv->bus[0].config_1.initiator_id);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : initiator scsi id bus[1]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : initiator scsi id bus[1]=%d\n",
             nv->bus[1].config_1.initiator_id);
     qla1280_print(debug_buff);
 
-    sprintf(debug_buff,"qla1280 : bus reset delay[0]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : bus reset delay[0]=%d\n",
             nv->bus[0].bus_reset_delay);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : bus reset delay[1]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : bus reset delay[1]=%d\n",
             nv->bus[1].bus_reset_delay);
     qla1280_print(debug_buff);
 
-    sprintf(debug_buff,"qla1280 : retry count[0]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : retry count[0]=%d\n",
             nv->bus[0].retry_count);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : retry delay[0]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : retry delay[0]=%d\n",
             nv->bus[0].retry_delay);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : retry count[1]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : retry count[1]=%d\n",
             nv->bus[1].retry_count);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : retry delay[1]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : retry delay[1]=%d\n",
             nv->bus[1].retry_delay);
     qla1280_print(debug_buff);
 
-    sprintf(debug_buff,"qla1280 : async data setup time[0]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : async data setup time[0]=%d\n",
             nv->bus[0].config_2.async_data_setup_time);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : async data setup time[1]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : async data setup time[1]=%d\n",
             nv->bus[1].config_2.async_data_setup_time);
     qla1280_print(debug_buff);
 
-    sprintf(debug_buff,"qla1280 : req/ack active negation[0]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : req/ack active negation[0]=%d\n",
             nv->bus[0].config_2.req_ack_active_negation);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : req/ack active negation[1]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : req/ack active negation[1]=%d\n",
             nv->bus[1].config_2.req_ack_active_negation);
     qla1280_print(debug_buff);
 
-    sprintf(debug_buff,"qla1280 : data line active negation[0]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : data line active negation[0]=%d\n",
             nv->bus[0].config_2.data_line_active_negation);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : data line active negation[1]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : data line active negation[1]=%d\n",
             nv->bus[1].config_2.data_line_active_negation);
     qla1280_print(debug_buff);
 
 
-    sprintf(debug_buff,"qla1280 : disable loading risc code=%d\n\r",
+    sprintf(debug_buff,"qla1280 : disable loading risc code=%d\n",
             nv->cntr_flags_1.disable_loading_risc_code);
     qla1280_print(debug_buff);
 
-    sprintf(debug_buff,"qla1280 : enable 64bit addressing=%d\n\r",
+    sprintf(debug_buff,"qla1280 : enable 64bit addressing=%d\n",
             nv->cntr_flags_1.enable_64bit_addressing);
     qla1280_print(debug_buff);
 
-    sprintf(debug_buff,"qla1280 : selection timeout limit[0]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : selection timeout limit[0]=%d\n",
             nv->bus[0].selection_timeout);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : selection timeout limit[1]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : selection timeout limit[1]=%d\n",
             nv->bus[1].selection_timeout);
 
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : max queue depth[0]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : max queue depth[0]=%d\n",
             nv->bus[0].max_queue_depth);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"qla1280 : max queue depth[1]=%d\n\r",
+    sprintf(debug_buff,"qla1280 : max queue depth[1]=%d\n",
             nv->bus[1].max_queue_depth);
     qla1280_print(debug_buff);
 #endif
@@ -3346,7 +3086,7 @@
     ha->flags.disable_risc_code_load =
             nv->cntr_flags_1.disable_loading_risc_code;
 
-#if BITS_PER_LONG > 32
+#ifdef QLA_64BIT_PTR
     /* Enable 64bit addressing for OS/System combination supporting it   */
     /* actual NVRAM bit is: nv->cntr_flags_1.enable_64bit_addressing     */ 
     /* but we will ignore it and use BITS_PER_LONG macro to setup for    */
@@ -3360,12 +3100,7 @@
     if (ha->flags.enable_64bit_addressing) {
       printk("[[[ qla1x160: 64 Bit PCI Addressing Enabled ]]]\n");
 
-#if BITS_PER_LONG > 32
-           /* Update our PCI device dma_mask for full 64 bit mask */
-           //ha->pdev->dma_mask = (pci_dma_t) 0xffffffffffffffffull;
-           ha->pdev->dma_mask =  0xffffffffffffffff;
-
-#endif
+      pci_set_dma_mask(ha->pdev, (dma_addr_t)~0ULL);
     }
 #endif
 
@@ -3496,7 +3231,7 @@
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     DEBUG(if (status))
-        DEBUG(qla1280_print("qla1280_nvram_config: **** FAILED ****\n\r");)
+        DEBUG(qla1280_print("qla1280_nvram_config: **** FAILED ****\n");)
 #endif
     LEAVE("qla1280_nvram_config");
     return(status);
@@ -3514,7 +3249,7 @@
  * Returns:
  *      data word.
  */
-STATIC uint16_t
+static uint16_t
 qla1280_get_nvram_word(scsi_qla_host_t *ha, uint32_t address)
 {
     uint32_t nv_cmd;
@@ -3523,9 +3258,6 @@
 #ifdef QL_DEBUG_ROUTINES
     uint8_t  saved_print_status = ql_debug_print;
 #endif
-#ifdef QL_DEBUG_LEVEL_4
-    ENTER("qla1280_get_nvram_word");
-#endif
 
     nv_cmd = address << 16;
     nv_cmd |= NV_READ_OP;
@@ -3541,9 +3273,9 @@
 #ifdef QL_DEBUG_LEVEL_4
     qla1280_print("qla1280_get_nvram_word: exiting normally NVRAM data = ");
     qla1280_output_number((uint32_t)data, 16);
-    qla1280_print("\n\r");
+    qla1280_print("\n");
 #endif
-    return(data);
+    return data;
 }
 
 /*
@@ -3560,11 +3292,11 @@
  * Returns:
  *      data word.
  */
-STATIC uint16_t
+static uint16_t
 qla1280_nvram_request(scsi_qla_host_t *ha, uint32_t nv_cmd)
 {
-    uint8_t      cnt;
     device_reg_t *reg = ha->iobase;
+    int		 cnt;
     uint16_t     data = 0;
     uint16_t     reg_data;
 
@@ -3585,52 +3317,36 @@
     for (cnt = 0; cnt < 16; cnt++)
     {
         WRT_REG_WORD(&reg->nvram, NV_SELECT+NV_CLOCK);
-        /* qla1280_nv_delay(ha); */
         NVRAM_DELAY();
         data <<= 1;
         reg_data = RD_REG_WORD(&reg->nvram);
         if (reg_data & NV_DATA_IN)
             data |= BIT_0;
         WRT_REG_WORD(&reg->nvram, NV_SELECT);
-        /* qla1280_nv_delay(ha); */
         NVRAM_DELAY();
     }
 
     /* Deselect chip. */
 
     WRT_REG_WORD(&reg->nvram, NV_DESELECT);
-    /* qla1280_nv_delay(ha); */
     NVRAM_DELAY();
 
     return(data);
 }
 
-STATIC void
+static void
 qla1280_nv_write(scsi_qla_host_t *ha, uint16_t data)
 {
     device_reg_t *reg = ha->iobase;
 
     WRT_REG_WORD(&reg->nvram, data | NV_SELECT);
     NVRAM_DELAY();
-    /* qla1280_nv_delay(ha); */
     WRT_REG_WORD(&reg->nvram, data | NV_SELECT | NV_CLOCK);
-    /* qla1280_nv_delay(ha); */
     NVRAM_DELAY();
     WRT_REG_WORD(&reg->nvram, data | NV_SELECT);
-    /* qla1280_nv_delay(ha); */
     NVRAM_DELAY();
 }
 
-STATIC void
-qla1280_nv_delay(scsi_qla_host_t *ha)
-{
-    device_reg_t *reg = ha->iobase;
-    int          cnt  = NV_DELAY_COUNT;
-    uint16_t     data = 0;
-
-    while (cnt--)
-        data |= RD_REG_WORD(&reg->nvram);
-}
 
 /*
  * Mailbox Command
@@ -3647,28 +3363,20 @@
  * Returns:
  *      0 = success
  */
-STATIC uint8_t
+static int
 qla1280_mailbox_command(scsi_qla_host_t *ha, uint8_t mr, uint16_t *mb)
 {
     device_reg_t *reg   = ha->iobase;
-    uint8_t      status = 0;
-    uint32_t     cnt;
-    uint16_t     *optr, *iptr;
-    uint16_t     data;
     srb_t        *done_q_first = 0;
     srb_t        *done_q_last = 0;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
+    int		 status = 0;
+    int		 cnt;
+    uint16_t     *optr, *iptr;
+    uint16_t     data;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_mailbox_command");
-#endif
 
-    /* Acquire interrupt specific lock */
-    QLA1280_INTR_LOCK(ha);
-    DRIVER_LOCK
-            ha->flags.mbox_busy = TRUE;
+    ha->flags.mbox_busy = TRUE;
 
     /* Load mailbox registers. */
     optr = (uint16_t *)&reg->mailbox0;
@@ -3693,11 +3401,10 @@
     for (cnt = 30000000; cnt > 0 && !ha->flags.mbox_int; cnt--)
     {
         /* Check for pending interrupts. */
-        if (data & RISC_INT)
-        {
+        if (data & RISC_INT) {
             qla1280_isr(ha, (srb_t **)&done_q_first, (srb_t **)&done_q_last);
         }
-        SYS_DELAY(1);
+        udelay(1);
         data = RD_REG_WORD(&reg->istatus);
     }
 
@@ -3708,7 +3415,7 @@
         qla1280_print(
                 "qla1280_mailbox_command: **** Command Timeout, mailbox0 = ");
         qla1280_output_number((uint32_t)mb[0], 16);
-        qla1280_print(" ****\n\r");
+        qla1280_print(" ****\n");
 #endif
         ha->flags.isp_abort_needed = TRUE; 
         status = 1;
@@ -3721,17 +3428,13 @@
     iptr = (uint16_t *)&ha->mailbox_out[0];
     mr = MAILBOX_REGISTER_COUNT;
     while (mr--)
-        *optr++ = *iptr++;
+	*optr++ = *iptr++;
 
     /* Go check for any response interrupts pending. */
     ha->flags.mbox_busy = FALSE;
     qla1280_isr(ha, (srb_t **)&done_q_first, (srb_t **)&done_q_last);
 
-    /* Release interrupt specific lock */
-    QLA1280_INTR_UNLOCK(ha);
-    DRIVER_UNLOCK
-
-            if (ha->flags.isp_abort_needed)
+    if (ha->flags.isp_abort_needed)
         qla1280_abort_isp(ha);
 
     if (ha->flags.reset_marker)
@@ -3745,14 +3448,12 @@
     {
         qla1280_print("qla1280_mailbox_command: **** FAILED, mailbox0 = ");
         qla1280_output_number((uint32_t)mb[0], 16);
-        qla1280_print(" ****\n\r");
+        qla1280_print(" ****\n");
     }
 #endif
-#ifdef QL_DEBUG_LEVEL_3
-    else
-        LEAVE("qla1280_mailbox_command");
-#endif
-    return(status);
+
+    LEAVE("qla1280_mailbox_command");
+    return status;
 }
 
 /*
@@ -3762,7 +3463,7 @@
  * Input:
  *      ha = adapter block pointer.
  */
-STATIC void
+static void
 qla1280_poll(scsi_qla_host_t *ha)
 {
     device_reg_t    *reg   = ha->iobase;
@@ -3770,21 +3471,13 @@
     srb_t           *done_q_first = 0;
     srb_t           *done_q_last = 0;
 
-#ifdef QL_DEBUG_LEVEL_3
     /* ENTER("qla1280_poll"); */
-#endif
-
-    /* Acquire interrupt specific lock */
-    QLA1280_INTR_LOCK(ha);
 
     /* Check for pending interrupts. */
     data = RD_REG_WORD(&reg->istatus);
     if (data & RISC_INT)
         qla1280_isr(ha, (srb_t **)&done_q_first, (srb_t **)&done_q_last);
 
-    /* Release interrupt specific lock */
-    QLA1280_INTR_UNLOCK(ha);
-
     if (!ha->flags.mbox_busy)
     {
         if (ha->flags.isp_abort_needed)
@@ -3796,9 +3489,7 @@
     if (done_q_first)
         qla1280_done(ha, (srb_t **)&done_q_first, (srb_t **)&done_q_last);
 
-#ifdef QL_DEBUG_LEVEL_3
     /* LEAVE("qla1280_poll"); */
-#endif
 }
 
 /*
@@ -3806,54 +3497,53 @@
  *      Issue SCSI bus reset.
  *
  * Input:
- *      ha = adapter block pointer.
- *      b  = SCSI bus number.
+ *      ha  = adapter block pointer.
+ *      bus = SCSI bus number.
  *
  * Returns:
  *      0 = success
  */
-STATIC uint8_t
-qla1280_bus_reset(scsi_qla_host_t *ha, uint8_t b)
+static int
+qla1280_bus_reset(scsi_qla_host_t *ha, u8 bus)
 {
-    uint8_t     status;
-    uint16_t    mb[MAILBOX_REGISTER_COUNT];
+    uint16_t mb[MAILBOX_REGISTER_COUNT];
+    int status;
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_bus_reset: entered\n\r");
+    qla1280_print("qla1280_bus_reset: entered\n");
 #endif
-   if( qla1280_verbose )
-   {
-    printk("scsi(%d): Resetting SCSI BUS (%d)\n",(int)ha->host_no,b);
-   }
+    if(qla1280_verbose) {
+	printk("scsi(%li): Resetting SCSI BUS (%i)\n", ha->host_no, bus);
+    }
 
     mb[0] = MBC_BUS_RESET;
-    mb[1] = ha->bus_settings[b].bus_reset_delay;
-    mb[2] = (uint16_t)b;
+    mb[1] = ha->bus_settings[bus].bus_reset_delay;
+    mb[2] = (uint16_t)bus;
     status = qla1280_mailbox_command(ha, BIT_2|BIT_1|BIT_0, &mb[0]);
 
     if (status)
     {
-        if (ha->bus_settings[b].failed_reset_count > 2)                  /* dg - 03/13/99 */
-            ha->bus_settings[b].scsi_bus_dead = TRUE;
-        ha->bus_settings[b].failed_reset_count++;
-    }
-	else
-    {
-       QLA1280_DELAY(4);
-       ha->bus_settings[b].scsi_bus_dead = FALSE;                         /* dg - 03/13/99 */
-       ha->bus_settings[b].failed_reset_count = 0;
-       /* Issue marker command. */
-       qla1280_marker(ha, b, 0, 0, MK_SYNC_ALL);
+	if (ha->bus_settings[bus].failed_reset_count > 2)  /* dg - 03/13/99 */
+	    ha->bus_settings[bus].scsi_bus_dead = TRUE;
+	ha->bus_settings[bus].failed_reset_count++;
+    }
+    else
+    {
+	mdelay(4000);
+	ha->bus_settings[bus].scsi_bus_dead = FALSE;       /* dg - 03/13/99 */
+	ha->bus_settings[bus].failed_reset_count = 0;
+	/* Issue marker command. */
+	qla1280_marker(ha, bus, 0, 0, MK_SYNC_ALL);
     }
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
-        qla1280_print("qla1280_bus_reset: **** FAILED ****\n\r");
+        qla1280_print("qla1280_bus_reset: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_bus_reset: exiting normally\n\r");
+        qla1280_print("qla1280_bus_reset: exiting normally\n");
 #endif
-    return(status);
+    return status;
 }
 
 /*
@@ -3861,39 +3551,35 @@
  *      Issue bus device reset message to the target.
  *
  * Input:
- *      ha = adapter block pointer.
- *      b  = SCSI BUS number.
- *      t  = SCSI ID.
+ *      ha      = adapter block pointer.
+ *      bus     = SCSI BUS number.
+ *      target  = SCSI ID.
  *
  * Returns:
  *      0 = success
  */
-STATIC uint8_t
-qla1280_device_reset(scsi_qla_host_t *ha, uint8_t b, uint32_t t)
+static int
+qla1280_device_reset(scsi_qla_host_t *ha, uint8_t bus, uint32_t target)
 {
-    uint8_t     status;
     uint16_t    mb[MAILBOX_REGISTER_COUNT];
+    int status;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_device_reset");
-#endif
 
     mb[0] = MBC_ABORT_TARGET;
-    mb[1] = (b ? (t | BIT_7) : t) << 8;
+    mb[1] = (bus ? (target | BIT_7) : target) << 8;
     mb[2] = 1;
     status = qla1280_mailbox_command(ha, BIT_2|BIT_1|BIT_0, &mb[0]);
 
     /* Issue marker command. */
-    qla1280_marker(ha, b, t, 0, MK_SYNC_ID);
+    qla1280_marker(ha, bus, target, 0, MK_SYNC_ID);
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
-        qla1280_print("qla1280_device_reset: **** FAILED ****\n\r");
-#endif
-#ifdef QL_DEBUG_LEVEL_3
-    else
-        LEAVE("qla1280_device_reset");
+        qla1280_print("qla1280_device_reset: **** FAILED ****\n");
 #endif
+
+    LEAVE("qla1280_device_reset");
     return(status);
 }
 
@@ -3910,32 +3596,28 @@
  * Returns:
  *      0 = success
  */
-STATIC uint8_t
-qla1280_abort_device(scsi_qla_host_t *ha, uint8_t b, uint32_t t, uint32_t l)
+static int
+qla1280_abort_device(scsi_qla_host_t *ha, u8 bus, u32 target, u32 lun)
 {
-    uint8_t     status;
     uint16_t    mb[MAILBOX_REGISTER_COUNT];
+    int status;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_abort_device");
-#endif
 
     mb[0] = MBC_ABORT_DEVICE;
-    mb[1] = (b ? t | BIT_7 : t) << 8 | l;
+    mb[1] = (bus ? target | BIT_7 : target) << 8 | lun;
     status = qla1280_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
 
     /* Issue marker command. */
-    qla1280_marker(ha, b, t, l, MK_SYNC_ID_LUN);
+    qla1280_marker(ha, bus, target, lun, MK_SYNC_ID_LUN);
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
-        qla1280_print("qla1280_abort_device: **** FAILED ****\n\r");
-#endif
-#ifdef QL_DEBUG_LEVEL_3
-    else
-        LEAVE("qla1280_abort_device");
+        qla1280_print("qla1280_abort_device: **** FAILED ****\n");
 #endif
-    return(status);
+
+    LEAVE("qla1280_abort_device");
+    return status;
 }
 
 /*
@@ -3949,41 +3631,39 @@
  * Returns:
  *      0 = success
  */
-STATIC uint8_t
+static int
 qla1280_abort_command(scsi_qla_host_t *ha, srb_t *sp)
 {
-    uint8_t         status;
-    uint16_t        mb[MAILBOX_REGISTER_COUNT];
-    uint32_t        b, t, l;
-    uint32_t        handle;
+    uint16_t	mb[MAILBOX_REGISTER_COUNT];
+    unsigned int b, t, l;
+    uint32_t	handle;
+    int		status;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_abort_command");
-#endif
 
     /* Locate handle number. */
     for (handle = 0; handle < MAX_OUTSTANDING_COMMANDS; handle++)
         if (ha->outstanding_cmds[handle] == sp)
             break;
 
-                b  = SCSI_BUS_32(sp->cmd);
-        t  = SCSI_TCN_32(sp->cmd);
-        l  = SCSI_LUN_32(sp->cmd);
-
-        mb[0] = MBC_ABORT_COMMAND;
-        mb[1] = (b ? t | BIT_7 : t) << 8 | l;
-        mb[2] = handle >> 16;
-        mb[3] = (uint16_t)handle;
-        status = qla1280_mailbox_command(ha, BIT_3|BIT_2|BIT_1|BIT_0, &mb[0]);
+    b  = SCSI_BUS_32(sp->cmd);
+    t  = SCSI_TCN_32(sp->cmd);
+    l  = SCSI_LUN_32(sp->cmd);
+
+    mb[0] = MBC_ABORT_COMMAND;
+    mb[1] = (b ? t | BIT_7 : t) << 8 | l;
+    mb[2] = handle >> 16;
+    mb[3] = handle & 0xffff;
+    status = qla1280_mailbox_command(ha, BIT_3|BIT_2|BIT_1|BIT_0, &mb[0]);
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
-        if (status)
-            qla1280_print("qla1280_abort_command: **** FAILED ****\n\r");
+    if (status)
+	qla1280_print("qla1280_abort_command: **** FAILED ****\n");
 #endif
-        sp->flags |= SRB_ABORT_PENDING;
+    sp->flags |= SRB_ABORT_PENDING;
 
-        LEAVE("qla1280_abort_command");
-        return(status);
+    LEAVE("qla1280_abort_command");
+    return status;
 }
 
 /*
@@ -3993,14 +3673,12 @@
  * Input:
  *      ha = adapter block pointer.
  */
-STATIC void
+static void
 qla1280_reset_adapter(scsi_qla_host_t *ha)
 {
     device_reg_t *reg = ha->iobase;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_reset_adapter");
-#endif
 
     /* Disable ISP chip */
     ha->flags.online = FALSE;
@@ -4009,9 +3687,7 @@
     WRT_REG_WORD(&reg->host_cmd, HC_RELEASE_RISC);
     WRT_REG_WORD(&reg->host_cmd, HC_DISABLE_BIOS);
 
-#ifdef QL_DEBUG_LEVEL_3
     LEAVE("qla1280_reset_adapter");
-#endif
 }
 
 /*
@@ -4020,35 +3696,31 @@
  *
  * Input:
  *      ha   = adapter block pointer.
- *      b    = SCSI BUS number
- *      t    = SCSI ID
- *      l    = SCSI LUN
+ *      bus  = SCSI BUS number
+ *      id   = SCSI ID
+ *      lun  = SCSI LUN
  *      type = marker modifier
  */
-STATIC void
-qla1280_marker(scsi_qla_host_t *ha, uint8_t b, uint32_t t, uint32_t l, uint8_t type)
+static void
+qla1280_marker(scsi_qla_host_t *ha, u8 bus, u32 id, u32 lun, u8 type)
 {
-    mrk_entry_t     *pkt;
+    mrk_entry_t *pkt;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_marker");
-#endif
 
     /* Get request packet. */
-    if ( (pkt = (mrk_entry_t *)qla1280_req_pkt(ha)) )
+    if ((pkt = (mrk_entry_t *)qla1280_req_pkt(ha)))
     {
         pkt->entry_type = MARKER_TYPE;
-        pkt->lun = (uint8_t)l;
-        pkt->target = (uint8_t)(b ? (t | BIT_7) : t);
+        pkt->lun = (uint8_t)lun;
+        pkt->target = (uint8_t)(bus ? (id | BIT_7) : id);
         pkt->modifier = type;
 
         /* Issue command to ISP */
         qla1280_isp_cmd(ha);
     }
 
-#ifdef QL_DEBUG_LEVEL_3
     LEAVE("qla1280_marker");
-#endif
 }
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
@@ -4064,29 +3736,29 @@
  * Returns:
  *      0 = success, was able to issue command.
  */
-STATIC uint8_t
+static int
 qla1280_64bit_start_scsi(scsi_qla_host_t *ha, srb_t *sp)
 {
-    device_reg_t    *reg   = ha->iobase;
-    uint8_t         status = 0;
-    Scsi_Cmnd       *cmd = sp->cmd;
-    uint32_t        cnt;
-    cmd_a64_entry_t     *pkt;
-    uint16_t        req_cnt;
-    uint16_t        seg_cnt;
-    struct scatterlist    *sg = (struct scatterlist *) NULL;
-    uint32_t        *dword_ptr;
-    dma_addr_t       dma_handle;
+    device_reg_t *reg = ha->iobase;
+    Scsi_Cmnd *cmd = sp->cmd;
+    cmd_a64_entry_t *pkt;
+    struct scatterlist *sg = (struct scatterlist *) NULL;
+    u32	*dword_ptr;
+    dma_addr_t	    dma_handle;
+    int	status = 0;
+    int cnt;
+    u16 req_cnt;
+    u16	seg_cnt;
 
     ENTER("qla1280_64bit_start_scsi:");
 
     DEBUG(sprintf(debug_buff,
-          "64bit_start: cmd=%x sp=%x CDB=%x\n\r",cmd,sp,cmd->cmnd[0]);)
+                  "64bit_start: cmd=%p sp=%p CDB=%x\n",
+                  (void *)cmd, (void *)sp, cmd->cmnd[0]);)
     DEBUG(qla1280_print(debug_buff));
 
-    if( qla1280_check_for_dead_scsi_bus(ha, sp) )
-    {
-        return(0);
+    if(qla1280_check_for_dead_scsi_bus(ha, sp)) {
+        return 0;
     }
 
     /* Calculate number of entries and segments required. */
@@ -4100,8 +3772,8 @@
             
         if (seg_cnt > 2)
         {
-           req_cnt += (uint16_t)(seg_cnt - 2) / 5;
-           if ((uint16_t)(seg_cnt - 2) % 5)
+           req_cnt += (seg_cnt - 2) / 5;
+           if ((seg_cnt - 2) % 5)
                req_cnt++;
         }
     }
@@ -4111,10 +3783,7 @@
         seg_cnt = 1;
     }
 
-    /* Acquire ring specific lock */
-    QLA1280_RING_LOCK(ha);
-
-    if ((uint16_t)(req_cnt + 2) >= ha->req_q_cnt)
+    if ((req_cnt + 2) >= ha->req_q_cnt)
     {
         /* Calculate number of free request entries. */
         cnt = RD_REG_WORD(&reg->mailbox4);
@@ -4125,7 +3794,7 @@
     }
 
     /* If room for request in request ring. */
-    if ((uint16_t)(req_cnt + 2) < ha->req_q_cnt)
+    if ((req_cnt + 2) < ha->req_q_cnt)
     {
         /* Check for room in outstanding command list. */
         for (cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS &&
@@ -4149,12 +3818,10 @@
             pkt->handle = (uint32_t)cnt;
 
             /* Zero out remaining portion of packet. */
-            dword_ptr = (uint32_t *)pkt + 2;
-            for (cnt = 2; cnt < REQUEST_ENTRY_SIZE/4; cnt++)
-                *dword_ptr++ = 0;
+            memset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));
 
             /* Set ISP command timeout. */
-            pkt->timeout = (uint16_t)30;
+            pkt->timeout = 30;
 
             /* Set device target ID and LUN */
             pkt->lun = SCSI_LUN_32(cmd);
@@ -4167,12 +3834,12 @@
 
             /* Load SCSI command packet. */
             pkt->cdb_len = (uint16_t)CMD_CDBLEN(cmd);
-            BCOPY(&(CMD_CDBP(cmd)), pkt->scsi_cdb, pkt->cdb_len);
-            //DEBUG(printk("Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]));
+            memcpy(pkt->scsi_cdb, &(CMD_CDBP(cmd)), pkt->cdb_len);
+            /* DEBUG(printk("Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0])); */
 
             /*
-            * Load data segments.
-            */
+	     * Load data segments.
+	     */
             if (seg_cnt)                /* If data transfer. */
             {
                 /* Set transfer direction. */
@@ -4200,7 +3867,7 @@
                         *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
                         sg++;
                         DEBUG(sprintf(debug_buff,
-                         "S/G Segment phys_addr=%x %x, len=0x%x\n\r",
+                         "S/G Segment phys_addr=%x %x, len=0x%x\n",
                           cpu_to_le32(pci_dma_hi32(sg_dma_address(sg))),
                           cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
                                       cpu_to_le32(sg_dma_len(sg)));)
@@ -4215,14 +3882,14 @@
                     qla1280_output_number((uint32_t)SCSI_TCN_32(cmd), 10);
                     qla1280_print(" d ");
                     qla1280_output_number((uint32_t)SCSI_LUN_32(cmd), 10);
-                    qla1280_print("\n\r");
-                    qla1280_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+                    qla1280_print("\n");
+                    qla1280_dump_buffer((char *)pkt, REQUEST_ENTRY_SIZE);
 #endif
                     /*
                     * Build continuation packets.
                     */
                     DEBUG(sprintf(debug_buff,
-                    "S/G Building Continuation...seg_cnt=0x%x remains\n\r",
+                    "S/G Building Continuation...seg_cnt=0x%x remains\n",
                     seg_cnt);)
                     DEBUG(qla1280_print(debug_buff));
                     while (seg_cnt > 0)
@@ -4240,9 +3907,7 @@
                         pkt = (cmd_a64_entry_t *)ha->request_ring_ptr;
 
                         /* Zero out packet. */
-                        dword_ptr = (uint32_t *)pkt;
-                        for (cnt = 0;cnt < REQUEST_ENTRY_SIZE/4; cnt++)
-                            *dword_ptr++ = 0;
+                        memset(pkt, 0, REQUEST_ENTRY_SIZE);
 
                         /* Load packet defaults. */
                         ((cont_a64_entry_t *)pkt)->entry_type =
@@ -4263,7 +3928,7 @@
                            *dword_ptr++ = cpu_to_le32(pci_dma_hi32(sg_dma_address(sg)));
                            *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
                            DEBUG(sprintf(debug_buff,
-                            "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n\r",
+                            "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n",
                              cpu_to_le32(pci_dma_hi32(sg_dma_address(sg))),
                              cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
                              cpu_to_le32(sg_dma_len(sg)));)
@@ -4280,8 +3945,8 @@
                         qla1280_output_number((uint32_t)SCSI_TCN_32(cmd), 10);
                         qla1280_print(" d ");
                         qla1280_output_number((uint32_t)SCSI_LUN_32(cmd), 10);
-                        qla1280_print("\n\r");
-                        qla1280_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+                        qla1280_print("\n");
+                        qla1280_dump_buffer((char *)pkt, REQUEST_ENTRY_SIZE);
 #endif
                     }
                 }
@@ -4298,7 +3963,7 @@
                     *dword_ptr++ = cpu_to_le32(pci_dma_hi32(dma_handle));
                     *dword_ptr   = (uint32_t) cmd->request_bufflen;
                     /*DEBUG(sprintf(debug_buff,
-                    "No S/G map_single saved_dma_handle=%lx\n\r",dma_handle));
+                    "No S/G map_single saved_dma_handle=%lx\n",dma_handle));
                     DEBUG(qla1280_print(debug_buff));*/
 #ifdef QL_DEBUG_LEVEL_5
                     qla1280_print(
@@ -4309,16 +3974,17 @@
                     qla1280_output_number((uint32_t)SCSI_TCN_32(cmd), 10);
                     qla1280_print(" d ");
                     qla1280_output_number((uint32_t)SCSI_LUN_32(cmd), 10);
-                    qla1280_print("\n\r");
-                    qla1280_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+                    qla1280_print("\n");
+                    qla1280_dump_buffer((char *)pkt, REQUEST_ENTRY_SIZE);
 #endif
                 }
             }
             else         /* No data transfer */
             {
-                *dword_ptr++ = (uint32_t) 0;
-                *dword_ptr++ = (uint32_t) 0;
-                *dword_ptr = (uint32_t)  0;
+                dword_ptr = (uint32_t *)(pkt + 1);
+                *dword_ptr++ = 0;
+                *dword_ptr++ = 0;
+                *dword_ptr = 0;
 #ifdef QL_DEBUG_LEVEL_5
                 qla1280_print(
                         "qla1280_64bit_start_scsi: No data, command packet data - c");
@@ -4328,8 +3994,8 @@
                 qla1280_output_number((uint32_t)SCSI_TCN_32(cmd), 10);
                 qla1280_print(" d ");
                 qla1280_output_number((uint32_t)SCSI_LUN_32(cmd), 10);
-                qla1280_print("\n\r");
-                qla1280_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+                qla1280_print("\n");
+                qla1280_dump_buffer((char *)pkt, REQUEST_ENTRY_SIZE);
 #endif
             }
             /* Adjust ring index. */
@@ -4343,7 +4009,7 @@
                 ha->request_ring_ptr++;
 
             /* Set chip new ring index. */
-            DEBUG(qla1280_print("qla1280_64bit_start_scsi: Wakeup RISC for pending command\n\r"));
+            DEBUG(qla1280_print("qla1280_64bit_start_scsi: Wakeup RISC for pending command\n"));
             ha->qthreads--;
             sp->flags |= SRB_SENT;
             ha->actthreads++;
@@ -4354,9 +4020,9 @@
             status = 1;
 #ifdef QL_DEBUG_LEVEL_2
             qla1280_print(
-                    "qla1280_64bit_start_scsi: NO ROOM IN OUTSTANDING ARRAY\n\r");
+                    "qla1280_64bit_start_scsi: NO ROOM IN OUTSTANDING ARRAY\n");
             qla1280_print(" req_q_cnt=");
-            qla1280_output_number((uint32_t)ha->req_q_cnt, 16);
+            qla1280_output_number((u32)ha->req_q_cnt, 16);
 #endif
         }
     }
@@ -4367,25 +4033,22 @@
         qla1280_print("qla1280_64bit_start_scsi: in-ptr=");
         qla1280_output_number((uint32_t)ha->req_ring_index, 16);
         qla1280_print(" req_q_cnt=");
-        qla1280_output_number((uint32_t)ha->req_q_cnt, 16);
+        qla1280_output_number((u32)ha->req_q_cnt, 16);
         qla1280_print(" req_cnt=");
-        qla1280_output_number((uint32_t)req_cnt, 16);
-        qla1280_print("\n\r");
+        qla1280_output_number(req_cnt, 16);
+        qla1280_print("\n");
 #endif
     }
 
-    /* Release ring specific lock */
-    QLA1280_RING_UNLOCK(ha);
-
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
-        qla1280_print("qla1280_64bit_start_scsi: **** FAILED ****\n\r");
+        qla1280_print("qla1280_64bit_start_scsi: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_64bit_start_scsi: exiting normally\n\r");
+        qla1280_print("qla1280_64bit_start_scsi: exiting normally\n");
 #endif
-    return(status);
+    return status;
 }
 #endif
 
@@ -4408,33 +4071,32 @@
  * Returns:
  *      0 = success, was able to issue command.
  */
-STATIC uint8_t
+static int
 qla1280_32bit_start_scsi(scsi_qla_host_t *ha, srb_t *sp)
 {
     device_reg_t    *reg   = ha->iobase;
-    uint8_t         status = 0;
     Scsi_Cmnd       *cmd = sp->cmd;
-    uint32_t        cnt;
     cmd_entry_t     *pkt;
-    uint16_t        req_cnt;
-    uint16_t        seg_cnt;
     struct scatterlist    *sg = (struct scatterlist *) NULL;
-    uint8_t        *data_ptr;
     uint32_t        *dword_ptr;
+    int status = 0;
+    int cnt;
+    int req_cnt;
+    uint16_t seg_cnt;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
-    dma_addr_t       dma_handle;
+    dma_addr_t dma_handle;
 #endif
 
     ENTER("qla1280_32bit_start_scsi");
 
     DEBUG(sprintf(debug_buff,
-          "32bit_start: cmd=%x sp=%x CDB=%x\n\r",cmd,sp,cmd->cmnd[0]);)
+                  "32bit_start: cmd=%p sp=%p CDB=%x\n",
+                  (void *)cmd, (void *)sp, cmd->cmnd[0]));
     DEBUG(qla1280_print(debug_buff));
 
-    if( qla1280_check_for_dead_scsi_bus(ha, sp) )
-    {
-        return(0);
+    if(qla1280_check_for_dead_scsi_bus(ha, sp)) {
+        return 0;
     }
 
     /* Calculate number of entries and segments required. */
@@ -4442,24 +4104,20 @@
     if (cmd->use_sg)
     {
         /*
-        * We must build an SG list in adapter format, as the kernel's SG list
-        * cannot be used directly because of data field size (__alpha__)
-        * differences and the kernel SG list uses virtual addresses where
-        * we need physical addresses.
-        */
+         * We must build an SG list in adapter format, as the kernel's SG list
+         * cannot be used directly because of data field size (__alpha__)
+         * differences and the kernel SG list uses virtual addresses where
+         * we need physical addresses.
+         */
         sg = (struct scatterlist *) cmd->request_buffer;
         /* 3.13 32 bit */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-        seg_cnt =  cmd->use_sg;
-#else
-        seg_cnt = pci_map_sg(ha->pdev,sg,cmd->use_sg, 
-                    scsi_to_pci_dma_dir(cmd->sc_data_direction));
-#endif
+        seg_cnt = pci_map_sg(ha->pdev, sg, cmd->use_sg, 
+                             scsi_to_pci_dma_dir(cmd->sc_data_direction));
 
         /* 
-        * if greater than four sg entries then we need to allocate
-        * continuation entries
-        */
+         * if greater than four sg entries then we need to allocate
+         * continuation entries
+         */
         if (seg_cnt > 4)
         {
             req_cnt += (uint16_t)(seg_cnt - 4) / 7;
@@ -4467,28 +4125,25 @@
                 req_cnt++;
         }
         DEBUG(sprintf(debug_buff,
-         "S/G Transfer cmd=%x seg_cnt=0x%x, req_cnt=%x\n\r",
-          cmd,seg_cnt,req_cnt));
+         "S/G Transfer cmd=%p seg_cnt=0x%x, req_cnt=%x\n",
+          (void *)cmd,seg_cnt,req_cnt));
         DEBUG(qla1280_print(debug_buff));
     }
     else if (cmd->request_bufflen)  /* If data transfer. */
     {
         DEBUG(sprintf(debug_buff,
-         "No S/G transfer t=%x cmd=%x len=%x CDB=%x\n\r",
-         SCSI_TCN_32(cmd),cmd,cmd->request_bufflen,cmd->cmnd[0]));
+         "No S/G transfer t=%x cmd=%p len=%x CDB=%x\n",
+         SCSI_TCN_32(cmd), (void *)cmd,cmd->request_bufflen,cmd->cmnd[0]));
         DEBUG(qla1280_print(debug_buff));
         seg_cnt = 1;
     }
     else
     {
-      //DEBUG(printk("No data transfer \n"));
+	/* DEBUG(printk("No data transfer \n")); */
         seg_cnt = 0;
     }
 
-    /* Acquire ring specific lock */
-    QLA1280_RING_LOCK(ha);
-
-    if ((uint16_t)(req_cnt + 2) >= ha->req_q_cnt)
+    if ((req_cnt + 2) >= ha->req_q_cnt)
     {
         /* Calculate number of free request entries. */
         cnt = RD_REG_WORD(&reg->mailbox4);
@@ -4498,11 +4153,11 @@
             ha->req_q_cnt = REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
     }
 
-    DEBUG(sprintf(debug_buff,"Number of free entries=(%d) seg_cnt=0x%x\n\r",
+    DEBUG(sprintf(debug_buff,"Number of free entries=(%d) seg_cnt=0x%x\n",
           ha->req_q_cnt,seg_cnt));
     DEBUG(qla1280_print(debug_buff));
     /* If room for request in request ring. */
-    if ((uint16_t)(req_cnt + 2) < ha->req_q_cnt)
+    if ((req_cnt + 2) < ha->req_q_cnt)
     {
         /* Check for empty slot in outstanding command list. */
         for (cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS &&
@@ -4516,8 +4171,8 @@
             ha->req_q_cnt -= req_cnt;
 
             /*
-            * Build command packet.
-            */
+	     * Build command packet.
+	     */
             pkt = (cmd_entry_t *)ha->request_ring_ptr;
 
             pkt->entry_type = COMMAND_TYPE;
@@ -4526,9 +4181,7 @@
             pkt->handle = (uint32_t)cnt;
 
             /* Zero out remaining portion of packet. */
-            dword_ptr = (uint32_t *)pkt + 2;
-            for (cnt = 2; cnt < REQUEST_ENTRY_SIZE/4; cnt++)
-                *dword_ptr++ = 0;
+            memset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));
 
             /* Set ISP command timeout. */
             pkt->timeout = (uint16_t)30;
@@ -4544,13 +4197,12 @@
 
             /* Load SCSI command packet. */
             pkt->cdb_len = (uint16_t)CMD_CDBLEN(cmd);
-            data_ptr = (uint8_t *) &(CMD_CDBP(cmd));
-            for (cnt = 0; cnt < pkt->cdb_len; cnt++)
-                pkt->scsi_cdb[cnt] = *data_ptr++;
-            //DEBUG(printk("Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]));
+            memcpy(pkt->scsi_cdb, &(CMD_CDBP(cmd)), pkt->cdb_len);
+
+            /* DEBUG(printk("Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0])); */
             /*
-            * Load data segments.
-            */
+	     * Load data segments.
+	     */
             if (seg_cnt)
             {
                 /* Set transfer direction (READ and WRITE) */
@@ -4576,24 +4228,26 @@
 
                 if (cmd->use_sg)     /* If scatter gather */
                 {
-                    DEBUG(qla1280_print("Building S/G data segments..\n\r"));
-                    DEBUG(qla1280_dump_buffer((caddr_t)sg, 4*16 ));
+#if QL_DEBUG_ROUTINES
+                    DEBUG(qla1280_print("Building S/G data segments..\n"));
+                    DEBUG(qla1280_dump_buffer((char *)sg, 4*16 ));
+#endif
                     /* Load command entry data segments. */
                     for (cnt = 0; cnt < 4 && seg_cnt; cnt++, seg_cnt--)
                     {
                         /* 3.13 32 bit */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-                        *dword_ptr++ = (uint32_t) cpu_to_le32(VIRT_TO_BUS(sg->address));
+                        *dword_ptr++ = cpu_to_le32(virt_to_bus(sg->address));
                         *dword_ptr++ = sg->length;
                         DEBUG(sprintf(debug_buff,
-                         "S/G Segment phys_addr=0x%x, len=0x%x\n\r",
-                          cpu_to_le32(VIRT_TO_BUS(sg->address)),sg->length));
+                         "S/G Segment phys_addr=0x%x, len=0x%x\n",
+                          cpu_to_le32(virt_to_bus(sg->address)),sg->length));
                         DEBUG(qla1280_print(debug_buff));
 #else
                         *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
                         *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
                         DEBUG(sprintf(debug_buff,
-                         "S/G Segment phys_addr=0x%x, len=0x%x\n\r",
+                         "S/G Segment phys_addr=0x%x, len=0x%x\n",
                           cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
                           cpu_to_le32(sg_dma_len(sg)));)
                         DEBUG(qla1280_print(debug_buff));
@@ -4601,10 +4255,10 @@
                         sg++;
                     }
                     /*
-                    * Build continuation packets.
-                    */
+		     * Build continuation packets.
+		     */
                     DEBUG(sprintf(debug_buff,
-                    "S/G Building Continuation...seg_cnt=0x%x remains\n\r",
+                    "S/G Building Continuation...seg_cnt=0x%x remains\n",
                     seg_cnt);)
                     DEBUG(qla1280_print(debug_buff));
                     while (seg_cnt > 0)
@@ -4622,9 +4276,7 @@
                         pkt = (cmd_entry_t *)ha->request_ring_ptr;
 
                         /* Zero out packet. */
-                        dword_ptr = (uint32_t *)pkt;
-                        for (cnt = 0;cnt < REQUEST_ENTRY_SIZE/4; cnt++)
-                            *dword_ptr++ = 0;
+                        memset(pkt, 0, REQUEST_ENTRY_SIZE);
 
                         /* Load packet defaults. */
                         ((cont_entry_t *)pkt)->entry_type =
@@ -4643,18 +4295,18 @@
                         {
                            /* 3.13 32 bit */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-                           *dword_ptr++ = (u_int) cpu_to_le32(VIRT_TO_BUS(sg->address));
+                           *dword_ptr++ = cpu_to_le32(virt_to_bus(sg->address));
                            *dword_ptr++ = sg->length;
                            DEBUG(sprintf(debug_buff,
-                           "S/G Segment Cont. phys_addr=0x%x, len=0x%x\n\r",
-                           cpu_to_le32(pci_dma_lo32(VIRT_TO_BUS(sg->address))),
+                           "S/G Segment Cont. phys_addr=0x%x, len=0x%x\n",
+                           cpu_to_le32(pci_dma_lo32(virt_to_bus(sg->address))),
                            sg->length);)
                            DEBUG(qla1280_print(debug_buff));
 #else
                            *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
                            *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
                            DEBUG(sprintf(debug_buff,
-                            "S/G Segment Cont. phys_addr=0x%x, len=0x%x\n\r",
+                            "S/G Segment Cont. phys_addr=0x%x, len=0x%x\n",
                              cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
                              cpu_to_le32(sg_dma_len(sg)));)
                            DEBUG(qla1280_print(debug_buff));
@@ -4669,8 +4321,8 @@
                         qla1280_output_number((uint32_t)SCSI_TCN_32(cmd), 10);
                         qla1280_print(":");
                         qla1280_output_number((uint32_t)SCSI_LUN_32(cmd), 10);
-                        qla1280_print(")\n\r");
-                        qla1280_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+                        qla1280_print(")\n");
+                        qla1280_dump_buffer((char *)pkt, REQUEST_ENTRY_SIZE);
 #endif
                     }
                 }
@@ -4678,7 +4330,7 @@
                 {
                     /* 3.13 32 bit */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-                    *dword_ptr++ = (uint32_t) cpu_to_le32(VIRT_TO_BUS(cmd->request_buffer));
+                    *dword_ptr++ = cpu_to_le32(virt_to_bus(cmd->request_buffer));
                     *dword_ptr = (uint32_t) cmd->request_bufflen;
 #else
                     dma_handle = pci_map_single(ha->pdev, 
@@ -4690,25 +4342,26 @@
                     *dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
                     *dword_ptr   = (uint32_t) cmd->request_bufflen;
                     /*DEBUG(sprintf(debug_buff,
-                    "No S/G map_single saved_dma_handle=%lx\n\r",dma_handle));
+                    "No S/G map_single saved_dma_handle=%lx\n",dma_handle));
                     DEBUG(qla1280_print(debug_buff));*/
 #endif 
                 }
             }
             else         /* No data transfer at all */
             {
-                *dword_ptr++ = (uint32_t) 0;
-                *dword_ptr = (uint32_t)  0;
+                dword_ptr = (uint32_t *)(pkt + 1);
+                *dword_ptr++ = 0;
+                *dword_ptr = 0;
 #ifdef QL_DEBUG_LEVEL_5
                 qla1280_print(
                         "qla1280_32bit_start_scsi: No data, command packet data - ");
-                qla1280_print("\n\r");
-                qla1280_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+                qla1280_print("\n");
+                qla1280_dump_buffer((char *)pkt, REQUEST_ENTRY_SIZE);
 #endif
             }
 #ifdef QL_DEBUG_LEVEL_5
-            qla1280_print("qla1280_32bit_start_scsi: First IOCB block:\n\r");
-            qla1280_dump_buffer((caddr_t)ha->request_ring_ptr, REQUEST_ENTRY_SIZE);
+            qla1280_print("qla1280_32bit_start_scsi: First IOCB block:\n");
+            qla1280_dump_buffer((char *)ha->request_ring_ptr, REQUEST_ENTRY_SIZE);
 #endif
             /* Adjust ring index. */
             ha->req_ring_index++;
@@ -4721,7 +4374,7 @@
                 ha->request_ring_ptr++;
 
             /* Set chip new ring index. */
-            DEBUG(qla1280_print("qla1280_32bit_start_scsi: Wakeup RISC for pending command\n\r"));
+            DEBUG(qla1280_print("qla1280_32bit_start_scsi: Wakeup RISC for pending command\n"));
             ha->qthreads--;
             sp->flags |= SRB_SENT;
             ha->actthreads++;
@@ -4732,10 +4385,10 @@
             status = 1;
 #ifdef QL_DEBUG_LEVEL_2
             qla1280_print(
-            "qla1280_32bit_start_scsi: NO ROOM IN OUTSTANDING ARRAY\n\r");
+            "qla1280_32bit_start_scsi: NO ROOM IN OUTSTANDING ARRAY\n");
             qla1280_print(" req_q_cnt=");
-            qla1280_output_number((uint32_t)ha->req_q_cnt, 16);
-            qla1280_print("\n\r");
+            qla1280_output_number((u32)ha->req_q_cnt, 16);
+            qla1280_print("\n");
 #endif
         }
     }
@@ -4746,24 +4399,21 @@
         /*  qla1280_print("qla1280_32bit_start_scsi: in-ptr=");
         qla1280_output_number((uint32_t)ha->req_ring_index, 16);
         qla1280_print(" req_q_cnt=");
-        qla1280_output_number((uint32_t)ha->req_q_cnt, 16);
+        qla1280_output_number((u32)ha->req_q_cnt, 16);
         qla1280_print(" req_cnt=");
-        qla1280_output_number((uint32_t)req_cnt, 16);
-        qla1280_print("\n\r"); */
+        qla1280_output_number(req_cnt, 16);
+        qla1280_print("\n"); */
 #endif
     }
 
-    /* Release ring specific lock */
-    QLA1280_RING_UNLOCK(ha);
-
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     /* if (status)
-    qla1280_print("qla1280_32bit_start_scsi: **** FAILED ****\n\r"); */
+    qla1280_print("qla1280_32bit_start_scsi: **** FAILED ****\n"); */
 #endif
 #ifdef QL_DEBUG_LEVEL_3
             LEAVE("qla1280_32bit_start_scsi");
 #endif
-    return(status);
+    return status;
 }
 
 
@@ -4778,25 +4428,22 @@
  * Returns:
  *      0 = failed to get slot.
  */
-STATIC request_t *
+static request_t *
 qla1280_req_pkt(scsi_qla_host_t *ha)
 {
     device_reg_t    *reg = ha->iobase;
     request_t       *pkt = 0;
-    uint16_t        cnt;
-    uint32_t        *dword_ptr;
+    int		    cnt;
     uint32_t        timer;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_req_pkt");
-#endif
 
+    /*
+     * This can be called from interrupt context, damn it!!!
+     */
     /* Wait for 30 seconds for slot. */
     for (timer = 15000000; timer; timer--)
     {
-        /* Acquire ring specific lock */
-        QLA1280_RING_LOCK(ha);
-
         if (ha->req_q_cnt > 0)
         {
             /* Calculate number of free request entries. */
@@ -4814,9 +4461,7 @@
             pkt = ha->request_ring_ptr;
 
             /* Zero out packet. */
-            dword_ptr = (uint32_t *)pkt;
-            for (cnt = 0; cnt < REQUEST_ENTRY_SIZE/4; cnt++)
-                *dword_ptr++ = 0;
+            memset(pkt, 0, REQUEST_ENTRY_SIZE);
 
             /* Set system defined field. */
             pkt->sys_define = (uint8_t)ha->req_ring_index;
@@ -4827,10 +4472,7 @@
             break;
         }
 
-        /* Release ring specific lock */
-        QLA1280_RING_UNLOCK(ha);
-
-        SYS_DELAY(2);   /* 10 */ 
+        udelay(2);   /* 10 */ 
 
         /* Check for pending interrupts. */
         qla1280_poll(ha);
@@ -4838,11 +4480,11 @@
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (!pkt)
-        qla1280_print("qla1280_req_pkt: **** FAILED ****\n\r");
+        qla1280_print("qla1280_req_pkt: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_req_pkt: exiting normally\n\r");
+        qla1280_print("qla1280_req_pkt: exiting normally\n");
 #endif
     return(pkt);
 }
@@ -4855,18 +4497,16 @@
  * Input:
  *      ha  = adapter block pointer.
  */
-STATIC void
+static void
 qla1280_isp_cmd(scsi_qla_host_t *ha)
 {
     device_reg_t    *reg = ha->iobase;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_isp_cmd");
-#endif
 
 #ifdef QL_DEBUG_LEVEL_5
-    qla1280_print("qla1280_isp_cmd: IOCB data:\n\r");
-    qla1280_dump_buffer((caddr_t)ha->request_ring_ptr, REQUEST_ENTRY_SIZE); 
+    qla1280_print("qla1280_isp_cmd: IOCB data:\n");
+    qla1280_dump_buffer((char *)ha->request_ring_ptr, REQUEST_ENTRY_SIZE); 
 #endif
 
     /* Adjust ring index. */
@@ -4882,14 +4522,10 @@
     /* Set chip new ring index. */
     WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
 
-    /* Release ring specific lock */
-    QLA1280_RING_UNLOCK(ha);
-
-#ifdef QL_DEBUG_LEVEL_3
     LEAVE("qla1280_isp_cmd");
-#endif
 }
 
+#if QL1280_LUN_SUPPORT
 /*
  * qla1280_enable_lun
  *      Issue enable LUN entry IOCB.
@@ -4899,41 +4535,42 @@
  *      b  = SCSI BUS number.
  *      l  = LUN number.
  */
-STATIC void
-qla1280_enable_lun(scsi_qla_host_t *ha, uint8_t b, uint32_t l)
+static void
+qla1280_enable_lun(scsi_qla_host_t *ha, uint8_t bus, uint32_t lun)
 {
     elun_entry_t    *pkt;
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_enable_lun: entered\n\r");
+    qla1280_print("qla1280_enable_lun: entered\n");
 #endif
 
     /* Get request packet. */
     /*
     if (pkt = (elun_entry_t *)qla1280_req_pkt(ha))
     {
-    pkt->entry_type = ENABLE_LUN_TYPE;
-    pkt->lun = (uint16_t)(b ? l | BIT_15 : l);
-    pkt->command_count = 32;
-    pkt->immed_notify_count = 1;
-    pkt->group_6_length = MAX_CMDSZ;
-    pkt->group_7_length = MAX_CMDSZ;
-    pkt->timeout = 0x30;
+	pkt->entry_type = ENABLE_LUN_TYPE;
+	pkt->lun = (uint16_t)(bus ? lun | BIT_15 : lun);
+	pkt->command_count = 32;
+	pkt->immed_notify_count = 1;
+	pkt->group_6_length = MAX_CMDSZ;
+	pkt->group_7_length = MAX_CMDSZ;
+	pkt->timeout = 0x30;
 
-    qla1280_isp_cmd(ha);
+	qla1280_isp_cmd(ha);
     }
     */
     pkt = (elun_entry_t *)1;
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (!pkt)
-        qla1280_print("qla1280_enable_lun: **** FAILED ****\n\r");
+        qla1280_print("qla1280_enable_lun: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_enable_lun: exiting normally\n\r");
+        qla1280_print("qla1280_enable_lun: exiting normally\n");
 #endif
 }
+#endif
 
 #if QL1280_TARGET_MODE_SUPPORT
 /****************************************************************************/
@@ -4950,13 +4587,13 @@
  *      ha      = adapter block pointer.
  *      inotify = immediate notify entry pointer.
  */
-STATIC void
+static void
 qla1280_notify_ack(scsi_qla_host_t *ha, notify_entry_t *inotify)
 {
     nack_entry_t    *pkt;
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_notify_ack: entered\n\r");
+    qla1280_print("qla1280_notify_ack: entered\n");
 #endif
 
     /* Get request packet. */
@@ -4977,11 +4614,11 @@
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (!pkt)
-        qla1280_print("qla1280_notify_ack: **** FAILED ****\n\r");
+        qla1280_print("qla1280_notify_ack: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_notify_ack: exiting normally\n\r");
+        qla1280_print("qla1280_notify_ack: exiting normally\n");
 #endif
 }
 
@@ -4993,13 +4630,13 @@
  *      ha      = adapter block pointer.
  *      inotify = immediate notify entry pointer.
  */
-STATIC void
+static void
 qla1280_immed_notify(scsi_qla_host_t *ha, notify_entry_t *inotify)
 {
     notify_entry_t    *pkt;
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_immed_notify: entered\n\r");
+    qla1280_print("qla1280_immed_notify: entered\n");
 #endif
 
     /* Get request packet. */
@@ -5017,11 +4654,11 @@
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (!pkt)
-        qla1280_print("qla1280_immed_notify: **** FAILED ****\n\r");
+        qla1280_print("qla1280_immed_notify: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_immed_notify: exiting normally\n\r");
+        qla1280_print("qla1280_immed_notify: exiting normally\n");
 #endif
 }
 
@@ -5033,13 +4670,13 @@
  *      ha = adapter block pointer.
  *      ctio = ctio returned entry pointer.
  */
-STATIC void
+static void
 qla1280_accept_io(scsi_qla_host_t *ha, ctio_ret_entry_t *ctio)
 {
     atio_entry_t    *pkt;
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_accept_io: entered\n\r");
+    qla1280_print("qla1280_accept_io: entered\n");
 #endif
 
     /* Get request packet. */
@@ -5058,11 +4695,11 @@
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (!pkt)
-        qla1280_print("qla1280_accept_io: **** FAILED ****\n\r");
+        qla1280_print("qla1280_accept_io: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_accept_io: exiting normally\n\r");
+        qla1280_print("qla1280_accept_io: exiting normally\n");
 #endif
 }
 
@@ -5076,7 +4713,7 @@
  *      len  = total bytecount.
  *      addr = physical address pointer.
  */
-STATIC void
+static void
 qla1280_64bit_continue_io(scsi_qla_host_t *ha, atio_entry_t *atio, uint32_t len,
                     paddr32_t *addr)
 {
@@ -5084,7 +4721,7 @@
     uint32_t         *dword_ptr;
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_64bit_continue_io: entered\n\r");
+    qla1280_print("qla1280_64bit_continue_io: entered\n");
 #endif
 
     /* Get request packet. */
@@ -5114,11 +4751,11 @@
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (!pkt)
-        qla1280_print("qla1280_64bit_continue_io: **** FAILED ****\n\r");
+        qla1280_print("qla1280_64bit_continue_io: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_64bit_continue_io: exiting normally\n\r");
+        qla1280_print("qla1280_64bit_continue_io: exiting normally\n");
 #endif
 }
 
@@ -5132,7 +4769,7 @@
  *      len  = total bytecount.
  *      addr = physical address pointer.
  */
-STATIC void
+static void
 qla1280_32bit_continue_io(scsi_qla_host_t *ha, atio_entry_t *atio, uint32_t len,
                     paddr32_t *addr)
 {
@@ -5140,7 +4777,7 @@
     uint32_t     *dword_ptr;
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_32bit_continue_io: entered\n\r");
+    qla1280_print("qla1280_32bit_continue_io: entered\n");
 #endif
 
     /* Get request packet. */
@@ -5169,11 +4806,11 @@
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (!pkt)
-        qla1280_print("qla1280_32bit_continue_io: **** FAILED ****\n\r");
+        qla1280_print("qla1280_32bit_continue_io: **** FAILED ****\n");
 #endif
 #ifdef QL_DEBUG_LEVEL_3
     else
-        qla1280_print("qla1280_32bit_continue_io: exiting normally\n\r");
+        qla1280_print("qla1280_32bit_continue_io: exiting normally\n");
 #endif
 }
 #endif /* QL1280_TARGET_MODE_SUPPORT */
@@ -5190,9 +4827,8 @@
  *      ha           = adapter block pointer.
  *      done_q_first = done queue first pointer.
  *      done_q_last  = done queue last pointer.
- *      INTR_LOCK must be already obtained.
  ****************************************************************************/
-STATIC void
+static void
 qla1280_isr(scsi_qla_host_t *ha, srb_t **done_q_first, srb_t **done_q_last)
 {
     device_reg_t    *reg = ha->iobase;
@@ -5201,9 +4837,13 @@
     uint16_t        mailbox[MAILBOX_REGISTER_COUNT];
     uint16_t        *wptr;
     uint32_t        index;
+    u16	istatus;
 
     ENTER("qla1280_isr");
 
+    istatus = RD_REG_WORD(&reg->istatus);
+    if (!(istatus & (RISC_INT | PCI_INT)))
+        return;
 
     /* Save mailbox register 5 */
     mailbox[5] = RD_REG_WORD(&reg->mailbox5);
@@ -5215,7 +4855,7 @@
     if (mailbox[0] & BIT_0)
     {
         /* Get mailbox data. */
-        //DEBUG(qla1280_print("qla1280_isr: In Get mailbox data \n\r");)
+        /* DEBUG(qla1280_print("qla1280_isr: In Get mailbox data \n");) */
 
         wptr = &mailbox[0];
         *wptr++ = RD_REG_WORD(&reg->mailbox0);
@@ -5239,7 +4879,7 @@
 #ifdef QL_DEBUG_LEVEL_5
         qla1280_print("qla1280_isr: mailbox interrupt mailbox[0] = ");
         qla1280_output_number((uint32_t)mailbox[0], 16);
-        qla1280_print("\n\r");
+        qla1280_print("\n");
 #endif
 
         /* Handle asynchronous event */
@@ -5248,7 +4888,7 @@
         {
             case MBA_SCSI_COMPLETION:   /* Response completion */
 #ifdef QL_DEBUG_LEVEL_5
-                qla1280_print("qla1280_isr: mailbox SCSI response completion\n\r");
+                qla1280_print("qla1280_isr: mailbox SCSI response completion\n");
 #endif
                 if (ha->flags.online)
                 {
@@ -5283,7 +4923,7 @@
                     {
 
 #ifdef QL_DEBUG_LEVEL_2
-                            qla1280_print("qla1280_isr: ISP invalid handle\n\r");
+                            qla1280_print("qla1280_isr: ISP invalid handle\n");
 #endif
                             printk(KERN_WARNING "qla1280: ISP invalid handle");
                             ha->flags.isp_abort_needed = TRUE;
@@ -5292,7 +4932,7 @@
                 break;
             case MBA_BUS_RESET:         /* SCSI Bus Reset */
 #ifdef QL_DEBUG_LEVEL_2
-                qla1280_print("qla1280_isr: asynchronous BUS_RESET\n\r");
+                qla1280_print("qla1280_isr: asynchronous BUS_RESET\n");
 #endif
                 ha->flags.reset_marker = TRUE;
                 index = mailbox[6] & BIT_0;
@@ -5306,7 +4946,7 @@
                 qla1280_output_number((uint32_t)mailbox[2], 16);
                 qla1280_print(", mbx3=");
                 qla1280_output_number((uint32_t)mailbox[3], 16);
-                qla1280_print("\n\r");
+                qla1280_print("\n");
 #endif
                 printk(KERN_WARNING
                         "qla1280: ISP System Error - mbx1=%xh, mbx2=%xh, mbx3=%xh\n",
@@ -5315,32 +4955,32 @@
                 break;
             case MBA_REQ_TRANSFER_ERR:  /* Request Transfer Error */
 #ifdef QL_DEBUG_LEVEL_2
-                qla1280_print("qla1280_isr: ISP Request Transfer Error\n\r");
+                qla1280_print("qla1280_isr: ISP Request Transfer Error\n");
 #endif
                 printk(KERN_WARNING "qla1280: ISP Request Transfer Error\n");
                 ha->flags.isp_abort_needed = TRUE;
                 break;
             case MBA_RSP_TRANSFER_ERR:  /* Response Transfer Error */
 #ifdef QL_DEBUG_LEVEL_2
-                qla1280_print("qla1280_isr: ISP Response Transfer Error\n\r");
+                qla1280_print("qla1280_isr: ISP Response Transfer Error\n");
 #endif
                 printk(KERN_WARNING "qla1280: ISP Response Transfer Error\n");
                 ha->flags.isp_abort_needed = TRUE;
                 break;
             case MBA_WAKEUP_THRES:      /* Request Queue Wake-up */
 #ifdef QL_DEBUG_LEVEL_2
-                qla1280_print("qla1280_isr: asynchronous WAKEUP_THRES\n\r");
+                qla1280_print("qla1280_isr: asynchronous WAKEUP_THRES\n");
 #endif
                 break;
             case MBA_TIMEOUT_RESET:     /* Execution Timeout Reset */
 #ifdef QL_DEBUG_LEVEL_2
-                qla1280_print("qla1280_isr: asynchronous TIMEOUT_RESET\n\r");
+                qla1280_print("qla1280_isr: asynchronous TIMEOUT_RESET\n");
 #endif
                 break;
             case MBA_DEVICE_RESET:         /* Bus Device Reset */
 #ifdef QL_DEBUG_LEVEL_2
                 qla1280_print(
-                        "qla1280_isr: asynchronous BUS_DEVICE_RESET\n\r");
+                        "qla1280_isr: asynchronous BUS_DEVICE_RESET\n");
 #endif
                 ha->flags.reset_marker = TRUE;
                 index = mailbox[6] & BIT_0;
@@ -5349,11 +4989,11 @@
             case MBA_BUS_MODE_CHANGE:
 #ifdef QL_DEBUG_LEVEL_2
                 qla1280_print(
-                        "qla1280_isr: asynchronous BUS_MODE_CHANGE\n\r");
+                        "qla1280_isr: asynchronous BUS_MODE_CHANGE\n");
 #endif
                 break;
             default:
-              //DEBUG(qla1280_print("qla1280_isr: default case of switch MB \n\r");)
+		/* DEBUG(qla1280_print("qla1280_isr: default case of switch MB \n");) */
                 if (mailbox[0] < MBA_ASYNC_EVENT)
                 {
                         wptr = &mailbox[0];
@@ -5389,8 +5029,8 @@
                 qla1280_output_number((uint32_t)ha->rsp_ring_index, 16);
                 qla1280_print(" mailbox[5] = ");
                 qla1280_output_number((uint32_t)mailbox[5], 16);
-                qla1280_print("\n\rqla1280_isr: response packet data\n\r");
-                qla1280_dump_buffer((caddr_t)pkt, RESPONSE_ENTRY_SIZE);
+                qla1280_print("\nqla1280_isr: response packet data\n");
+                qla1280_dump_buffer((char *)pkt, RESPONSE_ENTRY_SIZE);
 #endif
 
 #if defined(QL_DEBUG_LEVEL_2) && !defined(QL_DEBUG_LEVEL_5)
@@ -5404,15 +5044,15 @@
                                 16);)
                         DEBUG(qla1280_print(" mailbox[5] = ");)
                         DEBUG(qla1280_output_number((uint32_t)mailbox[5], 16);)
-                        DEBUG(qla1280_print( "\n\r comp_status = ");)
+                        DEBUG(qla1280_print( "\n comp_status = ");)
                         DEBUG(qla1280_output_number((uint32_t)pkt->comp_status,16);)
                         DEBUG(qla1280_print( ", ");)
                         DEBUG(qla1280_print( " scsi_status = ");)
                         DEBUG(qla1280_output_number((uint32_t)pkt->scsi_status,16);)
-                        DEBUG(qla1280_print( "\n\r");)
+                        DEBUG(qla1280_print( "\n");)
                         /* qla1280_print(
-                        "\n\rqla1280_isr: response packet data\n\r");
-                        qla1280_dump_buffer((caddr_t)pkt,
+                        "\nqla1280_isr: response packet data\n");
+                        qla1280_dump_buffer((char *)pkt,
                         RESPONSE_ENTRY_SIZE); */
                     }
                 }
@@ -5423,8 +5063,8 @@
                     qla1280_print(" mailbox[5] = ");
                     qla1280_output_number((uint32_t)mailbox[5], 16);
                     qla1280_print(
-                            "\n\rqla1280_isr: response packet data\n\r");
-                    qla1280_dump_buffer((caddr_t)pkt, RESPONSE_ENTRY_SIZE);
+                            "\nqla1280_isr: response packet data\n");
+                    qla1280_dump_buffer((char *)pkt, RESPONSE_ENTRY_SIZE);
                 }
 #endif
                 if (pkt->entry_type == STATUS_TYPE || pkt->entry_status)
@@ -5436,7 +5076,6 @@
                         qla1280_error_entry(ha, pkt,
                                 done_q_first, done_q_last);
 
-
                     /* Adjust ring index. */
                     ha->rsp_ring_index++;
                     if (ha->rsp_ring_index == RESPONSE_ENTRY_CNT)
@@ -5470,9 +5109,6 @@
                         ha->response_ring_ptr++;
                     WRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);
 
-                    /* Release interrupt specific lock */
-                    QLA1280_INTR_UNLOCK(ha);
-
                     switch (pkt->entry_type)
                     {
                         case ACCEPT_TGT_IO_TYPE:
@@ -5487,9 +5123,6 @@
                         default:
                             break;
                     }
-
-                    /* Acquire interrupt specific lock */
-                    QLA1280_INTR_LOCK(ha);
                 }
 #endif
             }
@@ -5513,17 +5146,15 @@
  * Input:
  *      ha  = adapter block pointer.
  */
-STATIC void
+static void
 qla1280_rst_aen(scsi_qla_host_t *ha)
 {
 #if QL1280_TARGET_MODE_SUPPORT
     notify_entry_t  nentry;
 #endif
-    uint8_t         b;
+    uint8_t         bus;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_rst_aen");
-#endif
 
     if (ha->flags.online && !ha->flags.reset_active &&
         !ha->flags.abort_isp_active)
@@ -5533,25 +5164,24 @@
         {
             /* Issue marker command. */
             ha->flags.reset_marker = FALSE;
-            for (b = 0; b < ha->ports && !ha->flags.reset_marker; b++)
+            for (bus = 0; bus < ha->ports && !ha->flags.reset_marker; bus++)
             {
-                if (ha->bus_settings[b].reset_marker)
+                if (ha->bus_settings[bus].reset_marker)
                 {
-                    ha->bus_settings[b].reset_marker = FALSE;
-                    qla1280_marker(ha, b, 0, 0, MK_SYNC_ALL);
+                    ha->bus_settings[bus].reset_marker = FALSE;
+                    qla1280_marker(ha, bus, 0, 0, MK_SYNC_ALL);
 
                     if (!ha->flags.reset_marker)
                     {
 #if QL1280_TARGET_MODE_SUPPORT
                         /* Issue notify acknowledgement command. */
-                        bzero((caddr_t)&nentry, sizeof(notify_entry_t));
+                        memset(&nentry, 0, sizeof(notify_entry_t));
 
-                        nentry.initiator_id = nentry.target_id = b ?
-                                ha->bus_settings[b].id | BIT_7 :
-                        ha->bus_settings[b].id;
+                        nentry.initiator_id = nentry.target_id = bus ?
+                                ha->bus_settings[bus].id | BIT_7 :
+                        ha->bus_settings[bus].id;
                         qla1280_notify_entry(ha, &nentry);
 #endif
-
                         /* Asynchronous event notification */
                     }
                 }
@@ -5559,9 +5189,7 @@
         }
     }
 
-#ifdef QL_DEBUG_LEVEL_3
     LEAVE("qla1280_rst_aen");
-#endif
 }
 
 #if QL1280_TARGET_MODE_SUPPORT
@@ -5573,7 +5201,7 @@
  *      ha  = adapter block pointer.
  *      pkt = entry pointer.
  */
-STATIC void
+static void
 qla1280_atio_entry(scsi_qla_host_t *ha, atio_entry_t *pkt)
 {
     uint64_t    *a64;
@@ -5586,7 +5214,7 @@
     uint8_t     *sense_ptr;
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_atio_entry: entered\n\r");
+    qla1280_print("qla1280_atio_entry: entered\n");
 #endif
 
     t = pkt->initiator_id;
@@ -5598,28 +5226,28 @@
     {
         case 7:                         /* Path invalid */
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
-            qla1280_print("qla1280_atio_entry: Path invalid\n\r");
+            qla1280_print("qla1280_atio_entry: Path invalid\n");
 #endif
             break;
         case 0x14:                  /* Target Bus Phase Sequence Failure */
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
             qla1280_print(
-                    "qla1280_atio_entry: Target Bus Phase Sequence Failure\n\r");
+                    "qla1280_atio_entry: Target Bus Phase Sequence Failure\n");
 #endif
             if (pkt->status & BIT_7)
             {
-                BCOPY((caddr_t)&pkt->sense_data, sense_ptr,TARGET_SENSE_SIZE);
+                memcpy(sense_ptr, &pkt->sense_data, TARGET_SENSE_SIZE);
             }
             else
             {
-                    bzero(sense_ptr, TARGET_SENSE_SIZE);
+                    memset(sense_ptr, 0, TARGET_SENSE_SIZE);
                     *sense_ptr = 0x70;
                     *(sense_ptr+2) = SD_HARDERR;
                     *(sense_ptr+7) = TARGET_SENSE_SIZE-8;
                     *(sense_ptr+12) = SC_SELFAIL;
             }
             pkt->scsi_status = S_CKCON;
-            pkt->option_flags |= (uint32_t)OF_SSTS | (uint32_t)OF_NO_DATA;
+            pkt->option_flags |= OF_SSTS | OF_NO_DATA;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
             if (ha->flags.enable_64bit_addressing)
@@ -5631,13 +5259,13 @@
         case 0x16:                  /* Requested Capability Not Available */
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
             qla1280_print(
-                    "qla1280_atio_entry: Target Bus Phase Sequence Failure\n\r");
+                    "qla1280_atio_entry: Target Bus Phase Sequence Failure\n");
 #endif
             break;
         case 0x17:                  /* Bus Device Reset Message Received */
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
             qla1280_print(
-                    "qla1280_atio_entry: Target Bus Phase Sequence Failure\n\r");
+                    "qla1280_atio_entry: Target Bus Phase Sequence Failure\n");
 #endif
             break;
         case 0x3D:                  /* CDB Received */
@@ -5651,9 +5279,9 @@
             {
                 case SS_TEST:
 #ifdef QL_DEBUG_LEVEL_3
-                    qla1280_print("qla1280_atio_entry: SS_TEST\n\r");
+                    qla1280_print("qla1280_atio_entry: SS_TEST\n");
 #endif
-                    bzero(sense_ptr, TARGET_SENSE_SIZE);
+                    memset(sense_ptr, 0, TARGET_SENSE_SIZE);
                     len = 0;
                     if (pkt->lun == 0)
                         pkt->scsi_status = S_GOOD;
@@ -5671,7 +5299,7 @@
                     break;
                 case SS_REQSEN:
 #ifdef QL_DEBUG_LEVEL_3
-                    qla1280_print("qla1280_atio_entry: SS_REQSEN\n\r");
+                    qla1280_print("qla1280_atio_entry: SS_REQSEN\n");
 #endif
                     phy_addr[0] = ha->tsense_dma;
                     phy_addr[1] = 0;
@@ -5686,9 +5314,9 @@
                     break;
                 case SS_INQUIR:
 #ifdef QL_DEBUG_LEVEL_3
-                    qla1280_print("qla1280_atio_entry: SS_INQUIR\n\r");
+                    qla1280_print("qla1280_atio_entry: SS_INQUIR\n");
 #endif
-                    bzero(sense_ptr, TARGET_SENSE_SIZE);
+                    memset(sense_ptr, 0, TARGET_SENSE_SIZE);
                     phy_addr[0] = ha->tbuf_dma;
                     phy_addr[1] = 0;
                     *a64 += TARGET_INQ_OFFSET;
@@ -5713,7 +5341,7 @@
                             (uint32_t)OF_DATA_IN;
                     break;
                 case SM_WRDB:
-                    bzero(sense_ptr, TARGET_SENSE_SIZE);
+                    memset(sense_ptr, 0, TARGET_SENSE_SIZE);
                     offset = pkt->cdb[5];
                     offset |= pkt->cdb[4] << 8;
                     offset |= pkt->cdb[3] << 16;
@@ -5727,12 +5355,12 @@
                     {
                         case RW_BUF_HDATA:
 #ifdef QL_DEBUG_LEVEL_3
-                            qla1280_print("qla1280_atio_entry: SM_WRDB, RW_BUF_HDATA\n\r");
+                            qla1280_print("qla1280_atio_entry: SM_WRDB, RW_BUF_HDATA\n");
 #endif
                             if (len > TARGET_DATA_SIZE + 4)
                             {
 #ifdef QL_DEBUG_LEVEL_2
-                                qla1280_print("qla1280_atio_entry: SM_WRDB, length > buffer size\n\r");
+                                qla1280_print("qla1280_atio_entry: SM_WRDB, length > buffer size\n");
 #endif
                                 *sense_ptr = 0x70;
                                 *(sense_ptr+2) = SD_ILLREQ;
@@ -5749,7 +5377,7 @@
                                     pkt->option_flags |= (uint32_t)OF_SSTS |
                                             (uint32_t)OF_DATA_OUT;
 #ifdef QL_DEBUG_LEVEL_3
-                                    qla1280_print("qla1280_atio_entry: Issuing SDI_TARMOD_WRCOMP\n\r");
+                                    qla1280_print("qla1280_atio_entry: Issuing SDI_TARMOD_WRCOMP\n");
 #endif
                                     sdi_xaen(SDI_TARMOD_WRCOMP, ha->cntlr,
                                             pkt->target_id, pkt->lun, 0, offset);
@@ -5757,7 +5385,7 @@
                             else
                             {
 #ifdef QL_DEBUG_LEVEL_2
-                                    qla1280_print("qla1280_atio_entry: SM_WRDB, zero length\n\r");
+                                    qla1280_print("qla1280_atio_entry: SM_WRDB, zero length\n");
 #endif
                                     pkt->scsi_status = S_GOOD;
                                     pkt->option_flags |= (uint32_t)OF_SSTS |
@@ -5767,21 +5395,21 @@
                             break;
                         case RW_BUF_DATA:
 #ifdef QL_DEBUG_LEVEL_3
-                            qla1280_print("qla1280_atio_entry: SM_WRDB, RW_BUF_DATA\n\r");
+                            qla1280_print("qla1280_atio_entry: SM_WRDB, RW_BUF_DATA\n");
 #endif
                             *a64 += offset + TARGET_DATA_OFFSET;
                             if (pkt->cdb[2] != 0 || *a64 >= *end_a64 ||
                                 *a64 + len > *end_a64)
                             {
 #ifdef QL_DEBUG_LEVEL_2
-                                    qla1280_print("qla1280_atio_entry: SM_WRDB, RW_BUF_DATA BAD\n\r");
+                                    qla1280_print("qla1280_atio_entry: SM_WRDB, RW_BUF_DATA BAD\n");
                                     qla1280_print("buf_id=");
                                     qla1280_output_number((uint32_t)pkt->cdb[2], 16);
                                     qla1280_print(", offset=");
                                     qla1280_output_number((uint32_t)offset, 16);
                                     qla1280_print(", length=");
                                     qla1280_output_number((uint32_t)len, 16);
-                                    qla1280_print("\n\r");
+                                    qla1280_print("\n");
 #endif
                                     *sense_ptr = 0x70;
                                     *(sense_ptr+2) = SD_ILLREQ;
@@ -5798,7 +5426,7 @@
                                     pkt->option_flags |= (uint32_t)OF_SSTS |
                                             (uint32_t)OF_DATA_OUT;
 #ifdef QL_DEBUG_LEVEL_3
-                                    qla1280_print("qla1280_atio_entry: Issuing SDI_TARMOD_WRCOMP\n\r");
+                                    qla1280_print("qla1280_atio_entry: Issuing SDI_TARMOD_WRCOMP\n");
 #endif
                                     sdi_xaen(SDI_TARMOD_WRCOMP, ha->cntlr,
                                             pkt->target_id, pkt->lun, 0, offset);
@@ -5806,7 +5434,7 @@
                             else
                             {
 #ifdef QL_DEBUG_LEVEL_2
-                                    qla1280_print("qla1280_atio_entry: SM_WRDB, zero length\n\r");
+                                    qla1280_print("qla1280_atio_entry: SM_WRDB, zero length\n");
 #endif
                                     pkt->scsi_status = S_GOOD;
                                     pkt->option_flags |= (uint32_t)OF_SSTS |
@@ -5815,7 +5443,7 @@
                             break;
                         default:
 #ifdef QL_DEBUG_LEVEL_2
-                            qla1280_print("qla1280_atio_entry: SM_WRDB unknown mode\n\r");
+                            qla1280_print("qla1280_atio_entry: SM_WRDB unknown mode\n");
 #endif
                             *sense_ptr = 0x70;
                             *(sense_ptr+2) = SD_ILLREQ;
@@ -5829,7 +5457,7 @@
                     }
                     break;
                 case SM_RDDB:
-                    bzero(sense_ptr, TARGET_SENSE_SIZE);
+                    memset(sense_ptr, 0, TARGET_SENSE_SIZE);
                     offset = pkt->cdb[5];
                     offset |= pkt->cdb[4] << 8;
                     offset |= pkt->cdb[3] << 16;
@@ -5843,7 +5471,7 @@
                     {
                         case RW_BUF_HDATA:
 #ifdef QL_DEBUG_LEVEL_3
-                            qla1280_print("qla1280_atio_entry: SM_RDDB, RW_BUF_HDATA\n\r");
+                            qla1280_print("qla1280_atio_entry: SM_RDDB, RW_BUF_HDATA\n");
 #endif
                             if (len)
                             {
@@ -5862,7 +5490,7 @@
                             else
                             {
 #ifdef QL_DEBUG_LEVEL_2
-                                    qla1280_print("qla1280_atio_entry: SM_RDDB, zero length\n\r");
+                                    qla1280_print("qla1280_atio_entry: SM_RDDB, zero length\n");
 #endif
                                     pkt->scsi_status = S_GOOD;
                                     pkt->option_flags |= (uint32_t)OF_SSTS |
@@ -5871,18 +5499,18 @@
                             break;
                         case RW_BUF_DATA:
 #ifdef QL_DEBUG_LEVEL_3
-                            qla1280_print("qla1280_atio_entry: SM_RDDB, RW_BUF_DATA\n\r");
+                            qla1280_print("qla1280_atio_entry: SM_RDDB, RW_BUF_DATA\n");
 #endif
                             *a64 += offset + TARGET_DATA_OFFSET;
                             if (pkt->cdb[2] != 0 || *a64 >= *end_a64)
                             {
 #ifdef QL_DEBUG_LEVEL_2
-                                    qla1280_print("qla1280_atio_entry: SM_RDDB, RW_BUF_DATA BAD\n\r");
+                                    qla1280_print("qla1280_atio_entry: SM_RDDB, RW_BUF_DATA BAD\n");
                                     qla1280_print("buf_id=");
                                     qla1280_output_number((uint32_t)pkt->cdb[2], 16);
                                     qla1280_print(", offset=");
                                     qla1280_output_number((uint32_t)offset, 16);
-                                    qla1280_print("\n\r");
+                                    qla1280_print("\n");
 #endif
                                     *sense_ptr = 0x70;
                                     *(sense_ptr+2) = SD_ILLREQ;
@@ -5906,7 +5534,7 @@
                                     else
                                     {
 #ifdef QL_DEBUG_LEVEL_2
-                                            qla1280_print("qla1280_atio_entry: SM_RDDB, zero length\n\r");
+                                            qla1280_print("qla1280_atio_entry: SM_RDDB, zero length\n");
 #endif
                                             pkt->scsi_status = S_GOOD;
                                             pkt->option_flags |= (uint32_t)OF_SSTS |
@@ -5916,7 +5544,7 @@
                             break;
                         case RW_BUF_DESC:
 #ifdef QL_DEBUG_LEVEL_3
-                            qla1280_print("qla1280_atio_entry: SM_RDDB, RW_BUF_DESC\n\r");
+                            qla1280_print("qla1280_atio_entry: SM_RDDB, RW_BUF_DESC\n");
 #endif
                             if (len)
                             {
@@ -5946,7 +5574,7 @@
                             else
                             {
 #ifdef QL_DEBUG_LEVEL_2
-                                    qla1280_print("qla1280_atio_entry: SM_RDDB, zero length\n\r");
+                                    qla1280_print("qla1280_atio_entry: SM_RDDB, zero length\n");
 #endif
                                     pkt->scsi_status = S_GOOD;
                                     pkt->option_flags |= (uint32_t)OF_SSTS |
@@ -5955,7 +5583,7 @@
                             break;
                         default:
 #ifdef QL_DEBUG_LEVEL_2
-                            qla1280_print("qla1280_atio_entry: SM_RDDB unknown mode\n\r");
+                            qla1280_print("qla1280_atio_entry: SM_RDDB unknown mode\n");
 #endif
                             *sense_ptr = 0x70;
                             *(sense_ptr+2) = SD_ILLREQ;
@@ -5970,10 +5598,10 @@
                     break;
                 default:
 #ifdef QL_DEBUG_LEVEL_2
-                    qla1280_print("qla1280_atio_entry: Unknown SCSI command\n\r");
-                    qla1280_dump_buffer((caddr_t)&pkt->cdb[0], pkt->cdb_len);
+                    qla1280_print("qla1280_atio_entry: Unknown SCSI command\n");
+                    qla1280_dump_buffer(&pkt->cdb[0], pkt->cdb_len);
 #endif
-                    bzero(sense_ptr, TARGET_SENSE_SIZE);
+                    memset(sense_ptr, 0, TARGET_SENSE_SIZE);
                     *sense_ptr = 0x70;
                     *(sense_ptr+2) = SD_ILLREQ;
                     *(sense_ptr+7) = TARGET_SENSE_SIZE-8;
@@ -5996,7 +5624,7 @@
     }
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_atio_entry: exiting normally\n\r");
+    qla1280_print("qla1280_atio_entry: exiting normally\n");
 #endif
 }
 
@@ -6008,11 +5636,11 @@
  *      ha  = adapter block pointer.
  *      pkt = entry pointer.
  */
-STATIC void
+static void
 qla1280_notify_entry(scsi_qla_host_t *ha, notify_entry_t *pkt)
 {
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_notify_entry: entered\n\r");
+    qla1280_print("qla1280_notify_entry: entered\n");
 #endif
 
     /* Acknowledge immediate notify */
@@ -6022,11 +5650,11 @@
     qla1280_immed_notify(ha, pkt);
 
 #ifdef QL_DEBUG_LEVEL_3
-    qla1280_print("qla1280_notify_entry: exiting normally\n\r");
+    qla1280_print("qla1280_notify_entry: exiting normally\n");
 #endif
 }
-
 #endif  /* QLA1280_TARGET_MODE_SUPPORT */
+
 /*
  *  qla1280_status_entry
  *      Processes received ISP status entry.
@@ -6037,19 +5665,17 @@
  *      done_q_first = done queue first pointer.
  *      done_q_last  = done queue last pointer.
  */
-STATIC void
-qla1280_status_entry(scsi_qla_host_t *ha, sts_entry_t *pkt, srb_t **done_q_first,
-                     srb_t **done_q_last)
+static void
+qla1280_status_entry(scsi_qla_host_t *ha, sts_entry_t *pkt,
+		     srb_t **done_q_first, srb_t **done_q_last)
 {
-    uint32_t        b, t, l;
-    uint8_t         sense_sz = 0;
+    unsigned int    b, t, l;
+    int             sense_sz;
     srb_t           *sp;
     scsi_lu_t       *q;
     Scsi_Cmnd       *cp;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_status_entry");
-#endif
 
     /* Validate handle. */
     if (pkt->handle < MAX_OUTSTANDING_COMMANDS)
@@ -6070,45 +5696,54 @@
         l = SCSI_LUN_32(cp);
         q = LU_Q(ha, b, t, l);
 
-        if( pkt->comp_status || pkt->scsi_status )
+        if (pkt->comp_status || pkt->scsi_status)
         {
             DEBUG(qla1280_print( "scsi: comp_status = ");)
             DEBUG(qla1280_output_number((uint32_t)pkt->comp_status,16);)
             DEBUG(qla1280_print( ", ");)
             DEBUG(qla1280_print( " scsi_status = ");)
             DEBUG(qla1280_output_number((uint32_t)pkt->scsi_status,16);)
-            DEBUG(qla1280_print( "\n\r");)
+            DEBUG(qla1280_print( "\n");)
             DEBUG(qla1280_print(", handle = ");)
             DEBUG(qla1280_output_number((uint32_t)pkt->handle, 16);)
-            DEBUG(qla1280_print("\n\r");)
+            DEBUG(qla1280_print("\n");)
         }
 
         /* Target busy */
-        if ( pkt->scsi_status & SS_BUSY_CONDITION &&
-            pkt->scsi_status != SS_RESERVE_CONFLICT   )
+        if (pkt->scsi_status & SS_BUSY_CONDITION &&
+            pkt->scsi_status != SS_RESERVE_CONFLICT)
         {
-            CMD_RESULT(cp) = (int) (DID_BUS_BUSY << 16) |
+            CMD_RESULT(cp) = DID_BUS_BUSY << 16 |
                     (pkt->scsi_status & 0xff);
         }
         else
         {
 
             /* Save ISP completion status */
-            CMD_RESULT(cp) = qla1280_return_status( pkt, cp );
+            CMD_RESULT(cp) = qla1280_return_status(pkt, cp);
 
             if (pkt->scsi_status & SS_CHECK_CONDITION)
             {
-                BZERO(cp->sense_buffer, CMD_SNSLEN(cp));
+#if 0
+                memset(cp->sense_buffer, 0, CMD_SNSLEN(cp));
+#endif
                 if (pkt->comp_status != CS_ARS_FAILED)
                 {
-                    if ( pkt->req_sense_length < CMD_SNSLEN(cp)  )
+                    if (pkt->req_sense_length < CMD_SNSLEN(cp))
                         sense_sz = pkt->req_sense_length;
                     else
+                        /*
+                         * Scsi_Cmnd->sense_buffer is 64 bytes, why
+                         * only copy 63? This looks wrong! /Jes
+                         */
                         sense_sz = CMD_SNSLEN(cp) - 1;
 
-                    BCOPY((caddr_t)&pkt->req_sense_data, cp->sense_buffer, sense_sz);
+                    memcpy(cp->sense_buffer, &pkt->req_sense_data, sense_sz);
+                } else
+                    sense_sz = 0;
+                memset(cp->sense_buffer + sense_sz, 0,
+                       sizeof(cp->sense_buffer) - sense_sz);
 
-                }
 #ifdef QL_DEBUG_LEVEL_2
                 DEBUG(qla1280_print(
                         "qla1280_status_entry: Check condition Sense data, b");)
@@ -6117,9 +5752,9 @@
                 DEBUG(qla1280_output_number((uint32_t)t, 10);)
                 DEBUG(qla1280_print("d");)
                 DEBUG(qla1280_output_number((uint32_t)l, 10);)
-                DEBUG(qla1280_print("\n\r");)
+                DEBUG(qla1280_print("\n");)
                 DEBUG(if (sense_sz))
-                    DEBUG(qla1280_dump_buffer(cp->sense_buffer, sense_sz);)
+                    DEBUG(qla1280_dump_buffer((char *)cp->sense_buffer, sense_sz);)
 #endif
             }
         }
@@ -6129,14 +5764,13 @@
     else
     {
 #ifdef QL_DEBUG_LEVEL_2
-        qla1280_print("qla1280_status_entry: ISP Invalid handle\n\r");
+        qla1280_print("qla1280_status_entry: ISP Invalid handle\n");
 #endif
         printk(KERN_WARNING "qla1280: Status Entry invalid handle\n");
         ha->flags.isp_abort_needed = TRUE;
     }
-#ifdef QL_DEBUG_LEVEL_3
+
     LEAVE("qla1280_status_entry");
-#endif
 }
 
 /*
@@ -6149,25 +5783,23 @@
  *      done_q_first = done queue first pointer.
  *      done_q_last  = done queue last pointer.
  */
-STATIC void
+static void
 qla1280_error_entry(scsi_qla_host_t *ha, response_t *pkt, srb_t **done_q_first,
                     srb_t **done_q_last)
 {
     srb_t   *sp;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_error_entry");
-#endif
 
 #ifdef QL_DEBUG_LEVEL_2
     if (pkt->entry_status & BIT_3)
-        qla1280_print("qla1280_error_entry: BAD PAYLOAD flag error\n\r");
+        qla1280_print("qla1280_error_entry: BAD PAYLOAD flag error\n");
     else if (pkt->entry_status & BIT_2)
-        qla1280_print("qla1280_error_entry: BAD HEADER flag error\n\r");
+        qla1280_print("qla1280_error_entry: BAD HEADER flag error\n");
     else if (pkt->entry_status & BIT_1)
-        qla1280_print("qla1280_error_entry: FULL flag error\n\r");
+        qla1280_print("qla1280_error_entry: FULL flag error\n");
     else
-        qla1280_print("qla1280_error_entry: UNKNOWN flag error\n\r");
+        qla1280_print("qla1280_error_entry: UNKNOWN flag error\n");
 #endif
 
     /* Validate handle. */
@@ -6186,34 +5818,32 @@
         {
             /* Bad payload or header, set error status. */
             /* CMD_RESULT(sp->cmd) = CS_BAD_PAYLOAD; */
-            CMD_RESULT(sp->cmd) = (int) DID_ERROR << 16;
+            CMD_RESULT(sp->cmd) = DID_ERROR << 16;
         }
         else if (pkt->entry_status & BIT_1 ) /* FULL flag */
         {
-            CMD_RESULT(sp->cmd) = (int) DID_BUS_BUSY << 16;
+            CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
         }
         else
         {
             /* Set error status. */
-            CMD_RESULT(sp->cmd) =(int)  DID_ERROR << 16;
+            CMD_RESULT(sp->cmd) = DID_ERROR << 16;
         }
         /* Place command on done queue. */
         qla1280_done_q_put(sp, done_q_first, done_q_last);
     }
-#if  BITS_PER_LONG > 32
+#ifdef QLA_64BIT_PTR
     else if (pkt->entry_type == COMMAND_A64_TYPE)
     {
 #ifdef QL_DEBUG_LEVEL_2
-        qla1280_print("qla1280_error_entry: ISP Invalid handle\n\r");
+        qla1280_print("qla1280_error_entry: ISP Invalid handle\n");
 #endif
         printk(KERN_WARNING "!qla1280: Error Entry invalid handle");
         ha->flags.isp_abort_needed = TRUE;
     }
 #endif
 
-#ifdef QL_DEBUG_LEVEL_3
     LEAVE("qla1280_error_entry");
-#endif
 }
 
 /*
@@ -6226,25 +5856,19 @@
  * Returns:
  *      0 = success
  */
-STATIC uint8_t
+static int
 qla1280_abort_isp(scsi_qla_host_t *ha)
 {
     device_reg_t    *reg = ha->iobase;
-    uint8_t         status = 0;
-    uint16_t        cnt;
     srb_t           *sp;
     scsi_lu_t       *q;
-    uint32_t        b, t, l;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-    unsigned long cpu_flags = 0;
-#endif
+    int		    status = 0;
+    int		    cnt;
+    unsigned int    b, t, l;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_abort_isp");
-#endif
 
-    DRIVER_LOCK
-            ha->flags.isp_abort_needed = FALSE;
+    ha->flags.isp_abort_needed = FALSE;
     if (!ha->flags.abort_isp_active && ha->flags.online)
     {
         ha->flags.abort_isp_active = TRUE;
@@ -6330,7 +5954,7 @@
                 if (!status)
                 { 
                     /* Enable ISP interrupts. */
-                    WRT_REG_WORD(&reg->ictrl, ISP_EN_INT + ISP_EN_RISC);
+                    WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT | ISP_EN_RISC));
                     ha->flags.abort_isp_active = FALSE;
                     /* Restart queues that may have been stopped. */
                     qla1280_restart_queues(ha);
@@ -6347,16 +5971,12 @@
         qla1280_abort_queues(ha);
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
-        qla1280_print("qla1280_abort_isp: **** FAILED ****\n\r");
+        qla1280_print("qla1280_abort_isp: **** FAILED ****\n");
 #endif
     }
-#ifdef QL_DEBUG_LEVEL_3
-    else
-        LEAVE("qla1280_abort_isp");
-#endif
-    DRIVER_UNLOCK
 
-            return(status);
+    LEAVE("qla1280_abort_isp");
+    return status;
 }
 
 /*
@@ -6366,15 +5986,13 @@
  * Input:
  *      ha = adapter block pointer.
  */
-STATIC void
+static void
 qla1280_restart_queues(scsi_qla_host_t *ha)
 {
     scsi_lu_t *q;
     uint32_t  b, t, l;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_restart_queues");
-#endif
 
     for (b = 0; b < ha->ports; b++)
         for (t = 0; t < MAX_TARGETS; t++)
@@ -6383,18 +6001,12 @@
                 q = (scsi_lu_t *) LU_Q(ha, b, t, l);
                 if (q != NULL)
                 {
-                    /* Acquire LU queue specific lock */
-                    QLA1280_SCSILU_LOCK(q);
-
                     if (q->q_first)
                         qla1280_next(ha, q, b);
-                    else
-                        /* Release LU queue specific lock */
-                        QLA1280_SCSILU_UNLOCK(q);
                 }
             }
 #ifdef QL_DEBUG_LEVEL_3
-            qla1280_print("qla1280_restart_queues: exiting normally\n\r");
+            qla1280_print("qla1280_restart_queues: exiting normally\n");
 #endif
 }
 
@@ -6405,7 +6017,7 @@
  * Input:
  *      ha = adapter block pointer.
  */
-STATIC void qla1280_abort_queue_single(scsi_qla_host_t *ha,uint32_t b,uint32_t t,uint32_t l,uint32_t stat)
+static void qla1280_abort_queue_single(scsi_qla_host_t *ha,uint32_t b,uint32_t t,uint32_t l,uint32_t stat)
 {
     scsi_lu_t *q;
     srb_t     *sp, *sp_next; 
@@ -6414,14 +6026,9 @@
     q = (scsi_lu_t * )LU_Q(ha, b, t, l);
     if (q != NULL)
     {
-        /* Acquire LU queue specific lock */
-        QLA1280_SCSILU_LOCK(q);
-
         sp = q->q_first;
         q->q_first = q->q_last = NULL;
 
-        QLA1280_SCSILU_UNLOCK(q);
-
         while (sp)
         {
             sp_next = sp->s_next;
@@ -6440,7 +6047,7 @@
  * Input:
  *      ha = adapter block pointer.
  */
-STATIC void
+static void
 qla1280_abort_queues(scsi_qla_host_t *ha)
 {
     uint32_t  b, t, l;
@@ -6450,9 +6057,9 @@
     for (b = 0; b < ha->ports; b++)
         for (t = 0; t < MAX_TARGETS; t++)
             for (l = 0; l < MAX_LUNS; l++)
-                qla1280_abort_queue_single(ha,b,t,l,DID_RESET);
+                qla1280_abort_queue_single(ha, b, t, l, DID_RESET);
 
-            LEAVE("qla1280_abort_queues");
+    LEAVE("qla1280_abort_queues");
 }
 
 /*
@@ -6465,19 +6072,18 @@
  * Returns:
  *      register value.
  */
-STATIC uint16_t
-qla1280_debounce_register(volatile uint16_t *addr)
+static u16
+qla1280_debounce_register(volatile u16 *addr)
 {
-    volatile uint16_t ret;
-    volatile uint16_t ret2;
+    volatile u16 ret;
+    volatile u16 ret2;
 
-    do
-    {
+    do {
         ret = RD_REG_WORD(addr);
         ret2 = RD_REG_WORD(addr);
-    }while (ret != ret2);
+    } while (ret != ret2);
 
-    return(ret);
+    return ret;
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
@@ -6497,20 +6103,20 @@
  ************************************************************************/
 #define SET_SXP_BANK            0x0100
 #define SCSI_PHASE_INVALID      0x87FF
-int  qla1280_check_for_dead_scsi_bus(scsi_qla_host_t *ha, srb_t *sp)
+static int qla1280_check_for_dead_scsi_bus(scsi_qla_host_t *ha, srb_t *sp)
 {
     uint16_t  config_reg, scsi_control;
     device_reg_t    *reg = ha->iobase;
-    uint32_t  b;
-    Scsi_Cmnd       *cp;
+    unsigned int b;
+    Scsi_Cmnd *cp;
 
     /*
      * If SCSI Bus is Dead because of bad termination,
      * we will return a status of Selection timeout.
      */
  
-     cp = sp->cmd;
-     b = SCSI_BUS_32(cp);
+    cp = sp->cmd;
+    b = SCSI_BUS_32(cp);
     if (ha->bus_settings[b].scsi_bus_dead)
     {
         WRT_REG_WORD(&reg->host_cmd, HC_PAUSE_RISC);
@@ -6523,16 +6129,12 @@
         if (scsi_control == SCSI_PHASE_INVALID)
         {
             CMD_RESULT(cp) = DID_NO_CONNECT << 16;
-            CMD_HANDLE(cp) = (unsigned char *) 0;
+            CMD_HANDLE(cp) = NULL;
             /* ha->actthreads--; */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-            sti(); 
-            (*(cp)->scsi_done)(cp);
-            cli(); 
-#else
+
             (*(cp)->scsi_done)(cp);
-#endif
-            return(TRUE);   /* bus is dead */
+
+            return TRUE;   /* bus is dead */
         }
         else
         {
@@ -6540,11 +6142,12 @@
             ha->bus_settings[b].failed_reset_count= 0; 
         }
     }
-    return(FALSE);   /* bus is not dead */
+    return FALSE;   /* bus is not dead */
 }
 
-STATIC uint8_t
-qla12160_set_target_parameters(scsi_qla_host_t *ha, uint32_t b, uint32_t t, uint32_t l, nvram160_t *nv)
+static int
+qla12160_set_target_parameters(scsi_qla_host_t *ha, uint32_t b,
+                               uint32_t t, uint32_t l, nvram160_t *nv)
 {
     uint16_t        mb[MAILBOX_REGISTER_COUNT];
 
@@ -6561,10 +6164,10 @@
 
     mb[6] = nv->bus[b].target[t].flags.ppr_options << 8;
     mb[6] |= nv->bus[b].target[t].flags.ppr_bus_width;
-    return( qla1280_mailbox_command(ha, BIT_6|BIT_3|BIT_2|BIT_1|BIT_0, &mb[0]) ) ;
+    return qla1280_mailbox_command(ha, BIT_6|BIT_3|BIT_2|BIT_1|BIT_0, &mb[0]);
 }
 
-STATIC void
+static void
 qla12160_get_target_parameters(scsi_qla_host_t *ha, uint32_t b, uint32_t t, uint32_t l)
 {
     uint16_t        mb[MAILBOX_REGISTER_COUNT];
@@ -6583,6 +6186,32 @@
 }
 
 
+#if DEBUG_QLA1280
+/*
+ *  Out NULL terminated string to COM port.
+ */
+static void
+qla1280_print(char *s)
+{
+    if (ql_debug_print)
+	printk("%s", s);
+}
+
+/*
+ *  Output long number to COM port.
+ */
+static void
+qla1280_output_number(u32 n, int base)
+{
+    char buf[12];
+    if (base == 10)
+	sprintf(buf, " %i", n);
+    else
+	sprintf(buf, " 0x%x", n);
+    qla1280_print(buf);
+}
+#endif
+
 #ifdef QL_DEBUG_ROUTINES
 /****************************************************************************/
 /*                         Driver Debug Functions.                          */
@@ -6591,15 +6220,15 @@
 /*
  *  Get byte from I/O port
  */
-STATIC uint8_t
-qla1280_getbyte(uint8_t *port)
+static u8
+qla1280_getbyte(u8 *port)
 {
-    uint8_t ret;
+    u8 ret;
 
 #if MEMORY_MAPPED_IO
-    ret = *port;
+    ret = readb(unsigned long)port);
 #else
-    ret = inb((long)port);
+    ret = inb((unsigned long)port);
 #endif
 
     if (ql_debug_print)
@@ -6607,49 +6236,49 @@
         qla1280_print("qla1280_getbyte: address = ");
         qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
-        qla1280_output_number((uint32_t)ret, 16);
-        qla1280_print("\n\r");
+        qla1280_output_number((u32)ret, 16);
+        qla1280_print("\n");
     }
 
-    return(ret);
+    return ret;
 }
 
 /*
  *  Get word from I/O port
  */
-STATIC uint16_t
-qla1280_getword(uint16_t *port)
+static u16
+qla1280_getword(u16 *port)
 {
-    uint16_t ret;
+    u16 ret;
 
 #if MEMORY_MAPPED_IO
-    ret = *port;
+    ret = readw(unsigned long)port;
 #else
     ret = inw((unsigned long)port);
 #endif
 
     if (ql_debug_print)
     {
-        qla1280_print("qla1280_getword: address = ");
+qla1280_print("qla1280_getword: address = ");
         qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
-        qla1280_output_number((uint32_t)ret, 16);
-        qla1280_print("\n\r");
+        qla1280_output_number((u32)ret, 16);
+        qla1280_print("\n");
     }
 
-    return(ret);
+    return ret;
 }
 
 /*
  *  Get double word from I/O port
  */
-STATIC uint32_t
-qla1280_getdword(uint32_t *port)
+static u32
+qla1280_getdword(u32 *port)
 {
-    uint32_t ret;
+    u32 ret;
 
 #if MEMORY_MAPPED_IO
-    ret = *port;
+    ret = readl((unsigned long)port);
 #else
     ret = inl((unsigned long)port);
 #endif
@@ -6659,21 +6288,21 @@
         qla1280_print("qla1280_getdword: address = ");
         qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
-        qla1280_output_number((uint32_t)ret, 16);
-        qla1280_print("\n\r");
+        qla1280_output_number(ret, 16);
+        qla1280_print("\n");
     }
 
-    return(ret);
+    return ret;
 }
 
 /*
  *  Send byte to I/O port
  */
-STATIC void
-qla1280_putbyte(uint8_t *port, uint8_t data)
+static void
+qla1280_putbyte(u8 *port, u8 data)
 {
 #if MEMORY_MAPPED_IO
-    *port = data;
+    writeb(data, (unsigned long)port);
 #else
     outb(data, (unsigned long)port);
 #endif
@@ -6683,25 +6312,21 @@
         qla1280_print("qla1280_putbyte: address = ");
         qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
-        qla1280_output_number((uint32_t)data, 16);
-        qla1280_print("\n\r");
+        qla1280_output_number((u32)data, 16);
+        qla1280_print("\n");
     }
 }
 
 /*
  *  Send word to I/O port
  */
-STATIC void
-qla1280_putword(uint16_t *port, uint16_t data)
+static void
+qla1280_putword(u16 *port, u16 data)
 {
 #if MEMORY_MAPPED_IO
-    *port = data;
-#else
-#ifdef _LINUX_IOPORTS
-    outw(data, (int)port);
+    writew(data, (unsigned long)port);
 #else
-    outw((unsigned long)port, data);
-#endif
+    outw(data, (unsigned long)port);
 #endif
 
     if (ql_debug_print)
@@ -6710,24 +6335,20 @@
         qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
         qla1280_output_number((uint32_t)data, 16);
-        qla1280_print("\n\r");
+        qla1280_print("\n");
     }
 }
 
 /*
  *  Send double word to I/O port
  */
-STATIC void
-qla1280_putdword(uint32_t *port, uint32_t data)
+static void
+qla1280_putdword(u32 *port, u32 data)
 {
 #if MEMORY_MAPPED_IO
-    *port = data;
-#else
-#ifdef _LINUX_IOPORTS
-    outl(data,(int)port);
+    writel(data, (unsigned long)port);
 #else
-    outl((unsigned long)port, data);
-#endif
+    outl(data, (unsigned long)port);
 #endif
 
     if (ql_debug_print)
@@ -6735,8 +6356,8 @@
         qla1280_print("qla1280_putdword: address = ");
         qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
-        qla1280_output_number((uint32_t)data, 16);
-        qla1280_print("\n\r");
+        qla1280_output_number(data, 16);
+        qla1280_print("\n");
     }
 }
 
@@ -6744,7 +6365,7 @@
  * Dummy function to prevent warnings for
  * declared and unused debug functions
  */
-void
+static void
 qla1280_debug(void)
 {
     qla1280_getbyte(0);
@@ -6755,203 +6376,57 @@
     qla1280_putdword(0, 0);
 }
 
-/*
- *  Out character to COM2 port.
- *      PORT must be at standard address for COM1 = 0x3f8
- */
-#define OUTB(addr,data)   outb((data),(addr))
-
-STATIC void
-qla1280_putc(uint8_t c)
-{
-#ifdef QL_DEBUG_CONSOLE
-    printk("%c", c);
-#else
-    int     com_addr              = 0x3f8;
-    int     hardware_flow_control = 1;
-    int     software_flow_control = 0;
-    uint8_t data;
-
-    /* Wait for transmitter holding and shift registers for empty. */
-    do
-    {
-        data = inb(com_addr+5);
-    }while (!(data & BIT_6));
-
-    /*
-    * Set BAUD rate for COM2 to 9600 (0x6)
-    */
-
-    /* Select rate divisor. */
-    OUTB(com_addr+3, 0x83); 
-
-    /* BAUD rate divisor LSB. */
-    OUTB(com_addr, 0xc);                    /* 0xC = 9600 baud */
-
-    /* BAUD rate divisor MSB. */
-    OUTB(com_addr+1, 0);
-
-    /* Set No parity, 8 bits, 1 stop bit and
-    select interrupt enable register. */
-    OUTB(com_addr+3, 3);
-
-    /* Disable interrupts. */
-    OUTB(com_addr+1, 0);
-
-    /* Set data terminal ready and request to send */
-    OUTB(com_addr+4,3);
-
-    if (hardware_flow_control)
-    {
-        /* Wait for clear-to-send and data-set-ready */
-        do
-        {
-            data = inb(com_addr+6) & (BIT_5 + BIT_4);
-        }while (data != (BIT_5 + BIT_4));
-    }
-    else if (software_flow_control)
-    {
-        /* Test for data ready. */
-        data = inb(com_addr+5);
-        if (data & BIT_0)
-        {
-            /* If XOFF */
-            data = inb(com_addr);
-            if (data == '\023')
-            {
-                /* Wait for XON */
-                do
-                {
-                    /* Wait for char */
-                    do
-                    {
-                        data = inb(com_addr+5);
-                    }while (!(data & BIT_0));
-                    data = inb(com_addr);
-                }while (data != '\021');
-            }
-        }
-    }
-
-    /* Output character. */
-    OUTB(com_addr, c);
-#endif
-}
-
-/*
- *  Out NULL terminated string to COM port.
- */
-STATIC void
-qla1280_print(caddr_t s)
-{
-    if (ql_debug_print)
-    {
-#ifdef QL_DEBUG_CONSOLE
-        printk("%s",s);
-#else
-        /* Output string. */
-        while (*s)
-            qla1280_putc(*s++);
-#endif
-    }
-}
-
-/*
- *  Output long number to COM port.
- */
-STATIC void
-qla1280_output_number(uint32_t n, uint8_t base)
-{
-    int8_t str[12];
-    int8_t *s     = &str[11];
-    int8_t output = 0;
-    int8_t hex    = FALSE;
-
-    if (ql_debug_print)
-    {
-        if (base == 10 || base == 16)
-        {
-            if (base == 16 && n > 9)
-                hex = TRUE;
-
-            *s = 0;
-            do
-            {
-                s--;
-                *s = n % base;
-                if (*s > 9)
-                    *s += 55;
-                else
-                    *s += '0';
-                n /= base;
-            }while (n);
-
-            for (; *s; s++)
-            {
-                if (*s != '0')
-                    output = 1;
-                if (output)
-                    qla1280_putc(*s);
-            }
-            if (!output)
-                qla1280_putc(*--s);
-
-            if (hex)
-                qla1280_putc('h');
-        }
-    }
-}
-
-STATIC void
-qla1280_dump_buffer(caddr_t b, uint32_t size)
+static void
+qla1280_dump_buffer(char *b, int size)
 {
-    uint32_t cnt;
-    uint8_t c;
+    int cnt;
+    u8 c;
 
     if (ql_debug_print)
     {
         qla1280_print(
-                " 0   1   2   3   4   5   6   7   8   9   Ah  Bh  Ch  Dh  Eh  Fh\n\r");
+                " 0   1   2   3   4   5   6   7   8   9   Ah  Bh  Ch  Dh  Eh  Fh\n");
         qla1280_print(
-                "---------------------------------------------------------------\n\r");
+                "---------------------------------------------------------------\n");
 
         for (cnt = 0; cnt < size; )
         {
             c = *b++;
             if (c < 16)
-                qla1280_putc(' ');
+                qla1280_print(' ');
             qla1280_output_number((uint32_t)c, 16);
             cnt++;
             if (!(cnt % 16))
-                qla1280_print("\n\r");
+                qla1280_print("\n");
             else if (c < 10)
                 qla1280_print("  ");
             else
-                qla1280_putc(' ');
+                qla1280_print(' ');
         }
         if (cnt % 16)
-            qla1280_print("\n\r");
+            qla1280_print("\n");
     }
 }
+
 /**************************************************************************
  *   ql1280_print_scsi_cmd
  *
  **************************************************************************/
-void qla1280_print_scsi_cmd(Scsi_Cmnd *cmd)
+static void qla1280_print_scsi_cmd(Scsi_Cmnd *cmd)
 {
     scsi_qla_host_t *ha;
     struct Scsi_Host  *host = cmd->host;
     srb_t           *sp;
-   /* struct scatterlist *sg; */
+    /* struct scatterlist *sg; */
 
     int i;
     ha = (scsi_qla_host_t *) host->hostdata;
 
     ql_debug_print = 1;
     sp = (srb_t *) CMD_SP(cmd);
-    sprintf(debug_buff,"SCSI Command @= 0x%p, Handle=0x%p\n\r", cmd, CMD_HANDLE(cmd));
+    sprintf(debug_buff,"SCSI Command @= 0x%p, Handle=0x%p\n", cmd, CMD_HANDLE(cmd));
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"  chan=%d, target = 0x%02x, lun = 0x%02x, cmd_len = 0x%02x\n\r",
+    sprintf(debug_buff,"  chan=%d, target = 0x%02x, lun = 0x%02x, cmd_len = 0x%02x\n",
             cmd->channel, cmd->target, cmd->lun, cmd->cmd_len);
     qla1280_print(debug_buff);
     qla1280_print(" CDB = ");
@@ -6960,22 +6435,22 @@
         sprintf(debug_buff,"0x%02x ", cmd->cmnd[i]);
         qla1280_print(debug_buff);
     }
-    sprintf(debug_buff,"  seg_cnt =%d\n\r",cmd->use_sg);
+    sprintf(debug_buff,"  seg_cnt =%d\n",cmd->use_sg);
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"  request buffer=0x%p, request buffer len=0x%x\n\r",cmd->request_buffer,cmd->request_bufflen);
+    sprintf(debug_buff,"  request buffer=0x%p, request buffer len=0x%x\n",cmd->request_buffer,cmd->request_bufflen);
     qla1280_print(debug_buff);
     /* if( cmd->use_sg )
     {
        sg = (struct scatterlist *) cmd->request_buffer;
-       qla1280_print("  SG buffer: \n\r");
-       qla1280_dump_buffer((caddr_t)sg, (cmd->use_sg*sizeof(struct scatterlist)) );
+       qla1280_print("  SG buffer: \n");
+       qla1280_dump_buffer((char *)sg, (cmd->use_sg*sizeof(struct scatterlist)) );
     } */
-    sprintf(debug_buff,"  tag=%d, flags=0x%x, transfersize=0x%x \n\r", 
+    sprintf(debug_buff,"  tag=%d, flags=0x%x, transfersize=0x%x \n", 
             cmd->tag, cmd->flags,cmd->transfersize );
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"  Pid=%d, SP=0x%p\n\r", (int)cmd->pid, CMD_SP(cmd));
+    sprintf(debug_buff,"  Pid=%d, SP=0x%p\n", (int)cmd->pid, CMD_SP(cmd));
     qla1280_print(debug_buff);
-    sprintf(debug_buff," underflow size = 0x%x, direction=0x%x, req.cmd=0x%x \n\r", cmd->underflow, sp->dir,cmd->request.cmd);    
+    sprintf(debug_buff," underflow size = 0x%x, direction=0x%x, req.cmd=0x%x \n", cmd->underflow, sp->dir,cmd->request.cmd);    
     qla1280_print(debug_buff);
 }
 /**************************************************************************
@@ -6989,16 +6464,15 @@
     Scsi_Cmnd       *cp;
     srb_t           *sp;
     int i;
-    qla1280_print("Outstanding Commands on controller:\n\r");   
-    for ( i=0; i < MAX_OUTSTANDING_COMMANDS; i++ )
+    qla1280_print("Outstanding Commands on controller:\n");   
+    for (i = 0; i < MAX_OUTSTANDING_COMMANDS; i++)
     {
-        if( (sp = ha->outstanding_cmds[i]) == NULL )
+        if((sp = ha->outstanding_cmds[i]) == NULL)
             continue;
-        if( (cp = sp->cmd) == NULL )
+        if((cp = sp->cmd) == NULL)
             continue;
         qla1280_print_scsi_cmd(cp);
     }
-
 }
 #endif
 
@@ -7021,8 +6495,7 @@
     printk("Number of SCSI queued commands =0x%lx\n", ha->qthreads);
     printk("Number of free entries = (%d)\n",ha->req_q_cnt);
     printk("Request Queue @ 0x%lx, Response Queue @ 0x%lx\n",
-                        ha->request_dma,
-                        ha->response_dma);
+                        ha->request_dma, ha->response_dma);
     printk("Request In Ptr %d\n", ha->req_ring_index );
     fp = (long *) &ha->flags;
     printk("HA flags =0x%lx\n", *fp);
@@ -7041,6 +6514,7 @@
 #endif
 
 
+#ifdef MODULE
 /**************************************************************************
  *   qla1280_setup
  *
@@ -7048,7 +6522,7 @@
  *   to a parameter with a ':' between the parameter and the value.
  *   ie. qla1280=max_reqs:0x0A,verbose
  **************************************************************************/
-void
+static void
 qla1280_setup(char *s, int *dummy)
 {
     char *end, *str, *cp;
@@ -7059,30 +6533,29 @@
     str = s;
     for( cp = s; *cp && cp != end; cp++ ) 
     {
-       cp = qla1280_get_token(cp, str);
-       printk("scsi: token str = %s\n", str);
-       /* if found execute routine */
-
+	cp = qla1280_get_token(cp, str);
+	printk("scsi: token str = %s\n", str);
+	/* if found execute routine */
     }
-    
 }
 
 static char	*qla1280_get_token(char *cmdline, char *str )
 {
     register	char 	*cp = cmdline;
 
-        /* skip preceeding spaces */
-        while(strchr(cp,' '))
-            ++cp;
-        /* symbol starts here */
-        str = cp;
-        /* skip char if not a space or : */
-        while (*cp && !( strchr(cp,' ') || strchr(cp,':'))  )
-            cp++;
-        *cp = '\0';
-        return( cp );
+    /* skip preceeding spaces */
+    while(strchr(cp,' '))
+	++cp;
+    /* symbol starts here */
+    str = cp;
+    /* skip char if not a space or : */
+    while (*cp && !( strchr(cp,' ') || strchr(cp,':'))  )
+	cp++;
+    *cp = '\0';
+    return cp;
 }
 MODULE_LICENSE("GPL");
+#endif
 
 /*
  * Overrides for Emacs so that we almost follow Linus's tabbing style.
@@ -7091,14 +6564,7 @@
  * of the file.
  * ---------------------------------------------------------------------------
  * Local variables:
- * c-indent-level: 2
- * c-brace-imaginary-offset: 0
- * c-brace-offset: -2
- * c-argdecl-indent: 2
- * c-label-offset: -2
- * c-continued-statement-offset: 2
- * c-continued-brace-offset: 0
- * indent-tabs-mode: nil
+ * c-basic-offset: 4
  * tab-width: 8
  * End:
  */
diff -urN --exclude-from=/home/mitica/quintela/config/misc/dontdiff linux-orig/drivers/scsi/qla1280.h linux/drivers/scsi/qla1280.h
--- linux-orig/drivers/scsi/qla1280.h	Fri Nov 23 13:05:47 2001
+++ linux/drivers/scsi/qla1280.h	Fri Nov 23 13:06:38 2001
@@ -21,14 +21,6 @@
 #define _IO_HBA_QLA1280_H           /* subject to change without notice */
 
 
-#ifndef LINUX_VERSION_CODE 
-#include <linux/version.h>
-#endif  /* LINUX_VERSION_CODE not defined */
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
 #ifndef HOSTS_C                     /* included in hosts.c */
 /*
  * Enable define statement to ignore Data Underrun Errors,
@@ -60,58 +52,6 @@
 #endif
 
 
-#ifndef KERNEL_VERSION
-#  define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
-#endif
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,1,92)
-#  if defined(__sparc_v9__) || defined(__powerpc__)
-#    error "PPC and Sparc platforms are only support under 2.1.92 and above"
-#  endif
-#endif
-
-
-/* 
- * Locking
- */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,0)
-#  if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
-#    include <asm/spinlock.h>
-#  else
-#    include <linux/spinlock.h>
-#  endif
-#  include <linux/smp.h>
-#  define cpuid smp_processor_id()
-#  if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-#    define DRIVER_LOCK_INIT \
-       spin_lock_init(&ha->spin_lock);
-#    define DRIVER_LOCK \
-       if(!ha->cpu_lock_count[cpuid]) { \
-         spin_lock_irqsave(&ha->spin_lock, cpu_flags); \
-         ha->cpu_lock_count[cpuid]++; \
-       } else { \
-         ha->cpu_lock_count[cpuid]++; \
-       }
-#    define DRIVER_UNLOCK \
-       if(--ha->cpu_lock_count[cpuid] == 0) \
-         spin_unlock_irqrestore(&ha->spin_lock, cpu_flags);
-#  else
-#    define DRIVER_LOCK_INIT
-#    define DRIVER_LOCK
-#    define DRIVER_UNLOCK
-#  endif 
-#else
-#  define cpuid 0
-#  define DRIVER_LOCK_INIT
-#  define DRIVER_LOCK \
-       save_flags(cpu_flags); \
-       cli();
-#  define DRIVER_UNLOCK \
-       restore_flags(cpu_flags);
-#  define le32_to_cpu(x) (x)
-#  define cpu_to_le32(x) (x)
-#endif
-
 /*
  * Data bit definitions.
  */
@@ -148,17 +88,6 @@
 #define BIT_30  0x40000000
 #define BIT_31  0x80000000
 
-/*
- * Common size type definitions
- */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
-typedef unsigned char  uint8_t; 
-typedef unsigned short uint16_t; 
-typedef unsigned long  uint32_t; 
-typedef char  int8_t; 
-typedef short int16_t; 
-typedef long  int32_t; 
-#endif
 
 /*
  *  Local Macro Definitions.
@@ -173,40 +102,33 @@
 /*
  * I/O port macros
 */
-#define LINUX_IOPORTS                     /* Linux in/out routines are define*/
-                                          /* differently from other OSs      */
 /* #define MEMORY_MAPPED_IO */            /* Enable memory mapped I/O */
 #undef MEMORY_MAPPED_IO            /* Disable memory mapped I/O */
 
 #ifdef QL_DEBUG_LEVEL_1
-#define RD_REG_BYTE(addr)         qla1280_getbyte((uint8_t *)addr)
-#define RD_REG_WORD(addr)         qla1280_getword((uint16_t *)addr)
-#define RD_REG_DWORD(addr)        qla1280_getdword((uint32_t *)addr)
-#define WRT_REG_BYTE(addr, data)  qla1280_putbyte((uint8_t *)addr, data)
-#define WRT_REG_WORD(addr, data)  qla1280_putword((uint16_t *)addr, data)
-#define WRT_REG_DWORD(addr, data) qla1280_putdword((uint32_t *)addr, data)
+#define RD_REG_BYTE(addr)		qla1280_getbyte((u8 *)addr)
+#define RD_REG_WORD(addr)		qla1280_getword((u16 *)addr)
+#define RD_REG_DWORD(addr)		qla1280_getdword((u32 *)addr)
+#define WRT_REG_BYTE(addr, data)	qla1280_putbyte((u8 *)addr, data)
+#define WRT_REG_WORD(addr, data)	qla1280_putword((u16 *)addr, data)
+#define WRT_REG_DWORD(addr, data)	qla1280_putdword((u32 *)addr, data)
 #else  /* QL_DEBUG_LEVEL_1 */
+
 #ifdef MEMORY_MAPPED_IO
-      #define RD_REG_BYTE(addr)         (*((volatile uint8_t *)addr))
-       #define RD_REG_WORD(addr)         (*((volatile uint16_t *)addr))
-       #define RD_REG_DWORD(addr)        (*((volatile uint32_t *)addr))
-       #define WRT_REG_BYTE(addr, data)  (*((volatile uint8_t *)addr) = data)
-       #define WRT_REG_WORD(addr, data)  (*((volatile uint16_t *)addr) = data)
-       #define WRT_REG_DWORD(addr, data) (*((volatile uint32_t *)addr) = data) 
+#define RD_REG_BYTE(addr)		readb(addr)
+#define RD_REG_WORD(addr)		readw(addr)
+#define RD_REG_DWORD(addr)		readl(addr)
+#define WRT_REG_BYTE(addr, data)	writeb(data, addr)
+#define WRT_REG_WORD(addr, data)	writew(data, addr)
+#define WRT_REG_DWORD(addr, data)	writel(data, addr)
 #else   /* MEMORY_MAPPED_IO */
-#define RD_REG_BYTE(addr)         (inb((unsigned long)addr))
-#define RD_REG_WORD(addr)         (inw((unsigned long)addr))
-#define RD_REG_DWORD(addr)        (inl((unsigned long)addr))
-#ifdef LINUX_IOPORTS
+#define RD_REG_BYTE(addr)		inb((unsigned long)addr)
+#define RD_REG_WORD(addr)		inw((unsigned long)addr)
+#define RD_REG_DWORD(addr)		inl((unsigned long)addr)
 /* Parameters are reversed in Linux */
-#define WRT_REG_BYTE(addr, data)  (outb(data,(unsigned long)addr))
-#define WRT_REG_WORD(addr, data)  (outw(data,(unsigned long)addr))
-#define WRT_REG_DWORD(addr, data) (outl(data,(unsigned long)addr))
-#else
-#define WRT_REG_BYTE(addr, data)  (outb((unsigned long)addr, data))
-#define WRT_REG_WORD(addr, data)  (outw((unsigned long)addr, data))
-#define WRT_REG_DWORD(addr, data) (outl((unsigned long)addr, data))
-#endif
+#define WRT_REG_BYTE(addr, data)	outb(data, (unsigned long)addr)
+#define WRT_REG_WORD(addr, data)	outw(data, (unsigned long)addr)
+#define WRT_REG_DWORD(addr, data)	outl(data, (unsigned long)addr)
 #endif  /* MEMORY_MAPPED_IO */
 #endif    /* QL_DEBUG_LEVEL_1 */
 
@@ -228,7 +150,7 @@
 #define QLA1280_WDG_TIME_QUANTUM   5    /* In seconds */
 
 /* Command retry count (0-65535) */
-#define COMMAND_RETRY_COUNT   255
+#define COMMAND_RETRY_COUNT	255
 
 /* Maximum outstanding commands in ISP queues (1-65535) */
 #define MAX_OUTSTANDING_COMMANDS   512
@@ -238,10 +160,10 @@
 #define RESPONSE_ENTRY_CNT      16      /* Number of response entries. */
 
 /* Maximum equipage per controller */
-#define MAX_EQ          (MAX_BUSES * MAX_TARGETS * MAX_LUNS)
+#define MAX_EQ			(MAX_BUSES * MAX_TARGETS * MAX_LUNS)
 
 /* Number of segments 1 - 65535 */
-#define SG_SEGMENTS     32             /* Cmd entry + 6 continuations */
+#define SG_SEGMENTS		32	/* Cmd entry + 6 continuations */
 
 
 /*
@@ -305,35 +227,6 @@
 #define QLA1280_BREM    BIT_7           /* controller is removed */
 
 /*
- *  ISP PCI Configuration Register Set
- */
-typedef volatile struct
-{
-    uint16_t vendor_id;                 /* 0x0 */
-    uint16_t device_id;                 /* 0x2 */
-    uint16_t command;                   /* 0x4 */
-    uint16_t status;                    /* 0x6 */
-    uint8_t revision_id;                /* 0x8 */
-    uint8_t programming_interface;      /* 0x9 */
-    uint8_t sub_class;                  /* 0xa */
-    uint8_t base_class;                 /* 0xb */
-    uint8_t cache_line;                 /* 0xc */
-    uint8_t latency_timer;              /* 0xd */
-    uint8_t header_type;                /* 0xe */
-    uint8_t bist;                       /* 0xf */
-    uint32_t base_port;                  /* 0x10 */
-    uint32_t mem_base_addr;              /* 0x14 */
-    uint32_t base_addr[4];               /* 0x18-0x24 */
-    uint32_t reserved_1[2];              /* 0x28-0x2c */
-    uint16_t expansion_rom;             /* 0x30 */
-    uint32_t reserved_2[2];              /* 0x34-0x38 */
-    uint8_t interrupt_line;             /* 0x3c */
-    uint8_t interrupt_pin;              /* 0x3d */
-    uint8_t min_grant;                  /* 0x3e */
-    uint8_t max_latency;                /* 0x3f */
-}config_reg_t;
-
-/*
  *  ISP I/O Register Set structure definitions.
  */
 typedef volatile struct
@@ -346,6 +239,8 @@
         #define ISP_RESET       BIT_0   /* ISP soft reset */
         #define ISP_EN_INT      BIT_1   /* ISP enable interrupts. */
         #define ISP_EN_RISC     BIT_2   /* ISP enable RISC interrupts. */
+	#define ISP_FLASH_ENABLE BIT_8	/* Flash BIOS Read/Write enable */
+	#define ISP_FLASH_UPPER BIT_9	/* Flash upper bank select */
     uint16_t istatus;                   /* Interface status */
         #define PCI_64BIT_SLOT  BIT_14  /* PCI 64-bit slot indicator. */
         #define RISC_INT        BIT_2   /* RISC interrupt */
@@ -735,9 +630,9 @@
             uint8_t auto_term_support   :1;
         }f;
     }termination;                                   /* 17 */
-								/* Auto Term - 3                          */
-								/* High Only - 1 (GPIO2 = 1 & GPIO3 = 0)  */
-								/* Disable - 0 (GPIO2 = 0 & GPIO3 = X)    */
+				/* Auto Term - 3                          */
+				/* High Only - 1 (GPIO2 = 1 & GPIO3 = 0)  */
+				/* Disable - 0 (GPIO2 = 0 & GPIO3 = X)    */
 
     uint16_t isp_parameter;                         /* 18, 19 */
 
@@ -1367,7 +1262,7 @@
     uint8_t     id;                    /* Host adapter SCSI id */
     uint8_t     bus_reset_delay;       /* SCSI bus reset delay. */
     uint8_t     failed_reset_count;    /* number of time reset failed */
-	uint8_t     unused;
+    uint8_t     unused;
     uint16_t    device_enables;        /* Device enable bits. */
     uint16_t    lun_disables;          /* LUN disable bits. */
     uint16_t    qtag_enables;          /* Tag queue enables. */
@@ -1390,18 +1285,14 @@
     uint8_t          pci_bus;
     uint8_t          pci_device_fn;
     uint8_t          devnum;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
     struct pci_dev *pdev;
-#endif
+
     volatile unsigned char  *mmpbase;      /* memory mapped address */
     unsigned long            host_no;
     unsigned long            instance;
     uint8_t           revision;
     uint8_t           ports;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,0)
-    spinlock_t               spin_lock;
-#endif
-    volatile unsigned char   cpu_lock_count[NR_CPUS];
+
     unsigned long            actthreads;
     unsigned long            qthreads;
     unsigned long            isr_count;        /* Interrupt count */
@@ -1418,11 +1309,6 @@
     /* Device LUN queues. */
     scsi_lu_t       *dev[MAX_EQ];      /* Logical unit queues */
 
-#ifdef UNUSED
-    /* Interrupt lock, and data */
-    uint8_t          intr_lock;         /* Lock for interrupt locking */
-#endif
-
     /* bottom half run queue */
     struct tq_struct run_qla_bh;
 
@@ -1430,41 +1316,24 @@
     volatile uint16_t mailbox_out[MAILBOX_REGISTER_COUNT];
 
 #ifdef UNUSED
-    /* ISP ring lock, rings, and indexes */
-    uint8_t          ring_lock;         /* ISP ring lock */
     struct timer_list        dev_timer[MAX_TARGETS];
 #endif
 
-    request_t       req[REQUEST_ENTRY_CNT+1];
-    response_t      res[RESPONSE_ENTRY_CNT+1];
-#if BITS_PER_LONG > 32
     dma_addr_t      request_dma;        /* Physical Address */
-#else
-    uint32_t        request_dma;        /* Physical address. */
-#endif
     request_t       *request_ring;      /* Base virtual address */
     request_t       *request_ring_ptr;  /* Current address. */
     uint16_t        req_ring_index;     /* Current index. */
     uint16_t        req_q_cnt;          /* Number of available entries. */
 
-#if BITS_PER_LONG > 32
     dma_addr_t      response_dma;       /* Physical address. */
-#else
-    uint32_t        response_dma;       /* Physical address. */
-#endif
     response_t      *response_ring;     /* Base virtual address */
     response_t      *response_ring_ptr; /* Current address. */
     uint16_t        rsp_ring_index;     /* Current index. */
 
 #if QL1280_TARGET_MODE_SUPPORT
     /* Target buffer and sense data. */
-#if BITS_PER_LONG > 32
     dma_addr_t      tbuf_dma;           /* Physical address. */
     dma_addr_t      tsense_dma;         /* Physical address. */
-#else
-    uint32_t        tbuf_dma;           /* Physical address. */
-    uint32_t        tsense_dma;         /* Physical address. */
-#endif
     tgt_t           *tbuf;
     uint8_t         *tsense;
 #endif
@@ -1495,14 +1364,11 @@
         uint32_t     abort_isp_active        :1;   /* 9 */
         uint32_t     disable_risc_code_load  :1;   /* 10 */
         uint32_t     enable_64bit_addressing :1;   /* 11 */
-#define QLA1280_IN_ISR_BIT      12
-        uint32_t     in_isr                  :1;   /* 12 */
-        uint32_t     in_abort                :1;   /* 13 */
-        uint32_t     in_reset                :1;   /* 14 */
-       uint32_t     dpc                     :1;   /* 15 */
-       uint32_t     dpc_sched               :1;   /* 16 */
-       uint32_t     interrupts_on               :1;   /* 17 */
-       uint32_t     bios_enabled               :1;   /* 18 */
+        uint32_t     in_abort                :1;   /* 12 */
+        uint32_t     in_reset                :1;   /* 13 */
+        uint32_t     dpc                     :1;   /* 14 */
+        uint32_t     dpc_sched               :1;   /* 15 */
+        uint32_t     bios_enabled            :1;   /* 16 */
     }flags;
 
   /* needed holders for PCI ordered list of hosts */
@@ -1517,31 +1383,8 @@
 #define SUBDEV(b, t, l)  ( (b << (MAX_T_BITS + MAX_L_BITS)) | (t << MAX_L_BITS) | l)
 #define LU_Q(ha, b, t, l)  (ha->dev[SUBDEV(b, t, l)])
 
-/*
- * Locking Macro Definitions
- *
- * LOCK/UNLOCK definitions are lock/unlock primitives for multi-processor
- * or spl/splx for uniprocessor.
- */
-#define QLA1280_HIER   HBA_HIER_BASE  /* Locking hierarchy base for hba */
-
-#define QLA1280_WATCHDOG_Q_LOCK(ha, p)   
-#define QLA1280_WATCHDOG_Q_UNLOCK(ha, p) 
-
-#define QLA1280_SCSILU_LOCK(q)  
-#define QLA1280_SCSILU_UNLOCK(q) 
-
-#define QLA1280_INTR_LOCK(ha)
-#define QLA1280_INTR_UNLOCK(ha)     
-
-#define QLA1280_RING_LOCK(ha)  
-#define QLA1280_RING_UNLOCK(ha)   
-
 #endif  /* HOSTS_C */
 
-#if defined(__cplusplus)
-}
-#endif
 /*
  *  Linux - SCSI Driver Interface Function Prototypes.
  */
@@ -1549,7 +1392,6 @@
 const char * qla1280_info(struct Scsi_Host *host);
 int qla1280_detect(Scsi_Host_Template *);
 int qla1280_release(struct Scsi_Host *);
-const char * qla1280_info(struct Scsi_Host *);
 int qla1280_queuecommand(Scsi_Cmnd *, void (* done)(Scsi_Cmnd *));
 int qla1280_abort(Scsi_Cmnd *);
 int qla1280_reset(Scsi_Cmnd *, unsigned int);
@@ -1569,7 +1411,7 @@
 	module: NULL,						\
 	proc_dir: NULL,						\
 	proc_info: qla1280_proc_info,				\
-	name:			"Qlogic ISP 1280\12160",        \
+	name:			"Qlogic ISP 1280/12160",        \
 	detect: qla1280_detect,					\
 	release: qla1280_release,				\
 	info: qla1280_info,					\
@@ -1595,8 +1437,6 @@
 	use_new_eh_code: 0,					\
 	emulated: 0					        \
 }
-
-
 
 #endif /* _IO_HBA_QLA1280_H */
 
