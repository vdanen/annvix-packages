--- linux-2.4.22/kernel/sysctl.c.cc07.orig	2003-08-28 03:03:33.000000000 +0200
+++ linux-2.4.22/kernel/sysctl.c	2003-08-28 03:03:56.000000000 +0200
@@ -30,6 +30,7 @@
 #include <linux/init.h>
 #include <linux/sysrq.h>
 #include <linux/highuid.h>
+#include <linux/swap.h>
 
 #include <asm/uaccess.h>
 
@@ -275,6 +276,18 @@ static ctl_table kern_table[] = {
 };
 
 static ctl_table vm_table[] = {
+	{VM_GFP_DEBUG, "vm_gfp_debug", 
+	 &vm_gfp_debug, sizeof(int), 0644, NULL, &proc_dointvec},
+	{VM_VFS_SCAN_RATIO, "vm_vfs_scan_ratio", 
+	 &vm_vfs_scan_ratio, sizeof(int), 0644, NULL, &proc_dointvec},
+	{VM_CACHE_SCAN_RATIO, "vm_cache_scan_ratio", 
+	 &vm_cache_scan_ratio, sizeof(int), 0644, NULL, &proc_dointvec},
+	{VM_MAPPED_RATIO, "vm_mapped_ratio", 
+	 &vm_mapped_ratio, sizeof(int), 0644, NULL, &proc_dointvec},
+	{VM_LRU_BALANCE_RATIO, "vm_lru_balance_ratio", 
+	 &vm_lru_balance_ratio, sizeof(int), 0644, NULL, &proc_dointvec},
+	{VM_PASSES, "vm_passes", 
+	 &vm_passes, sizeof(int), 0644, NULL, &proc_dointvec},
 	{VM_BDFLUSH, "bdflush", &bdf_prm, 9*sizeof(int), 0644, NULL,
 	 &proc_dointvec_minmax, &sysctl_intvec, NULL,
 	 &bdflush_min, &bdflush_max},
--- linux-2.4.22/mm/page_alloc.c.cc07.orig	2003-08-28 02:43:38.000000000 +0200
+++ linux-2.4.22/mm/page_alloc.c	2003-08-28 03:03:56.000000000 +0200
@@ -45,6 +45,8 @@ static int zone_balance_ratio[MAX_NR_ZON
 static int zone_balance_min[MAX_NR_ZONES] __initdata = { 20 , 20, 20, };
 static int zone_balance_max[MAX_NR_ZONES] __initdata = { 255 , 255, 255, };
 
+int vm_gfp_debug = 0;
+
 /*
  * Temporary debugging check.
  */
--- linux-2.4.22/mm/vmscan.c.cc07.orig	2003-08-28 02:43:38.000000000 +0200
+++ linux-2.4.22/mm/vmscan.c	2003-08-28 03:03:56.000000000 +0200
@@ -28,12 +28,42 @@
 #include <asm/pgalloc.h>
 
 /*
- * The "priority" of VM scanning is how much of the queues we
- * will scan in one go. A value of 6 for DEF_PRIORITY implies
- * that we'll scan 1/64th of the queues ("queue_length >> 6")
- * during a normal aging round.
+ * "vm_passes" is the number of vm passes before failing the
+ * memory balancing. Take into account 3 passes are needed
+ * for a flush/wait/free cycle and that we only scan 1/vm_cache_scan_ratio
+ * of the inactive list at each pass.
  */
-#define DEF_PRIORITY (6)
+int vm_passes = 60;
+
+/*
+ * "vm_cache_scan_ratio" is how much of the inactive LRU queue we will scan
+ * in one go. A value of 6 for vm_cache_scan_ratio implies that we'll
+ * scan 1/6 of the inactive lists during a normal aging round.
+ */
+int vm_cache_scan_ratio = 6;
+
+/*
+ * "vm_mapped_ratio" controls the pageout rate, the smaller, the earlier
+ * we'll start to pageout.
+ */
+int vm_mapped_ratio = 100;
+
+/*
+ * "vm_lru_balance_ratio" controls the balance between active and
+ * inactive cache. The bigger vm_balance is, the easier the
+ * active cache will grow, because we'll rotate the active list
+ * slowly. A value of 2 means we'll go towards a balance of
+ * 1/3 of the cache being inactive.
+ */
+int vm_lru_balance_ratio = 2;
+
+/*
+ * "vm_vfs_scan_ratio" is what proportion of the VFS queues we will scan
+ * in one go. A value of 6 for vm_vfs_scan_ratio implies that 1/6th of
+ * the unused-inode, dentry and dquot caches will be freed during a normal
+ * aging round.
+ */
+int vm_vfs_scan_ratio = 6;
 
 /*
  * The swap-out function returns 1 if it successfully
@@ -582,7 +612,7 @@ static int shrink_caches(zone_t * classz
 	shrink_dcache_memory(priority, gfp_mask);
 	shrink_icache_memory(priority, gfp_mask);
 #ifdef CONFIG_QUOTA
-	shrink_dqcache_memory(DEF_PRIORITY, gfp_mask);
+	shrink_dqcache_memory(priority, gfp_mask);
 #endif
 
 	return nr_pages;
@@ -590,7 +620,7 @@ static int shrink_caches(zone_t * classz
 
 int try_to_free_pages_zone(zone_t *classzone, unsigned int gfp_mask)
 {
-	int priority = DEF_PRIORITY;
+	int priority = 6;
 	int nr_pages = SWAP_CLUSTER_MAX;
 
 	gfp_mask = pf_gfp_mask(gfp_mask);
--- linux-2.4.22/include/linux/swap.h.cc07.orig	2003-08-28 02:43:38.000000000 +0200
+++ linux-2.4.22/include/linux/swap.h	2003-08-28 03:03:56.000000000 +0200
@@ -115,6 +115,7 @@ extern void swap_setup(void);
 extern wait_queue_head_t kswapd_wait;
 extern int FASTCALL(try_to_free_pages_zone(zone_t *, unsigned int));
 extern int FASTCALL(try_to_free_pages(unsigned int));
+extern int vm_vfs_scan_ratio, vm_cache_scan_ratio, vm_lru_balance_ratio, vm_passes, vm_gfp_debug, vm_mapped_ratio;
 
 /* linux/mm/page_io.c */
 extern void rw_swap_page(int, struct page *);
--- linux-2.4.22/include/linux/sysctl.h.cc07.orig	2003-08-28 03:03:51.000000000 +0200
+++ linux-2.4.22/include/linux/sysctl.h	2003-08-28 03:05:15.000000000 +0200
@@ -149,8 +149,13 @@ enum
 	VM_MAX_READAHEAD=13,    /* Max file readahead */
 	VM_LAPTOP_MODE=14,	/* vm laptop mode */
 	VM_BLOCK_DUMP=15,	/* dump data read/write and dirtying */
-	VM_HEAP_STACK_GAP=16,	/* int: page gap between heap and stack */
 	VM_PAGEBUF=17,		/* struct: Control pagebuf parameters */
+	VM_VFS_SCAN_RATIO=18,	/* part of the inactive vfs lists to scan */
+	VM_LRU_BALANCE_RATIO=19,/* balance active and inactive caches */
+	VM_PASSES=20,		/* number of vm passes before failing */
+	VM_GFP_DEBUG=21,	/* debug GFP failures */
+	VM_CACHE_SCAN_RATIO=22,	/* part of the inactive cache list to scan */
+	VM_MAPPED_RATIO=23,	/* amount of unfreeable pages that triggers swapout */
 };
 
 
