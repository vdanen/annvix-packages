diff -ruN certwatch.org/certwatch.c certwatch/certwatch.c
--- certwatch.org/certwatch.c	2004-10-13 16:10:10.000000000 -0600
+++ certwatch/certwatch.c	2005-03-18 12:28:31.000000000 -0700
@@ -57,7 +57,7 @@
 /* Print a warning message that the certificate in 'filename', issued
  * to hostname 'hostname', will expire (or has expired). */
 static int warning(FILE *out, const char *filename, const char *hostname,
-                   time_t start, time_t end, time_t now, int quiet)
+                   time_t start, time_t end, time_t now, int quiet, const char *email)
 {
     int renew = 1, days = (end - now) / (3600 * 24);    /* days till expiry */
     char subj[50];
@@ -79,36 +79,39 @@
 
     if (quiet) return 1;
 
-    fputs("To: root@localhost\n", out);
+    if (email == NULL)
+        email = "root@localhost";
+    
+    fprintf(out, "To: %s\n", email);
     fprintf(out, "Subject: The certificate for %s %s\n", hostname, subj);
     fputs("\n", out);
     
     fprintf(out, 
-            " ################# SSL Certificate Warning ################\n\n");
+            " ######################## SSL Certificate Warning ########################\n\n");
 
-    fprintf(out, " Certificate for %s, in '%s':\n\n", hostname, filename);
+    fprintf(out, " The certificate for host %s in the file:\n\n  %s\n\n generated the following warning:\n\n", hostname, filename);
 
     if (renew) {
-        fputs("  The certificate needs to be renewed; this can be done using the\n"
-              "  '/usr/bin/openssl' or the '/usr/lib/ssl/apache2-mod_ssl/gentestcrt.sh'\n"
-              "  programs supplied with Mandrakelinux.\n\n"
-              "  Browsers will not be able to correctly connect to this\n"
-              "  web site using SSL until the certificate is renewed.\n",
+        fputs(" The certificate needs to be renewed; this can be done using the\n"
+              " '/usr/bin/openssl' or the '/usr/lib/ssl/apache2-mod_ssl/gentestcrt.sh'\n"
+              " programs supplied with Annvix.\n\n"
+              " Browsers will not be able to correctly connect to this web site using SSL\n"
+              " until the certificate is renewed.\n",
               out);
     } else {
         char until[30] = "(unknown date)";
         ctime_r(&start, until);
         if (strlen(until) > 2) until[strlen(until)-1] = '\0';
         fprintf(out, 
-                "  The certificate is not valid until %s.\n\n"
-                "  Browsers will not be able to correctly connect to this\n"
-                "  web site using SSL until the certificate becomes valid.\n", 
+                " The certificate is not valid until %s.\n\n"
+                " Browsers will not be able to correctly connect to this web site using SSL\n"
+                " until the certificate becomes valid.\n", 
                 until);
     }
 
     fputs("\n"
-          " ##########################################################\n"
-          "                                  Generated by certwatch(8)\n\n",
+          " #########################################################################\n"
+          " Warning generated by certwatch(8)\n\n",
           out);
     return 1;
 }
@@ -128,7 +131,7 @@
  * returns one to indicate that a warning would have been issued, zero
  * to indicate no warning would be issued, or -1 if an error
  * occurred. */
-static int check_cert(const char *filename, int quiet)
+static int check_cert(const char *filename, int quiet, const char *email)
 {
     X509 *cert;
     FILE *fp;
@@ -163,7 +166,7 @@
         strcmp(cname, "localhost.localdomain") == 0)
         return -1;
 
-    return warning(stdout, filename, cname, begin, end, now, quiet);
+    return warning(stdout, filename, cname, begin, end, now, quiet, email);
 }
 
 int main(int argc, char **argv)
@@ -176,7 +179,10 @@
         argv++;
     }
     
-    if (argc != 2) return 0;
-
-    return check_cert(argv[1], quiet) == 1 ? EXIT_SUCCESS : EXIT_FAILURE;
+    if (argc < 2) {
+        printf("Usage: certwatch [-q] certificate_file [email_address]\n\n");
+        return 0;
+    }
+    
+    return check_cert(argv[1], quiet, argv[2]) == 1 ? EXIT_SUCCESS : EXIT_FAILURE;
 }
diff -ruN certwatch.org/certwatch.cron certwatch/certwatch.cron
--- certwatch.org/certwatch.cron	2004-10-13 17:49:17.000000000 -0400
+++ certwatch/certwatch.cron	2005-10-13 10:56:57.000000000 -0400
@@ -8,23 +8,64 @@
 [ -r /etc/sysconfig/httpd ] && . /etc/sysconfig/httpd
 
 # Use configured httpd binary
-HTTPD="/usr/sbin/httpd2"
-CONF="/etc/httpd/conf/httpd2.conf"
+HTTPD="/usr/sbin/httpd"
+CONF="/etc/httpd/conf"
+EMAIL="`egrep '^ServerAdmin' $CONF/httpd.conf |awk '{print $2}'`"
 
 # Sanity checks
 test -z "${NOCERTWATCH}" || exit 0
 test -x $HTTPD || exit 0
-test -r $CONF || exit 0
+test -r $CONF/httpd.conf || exit 0
 test -x /usr/sbin/certwatch || exit 0
-test -x /usr/sbin/sendmail || exit 0
+test -x /usr/sbin/exim || exit 0
 
-DEFINE=`/etc/rc.d/init.d/httpd define`
-certs=`$HTTPD -t -f $CONF $DEFINE -DDUMP_CERTS  2>/dev/null`
+# taken from the httpd2 run script
+moduleargs() {
+	moduleargs=
+	for module in $1/*.so ; do
+		if [ -x ${module} ] ; then
+			module=`echo ${module} | awk '{
+				gsub(".*/","");
+				gsub("^mod_","");
+				gsub("^lib","");
+				gsub(".so$","");
+				print toupper($0)}'`
+			moduleargs="${moduleargs} -DHAVE_$module"
+		fi
+	done
+	echo ${moduleargs}
+}
+
+# Get the extra modules so only the main server gets them
+extramoduleargs() {
+	extramoduleargs=
+	for extramodule in $1/*.so ; do
+		if [ -x ${extramodule} ] ; then
+			extramodule=`echo ${extramodule} | awk '{
+				gsub(".*/","");
+				gsub("^mod_","");
+				gsub("^lib","");
+				gsub(".so$","");
+				print toupper($0)}'`
+			extramoduleargs="${extramoduleargs} -DHAVE_$extramodule" 
+		fi
+	done
+	echo ${extramoduleargs}
+}
+
+APACHEXMODS="-DAPACHE2 -DNO_DETACH `extramoduleargs /etc/httpd/extramodules`"
+APACHEREGMODS=`moduleargs /etc/httpd/modules`
+
+certs=`$HTTPD -t -f $CONF/httpd.conf $APACHEXMODS $APACHEREGMODS -DDUMP_CERTS  2>/dev/null`
 RETVAL=$?
 test $RETVAL -eq 0 || exit 0
 
 for c in $certs; do
     # Check whether a warning message is needed, then issue one if so.
     /usr/sbin/certwatch -q "$c" && 
-    /usr/sbin/certwatch "$c" | /usr/sbin/sendmail -oem -oi -t 2>/dev/null
+    /usr/sbin/certwatch "$c" "$EMAIL" | /usr/sbin/exim -t 2>/dev/null
 done
+
+# because certwatch does exit 1 on a valid cert, force exit 0 here so cron
+# doesn't think there are errors
+exit 0
