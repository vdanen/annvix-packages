diff -ur xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h
--- xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h	2005-01-25 04:20:12.000000000 +0100
+++ xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h	2005-05-31 14:20:12.274375263 +0200
@@ -596,6 +596,8 @@
 
     /* special handlings for DELL triple-head server */
     Bool		IsDellServer; 
+
+    Bool		VGAAccess;
 } RADEONInfoRec, *RADEONInfoPtr;
 
 
Only in xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati: radeon.h.orig
diff -ur xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.man xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati/radeon.man
--- xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.man	2004-09-04 01:26:19.000000000 +0200
+++ xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati/radeon.man	2005-05-31 14:20:12.270375189 +0200
@@ -494,6 +494,17 @@
 with this enabled.  The default is
 .B off.
 .TP
+.BI "Option \*qVGAAccess\*q \*q" boolean \*q
+Tell the driver if it can do legacy VGA IOs to the card. This is
+necessary for properly resuming consoles when in VGA text mode, but
+shouldn't be if the console is using radeonfb or some other graphic
+mode driver. Some platforms like PowerPC have issues with those, and they aren't
+necessary unless you have a real text mode in console. The default is
+.B off
+on PowerPC and
+.B on
+on other architectures.
+.TP
 
 .SH SEE ALSO
 __xservername__(__appmansuffix__), __xconfigfile__(__filemansuffix__), xorgconfig(__appmansuffix__), Xserver(__appmansuffix__), X(__miscmansuffix__)
Only in xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati: radeon.man.orig
diff -ur xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c
--- xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c	2004-08-12 07:00:22.000000000 +0200
+++ xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c	2005-05-31 14:20:12.344376566 +0200
@@ -291,10 +291,7 @@
     OUTREGP(RADEON_DP_DATATYPE, 0, ~RADEON_HOST_BIG_ENDIAN_EN);
 #endif
 
-    /* Restore SURFACE_CNTL - only the first head contains valid data -ReneR */
-    if (!info->IsSecondary) {
-	OUTREG(RADEON_SURFACE_CNTL, info->ModeReg.surface_cntl);
-    }
+    OUTREG(RADEON_SURFACE_CNTL, info->ModeReg.surface_cntl);
 
     RADEONWaitForFifo(pScrn, 1);
     OUTREG(RADEON_DEFAULT_SC_BOTTOM_RIGHT, (RADEON_DEFAULT_SC_RIGHT_MAX
Only in xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati: radeon_accel.c.orig
diff -ur xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c
--- xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c	2005-05-31 14:15:26.000000000 +0200
+++ xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c	2005-05-31 14:20:12.416377905 +0200
@@ -164,6 +164,7 @@
     OPTION_SUBPIXEL_ORDER,
 #endif
     OPTION_SHOWCACHE,
+    OPTION_VGA_ACCESS,
     OPTION_DYNAMIC_CLOCKS
 } RADEONOpts;
 
@@ -209,6 +210,7 @@
 #endif
     { OPTION_SHOWCACHE,      "ShowCache",        OPTV_BOOLEAN, {0}, FALSE },
     { OPTION_DYNAMIC_CLOCKS, "DynamicClocks",    OPTV_BOOLEAN, {0}, FALSE },
+    { OPTION_VGA_ACCESS,     "VGAAccess",        OPTV_BOOLEAN, {0}, TRUE  },
     { -1,                    NULL,               OPTV_NONE,    {0}, FALSE }
 };
 
@@ -938,6 +940,9 @@
 	MonType = MT_NONE;
     }
 
+    OUTREG(info->DDCReg, INREG(info->DDCReg) &
+	   ~(RADEON_GPIO_EN_0 | RADEON_GPIO_EN_1));
+
     if (*MonInfo) {
 	if ((*MonInfo)->rawData[0x14] & 0x80) {
 	    /* Note some laptops have a DVI output that uses internal TMDS,
@@ -1184,41 +1189,59 @@
     return(bConnected ? MT_CRT : MT_NONE);
 }
 
-#if defined(__powerpc__)
 static Bool RADEONProbePLLParameters(ScrnInfoPtr pScrn)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     RADEONPLLPtr  pll  = &info->pll;
     unsigned char *RADEONMMIO = info->MMIO;
     unsigned char ppll_div_sel;
-    unsigned Nx, M;
+    unsigned mpll_fb_div, spll_fb_div, M;
     unsigned xclk, tmp, ref_div;
     int hTotal, vTotal, num, denom, m, n;
-    float hz, vclk, xtal;
+    float hz, prev_xtal, vclk, xtal, mpll, spll;
     long start_secs, start_usecs, stop_secs, stop_usecs, total_usecs;
-    int i;
-
-    for(i=0; i<1000000; i++)
-	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
+    long to1_secs, to1_usecs, to2_secs, to2_usecs;
+    unsigned int f1, f2, f3;
+    int tries = 0;
+
+    prev_xtal = 0;
+ again:
+    xtal = 0;
+    if (++tries > 10)
+           goto failed;
+
+    xf86getsecs(&to1_secs, &to1_usecs);
+    f1 = INREG(RADEON_CRTC_CRNT_FRAME);
+    for (;;) {
+       f2 = INREG(RADEON_CRTC_CRNT_FRAME);
+       if (f1 != f2)
 	    break;
-
+       xf86getsecs(&to2_secs, &to2_usecs);
+       if ((to2_secs - to1_secs) > 1) {
+           xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Clock not counting...\n");
+           goto failed;
+       }
+    }
     xf86getsecs(&start_secs, &start_usecs);
-
-    for(i=0; i<1000000; i++)
-	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) != 0)
-	    break;
-
-    for(i=0; i<1000000; i++)
-	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
+    for(;;) {
+       f3 = INREG(RADEON_CRTC_CRNT_FRAME);
+       if (f3 != f2)
 	    break;
-
+       xf86getsecs(&to2_secs, &to2_usecs);
+       if ((to2_secs - start_secs) > 1)
+           goto failed;
+    }
     xf86getsecs(&stop_secs, &stop_usecs);
 
+    if ((stop_secs - start_secs) != 0)
+           goto again;
     total_usecs = abs(stop_usecs - start_usecs);
-    hz = 1000000/total_usecs;
+    if (total_usecs == 0)
+           goto again;
+    hz = 1000000.0/(float)total_usecs;
 
-    hTotal = ((INREG(RADEON_CRTC_H_TOTAL_DISP) & 0x1ff) + 1) * 8;
-    vTotal = ((INREG(RADEON_CRTC_V_TOTAL_DISP) & 0x3ff) + 1);
+    hTotal = ((INREG(RADEON_CRTC_H_TOTAL_DISP) & 0x3ff) + 1) * 8;
+    vTotal = ((INREG(RADEON_CRTC_V_TOTAL_DISP) & 0xfff) + 1);
     vclk = (float)(hTotal * (float)(vTotal * hz));
 
     switch((INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x30000) >> 16) {
@@ -1241,8 +1264,7 @@
         break;
      }
 
-    OUTREG(RADEON_CLOCK_CNTL_INDEX, 1);
-    ppll_div_sel = INREG8(RADEON_CLOCK_CNTL_DATA + 1) & 0x3;
+    ppll_div_sel = INREG8(RADEON_CLOCK_CNTL_INDEX + 1) & 0x3;
 
     n = (INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel) & 0x7ff);
     m = (INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x3ff);
@@ -1280,23 +1302,93 @@
     else if ((xtal > 29400000) && (xtal < 29600000))
         xtal = 2950;
     else
-	return FALSE;
+       goto again;
+ failed:
+    if (xtal == 0) {
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Failed to probe xtal value ! "
+                  "Using default 27Mhz\n");
+       xtal = 2700;
+    } else {
+       if (prev_xtal == 0) {
+           prev_xtal = xtal;
+           tries = 0;
+           goto again;
+       } else if (prev_xtal != xtal) {
+           prev_xtal = 0;
+           goto again;
+       }
+    }
 
     tmp = INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV);
     ref_div = INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x3ff;
 
-    Nx = (tmp & 0xff00) >> 8;
+    /* Some sanity check based on the BIOS code .... */
+    if (ref_div < 2) {
+       CARD32 tmp;
+       tmp = INPLL(pScrn, RADEON_PPLL_REF_DIV);
+       if (IS_R300_VARIANT || (info->ChipFamily == CHIP_FAMILY_RS300))
+           ref_div = (tmp & R300_PPLL_REF_DIV_ACC_MASK) >>
+                   R300_PPLL_REF_DIV_ACC_SHIFT;
+       else
+           ref_div = tmp & RADEON_PPLL_REF_DIV_MASK;
+       if (ref_div < 2)
+           ref_div = 12;
+    }
+
+    /* Calculate "base" xclk straight from MPLL, though that isn't
+     * really useful (hopefully). This isn't called XCLK anymore on
+     * radeon's...
+     */
+    mpll_fb_div = (tmp & 0xff00) >> 8;
+    spll_fb_div = (tmp & 0xff0000) >> 16;
     M = (tmp & 0xff);
-    xclk = RADEONDiv((2 * Nx * xtal), (2 * M));
+    xclk = RADEONDiv((2 * mpll_fb_div * xtal), (M));
+
+    /*
+     * Calculate MCLK based on MCLK-A
+     */
+    mpll = (2.0 * (float)mpll_fb_div * (xtal / 100.0)) / (float)M;
+    spll = (2.0 * (float)spll_fb_div * (xtal / 100.0)) / (float)M;
+
+    tmp = INPLL(pScrn, RADEON_MCLK_CNTL) & 0x7;
+    switch(tmp) {
+    case 1: info->mclk = mpll; break;
+    case 2: info->mclk = mpll / 2.0; break;
+    case 3: info->mclk = mpll / 4.0; break;
+    case 4: info->mclk = mpll / 8.0; break;
+    case 7: info->mclk = spll; break;
+    default:
+           info->mclk = 200.00;
+           xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Unsupported MCLKA source"
+                      " setting %d, can't probe MCLK value !\n", tmp);
+    }
+
+    /*
+     * Calculate SCLK
+     */
+    tmp = INPLL(pScrn, RADEON_SCLK_CNTL) & 0x7;
+    switch(tmp) {
+    case 1: info->sclk = spll; break;
+    case 2: info->sclk = spll / 2.0; break;
+    case 3: info->sclk = spll / 4.0; break;
+    case 4: info->sclk = spll / 8.0; break;
+    case 7: info->sclk = mpll;
+    default:
+           info->sclk = 200.00;
+           xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Unsupported SCLK source"
+                      " setting %d, can't probe SCLK value !\n", tmp);
+    }
 
     /* we're done, hopefully these are sane values */
     pll->reference_div = ref_div;
     pll->xclk = xclk;
     pll->reference_freq = xtal;
 
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Probed PLL values: xtal: %f Mhz, "
+              "sclk: %f Mhz, mclk: %f Mhz\n", xtal/100.0, info->sclk, info->mclk);
+
     return TRUE;
 }
-#endif
 
 static void RADEONGetPanelInfoFromReg (ScrnInfoPtr pScrn)
 {
@@ -1448,17 +1540,24 @@
 	xf86DrvMsg (pScrn->scrnIndex, X_WARNING,
 		    "Video BIOS not detected, using default clock settings!\n");
 
-#if defined(__powerpc__)
-	if (RADEONProbePLLParameters(pScrn)) return;
-#endif
+       /* Default min/max PLL values */
+       if (info->ChipFamily == CHIP_FAMILY_R420) {
+           pll->min_pll_freq = 20000;
+           pll->max_pll_freq = 50000;
+       } else {
+           pll->min_pll_freq = 12500;
+           pll->max_pll_freq = 35000;
+       }
+
+       if (RADEONProbePLLParameters(pScrn))
+            return;
+
 	if (info->IsIGP)
 	    pll->reference_freq = 1432;
 	else
 	    pll->reference_freq = 2700;
 
 	pll->reference_div = 12;
-	pll->min_pll_freq = 12500;
-	pll->max_pll_freq = 35000;
 	pll->xclk = 10300;
 
         info->sclk = 200.00;
@@ -3411,7 +3510,7 @@
 		}
 	    }
 
- 	    if ((modesFound <= 1) || (user_modes_found < user_modes_asked)) {
+ 	    if ((modesFound < 1) || (user_modes_found < user_modes_asked)) {
 		/* when panel size is not valid, try to validate 
 		 * mode using xf86ValidateModes routine
 		 * This can happen when DDC is disabled.
@@ -3675,7 +3774,7 @@
 		}
 	    }
 
-	    if ((modesFound <= 1) || (user_modes_found < user_modes_asked)) {
+	    if ((modesFound < 1) || (user_modes_found < user_modes_asked)) {
 		/* when panel size is not valid, try to validate
 		 * mode using xf86ValidateModes routine
 		 * This can happen when DDC is disabled.
@@ -4146,14 +4245,6 @@
 	return TRUE;
     }
 
-    if (!xf86LoadSubModule(pScrn, "vgahw")) return FALSE;
-    xf86LoaderReqSymLists(vgahwSymbols, NULL);
-    if (!vgaHWGetHWRec(pScrn)) {
-	RADEONFreeRec(pScrn);
-	goto fail2;
-    }
-
-    vgaHWGetIOBase(VGAHWPTR(pScrn));
 
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 	       "PCI bus %d card %d func %d\n",
@@ -4182,6 +4273,32 @@
     memcpy(info->Options, RADEONOptions, sizeof(RADEONOptions));
     xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, info->Options);
 
+    /* By default, don't do VGA IOs on ppc */
+#ifdef __powerpc__
+    info->VGAAccess = FALSE;
+#else
+    info->VGAAccess = TRUE;
+#endif
+
+    xf86GetOptValBool(info->Options, OPTION_VGA_ACCESS, &info->VGAAccess);
+    if (info->VGAAccess) {
+       if (!xf86LoadSubModule(pScrn, "vgahw"))
+           info->VGAAccess = FALSE;
+        else {
+           xf86LoaderReqSymLists(vgahwSymbols, NULL);
+            if (!vgaHWGetHWRec(pScrn))
+               info->VGAAccess = FALSE;
+       }
+       if (!info->VGAAccess)
+           xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Loading VGA module failed,"
+                      " trying to run without it\n");
+    } else
+           xf86DrvMsg(pScrn->scrnIndex, X_INFO, "VGAAccess option set to FALSE,"
+                      " VGA module load skipped\n");
+    if (info->VGAAccess)
+        vgaHWGetIOBase(VGAHWPTR(pScrn));
+
+
     if (!RADEONPreInitWeight(pScrn))
 	goto fail;
 
@@ -4296,7 +4413,8 @@
     if (pInt10)
 	xf86FreeInt10(pInt10);
 
-    vgaHWFreeHWRec(pScrn);
+    if (info->VGAAccess)
+           vgaHWFreeHWRec(pScrn);
 
  fail2:
     if(info->MMIO) RADEONUnmapMMIO(pScrn);
@@ -5287,8 +5405,13 @@
            By doing this we can avoid the blanking problem with some panels.
         */
         if ((restore->ppll_ref_div == (INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_REF_DIV_MASK)) &&
-	    (restore->ppll_div_3 == (INPLL(pScrn, RADEON_PPLL_DIV_3) & (RADEON_PPLL_POST3_DIV_MASK | RADEON_PPLL_FB3_DIV_MASK))))
-            return;
+	    (restore->ppll_div_3 == (INPLL(pScrn, RADEON_PPLL_DIV_3) & 
+				     (RADEON_PPLL_POST3_DIV_MASK | RADEON_PPLL_FB3_DIV_MASK)))) {
+	    OUTREGP(RADEON_CLOCK_CNTL_INDEX,
+		    RADEON_PLL_DIV_SEL,
+		    ~(RADEON_PLL_DIV_SEL));
+	    return;
+	}
     }
 
     OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL,
@@ -5734,7 +5857,6 @@
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
     RADEONSavePtr  save       = &info->SavedReg;
-    vgaHWPtr       hwp        = VGAHWPTR(pScrn);
 
     RADEONTRACE(("RADEONSave\n"));
     if (info->FBDev) {
@@ -5743,19 +5865,23 @@
     }
 
     if (!info->IsSecondary) {
-	vgaHWUnlock(hwp);
+        if (info->VGAAccess) {
+           vgaHWPtr hwp = VGAHWPTR(pScrn);
+
+            vgaHWUnlock(hwp);
 #if defined(__powerpc__)
-	/* temporary hack to prevent crashing on PowerMacs when trying to
-	 * read VGA fonts and colormap, will find a better solution
-	 * in the future
-	 */
-	vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE); /* Save mode only */
+           /* temporary hack to prevent crashing on PowerMacs when trying to
+            * read VGA fonts and colormap, will find a better solution
+            * in the future. TODO: Check if there's actually some VGA stuff
+            * setup in the card at all !!
+            */
+           vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE); /* Save mode only */
 #else
-	vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE | VGA_SR_FONTS); /* Save mode
-						       * & fonts & cmap
-						       */
+           /* Save mode * & fonts & cmap */
+           vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE | VGA_SR_FONTS);
 #endif
-	vgaHWLock(hwp);
+           vgaHWLock(hwp);
+       }
 	save->dp_datatype      = INREG(RADEON_DP_DATATYPE);
 	save->rbbm_soft_reset  = INREG(RADEON_RBBM_SOFT_RESET);
 	save->clock_cntl_index = INREG(RADEON_CLOCK_CNTL_INDEX);
@@ -5771,7 +5897,6 @@
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
     RADEONSavePtr  restore    = &info->SavedReg;
-    vgaHWPtr       hwp        = VGAHWPTR(pScrn);
 
     RADEONTRACE(("RADEONRestore\n"));
 
@@ -5813,27 +5938,36 @@
     usleep(100000);
 #endif
 
-    if (!info->IsSecondary) {
-	vgaHWUnlock(hwp);
+    if (info->VGAAccess) {
+       vgaHWPtr hwp = VGAHWPTR(pScrn);
+        if (!info->IsSecondary) {
+            vgaHWUnlock(hwp);
 #if defined(__powerpc__)
-	/* Temporary hack to prevent crashing on PowerMacs when trying to
-	 * write VGA fonts, will find a better solution in the future
-	 */
-	vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE );
+           /* Temporary hack to prevent crashing on PowerMacs when trying to
+            * write VGA fonts, will find a better solution in the future
+            */
+           vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE );
 #else
-	vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE | VGA_SR_FONTS );
+           vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE | VGA_SR_FONTS );
 #endif
-	vgaHWLock(hwp);
-    } else {
-        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
-	ScrnInfoPtr   pScrn0;
-	vgaHWPtr      hwp0;
-
-	pScrn0 = pRADEONEnt->pPrimaryScrn;
-	hwp0   = VGAHWPTR(pScrn0);
-	vgaHWUnlock(hwp0);
-	vgaHWRestore(pScrn0, &hwp0->SavedReg, VGA_SR_MODE | VGA_SR_FONTS );
-	vgaHWLock(hwp0);
+           vgaHWLock(hwp);
+        } else {
+            RADEONEntPtr  pRADEONEnt = RADEONEntPriv(pScrn);
+           ScrnInfoPtr   pScrn0 = pRADEONEnt->pPrimaryScrn;
+            RADEONInfoPtr info0 = RADEONPTR(pScrn0);
+           vgaHWPtr      hwp0;
+
+           if (info0->VGAAccess) {
+               hwp0 = VGAHWPTR(pScrn0);
+               vgaHWUnlock(hwp0);
+#if defined(__powerpc__)
+               vgaHWRestore(pScrn0, &hwp0->SavedReg, VGA_SR_MODE);
+#else
+               vgaHWRestore(pScrn0, &hwp0->SavedReg, VGA_SR_MODE | VGA_SR_FONTS );
+#endif
+               vgaHWLock(hwp0);
+           }
+       }
     }
     RADEONUnblank(pScrn);
 
@@ -5981,7 +6115,7 @@
 	*/
 	temp = INREG(RADEON_MEM_CNTL);
 	data = (R300_MEM_NUM_CHANNELS_MASK & temp);
-	if (data == 2) {
+	if (data == 1) {
 	    if (R300_MEM_USE_CD_CH_ONLY & temp) {
 		temp  = INREG(R300_MC_IND_INDEX);
 		temp &= ~R300_MC_IND_ADDR_MASK;
@@ -6462,8 +6596,12 @@
 				      ? RADEON_CRTC2_V_SYNC_POL
 				      : 0));
 
+    /* This version of the driver doesn't do tiling, make sure it is disabled
+     * as the BIOS may have enabled it. 0 is a sane value for CRTC2_OFFSET_CNTL
+     * based on the documentation
+     */
     save->crtc2_offset      = 0;
-    save->crtc2_offset_cntl = INREG(RADEON_CRTC2_OFFSET_CNTL);
+    save->crtc2_offset_cntl = 0;
     /* this should be right */
     if (info->MergedFB) {
     save->crtc2_pitch  = (((info->CRT2pScrn->displayWidth * pScrn->bitsPerPixel) +
@@ -6505,6 +6643,23 @@
 
     }
 
+    /* We must set SURFACE_CNTL properly on the second screen too */
+    save->surface_cntl = 0;
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    /* Alhought we current onlu use aperture 0, also setting aperture 1 should not harm -ReneR */
+    switch (pScrn->bitsPerPixel) {
+    case 16:
+       save->surface_cntl |= RADEON_NONSURF_AP0_SWP_16BPP;
+       save->surface_cntl |= RADEON_NONSURF_AP1_SWP_16BPP;
+       break;
+
+    case 32:
+       save->surface_cntl |= RADEON_NONSURF_AP0_SWP_32BPP;
+       save->surface_cntl |= RADEON_NONSURF_AP1_SWP_32BPP;
+       break;
+    }
+#endif
+
     RADEONTRACE(("Pitch = %d bytes (virtualX = %d, displayWidth = %d)\n",
 		 save->crtc2_pitch, pScrn->virtualX,
 		 info->CurrentLayout.displayWidth));
@@ -6730,8 +6885,8 @@
 }
 
 /* Define PLL registers for requested video mode */
-static void RADEONInitPLLRegisters(RADEONSavePtr save, RADEONPLLPtr pll,
-				   double dot_clock)
+static void RADEONInitPLLRegisters(RADEONInfoPtr info, RADEONSavePtr save,
+                                  RADEONPLLPtr pll, double dot_clock)
 {
     unsigned long  freq = dot_clock * 100;
 
@@ -6755,6 +6910,13 @@
 	{  0, 0 }
     };
 
+    if (info->UseBiosDividers) {
+       save->ppll_ref_div = info->RefDivider;
+       save->ppll_div_3   = info->FeedbackDivider | (info->PostDivider << 16);
+       save->htotal_cntl  = 0;
+       return;
+    }
+
     if (freq > pll->max_pll_freq)      freq = pll->max_pll_freq;
     if (freq * 12 < pll->min_pll_freq) freq = pll->min_pll_freq / 12;
 
@@ -6789,7 +6951,7 @@
 
 /* Define PLL2 registers for requested video mode */
 static void RADEONInitPLL2Registers(RADEONSavePtr save, RADEONPLLPtr pll,
-				    double dot_clock)
+				    double dot_clock, int no_odd_postdiv)
 {
     unsigned long  freq = dot_clock * 100;
 
@@ -6816,6 +6978,11 @@
     if (freq * 12 < pll->min_pll_freq) freq = pll->min_pll_freq / 12;
 
     for (post_div = &post_divs[0]; post_div->divider; ++post_div) {
+       /* Odd post divider value don't work properly on the second digital
+        * output
+        */
+       if (no_odd_postdiv && (post_div->divider & 1))
+           continue;
 	save->pll_output_freq_2 = post_div->divider * freq;
 	if (save->pll_output_freq_2 >= pll->min_pll_freq
 	    && save->pll_output_freq_2 <= pll->max_pll_freq) break;
@@ -6916,7 +7083,7 @@
     if (info->IsSecondary) {
 	if (!RADEONInitCrtc2Registers(pScrn, save, mode, info))
 	    return FALSE;
-	RADEONInitPLL2Registers(save, &info->pll, dot_clock);
+       RADEONInitPLL2Registers(save, &info->pll, dot_clock, info->DisplayType != MT_CRT);
     } else if (info->MergedFB) {
         RADEONInitCommonRegisters(save, info);
         if (!RADEONInitCrtcRegisters(pScrn, save, 
@@ -6924,7 +7091,7 @@
             return FALSE;
         dot_clock = (((RADEONMergedDisplayModePtr)mode->Private)->CRT1)->Clock / 1000.0;
         if (dot_clock) {
-            RADEONInitPLLRegisters(save, &info->pll, dot_clock);
+            RADEONInitPLLRegisters(info, save, &info->pll, dot_clock);
         } else {
             save->ppll_ref_div = info->SavedReg.ppll_ref_div;
             save->ppll_div_3   = info->SavedReg.ppll_div_3;
@@ -6933,19 +7100,13 @@
         RADEONInitCrtc2Registers(pScrn, save, 
 			((RADEONMergedDisplayModePtr)mode->Private)->CRT2, info);
         dot_clock = (((RADEONMergedDisplayModePtr)mode->Private)->CRT2)->Clock / 1000.0;
-        RADEONInitPLL2Registers(save, &info->pll, dot_clock);
+        RADEONInitPLL2Registers(save, &info->pll, dot_clock, info->MergeType != MT_CRT);
     } else {
 	if (!RADEONInitCrtcRegisters(pScrn, save, mode, info))
 	    return FALSE;
 	dot_clock = mode->Clock/1000.0;
 	if (dot_clock) {
-            if (info->UseBiosDividers) {
-                save->ppll_ref_div = info->RefDivider;
-                save->ppll_div_3   = info->FeedbackDivider | (info->PostDivider << 16);
-                save->htotal_cntl  = 0;
-            }
-            else
-		RADEONInitPLLRegisters(save, &info->pll, dot_clock);
+           RADEONInitPLLRegisters(info, save, &info->pll, dot_clock);
 	} else {
 	    save->ppll_ref_div = info->SavedReg.ppll_ref_div;
 	    save->ppll_div_3   = info->SavedReg.ppll_div_3;
@@ -7351,7 +7512,7 @@
        }
     }
 
-    if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
+    if (info->VGAAccess && xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
 	vgaHWFreeHWRec(pScrn);
     RADEONFreeRec(pScrn);
 }
Only in xc-radeon-ppc/programs/Xserver/hw/xfree86/drivers/ati: radeon_driver.c.orig
