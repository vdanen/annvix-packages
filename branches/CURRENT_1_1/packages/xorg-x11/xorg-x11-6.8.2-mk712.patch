--- xorg-x11-6.8.2/xc/config/cf/xfree86.cf.mk712	2004-07-06 19:50:59.000000000 -0400
+++ xorg-x11-6.8.2/xc/config/cf/xfree86.cf	2005-01-09 08:33:31.337941848 -0500
@@ -199,7 +199,7 @@
 				digitaledge dmc dynapro elographics tek4957 \
 				microtouch mutouch penmount spaceorb summa \
 				wacom void magellan /* magictouch */ hyperpen \
-				jamstudio fpit \
+				jamstudio fpit mk712 \
 				palmax OSXInputDrivers ExtraXInputDrivers
 #endif
 
--- xorg-x11-6.8.2/xc/config/cf/xorg.cf.mk712	2004-12-19 10:20:22.000000000 -0500
+++ xorg-x11-6.8.2/xc/config/cf/xorg.cf	2005-01-09 08:49:24.275073384 -0500
@@ -208,7 +208,7 @@
 #ifndef XInputDrivers
 #define XInputDrivers		mouse keyboard acecad calcomp citron \
 				digitaledge dmc dynapro elographics tek4957 \
-				microtouch mutouch penmount spaceorb summa \
+				microtouch mk712 mutouch penmount spaceorb summa \
 				wacom void magellan /* magictouch */ hyperpen \
 				jamstudio fpit \
 				palmax OSXInputDrivers ExtraXInputDrivers
--- xorg-x11-6.8.2/xc/config/cf/xf86site.def.mk712	2005-01-09 08:51:52.915476608 -0500
+++ xorg-x11-6.8.2/xc/config/cf/xf86site.def	2005-01-09 08:52:11.895591192 -0500
@@ -116,7 +116,7 @@
  *
 #define XInputDrivers		mouse keyboard acecad calcomp citron \
 				digitaledge dmc dynapro elographics \
-				microtouch mutouch penmount spaceorb summa \
+				microtouch mk712 mutouch penmount spaceorb summa \
 				wacom void magictouch aiptek
  */
 
--- xorg-x11-6.8.2/xc/config/cf/xorgsite.def.mk712	2005-01-09 08:52:27.383236712 -0500
+++ xorg-x11-6.8.2/xc/config/cf/xorgsite.def	2005-01-09 08:52:45.091544640 -0500
@@ -116,7 +116,7 @@
  *
 #define XInputDrivers		mouse keyboard acecad calcomp citron \
 				digitaledge dmc dynapro elographics \
-				microtouch mutouch penmount spaceorb summa \
+				microtouch mk712 mutouch penmount spaceorb summa \
 				wacom void magictouch aiptek
  */
 
--- xorg-x11-6.8.2/xc/programs/Xserver/hw/xfree86/input/mk712/Imakefile.mk712	2005-01-09 08:33:31.338941696 -0500
+++ xorg-x11-6.8.2/xc/programs/Xserver/hw/xfree86/input/mk712/Imakefile	2005-01-09 08:33:31.338941696 -0500
@@ -0,0 +1,25 @@
+
+#define IHaveModules
+#include <Server.tmpl>
+
+SRCS = mk712.c
+OBJS = mk712.o
+
+DRIVER = mk712
+
+INCLUDES = -I. -I$(XF86COMSRC) -I$(XF86SRC)/loader -I$(XF86OSSRC) \
+			-I$(SERVERSRC)/include -I$(XINCLUDESRC) -I$(EXTINCSRC)
+
+#if MakeHasPosixVariableSubstitutions
+SubdirLibraryRule($(OBJS))
+#endif
+
+ModuleObjectRule()
+
+ObjectModuleTarget($(DRIVER),$(OBJS))
+
+InstallObjectModule($(DRIVER),$(MODULEDIR),input)
+
+DependTarget()
+
+InstallDriverSDKObjectModule($(DRIVER),$(DRIVERSDKMODULEDIR),input)
--- xorg-x11-6.8.2/xc/programs/Xserver/hw/xfree86/input/mk712/mk712.c.mk712	2005-01-09 08:33:31.339941544 -0500
+++ xorg-x11-6.8.2/xc/programs/Xserver/hw/xfree86/input/mk712/mk712.c	2005-01-09 08:33:31.338941696 -0500
@@ -0,0 +1,510 @@
+/* 
+ * Copyright (c) 2000 Transmeta Corporation
+ *
+ * Written by Patrick Mochel  <mochel@transmeta.com>
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, cpy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#define _MK712_C_
+/*****************************************************************************
+ *	Standard Headers
+ ****************************************************************************/
+
+#include <misc.h>
+#include <xf86.h>
+#define NEED_XF86_TYPES
+#include <xf86_ansic.h>
+#include <xf86_OSproc.h>
+#include <xf86Xinput.h>
+#include <xisb.h>
+#include <exevents.h>		/* Needed for InitValuator/Proximity stuff */
+#include <xf86Priv.h>
+
+#define MK712_PACKET_SIZE	16
+
+struct mk712_packet {
+	unsigned int header;
+	unsigned int x;
+	unsigned int y;
+	unsigned int reserved;
+};
+
+typedef struct _MK712PrivateRec {
+	CalibrationCtrl ctrl;   /* min/max parameters for device */
+	int axes;
+	Bool proximity;         /* is the stylus in proximity */
+	Bool button_down;	/* is the "button" currently down */
+	int reporting_mode;	/* TS_Raw or TS_Scaled */
+
+	int untouch_delay;	/* Delay before reporting an untouch (in ms) */
+	int report_delay;	/* Delay between touch report packets       */
+
+	int screen_num;		/* Screen associated with the device        */
+	int screen_width;	/* Width of the associated X screen     */
+	int screen_height;	/* Height of the screen             */
+	int fd;                 /* fd  of the device */
+	struct mk712_packet  packet;   /* touchscreen data */
+} MK712PrivateRec, *MK712PrivatePtr;
+
+/*
+ * Local copy of private data
+ */
+MK712PrivatePtr priv;
+
+
+/*
+ * Function prototypes
+ */
+static pointer
+SetupProc (pointer module,
+	   pointer options,
+	   int *errmaj,
+	   int *errmin);
+
+static void TearDownProc (pointer p);
+static Bool DeviceOff (DeviceIntPtr dev);
+static Bool DeviceOn (DeviceIntPtr dev);
+static Bool DeviceInit (DeviceIntPtr dev);
+static Bool DeviceControl (DeviceIntPtr dev, int mode);
+static void ReadInput (LocalDevicePtr dev);
+
+static Bool CalibrationControlProc (DeviceIntPtr, CalibrationCtrl*);
+
+static Bool MK712GetPacket (MK712PrivatePtr priv);
+
+static InputInfoPtr 
+Mk712PreInit (InputDriverPtr drv, IDevPtr dev, int flags);
+
+InputDriverRec MK712 = {
+	1,
+	"mk712",
+	NULL,
+	Mk712PreInit,
+	NULL,  /* Mk712PreInit */
+	NULL,
+	0
+};
+
+static XF86ModuleVersionInfo VersionRec =
+{
+	"mk712",
+	MODULEVENDORSTRING,
+	MODINFOSTRING1,
+	MODINFOSTRING2,
+	XF86_VERSION_CURRENT,
+	1, 0, 0,
+	ABI_CLASS_XINPUT,
+	ABI_XINPUT_VERSION,
+	MOD_CLASS_XINPUT,
+	{0, 0, 0, 0}		/* signature, to be patched into the file by a tool */
+};
+
+XF86ModuleData mk712ModuleData = { 
+	&VersionRec, 
+	SetupProc, 
+	TearDownProc 
+};
+
+static pointer
+SetupProc (pointer module,
+	   pointer options,
+	   int *errmaj,
+	   int *errmin)
+{
+	xf86AddInputDriver(&MK712, module, 0);
+
+	return (pointer) 1;
+}
+
+static void
+TearDownProc( pointer p )
+{
+	LocalDevicePtr local = (LocalDevicePtr) p;
+
+	DeviceOff (local->dev);
+
+	xf86RemoveLocalDevice (local);
+
+	xf86CloseSerial (local->fd);
+	xfree (priv);
+	xfree (local->name);
+	xfree (local);
+}
+
+
+static Bool
+DeviceOn (DeviceIntPtr dev)
+{
+	LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;
+
+	local->fd = xf86OpenSerial(local->options);
+
+	if (local->fd <= 0) {
+		xf86Msg (X_WARNING, "%s : cannot open device\n",local->name);
+		return !Success;
+	}
+	priv->fd = local->fd;
+
+	xf86FlushInput(local->fd);
+
+	xf86AddEnabledDevice (local);
+
+	dev->public.on = TRUE;
+	return (Success);
+}
+
+static Bool
+DeviceOff (DeviceIntPtr dev)
+{
+	LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;
+
+	if (local->fd > 0) {
+		xf86RemoveEnabledDevice (local);
+		xf86CloseSerial(local->fd);
+		priv->fd = local->fd = -1;
+	}
+
+	dev->public.on = FALSE;
+
+	return (Success);
+}
+
+static void
+PtrControlProc (DeviceIntPtr device, PtrCtrl *ctrl)
+{
+}
+
+static Bool
+DeviceInit (DeviceIntPtr dev)
+{
+	LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;
+	unsigned char map[] =
+	{0, 1};
+
+	priv->screen_width = screenInfo.screens[priv->screen_num]->width;
+	priv->screen_height = screenInfo.screens[priv->screen_num]->height;
+
+	/* 
+	 * - Device reports button press for 1 button
+	 * - Reports motion on 2 axes in absolute coords
+	 *
+	 * This call makes calls to InitButtonClassDeviceStruct,
+	 *   InitPtrFeedbackClassDeviceStruct, and InitValuatorDeviceStruct
+	 */
+	if (InitPointerDeviceStruct(&dev->public, map, 1, xf86GetMotionEvents,
+				    PtrControlProc, local->history_size) == FALSE)
+	{
+		ErrorF ("Unable to intialize pointer device struct\n");
+		return !Success;
+	}
+
+	xf86InitValuatorAxisStruct (dev, 
+				0,              /* axis */
+				priv->ctrl.min_x,    /* min val */ 
+				priv->ctrl.max_x,    /* max val */
+				4096,           /* resolution */
+				0               /* min_res */ ,
+				4096            /* max_res */ 
+		);
+	xf86InitValuatorAxisStruct (dev, 
+				1, 
+				priv->ctrl.min_y, 
+				priv->ctrl.max_y,
+				4096,            /* resolution */
+				0                /* min_res */ ,
+				4096             /* max_res */ 
+		);
+
+	if (InitProximityClassDeviceStruct (dev) == FALSE) {
+		ErrorF ("unable to allocate MK712 ProximityClassDeviceStruct\n");
+		return !Success;
+	}
+
+	if (InitCalibrationDeviceStruct(&dev->public, priv->ctrl.button, 
+					CalibrationControlProc, &priv->ctrl) == FALSE) {
+		ErrorF("Unable to initialize Calibration Control Struct\n");
+		return !Success;
+	}
+
+	/*
+	 * can we force this?
+	 */
+	xf86XInputSetSendCoreEvents(local,TRUE);
+
+	/* 
+	 * Allocate the motion events buffer.
+	 */
+	xf86MotionHistoryAllocate (local);
+
+	return (Success);
+}
+
+static Bool
+DeviceControl (DeviceIntPtr dev, int mode)
+{
+	Bool	RetValue;
+
+	switch (mode)
+	{
+	case DEVICE_INIT:
+		RetValue = DeviceInit (dev);
+		break;
+	case DEVICE_ON:
+		RetValue = DeviceOn( dev );
+		break;
+	case DEVICE_OFF:
+	case DEVICE_CLOSE:
+		RetValue = DeviceOff( dev );
+		break;
+	default:
+		RetValue = !Success;
+	}
+
+	return RetValue;
+}
+
+static void
+ReadInput (LocalDevicePtr local)
+{
+	int x, y;
+	int type;
+
+	while (MK712GetPacket(priv) == Success) {
+		if (priv->packet.header == 1) {
+			x = local->old_x;
+			y = local->old_y;
+
+			xf86XInputSetScreen(local, priv->screen_num, x, y);
+
+			xf86PostMotionEvent(local->dev, TRUE, 0, 2, x, y);
+
+			if (priv->button_down == TRUE) {
+				priv->button_down =  FALSE;
+
+				xf86PostButtonEvent(local->dev, TRUE, priv->ctrl.button,
+						    0, 0, 2, x, y);
+			}
+
+			if (priv->proximity == TRUE) {
+				priv->proximity = FALSE;
+				xf86PostProximityEvent(local->dev, 0, 0, 2,
+						       x, y);
+			}
+			continue;
+		}
+		/*
+		 * Otherwise, we have a valid packet, so we scale 
+		 * and process it.
+		 */
+		type = priv->packet.header;
+
+		x = priv->packet.x;
+		y = priv->packet.y;
+
+		if (priv->reporting_mode == TS_Scaled) {
+
+		x = xf86ScaleAxis (x, 0, priv->screen_width, 
+					   priv->ctrl.min_x, priv->ctrl.max_x);
+			y = xf86ScaleAxis (y, 0, priv->screen_height, 
+					   priv->ctrl.min_y, priv->ctrl.max_y);
+		}
+		xf86XInputSetScreen(local, priv->screen_num, x, y);
+
+		if (priv->proximity == FALSE) {
+			priv->proximity = TRUE;
+			xf86PostProximityEvent(local->dev, 1, 0, 2, x, y);
+		}
+
+		/*
+		 * Send Events
+		 *
+		 * Some other touchscreen driver says they must always post
+		 *  a motion event, so we'll go ahead and do that just in case.
+		 */
+
+		xf86PostMotionEvent(local->dev, TRUE, 0, 2, x, y);
+		/* 
+		 * Emit a button press or release
+		 */
+		if (priv->button_down == FALSE) { 
+			xf86PostButtonEvent(local->dev, TRUE, priv->ctrl.button, 
+					    1, 0, 2, x, y);
+			priv->button_down = TRUE;
+		}
+	}
+}
+
+static Bool
+CalibrationControlProc (DeviceIntPtr dev, CalibrationCtrl *in)
+{
+
+	priv->ctrl.min_x = in->min_x;
+	priv->ctrl.max_x = in->max_x;
+
+	priv->ctrl.min_y = in->min_y;
+	priv->ctrl.max_y = in->max_y;
+
+	priv->ctrl.button = in->button;
+	priv->ctrl.button_threshold = in->button_threshold;
+
+	return TRUE;
+}
+
+static int
+ControlProc (LocalDevicePtr local, xDeviceCtl * control)
+{
+	xDeviceTSCalibrationCtl *c = (xDeviceTSCalibrationCtl*) control;
+
+	priv->ctrl.min_x = c->min_x;
+	priv->ctrl.max_x = c->max_x;
+	priv->ctrl.min_y = c->min_y;
+	priv->ctrl.max_y = c->max_y;
+
+	return (Success);
+}
+
+static void
+CloseProc (LocalDevicePtr local)
+{
+}
+
+static int
+SwitchMode (ClientPtr client, DeviceIntPtr dev, int mode)
+{
+	LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;
+
+	switch (mode) {
+	case TS_Raw:
+	case TS_Scaled:
+		priv->reporting_mode = mode;
+		return Success;
+	case SendCoreEvents:
+	case DontSendCoreEvents:
+		xf86XInputSetSendCoreEvents(local,(mode == SendCoreEvents));
+		return Success;
+	}
+
+	return !Success;
+}
+
+static Bool
+ConvertProc (LocalDevicePtr local,
+	     int first, int num,
+	     int v0, int v1, 
+	     int v2, int v3,
+	     int v4, int v5,
+	     int *x, int *y)
+{
+	if (priv->reporting_mode == TS_Raw) {
+		*x = v0;
+		*y = v1;
+		*x = xf86ScaleAxis (v0, 0, priv->screen_width, 
+			priv->ctrl.min_x, priv->ctrl.max_x);
+		*y = xf86ScaleAxis (v1, 0, priv->screen_height, 
+				    priv->ctrl.min_y, priv->ctrl.max_y);
+	} else {
+		*x = v0;
+		*y = v1;
+	}
+
+	return TRUE;
+}
+
+static InputInfoPtr 
+Mk712PreInit (InputDriverPtr drv, IDevPtr dev, int flags)
+{
+	InputInfoPtr local = xf86AllocateInput (drv,0);
+	char *s;
+
+	priv = (MK712PrivatePtr)xcalloc(1,sizeof(MK712PrivateRec));
+
+	if ((!local) || (!priv))
+		return NULL;
+
+	local->type_name = XI_TOUCHSCREEN;
+	local->device_control = DeviceControl;
+	local->read_input = ReadInput;
+	local->control_proc = ControlProc;
+	local->close_proc = CloseProc;
+	local->switch_mode = SwitchMode;
+	local->conversion_proc = ConvertProc;
+	local->dev = NULL;
+	local->private = priv;
+	local->private_flags = 0;
+	local->flags = XI86_POINTER_CAPABLE | XI86_SEND_DRAG_EVENTS;
+	local->conf_idev = dev;
+	local->always_core_feedback = 0;
+
+	xf86CollectInputOptions(local,NULL,NULL);
+
+	xf86OptionListReport(local->options);
+
+	local->fd = xf86OpenSerial(local->options);
+
+	if(local->fd == -1) {
+		ErrorF("Mk712 driver unable to open device\n");
+		xfree(local);
+		return NULL;
+	}
+
+	/* this results in an xstrdup that must be freed later */
+	local->name = xf86SetStrOption( local->options, "DeviceName",
+					"mk712");
+	local->history_size = xf86SetIntOption( local->options, "HistorySize", 100 );
+
+	priv->ctrl.min_x = xf86SetIntOption(local->options, "MinX", 0);
+	priv->ctrl.max_x = xf86SetIntOption(local->options, "MaxX", 4096);
+	priv->ctrl.min_y = xf86SetIntOption(local->options, "MinY", 0);
+	priv->ctrl.max_y = xf86SetIntOption(local->options, "MaxY", 4096);
+	priv->ctrl.button = xf86SetIntOption(local->options, "ButtonNumber", 1);
+	priv->ctrl.button_threshold = xf86SetIntOption(local->options, "ButtonThreshold", 0);
+
+	priv->screen_num = xf86SetIntOption(local->options, "ScreenNumber", 0);
+
+	s = xf86FindOptionValue(local->options, "ReportingMode");
+	if (s && (xf86NameCmp(s, "raw") == 0)) 
+		priv->reporting_mode = TS_Raw;
+	else
+		priv->reporting_mode = TS_Scaled;
+	
+	priv->proximity = FALSE;
+	priv->button_down = FALSE;
+
+	local->flags |= XI86_CONFIGURED;
+
+	xf86RemoveEnabledDevice(local);
+	xf86CloseSerial(local->fd);
+	priv->fd = local->fd = -1;
+
+	return (local);
+}
+
+static Bool
+MK712GetPacket (MK712PrivatePtr priv)
+{
+	int count = 0;
+
+	do {
+		count = read(priv->fd,&priv->packet,MK712_PACKET_SIZE);
+	} while ((count < 0) && (errno == EINTR));
+
+	return (count >= 0) ? Success : !Success;
+}
