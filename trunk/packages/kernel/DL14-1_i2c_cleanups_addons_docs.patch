--- linux-2.4.21/include/linux/i2c-algo-biths.h.dl14.orig	2003-08-24 01:18:22.000000000 +0200
+++ linux-2.4.21/include/linux/i2c-algo-biths.h	2003-08-24 01:18:22.000000000 +0200
@@ -0,0 +1,89 @@
+/* ------------------------------------------------------------------------- */
+/* i2c-algo-biths.h i2c driver algorithms for faster bit-shift adapters      */
+/* ------------------------------------------------------------------------- */
+/*   Copyright (C) 1995-99 Simon G. Vogl
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
+/* ------------------------------------------------------------------------- */
+
+/* With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi> and even
+   Frodo Looijaard <frodol@dds.nl> */
+
+/* $Id: i2c-algo-biths.h,v 1.6.2.1 2003/01/21 10:00:19 kmalkki Exp $ */
+
+#ifndef _LINUX_I2C_ALGO_BITHS_H
+#define _LINUX_I2C_ALGO_BITHS_H
+
+#if 1
+#define _HS_ATTR_
+#else
+#define _HS_ATTR_ __attribute__ ((regparm (2)))
+#endif
+
+#ifdef _HW_NO_INLINE_
+#define _HW_ATTR_ __attribute__ ((regparm (2)))
+#else
+#define _HW_ATTR_ inline 
+#endif
+
+/* --- Defines for bit-adapters ---------------------------------------	*/
+/*
+ * This struct contains the hw-dependent functions of bit-style adapters to 
+ * manipulate the line states, and to init any hw-specific features. This is
+ * only used if you have more than one hw-type of adapter running. 
+ */
+struct i2c_algo_biths_data {
+	void *hw_data;		/* private data for lowlevel routines */
+	int hw_state;
+	void (*setscl)(void *hw_data, int hw_state) _HS_ATTR_ ;
+	void (*setsda)(void *hw_data, int hw_state) _HS_ATTR_ ;
+	int (*getscl) (void *hw_data) _HS_ATTR_ ;
+	int (*getsda) (void *hw_data) _HS_ATTR_ ;
+
+	void (*setstate)(struct i2c_algo_biths_data *adap) _HS_ATTR_ ;
+	void (*set_timer)(struct i2c_algo_biths_data *adap) _HS_ATTR_ ;
+	void (*run_timer)(struct i2c_algo_biths_data *adap) _HS_ATTR_ ;
+
+	short ctrl;
+	short errors;
+	char shiftreg;
+
+	/* local settings */
+	unsigned long bclock;
+	unsigned long xloops;	/* 1/4 clock-cycle time in x86 TSC ticks */
+				/* i.e. bus clock is 250*0x10c6 / xloops kHz */
+
+	int timeout;		/* in jiffies */
+	char *name;		/* replicate i2c_adapter->name */
+	char *dstr;		/* protocol debug string */
+};
+
+#define I2C_BIT_ADAP_MAX	16
+
+#define _HS_SCL		0x0001
+#define _HS_SDA		0x0002
+#define _HS_SDA_FREE	0x0004	/* client has SDA control */
+#define _HS_STD_MODE	0x0008  /* drop speed to 100kHz */
+#define _HS_DBL_DT	0x0010	/* T_sclhi is twice longer */
+
+#define _HS_NAK		0x0001
+#define _HS_TIMEOUT	0x0002
+#define _HS_SDA_ARB	0x0004
+#define _HS_HW_FAIL	0x0008
+
+int i2c_biths_add_bus(struct i2c_adapter *);
+int i2c_biths_del_bus(struct i2c_adapter *);
+
+#endif /* _LINUX_I2C_ALGO_BITHS_H */
--- linux-2.4.21/drivers/i2c/Config.in.dl14.orig	2003-08-24 01:18:21.000000000 +0200
+++ linux-2.4.21/drivers/i2c/Config.in	2003-08-24 01:18:22.000000000 +0200
@@ -9,7 +9,10 @@ tristate 'I2C support' CONFIG_I2C
 if [ "$CONFIG_I2C" != "n" ]; then
 
    dep_tristate 'I2C bit-banging interfaces'  CONFIG_I2C_ALGOBIT $CONFIG_I2C
-   if [ "$CONFIG_I2C_ALGOBIT" != "n" ]; then
+   if [ "$CONFIG_I2C_ALGOBIT" = "n" ]; then
+      dep_tristate 'I2C bit-banging interfaces (hs alternative)'  CONFIG_I2C_ALGOBITHS $CONFIG_I2C
+   fi
+   if [ "$CONFIG_I2C_ALGOBIT" != "n" -o "$CONFIG_I2C_ALGOBITHS" != "n" ]; then
       dep_tristate '  Philips style parallel port adapter' CONFIG_I2C_PHILIPSPAR $CONFIG_I2C_ALGOBIT $CONFIG_PARPORT
       dep_tristate '  ELV adapter' CONFIG_I2C_ELV $CONFIG_I2C_ALGOBIT
       dep_tristate '  Velleman K9000 adapter' CONFIG_I2C_VELLEMAN $CONFIG_I2C_ALGOBIT
--- linux-2.4.21/drivers/i2c/i2c-algo-biths.c.dl14.orig	2003-08-24 01:18:22.000000000 +0200
+++ linux-2.4.21/drivers/i2c/i2c-algo-biths.c	2003-08-24 01:18:22.000000000 +0200
@@ -0,0 +1,777 @@
+/* ------------------------------------------------------------------------- */
+/* i2c-algo-biths.c i2c driver algorithms for bit-shift adapters	     */
+/* ------------------------------------------------------------------------- */
+/*   Copyright (C) 1995-2000 Simon G. Vogl
+     Copyright (C) 2002-2003 Kyösti Mälkki
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
+/* ------------------------------------------------------------------------- */
+
+/* $Id: i2c-algo-biths.c,v 1.8.2.3 2003/06/07 21:10:06 mds Exp $ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-biths.h>
+
+/* ----- global defines ----------------------------------------------- */
+
+/* If non-zero, adapter code written for original i2c-algo-bit can be used unmodified. 
+ * As this export same symbols, you should either remove i2c-algo-bit.o from depmod
+ * directories, or load this module manually.
+ */
+#ifndef ALGO_BIT_COMPATIBILITY
+#define ALGO_BIT_COMPATIBILITY 0
+#endif
+
+#define FATAL_BUS	0
+#define MODULE_STATUS	1
+#define FATAL_MSG	2
+#define FATAL_PROTOCOL	3
+#define ALL_MSG		4
+#define ALL_PROTOCOL	5
+#define BIT_LEVEL	9
+
+#define DEB1(x)		if (i2c_debug>=MODULE_STATUS) (x);
+static void proto_s(char *d, const char *s) { strcat(d, s); }
+static void proto_x(char *d, const char *x, unsigned char y) { while (*d) d++; sprintf(d, x, y); }
+#define PROTO_S(x)	if (adap->dstr) proto_s(adap->dstr, x)
+#define PROTO_B(x)	if ((adap->dstr) && (i2c_debug>=BIT_LEVEL)) proto_s(adap->dstr, x)
+#define PROTO_X(x,y)	if (adap->dstr) proto_x(adap->dstr, x, y)
+
+#define PROTO_MAX_DUMP 1024  // 50 x ".oooooooo [xx] .i[xx]"
+
+/* ----- global variables ---------------------------------------------	*/
+
+/* module parameters:
+ */
+static int i2c_debug; 
+static int bit_test;	/* see if the line-setting functions work	*/
+
+/* Bus timing for 50/50 duty cycle :  T_setup + T_hold = T_scllo = T_sclhi */
+/* Run setscl/setsda with a special flag */
+#define T_min   0		/* after any SCL SDA change	*/
+#define T_sclhi _HS_DBL_DT	/* SCL high			*/
+#define T_scllo	_HS_DBL_DT	/* SCL low 			*/
+#define T_setup 0		/* SDA change to SCL rise	*/
+#define T_hold  0		/* SCL fall to SDA change	*/
+
+#define _sf(a)		adap->ctrl|=(a)
+#define _cf(a)		adap->ctrl&=~(a)
+#define ___setscl(b)	if (b) _sf(_HS_SCL); else _cf(_HS_SCL); i2c_setscl(adap)
+#define ___setsda(b)	if (b) _sf(_HS_SDA); else _cf(_HS_SDA); i2c_setsda(adap)
+
+#define __setdt(x,dt)	if (dt) _sf(dt); x; if (dt) _cf(dt)
+#define __setscl(b,dt)	__setdt(___setscl(b),dt)
+#define __setsda(b,dt)	__setdt(___setsda(b),dt)
+#define __getscl()	i2c_getscl(adap)
+#define __getsda()	i2c_getsda(adap)
+
+#define RETURN_ON_FAILURE(x)		x; if (adap->errors) return
+#define TRY(x) RETURN_ON_FAILURE(x)
+
+#define _setscl(b,dt)	RETURN_ON_FAILURE(__setscl(b,dt))
+#define _setsda(b,dt)	RETURN_ON_FAILURE(__setsda(b,dt))
+#define _getscl		__getscl
+#define _getsda		__getsda
+
+#define _sclhi(dt)	_setscl(1,dt)
+#define _scllo(dt)	_setscl(0,dt)
+#define _sdahi(dt)	_setsda(1,dt)
+#define _sdalo(dt)	_setsda(0,dt)
+
+/* --- setting states on the bus with the right timing: ---------------	*/
+
+static int i2c_sda_set(struct i2c_algo_biths_data *adap, int rdcount)
+{
+	int sda;
+	/* allow some rise/fall time */
+	while ( rdcount-- ) {
+		sda = adap->getsda(adap->hw_data);
+		if (adap->ctrl & _HS_SDA) {
+			if (sda)
+				return 0;
+			if (!rdcount) {
+				adap->errors |= _HS_SDA_ARB;
+				return -1;
+			}
+		} else { /* !(adap->ctrl & _HS_SDA) */
+			if (!sda)
+				return 0;
+			if (!rdcount) {
+				adap->errors |= _HS_HW_FAIL;
+				return -1;
+			}
+		}
+	}
+	return 0;
+}
+
+static void i2c_setsda(struct i2c_algo_biths_data *adap)
+{
+	adap->setstate(adap); 
+	adap->setsda(adap->hw_data, adap->hw_state);
+	if ( !(adap->ctrl & _HS_SDA_FREE) && ! i2c_sda_set(adap, 10)) {
+		return;
+	}
+	adap->set_timer(adap);
+	adap->run_timer(adap);
+}
+
+static int i2c_getscl(struct i2c_algo_biths_data *adap)
+{
+	return adap->getscl(adap->hw_data);
+}
+
+static int i2c_getsda(struct i2c_algo_biths_data *adap)
+{
+	return adap->getsda(adap->hw_data);
+}
+/*
+ * Raise scl line, and do check for delays. This is necessary for slower
+ * devices.
+ */
+
+static void i2c_setscl(struct i2c_algo_biths_data *adap)
+{
+#ifndef HW_CANNOT_READ_SCL /* Not all adapters have scl sense line... */
+	int rdcount = 10;
+	adap->setstate(adap);
+	adap->setscl(adap->hw_data, adap->hw_state);
+	if (adap->ctrl & _HS_SCL) {
+		unsigned long start;
+		/* allow some rise time */
+		while (rdcount && !adap->getscl(adap->hw_data)) rdcount--;
+		/* else clock synchronisation, give more time */
+		start = jiffies;
+		while (!rdcount && !adap->getscl(adap->hw_data)) {
+			if ( time_after(jiffies, start+adap->timeout) ) {
+				adap->errors |= _HS_TIMEOUT; /* scl undef */
+				return;
+			}
+#ifdef cond_resched
+			cond_resched();
+#else
+			if (current->need_resched) {
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				schedule_timeout(1);
+			}
+#endif
+		}
+		adap->set_timer(adap);
+		/* test for SDA arbitration when SCL is high */
+		if ( !(adap->ctrl & _HS_SDA_FREE) && ! i2c_sda_set(adap, 1)) {
+			return;
+		}
+	} else {
+		/* allow some fall time */
+		while (rdcount && adap->getscl(adap->hw_data)) rdcount--;
+		if ( !rdcount ) {
+			adap->errors |= _HS_HW_FAIL;
+			return;
+		}
+		adap->set_timer(adap);
+	}
+#else
+	adap->setstate(adap);
+	adap->setscl(adap->hw_data, adap->hw_state);
+	adap->set_timer(adap);
+#endif /* HW_CANNOT_READ_SCL */
+	adap->run_timer(adap);
+}
+
+
+/* start, repstart */
+static void i2c_start(struct i2c_algo_biths_data *adap)
+{
+	PROTO_S("S");
+	/* assert: scl, sda undef */
+	adap->errors = 0;
+	_sdahi(T_setup);
+	_sclhi(T_min);
+	_sdalo(T_min);
+	_scllo(T_hold);
+	/* assert: scl, sda low */
+}
+
+static void i2c_stop(struct i2c_algo_biths_data *adap)
+{
+	PROTO_S(" P");
+	/* scl undef after error, sda, scl freedom unknown */
+	adap->ctrl &= ~(_HS_SDA_FREE | _HS_DBL_DT);
+	if (adap->errors) {
+		adap->errors = 0;
+		_scllo(T_hold);
+	}
+	/* assert: scl low, sda undef */
+	_sdalo(T_setup);
+	_sclhi(T_min);
+	_sdahi(T_min);
+	/* assert: scl, sda high */
+}
+
+
+static void i2c_outbits(struct i2c_algo_biths_data *adap, int i) 
+{
+	/* assert: scl is low */
+	PROTO_B(".");
+	while  (i--) {
+		PROTO_B("o");
+		_setsda(adap->shiftreg & 0x80, T_setup);
+		_sclhi(T_sclhi);
+		_scllo(T_hold);
+		adap->shiftreg<<=1;
+	}
+	/* assert: scl is low */
+}
+
+static void i2c_inbits(struct i2c_algo_biths_data *adap, int i)
+{
+	/* assert: scl is low, sda undef */
+	adap->ctrl |= _HS_SDA_FREE;
+	PROTO_B(".");
+	while  (i--) {
+		PROTO_B("i");
+		_sdahi(T_setup); 
+		_sclhi(T_sclhi);	
+		adap->shiftreg<<=1;
+		if (_getsda())
+			adap->shiftreg |= 0x01;
+		_scllo(T_hold);
+	}
+	adap->ctrl &= ~_HS_SDA_FREE;
+	/* assert: scl is low */
+}
+
+static void i2c_outb(struct i2c_algo_biths_data *adap, unsigned short flags,
+		     char *buf, int *count) 
+{
+	while (*count) {
+		adap->shiftreg = *buf;
+		TRY(i2c_outbits(adap, 8));
+		PROTO_X(" %02X ", *buf);
+		buf++;
+	    
+		/* read ack: SDA should be pulled down by slave */
+		TRY(i2c_inbits(adap, 1));
+	    
+		if (! (adap->shiftreg & 0x01)) { 
+			PROTO_S("[A]");
+		} else if (flags & I2C_M_IGNORE_NAK) {
+			PROTO_S("[NA]");
+		} else {
+			PROTO_S("[NA]");
+			adap->errors |= _HS_NAK;
+		}
+		if (adap->errors) return;
+		(*count)--;
+	}
+}
+
+static void i2c_inb(struct i2c_algo_biths_data *adap, unsigned short flags,
+		    char *buf, int *count) 
+{
+	while (*count) {
+		TRY(i2c_inbits(adap, 8));
+		*buf = adap->shiftreg;
+		PROTO_X(" [%02X] ", *buf);
+		buf++;
+	    
+		if (! (flags & I2C_M_NO_RD_ACK)) {
+			if (*count == 1) /* was last */
+				adap->shiftreg = 0x80;
+			else
+				adap->shiftreg = 0x00;
+			TRY(i2c_outbits(adap,1));
+
+			if (*count == 1) {
+				PROTO_S("NA");
+			} else {
+				PROTO_S("A");
+			}
+		}
+		(*count)--;
+	}
+}
+
+
+static void debug_protocol(struct i2c_algo_biths_data *adap, int retval)
+{
+	if (! adap->dstr) return;
+
+	if ( ((retval<0) && (i2c_debug>=FATAL_PROTOCOL)) || 
+	     (i2c_debug>=ALL_PROTOCOL) ) {
+		printk(KERN_DEBUG "i2c-algo-biths.o: %s: %s\n", adap->name, adap->dstr); 
+	}
+	*adap->dstr = 0;
+}
+
+static const char * i2c_strerr(int retval)
+{ 
+	switch (retval) {
+	    case 2:
+		    return "ack";
+		
+	    case 1:
+		    return "no ack (ignored)";
+
+	    case 0:
+		    return "not reached";
+
+	    case -EREMOTEIO:
+		    return "no ack";
+
+	    case -ETIMEDOUT:
+		    return "SCL rise timeout";
+	 
+	    case -ECOMM:
+		    return "SDA arbitration";
+
+	    case -ENODEV:
+		    return "SCL/SDA failure";
+
+	    default:
+		    return "unknown";
+	}
+}
+
+static int errflag(int flags)
+{
+	if (! flags)
+		return 2;
+	if (flags & _HS_HW_FAIL)
+		return -ENODEV;
+	if (flags & _HS_SDA_ARB)
+		return -ECOMM;
+	if (flags & _HS_TIMEOUT)
+		return -ETIMEDOUT;
+	if (flags & _HS_NAK)
+		return -EREMOTEIO;
+
+	return -1;
+}
+
+static void debug_printout(struct i2c_adapter *i2c_adap, int num, int retval)
+{ 
+	if ( ((retval<0) && (i2c_debug>=FATAL_MSG)) ||
+	     (i2c_debug>=ALL_MSG) ) {
+		printk(KERN_ERR "i2c-algo-biths.o: %s: msg #%d %s\n", i2c_adap->name, num, i2c_strerr(retval));
+	}
+}
+
+/*
+ * Sanity check for the adapter hardware
+ */
+static int test_bus(struct i2c_algo_biths_data *adap)
+{
+
+	int sscl, ssda, gscl, gsda, i=0;
+	int errors;
+	int test[][2] = {{1,1}, {0,1}, {1,1}, {1,0}, {1,1}, {-1,-1}}; // SDA, SCL pair
+
+	printk(KERN_INFO "i2c-algo-biths.o: %s bus test\n", adap->name);
+
+	while ( test[i][0]!=-1 ) {
+		ssda = test[i][0];
+		sscl = test[i][1];
+
+		adap->errors = 0;
+		__setsda(ssda, T_min);
+		gsda = __getsda() ? 1 : 0;
+		errors = adap->errors & (_HS_HW_FAIL | _HS_SDA_ARB);
+		if (errors)
+			printk(KERN_WARNING "i2c-algo-biths.o: %s %s\n", adap->name,
+			       i2c_strerr(errflag(errors)));
+	    
+		__setscl(sscl, T_min);
+		gscl = __getscl() ? 1 : 0;
+		errors = adap->errors & (_HS_HW_FAIL | _HS_TIMEOUT);
+		if (errors)
+			printk(KERN_WARNING "i2c-algo-biths.o: %s %s\n", adap->name,
+			       i2c_strerr(errflag(errors)));
+
+		printk(KERN_DEBUG "i2c-algo-biths.o: %s SCL: %d  SDA: %d\n", adap->name, gscl, gsda);
+		if ( sscl!=gscl )
+			printk(KERN_WARNING "i2c-algo-biths.o: %s SCL set %d, got %d!\n", adap->name, sscl, gscl);
+		if ( ssda!=gsda )
+			printk(KERN_WARNING "i2c-algo-biths.o: %s SDA set %d, got %d!\n", adap->name, ssda, gsda);
+		if ( (adap->errors) || sscl!=gscl || ssda!=gsda )
+			break;
+		i++;
+	}
+    
+	__setsda(1,0);
+	__setscl(1,0);
+	adap->errors = 0;
+
+	if (test[i][0]==-1) {
+		printk(KERN_INFO "i2c-algo-biths.o: %s passed bus test.\n",adap->name);
+		return 0;
+	} else {
+		printk(KERN_INFO "i2c-algo-biths.o: %s failed bus test.\n",adap->name);
+		return -ENODEV;
+	}
+}
+
+
+/* doAddress transmits the address in the necessary format to handle
+ * reads, writes as well as 10bit-addresses.
+ */
+
+static void doAddress(struct i2c_algo_biths_data *adap, struct i2c_msg *msg) 
+{
+	unsigned char addr[2];
+	int count;
+
+	if ( msg->flags & I2C_M_TEN ) { 
+		/* a ten bit address */
+		count = 2;
+		addr[0] = 0xf0 | (( msg->addr >> 7) & 0x03);
+		addr[1] = msg->addr & 0x7f;
+
+		/* try extended address code ... and the remaining 8 bit address */
+		TRY(i2c_outb(adap, msg->flags, addr, &count));
+
+		if ( msg->flags & I2C_M_RD ) {
+			TRY(i2c_start(adap));
+			
+			/* okay, now switch into reading mode */
+			count = 1;
+			addr[0] |= 0x01;
+			TRY(i2c_outb(adap, msg->flags, addr, &count));
+		}
+	} else {		/* normal 7bit address	*/
+		count = 1;
+		addr[0] = ( msg->addr << 1 );
+		if (msg->flags & I2C_M_RD )
+			addr[0] |= 1;
+		if (msg->flags & I2C_M_REV_DIR_ADDR )
+			addr[0] ^= 1;
+		TRY(i2c_outb(adap, msg->flags, addr, &count));
+	}
+}
+
+/*
+ * return values:
+ * 1 ACK
+ * 0 IGNORED client NAK
+ * -EREMOTEIO  client NAK
+ * -ETIMEDOUT  from sclhi()
+ */
+
+
+static int bit_xfer(struct i2c_adapter *i2c_adap,
+		    struct i2c_msg msgs[], int num)
+{
+	struct i2c_msg *msg = msgs;
+	struct i2c_algo_biths_data *adap = i2c_adap->algo_data;
+	int mn, j, state;
+	enum { MSG_INIT, MSG_START, MSG_ADDRESS, MSG_DATA, MSG_READY, MSG_STOP, MSG_EXIT };
+
+	state = MSG_INIT;
+	mn=0;
+
+	adap->dstr=NULL;
+	if (i2c_debug>=FATAL_PROTOCOL) {
+		adap->dstr = kmalloc(PROTO_MAX_DUMP, GFP_KERNEL);
+		if (adap->dstr) {
+			*adap->dstr = 0;
+		} else {
+			printk(KERN_DEBUG "i2c-algo-biths.o %s: missing protocol dump (-ENOMEM)\n", adap->name);
+		}
+	}
+
+	for (j=0; j<num; j++) msgs[j].err = 0; // unprocessed
+
+	do switch (state) {
+	    
+	    case MSG_INIT:
+		    msg = &msgs[mn];
+		    if ((msg->flags & I2C_M_NOSTART) && (mn)) {
+			    state = MSG_DATA;
+			    break;
+		    }
+
+	    case MSG_START:	
+		    i2c_start(adap);
+		    if (adap->errors) {
+			    state = MSG_STOP;	
+			    break;
+		    }	
+		    
+	    case MSG_ADDRESS:
+		    doAddress(adap, msg);
+		    if (adap->errors) {
+			    state = MSG_STOP;
+			    break;
+		    }
+
+	    case MSG_DATA:
+		    j = msg->len;
+		    if ( msg->flags & I2C_M_RD ) {
+			    i2c_inb(adap, msg->flags, msg->buf, &j);
+		    } else {
+			    i2c_outb(adap, msg->flags, msg->buf, &j);
+		    }
+		    msg->done = msg->len - j;
+		    if (adap->errors) {
+			    state = MSG_STOP;
+			    break;
+		    }
+	
+	    case MSG_READY:
+		    mn++;
+		    if (mn<num) {
+			    msg->err = errflag(adap->errors);
+			    debug_protocol(adap, msg->err);
+			    state = MSG_INIT;
+			    break;
+		    }
+
+	    case MSG_STOP:
+		    msg->err = errflag(adap->errors);
+		    i2c_stop(adap);
+		    j = 0;
+		    while (adap->errors) {
+			    if ( ++j > 10) {
+				    msg->err = -ENODEV;
+				    break;
+			    }
+			    i2c_stop(adap);
+		    }
+		    debug_protocol(adap, msg->err);
+		    state = MSG_EXIT;
+		    break;
+
+	    default: /* not reached */
+		    state = MSG_EXIT;
+		    msg->err = -EINVAL;
+		    break;
+		    		  
+	} while (state != MSG_EXIT);
+	
+	if (adap->dstr) kfree(adap->dstr);
+
+	for (j=0; j<num; j++)
+		debug_printout(i2c_adap, j, msgs[j].err);
+
+	return (msg->err < 0) ? msg->err : mn;
+}
+
+static u32 bit_func(struct i2c_adapter *i2c_adap)
+{
+	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR | 
+		I2C_FUNC_PROTOCOL_MANGLING;
+}
+
+
+/* -----exported algorithm data: -------------------------------------	*/
+
+static struct i2c_algorithm i2c_algo_biths = {
+	.owner		= THIS_MODULE,
+	.name		= "Bit-shift algorithm",
+	.id		= I2C_ALGO_BIT,
+	.master_xfer	= bit_xfer,
+	.functionality	= bit_func,
+};
+
+
+#if ALGO_BIT_COMPATIBILITY 
+#include <linux/i2c-algo-bit.h>
+
+static _HS_ATTR_ void _old_setscl(void *hw_data, int hw_state)
+{
+	struct i2c_algo_bit_data *old = hw_data;
+	old->setscl(old->data, hw_state & _HS_SCL);
+}
+static _HS_ATTR_ void _old_setsda(void *hw_data, int hw_state)
+{
+	struct i2c_algo_bit_data *old = hw_data;
+	old->setsda(old->data, hw_state & _HS_SDA);
+}
+static _HS_ATTR_ int _old_getscl(void *hw_data)
+{
+	struct i2c_algo_bit_data *old = hw_data;
+	return old->getscl(old->data);
+}
+static _HS_ATTR_ int _old_getsda(void *hw_data)
+{
+	struct i2c_algo_bit_data *old = hw_data;
+	return old->getsda(old->data);
+}
+
+static _HS_ATTR_ void _old_setstate(struct i2c_algo_biths_data *adap)
+{
+	adap->hw_state = adap->ctrl;
+}
+
+static struct i2c_algo_biths_data _old_template = {
+	.setstate	= _old_setstate,
+	.setsda		= _old_setsda,
+	.setscl		= _old_setscl,
+	.getsda		= _old_getsda,
+	.getscl		= _old_getscl,
+};
+
+/* 
+ * registering functions to load algorithms at runtime 
+ */
+int i2c_bit_add_bus(struct i2c_adapter *i2c_adap)
+{
+	int i;
+ 	struct i2c_algo_bit_data *old_adap = i2c_adap->algo_data;
+	struct i2c_algo_biths_data *adap;
+
+	adap = kmalloc(sizeof(struct i2c_algo_biths_data), GFP_KERNEL);
+	if (adap==NULL)
+		return -ENOMEM;
+
+	memcpy(adap, &_old_template, sizeof(struct i2c_algo_biths_data));
+	adap->hw_data = old_adap;
+	adap->xloops = old_adap->udelay * 0x0863; /* 1/4 vs 1/2 cycle, 0x10c6 / 2 */
+	adap->timeout = old_adap->timeout;
+	i2c_adap->algo_data = adap;
+
+	return i2c_biths_add_bus(i2c_adap);
+}
+
+
+int i2c_bit_del_bus(struct i2c_adapter *i2c_adap)
+{
+	int res;
+
+	if ((res = i2c_biths_del_bus(i2c_adap)) < 0)
+		return res;
+
+	kfree(i2c_adap->algo_data);
+	return 0;
+}
+
+EXPORT_SYMBOL(i2c_bit_add_bus);
+EXPORT_SYMBOL(i2c_bit_del_bus);
+
+#endif
+
+#ifdef rdtscl
+/* TSC stuff from arch/i386/lib/delay.c */
+
+static _HS_ATTR_ void i2c_tsc_set(struct i2c_algo_biths_data *adap)
+{
+	rdtscl(adap->bclock);
+}
+
+static _HS_ATTR_ void i2c_tsc_run(struct i2c_algo_biths_data *adap)
+{
+	unsigned long now, loops, xloops;
+	int d0;
+	xloops = adap->xloops; 
+	__asm__("mull %0"
+		:"=d" (xloops), "=&a" (d0)
+		:"1" (xloops),"0" (current_cpu_data.loops_per_jiffy));
+	loops = xloops * HZ;
+	do
+	{
+		rep_nop();
+		rdtscl(now);
+	} while ( (now - adap->bclock) < loops );
+}
+
+#else 
+
+static _HS_ATTR_ void i2c_udelay_set(struct i2c_algo_biths_data *adap) {}
+
+static _HS_ATTR_ void i2c_udelay_run(struct i2c_algo_biths_data *adap)
+{
+	int usecs;
+	/* adap->xloops = usecs * 0x000010c6 / 2; */
+	usecs = ((adap->xloops + 0x0863) >> 12); 
+	if (adap->ctrl & _HS_DBL_DT)
+		usecs<<=1;
+	udelay(usecs);
+}
+
+#endif /* rdtscl */
+
+
+/* 
+ * registering functions to load algorithms at runtime 
+ */
+int i2c_biths_add_bus(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_algo_biths_data *adap = i2c_adap->algo_data;
+
+	/* get name */
+	adap->name = i2c_adap->name;
+	adap->dstr = 0; // no protocol dump buffer
+
+	if (adap->set_timer == NULL) {
+#ifdef rdtscl 	/* if (x86_udelay_tsc) here instead ? */
+		adap->set_timer = i2c_tsc_set;
+		adap->run_timer = i2c_tsc_run;
+#else
+		adap->set_timer = i2c_udelay_set;
+		adap->run_timer = i2c_udelay_run;
+#endif
+	}
+
+	if (bit_test) {
+		int ret = test_bus(adap);
+		if (ret<0)
+			return ret;
+	}
+
+	DEB1(printk(KERN_DEBUG "i2c-algo-biths.o: hw routines for %s registered.\n",
+	            i2c_adap->name));
+#ifdef rdtscl
+	DEB1(printk(KERN_DEBUG "i2c-algo-biths.o:  ... will use rdtscl() for bus clock\n"));
+#else
+	DEB1(printk(KERN_DEBUG "i2c-algo-biths.o:  ... will use udelay() for bus clock\n"));
+#endif
+	
+	/* register new adapter to i2c module... */
+
+	i2c_adap->id |= i2c_algo_biths.id;
+	i2c_adap->algo = &i2c_algo_biths;
+
+	i2c_adap->timeout = HZ;	/* default values, should	*/
+	i2c_adap->retries = 3;	/* be replaced by defines	*/
+
+	i2c_add_adapter(i2c_adap);
+	return 0;
+}
+
+
+int i2c_biths_del_bus(struct i2c_adapter *i2c_adap)
+{
+	return i2c_del_adapter(i2c_adap);
+}
+
+EXPORT_SYMBOL(i2c_biths_add_bus);
+EXPORT_SYMBOL(i2c_biths_del_bus);
+
+MODULE_AUTHOR("Kyösti Mälkki <kmalkki@cc.hut.fi>");
+MODULE_DESCRIPTION("I2C-Bus bit-banging algorithm");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM(bit_test, "i");
+MODULE_PARM(i2c_debug,"i");
+
+MODULE_PARM_DESC(bit_test, "Test the lines of the bus to see if it is stuck");
+MODULE_PARM_DESC(i2c_debug, "debug level - 1 use; 2 fatal, 3 +proto; 4 all, 5 +proto");
--- linux-2.4.21/drivers/i2c/Makefile.dl14.orig	2003-08-24 01:18:21.000000000 +0200
+++ linux-2.4.21/drivers/i2c/Makefile	2003-08-24 01:20:53.000000000 +0200
@@ -5,11 +5,13 @@
 O_TARGET := i2c.o
 
 export-objs	:= i2c-core.o i2c-algo-bit.o i2c-algo-pcf.o \
-		   i2c-algo-ite.o i2c-proc.o i2c-algo-sibyte.o
+		   i2c-algo-ite.o i2c-proc.o i2c-algo-sibyte.o \
+		   i2c-algo-biths.o
 
 obj-$(CONFIG_I2C)		+= i2c-core.o
 obj-$(CONFIG_I2C_CHARDEV)	+= i2c-dev.o
 obj-$(CONFIG_I2C_ALGOBIT)	+= i2c-algo-bit.o
+obj-$(CONFIG_I2C_ALGOBITHS)	+= i2c-algo-biths.o
 obj-$(CONFIG_I2C_PHILIPSPAR)	+= i2c-philips-par.o
 obj-$(CONFIG_I2C_ELV)		+= i2c-elv.o
 obj-$(CONFIG_I2C_VELLEMAN)	+= i2c-velleman.o
--- linux-2.4.21/Documentation/i2c/bit_via.dl14.orig	2003-08-24 01:18:22.000000000 +0200
+++ linux-2.4.21/Documentation/i2c/bit_via	2003-08-24 01:18:22.000000000 +0200
@@ -0,0 +1,2 @@
+This driver has been moved to the lm_sensors project, and renamed to
+i2c-via.
--- linux-2.4.21/Documentation/i2c/i2c-old-porting.dl14.orig	2003-08-24 01:18:22.000000000 +0200
+++ linux-2.4.21/Documentation/i2c/i2c-old-porting	2003-08-24 01:18:22.000000000 +0200
@@ -0,0 +1,626 @@
+I2C Conversion Guide for I2C-old to the current I2C API
+July 2002
+For Linux Kernel v2.5.x
+Frank Davis <fdavis@si.rr.com>
+-------------------------------------------------------
+
+There exists several kernel drivers that are using an old version of the I2C
+API. These drivers need to be converted to the current (kernel 2.5.x) version.
+The following document provides a guideline to make the appropriate changes to
+the affected drivers. There maybe slight modifications to this guide that are 
+specific to the driver you are working on. If you see {driver_name}, replace 
+that with the respective name of the driver, such as saa7110.c , {driver_name} 
+= saa7110.
+
+-------------------------------------------------------
+
+Step 1: Include the right header file
+ 
+Perform the following change within the driver
+ 
+#include <linux/i2c-old.h> --> #include <linux/i2c.h>
+
+Step 2: Add and set the i2c modes
+
+Add the following code near the top of the driver
+
+static unsigned short normal_i2c[] = {34>>1, I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
+static unsigned short probe[2] = { I2C_CLIENT_END , I2C_CLIENT_END };
+static unsigned short probe_range[2] = { I2C_CLIENT_END , I2C_CLIENT_END };	
+static unsigned short ignore[2] = { I2C_CLIENT_END , I2C_CLIENT_END };
+static unsigned short ignore_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short force[2] = { I2C_CLIENT_END , I2C_CLIENT_END };
+
+static struct i2c_client_address_data addr_data  = {
+	normal_i2c , normal_i2c_range,
+	probe , probe_range,
+	ignore , ignore_range,
+	force
+};
+
+static struct i2c_client client_template;
+
+Step 3: Modify the driver info struct
+
+Within the struct for the driver , such as struct {driver_name}  ,  make the 
+following change ,
+struct i2c_bus *bus --> struct i2c_client *client
+
+Make changes where this change affects references within the file.
+
+Add a semaphore to the driver struct (as above)
+
+struct semaphore lock 
+
+Step 5: Remove specific read and write functions
+
+Remove the driver specific write and read functions, usually in the form:
+{driver_name}_write , {driver_name}_read , {driver_name}_write_block , etc.
+
+Step 6: Update the write and read functions for the current I2C API
+
+Replace all references of {driver_name}_write with i2c_smbus_write_byte_data
+Replace all references of {driver_name}_read with i2c_smbus_read_byte_data or
+i2c_smbus_read_byte , depending on args passed in.
+
+** Ensure that these functions pass in the i2c_client *client , NOT the
+decoder/encoder that was passed in the driver specific write and read
+functions. 
+ 
+Step 7: Modify the driver's attach function
+
+Change the driver attach function prototype :
+{driver_name}_attach(struct i2c_device *device) --> {driver_name}_attach(struct 
+i2c_adapter *adap, int addr , unsigned short flags, int kind)
+
+Create a i2c_client client...
+Add the following (where "decoder" is a reference to a struct for the driver
+info:
+
+struct i2c_client *client;
+client = kmalloc(sizeof(*client), GFP_KERNEL);
+if(client == NULL)
+	return -ENOMEM;
+client_template.adapter = adap;
+client_template.addr  = addr;
+memcpy(client, &client_template, sizeof(*client));
+strcpy(client->name , "{driver_name}");
+decoder->client = client;
+client->data = decoder;
+decoder->addr = addr;
+
+Towards the end of the function, add:
+
+init_MUTEX(&decoder->lock);
+i2c_attach_client(client);
+
+
+Step 8: Modify the driver's detach function
+
+Change the driver detach function prototype :
+{driver_name}_detach(struct i2c_device *device) --> {driver_name}_detach(struct 
+i2c_client *client)
+
+In the beginning of the detach function, add:
+i2c_detach_client(client);
+
+Towards the end of the detach function, add:
+kfree(client->data);
+kfree(client);
+
+Step 9: Modify the driver's command function
+
+Change the driver command function prototype :
+
+Step 10: Add the probe function after the driver's attach function.
+
+Add the following code:
+
+static int {driver_name}_probe(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, {driver_name}_attach);
+
+}
+
+Step 11: Modify the driver's i2c_driver
+
+Find the i2c_driver , such as
+static struct i2c_driver i2c_driver_saa7110
+It is usually located towards the end of the driver 
+Replace the values from I2C_DRIVERID_{something} to {driver_name}_attach, and 
+add the following
+I2C_DRIVERID_{driver_name} , // verify by looking in include/linux/i2c-id.h 
+I2C_DF_NOTIFY,
+{driver_name}_probe, 
+....
+
+Step 12: Adding the i2c_client 
+
+Add the i2c_client to the driver. Add the following code:
+
+static struct i2c_client client_template = {
+	"{driver_name}_client",
+	-1,
+	0,
+	0,
+	NULL,
+	{i2c_driver reference}
+};
+
+Step 13: Registering and Unregistering
+
+Replace i2c_register_driver with i2c_add_driver
+Replace i2c_unregister_driver with i2c_del_driver
+
+-------------------------------------------------------
+
+Example:
+
+The following patch provides the i2c coversion patch for the saa7110 driver
+based on the above guide (for clarity).
+
+
+--- drivers/media/video/saa7110.c.old	Fri Jun 28 10:22:52 2002
++++ drivers/media/video/saa7110.c	Thu Jul  4 16:51:08 2002
+@@ -26,7 +26,7 @@
+ #include <asm/io.h>
+ #include <asm/uaccess.h>
+ 
+-#include <linux/i2c-old.h>
++#include <linux/i2c.h>
+ #include <linux/videodev.h>
+ #include "linux/video_decoder.h"
+ 
+@@ -37,13 +37,31 @@
+ 
+ #define	I2C_SAA7110		0x9C	/* or 0x9E */
+ 
++#define IF_NAME	"saa7110"
+ #define	I2C_DELAY		10	/* 10 us or 100khz */
+ 
++static unsigned short normal_i2c[] = {34>>1, I2C_CLIENT_END };
++static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
++static unsigned short probe[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
++static unsigned short probe_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
++static unsigned short ignore[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
++static unsigned short ignore_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
++static unsigned short force[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
++
++static struct i2c_client_address_data addr_data = {
++	normal_i2c, normal_i2c_range,
++	probe, probe_range,
++	ignore, ignore_range,
++	force
++};
++
++static struct i2c_client client_template;
++
+ struct saa7110 {
+-	struct	i2c_bus	*bus;
++	struct i2c_client *client;
+ 	int		addr;
+ 	unsigned char	reg[36];
+-
++	struct semaphore lock;
+ 	int		norm;
+ 	int		input;
+ 	int		enable;
+@@ -54,67 +72,10 @@
+ };
+ 
+ /* ----------------------------------------------------------------------- */
+-/* I2C support functions						   */
+-/* ----------------------------------------------------------------------- */
+-static
+-int saa7110_write(struct saa7110 *decoder, unsigned char subaddr, unsigned char data)
+-{
+-	int ack;
+-
+-	LOCK_I2C_BUS(decoder->bus);
+-	i2c_start(decoder->bus);
+-	i2c_sendbyte(decoder->bus, decoder->addr, I2C_DELAY);
+-	i2c_sendbyte(decoder->bus, subaddr, I2C_DELAY);
+-	ack = i2c_sendbyte(decoder->bus, data, I2C_DELAY);
+-	i2c_stop(decoder->bus);
+-	decoder->reg[subaddr] = data;
+-	UNLOCK_I2C_BUS(decoder->bus);
+-	return ack;
+-}
+-
+-static
+-int saa7110_write_block(struct saa7110* decoder, unsigned const char *data, unsigned int len)
+-{
+-	unsigned subaddr = *data;
+-
+-	LOCK_I2C_BUS(decoder->bus);
+-        i2c_start(decoder->bus);
+-        i2c_sendbyte(decoder->bus,decoder->addr,I2C_DELAY);
+-	while (len-- > 0) {
+-                if (i2c_sendbyte(decoder->bus,*data,0)) {
+-                        i2c_stop(decoder->bus);
+-                        UNLOCK_I2C_BUS(decoder->bus);
+-                        return -EAGAIN;
+-                }
+-		decoder->reg[subaddr++] = *data++;
+-        }
+-	i2c_stop(decoder->bus);
+-	UNLOCK_I2C_BUS(decoder->bus);
+-
+-	return 0;
+-}
+-
+-static
+-int saa7110_read(struct saa7110* decoder)
+-{
+-	int data;
+-
+-	LOCK_I2C_BUS(decoder->bus);
+-	i2c_start(decoder->bus);
+-	i2c_sendbyte(decoder->bus, decoder->addr, I2C_DELAY);
+-	i2c_start(decoder->bus);
+-	i2c_sendbyte(decoder->bus, decoder->addr | 1, I2C_DELAY);
+-	data = i2c_readbyte(decoder->bus, 1);
+-	i2c_stop(decoder->bus);
+-	UNLOCK_I2C_BUS(decoder->bus);
+-	return data;
+-}
+-
+-/* ----------------------------------------------------------------------- */
+ /* SAA7110 functions							   */
+ /* ----------------------------------------------------------------------- */
+ static
+-int saa7110_selmux(struct i2c_device *device, int chan)
++int saa7110_selmux(struct i2c_client *client, int chan)
+ {
+ static	const unsigned char modes[9][8] = {
+ /* mode 0 */	{ 0x00, 0xD9, 0x17, 0x40, 0x03, 0x44, 0x75, 0x16 },
+@@ -126,61 +87,59 @@
+ /* mode 6 */	{ 0x80, 0x59, 0x17, 0x42, 0xA3, 0x44, 0x75, 0x12 },
+ /* mode 7 */	{ 0x80, 0x9A, 0x17, 0xB1, 0x13, 0x60, 0xB5, 0x14 },
+ /* mode 8 */	{ 0x80, 0x3C, 0x27, 0xC1, 0x23, 0x44, 0x75, 0x21 } };
+-	struct saa7110* decoder = device->data;
+ 	const unsigned char* ptr = modes[chan];
+ 
+-	saa7110_write(decoder,0x06,ptr[0]);	/* Luminance control	*/
+-	saa7110_write(decoder,0x20,ptr[1]);	/* Analog Control #1	*/
+-	saa7110_write(decoder,0x21,ptr[2]);	/* Analog Control #2	*/
+-	saa7110_write(decoder,0x22,ptr[3]);	/* Mixer Control #1	*/
+-	saa7110_write(decoder,0x2C,ptr[4]);	/* Mixer Control #2	*/
+-	saa7110_write(decoder,0x30,ptr[5]);	/* ADCs gain control	*/
+-	saa7110_write(decoder,0x31,ptr[6]);	/* Mixer Control #3	*/
+-	saa7110_write(decoder,0x21,ptr[7]);	/* Analog Control #2	*/
++	i2c_smbus_write_byte_data(client,0x06,ptr[0]);	/* Luminance control	*/
++	i2c_smbus_write_byte_data(client,0x20,ptr[1]);	/* Analog Control #1	*/
++	i2c_smbus_write_byte_data(client,0x21,ptr[2]);	/* Analog Control #2	*/
++	i2c_smbus_write_byte_data(client,0x22,ptr[3]);	/* Mixer Control #1	*/
++	i2c_smbus_write_byte_data(client,0x2C,ptr[4]);	/* Mixer Control #2	*/
++	i2c_smbus_write_byte_data(client,0x30,ptr[5]);	/* ADCs gain control	*/
++	i2c_smbus_write_byte_data(client,0x31,ptr[6]);	/* Mixer Control #3	*/
++	i2c_smbus_write_byte_data(client,0x21,ptr[7]);	/* Analog Control #2	*/
+ 
+ 	return 0;
+ }
+ 
+ static
+-int determine_norm(struct i2c_device* dev)
++int determine_norm(struct i2c_client* client)
+ {
+-	struct	saa7110* decoder = dev->data;
+ 	int	status;
+ 
+ 	/* mode changed, start automatic detection */
+-	status = saa7110_read(decoder);
++	status = i2c_smbus_read_byte(client);
+ 	if ((status & 3) == 0) {
+-		saa7110_write(decoder,0x06,0x80);
++		i2c_smbus_write_byte_data(client,0x06,0x80);
+ 		if (status & 0x20) {
+-			DEBUG(printk(KERN_INFO "%s: norm=bw60\n",dev->name));
+-			saa7110_write(decoder,0x2E,0x81);
++			DEBUG(printk(KERN_INFO "%s: norm=bw60\n",adp->name));
++			i2c_smbus_write_byte_data(client,0x2E,0x81);
+ 			return VIDEO_MODE_NTSC;
+ 		}
+-		DEBUG(printk(KERN_INFO "%s: norm=bw50\n",dev->name));
+-		saa7110_write(decoder,0x2E,0x9A);
++		DEBUG(printk(KERN_INFO "%s: norm=bw50\n",adp->name));
++		i2c_smbus_write_byte_data(client,0x2E,0x9A);
+ 		return VIDEO_MODE_PAL;
+ 	}
+ 
+-	saa7110_write(decoder,0x06,0x00);
++	i2c_smbus_write_byte_data(client,0x06,0x00);
+ 	if (status & 0x20) {	/* 60Hz */
+-		DEBUG(printk(KERN_INFO "%s: norm=ntsc\n",dev->name));
+-		saa7110_write(decoder,0x0D,0x06);
+-		saa7110_write(decoder,0x11,0x2C);
+-		saa7110_write(decoder,0x2E,0x81);
++		DEBUG(printk(KERN_INFO "%s: norm=ntsc\n",adp->name));
++		i2c_smbus_write_byte_data(client,0x0D,0x06);
++		i2c_smbus_write_byte_data(client,0x11,0x2C);
++		i2c_smbus_write_byte_data(client,0x2E,0x81);
+ 		return VIDEO_MODE_NTSC;
+ 	}
+ 
+ 	/* 50Hz -> PAL/SECAM */
+-	saa7110_write(decoder,0x0D,0x06);
+-	saa7110_write(decoder,0x11,0x59);
+-	saa7110_write(decoder,0x2E,0x9A);
++	i2c_smbus_write_byte_data(client,0x0D,0x06);
++	i2c_smbus_write_byte_data(client,0x11,0x59);
++	i2c_smbus_write_byte_data(client,0x2E,0x9A);
+ 
+ 	mdelay(150);	/* pause 150 ms */
+ 
+-	status = saa7110_read(decoder);
++	status = i2c_smbus_read_byte(client);
+ 	if ((status & 0x03) == 0x01) {
+ 		DEBUG(printk(KERN_INFO "%s: norm=secam\n",dev->name));
+-		saa7110_write(decoder,0x0D,0x07);
++		i2c_smbus_write_byte_data(client,0x0D,0x07);
+ 		return VIDEO_MODE_SECAM;
+ 	}
+ 	DEBUG(printk(KERN_INFO "%s: norm=pal\n",dev->name));
+@@ -188,7 +147,7 @@
+ }
+ 
+ static
+-int saa7110_attach(struct i2c_device *device)
++int saa7110_attach(struct i2c_adapter *adap, int  addr, unsigned short flags, int kind)
+ {
+ static	const unsigned char initseq[] = {
+ 	     0, 0x4C, 0x3C, 0x0D, 0xEF, 0xBD, 0xF0, 0x00, 0x00,
+@@ -198,20 +157,28 @@
+ 		0xD9, 0x17, 0x40, 0x41, 0x80, 0x41, 0x80, 0x4F,
+ 		0xFE, 0x01, 0xCF, 0x0F, 0x03, 0x01, 0x81, 0x03,
+ 		0x40, 0x75, 0x01, 0x8C, 0x03};
+-	struct	saa7110*	decoder;
++	struct	saa7110	*decoder;
++	struct i2c_client *client;
+ 	int			rv;
+-
+-	device->data = decoder = kmalloc(sizeof(struct saa7110), GFP_KERNEL);
+-	if (device->data == 0)
++	client=kmalloc(sizeof(*client), GFP_KERNEL);
++	if(client == NULL) 
+ 		return -ENOMEM;
+-
+-	MOD_INC_USE_COUNT;
++	client_template.adapter = adap;
++	client_template.addr = addr;
++	memcpy(client, &client_template, sizeof(*client));
++
++	decoder = kmalloc(sizeof(*decoder), GFP_KERNEL);
++	if (decoder == NULL) {
++		kfree(client);
++		return -ENOMEM;
++		}
+ 
+ 	/* clear our private data */
+-	memset(decoder, 0, sizeof(struct saa7110));
+-	strcpy(device->name, "saa7110");
+-	decoder->bus = device->bus;
+-	decoder->addr = device->addr;
++	memset(decoder, 0, sizeof(*decoder));
++	strcpy(client->name, IF_NAME);
++	decoder->client = client;
++	client->data = decoder;
++	decoder->addr = addr;
+ 	decoder->norm = VIDEO_MODE_PAL;
+ 	decoder->input = 0;
+ 	decoder->enable = 1;
+@@ -220,40 +187,52 @@
+ 	decoder->hue = 32768;
+ 	decoder->sat = 32768;
+ 
+-	rv = saa7110_write_block(decoder, initseq, sizeof(initseq));
++	rv = i2c_master_send(client, initseq, sizeof(initseq));
+ 	if (rv < 0)
+-		printk(KERN_ERR "%s_attach: init status %d\n", device->name, rv);
++		printk(KERN_ERR "%s_attach: init status %d\n", client->name, rv);
+ 	else {
+-		saa7110_write(decoder,0x21,0x16);
+-		saa7110_write(decoder,0x0D,0x04);
+-		DEBUG(printk(KERN_INFO "%s_attach: chip version %x\n", device->name, saa7110_read(decoder)));
+-		saa7110_write(decoder,0x0D,0x06);
++		i2c_smbus_write_byte_data(client,0x21,0x16);
++		i2c_smbus_write_byte_data(client,0x0D,0x04);
++		DEBUG(printk(KERN_INFO "%s_attach: chip version %x\n", client->name, i2c_smbus_read_byte(client)));
++		i2c_smbus_write_byte_data(client,0x0D,0x06);
+ 	}
+ 
++	init_MUTEX(&decoder->lock);
++	i2c_attach_client(client);
++	MOD_INC_USE_COUNT;
+ 	/* setup and implicit mode 0 select has been performed */
+ 	return 0;
+ }
+ 
++static 
++int saa7110_probe(struct i2c_adapter *adap) 
++{
++	return i2c_probe(adap, &addr_data, saa7110_attach);
++}
++
+ static
+-int saa7110_detach(struct i2c_device *device)
++int saa7110_detach(struct i2c_client *client)
+ {
+-	struct saa7110* decoder = device->data;
++	struct saa7110* decoder = client->data;
+ 
+-	DEBUG(printk(KERN_INFO "%s_detach\n",device->name));
++	i2c_detach_client(client);
++
++	DEBUG(printk(KERN_INFO "%s_detach\n",client->name));
+ 
+ 	/* stop further output */
+-	saa7110_write(decoder,0x0E,0x00);
++	i2c_smbus_write_byte_data(client,0x0E,0x00);
+ 
+-	kfree(device->data);
++	kfree(decoder);
++	kfree(client);
+ 
+ 	MOD_DEC_USE_COUNT;
+ 	return 0;
+ }
+ 
+ static
+-int saa7110_command(struct i2c_device *device, unsigned int cmd, void *arg)
++int saa7110_command(struct i2c_client *client, unsigned int cmd, void *arg)
+ {
+-	struct saa7110* decoder = device->data;
++	struct saa7110* decoder = client->data;
+ 	int	v;
+ 
+ 	switch (cmd) {
+@@ -272,11 +251,11 @@
+ 
+ 	 case DECODER_GET_STATUS:
+ 		{
+-			struct saa7110* decoder = device->data;
++			struct saa7110* decoder = client->data;
+ 			int status;
+ 			int res = 0;
+ 
+-			status = i2c_read(device->bus,device->addr|1);
++			status = i2c_smbus_read_byte(client);
+ 			if (status & 0x40)
+ 				res |= DECODER_STATUS_GOOD;
+ 			if (status & 0x03)
+@@ -301,26 +280,26 @@
+ 		v = *(int*)arg;
+ 		if (decoder->norm != v) {
+ 			decoder->norm = v;
+-			saa7110_write(decoder, 0x06, 0x00);
++			i2c_smbus_write_byte_data(client, 0x06, 0x00);
+ 			switch (v) {
+ 			 case VIDEO_MODE_NTSC:
+-				saa7110_write(decoder, 0x0D, 0x06);
+-				saa7110_write(decoder, 0x11, 0x2C);
+-				saa7110_write(decoder, 0x30, 0x81);
+-				saa7110_write(decoder, 0x2A, 0xDF);
++				i2c_smbus_write_byte_data(client, 0x0D, 0x06);
++				i2c_smbus_write_byte_data(client, 0x11, 0x2C);
++				i2c_smbus_write_byte_data(client, 0x30, 0x81);
++				i2c_smbus_write_byte_data(client, 0x2A, 0xDF);
+ 				break;
+ 			 case VIDEO_MODE_PAL:
+-				saa7110_write(decoder, 0x0D, 0x06);
+-				saa7110_write(decoder, 0x11, 0x59);
+-				saa7110_write(decoder, 0x2E, 0x9A);
++				i2c_smbus_write_byte_data(client, 0x0D, 0x06);
++				i2c_smbus_write_byte_data(client, 0x11, 0x59);
++				i2c_smbus_write_byte_data(client, 0x2E, 0x9A);
+ 				break;
+ 			 case VIDEO_MODE_SECAM:
+-				saa7110_write(decoder, 0x0D, 0x07);
+-				saa7110_write(decoder, 0x11, 0x59);
+-				saa7110_write(decoder, 0x2E, 0x9A);
++				i2c_smbus_write_byte_data(client, 0x0D, 0x07);
++				i2c_smbus_write_byte_data(client, 0x11, 0x59);
++				i2c_smbus_write_byte_data(client, 0x2E, 0x9A);
+ 				break;
+ 			 case VIDEO_MODE_AUTO:
+-				*(int*)arg = determine_norm(device);
++				*(int*)arg = determine_norm(client);
+ 				break;
+ 			 default:
+ 				return -EPERM;
+@@ -334,7 +313,7 @@
+ 			return -EINVAL;
+ 		if (decoder->input != v) {
+ 			decoder->input = v;
+-			saa7110_selmux(device, v);
++			saa7110_selmux(client, v);
+ 		}
+ 		break;
+ 
+@@ -349,7 +328,7 @@
+ 		v = *(int*)arg;
+ 		if (decoder->enable != v) {
+ 			decoder->enable = v;
+-			saa7110_write(decoder,0x0E, v ? 0x18 : 0x00);
++			i2c_smbus_write_byte_data(client,0x0E, v ? 0x18 : 0x00);
+ 		}
+ 		break;
+ 
+@@ -360,22 +339,22 @@
+ 			if (decoder->bright != pic->brightness) {
+ 				/* We want 0 to 255 we get 0-65535 */
+ 				decoder->bright = pic->brightness;
+-				saa7110_write(decoder, 0x19, decoder->bright >> 8);
++				i2c_smbus_write_byte_data(client, 0x19, decoder->bright >> 8);
+ 			}
+ 			if (decoder->contrast != pic->contrast) {
+ 				/* We want 0 to 127 we get 0-65535 */
+ 				decoder->contrast = pic->contrast;
+-				saa7110_write(decoder, 0x13, decoder->contrast >> 9);
++				i2c_smbus_write_byte_data(client, 0x13, decoder->contrast >> 9);
+ 			}
+ 			if (decoder->sat != pic->colour) {
+ 				/* We want 0 to 127 we get 0-65535 */
+ 				decoder->sat = pic->colour;
+-				saa7110_write(decoder, 0x12, decoder->sat >> 9);
++				i2c_smbus_write_byte_data(client, 0x12, decoder->sat >> 9);
+ 			}
+ 			if (decoder->hue != pic->hue) {
+ 				/* We want -128 to 127 we get 0-65535 */
+ 				decoder->hue = pic->hue;
+-				saa7110_write(decoder, 0x07, (decoder->hue>>8)-128);
++				i2c_smbus_write_byte_data(client, 0x07, (decoder->hue>>8)-128);
+ 			}
+ 		}
+ 		break;
+@@ -383,7 +362,7 @@
+ 	 case DECODER_DUMP:
+ 		for (v=0; v<34; v+=16) {
+ 			int j;
+-			DEBUG(printk(KERN_INFO "%s: %03x\n",device->name,v));
++			DEBUG(printk(KERN_INFO "%s: %03x\n",client->name,v));
+ 			for (j=0; j<16; j++) {
+ 				DEBUG(printk(KERN_INFO " %02x",decoder->reg[v+j]));
+ 			}
+@@ -402,24 +381,30 @@
+ 
+ static struct i2c_driver i2c_driver_saa7110 =
+ {
+-	"saa7110",			/* name */
+-
+-	I2C_DRIVERID_VIDEODECODER,	/* in i2c.h */
+-	I2C_SAA7110, I2C_SAA7110+1,	/* Addr range */
+-
+-	saa7110_attach,
++	IF_NAME,			/* name */
++	I2C_DRIVERID_SAA7110,	/* in i2c.h */
++	I2C_DF_NOTIFY,	/* Addr range */
++	saa7110_probe,
+ 	saa7110_detach,
+ 	saa7110_command
+ };
++static struct i2c_client client_template = {
++	"saa7110_client",
++	-1,
++	0,
++	0,
++	NULL,
++	&i2c_driver_saa7110
++};
+ 
+ static int saa7110_init(void)
+ {
+-	return i2c_register_driver(&i2c_driver_saa7110);
++	return i2c_add_driver(&i2c_driver_saa7110);
+ }
+ 
+ static void saa7110_exit(void)
+ {
+-	i2c_unregister_driver(&i2c_driver_saa7110);
++	i2c_del_driver(&i2c_driver_saa7110);
+ }
+ 
+ 
+ 
+
--- linux-2.4.21/Documentation/i2c/pcf.dl14.orig	2003-08-24 01:18:22.000000000 +0200
+++ linux-2.4.21/Documentation/i2c/pcf	2003-08-24 01:18:22.000000000 +0200
@@ -0,0 +1,63 @@
+<simon>
+This file written by Hans Berglund, who developed the pcf driver included
+in this directory.
+</simon>
+BACKGROUND
+==========
+
+This is an update to Simons i2c driver, based on his 19990214 version.
+
+I do care about the PCF8584 part only, that means the following files:
+
+	algo_pcf.c	- PCF8584 algorithm, no HW access here.
+	algo_pcf.h	- Header file for the PCF algorithm.
+	pcf_isa.c	- The Elektor ISA I2C board interface. The
+			  I/O address, interrupt etc. is defined here.
+	pcf_isa.h	- Header file for HW definitions
+	pcf8584.h	- PCF8584 registers and bits.
+
+I have always got plenty of warnings when compiling the i2c driver. The
+warnings come from the C preprocessor complaining about '-' in variable
+names. My suggestion is to avoid '-' and use '_' instead.
+
+
+VERSIONS
+========
+
+20000109 (Frodo Looijaard, frodol@dds.nl)
+-----------------------------------------
+
+- Hopefully fixed the horribly broken pcf_xfer function
+- Added I2C_M_NOSTART and I2C_M_REV_DIR_ADDR support
+
+19990218
+--------
+- Changed default clock setting to 0x1c
+- Changes in pcf_isa.c to make interrupt work
+- Added changes from Simons 19990214 version
+
+19990202 (Changes from Simons 19990118)
+---------------------------------------
+- Added algo_pcf.c
+- Added algo_pcf.h
+- Added pcf_isa.c
+- Added pcf_isa.h
+- Moved pcf8584.h from "old-code", and did minor changes.
+- Changed detect/detect.c to give nicer output.
+- Use i2c_debug in i2c-dev.c
+
+
+LOCATIONS
+=========
+
+This driver: http://home.telia.no/hansb/I2C_page.htm
+     Additions to Simons driver to make it work with PCF8584.
+     Interrupthandling added. Some testing performed, but still
+     experimental version.
+
+Simons driver: http://www.tk.uni-linz.ac.at/~simon/private/i2c/v4l/
+     The baseline for further development.
+
+Pybes driver: http://www.iae.nl/users/pybe/linux/index.htm
+     More advanced PCF8584 additions. Supports message passing on 
+     module level
--- linux-2.4.21/Documentation/Configure.help.dl14.orig	2003-08-24 01:18:21.000000000 +0200
+++ linux-2.4.21/Documentation/Configure.help	2003-08-24 01:18:22.000000000 +0200
@@ -18381,6 +18381,70 @@ CONFIG_ITE_I2C_ADAP
   <file:Documentation/modules.txt>.
   The module will be called i2c-adap-ite.o.
 
+Basic I2C on Parallel Port adapter
+CONFIG_I2C_PPORT
+  This supports directly connecting I2C devices to the parallel port.
+  See <file:Documentation/i2c/i2c-pport> for more information.
+
+  This driver is also available as a module.  If you want to compile
+  it as a module, say M here and read
+  <file:Documentation/modules.txt>.
+  The module will be called i2c-pport.o.
+
+PCF on the EPP Parallel Port
+CONFIG_I2C_PCFEPP
+  This supports the PCF8584 connected to the parallel port.
+
+  This driver is also available as a module.  If you want to compile
+  it as a module, say M here and read
+  <file:Documentation/modules.txt>.
+  The module will be called i2c-pcf-epp.o.
+
+Motorola 8xx I2C algorithm
+CONFIG_I2C_ALGO8XX
+  This is the algorithm that allows you to use Motorola 8xx I2C adapters.
+
+  This driver is also available as a module.  If you want to compile
+  it as a module, say M here and read
+  <file:Documentation/modules.txt>.
+  The module will be called i2c-algo-8xx.o.
+
+Motorola 8xx I2C interface
+CONFIG_I2C_RPXLITE
+  This supports the Motorola 8xx I2C device.
+
+  This driver is also available as a module.  If you want to compile
+  it as a module, say M here and read
+  <file:Documentation/modules.txt>.
+  The module will be called i2c-rpx.o.
+
+IBM 405 I2C algorithm
+CONFIG_I2C_IBM_OCP_ALGO
+  This is the algorithm that allows you to use IBM 405 I2C adapters.
+
+  This driver is also available as a module.  If you want to compile
+  it as a module, say M here and read
+  <file:Documentation/modules.txt>.
+  The module will be called i2c-algo-ibm_ocp.o.
+
+IBM 405 I2C interface
+CONFIG_I2C_IBM_OCP_ADAP
+  This supports the IBM 405 I2C device.
+
+  This driver is also available as a module.  If you want to compile
+  it as a module, say M here and read
+  <file:Documentation/modules.txt>.
+  The module will be called i2c-adap-ibm_ocp.o.
+
+StrongARM SA-1110 interface
+CONFIG_I2C_FRODO
+  This supports the StrongARM SA-1110 Development Board.
+
+  This driver is also available as a module.  If you want to compile
+  it as a module, say M here and read
+  <file:Documentation/modules.txt>.
+  The module will be called i2c-frodo.o.
+
 I2C support
 CONFIG_I2C
   I2C (pronounce: I-square-C) is a slow serial bus protocol used in
@@ -18416,6 +18480,19 @@ CONFIG_I2C_ALGOBIT
   <file:Documentation/modules.txt>.
   The module will be called i2c-algo-bit.o.
 
+I2C bit-banging interfaces (hs alternative)
+CONFIG_I2C_ALGOBITHS
+  This allows you to use a range of I2C adapters called bit-banging
+  adapters.  Say Y if you own an I2C adapter belonging to this class
+  and then say Y to the specific driver for you adapter below.
+
+  This is an alternative driver to the standard i2c-algo-bit driver.
+
+  This support is also available as a module.  If you want to compile
+  it as a module, say M here and read
+  <file:Documentation/modules.txt>.
+  The module will be called i2c-algo-biths.o.
+
 Philips style parallel port adapter
 CONFIG_I2C_PHILIPSPAR
   This supports parallel-port I2C adapters made by Philips.  Say Y if
