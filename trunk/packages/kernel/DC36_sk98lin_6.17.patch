diff -Nru a/Documentation/Configure.help b/Documentation/Configure.help
--- a/Documentation/Configure.help	Wed Sep  3 22:38:48 2003
+++ b/Documentation/Configure.help	Wed Sep  3 22:38:49 2003
@@ -11557,33 +11557,60 @@
 
   The safe and default value for this is N.
 
-SysKonnect SK-98xx and SK-95xx Gigabit Ethernet Adapter family support
+Marvell Yukon / SysKonnect SK-98xx and SK-95xx Gigabit Ethernet Adapter family support
 CONFIG_SK98LIN
-  Say Y here if you have a SysKonnect SK-98xx or SK-95xx Gigabit 
-  Ethernet Server Adapter. The following adapters are supported by 
-  this driver:
-  - SK-9521 10/100/1000Base-T Adapter
-  - SK-9821 Gigabit Ethernet 1000Base-T Server Adapter
-  - SK-9822 Gigabit Ethernet 1000Base-T Dual Port Server Adapter
-  - SK-9841 Gigabit Ethernet 1000Base-LX Server Adapter
-  - SK-9842 Gigabit Ethernet 1000Base-LX Dual Port Server Adapter
-  - SK-9843 Gigabit Ethernet 1000Base-SX Server Adapter
-  - SK-9844 Gigabit Ethernet 1000Base-SX Dual Port Server Adapter
-  - SK-9861 Gigabit Ethernet 1000Base-SX Server Adapter
-  - SK-9862 Gigabit Ethernet 1000Base-SX Dual Port Server Adapter
-  - SK-9871 Gigabit Ethernet 1000Base-ZX Server Adapter
-  - SK-9872 Gigabit Ethernet 1000Base-ZX Dual Port Server Adapter
+  Say Y here if you have a Marvell Yukon or SysKonnect SK-98xx/SK-95xx
+  compliant Gigabit Ethernet Adapter. The following adapters are supported
+  by this driver:
+  - 3Com 3C940 Gigabit LOM Ethernet Adapter
+  - 3Com 3C941 Gigabit LOM Ethernet Adapter
+  - SK-9821 Gigabit Ethernet Server Adapter (SK-NET GE-T)
+  - SK-9822 Gigabit Ethernet Server Adapter (SK-NET GE-T dual link)
+  - SK-9841 Gigabit Ethernet Server Adapter (SK-NET GE-LX)
+  - SK-9842 Gigabit Ethernet Server Adapter (SK-NET GE-LX dual link)
+  - SK-9843 Gigabit Ethernet Server Adapter (SK-NET GE-SX)
+  - SK-9844 Gigabit Ethernet Server Adapter (SK-NET GE-SX dual link)
+  - SK-9861 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition)
+  - SK-9862 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition dual link)
+  - SK-9871 Gigabit Ethernet Server Adapter (SK-NET GE-ZX)
+  - SK-9872 Gigabit Ethernet Server Adapter (SK-NET GE-ZX dual link)
+  - Allied Telesyn AT-2970SX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970LX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970TX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2971SX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2971T Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970SX/2SC Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970LX/2SC Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970TX/2TX Gigabit Ethernet Adapter
+  - Marvell RDK-8001 Adapter
+  - Marvell RDK-8002 Adapter
+  - Marvell RDK-8003 Adapter
+  - Marvell RDK-8004 Adapter
+  - Marvell RDK-8006 Adapter
+  - Marvell RDK-8007 Adapter
+  - Marvell RDK-8008 Adapter
+  - Marvell RDK-8009 Adapter
+  - Marvell RDK-8011 Adapter
+  - Marvell RDK-8012 Adapter
+  - SK-9521 V2.0 10/100/1000Base-T Adapter
   - SK-9821 V2.0 Gigabit Ethernet 10/100/1000Base-T Adapter
   - SK-9841 V2.0 Gigabit Ethernet 1000Base-LX Adapter
   - SK-9843 V2.0 Gigabit Ethernet 1000Base-SX Adapter
   - SK-9851 V2.0 Gigabit Ethernet 1000Base-SX Adapter
   - SK-9861 V2.0 Gigabit Ethernet 1000Base-SX Adapter
   - SK-9871 V2.0 Gigabit Ethernet 1000Base-ZX Adapter
+  - SK-9521 10/100/1000Base-T Adapter
+  - DGE-530T Gigabit Ethernet Adapter
+  - Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Adapter
+  - N-Way PCI-Bus Giga-Card 1000/100/10Mbps(L)
+  - EG1032 v2 Instant Gigabit Network Adapter
+  - EG1064 v2 Instant Gigabit Network Adapter
 
   The adapters support Jumbo Frames.
   The dual link adapters support link-failover and dual port features.
-  The V2.0 adapters support the scatter-gather functionality with
-  sendfile(). Read Documentation/networking/sk98lin.txt for information about
+  Both Marvell Yukon and SysKonnect SK-98xx/SK-95xx adapters support 
+  the scatter-gather functionality with sendfile(). Please refer to 
+  Documentation/networking/sk98lin.txt for more information about
   optional driver parameters.
   Questions concerning this driver may be addressed to:
     linux@syskonnect.de
@@ -11592,6 +11619,122 @@
   inserted in and removed from the running kernel whenever you want),
   say M here and read Documentation/modules.txt. This is recommended.
   The module will be called sk98lin.o.
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T1
+  This driver supports:
+
+  - 3Com 3C940 Gigabit LOM Ethernet Adapter
+  - 3Com 3C941 Gigabit LOM Ethernet Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+SysKonnect SK98xx Support
+CONFIG_SK98LIN_T2
+  This driver supports:
+
+  - SK-9821 Gigabit Ethernet Server Adapter (SK-NET GE-T)
+  - SK-9822 Gigabit Ethernet Server Adapter (SK-NET GE-T dual link)
+  - SK-9841 Gigabit Ethernet Server Adapter (SK-NET GE-LX)
+  - SK-9842 Gigabit Ethernet Server Adapter (SK-NET GE-LX dual link)
+  - SK-9843 Gigabit Ethernet Server Adapter (SK-NET GE-SX)
+  - SK-9844 Gigabit Ethernet Server Adapter (SK-NET GE-SX dual link)
+  - SK-9861 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition)
+  - SK-9862 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition dual link)
+  - SK-9871 Gigabit Ethernet Server Adapter (SK-NET GE-ZX)
+  - SK-9872 Gigabit Ethernet Server Adapter (SK-NET GE-ZX dual link)
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+SysKonnect SK98xx Support
+CONFIG_SK98LIN_T3
+  This driver supports:
+
+  - Allied Telesyn AT-2970SX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970LX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970TX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2971SX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2971T Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970SX/2SC Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970LX/2SC Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970TX/2TX Gigabit Ethernet Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T4
+  This driver supports:
+
+  - Marvell RDK-8001 Adapter
+  - Marvell RDK-8002 Adapter
+  - Marvell RDK-8003 Adapter
+  - Marvell RDK-8004 Adapter
+  - Marvell RDK-8006 Adapter
+  - Marvell RDK-8007 Adapter
+  - Marvell RDK-8008 Adapter
+  - Marvell RDK-8009 Adapter
+  - Marvell RDK-8011 Adapter
+  - Marvell RDK-8012 Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T5
+  This driver supports:
+
+  - SK-9521 V2.0 10/100/1000Base-T Adapter
+  - SK-9821 V2.0 Gigabit Ethernet 10/100/1000Base-T Adapter
+  - SK-9841 V2.0 Gigabit Ethernet 1000Base-LX Adapter
+  - SK-9843 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+  - SK-9851 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+  - SK-9861 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+  - SK-9871 V2.0 Gigabit Ethernet 1000Base-ZX Adapter
+  - SK-9521 10/100/1000Base-T Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T6
+  This driver supports:
+
+  - DGE-530T Gigabit Ethernet Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T7
+  This driver supports:
+
+  - Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T8
+  This driver supports:
+
+  - N-Way PCI-Bus Giga-Card 1000/100/10Mbps(L)
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T9
+  This driver supports:
+
+  - EG1032 v2 Instant Gigabit Network Adapter
+  - EG1064 v2 Instant Gigabit Network Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
 
 Sun GEM support
 CONFIG_SUNGEM
diff -Nru a/Documentation/networking/sk98lin.txt b/Documentation/networking/sk98lin.txt
--- a/Documentation/networking/sk98lin.txt	Wed Sep  3 22:38:48 2003
+++ b/Documentation/networking/sk98lin.txt	Wed Sep  3 22:38:48 2003
@@ -1,11 +1,11 @@
-(C)Copyright 1999-2002 SysKonnect GmbH.
+(C)Copyright 1999-2003 Marvell(R).
 All rights reserved
 ===========================================================================
 
-sk98lin.txt created 19-Dec-2002
+sk98lin.txt created 26-Aug-2003
 
-Readme File for sk98lin v6.02
-SysKonnect SK-98xx Gigabit Ethernet Adapter family driver for LINUX
+Readme File for sk98lin v6.17
+Marvell Yukon/SysKonnect SK-98xx Gigabit Ethernet Adapter family driver for LINUX
 
 This file contains
  1  Overview
@@ -19,7 +19,6 @@
  5  Large Frame Support
  6  VLAN and Link Aggregation Support (IEEE 802.1, 802.1q, 802.3ad)
  7  Troubleshooting
- 8  History
 
 ===========================================================================
 
@@ -27,8 +26,9 @@
 1  Overview
 ===========
 
-The sk98lin driver supports the SysKonnect SK-98xx and SK-95xx family 
-on Linux. It has been tested with Linux on Intel/x86 machines.
+The sk98lin driver supports the Marvell Yukon and SysKonnect 
+SK-98xx/SK-95xx compliant Gigabit Ethernet Adapter on Linux. It has 
+been tested with Linux on Intel/x86 machines.
 ***
 
 
@@ -75,8 +75,8 @@
 To integrate the driver permanently into the kernel, proceed as follows:
 
 1. Select the menu "Network device support" and then "Ethernet(1000Mbit)"
-2. Mark "SysKonnect SK-98xx and SK-95xx Gigabit Ethernet Adapter
-   family support" with (*) 
+2. Mark "Marvell Yukon Chipset / SysKonnect SK-98xx family support" 
+   with (*) 
 3. Build a new kernel when the configuration of the above options is 
    finished.
 4. Install the new kernel.
@@ -87,8 +87,8 @@
 1. Enable 'loadable module support' in the kernel.
 2. For automatic driver start, enable the 'Kernel module loader'.
 3. Select the menu "Network device support" and then "Ethernet(1000Mbit)"
-4. Mark "SysKonnect SK-98xx and SK-95xx Gigabit Ethernet Adapter
-   family support" with (M)
+4. Mark "Marvell Yukon Chipset / SysKonnect SK-98xx family support" 
+   with (M)
 5. Execute the command "make modules".
 6. Execute the command "make modules_install".
    The appropiate modules will be installed.
@@ -100,21 +100,23 @@
 To load the module manually, proceed as follows:
 
 1. Enter "modprobe sk98lin".
-2. If the SysKonnect SK-98xx adapter is installed in your computer and you
-   have a /proc file system, execute the command:
+2. If a Marvell Yukon or SysKonnect SK-98xx adapter is installed in 
+   your computer and you have a /proc file system, execute the command:
    "ls /proc/net/sk98lin/" 
    This should produce an output containing a line with the following 
    format:
    eth0   eth1  ...
    which indicates that your adapter has been found and initialized.
    
-   NOTE 1: If you have more than one SysKonnect SK-98xx adapter installed,
-           the adapters will be listed as 'eth0', 'eth1', 'eth2', etc.
-           For each adapter, repeat steps 3 and 4 below.
-
-   NOTE 2: If you have other Ethernet adapters installed, your SysKonnect
-           SK-98xx adapter will be mapped to the next available number, 
-           e.g. 'eth1'. The mapping is executed automatically.
+   NOTE 1: If you have more than one Marvell Yukon or SysKonnect SK-98xx 
+           adapter installed, the adapters will be listed as 'eth0', 
+                   'eth1', 'eth2', etc.
+                   For each adapter, repeat steps 3 and 4 below.
+
+   NOTE 2: If you have other Ethernet adapters installed, your Marvell
+           Yukon or SysKonnect SK-98xx adapter will be mapped to the 
+                   next available number, e.g. 'eth1'. The mapping is executed 
+                   automatically.
            The module installation message (displayed either in a system
            log file or on the console) prints a line for each adapter 
            found containing the corresponding 'ethX'.
@@ -141,7 +143,7 @@
    Use 'ping <otherstation>' to verify the connection to other computers 
    on your network.
 5. To check the adapter configuration view /proc/net/sk98lin/[devicename].
-   For example by executing:	
+   For example by executing:    
    "cat /proc/net/sk98lin/eth0" 
 
 Unload the module
@@ -184,7 +186,7 @@
    unload and reload the driver.
    The syntax of the driver parameters is:
 
- 	modprobe sk98lin parameter=value1[,value2[,value3...]]
+        modprobe sk98lin parameter=value1[,value2[,value3...]]
 
    where value1 refers to the first adapter, value2 to the second etc.
 
@@ -198,7 +200,7 @@
 to FULL, and on the second adapter to HALF.
 Then, you must enter:
 
- 	modprobe sk98lin AutoNeg=On,Off DupCap=Full,Half
+        modprobe sk98lin AutoNeg_A=On,Off DupCap_A=Full,Half
 
 NOTE: The number of adapters that can be configured this way is
       limited in the driver (file skge.c, constant SK_MAX_CARD_PARAM).
@@ -256,9 +258,9 @@
 port reports during auto-negotiation. It can be set for each port 
 individually.
 Possible modes:
-   -- Sym      = Symetric: both link partners are allowed to send 
+   -- Sym      = Symmetric: both link partners are allowed to send 
                   PAUSE frames
-   -- SymOrRem = SymetricOrRemote: both or only remote partner 
+   -- SymOrRem = SymmetricOrRemote: both or only remote partner 
                   are allowed to send PAUSE frames
    -- LocSend  = LocalSend: only local link partner is allowed 
                   to send PAUSE frames
@@ -283,6 +285,101 @@
 4.2  Adapter Parameters
 -----------------------
 
+Connection Type (SK-98xx V2.0 copper adapters only)
+---------------
+Parameter:    ConType
+Values:       Auto, 100FD, 100HD, 10FD, 10HD
+Default:      Auto
+
+The parameter 'ConType' is a combination of all five per-port parameters
+within one single parameter. This simplifies the configuration of both ports
+of an adapter card! The different values of this variable reflect the most 
+meaningful combinations of port parameters.
+
+The following table shows the values of 'ConType' and the corresponding
+combinations of the per-port parameters:
+
+    ConType   |  DupCap   AutoNeg   FlowCtrl   Role             Speed
+    ----------+------------------------------------------------------
+    Auto      |  Both     On        SymOrRem   Auto             Auto
+    100FD     |  Full     Off       None       Auto (ignored)   100
+    100HD     |  Half     Off       None       Auto (ignored)   100
+    10FD      |  Full     Off       None       Auto (ignored)   10
+    10HD      |  Half     Off       None       Auto (ignored)   10
+
+Stating any other port parameter together with this 'ConType' variable
+will result in a merged configuration of those settings. This due to 
+the fact, that the per-port parameters (e.g. Speed_? ) have a higher
+priority than the combined variable 'ConType'.
+
+NOTE: This parameter is always used on both ports of the adapter card.
+
+Interrupt Moderation
+--------------------
+Parameter:    Moderation
+Values:       None, Static, Dynamic
+Default:      None
+
+Interrupt moderation is employed to limit the maxmimum number of interrupts
+the driver has to serve. That is, one or more interrupts (which indicate any
+transmit or receive packet to be processed) are queued until the driver 
+processes them. When queued interrupts are to be served, is determined by the
+'IntsPerSec' parameter, which is explained later below.
+
+Possible modes:
+
+   -- None - No interrupt moderation is applied on the adapter card. 
+      Therefore, each transmit or receive interrupt is served immediately
+      as soon as it appears on the interrupt line of the adapter card.
+
+   -- Static - Interrupt moderation is applied on the adapter card. 
+      All transmit and receive interrupts are queued until a complete
+      moderation interval ends. If such a moderation interval ends, all
+      queued interrupts are processed in one big bunch without any delay.
+      The term 'static' reflects the fact, that interrupt moderation is
+      always enabled, regardless how much network load is currently 
+      passing via a particular interface. In addition, the duration of
+      the moderation interval has a fixed length that never changes while
+      the driver is operational.
+
+   -- Dynamic - Interrupt moderation might be applied on the adapter card,
+      depending on the load of the system. If the driver detects that the
+      system load is too high, the driver tries to shield the system against 
+      too much network load by enabling interrupt moderation. If - at a later
+      time - the CPU utilizaton decreases again (or if the network load is 
+      negligible) the interrupt moderation will automatically be disabled.
+
+Interrupt moderation should be used when the driver has to handle one or more
+interfaces with a high network load, which - as a consequence - leads also to a
+high CPU utilization. When moderation is applied in such high network load 
+situations, CPU load might be reduced by 20-30%.
+
+NOTE: The drawback of using interrupt moderation is an increase of the round-
+trip-time (RTT), due to the queueing and serving of interrupts at dedicated
+moderation times.
+
+Interrupts per second
+---------------------
+Parameter:    IntsPerSec
+Values:       30...40000 (interrupts per second)
+Default:      2000
+
+This parameter is only used, if either static or dynamic interrupt moderation
+is used on a network adapter card. Using this paramter if no moderation is
+applied, will lead to no action performed.
+
+This parameter determines the length of any interrupt moderation interval. 
+Assuming that static interrupt moderation is to be used, an 'IntsPerSec' 
+parameter value of 2000 will lead to an interrupt moderation interval of
+500 microseconds. 
+
+NOTE: The duration of the moderation interval is to be chosen with care.
+At first glance, selecting a very long duration (e.g. only 100 interrupts per 
+second) seems to be meaningful, but the increase of packet-processing delay 
+is tremendous. On the other hand, selecting a very short moderation time might
+compensate the use of any moderation being applied.
+
+
 Preferred Port
 --------------
 Parameter:    PrefPort
@@ -365,10 +462,10 @@
 6  VLAN and Link Aggregation Support (IEEE 802.1, 802.1q, 802.3ad)
 ==================================================================
 
-The SysKonnect Linux drivers are able to support VLAN and Link Aggregation
-according to IEEE standards 802.1, 802.1q, and 802.3ad. These features are
-only available after installation of open source modules available on the 
-Internet:
+The Marvell Yukon/SysKonnect Linux drivers are able to support VLAN and 
+Link Aggregation according to IEEE standards 802.1, 802.1q, and 802.3ad. 
+These features are only available after installation of open source 
+modules available on the Internet:
 For VLAN go to: http://scry.wanfear.com/~greear/vlan.html
 For Link Aggregation go to: http://www.st.rim.or.jp/~yumo
 
@@ -448,7 +545,7 @@
           Nr:    0xcc
           Msg:   SkGeInitPort() cannot init running ports"
 Reason:   You are using a driver compiled for single processor machines 
-          on a multiprocessor machine with SMP (Symetric MultiProcessor) 
+          on a multiprocessor machine with SMP (Symmetric MultiProcessor) 
           kernel.
 Solution: Configure your kernel appropriately and recompile the kernel or
           the modules.
@@ -459,208 +556,13 @@
 support for help (linux@syskonnect.de).
 When contacting our technical support, please ensure that the following 
 information is available:
-- System Manufacturer and Model
-- Boards in your system
+- System Manufacturer and HW Informations (CPU, Memory... )
+- PCI-Boards in your system
 - Distribution
 - Kernel version
 - Driver version
 ***
 
-8  History
-==========
 
-VERSION 6.00 (In-Kernel version)
-New Features:
-- Support for SK-98xx V2.0 adapters
-- Support for gmac
-- Support for kernel 2.4.x and kernel 2.2.x
-- Zerocopy support for kernel 2.4.x with sendfile()
-- Support for scatter-gather functionality with sendfile()
-- Speed support for SK-98xx V2.0 adapters
-- New ProcFs entries
-- New module parameters
-Problems fixed:
-- ProcFS initialization
-- csum packet error
-- Ierror/crc counter error (#10767)
-- rx_too_long counter error (#10751)
-Known limitations:
-- None
-
-VERSION 4.11
-New Features:
-- none
-Problems fixed:
-- Error statistic counter fix (#10620)
-- RLMT-Fixes (#10659, #10639, #10650)
-- LM80 sensor initialization fix (#10623)
-- SK-CSUM memory fixes (#10610).
-Known limitations:
-- None
-
-VERSION 4.10
-New Features:
-- New ProcFs entries
-Problems fixed:
-- Corrected some printk's
-Known limitations:
-- None
-
-VERSION 4.09
-New Features:
-- IFF_RUNNING support (link status)
-- New ProcFs entries
-Problems fixed:
-- too long counters
-- too short counters
-- Kernel error compilation
-Known limitations:
-- None
- 
-VERSION 4.06 (In-Kernel version)
-Problems fixed:
-- MTU init problems
- 
-VERSION 4.04
-Problems fixed:
-- removed VLAN error messages
-
-VERSION 4.02 (In-Kernel version)
-New Features:
-- Add Kernel 2.4 changes
-Known limitations:
-- None
-
-VERSION 4.01 (In-Kernel version)
-Problems fixed:
-- Full statistics support for DualNet mode
-Known limitations:
-- None
-
-VERSION 4.00 (In-Kernel version)
-Problems fixed:
-- Memory leak found 
-New Features:
-- Proc filesystem integration
-- DualNet functionality integrated
-- Rlmt networks added
-Known limitations:
-- statistics partially incorrect in DualNet mode
-
-VERSION 3.04 (In-Kernel version)
-Problems fixed:
-- Driver start failed on UltraSPARC
-- Rx checksum calculation for big endian machines did not work
-- Jumbo frames were counted as input-errors in netstat
-
-VERSION 3.03 (Standalone version)
-Problems fixed:
-- Compilation did not find script "printver.sh" if "." not in PATH
-Known limitations:
-- None
-
-VERSION 3.02 (In-Kernel version)
-Problems fixed:
-- None
-New Features:
-- Integration in Linux kernel source (2.2.14 and 2.3.29) 
-Known limitations:
-- None
-
-VERSION 3.01
-Problems fixed:
-- None
-New Features:
-- Full source release
-Known limitations:
-- None
-
-VERSION 3.00
-Problems fixed:
-- None
-New Features:
-- Support for 1000Base-T adapters (SK-9821 and SK-9822)
-Known limitations:
-- None
-
-VERSION 1.07
-Problems fixed:
-- RlmtMode parameter value strings were wrong (#10437)
-- Driver sent too many RLMT frames (#10439)
-- Driver did not recognize network segmentation (#10440)
-- RLMT switched too often on segmented network (#10441)
-Known limitations:
-- None
-
-VERSION 1.06
-Problems fixed:
-- System panic'ed after some time when running with 
-  RlmtMode=CheckOtherLink or RlmtMode=CheckSeg (#10421)
-  Panic message: "Kernel panic: skput: over ... dev: eth0"
-- Driver did not switch back to default port when connected
-  back-to-back (#10422).
-Changes:
-- RlmtMode parameter names have changed
-New features:
-- There is now a version for ALPHA processors
-Known limitations:
-- None
-
-VERSION 1.05
-Problems fixed:
-- Driver failed to load on kernels with version information
-  for module symbols enabled
-Known limitations:
-- None
-
-VERSION 1.04
-Problems fixed:
-- Large frame support does work now (no autonegotiation
-  support for large frames, just manually selectable)
-New Features:
-- Receive checksumming in hardware
-- Performance optimizations
-  Some numbers (on two PII-400 machines, back-to-back):
-  netpipe: 300 MBit/sec, with large frames: 470 MBit/sec
-  ttcp:  38 MByte/sec, with large frames: 60 MByte/sec
-  ttcp (UDP send): 66 MByte/sec, with large frames: 106 MByte/sec
-Known limitations:
-- None
-
-VERSION 1.03
-Problems fixed:
-- Unloading with "rmmod" caused segmentation fault (#10415)
-- The link LED flickered from time to time, if no link was
-  established (#10402)
-- Installation problems with RedHat 6.0 (#10409)
-New Features:
-- Connection state ouput at "network connection up"
-Known limitations:
-- None
-
-VERSION 1.02
-Problems fixed:
-- Failed with multiple adapters
-- Failed with Single Port adapters
-- Startup string was only displayed if adapter found
-- No link could be established on certain switches when the switches were
-  rebooted. (#10377)
-Known limitations:
-- Segmentation fault at "rmmod" with kernel 2.2.3 on some machines
-
-VERSION 1.01
-Problems fixed:
-- Sensor status was not set back to 'ok' after 'warning/error'. (#10386)
-Changes:
-- improved parallelism in driver
-
-VERSION 1.00
-Known limitations:
-- not tested with all kernel versions (I don't have that much time :-)
-- only x86 version available (if you need others, ask for it)
-- source code not completely available
 
 ***End of Readme File***
-
-
-
diff -Nru a/MAINTAINERS b/MAINTAINERS
--- a/MAINTAINERS	Wed Sep  3 22:38:48 2003
+++ b/MAINTAINERS	Wed Sep  3 22:38:48 2003
@@ -504,6 +504,14 @@
 M:	jmorris@intercode.com.au
 P:	David S. Miller
 M:	davem@redhat.com
+MARVELL YUKON / SYSKONNECT DRIVER
+P:	Mirko Lindner
+M: 	mlindner@syskonnect.de
+P:	Ralph Roesler
+M: 	rroesler@syskonnect.de
+W: 	http://www.syskonnect.com
+S: 	Supported
+M:	davem@redhat.com
 W	http://samba.org/~jamesm/crypto/
 L:	linux-kernel@vger.kernel.org
 S:	Maintained
@@ -1749,12 +1757,6 @@
 M:	mj@ucw.cz
 L:	linux-video@atrey.karlin.mff.cuni.cz
 S:	Maintained
-
-SYSKONNECT DRIVER
-P: Mirko Lindner
-M: mlindner@syskonnect.de
-W: http://www.syskonnect.com
-S: Supported
 
 SYSV FILESYSTEM
 P:	Christoph Hellwig
diff -Nru a/drivers/net/Config.in b/drivers/net/Config.in
--- a/drivers/net/Config.in	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/Config.in	Wed Sep  3 22:38:48 2003
@@ -268,7 +268,18 @@
 dep_tristate 'Packet Engines Hamachi GNIC-II support' CONFIG_HAMACHI $CONFIG_PCI
 dep_tristate 'Packet Engines Yellowfin Gigabit-NIC support (EXPERIMENTAL)' CONFIG_YELLOWFIN $CONFIG_PCI $CONFIG_EXPERIMENTAL
 dep_tristate 'Realtek 8169 Gigabit Ethernet support' CONFIG_R8169 $CONFIG_PCI
-dep_tristate 'SysKonnect SK-98xx and SK-95xx Gigabit Ethernet Adapter family support' CONFIG_SK98LIN $CONFIG_PCI
+dep_tristate 'Marvell Yukon Chipset / SysKonnect SK-98xx Support' CONFIG_SK98LIN $CONFIG_PCI
+if [ "$CONFIG_SK98LIN" != "n" ]; then
+   bool '  3Com 3C940/3C941 Gigabit Ethernet Adapter' CONFIG_SK98LIN_T1
+   bool '  Allied Telesyn AT-29xx Gigabit Ethernet Adapter' CONFIG_SK98LIN_T3
+   bool '  CNet N-Way Gigabit Ethernet Adapter' CONFIG_SK98LIN_T8
+   bool '  D-Link DGE-530T Gigabit Ethernet Adapter' CONFIG_SK98LIN_T6
+   bool '  Linksys EG10xx Ethernet Server Adapter' CONFIG_SK98LIN_T9
+   bool '  Marvell RDK-80xx Adapter' CONFIG_SK98LIN_T4
+   bool '  Marvell Yukon Gigabit Ethernet Adapter' CONFIG_SK98LIN_T7
+   bool '  SysKonnect SK-98xx Server Gigabit Adapter' CONFIG_SK98LIN_T2
+   bool '  SysKonnect SK-98xx V2.0 Gigabit Ethernet Adapter' CONFIG_SK98LIN_T5
+fi
 dep_tristate 'Broadcom Tigon3 support' CONFIG_TIGON3 $CONFIG_PCI
 
 if [ "$CONFIG_MOMENCO_OCELOT_C" = "y" -o "$CONFIG_MOMENCO_JAGUAR_ATX" = "y" ]; then
diff -Nru a/drivers/net/sk98lin/Makefile b/drivers/net/sk98lin/Makefile
--- a/drivers/net/sk98lin/Makefile	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/Makefile	Wed Sep  3 22:38:48 2003
@@ -3,11 +3,32 @@
 # Makefile for the SysKonnect SK-98xx device driver.
 #
 
+#
+# Standalone driver params
+# SKPARAM += -DSK_KERNEL_24
+# SKPARAM += -DSK_KERNEL_24_26
+# SKPARAM += -DSK_KERNEL_26
+# SKPARAM += -DSK_KERNEL_22_24
+
 O_TARGET := sk98lin.o
 
-obj-y :=     skge.o skaddr.o skgehwt.o skgeinit.o skgepnmi.o skgesirq.o \
-             ski2c.o sklm80.o skqueue.o skrlmt.o sktimer.o skvpd.o \
-             skxmac2.o skproc.o skcsum.o
+obj-y :=	\
+		skge.o		\
+		skdim.o		\
+		skaddr.o	\
+		skgehwt.o	\
+		skgeinit.o	\
+		skgepnmi.o	\
+		skgesirq.o	\
+		ski2c.o		\
+		sklm80.o	\
+		skqueue.o	\
+		skrlmt.o	\
+		sktimer.o	\
+		skvpd.o		\
+		skxmac2.o	\
+		skproc.o	\
+		skcsum.o
 obj-m := $(O_TARGET)
 
 # DBGDEF =  \
@@ -57,7 +78,7 @@
 # SK_DBGCAT_DRV_INT_SRC         0x04000000      interrupts sources
 # SK_DBGCAT_DRV_EVENT           0x08000000      driver events
 
-EXTRA_CFLAGS += -I. -DSK_USE_CSUM $(DBGDEF)
+EXTRA_CFLAGS += -I. -DSK_USE_CSUM -DGENESIS -DYUKON $(DBGDEF) $(SKPARAM)
 
 include $(TOPDIR)/Rules.make
 
diff -Nru a/drivers/net/sk98lin/h/lm80.h b/drivers/net/sk98lin/h/lm80.h
--- a/drivers/net/sk98lin/h/lm80.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/lm80.h	Wed Sep  3 22:38:48 2003
@@ -1,9 +1,9 @@
 /******************************************************************************
  *
  * Name:	lm80.h	
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.4 $
- * Date:	$Date: 2002/04/25 11:04:10 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.6 $
+ * Date:	$Date: 2003/05/13 17:26:52 $
  * Purpose:	Contains all defines for the LM80 Chip
  *		(National Semiconductor).
  *
@@ -11,7 +11,8 @@
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,13 @@
  *
  * History:
  *	$Log: lm80.h,v $
+ *	Revision 1.6  2003/05/13 17:26:52  mkarl
+ *	Editorial changes.
+ *	
+ *	Revision 1.5  2003/03/31 07:15:18  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
  *	Revision 1.4  2002/04/25 11:04:10  rschmidt
  *	Editorial changes
  *	
@@ -55,8 +63,8 @@
  *
  * All registers are 8 bit wide
  */
-#define	LM80_CFG			0x00	/* Configuration Register */
-#define	LM80_ISRC_1			0x01	/* Interrupt Status Register 1 */
+#define LM80_CFG			0x00	/* Configuration Register */
+#define LM80_ISRC_1			0x01	/* Interrupt Status Register 1 */
 #define LM80_ISRC_2			0x02	/* Interrupt Status Register 2 */
 #define LM80_IMSK_1			0x03	/* Interrupt Mask Register 1 */
 #define LM80_IMSK_2			0x04	/* Interrupt Mask Register 2 */
@@ -93,8 +101,8 @@
 #define LM80_THOT_LIM_LO	0x39	/* hot temperature limit (low) */
 #define LM80_TOS_LIM_UP		0x3a	/* OS temperature limit (high) */
 #define LM80_TOS_LIM_LO		0x3b	/* OS temperature limit (low) */
-#define	LM80_FAN1_COUNT_LIM	0x3c	/* Fan 1 count limit (high) */
-#define	LM80_FAN2_COUNT_LIM	0x3d	/* Fan 2 count limit (low) */
+#define LM80_FAN1_COUNT_LIM	0x3c	/* Fan 1 count limit (high) */
+#define LM80_FAN2_COUNT_LIM	0x3d	/* Fan 2 count limit (low) */
 	/* 0x3e - 0x3f reserved	*/
 
 /*
@@ -124,7 +132,7 @@
 
 /*	LM80_ISRC_2		Interrupt Status Register 2 */
 /*	LM80_IMSK_2		Interrupt Mask Register 2 */
-#define	LM80_IS_TEMP		(1<<0)	/* HOT temperature limit exceeded */
+#define LM80_IS_TEMP		(1<<0)	/* HOT temperature limit exceeded */
 #define LM80_IS_BTI			(1<<1)	/* state of BTI# pin */
 #define LM80_IS_FAN1		(1<<2)	/* count limit exceeded for Fan 1 */
 #define LM80_IS_FAN2		(1<<3)	/* count limit exceeded for Fan 2 */
@@ -143,7 +151,7 @@
 #define LM80_FAN_RST_ENA	(1<<7)	/* sets RST_OUT#/OS# pins in RST mode */
 
 /*	LM80_TEMP_CTRL		OS# Config, Temp Res. Reg */
-#define	LM80_TEMP_OS_STAT	(1<<0)	/* mirrors the state of RST_OUT#/OS# */
+#define LM80_TEMP_OS_STAT	(1<<0)	/* mirrors the state of RST_OUT#/OS# */
 #define LM80_TEMP_OS_POL	(1<<1)	/* select OS# polarity */
 #define LM80_TEMP_OS_MODE	(1<<2)	/* selects Interrupt mode */
 #define LM80_TEMP_RES		(1<<3)	/* selects 9 or 11 bit temp resulution*/
diff -Nru a/drivers/net/sk98lin/h/skaddr.h b/drivers/net/sk98lin/h/skaddr.h
--- a/drivers/net/sk98lin/h/skaddr.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skaddr.h	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skaddr.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.26 $
- * Date:	$Date: 2002/11/15 07:24:42 $
+ * Project:	Gigabit Ethernet Adapters, ADDR-Modul
+ * Version:	$Revision: 1.29 $
+ * Date:	$Date: 2003/05/13 16:57:24 $
  * Purpose:	Header file for Address Management (MC, UC, Prom).
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,16 @@
  * History:
  *
  *	$Log: skaddr.h,v $
+ *	Revision 1.29  2003/05/13 16:57:24  mkarl
+ *	Changes for SLIM driver.
+ *	Editorial changes.
+ *	
+ *	Revision 1.28  2003/04/15 09:33:22  tschilli
+ *	Copyright messages changed.
+ *	
+ *	Revision 1.27  2003/04/14 15:55:11  tschilli
+ *	"#error C++ is not yet supported." removed.
+ *	
  *	Revision 1.26  2002/11/15 07:24:42  tschilli
  *	SK_ADDR_EQUAL macro fixed.
  *	
@@ -140,7 +151,6 @@
 #define __INC_SKADDR_H
 
 #ifdef __cplusplus
-#error C++ is not yet supported.
 extern "C" {
 #endif	/* cplusplus */
 
@@ -206,7 +216,7 @@
 
 /* Macros */
 
-#if 0
+#ifdef OLD_STUFF
 #ifndef SK_ADDR_EQUAL
 /*
  * "&" instead of "&&" allows better optimization on IA-64.
@@ -231,16 +241,18 @@
 #ifndef SK_ADDR_EQUAL
 #ifndef SK_ADDR_DWORD_COMPARE
 #define SK_ADDR_EQUAL(A1,A2)	( \
-	(((SK_U8 *)(A1))[5] == ((SK_U8 *)(A2))[5]) & \
-	(((SK_U8 *)(A1))[4] == ((SK_U8 *)(A2))[4]) & \
-	(((SK_U8 *)(A1))[3] == ((SK_U8 *)(A2))[3]) & \
-	(((SK_U8 *)(A1))[2] == ((SK_U8 *)(A2))[2]) & \
-	(((SK_U8 *)(A1))[1] == ((SK_U8 *)(A2))[1]) & \
-	(((SK_U8 *)(A1))[0] == ((SK_U8 *)(A2))[0]))
+	(((SK_U8 SK_FAR *)(A1))[5] == ((SK_U8 SK_FAR *)(A2))[5]) & \
+	(((SK_U8 SK_FAR *)(A1))[4] == ((SK_U8 SK_FAR *)(A2))[4]) & \
+	(((SK_U8 SK_FAR *)(A1))[3] == ((SK_U8 SK_FAR *)(A2))[3]) & \
+	(((SK_U8 SK_FAR *)(A1))[2] == ((SK_U8 SK_FAR *)(A2))[2]) & \
+	(((SK_U8 SK_FAR *)(A1))[1] == ((SK_U8 SK_FAR *)(A2))[1]) & \
+	(((SK_U8 SK_FAR *)(A1))[0] == ((SK_U8 SK_FAR *)(A2))[0]))
 #else	/* SK_ADDR_DWORD_COMPARE */
 #define SK_ADDR_EQUAL(A1,A2)	( \
-	(*(SK_U16 *)&(((SK_U8 *)(A1))[4]) == *(SK_U16 *)&(((SK_U8 *)(A2))[4])) && \
-	(*(SK_U32 *)&(((SK_U8 *)(A1))[0]) == *(SK_U32 *)&(((SK_U8 *)(A2))[0])))
+	(*(SK_U16 SK_FAR *)&(((SK_U8 SK_FAR *)(A1))[4]) == \
+	*(SK_U16 SK_FAR *)&(((SK_U8 SK_FAR *)(A2))[4])) && \
+	(*(SK_U32 SK_FAR *)&(((SK_U8 SK_FAR *)(A1))[0]) == \
+	*(SK_U32 SK_FAR *)&(((SK_U8 SK_FAR *)(A2))[0])))
 #endif	/* SK_ADDR_DWORD_COMPARE */
 #endif	/* SK_ADDR_EQUAL */
 
@@ -382,7 +394,7 @@
 	SK_AC		*pAC,
 	SK_IOC		IoC,
 	SK_U32		PortNumber,
-	SK_MAC_ADDR	*pNewAddr,
+	SK_MAC_ADDR	SK_FAR *pNewAddr,
 	int		Flags);
 
 extern	int	SkAddrPromiscuousChange(
@@ -403,11 +415,13 @@
 	SK_U32	PortNumber,
 	int	NewPromMode);	
 
+#ifndef SK_SLIM
 extern	int	SkAddrSwap(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	SK_U32	FromPortNumber,
 	SK_U32	ToPortNumber);
+#endif
 
 #else	/* defined(SK_KR_PROTO)) */
 
diff -Nru a/drivers/net/sk98lin/h/skdebug.h b/drivers/net/sk98lin/h/skdebug.h
--- a/drivers/net/sk98lin/h/skdebug.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skdebug.h	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skdebug.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.12 $
- * Date:	$Date: 2002/07/15 15:37:13 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.14 $
+ * Date:	$Date: 2003/05/13 17:26:00 $
  * Purpose:	SK specific DEBUG support
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -25,6 +26,12 @@
  *
  * History:
  *	$Log: skdebug.h,v $
+ *	Revision 1.14  2003/05/13 17:26:00  mkarl
+ *	Editorial changes.
+ *	
+ *	Revision 1.13  2003/03/31 07:16:39  mkarl
+ *	Corrected Copyright.
+ *	
  *	Revision 1.12  2002/07/15 15:37:13  rschmidt
  *	Power Management support
  *	Editorial changes
diff -Nru a/drivers/net/sk98lin/h/skdrv1st.h b/drivers/net/sk98lin/h/skdrv1st.h
--- a/drivers/net/sk98lin/h/skdrv1st.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skdrv1st.h	Wed Sep  3 22:38:48 2003
@@ -2,16 +2,15 @@
  *
  * Name:	skdrv1st.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.9.2.2 $
- * Date:	$Date: 2001/12/07 12:06:42 $
+ * Version:	$Revision: 1.1 $
+ * Date:	$Date: 2003/07/21 07:22:43 $
  * Purpose:	First header file for driver and all other modules
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,30 @@
  * History:
  *
  *	$Log: skdrv1st.h,v $
+ *	Revision 1.1  2003/07/21 07:22:43  rroesler
+ *	Fix: Re-Enter after CVS crash
+ *	
+ *	Revision 1.15  2003/07/17 14:54:09  rroesler
+ *	Fix: Corrected SK_PNMI_READ macros to copy right amount of bytes
+ *	
+ *	Revision 1.14  2003/06/03 14:36:32  mlindner
+ *	Add: Additions for SK_SLIM
+ *	
+ *	Revision 1.13  2003/05/26 14:03:06  mlindner
+ *	Add: Support for SLIM skaddr
+ *	
+ *	Revision 1.12  2003/05/26 12:56:39  mlindner
+ *	Add: Support for Kernel 2.5/2.6
+ *	Add: New SkOsGetTimeCurrent function
+ *	Add: SK_PNMI_HUNDREDS_SEC definition
+ *	Fix: SK_TICKS_PER_SEC on Intel Itanium2
+ *	
+ *	Revision 1.11  2003/02/25 14:16:40  mlindner
+ *	Fix: Copyright statement
+ *	
+ *	Revision 1.10  2002/10/02 12:46:02  mlindner
+ *	Add: Support for Yukon
+ *	
  *	Revision 1.9.2.2  2001/12/07 12:06:42  mlindner
  *	Fix: malloc -> slab changes
  *	
@@ -89,19 +112,20 @@
 
 /* Check kernel version */
 #include <linux/version.h>
-#if (LINUX_VERSION_CODE > 0x020300)
-#endif
 
 typedef struct s_AC	SK_AC;
 
+/* Set card versions */
+#define SK_FAR
+
 /* override some default functions with optimized linux functions */
 
 #define SK_PNMI_STORE_U16(p,v)		memcpy((char*)(p),(char*)&(v),2)
 #define SK_PNMI_STORE_U32(p,v)		memcpy((char*)(p),(char*)&(v),4)
 #define SK_PNMI_STORE_U64(p,v)		memcpy((char*)(p),(char*)&(v),8)
 #define SK_PNMI_READ_U16(p,v)		memcpy((char*)&(v),(char*)(p),2)
-#define SK_PNMI_READ_U32(p,v)		memcpy((char*)&(v),(char*)(p),2)
-#define SK_PNMI_READ_U64(p,v)		memcpy((char*)&(v),(char*)(p),2)
+#define SK_PNMI_READ_U32(p,v)		memcpy((char*)&(v),(char*)(p),4)
+#define SK_PNMI_READ_U64(p,v)		memcpy((char*)&(v),(char*)(p),8)
 
 #define SkCsCalculateChecksum(p,l)	((~ip_compute_csum(p, l)) & 0xffff)
 
@@ -150,7 +174,7 @@
 
 
 /* we use gethrtime(), return unit: nanoseconds */
-#define SK_TICKS_PER_SEC	HZ
+#define SK_TICKS_PER_SEC	100
 
 #define	SK_MEM_MAPPED_IO
 
diff -Nru a/drivers/net/sk98lin/h/skdrv2nd.h b/drivers/net/sk98lin/h/skdrv2nd.h
--- a/drivers/net/sk98lin/h/skdrv2nd.h	Wed Sep  3 22:38:49 2003
+++ b/drivers/net/sk98lin/h/skdrv2nd.h	Wed Sep  3 22:38:49 2003
@@ -2,16 +2,15 @@
  *
  * Name:	skdrv2nd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.12.2.2 $
- * Date:	$Date: 2001/09/05 12:14:50 $
+ * Version:	$Revision: 1.3 $
+ * Date:	$Date: 2003/08/12 16:51:18 $
  * Purpose:	Second header file for driver and all other modules
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,40 @@
  * History:
  *
  *	$Log: skdrv2nd.h,v $
+ *	Revision 1.3  2003/08/12 16:51:18  mlindner
+ *	Fix: UDP and TCP Proto checks
+ *	Fix: UDP header offset
+ *	
+ *	Revision 1.2  2003/08/07 10:50:54  mlindner
+ *	Add: Speed and HW-Csum support for Yukon Lite chipset
+ *	
+ *	Revision 1.1  2003/07/21 07:25:29  rroesler
+ *	Fix: Re-Enter after CVS crash
+ *	
+ *	Revision 1.19  2003/07/07 09:53:10  rroesler
+ *	Fix: Removed proprietary RxTx defines and used the ones from skgehw.h instead
+ *	
+ *	Revision 1.18  2003/06/12 07:54:14  mlindner
+ *	Fix: Changed Descriptor Alignment to 64 Byte
+ *	
+ *	Revision 1.17  2003/05/26 12:56:39  mlindner
+ *	Add: Support for Kernel 2.5/2.6
+ *	Add: New SkOsGetTimeCurrent function
+ *	Add: SK_PNMI_HUNDREDS_SEC definition
+ *	Fix: SK_TICKS_PER_SEC on Intel Itanium2
+ *	
+ *	Revision 1.16  2003/03/21 14:56:18  rroesler
+ *	Added code regarding interrupt moderation
+ *	
+ *	Revision 1.15  2003/02/25 14:16:40  mlindner
+ *	Fix: Copyright statement
+ *	
+ *	Revision 1.14  2003/02/25 13:26:26  mlindner
+ *	Add: Support for various vendors
+ *	
+ *	Revision 1.13  2002/10/02 12:46:02  mlindner
+ *	Add: Support for Yukon
+ *	
  *	Revision 1.12.2.2  2001/09/05 12:14:50  mlindner
  *	add: New hardware revision int
  *	
@@ -114,7 +147,54 @@
 #include "h/skrlmt.h"
 #include "h/skgedrv.h"
 
-/* global function prototypes ******************************************/
+#define SK_PCI_ISCOMPLIANT(result, pdev) {     \
+    result = SK_FALSE; /* default */     \
+    /* 3Com (0x10b7) */     \
+    if (pdev->vendor == 0x10b7) {     \
+        /* Gigabit Ethernet Adapter (0x1700) */     \
+        if ((pdev->device == 0x1700)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* SysKonnect (0x1148) */     \
+    } else if (pdev->vendor == 0x1148) {     \
+        /* SK-98xx Gigabit Ethernet Server Adapter (0x4300) */     \
+        /* SK-98xx V2.0 Gigabit Ethernet Adapter (0x4320) */     \
+        if ((pdev->device == 0x4300) || \
+            (pdev->device == 0x4320)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* D-Link (0x1186) */     \
+    } else if (pdev->vendor == 0x1186) {     \
+        /* Gigabit Ethernet Adapter (0x4c00) */     \
+        if ((pdev->device == 0x4c00)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* Marvell (0x11ab) */     \
+    } else if (pdev->vendor == 0x11ab) {     \
+        /* Gigabit Ethernet Adapter (0x4320) */     \
+        if ((pdev->device == 0x4320)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* CNet (0x1371) */     \
+    } else if (pdev->vendor == 0x1371) {     \
+        /* GigaCard Network Adapter (0x434e) */     \
+        if ((pdev->device == 0x434e)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* Linksys (0x1737) */     \
+    } else if (pdev->vendor == 0x1737) {     \
+        /* Gigabit Network Adapter (0x1032) */     \
+        /* Gigabit Network Adapter (0x1064) */     \
+        if ((pdev->device == 0x1032) || \
+            (pdev->device == 0x1064)) { \
+            result = SK_TRUE;     \
+        }     \
+    } else {     \
+        result = SK_FALSE;     \
+    }     \
+}
+
+
 extern SK_MBUF		*SkDrvAllocRlmtMbuf(SK_AC*, SK_IOC, unsigned);
 extern void		SkDrvFreeRlmtMbuf(SK_AC*, SK_IOC, SK_MBUF*);
 extern SK_U64		SkOsGetTime(SK_AC*);
@@ -139,6 +219,25 @@
 };
 
 
+/*
+ * Time macros
+ */
+#if SK_TICKS_PER_SEC == 100
+#define SK_PNMI_HUNDREDS_SEC(t)	(t)
+#else
+#define SK_PNMI_HUNDREDS_SEC(t)	((((unsigned long)t) * 100) / \
+										(SK_TICKS_PER_SEC))
+#endif
+
+/*
+ * New SkOsGetTime
+ */
+#define SkOsGetTimeCurrent(pAC, pUsec) {\
+	struct timeval t;\
+	do_gettimeofday(&t);\
+	*pUsec = ((((t.tv_sec) * 1000000L)+t.tv_usec)/10000);\
+}
+
 
 /*
  * ioctl definitions
@@ -147,6 +246,7 @@
 #define		SK_IOCTL_GETMIB		(SK_IOCTL_BASE + 0)
 #define		SK_IOCTL_SETMIB		(SK_IOCTL_BASE + 1)
 #define		SK_IOCTL_PRESETMIB	(SK_IOCTL_BASE + 2)
+#define		SK_IOCTL_GEN		(SK_IOCTL_BASE + 3)
 
 typedef struct s_IOCTL	SK_GE_IOCTL;
 
@@ -181,7 +281,7 @@
 /*
  * alignment of rx/tx descriptors
  */
-#define DESCR_ALIGN	8
+#define DESCR_ALIGN	64
 
 /*
  * definitions for pnmi. TODO
@@ -194,6 +294,44 @@
 #define SK_DRIVER_SET_MTU(pAc,IoC,i,v)	0
 #define SK_DRIVER_PRESET_MTU(pAc,IoC,i,v)	0
 
+/*
+** Interim definition of SK_DRV_TIMER placed in this file until 
+** common modules have boon finallized
+*/
+#define SK_DRV_TIMER			11 
+#define	SK_DRV_MODERATION_TIMER		1
+#define SK_DRV_MODERATION_TIMER_LENGTH  1000000  /* 1 second */
+#define SK_DRV_RX_CLEANUP_TIMER		2
+#define SK_DRV_RX_CLEANUP_TIMER_LENGTH	1000000	 /* 100 millisecs */
+
+/*
+** Definitions regarding transmitting frames 
+** any calculating any checksum.
+*/
+#define C_LEN_ETHERMAC_HEADER_DEST_ADDR 6
+#define C_LEN_ETHERMAC_HEADER_SRC_ADDR  6
+#define C_LEN_ETHERMAC_HEADER_LENTYPE   2
+#define C_LEN_ETHERMAC_HEADER           ( (C_LEN_ETHERMAC_HEADER_DEST_ADDR) + \
+                                          (C_LEN_ETHERMAC_HEADER_SRC_ADDR)  + \
+                                          (C_LEN_ETHERMAC_HEADER_LENTYPE) )
+
+#define C_LEN_ETHERMTU_MINSIZE          46
+#define C_LEN_ETHERMTU_MAXSIZE_STD      1500
+#define C_LEN_ETHERMTU_MAXSIZE_JUMBO    9000
+
+#define C_LEN_ETHERNET_MINSIZE          ( (C_LEN_ETHERMAC_HEADER) + \
+                                          (C_LEN_ETHERMTU_MINSIZE) )
+
+#define C_OFFSET_IPHEADER               C_LEN_ETHERMAC_HEADER
+#define C_OFFSET_IPHEADER_IPPROTO       9
+#define C_OFFSET_TCPHEADER_TCPCS        16
+#define C_OFFSET_UDPHEADER_UDPCS        6
+
+#define C_OFFSET_IPPROTO                ( (C_LEN_ETHERMAC_HEADER) + \
+                                          (C_OFFSET_IPHEADER_IPPROTO) )
+
+#define C_PROTO_ID_UDP                  17       /* refer to RFC 790 or Stevens'   */
+#define C_PROTO_ID_TCP                  6        /* TCP/IP illustrated for details */
 
 /* TX and RX descriptors *****************************************************/
 
@@ -228,160 +366,42 @@
 	struct sk_buff	*pMBuf;		/* Pointer to Linux' socket buffer */
 };
 
+/* Used interrupt bits in the interrupts source register *********************/
 
-/* definition of flags in descriptor control field */
-#define	RX_CTRL_OWN_BMU 	UINT32_C(0x80000000)
-#define	RX_CTRL_STF		UINT32_C(0x40000000)
-#define	RX_CTRL_EOF		UINT32_C(0x20000000)
-#define	RX_CTRL_EOB_IRQ		UINT32_C(0x10000000)
-#define	RX_CTRL_EOF_IRQ		UINT32_C(0x08000000)
-#define RX_CTRL_DEV_NULL	UINT32_C(0x04000000)
-#define RX_CTRL_STAT_VALID	UINT32_C(0x02000000)
-#define RX_CTRL_TIME_VALID	UINT32_C(0x01000000)
-#define RX_CTRL_CHECK_DEFAULT	UINT32_C(0x00550000)
-#define RX_CTRL_CHECK_CSUM	UINT32_C(0x00560000)
-#define	RX_CTRL_LEN_MASK	UINT32_C(0x0000FFFF)
-
-#define	TX_CTRL_OWN_BMU 	UINT32_C(0x80000000)
-#define	TX_CTRL_STF		UINT32_C(0x40000000)
-#define	TX_CTRL_EOF		UINT32_C(0x20000000)
-#define	TX_CTRL_EOB_IRQ		UINT32_C(0x10000000)
-#define	TX_CTRL_EOF_IRQ		UINT32_C(0x08000000)
-#define TX_CTRL_ST_FWD		UINT32_C(0x04000000)
-#define TX_CTRL_DISAB_CRC	UINT32_C(0x02000000)
-#define TX_CTRL_SOFTWARE	UINT32_C(0x01000000)
-#define TX_CTRL_CHECK_DEFAULT	UINT32_C(0x00550000)
-#define TX_CTRL_CHECK_CSUM	UINT32_C(0x00560000)
-#define	TX_CTRL_LEN_MASK	UINT32_C(0x0000FFFF)
-
-
-
-/* The offsets of registers in the TX and RX queue control io area ***********/
-
-#define RX_Q_BUF_CTRL_CNT	0x00
-#define RX_Q_NEXT_DESCR_LOW	0x04
-#define RX_Q_BUF_ADDR_LOW	0x08
-#define RX_Q_BUF_ADDR_HIGH	0x0c
-#define RX_Q_FRAME_STAT		0x10
-#define RX_Q_TIME_STAMP		0x14
-#define RX_Q_CSUM_1_2		0x18
-#define RX_Q_CSUM_START_1_2	0x1c
-#define RX_Q_CUR_DESCR_LOW	0x20
-#define RX_Q_DESCR_HIGH		0x24
-#define RX_Q_CUR_ADDR_LOW	0x28
-#define RX_Q_CUR_ADDR_HIGH	0x2c
-#define RX_Q_CUR_BYTE_CNT	0x30
-#define RX_Q_CTRL		0x34
-#define RX_Q_FLAG		0x38
-#define RX_Q_TEST1		0x3c
-#define RX_Q_TEST2		0x40
-#define RX_Q_TEST3		0x44
-
-#define TX_Q_BUF_CTRL_CNT	0x00
-#define TX_Q_NEXT_DESCR_LOW	0x04
-#define TX_Q_BUF_ADDR_LOW	0x08
-#define TX_Q_BUF_ADDR_HIGH	0x0c
-#define TX_Q_FRAME_STAT		0x10
-#define TX_Q_CSUM_START		0x14
-#define TX_Q_CSUM_START_POS	0x18
-#define TX_Q_RESERVED		0x1c
-#define TX_Q_CUR_DESCR_LOW	0x20
-#define TX_Q_DESCR_HIGH		0x24
-#define TX_Q_CUR_ADDR_LOW	0x28
-#define TX_Q_CUR_ADDR_HIGH	0x2c
-#define TX_Q_CUR_BYTE_CNT	0x30
-#define TX_Q_CTRL		0x34
-#define TX_Q_FLAG		0x38
-#define TX_Q_TEST1		0x3c
-#define TX_Q_TEST2		0x40
-#define TX_Q_TEST3		0x44
-
-/* definition of flags in the queue control field */
-#define RX_Q_CTRL_POLL_ON	0x00000080
-#define RX_Q_CTRL_POLL_OFF	0x00000040
-#define RX_Q_CTRL_STOP		0x00000020
-#define RX_Q_CTRL_START		0x00000010
-#define RX_Q_CTRL_CLR_I_PAR	0x00000008
-#define RX_Q_CTRL_CLR_I_EOB	0x00000004
-#define RX_Q_CTRL_CLR_I_EOF	0x00000002
-#define RX_Q_CTRL_CLR_I_ERR	0x00000001
-
-#define TX_Q_CTRL_POLL_ON	0x00000080
-#define TX_Q_CTRL_POLL_OFF	0x00000040
-#define TX_Q_CTRL_STOP		0x00000020
-#define TX_Q_CTRL_START		0x00000010
-#define TX_Q_CTRL_CLR_I_EOB	0x00000004
-#define TX_Q_CTRL_CLR_I_EOF	0x00000002
-#define TX_Q_CTRL_CLR_I_ERR	0x00000001
-
-
-/* Interrupt bits in the interrupts source register **************************/
-#define IRQ_HW_ERROR		0x80000000
-#define IRQ_RESERVED		0x40000000
-#define IRQ_PKT_TOUT_RX1	0x20000000
-#define IRQ_PKT_TOUT_RX2	0x10000000
-#define IRQ_PKT_TOUT_TX1	0x08000000
-#define IRQ_PKT_TOUT_TX2	0x04000000
-#define IRQ_I2C_READY		0x02000000
-#define IRQ_SW			0x01000000
-#define IRQ_EXTERNAL_REG	0x00800000
-#define IRQ_TIMER		0x00400000
-#define IRQ_MAC1		0x00200000
-#define IRQ_LINK_SYNC_C_M1	0x00100000
-#define IRQ_MAC2		0x00080000
-#define IRQ_LINK_SYNC_C_M2	0x00040000
-#define IRQ_EOB_RX1		0x00020000
-#define IRQ_EOF_RX1		0x00010000
-#define IRQ_CHK_RX1		0x00008000
-#define IRQ_EOB_RX2		0x00004000
-#define IRQ_EOF_RX2		0x00002000
-#define IRQ_CHK_RX2		0x00001000
-#define IRQ_EOB_SY_TX1		0x00000800
-#define IRQ_EOF_SY_TX1		0x00000400
-#define IRQ_CHK_SY_TX1		0x00000200
-#define IRQ_EOB_AS_TX1		0x00000100
-#define IRQ_EOF_AS_TX1		0x00000080
-#define IRQ_CHK_AS_TX1		0x00000040
-#define IRQ_EOB_SY_TX2		0x00000020
-#define IRQ_EOF_SY_TX2		0x00000010
-#define IRQ_CHK_SY_TX2		0x00000008
-#define IRQ_EOB_AS_TX2		0x00000004
-#define IRQ_EOF_AS_TX2		0x00000002
-#define IRQ_CHK_AS_TX2		0x00000001
-
-#define DRIVER_IRQS	(IRQ_SW | IRQ_EOF_RX1 | IRQ_EOF_RX2 | \
-			IRQ_EOF_SY_TX1 | IRQ_EOF_AS_TX1 | \
-			IRQ_EOF_SY_TX2 | IRQ_EOF_AS_TX2)
-
-#define SPECIAL_IRQS	(IRQ_HW_ERROR | IRQ_PKT_TOUT_RX1 | IRQ_PKT_TOUT_RX2 | \
-			IRQ_PKT_TOUT_TX1 | IRQ_PKT_TOUT_TX2 | \
-			IRQ_I2C_READY | IRQ_EXTERNAL_REG | IRQ_TIMER | \
-			IRQ_MAC1 | IRQ_LINK_SYNC_C_M1 | \
-			IRQ_MAC2 | IRQ_LINK_SYNC_C_M2 | \
-			IRQ_CHK_RX1 | IRQ_CHK_RX2 | \
-			IRQ_CHK_SY_TX1 | IRQ_CHK_AS_TX1 | \
-			IRQ_CHK_SY_TX2 | IRQ_CHK_AS_TX2)
-
-#define IRQ_MASK	(IRQ_SW | IRQ_EOB_RX1 | IRQ_EOF_RX1 | \
-			IRQ_EOB_RX2 | IRQ_EOF_RX2 | \
-			IRQ_EOB_SY_TX1 | IRQ_EOF_SY_TX1 | \
-			IRQ_EOB_AS_TX1 | IRQ_EOF_AS_TX1 | \
-			IRQ_EOB_SY_TX2 | IRQ_EOF_SY_TX2 | \
-			IRQ_EOB_AS_TX2 | IRQ_EOF_AS_TX2 | \
-			IRQ_HW_ERROR | IRQ_PKT_TOUT_RX1 | IRQ_PKT_TOUT_RX2 | \
-			IRQ_PKT_TOUT_TX1 | IRQ_PKT_TOUT_TX2 | \
-			IRQ_I2C_READY | IRQ_EXTERNAL_REG | IRQ_TIMER | \
-			IRQ_MAC1 | \
-			IRQ_MAC2 | \
-			IRQ_CHK_RX1 | IRQ_CHK_RX2 | \
-			IRQ_CHK_SY_TX1 | IRQ_CHK_AS_TX1 | \
-			IRQ_CHK_SY_TX2 | IRQ_CHK_AS_TX2)
+#define DRIVER_IRQS	((IS_IRQ_SW)   | \
+			(IS_R1_F)      |(IS_R2_F)  | \
+			(IS_XS1_F)     |(IS_XA1_F) | \
+			(IS_XS2_F)     |(IS_XA2_F))
+
+#define SPECIAL_IRQS	((IS_HW_ERR)   |(IS_I2C_READY)  | \
+			(IS_EXT_REG)   |(IS_TIMINT)     | \
+			(IS_PA_TO_RX1) |(IS_PA_TO_RX2)  | \
+			(IS_PA_TO_TX1) |(IS_PA_TO_TX2)  | \
+			(IS_MAC1)      |(IS_LNK_SYNC_M1)| \
+			(IS_MAC2)      |(IS_LNK_SYNC_M2)| \
+			(IS_R1_C)      |(IS_R2_C)       | \
+			(IS_XS1_C)     |(IS_XA1_C)      | \
+			(IS_XS2_C)     |(IS_XA2_C))
+
+#define IRQ_MASK	((IS_IRQ_SW)   | \
+			(IS_R1_B)      |(IS_R1_F)     |(IS_R2_B) |(IS_R2_F) | \
+			(IS_XS1_B)     |(IS_XS1_F)    |(IS_XA1_B)|(IS_XA1_F)| \
+			(IS_XS2_B)     |(IS_XS2_F)    |(IS_XA2_B)|(IS_XA2_F)| \
+			(IS_HW_ERR)    |(IS_I2C_READY)| \
+			(IS_EXT_REG)   |(IS_TIMINT)   | \
+			(IS_PA_TO_RX1) |(IS_PA_TO_RX2)| \
+			(IS_PA_TO_TX1) |(IS_PA_TO_TX2)| \
+			(IS_MAC1)      |(IS_MAC2)     | \
+			(IS_R1_C)      |(IS_R2_C)     | \
+			(IS_XS1_C)     |(IS_XA1_C)    | \
+			(IS_XS2_C)     |(IS_XA2_C))
 
-#define IRQ_HWE_MASK	0x00000FFF /* enable all HW irqs */
+#define IRQ_HWE_MASK	(IS_ERR_MSK) /* enable all HW irqs */
 
 typedef struct s_DevNet DEV_NET;
 
 struct s_DevNet {
+	struct			proc_dir_entry *proc;
 	int             PortNr;
 	int             NetNr;
 	int             Mtu;
@@ -420,6 +440,55 @@
 	int		PortIndex;	/* index number of port (0 or 1) */
 };
 
+/* Definitions needed for interrupt moderation *******************************/
+
+#define IRQ_EOF_AS_TX     ((IS_XA1_F)     | (IS_XA2_F))
+#define IRQ_EOF_SY_TX     ((IS_XS1_F)     | (IS_XS2_F))
+#define IRQ_MASK_TX_ONLY  ((IRQ_EOF_AS_TX)| (IRQ_EOF_SY_TX))
+#define IRQ_MASK_RX_ONLY  ((IS_R1_F)      | (IS_R2_F))
+#define IRQ_MASK_SP_ONLY  (SPECIAL_IRQS)
+#define IRQ_MASK_TX_RX    ((IRQ_MASK_TX_ONLY)| (IRQ_MASK_RX_ONLY))
+#define IRQ_MASK_SP_RX    ((SPECIAL_IRQS)    | (IRQ_MASK_RX_ONLY))
+#define IRQ_MASK_SP_TX    ((SPECIAL_IRQS)    | (IRQ_MASK_TX_ONLY))
+#define IRQ_MASK_RX_TX_SP ((SPECIAL_IRQS)    | (IRQ_MASK_TX_RX))
+
+#define C_INT_MOD_NONE                 1
+#define C_INT_MOD_STATIC               2
+#define C_INT_MOD_DYNAMIC              4
+
+#define C_CLK_FREQ_GENESIS      53215000 /* shorter: 53.125 MHz  */
+#define C_CLK_FREQ_YUKON        78215000 /* shorter: 78.125 MHz  */
+
+#define C_INTS_PER_SEC_DEFAULT      2000 
+#define C_INT_MOD_ENABLE_PERCENTAGE   50 /* if higher 50% enable */
+#define C_INT_MOD_DISABLE_PERCENTAGE  50 /* if lower 50% disable */
+
+typedef struct s_DynIrqModInfo  DIM_INFO;
+struct s_DynIrqModInfo {
+	unsigned long   PrevTimeVal;
+	unsigned int    PrevSysLoad;
+	unsigned int    PrevUsedTime;
+	unsigned int    PrevTotalTime;
+	int             PrevUsedDescrRatio;
+	int             NbrProcessedDescr;
+        SK_U64          PrevPort0RxIntrCts;
+        SK_U64          PrevPort1RxIntrCts;
+        SK_U64          PrevPort0TxIntrCts;
+        SK_U64          PrevPort1TxIntrCts;
+	SK_BOOL         ModJustEnabled;     /* Moderation just enabled yes/no */
+
+	int             MaxModIntsPerSec;            /* Moderation Threshold */
+	int             MaxModIntsPerSecUpperLimit;  /* Upper limit for DIM  */
+	int             MaxModIntsPerSecLowerLimit;  /* Lower limit for DIM  */
+
+	long            MaskIrqModeration;   /* ModIrqType (eg. 'TxRx')      */
+	SK_BOOL         DisplayStats;        /* Stats yes/no                 */
+	SK_BOOL         AutoSizing;          /* Resize DIM-timer on/off      */
+	int             IntModTypeSelect;    /* EnableIntMod (eg. 'dynamic') */
+
+	SK_TIMER        ModTimer; /* just some timer */
+};
+
 typedef struct s_PerStrm	PER_STRM;
 
 #define SK_ALLOC_IRQ	0x00000001
@@ -487,11 +556,16 @@
 	SK_U32		CsOfs;		/* for checksum calculation */
 
 	SK_BOOL		CheckQueue;	/* check event queue soon */
+	SK_TIMER        DrvCleanupTimer;/* to check for pending descriptors */
+	DIM_INFO        DynIrqModInfo;  /* all data related to DIM */
 
 	/* Only for tests */
 	int		PortUp;
 	int		PortDown;
-
+	int		ChipsetType;	/*  Chipset family type 
+							 *  0 == Genesis family support
+							 *  1 == Yukon family support
+							 */
 };
 
 
diff -Nru a/drivers/net/sk98lin/h/skerror.h b/drivers/net/sk98lin/h/skerror.h
--- a/drivers/net/sk98lin/h/skerror.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skerror.h	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skerror.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.5 $
- * Date:	$Date: 2002/04/25 11:05:10 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.7 $
+ * Date:	$Date: 2003/05/13 17:25:13 $
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -25,6 +26,12 @@
  *
  * History:
  *	$Log: skerror.h,v $
+ *	Revision 1.7  2003/05/13 17:25:13  mkarl
+ *	Editorial changes.
+ *	
+ *	Revision 1.6  2003/03/31 07:17:48  mkarl
+ *	Corrected Copyright.
+ *	
  *	Revision 1.5  2002/04/25 11:05:10  rschmidt
  *	Editorial changes
  *	
diff -Nru a/drivers/net/sk98lin/h/skgedrv.h b/drivers/net/sk98lin/h/skgedrv.h
--- a/drivers/net/sk98lin/h/skgedrv.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skgedrv.h	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skgedrv.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.6 $
- * Date:	$Date: 2002/07/15 15:38:01 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.10 $
+ * Date:	$Date: 2003/07/04 12:25:01 $
  * Purpose:	Interface with the driver
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,20 @@
  * History:
  *
  *	$Log: skgedrv.h,v $
+ *	Revision 1.10  2003/07/04 12:25:01  rschmidt
+ *	Added event SK_DRV_DOWNSHIFT_DET for Downshift 4-Pair / 2-Pair
+ *	
+ *	Revision 1.9  2003/05/13 17:24:21  mkarl
+ *	Added events SK_DRV_LINK_UP and SK_DRV_LINK_DOWN for drivers not using
+ *	RLMT (SK_NO_RLMT).
+ *	Editorial changes.
+ *	
+ *	Revision 1.8  2003/03/31 07:18:54  mkarl
+ *	Corrected Copyright.
+ *	
+ *	Revision 1.7  2003/03/18 09:43:47  rroesler
+ *	Added new event for timer
+ *	
  *	Revision 1.6  2002/07/15 15:38:01  rschmidt
  *	Power Management support
  *	Editorial changes
@@ -68,5 +83,10 @@
 #define SK_DRV_PORT_FAIL		 8	/* One port fails */
 #define SK_DRV_SWITCH_INTERN	 9	/* Port switch by the driver itself */
 #define SK_DRV_POWER_DOWN		10	/* Power down mode */
-
-#endif	/* __INC_SKGEDRV_H_ */
+#define SK_DRV_TIMER			11	/* Timer for free use */
+#ifdef SK_NO_RLMT
+#define SK_DRV_LINK_UP  		12	/* Link Up event for driver */
+#define SK_DRV_LINK_DOWN		13	/* Link Down event for driver */
+#endif
+#define SK_DRV_DOWNSHIFT_DET	14	/* Downshift 4-Pair / 2-Pair (YUKON only) */
+#endif /* __INC_SKGEDRV_H_ */
diff -Nru a/drivers/net/sk98lin/h/skgehw.h b/drivers/net/sk98lin/h/skgehw.h
--- a/drivers/net/sk98lin/h/skgehw.h	Wed Sep  3 22:38:49 2003
+++ b/drivers/net/sk98lin/h/skgehw.h	Wed Sep  3 22:38:49 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skgehw.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.48 $
- * Date:	$Date: 2002/12/05 10:25:11 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.53 $
+ * Date:	$Date: 2003/07/04 12:39:01 $
  * Purpose:	Defines and Macros for the Gigabit Ethernet Adapter Product Family
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -25,6 +26,27 @@
  *
  * History:
  * $Log: skgehw.h,v $
+ * Revision 1.53  2003/07/04 12:39:01  rschmidt
+ * Added SK_FAR to pointers in XM_IN32() and GM_IN32() macros (for PXE)
+ * Editorial changes
+ *
+ * Revision 1.52  2003/05/13 17:16:36  mkarl
+ * Added SK_FAR for PXE.
+ * Editorial changes.
+ *
+ * Revision 1.51  2003/04/08 16:31:50  rschmidt
+ * Added defines for new Chip IDs (YUKON-Lite, YUKON-LP)
+ * Editorial changes
+ *
+ * Revision 1.50  2003/03/31 07:29:45  mkarl
+ * Corrected Copyright.
+ * Editorial changes.
+ *
+ * Revision 1.49  2003/01/28 09:43:49  rschmidt
+ * Added defines for PCI-Spec. 2.3 IRQ
+ * Added defines for CLK_RUN (YUKON-Lite)
+ * Editorial changes
+ *
  * Revision 1.48  2002/12/05 10:25:11  rschmidt
  * Added defines for Half Duplex Burst Mode On/Off
  * Added defines for Rx GMAC FIFO Flush feature
@@ -334,7 +356,7 @@
 #define PCI_SUB_ID		0x2e	/* 16 bit	Subsystem ID */
 #define PCI_BASE_ROM	0x30	/* 32 bit	Expansion ROM Base Address */
 #define PCI_CAP_PTR		0x34	/*  8 bit 	Capabilities Ptr */
-	/* Byte 35..3b:	reserved */
+	/* Byte 0x35..0x3b:	reserved */
 #define PCI_IRQ_LINE	0x3c	/*  8 bit	Interrupt Line */
 #define PCI_IRQ_PIN		0x3d	/*  8 bit	Interrupt Pin */
 #define PCI_MIN_GNT		0x3e	/*  8 bit	Min_Gnt */
@@ -354,7 +376,9 @@
 #define PCI_VPD_NITEM	0x51	/*  8 bit 	Next Item Ptr */
 #define PCI_VPD_ADR_REG	0x52	/* 16 bit 	VPD Address Register */
 #define PCI_VPD_DAT_REG	0x54	/* 32 bit 	VPD Data Register */
-	/* Byte 0x58..0xff:	reserved */
+	/* Byte 0x58..0x59:	reserved */
+#define PCI_SER_LD_CTRL	0x5a	/* 16 bit 	SEEPROM Loader Ctrl (YUKON only) */
+	/* Byte 0x5c..0xff:	reserved */
 
 /*
  * I2C Address (PCI Config)
@@ -362,13 +386,14 @@
  * Note: The temperature and voltage sensors are relocated on a different
  *	 I2C bus.
  */
-#define I2C_ADDR_VPD	0xA0	/* I2C address for the VPD EEPROM */
+#define I2C_ADDR_VPD	0xa0	/* I2C address for the VPD EEPROM */
 
 /*
  * Define Bits and Values of the registers
  */
 /*	PCI_COMMAND	16 bit	Command */
-								/* Bit 15..10:	reserved */
+								/* Bit 15..11:	reserved */
+#define PCI_INT_DIS		BIT_10S		/* Interrupt INTx# disable (PCI 2.3) */
 #define PCI_FBTEN		BIT_9S		/* Fast Back-To-Back enable */
 #define PCI_SERREN		BIT_8S		/* SERR enable */
 #define PCI_ADSTEP		BIT_7S		/* Address Stepping */
@@ -398,7 +423,8 @@
 #define PCI_UDF			BIT_6S		/* User Defined Features */
 #define PCI_66MHZCAP	BIT_5S		/* 66 MHz PCI bus clock capable */
 #define PCI_NEWCAP		BIT_4S		/* New cap. list implemented */
-								/* Bit  3.. 0:	reserved */
+#define PCI_INT_STAT	BIT_3S		/* Interrupt INTx# Status (PCI 2.3) */
+								/* Bit  2.. 0:	reserved */
 
 #define PCI_ERRBITS	(PCI_PERR | PCI_SERR | PCI_RMABORT | PCI_RTABORT |\
 			PCI_DATAPERR)
@@ -427,7 +453,7 @@
 #define PCI_MEM32BIT	(0L<<1)		/* Base addr anywhere in 32 Bit range */
 #define PCI_MEM1M		(1L<<1)		/* Base addr below 1 MegaByte */
 #define PCI_MEM64BIT	(2L<<1)		/* Base addr anywhere in 64 Bit range */
-#define PCI_MEMSPACE	BIT_0		/* Memory Space Indic. */
+#define PCI_MEMSPACE	BIT_0		/* Memory Space Indicator */
 
 /*	PCI_BASE_2ND	32 bit	2nd Base address */
 #define PCI_IOBASE		0xffffff00L	/* Bit 31.. 8:	I/O Base address */
@@ -436,8 +462,8 @@
 #define PCI_IOSPACE		BIT_0		/* I/O Space Indicator */
 
 /*	PCI_BASE_ROM	32 bit	Expansion ROM Base Address */
-#define PCI_ROMBASE		0xfffe0000L	/* Bit 31..17:	ROM BASE address (1st)*/
-#define PCI_ROMBASZ		(0x1cL<<14)	/* Bit 16..14:	Treat as BASE or SIZE */
+#define PCI_ROMBASE_MSK	0xfffe0000L	/* Bit 31..17:	ROM Base address */
+#define PCI_ROMBASE_SIZ	(0x1cL<<14)	/* Bit 16..14:	Treat as Base or Size */
 #define PCI_ROMSIZE		(0x38L<<11)	/* Bit 13..11:	ROM Size Requirements */
 									/* Bit 10.. 1:	reserved */
 #define PCI_ROMEN		BIT_0		/* Address Decode enable */
@@ -445,15 +471,15 @@
 /* Device Dependent Region */
 /*	PCI_OUR_REG_1		32 bit	Our Register 1 */
 									/* Bit 31..29:	reserved */
-#define PCI_PHY_COMA	BIT_28		/* Set PHY to Coma Mode */
-#define PCI_EN_CAL		BIT_27		/* Enable  PCI buffer strength calibr. */
-#define PCI_DIS_CAL		BIT_26		/* Disable PCI buffer strength calibr. */
+#define PCI_PHY_COMA	BIT_28		/* Set PHY to Coma Mode (YUKON only) */
+#define PCI_TEST_CAL	BIT_27		/* Test PCI buffer calib. (YUKON only) */
+#define PCI_EN_CAL		BIT_26		/* Enable PCI buffer calib. (YUKON only) */
 #define PCI_VIO			BIT_25		/* PCI I/O Voltage, 0 = 3.3V, 1 = 5V */
-#define PCI_EN_BOOT		BIT_24		/* Enable BOOT via ROM */
+#define PCI_DIS_BOOT	BIT_24		/* Disable BOOT via ROM */
 #define PCI_EN_IO		BIT_23		/* Mapping to I/O space */
-#define PCI_EN_FPROM	BIT_22		/* FLASH mapped to mem? */
-									/*		1 = Map Flash to Mem */
-									/*		0 = Disable addr. dec*/
+#define PCI_EN_FPROM	BIT_22		/* Enable FLASH mapping to memory */
+									/*		1 = Map Flash to memory */
+									/*		0 = Disable addr. dec */
 #define PCI_PAGESIZE	(3L<<20)	/* Bit 21..20:	FLASH Page Size	*/
 #define PCI_PAGE_16		(0L<<20)	/*		16 k pages	*/
 #define PCI_PAGE_32K	(1L<<20)	/*		32 k pages	*/
@@ -496,7 +522,7 @@
 
 /* Power Management Region */
 /*	PCI_PM_CAP_REG		16 bit	Power Management Capabilities */
-#define PCI_PME_SUP		(0x1f<<11)	/* Bit 15..11:	PM Event Support */
+#define PCI_PME_SUP_MSK	(0x1f<<11)	/* Bit 15..11:	PM Event Support Mask */
 #define PCI_PME_D3C_SUP	BIT_15S		/* PME from D3cold Support (if Vaux) */
 #define PCI_PME_D3H_SUP	BIT_14S		/* PME from D3hot Support */
 #define PCI_PME_D2_SUP	BIT_13S		/* PME from D2 Support */
@@ -525,8 +551,8 @@
 
 /* VPD Region */
 /*	PCI_VPD_ADR_REG		16 bit	VPD Address Register */
-#define PCI_VPD_FLAG	BIT_15S			/* starts VPD rd/wd cycle*/
-#define PCI_VPD_ADDR	0x3fffL		/* Bit 14.. 0:	VPD address */
+#define PCI_VPD_FLAG	BIT_15S		/* starts VPD rd/wr cycle */
+#define PCI_VPD_ADR_MSK	0x7fffL		/* Bit 14.. 0:	VPD address mask */
 
 /*	Control Register File (Address Map) */
 
@@ -996,7 +1022,10 @@
 #define RAP_RAP			0x3f	/* Bit 6..0:	0 = block 0,..,6f = block 6f */
 
 /*	B0_CTST		16 bit	Control/Status register */
-								/* Bit 15..11:	reserved */
+								/* Bit 15..14:	reserved */
+#define CS_CLK_RUN_HOT	BIT_13S		/* CLK_RUN hot m. (YUKON-Lite only) */
+#define CS_CLK_RUN_RST	BIT_12S		/* CLK_RUN reset  (YUKON-Lite only) */
+#define CS_CLK_RUN_ENA	BIT_11S		/* CLK_RUN enable (YUKON-Lite only) */
 #define CS_VAUX_AVAIL	BIT_10S		/* VAUX available (YUKON only) */
 #define CS_BUS_CLOCK	BIT_9S		/* Bus Clock 0/1 = 33/66 MHz */
 #define CS_BUS_SLOT_SZ	BIT_8S		/* Slot Size 0/1 = 32/64 bit slot */
@@ -1028,7 +1057,7 @@
 /*	B0_IMSK		32 bit	Interrupt Mask Register */
 /*	B0_SP_ISRC	32 bit	Special Interrupt Source Reg */
 /*	B2_IRQM_MSK 	32 bit	IRQ Moderation Mask */
-#define IS_ALL_MSK		0xbfffffffL	/* 		All Interrupt bits */
+#define IS_ALL_MSK		0xbfffffffUL	/* All Interrupt bits */
 #define IS_HW_ERR		BIT_31		/* Interrupt HW Error */
 								/* Bit 30:	reserved */
 #define IS_PA_TO_RX1	BIT_29		/* Packet Arb Timeout Rx1 */
@@ -1101,8 +1130,10 @@
 #define CFG_SNG_MAC		BIT_0S		/* MAC Config: 0=2 MACs / 1=1 MAC*/
 
 /*	B2_CHIP_ID	 8 bit 	Chip Identification Number */
-#define CHIP_ID_GENESIS	0x0a		/* Chip ID for GENESIS */
-#define CHIP_ID_YUKON	0xb0		/* Chip ID for YUKON */
+#define CHIP_ID_GENESIS		0x0a	/* Chip ID for GENESIS */
+#define CHIP_ID_YUKON		0xb0	/* Chip ID for YUKON */
+#define CHIP_ID_YUKON_LITE	0xb1	/* Chip ID for YUKON-Lite (Rev. A1) */
+#define CHIP_ID_YUKON_LP	0xb2	/* Chip ID for YUKON-LP */
 
 /*	B2_FAR		32 bit	Flash-Prom Addr Reg/Cnt */
 #define FAR_ADDR		0x1ffffL	/* Bit 16.. 0:	FPROM Address mask */
@@ -1168,16 +1199,16 @@
 
 /*	B2_GP_IO	32 bit	General Purpose I/O Register */
 							/* Bit 31..26:	reserved */
-#define GP_DIR_9	BIT_25	/* IO_9 direct, 0=I/1=O */
-#define GP_DIR_8	BIT_24	/* IO_8 direct, 0=I/1=O */
-#define GP_DIR_7	BIT_23	/* IO_7 direct, 0=I/1=O */
-#define GP_DIR_6	BIT_22	/* IO_6 direct, 0=I/1=O */
-#define GP_DIR_5	BIT_21	/* IO_5 direct, 0=I/1=O */
-#define GP_DIR_4	BIT_20	/* IO_4 direct, 0=I/1=O */
-#define GP_DIR_3	BIT_19	/* IO_3 direct, 0=I/1=O */
-#define GP_DIR_2	BIT_18	/* IO_2 direct, 0=I/1=O */
-#define GP_DIR_1	BIT_17	/* IO_1 direct, 0=I/1=O */
-#define GP_DIR_0	BIT_16	/* IO_0 direct, 0=I/1=O */
+#define GP_DIR_9	BIT_25	/* IO_9 direct, 0=In/1=Out */
+#define GP_DIR_8	BIT_24	/* IO_8 direct, 0=In/1=Out */
+#define GP_DIR_7	BIT_23	/* IO_7 direct, 0=In/1=Out */
+#define GP_DIR_6	BIT_22	/* IO_6 direct, 0=In/1=Out */
+#define GP_DIR_5	BIT_21	/* IO_5 direct, 0=In/1=Out */
+#define GP_DIR_4	BIT_20	/* IO_4 direct, 0=In/1=Out */
+#define GP_DIR_3	BIT_19	/* IO_3 direct, 0=In/1=Out */
+#define GP_DIR_2	BIT_18	/* IO_2 direct, 0=In/1=Out */
+#define GP_DIR_1	BIT_17	/* IO_1 direct, 0=In/1=Out */
+#define GP_DIR_0	BIT_16	/* IO_0 direct, 0=In/1=Out */
 						/* Bit 15..10:	reserved */
 #define GP_IO_9		BIT_9	/* IO_9 pin */
 #define GP_IO_8		BIT_8	/* IO_8 pin */
@@ -1327,7 +1358,7 @@
 /*	TXA_LIM_INI	32 bit	Tx Arb Limit Counter Init Val */
 /*	TXA_LIM_VAL	32 bit	Tx Arb Limit Counter Value */
 								/* Bit 31..24:	reserved */
-#define TXA_MAX_VAL	0x00ffffffL	/* Bit 23.. 0:	Max TXA Timer/Cnt Val */
+#define TXA_MAX_VAL	0x00ffffffUL/* Bit 23.. 0:	Max TXA Timer/Cnt Val */
 
 /*	TXA_CTRL	 8 bit	Tx Arbiter Control Register */
 #define TXA_ENA_FSYNC	BIT_7S	/* Enable  force of sync Tx queue */
@@ -1646,9 +1677,11 @@
 #define GMF_CLI_TX_PE	BIT_4		/* Clear IRQ Tx Parity Error */
 						/* Bits 3..0: same as for RX_GMF_CTRL_T */
 
-#define GMF_RX_CTRL_DEF		GMF_OPER_ON
+#define GMF_RX_CTRL_DEF		(GMF_OPER_ON | GMF_RX_F_FL_ON)
 #define GMF_TX_CTRL_DEF		GMF_OPER_ON
 
+#define RX_GMF_FL_THR_DEF	0x0a	/* Rx GMAC FIFO Flush Threshold default */
+
 /*	GMAC_TI_ST_CTRL		  8 bit	Time Stamp Timer Ctrl Reg (YUKON only) */
 								/* Bit 7.. 3:	reserved */
 #define GMT_ST_START	BIT_2S		/* Start Time Stamp Timer */
@@ -1767,7 +1800,7 @@
 	WOL_CTL_DIS_LINK_CHG_UNIT |		\
 	WOL_CTL_DIS_PATTERN_UNIT |		\
 	WOL_CTL_DIS_MAGIC_PKT_UNIT)
-	
+
 /*	WOL_MATCH_CTL		 8 bit	WOL Match Control Reg */
 #define WOL_CTL_PATT_ENA(x)				(BIT_0 << (x))
 
@@ -1811,7 +1844,7 @@
 	SK_U32	RxAdrHi;		/* Physical Rx Buffer Address upper dword */
 	SK_U32	RxStat;			/* Receive Frame Status Word */
 	SK_U32	RxTiSt;			/* Receive Time Stamp (from XMAC on GENESIS) */
-#ifndef	SK_USE_REV_DESC	
+#ifndef	SK_USE_REV_DESC
 	SK_U16	RxTcpSum1;		/* TCP Checksum 1 */
 	SK_U16	RxTcpSum2;		/* TCP Checksum 2 */
 	SK_U16	RxTcpSp1;		/* TCP Checksum Calculation Start Position 1 */
@@ -1855,7 +1888,7 @@
 #define BMU_CHECK		(0x55L<<16)	/* Default BMU check */
 #define BMU_TCP_CHECK	(0x56L<<16)	/* Descr with TCP ext */
 #define BMU_UDP_CHECK	(0x57L<<16)	/* Descr with UDP ext (YUKON only) */
-#define BMU_BBC			0xFFFFL	/* Bit 15.. 0:	Buffer Byte Counter */
+#define BMU_BBC			0xffffL	/* Bit 15.. 0:	Buffer Byte Counter */
 
 /*	TxStat		Transmit Frame Status Word */
 /*	RxStat		Receive Frame Status Word */
@@ -1866,20 +1899,9 @@
  *	(see XMR_FS bits)
  */
 
-/* other defines *************************************************************/
-
-/*
- * FlashProm specification
- */
-#define MAX_PAGES	0x20000L	/* Every byte has a single page */
-#define MAX_FADDR	1			/* 1 byte per page */
-#define SKFDDI_PSZ	8			/* address PROM size */
-
 /* macros ********************************************************************/
 
-/*
- * Receive and Transmit Queues
- */
+/* Receive and Transmit Queues */
 #define Q_R1	0x0000		/* Receive Queue 1 */
 #define Q_R2	0x0080		/* Receive Queue 2 */
 #define Q_XS1	0x0200		/* Synchronous Transmit Queue 1 */
@@ -1892,7 +1914,7 @@
  *
  *	Use this macro to access the Receive and Transmit Queue Registers.
  *
- * para:	
+ * para:
  *	Queue	Queue to access.
  *				Values: Q_R1, Q_R2, Q_XS1, Q_XA1, Q_XS2, and Q_XA2
  *	Offs	Queue register offset.
@@ -1907,7 +1929,7 @@
  *
  *	Use this macro to access the RAM Buffer Registers.
  *
- * para:	
+ * para:
  *	Queue	Queue to access.
  *				Values: Q_R1, Q_R2, Q_XS1, Q_XA1, Q_XS2, and Q_XA2
  *	Offs	Queue register offset.
@@ -1918,9 +1940,7 @@
 #define RB_ADDR(Queue, Offs)	(B16_RAM_REGS + (Queue) + (Offs))
 
 
-/*
- * MAC Related Registers
- */
+/* MAC Related Registers */
 #define MAC_1		0	/* belongs to the port near the slot */
 #define MAC_2		1	/* belongs to the port far away from the slot */
 
@@ -1929,7 +1949,7 @@
  *
  *	Use this macro to access a MAC Related Registers inside the ASIC.
  *
- * para:	
+ * para:
  *	Mac		MAC to access.
  *				Values: MAC_1, MAC_2
  *	Offs	MAC register offset.
@@ -1981,9 +2001,9 @@
 
 #define XM_IN32(IoC, Mac, Reg, pVal) {					\
 	SK_IN16((IoC), XMA((Mac), (Reg)),					\
-		(SK_U16 *)&((SK_U16 *)(pVal))[XM_WORD_LO]);		\
+		(SK_U16 SK_FAR*)&((SK_U16 SK_FAR*)(pVal))[XM_WORD_LO]);		\
 	SK_IN16((IoC), XMA((Mac), (Reg+2)),					\
-		(SK_U16 *)&((SK_U16 *)(pVal))[XM_WORD_HI]);		\
+		(SK_U16 SK_FAR*)&((SK_U16 SK_FAR*)(pVal))[XM_WORD_HI]);		\
 }
 
 #define XM_OUT32(IoC, Mac, Reg, Val) {										\
@@ -2009,8 +2029,8 @@
 }
 
 #define XM_OUTADDR(IoC, Mac, Reg, pVal) {				\
-	SK_U8	*pByte;										\
-	pByte = (SK_U8 *)&((SK_U8 *)(pVal))[0];				\
+	SK_U8	SK_FAR *pByte;								\
+	pByte = (SK_U8 SK_FAR *)&((SK_U8 SK_FAR *)(pVal))[0];	\
 	SK_OUT16((IoC), XMA((Mac), (Reg)), (SK_U16)			\
 		(((SK_U16)(pByte[0]) & 0x00ff) |				\
 		(((SK_U16)(pByte[1]) << 8) & 0xff00)));			\
@@ -2024,8 +2044,8 @@
 
 #define XM_INHASH(IoC, Mac, Reg, pVal) {				\
 	SK_U16	Word;										\
-	SK_U8	*pByte;										\
-	pByte = (SK_U8 *)&((SK_U8 *)(pVal))[0];				\
+	SK_U8	SK_FAR *pByte;								\
+	pByte = (SK_U8 SK_FAR *)&((SK_U8 SK_FAR *)(pVal))[0];	\
 	SK_IN16((IoC), XMA((Mac), (Reg)), &Word);			\
 	pByte[0] = (SK_U8)(Word  & 0x00ff);					\
 	pByte[1] = (SK_U8)((Word >> 8) & 0x00ff);			\
@@ -2041,8 +2061,8 @@
 }
 
 #define XM_OUTHASH(IoC, Mac, Reg, pVal) {				\
-	SK_U8	*pByte;										\
-	pByte = (SK_U8 *)&((SK_U8 *)(pVal))[0];				\
+	SK_U8	SK_FAR *pByte;								\
+	pByte = (SK_U8 SK_FAR *)&((SK_U8 SK_FAR *)(pVal))[0];	\
 	SK_OUT16((IoC), XMA((Mac), (Reg)), (SK_U16)			\
 		(((SK_U16)(pByte[0]) & 0x00ff)|					\
 		(((SK_U16)(pByte[1]) << 8) & 0xff00)));			\
@@ -2089,9 +2109,9 @@
 
 #define GM_IN32(IoC, Mac, Reg, pVal) {					\
 	SK_IN16((IoC), GMA((Mac), (Reg)),					\
-		(SK_U16 *)&((SK_U16 *)(pVal))[XM_WORD_LO]);		\
+		(SK_U16 SK_FAR*)&((SK_U16 SK_FAR*)(pVal))[XM_WORD_LO]);		\
 	SK_IN16((IoC), GMA((Mac), (Reg+4)),					\
-		(SK_U16 *)&((SK_U16 *)(pVal))[XM_WORD_HI]);		\
+		(SK_U16 SK_FAR*)&((SK_U16 SK_FAR*)(pVal))[XM_WORD_HI]);		\
 }
 
 #define GM_OUT32(IoC, Mac, Reg, Val) {										\
@@ -2115,8 +2135,8 @@
 }
 
 #define GM_OUTADDR(IoC, Mac, Reg, pVal) {				\
-	SK_U8	*pByte;										\
-	pByte = (SK_U8 *)&((SK_U8 *)(pVal))[0];				\
+	SK_U8	SK_FAR *pByte;								\
+	pByte = (SK_U8 SK_FAR *)&((SK_U8 SK_FAR *)(pVal))[0];	\
 	SK_OUT16((IoC), GMA((Mac), (Reg)), (SK_U16)			\
 		(((SK_U16)(pByte[0]) & 0x00ff) |				\
 		(((SK_U16)(pByte[1]) << 8) & 0xff00)));			\
@@ -2186,7 +2206,7 @@
 #define PHY_ADDR_BCOM	(1<<8)
 #define PHY_ADDR_LONE	(3<<8)
 #define PHY_ADDR_NAT	(0<<8)
-		
+
 /* GPHY address (bits 15..11 of SMI control reg) */
 #define PHY_ADDR_MARV	0
 
@@ -2196,7 +2216,7 @@
  * PHY_READ()		read a 16 bit value from the PHY
  * PHY_WRITE()		write a 16 bit value to the PHY
  *
- * para:	
+ * para:
  * 	IoC		I/O context needed for SK I/O macros
  * 	pPort	Pointer to port struct for PhyAddr
  * 	Mac		XMAC to access		values: MAC_1 or MAC_2
@@ -2268,7 +2288,7 @@
  *
  * para:
  *	Addr	PCI configuration register to access.
- *			Values:	PCI_VENDOR_ID	...	PCI_VPD_ADDR,
+ *			Values:	PCI_VENDOR_ID ... PCI_VPD_ADR_REG,
  *
  * usage	SK_IN16(pAC, PCI_C(PCI_VENDOR_ID), pVal);
  */
@@ -2287,12 +2307,12 @@
  *		#define SK_IN8(pAC, Addr, pVal) ...\
  *			*pVal = (SK_U8)inp(SK_HW_ADDR(pAC->Hw.Iop, Addr)))
  */
-#ifdef	SK_MEM_MAPPED_IO
+#ifdef SK_MEM_MAPPED_IO
 #define SK_HW_ADDR(Base, Addr)	((Base) + (Addr))
-#else	/* SK_MEM_MAPPED_IO */
+#else  /* SK_MEM_MAPPED_IO */
 #define SK_HW_ADDR(Base, Addr)	\
 			((Base) + (((Addr) & 0x7f) | (((Addr) >> 7 > 0) ? 0x80 : 0)))
-#endif	/* SK_MEM_MAPPED_IO */
+#endif /* SK_MEM_MAPPED_IO */
 
 #define SZ_LONG	(sizeof(SK_U32))
 
diff -Nru a/drivers/net/sk98lin/h/skgehwt.h b/drivers/net/sk98lin/h/skgehwt.h
--- a/drivers/net/sk98lin/h/skgehwt.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skgehwt.h	Wed Sep  3 22:38:48 2003
@@ -1,17 +1,17 @@
 /******************************************************************************
  *
  * Name:	skhwt.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.5 $
- * Date:	$Date: 1999/11/22 13:54:24 $
+ * Project:	Gigabit Ethernet Adapters, Schedule-Modul
+ * Version:	$Revision: 1.6 $
+ * Date:	$Date: 2003/05/13 17:57:48 $
  * Purpose:	Defines for the hardware timer functions
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: skgehwt.h,v $
+ *	Revision 1.6  2003/05/13 17:57:48  mkarl
+ *	Editorial changes.
+ *	
  *	Revision 1.5  1999/11/22 13:54:24  cgoos
  *	Changed license header to GPL.
  *	
diff -Nru a/drivers/net/sk98lin/h/skgeinit.h b/drivers/net/sk98lin/h/skgeinit.h
--- a/drivers/net/sk98lin/h/skgeinit.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skgeinit.h	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skgeinit.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.73 $
- * Date:	$Date: 2002/11/15 12:47:25 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.81 $
+ * Date:	$Date: 2003/07/04 12:30:38 $
  * Purpose:	Structures and prototypes for the GE Init Module
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,66 +27,98 @@
  * History:
  *
  *	$Log: skgeinit.h,v $
+ *	Revision 1.81  2003/07/04 12:30:38  rschmidt
+ *	Added SK_FAR to pointers in MAC statistic functions (for PXE)
+ *	Editorial changes
+ *	
+ *	Revision 1.80  2003/05/28 15:25:30  rschmidt
+ *	Added SK_FAR to pointers in MAC/PHY read functions (for PXE)
+ *	Minor changes to avoid LINT warnings
+ *	Editorial changes
+ *
+ *	Revision 1.79  2003/05/06 12:02:33  rschmidt
+ *	Added entry GIYukon in s_GeInit structure
+ *	Editorial changes
+ *
+ *	Revision 1.78  2003/04/28 08:59:57  rschmidt
+ *	Added entries GIValIrqMask and GITimeStampCnt in s_GeInit structure
+ *
+ *	Revision 1.77  2003/04/08 16:27:02  rschmidt
+ *	Added entry GILedBlinkCtrl in s_GeInit structure
+ *	Added defines for LED Blink Control
+ *
+ *	Revision 1.76  2003/03/31 07:21:01  mkarl
+ *	Added PGmANegAdv to SK_GEPORT.
+ *	Corrected Copyright.
+ *
+ *	Revision 1.75  2003/02/05 13:36:39  rschmidt
+ *	Added define SK_FACT_78	for YUKON's Host Clock of 78.12 MHz
+ *	Editorial changes
+ *
+ *	Revision 1.74  2003/01/28 09:39:16  rschmidt
+ *	Added entry GIYukonLite in s_GeInit structure
+ *	Editorial changes
+ *
  *	Revision 1.73  2002/11/15 12:47:25  rschmidt
  *	Replaced error message SKERR_HWI_E024 for Cable Diagnostic with
  *	Rx queue error in SkGeStopPort().
- *	
+ *
  *	Revision 1.72  2002/11/12 17:08:35  rschmidt
  *	Added entries for Cable Diagnostic to Port structure
  *	Added entries GIPciSlot64 and GIPciClock66 in s_GeInit structure
  *	Added error message for Cable Diagnostic
  *	Added prototypes for SkGmCableDiagStatus()
  *	Editorial changes
- *	
+ *
  *	Revision 1.71  2002/10/21 11:26:10  mkarl
  *	Changed interface of SkGeInitAssignRamToQueues().
- *	
+ *
  *	Revision 1.70  2002/10/14 08:21:32  rschmidt
  *	Changed type of GICopperType, GIVauxAvail to SK_BOOL
  *	Added entry PRxOverCnt to Port structure
  *	Added entry GIYukon32Bit in s_GeInit structure
  *	Editorial changes
- *	
+ *
  *	Revision 1.69  2002/10/09 16:57:15  mkarl
  *	Added some constants and macros for SkGeInitAssignRamToQueues().
- *	
+ *
  *	Revision 1.68  2002/09/12 08:58:51  rwahl
  *	Retrieve counters needed for XMAC errata workarounds directly because
  *	PNMI returns corrected counter values (e.g. #10620).
- *	
+ *
  *	Revision 1.67  2002/08/16 14:40:30  rschmidt
  *	Added entries GIGenesis and GICopperType in s_GeInit structure
  *	Added prototypes for SkMacHashing()
  *	Editorial changes
- *	
+ *
  *	Revision 1.66  2002/08/12 13:27:21  rschmidt
  *	Added defines for Link speed capabilities
  *	Added entry PLinkSpeedCap to Port structure
  *	Added entry GIVauxAvail in s_GeInit structure
  *	Added prototypes for SkMacPromiscMode()
  *	Editorial changes
- *	
+ *
  *	Revision 1.65  2002/08/08 15:46:18  rschmidt
  *	Added define SK_PHY_ACC_TO for PHY access timeout
  *	Added define SK_XM_RX_HI_WM for XMAC Rx High Watermark
  *	Added define SK_MIN_TXQ_SIZE for Min RAM Buffer Tx Queue Size
  *	Added entry PhyId1 to Port structure
- *	
+ *
  *	Revision 1.64  2002/07/23 16:02:56  rschmidt
  *	Added entry GIWolOffs in s_GeInit struct (HW-Bug in YUKON 1st rev.)
  *	Added prototypes for: SkGePhyRead(), SkGePhyWrite()
- *	
+ *
  *	Revision 1.63  2002/07/18 08:17:38  rwahl
  *	Corrected definitions for SK_LSPEED_xxx & SK_LSPEED_STAT_xxx.
- *	
+ *
  *	Revision 1.62  2002/07/17 18:21:55  rwahl
  *	Added SK_LSPEED_INDETERMINATED define.
- *	
+ *
  *	Revision 1.61  2002/07/17 17:16:03  rwahl
  *	- MacType now member of GIni struct.
  *	- Struct alignment to 32bit.
  *	- Editorial change.
- *	
+ *
  *	Revision 1.60  2002/07/15 18:23:39  rwahl
  *	Added GeMacFunc to GE Init structure.
  *	Added prototypes for SkXmUpdateStats(), SkGmUpdateStats(),
@@ -93,19 +126,19 @@
  *	  SkGmResetCounter(), SkXmOverflowStatus(), SkGmOverflowStatus().
  *	Added defines for current link speed state.
  *	Added ERRMSG defintions for MacUpdateStat() & MacStatistics().
- *	
+ *
  *	Revision 1.59  2002/07/15 15:40:22  rschmidt
  *	Added entry PLinkSpeedUsed to Port structure
  *	Editorial changes
- *	
+ *
  *	Revision 1.58  2002/06/10 09:36:30  rschmidt
  *	Editorial changes.
- *	
+ *
  *	Revision 1.57  2002/06/05 08:18:00  rschmidt
  *	Corrected alignment in Port Structure
  *	Added new prototypes for GMAC
  *	Editorial changes
- *	
+ *
  *	Revision 1.56  2002/04/25 11:38:12  rschmidt
  *	Added defines for Link speed values
  *	Added defines for Loopback parameters for MAC and PHY
@@ -120,150 +153,150 @@
  *	SkXmPhyRead(), SkXmPhyRead(), SkGmPhyWrite(), SkGmPhyWrite();
  *	Removed prototypes for static functions in SkXmac2.c
  *	Editorial changes
- *	
+ *
  *	Revision 1.55  2002/02/26 15:24:53  rwahl
  *	Fix: no link with manual configuration (#10673). The previous fix for
  *	#10639 was removed. So for RLMT mode = CLS the RLMT may switch to
  *	misconfigured port. It should not occur for the other RLMT modes.
- *	
+ *
  *	Revision 1.54  2002/01/18 16:52:52  rwahl
  *	Editorial corrections.
- *	
+ *
  *	Revision 1.53  2001/11/20 09:19:58  rwahl
  *	Reworked bugfix #10639 (no dependency to RLMT mode).
- *	
+ *
  *	Revision 1.52  2001/10/26 07:52:23  afischer
  *	Port switching bug in `check local link` mode
- *	
+ *
  *	Revision 1.51  2001/02/09 12:26:38  cgoos
  *	Inserted #ifdef DIAG for half duplex workaround timer.
- *	
+ *
  *	Revision 1.50  2001/02/07 07:56:40  rassmann
  *	Corrected copyright.
- *	
+ *
  *	Revision 1.49  2001/01/31 15:32:18  gklug
  *	fix: problem with autosensing an SR8800 switch
  *	add: counter for autoneg timeouts
- *	
+ *
  *	Revision 1.48  2000/11/09 11:30:10  rassmann
  *	WA: Waiting after releasing reset until BCom chip is accessible.
- *	
+ *
  *	Revision 1.47  2000/10/18 12:22:40  cgoos
  *	Added workaround for half duplex hangup.
- *	
+ *
  *	Revision 1.46  2000/08/10 11:28:00  rassmann
  *	Editorial changes.
  *	Preserving 32-bit alignment in structs for the adapter context.
- *	
+ *
  *	Revision 1.45  1999/11/22 13:56:19  cgoos
  *	Changed license header to GPL.
- *	
+ *
  *	Revision 1.44  1999/10/26 07:34:15  malthoff
  *	The define SK_LNK_ON has been lost in v1.41.
- *	
+ *
  *	Revision 1.43  1999/10/06 09:30:16  cgoos
  *	Changed SK_XM_THR_JUMBO.
- *	
+ *
  *	Revision 1.42  1999/09/16 12:58:26  cgoos
  *	Changed SK_LED_STANDY macro to be independent of HW link sync.
- *	
+ *
  *	Revision 1.41  1999/07/30 06:56:14  malthoff
  *	Correct comment for SK_MS_STAT_UNSET.
- *	
+ *
  *	Revision 1.40  1999/05/27 13:38:46  cgoos
  *	Added SK_BMU_TX_WM.
  *	Made SK_BMU_TX_WM and SK_BMU_RX_WM user-definable.
  *	Changed XMAC Tx treshold to max. values.
- *	
+ *
  *	Revision 1.39  1999/05/20 14:35:26  malthoff
  *	Remove prototypes for SkGeLinkLED().
- *	
+ *
  *	Revision 1.38  1999/05/19 11:59:12  cgoos
  *	Added SK_MS_CAP_INDETERMINATED define.
- *	
+ *
  *	Revision 1.37  1999/05/19 07:32:33  cgoos
  *	Changes for 1000Base-T.
  *	LED-defines for HWAC_LINK_LED macro.
- *	
+ *
  *	Revision 1.36  1999/04/08 14:00:24  gklug
  *	add:Port struct field PLinkResCt
- *	
+ *
  *	Revision 1.35  1999/03/25 07:43:07  malthoff
  *	Add error string for SKERR_HWI_E018MSG.
- *	
+ *
  *	Revision 1.34  1999/03/12 16:25:57  malthoff
  *	Remove PPollRxD and PPollTxD.
  *	Add SKERR_HWI_E017MSG. and SK_DPOLL_MAX.
- *	
+ *
  *	Revision 1.33  1999/03/12 13:34:41  malthoff
  *	Add Autonegotiation error codes.
  *	Change defines for parameter Mode in SkXmSetRxCmd().
  *	Replace __STDC__ by SK_KR_PROTO.
- *	
+ *
  *	Revision 1.32  1999/01/25 14:40:20  mhaveman
  *	Added new return states for the virtual management port if multiple
  *	ports are active but differently configured.
- *	
+ *
  *	Revision 1.31  1998/12/11 15:17:02  gklug
- *	add: Link partnet autoneg states : Unknown Manual and Autonegotiation
- *	
+ *	add: Link partnet autoneg states : Unknown Manual and Auto-negotiation
+ *
  *	Revision 1.30  1998/12/07 12:17:04  gklug
- *	add: Link Partner autonegotiation flag
- *	
+ *	add: Link Partner auto-negotiation flag
+ *
  *	Revision 1.29  1998/12/01 10:54:42  gklug
  *	add: variables for XMAC Errata
- *	
+ *
  *	Revision 1.28  1998/12/01 10:14:15  gklug
  *	add: PIsave saves the Interrupt status word
- *	
+ *
  *	Revision 1.27  1998/11/26 15:24:52  mhaveman
  *	Added link status states SK_LMODE_STAT_AUTOHALF and
  *	SK_LMODE_STAT_AUTOFULL which are used by PNMI.
- *	
+ *
  *	Revision 1.26  1998/11/26 14:53:01  gklug
  *	add:autoNeg Timeout variable
- *	
+ *
  *	Revision 1.25  1998/11/26 08:58:50  gklug
  *	add: Link Mode configuration (AUTO Sense mode)
- *	
+ *
  *	Revision 1.24  1998/11/24 13:30:27  gklug
  *	add: PCheckPar to port struct
- *	
+ *
  *	Revision 1.23  1998/11/18 13:23:26  malthoff
  *	Add SK_PKT_TO_MAX.
- *	
+ *
  *	Revision 1.22  1998/11/18 13:19:54  gklug
  *	add: PPrevShorts and PLinkBroken to port struct for WA XMAC Errata #C1
  *
  *	Revision 1.21  1998/10/26 08:02:57  malthoff
  *	Add GIRamOffs.
- *	
+ *
  *	Revision 1.20  1998/10/19 07:28:37  malthoff
  *	Add prototype for SkGeInitRamIface().
- *	
+ *
  *	Revision 1.19  1998/10/14 14:47:48  malthoff
  *	SK_TIMER should not be defined for Diagnostics.
  *	Add SKERR_HWI_E015MSG and SKERR_HWI_E016MSG.
- *	
+ *
  *	Revision 1.18  1998/10/14 14:00:03  gklug
  *	add: timer to port struct for workaround of Errata #2
- *	
+ *
  *	Revision 1.17  1998/10/14 11:23:09  malthoff
  *	Add prototype for SkXmAutoNegDone().
  *	Fix SkXmSetRxCmd() prototype statement.
  *
  *	Revision 1.16  1998/10/14 05:42:29  gklug
  *	add: HWLinkUp flag to Port struct
- *	
+ *
  *	Revision 1.15  1998/10/09 08:26:33  malthoff
  *	Rename SK_RB_ULPP_B to SK_RB_LLPP_B.
- *	
+ *
  *	Revision 1.14  1998/10/09 07:11:13  malthoff
  *	bug fix: SK_FACT_53 is 85 not 117.
  *	Rework time out init values.
  *	Add GIPortUsage and corresponding defines.
  *	Add some error log messages.
- *	
+ *
  *	Revision 1.13  1998/10/06 14:13:14  malthoff
  *	Add prototype for SkGeLoadLnkSyncCnt().
  *
@@ -328,9 +361,11 @@
 
 /* defines ********************************************************************/
 
+#define SK_TEST_VAL		0x11335577UL
+
 /* modifying Link LED behaviour (used with SkGeLinkLED()) */
 #define SK_LNK_OFF		LED_OFF
-#define SK_LNK_ON		(LED_ON | LED_BLK_OFF | LED_SYNC_OFF)	
+#define SK_LNK_ON		(LED_ON | LED_BLK_OFF | LED_SYNC_OFF)
 #define SK_LNK_BLINK	(LED_ON | LED_BLK_ON  | LED_SYNC_ON)
 #define SK_LNK_PERM		(LED_ON | LED_BLK_OFF | LED_SYNC_ON)
 #define SK_LNK_TST		(LED_ON | LED_BLK_ON  | LED_SYNC_OFF)
@@ -352,14 +387,17 @@
 #define SK_LED_TST	2
 
 /* Counter and Timer constants, for a host clock of 62.5 MHz */
-#define SK_XMIT_DUR		0x002faf08L		/*  50 ms */
-#define SK_BLK_DUR		0x01dcd650L		/* 500 ms */
+#define SK_XMIT_DUR		0x002faf08UL	/*  50 ms */
+#define SK_BLK_DUR		0x01dcd650UL	/* 500 ms */
+
+#define SK_DPOLL_DEF	0x00ee6b28UL	/* 250 ms at 62.5 MHz */
 
-#define SK_DPOLL_DEF	0x00EE6B28L		/* 250 ms */
-#define SK_DPOLL_MAX	0x00FFFFFFL		/* ca. 268ms */
+#define SK_DPOLL_MAX	0x00ffffffUL	/* 268 ms at 62.5 MHz */
+										/* 215 ms at 78.12 MHz */
 
 #define SK_FACT_62		100			/* is given in percent */
-#define SK_FACT_53		 85
+#define SK_FACT_53		 85         /* on GENESIS:	53.12 MHz */
+#define SK_FACT_78		125			/* on YUKON:	78.12 MHz */
 
 /* Timeout values */
 #define SK_MAC_TO_53	72			/* MAC arbiter timeout */
@@ -447,9 +485,7 @@
 #define SK_LMODE_AUTOFULL	4	/* AutoFull Duplex Mode */
 #define SK_LMODE_AUTOBOTH	5	/* AutoBoth Duplex Mode */
 #define SK_LMODE_AUTOSENSE	6	/* configured mode auto sensing */
-#define SK_LMODE_INDETERMINATED	7	/* Return value for virtual port if
-								* multiple ports are differently configured.
-								*/
+#define SK_LMODE_INDETERMINATED	7	/* indeterminated */
 
 /* Auto-negotiation timeout in 100ms granularity */
 #define SK_AND_MAX_TO		6	/* Wait 600 msec before link comes up */
@@ -465,27 +501,21 @@
 #define SK_LSPEED_CAP_10MBPS		(1<<1)	/* 10 Mbps */
 #define SK_LSPEED_CAP_100MBPS		(1<<2)	/* 100 Mbps */
 #define SK_LSPEED_CAP_1000MBPS		(1<<3)	/* 1000 Mbps */
-#define SK_LSPEED_CAP_INDETERMINATED (1<<4) /* Return value for virtual port if
-									  * multiple ports are differently configured.
-									  */
+#define SK_LSPEED_CAP_INDETERMINATED (1<<4) /* indeterminated */
 
 /* Link Speed Parameter */
 #define SK_LSPEED_AUTO				1	/* Automatic resolution */
 #define SK_LSPEED_10MBPS			2	/* 10 Mbps */
 #define SK_LSPEED_100MBPS			3	/* 100 Mbps */
 #define SK_LSPEED_1000MBPS			4	/* 1000 Mbps */
-#define SK_LSPEED_INDETERMINATED	5	/* Return value for virtual port if
-					 * multiple ports are differently configured.
-					 */
+#define SK_LSPEED_INDETERMINATED	5	/* indeterminated */
 
 /* Link Speed Current State */
 #define SK_LSPEED_STAT_UNKNOWN		1
 #define SK_LSPEED_STAT_10MBPS		2
 #define SK_LSPEED_STAT_100MBPS 		3
 #define SK_LSPEED_STAT_1000MBPS		4
-#define SK_LSPEED_STAT_INDETERMINATED 5	/* Return value for virtual port if
-					 * multiple ports are differently configured.
-					 */
+#define SK_LSPEED_STAT_INDETERMINATED 5
 
 
 /* Link Capability Parameter */
@@ -493,62 +523,50 @@
 #define SK_LMODE_CAP_FULL		(1<<1)	/* Full Duplex Mode */
 #define SK_LMODE_CAP_AUTOHALF	(1<<2)	/* AutoHalf Duplex Mode */
 #define SK_LMODE_CAP_AUTOFULL	(1<<3)	/* AutoFull Duplex Mode */
-#define SK_LMODE_CAP_INDETERMINATED (1<<4) /* Return value for virtual port if
-					 * multiple ports are differently configured.
-					 */
+#define SK_LMODE_CAP_INDETERMINATED (1<<4) /* indeterminated */
 
 /* Link Mode Current State */
 #define SK_LMODE_STAT_UNKNOWN	1	/* Unknown Duplex Mode */
 #define SK_LMODE_STAT_HALF		2	/* Half Duplex Mode */
 #define SK_LMODE_STAT_FULL		3	/* Full Duplex Mode */
-#define SK_LMODE_STAT_AUTOHALF	4	/* Half Duplex Mode obtained by AutoNeg */
-#define SK_LMODE_STAT_AUTOFULL	5	/* Full Duplex Mode obtained by AutoNeg */
-#define SK_LMODE_STAT_INDETERMINATED 6	/* Return value for virtual port if
-					 * multiple ports are differently configured.
-					 */
+#define SK_LMODE_STAT_AUTOHALF	4	/* Half Duplex Mode obtained by Auto-Neg */
+#define SK_LMODE_STAT_AUTOFULL	5	/* Full Duplex Mode obtained by Auto-Neg */
+#define SK_LMODE_STAT_INDETERMINATED 6	/* indeterminated */
+
 /* Flow Control Mode Parameter (and capabilities) */
-#define SK_FLOW_MODE_NONE		1	/* No Flow Control */
+#define SK_FLOW_MODE_NONE		1	/* No Flow-Control */
 #define SK_FLOW_MODE_LOC_SEND	2	/* Local station sends PAUSE */
-#define SK_FLOW_MODE_SYMMETRIC	3	/* Both station may send PAUSE */
-#define SK_FLOW_MODE_SYM_OR_REM	4	/* Both station may send PAUSE or
+#define SK_FLOW_MODE_SYMMETRIC	3	/* Both stations may send PAUSE */
+#define SK_FLOW_MODE_SYM_OR_REM	4	/* Both stations may send PAUSE or
 					 * just the remote station may send PAUSE
 					 */
-#define SK_FLOW_MODE_INDETERMINATED 5	/* Return value for virtual port if
-					 * multiple ports are differently configured.
-					 */
+#define SK_FLOW_MODE_INDETERMINATED 5	/* indeterminated */
 
 /* Flow Control Status Parameter */
 #define SK_FLOW_STAT_NONE		1	/* No Flow Control */
 #define SK_FLOW_STAT_REM_SEND	2	/* Remote Station sends PAUSE */
 #define SK_FLOW_STAT_LOC_SEND	3	/* Local station sends PAUSE */
 #define SK_FLOW_STAT_SYMMETRIC	4	/* Both station may send PAUSE */
-#define SK_FLOW_STAT_INDETERMINATED 5	/* Return value for virtual port if
-					 * multiple ports are differently configured.
-					 */
+#define SK_FLOW_STAT_INDETERMINATED 5	/* indeterminated */
+
 /* Master/Slave Mode Capabilities */
 #define SK_MS_CAP_AUTO		(1<<0)	/* Automatic resolution */
 #define SK_MS_CAP_MASTER	(1<<1)	/* This station is master */
 #define SK_MS_CAP_SLAVE		(1<<2)	/* This station is slave */
-#define SK_MS_CAP_INDETERMINATED (1<<3)	/* Return value for virtual port if
-					 * multiple ports are differently configured.
-					 */
+#define SK_MS_CAP_INDETERMINATED (1<<3)	/* indeterminated */
 
 /* Set Master/Slave Mode Parameter (and capabilities) */
 #define SK_MS_MODE_AUTO		1	/* Automatic resolution */
 #define SK_MS_MODE_MASTER	2	/* This station is master */
 #define SK_MS_MODE_SLAVE	3	/* This station is slave */
-#define SK_MS_MODE_INDETERMINATED 4	/* Return value for virtual port if
-					 * multiple ports are differently
-					 */
+#define SK_MS_MODE_INDETERMINATED 4	/* indeterminated */
 
 /* Master/Slave Status Parameter */
-#define SK_MS_STAT_UNSET	1	/* The MS status is never been determ*/
+#define SK_MS_STAT_UNSET	1	/* The M/S status is not set */
 #define SK_MS_STAT_MASTER	2	/* This station is master */
 #define SK_MS_STAT_SLAVE	3	/* This station is slave */
-#define SK_MS_STAT_FAULT	4	/* MS resolution failed */
-#define SK_MS_STAT_INDETERMINATED 5	/* Return value for virtual port if
-					 * multiple ports are differently
-					 */
+#define SK_MS_STAT_FAULT	4	/* M/S resolution failed */
+#define SK_MS_STAT_INDETERMINATED 5	/* indeterminated */
 
 /* parameter 'Mode' when calling SkXmSetRxCmd() */
 #define SK_STRIP_FCS_ON		(1<<0)	/* Enable  FCS stripping of Rx frames */
@@ -557,8 +575,8 @@
 #define SK_STRIP_PAD_OFF	(1<<3)	/* Disable pad byte stripping of Rx fr */
 #define SK_LENERR_OK_ON		(1<<4)	/* Don't chk fr for in range len error */
 #define SK_LENERR_OK_OFF	(1<<5)	/* Check frames for in range len error */
-#define SK_BIG_PK_OK_ON		(1<<6)	/* Don't set rcvError bit for big fr */
-#define SK_BIG_PK_OK_OFF	(1<<7)	/* Set rcvError bit for big frames */	
+#define SK_BIG_PK_OK_ON		(1<<6)	/* Don't set Rx Error bit for big frames */
+#define SK_BIG_PK_OK_OFF	(1<<7)	/* Set Rx Error bit for big frames */
 #define SK_SELF_RX_ON		(1<<8)	/* Enable  Rx of own packets */
 #define SK_SELF_RX_OFF		(1<<9)	/* Disable Rx of own packets */
 
@@ -579,6 +597,11 @@
 /* Default receive frame limit for Workaround of XMAC Errata */
 #define SK_DEF_RX_WA_LIM	SK_CONSTU64(100)
 
+/* values for GILedBlinkCtrl (LED Blink Control) */
+#define SK_ACT_LED_BLINK	(1<<0)	/* Active LED blinking */
+#define SK_DUP_LED_NORMAL	(1<<1)	/* Duplex LED normal */
+#define SK_LED_LINK100_ON	(1<<2)	/* Link 100M LED on */
+
 /* Link Partner Status */
 #define SK_LIPA_UNKNOWN	0	/* Link partner is in unknown state */
 #define SK_LIPA_MANUAL	1	/* Link partner is in detected manual state */
@@ -598,10 +621,10 @@
 typedef struct s_GeMacFunc {
 	int  (*pFnMacUpdateStats)(SK_AC *pAC, SK_IOC IoC, unsigned int Port);
 	int  (*pFnMacStatistic)(SK_AC *pAC, SK_IOC IoC, unsigned int Port,
-							SK_U16 StatAddr, SK_U32 *pVal);
+							SK_U16 StatAddr, SK_U32 SK_FAR *pVal);
 	int  (*pFnMacResetCounter)(SK_AC *pAC, SK_IOC IoC, unsigned int Port);
 	int  (*pFnMacOverflow)(SK_AC *pAC, SK_IOC IoC, unsigned int Port,
-						   SK_U16 IStatus, SK_U64 *pVal);
+						   SK_U16 IStatus, SK_U64 SK_FAR *pVal);
 } SK_GEMACFUNC;
 
 /*
@@ -612,7 +635,7 @@
 	SK_TIMER	PWaTimer;	/* Workaround Timer */
 	SK_TIMER	HalfDupChkTimer;
 #endif /* SK_DIAG */
-	SK_U32	PPrevShorts;	/* Previous short Counter checking */
+	SK_U32	PPrevShorts;	/* Previous Short Counter checking */
 	SK_U32	PPrevFcs;		/* Previous FCS Error Counter checking */
 	SK_U64	PPrevRx;		/* Previous RxOk Counter checking */
 	SK_U64	PRxLim;			/* Previous RxOk Counter checking */
@@ -634,12 +657,13 @@
 	int		PXsQOff;		/* Synchronous Tx Queue Address Offset */
 	int		PXaQOff;		/* Asynchronous Tx Queue Address Offset */
 	int		PhyType;		/* PHY used on this port */
+	int		PState;			/* Port status (reset, stop, init, run) */
 	SK_U16	PhyId1;			/* PHY Id1 on this port */
 	SK_U16	PhyAddr;		/* MDIO/MDC PHY address */
 	SK_U16	PIsave;			/* Saved Interrupt status word */
 	SK_U16	PSsave;			/* Saved PHY status word */
+	SK_U16	PGmANegAdv;		/* Saved GPhy AutoNegAdvertisment register */
 	SK_BOOL	PHWLinkUp;		/* The hardware Link is up (wiring) */
-	SK_BOOL	PState;			/* Is port initialized ? */
 	SK_BOOL	PLinkBroken;	/* Is Link broken ? */
 	SK_BOOL	PCheckPar;		/* Do we check for parity errors ? */
 	SK_BOOL	HalfDupTimerActive;
@@ -656,7 +680,7 @@
 	SK_U8	PMSCap;			/* Master/Slave Capabilities */
 	SK_U8	PMSMode;		/* Master/Slave Mode */
 	SK_U8	PMSStatus;		/* Master/Slave Status */
-	SK_U8	PAutoNegFail;	/* Auto-negotiation fail flag */
+	SK_BOOL	PAutoNegFail;	/* Auto-negotiation fail flag */
 	SK_U8	PLipaAutoNeg;	/* Auto-negotiation possible with Link Partner */
 	SK_U8	PCableLen;		/* Cable Length */
 	SK_U8	PMdiPairLen[4];	/* MDI[0..3] Pair Length */
@@ -668,24 +692,29 @@
  * (has to be included in the adapter context)
  */
 typedef	struct s_GeInit {
+	int			GIChipId;		/* Chip Identification Number */
+	int			GIChipRev;		/* Chip Revision Number */
 	SK_U8		GIPciHwRev;		/* PCI HW Revision Number */
-	SK_U8		GIChipId;		/* Chip Identification Number */
-	SK_U8		GIChipRev;		/* Chip Revision Number */
 	SK_BOOL		GIGenesis;		/* Genesis adapter ? */
+	SK_BOOL		GIYukon;		/* YUKON-A1/Bx chip */
+	SK_BOOL		GIYukonLite;	/* YUKON-Lite chip */
 	SK_BOOL		GICopperType;	/* Copper Type adapter ? */
 	SK_BOOL		GIPciSlot64;	/* 64-bit PCI Slot */
 	SK_BOOL		GIPciClock66;	/* 66 MHz PCI Clock */
 	SK_BOOL		GIVauxAvail;	/* VAUX available (YUKON) */
 	SK_BOOL		GIYukon32Bit;	/* 32-Bit YUKON adapter */
+	SK_U16		GILedBlinkCtrl;	/* LED Blink Control */
 	int			GIMacsFound;	/* Number of MACs found on this adapter */
 	int			GIMacType;		/* MAC Type used on this adapter */
 	int			GIHstClkFact;	/* Host Clock Factor (62.5 / HstClk * 100) */
-	int			GIPortUsage;	/* Driver Port Usage: SK_RED_LINK/SK_MUL_LINK */
+	int			GIPortUsage;	/* Driver Port Usage */
 	int			GILevel;		/* Initialization Level completed */
 	int			GIRamSize;		/* The RAM size of the adapter in kB */
-	int			GIWolOffs;		/* WOL Register Offset (HW-Bug in 1st revision) */
+	int			GIWolOffs;		/* WOL Register Offset (HW-Bug in Rev. A) */
 	SK_U32		GIRamOffs;		/* RAM Address Offset for addr calculation */
-	SK_U32		GIPollTimerVal;	/* Descriptor Poll Timer Init Val in clk ticks*/
+	SK_U32		GIPollTimerVal;	/* Descr. Poll Timer Init Val (HstClk ticks) */
+	SK_U32		GIValIrqMask;	/* Value for Interrupt Mask */
+	SK_U32		GITimeStampCnt;	/* Time Stamp High Counter (YUKON only) */
 	SK_GEPORT	GP[SK_MAX_MACS];/* Port Dependent Information */
 	SK_GEMACFUNC GIFunc;		/* MAC depedent functions */
 } SK_GEINIT;
@@ -714,7 +743,7 @@
 #define SKERR_HWI_E010		(SKERR_HWI_E009+1)
 #define SKERR_HWI_E010MSG	"SkGeCfgSync() called with invalid parameters"
 #define SKERR_HWI_E011		(SKERR_HWI_E010+1)
-#define SKERR_HWI_E011MSG	"SkGeInitPort(): Receive Queue Size to small"
+#define SKERR_HWI_E011MSG	"SkGeInitPort(): Receive Queue Size too small"
 #define SKERR_HWI_E012		(SKERR_HWI_E011+1)
 #define SKERR_HWI_E012MSG	"SkGeInitPort(): invalid Queue Size specified"
 #define SKERR_HWI_E013		(SKERR_HWI_E012+1)
@@ -738,7 +767,7 @@
 #define	SKERR_HWI_E022		(SKERR_HWI_E021+1)
 #define	SKERR_HWI_E022MSG	"MacStatistic(): illegal statistic base address"
 #define SKERR_HWI_E023		(SKERR_HWI_E022+1)
-#define SKERR_HWI_E023MSG	"SkGeInitPort(): Transmit Queue Size to small"
+#define SKERR_HWI_E023MSG	"SkGeInitPort(): Transmit Queue Size too small"
 #define SKERR_HWI_E024		(SKERR_HWI_E023+1)
 #define SKERR_HWI_E024MSG	"FATAL: SkGeStopPort() does not terminate (Rx)"
 #define SKERR_HWI_E025		(SKERR_HWI_E024+1)
@@ -911,7 +940,7 @@
 	SK_IOC	IoC,
 	int		Port,
 	int		Addr,
-	SK_U16	*pVal);
+	SK_U16	SK_FAR *pVal);
 
 extern void	SkXmPhyWrite(
 	SK_AC	*pAC,
@@ -925,7 +954,7 @@
 	SK_IOC	IoC,
 	int		Port,
 	int		Addr,
-	SK_U16	*pVal);
+	SK_U16	SK_FAR *pVal);
 
 extern void	SkGmPhyWrite(
 	SK_AC	*pAC,
@@ -934,20 +963,6 @@
 	int		Addr,
 	SK_U16	Val);
 
-extern void	SkGePhyRead(
-	SK_AC	*pAC,
-	SK_IOC	IoC,
-	int		Port,
-	int		Addr,
-	SK_U16	*pVal);
-
-extern void	SkGePhyWrite(
-	SK_AC	*pAC,
-	SK_IOC	IoC,
-	int		Port,
-	int		Addr,
-	SK_U16	Val);
-
 extern void	SkXmClrExactAddr(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
@@ -986,14 +1001,14 @@
 	SK_IOC	IoC,
 	unsigned int Port,
 	SK_U16	StatAddr,
-	SK_U32	*pVal);
+	SK_U32	SK_FAR *pVal);
 
 extern int SkGmMacStatistic(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	unsigned int Port,
 	SK_U16	StatAddr,
-	SK_U32	*pVal);
+	SK_U32	SK_FAR *pVal);
 
 extern int SkXmResetCounter(
 	SK_AC	*pAC,
@@ -1010,14 +1025,14 @@
 	SK_IOC	IoC,
 	unsigned int Port,
 	SK_U16  IStatus,
-	SK_U64	*pStatus);
+	SK_U64	SK_FAR *pStatus);
 
 extern int SkGmOverflowStatus(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	unsigned int Port,
 	SK_U16	MacStatus,
-	SK_U64	*pStatus);
+	SK_U64	SK_FAR *pStatus);
 
 extern int SkGmCableDiagStatus(
 	SK_AC	*pAC,
@@ -1026,6 +1041,20 @@
 	SK_BOOL	StartTest);
 
 #ifdef SK_DIAG
+extern void	SkGePhyRead(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		Addr,
+	SK_U16	*pVal);
+
+extern void	SkGePhyWrite(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		Addr,
+	SK_U16	Val);
+
 extern void	SkMacSetRxCmd(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
@@ -1083,8 +1112,6 @@
 extern int	SkMacAutoNegDone();
 extern void	SkMacAutoNegLipaPhy();
 extern void SkMacSetRxTxEn();
-extern void	SkGePhyRead();
-extern void	SkGePhyWrite();
 extern void	SkXmInitMac();
 extern void	SkXmPhyRead();
 extern void	SkXmPhyWrite();
@@ -1106,6 +1133,8 @@
 extern int	SkGmCableDiagStatus();
 
 #ifdef SK_DIAG
+extern void	SkGePhyRead();
+extern void	SkGePhyWrite();
 extern void	SkMacSetRxCmd();
 extern void	SkMacCrcGener();
 extern void	SkMacTimeStamp();
diff -Nru a/drivers/net/sk98lin/h/skgepnm2.h b/drivers/net/sk98lin/h/skgepnm2.h
--- a/drivers/net/sk98lin/h/skgepnm2.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skgepnm2.h	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgepnm2.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.34 $
- * Date:	$Date: 2002/12/16 09:05:18 $
+ * Version:	$Revision: 1.36 $
+ * Date:	$Date: 2003/05/23 12:45:13 $
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,13 @@
  * History:
  *
  *	$Log: skgepnm2.h,v $
+ *	Revision 1.36  2003/05/23 12:45:13  tschilli
+ *	#ifndef SK_PNMI_HUNDREDS_SEC added to SK_PNMI_HUNDREDS_SEC definition
+ *	to allow own time macro defines.
+ *	
+ *	Revision 1.35  2003/03/27 11:27:48  tschilli
+ *	Copyright messages changed.
+ *	
  *	Revision 1.34  2002/12/16 09:05:18  tschilli
  *	Code for VCT handling added.
  *	
@@ -359,11 +367,13 @@
 /*
  * Time macros
  */
+#ifndef SK_PNMI_HUNDREDS_SEC
 #if SK_TICKS_PER_SEC == 100
 #define SK_PNMI_HUNDREDS_SEC(t)	(t)
 #else
 #define SK_PNMI_HUNDREDS_SEC(t)	(((t) * 100) / (SK_TICKS_PER_SEC))
-#endif
+#endif /* !SK_TICKS_PER_SEC */
+#endif /* !SK_PNMI_HUNDREDS_SEC */
 
 /*
  * Macros to work around alignment problems
diff -Nru a/drivers/net/sk98lin/h/skgepnmi.h b/drivers/net/sk98lin/h/skgepnmi.h
--- a/drivers/net/sk98lin/h/skgepnmi.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skgepnmi.h	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgepnmi.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.59 $
- * Date:	$Date: 2002/12/16 14:03:50 $
+ * Version:	$Revision: 1.61 $
+ * Date:	$Date: 2003/05/23 12:53:52 $
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,16 @@
  * History:
  *
  *	$Log: skgepnmi.h,v $
+ *	Revision 1.61  2003/05/23 12:53:52  tschilli
+ *	Generic PNMI IOCTL subcommands added.
+ *	Function prototype SkPnmiGenIoctl() added.
+ *	OID_SKGE_BOARDLEVEL added.
+ *	Return value SK_PNMI_ERR_NOT_SUPPORTED added.
+ *	Editorial changes.
+ *	
+ *	Revision 1.60  2003/03/27 11:27:26  tschilli
+ *	Copyright messages changed.
+ *	
  *	Revision 1.59  2002/12/16 14:03:50  tschilli
  *	New defines for VCT added.
  *	
@@ -284,6 +295,7 @@
 #define SK_PNMI_ERR_UNKNOWN_OID		5
 #define SK_PNMI_ERR_UNKNOWN_INST	6
 #define SK_PNMI_ERR_UNKNOWN_NET 	7
+#define SK_PNMI_ERR_NOT_SUPPORTED	10
 
 
 /*
@@ -436,6 +448,8 @@
 #define OID_SKGE_SPEED_MODE				0xFF010171
 #define OID_SKGE_SPEED_STATUS			0xFF010172
 
+#define OID_SKGE_BOARDLEVEL				0xFF010180
+
 #define OID_SKGE_SENSOR_NUMBER			0xFF020100			
 #define OID_SKGE_SENSOR_INDEX			0xFF020101
 #define OID_SKGE_SENSOR_DESCR			0xFF020102
@@ -558,6 +572,11 @@
 #define OID_SKGE_VCT_SET			0xFF020201
 #define OID_SKGE_VCT_STATUS			0xFF020202
 
+#ifdef SK_DIAG_SUPPORT
+/* Defines for driver DIAG mode. */
+#define OID_SKGE_DIAG_MODE			0xFF020204
+#endif /* SK_DIAG_SUPPORT */
+
 
 /* VCT struct to store a backup copy of VCT data after a port reset. */
 typedef struct s_PnmiVct {
@@ -596,6 +615,17 @@
 
 
 /*
+ * Generic PNMI IOCTL subcommand definitions.
+ */
+#define	SK_GET_SINGLE_VAR		1
+#define	SK_SET_SINGLE_VAR		2
+#define	SK_PRESET_SINGLE_VAR	3
+#define	SK_GET_FULL_MIB			4
+#define	SK_SET_FULL_MIB			5
+#define	SK_PRESET_FULL_MIB		6
+
+
+/*
  * Define error numbers and messages for syslog
  */
 #define SK_PNMI_ERR001		(SK_ERRBASE_PNMI + 1)
@@ -1095,20 +1125,22 @@
 /*
  * Function prototypes
  */
-extern int SkPnmiInit(SK_AC *pAc, SK_IOC IoC, int level);
-extern int SkPnmiGetVar(SK_AC *pAc, SK_IOC IoC, SK_U32 Id, void* pBuf,
+extern int SkPnmiInit(SK_AC *pAC, SK_IOC IoC, int Level);
+extern int SkPnmiGetVar(SK_AC *pAC, SK_IOC IoC, SK_U32 Id, void* pBuf,
 	unsigned int* pLen, SK_U32 Instance, SK_U32 NetIndex);
-extern int SkPnmiPreSetVar(SK_AC *pAc, SK_IOC IoC, SK_U32 Id,
+extern int SkPnmiPreSetVar(SK_AC *pAC, SK_IOC IoC, SK_U32 Id,
 	void* pBuf, unsigned int *pLen, SK_U32 Instance, SK_U32 NetIndex);
-extern int SkPnmiSetVar(SK_AC *pAc, SK_IOC IoC, SK_U32 Id, void* pBuf,
+extern int SkPnmiSetVar(SK_AC *pAC, SK_IOC IoC, SK_U32 Id, void* pBuf,
 	unsigned int *pLen, SK_U32 Instance, SK_U32 NetIndex);
-extern int SkPnmiGetStruct(SK_AC *pAc, SK_IOC IoC, void* pBuf,
+extern int SkPnmiGetStruct(SK_AC *pAC, SK_IOC IoC, void* pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
-extern int SkPnmiPreSetStruct(SK_AC *pAc, SK_IOC IoC, void* pBuf,
+extern int SkPnmiPreSetStruct(SK_AC *pAC, SK_IOC IoC, void* pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
-extern int SkPnmiSetStruct(SK_AC *pAc, SK_IOC IoC, void* pBuf,
+extern int SkPnmiSetStruct(SK_AC *pAC, SK_IOC IoC, void* pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
-extern int SkPnmiEvent(SK_AC *pAc, SK_IOC IoC, SK_U32 Event,
+extern int SkPnmiEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event,
 	SK_EVPARA Param);
+extern int SkPnmiGenIoctl(SK_AC *pAC, SK_IOC IoC, void * pBuf,
+	unsigned int * pLen, SK_U32 NetIndex);
 
 #endif
diff -Nru a/drivers/net/sk98lin/h/skgesirq.h b/drivers/net/sk98lin/h/skgesirq.h
--- a/drivers/net/sk98lin/h/skgesirq.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skgesirq.h	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skgesirq.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.26 $
- * Date:	$Date: 2002/10/14 09:52:36 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.30 $
+ * Date:	$Date: 2003/07/04 12:34:13 $
  * Purpose:	SK specific Gigabit Ethernet special IRQ functions
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -25,8 +26,22 @@
  *
  * History:
  *	$Log: skgesirq.h,v $
+ *	Revision 1.30  2003/07/04 12:34:13  rschmidt
+ *	Added SKERR_SIRQ_E025 for Downshift detected (Yukon-Copper)
+ *	
+ *	Revision 1.29  2003/05/28 15:14:49  rschmidt
+ *	Moved defines for return codes of SkGePortCheckUp() to header file.
+ *	Minor changes to avoid LINT warnings.
+ *	
+ *	Revision 1.28  2003/05/13 17:22:43  mkarl
+ *	Editorial changes.
+ *	
+ *	Revision 1.27  2003/03/31 07:32:34  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
  *	Revision 1.26  2002/10/14 09:52:36  rschmidt
- *	Added SKERR_SIRQ_E023 and SKERR_SIRQ_E023 for GPHY (Yukon)
+ *	Added SKERR_SIRQ_E023 and SKERR_SIRQ_E024 for GPHY (Yukon)
  *	Editorial changes
  *	
  *	Revision 1.25  2002/07/15 18:15:52  rwahl
@@ -115,10 +130,15 @@
 #ifndef _INC_SKGESIRQ_H_
 #define _INC_SKGESIRQ_H_
 
+/* Define return codes of SkGePortCheckUp and CheckShort */
+#define	SK_HW_PS_NONE		0	/* No action needed */
+#define	SK_HW_PS_RESTART	1	/* Restart needed */
+#define	SK_HW_PS_LINK		2	/* Link Up actions needed */
+
 /*
  * Define the Event the special IRQ/INI module can handle
  */
-#define SK_HWEV_WATIM			1	/* Timeout for WA errata #2 XMAC */
+#define SK_HWEV_WATIM			1	/* Timeout for WA Errata #2 XMAC */
 #define SK_HWEV_PORT_START		2	/* Port Start Event by RLMT */
 #define SK_HWEV_PORT_STOP		3	/* Port Stop Event by RLMT */
 #define SK_HWEV_CLEAR_STAT		4	/* Clear Statistics by PNMI */
@@ -129,10 +149,10 @@
 #define SK_HWEV_SET_SPEED		9	/* Set Link Speed by PNMI */
 #define SK_HWEV_HALFDUP_CHK		10	/* Half Duplex Hangup Workaround */
 
-#define SK_WA_ACT_TIME		(5000000L)	/* 5 sec */
-#define SK_WA_INA_TIME		(100000L)	/* 100 msec */
+#define SK_WA_ACT_TIME		(5000000UL)	/* 5 sec */
+#define SK_WA_INA_TIME		(100000UL)	/* 100 msec */
 
-#define SK_HALFDUP_CHK_TIME	(10000L)	/* 10 msec */
+#define SK_HALFDUP_CHK_TIME	(10000UL)	/* 10 msec */
 
 /*
  * Define the error numbers and messages
@@ -185,6 +205,8 @@
 #define SKERR_SIRQ_E023MSG	"Auto-negotiation error"
 #define SKERR_SIRQ_E024		(SKERR_SIRQ_E023+1)
 #define SKERR_SIRQ_E024MSG	"FIFO overflow error"
+#define SKERR_SIRQ_E025		(SKERR_SIRQ_E024+1)
+#define SKERR_SIRQ_E025MSG	"2 Pair Downshift detected"
 
 extern void SkGeSirqIsr(SK_AC *pAC, SK_IOC IoC, SK_U32 Istatus);
 extern int  SkGeSirqEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event, SK_EVPARA Para);
diff -Nru a/drivers/net/sk98lin/h/ski2c.h b/drivers/net/sk98lin/h/ski2c.h
--- a/drivers/net/sk98lin/h/ski2c.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/ski2c.h	Wed Sep  3 22:38:48 2003
@@ -2,17 +2,15 @@
  *
  * Name:	ski2c.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.33 $
- * Date:	$Date: 2002/10/14 16:40:50 $
+ * Version:	$Revision: 1.34 $
+ * Date:	$Date: 2003/01/28 09:11:21 $
  * Purpose:	Defines to access Voltage and Temperature Sensor
- *		(taken from Monalisa (taken from Concentrator))
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -28,6 +26,9 @@
  * History:
  *
  *	$Log: ski2c.h,v $
+ *	Revision 1.34  2003/01/28 09:11:21  rschmidt
+ *	Editorial changes
+ *	
  *	Revision 1.33  2002/10/14 16:40:50  rschmidt
  *	Editorial changes (TWSI)
  *	
@@ -163,7 +164,7 @@
 #define I2C_READ	0
 #define I2C_WRITE	1
 #define I2C_BURST	1
-#define I2C_SIGLE	0
+#define I2C_SINGLE	0
 
 #define SKERR_I2C_E001		(SK_ERRBASE_I2C+0)
 #define SKERR_I2C_E001MSG	"Sensor index unknown"
diff -Nru a/drivers/net/sk98lin/h/skqueue.h b/drivers/net/sk98lin/h/skqueue.h
--- a/drivers/net/sk98lin/h/skqueue.h	Wed Sep  3 22:38:49 2003
+++ b/drivers/net/sk98lin/h/skqueue.h	Wed Sep  3 22:38:49 2003
@@ -1,17 +1,17 @@
 /******************************************************************************
  *
  * Name:	skqueue.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.14 $
- * Date:	$Date: 2002/03/15 10:52:13 $
+ * Project:	Gigabit Ethernet Adapters, Schedule-Modul
+ * Version:	$Revision: 1.15 $
+ * Date:	$Date: 2003/05/13 17:54:57 $
  * Purpose:	Defines for the Event queue
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: skqueue.h,v $
+ *	Revision 1.15  2003/05/13 17:54:57  mkarl
+ *	Editorial changes.
+ *	
  *	Revision 1.14  2002/03/15 10:52:13  mkunz
  *	Added event classes for link aggregation
  *	
diff -Nru a/drivers/net/sk98lin/h/skrlmt.h b/drivers/net/sk98lin/h/skrlmt.h
--- a/drivers/net/sk98lin/h/skrlmt.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skrlmt.h	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skrlmt.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.33 $
- * Date:	$Date: 2001/07/03 12:16:48 $
+ * Version:	$Revision: 1.37 $
+ * Date:	$Date: 2003/04/15 09:43:43 $
  * Purpose:	Header file for Redundant Link ManagemenT.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,18 @@
  * History:
  *
  *	$Log: skrlmt.h,v $
+ *	Revision 1.37  2003/04/15 09:43:43  tschilli
+ *	Copyright messages changed.
+ *	
+ *	Revision 1.36  2003/04/14 15:56:22  tschilli
+ *	"#error C++ is not yet supported." removed.
+ *	
+ *	Revision 1.35  2003/01/31 14:12:41  mkunz
+ *	single port adapter runs now with two identical MAC addresses
+ *	
+ *	Revision 1.34  2002/09/23 15:13:41  rwahl
+ *	Editorial changes.
+ *	
  *	Revision 1.33  2001/07/03 12:16:48  mkunz
  *	New Flag ChgBcPrio (Change priority of last broadcast received)
  *	
@@ -163,7 +176,6 @@
 #define __INC_SKRLMT_H
 
 #ifdef __cplusplus
-#error C++ is not yet supported.
 extern "C" {
 #endif	/* cplusplus */
 
@@ -286,28 +298,33 @@
 	_PortNum = (SK_U32)(PortNum); \
 	/* _pAC->Rlmt.Port[_PortNum].PacketsRx++; */ \
 	_pAC->Rlmt.Port[_PortNum].PacketsPerTimeSlot++; \
-	if ((_pAC->Rlmt.Port[_PortNum].Net->RlmtMode & SK_RLMT_TRANSPARENT) != 0) { \
+    if (_pAC->Rlmt.RlmtOff) { \
 		*(pNumBytes) = 0; \
-	} \
-	else if (IsBc) { \
-		if (_pAC->Rlmt.Port[_PortNum].Net->RlmtMode != SK_RLMT_MODE_CLS) { \
-			*(pNumBytes) = 6; \
-			*(pOffset) = 6; \
-		} \
-		else { \
-			*(pNumBytes) = 0; \
-		} \
-	} \
-	else { \
-		if ((PktLen) > SK_RLMT_MAX_TX_BUF_SIZE) { \
-			/* _pAC->Rlmt.Port[_PortNum].DataPacketsPerTimeSlot++; */ \
-			*(pNumBytes) = 0; \
-		} \
-		else { \
-			*(pNumBytes) = 6; \
-			*(pOffset) = 0; \
-		} \
-	} \
+    } \
+    else {\
+        if ((_pAC->Rlmt.Port[_PortNum].Net->RlmtMode & SK_RLMT_TRANSPARENT) != 0) { \
+    		*(pNumBytes) = 0; \
+    	} \
+    	else if (IsBc) { \
+    		if (_pAC->Rlmt.Port[_PortNum].Net->RlmtMode != SK_RLMT_MODE_CLS) { \
+    			*(pNumBytes) = 6; \
+    			*(pOffset) = 6; \
+    		} \
+    		else { \
+    			*(pNumBytes) = 0; \
+    		} \
+    	} \
+    	else { \
+    		if ((PktLen) > SK_RLMT_MAX_TX_BUF_SIZE) { \
+    			/* _pAC->Rlmt.Port[_PortNum].DataPacketsPerTimeSlot++; */ \
+    			*(pNumBytes) = 0; \
+    		} \
+    		else { \
+    			*(pNumBytes) = 6; \
+    			*(pOffset) = 0; \
+    		} \
+    	} \
+    } \
 }
 
 #if 0
@@ -505,8 +522,10 @@
 
 /* ----- Private part ----- */
 	SK_BOOL			CheckSwitch;
-	SK_U8			Align01;
-	SK_U16			Align02;
+	SK_BOOL			RlmtOff;            /* set to zero if the Mac addresses 
+                                           are equal or the second one 
+                                           is zero */
+	SK_U16			Align01;
 
 } SK_RLMT;
 
diff -Nru a/drivers/net/sk98lin/h/sktimer.h b/drivers/net/sk98lin/h/sktimer.h
--- a/drivers/net/sk98lin/h/sktimer.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/sktimer.h	Wed Sep  3 22:38:48 2003
@@ -1,17 +1,17 @@
 /******************************************************************************
  *
  * Name:	sktimer.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.9 $
- * Date:	$Date: 1999/11/22 14:00:29 $
+ * Project:	Gigabit Ethernet Adapters, Schedule-Modul
+ * Version:	$Revision: 1.10 $
+ * Date:	$Date: 2003/05/13 17:56:44 $
  * Purpose:	Defines for the timer functions
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: sktimer.h,v $
+ *	Revision 1.10  2003/05/13 17:56:44  mkarl
+ *	Editorial changes.
+ *	
  *	Revision 1.9  1999/11/22 14:00:29  cgoos
  *	Changed license header to GPL.
  *	
diff -Nru a/drivers/net/sk98lin/h/sktypes.h b/drivers/net/sk98lin/h/sktypes.h
--- a/drivers/net/sk98lin/h/sktypes.h	Wed Sep  3 22:38:49 2003
+++ b/drivers/net/sk98lin/h/sktypes.h	Wed Sep  3 22:38:49 2003
@@ -2,16 +2,15 @@
  *
  * Name:	sktypes.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.2 $
- * Date:	$Date: 1999/11/22 14:01:58 $
+ * Version:	$Revision: 1.1 $
+ * Date:	$Date: 2003/07/21 07:26:01 $
  * Purpose:	Define data types for Linux
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,12 @@
  * History:
  *
  *	$Log: sktypes.h,v $
+ *	Revision 1.1  2003/07/21 07:26:01  rroesler
+ *	Fix: Re-Enter after CVS crash
+ *	
+ *	Revision 1.3  2003/02/25 14:16:40  mlindner
+ *	Fix: Copyright statement
+ *	
  *	Revision 1.2  1999/11/22 14:01:58  cgoos
  *	Changed license header to GPL.
  *	Now using Linux' fixed size types instead of standard types.
diff -Nru a/drivers/net/sk98lin/h/skversion.h b/drivers/net/sk98lin/h/skversion.h
--- a/drivers/net/sk98lin/h/skversion.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skversion.h	Wed Sep  3 22:38:48 2003
@@ -2,16 +2,15 @@
  *
  * Name:	version.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.1.2.1 $
- * Date:	$Date: 2001/09/05 13:38:30 $
+ * Version:	$Revision: 1.2 $
+ * Date:	$Date: 2003/08/13 12:01:01 $
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +25,18 @@
  *
  * History:
  *	$Log: skversion.h,v $
+ *	Revision 1.2  2003/08/13 12:01:01  mlindner
+ *	Add: Changes for Lint
+ *	
+ *	Revision 1.1  2003/07/24 09:29:56  rroesler
+ *	Fix: Re-Enter after CVS crash
+ *	
+ *	Revision 1.4  2003/02/25 14:16:40  mlindner
+ *	Fix: Copyright statement
+ *	
+ *	Revision 1.3  2003/02/25 13:30:18  mlindner
+ *	Add: Support for various vendors
+ *	
  *	Revision 1.1.2.1  2001/09/05 13:38:30  mlindner
  *	Removed FILE description
  *	
@@ -37,13 +48,15 @@
  ******************************************************************************/
  
  
+#ifdef	lint
 static const char SysKonnectFileId[] = "@(#) (C) SysKonnect GmbH.";
 static const char SysKonnectBuildNumber[] =
-	"@(#)SK-BUILD: 6.02 PL: 01"; 
+	"@(#)SK-BUILD: 6.17 PL: 01"; 
+#endif	/* !defined(lint) */
 
-#define BOOT_STRING	"sk98lin: Network Device Driver v6.02\n" \
-			"Copyright (C) 2000-2002 SysKonnect GmbH."
+#define BOOT_STRING	"sk98lin: Network Device Driver v6.17\n" \
+			"(C)Copyright 1999-2003 Marvell(R)."
 
-#define VER_STRING	"6.02"
+#define VER_STRING	"6.17"
 
 
diff -Nru a/drivers/net/sk98lin/h/skvpd.h b/drivers/net/sk98lin/h/skvpd.h
--- a/drivers/net/sk98lin/h/skvpd.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/skvpd.h	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,15 @@
  *
  * Name:	skvpd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.13 $
- * Date:	$Date: 2002/10/14 15:58:18 $
+ * Version:	$Revision: 1.15 $
+ * Date:	$Date: 2003/01/13 10:39:38 $
  * Purpose:	Defines and Macros for VPD handling
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +26,14 @@
  * History:
  *
  *	$Log: skvpd.h,v $
+ *	Revision 1.15  2003/01/13 10:39:38  rschmidt
+ *	Replaced define for PCI device Id for YUKON with GENESIS
+ *	Editorial changes
+ *	
+ *	Revision 1.14  2002/11/14 15:18:10  gheinig
+ *	Added const specifier to key and buf parameters for VpdPara,VpdRead
+ *	and VpdWrite. This is necessary for the Diag 7 GUI API
+ *	
  *	Revision 1.13  2002/10/14 15:58:18  rschmidt
  *	Added entry in rom_size struct s_vpd
  *	Editorial changes
@@ -63,7 +71,7 @@
  *	Changed constants in SK_SWAP_32 to UL.
  *	
  *	Revision 1.4  1998/08/19 08:14:09  gklug
- *	fix: remove struct keyword as much as possible from the c-code (see CCC)
+ *	fix: remove struct keyword as much as possible from the C-code (see CCC)
  *	
  *	Revision 1.3  1998/08/18 08:18:56  malthoff
  *	Modify VPD in and out macros for SK_DIAG
@@ -118,7 +126,7 @@
  * Define READ and WRITE Constants.
  */
 
-#define VPD_PCI_ID_YUKON 	0x4320
+#define VPD_DEV_ID_GENESIS 	0x4300
 
 #define	VPD_SIZE_YUKON		256
 #define	VPD_SIZE_GENESIS	512
@@ -249,8 +257,8 @@
 
 extern int	VpdSetupPara(
 	SK_AC		*pAC,
-	char		*key,
-	char		*buf,
+	const char	*key,
+	const char	*buf,
 	int			len,
 	int			type,
 	int			op);
@@ -269,7 +277,7 @@
 extern int	VpdRead(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
-	char		*key,
+	const char	*key,
 	char		*buf,
 	int			*len);
 
@@ -279,8 +287,8 @@
 extern int	VpdWrite(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
-	char		*key,
-	char		*buf);
+	const char	*key,
+	const char	*buf);
 
 extern int	VpdDelete(
 	SK_AC		*pAC,
diff -Nru a/drivers/net/sk98lin/h/xmac_ii.h b/drivers/net/sk98lin/h/xmac_ii.h
--- a/drivers/net/sk98lin/h/xmac_ii.h	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/h/xmac_ii.h	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	xmac_ii.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.45 $
- * Date:	$Date: 2002/12/10 14:35:13 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.48 $
+ * Date:	$Date: 2003/05/13 17:17:55 $
  * Purpose:	Defines and Macros for Gigabit Ethernet Controller
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,18 @@
  * History:
  *
  *	$Log: xmac_ii.h,v $
+ *	Revision 1.48  2003/05/13 17:17:55  mkarl
+ *	Editorial changes.
+ *	
+ *	Revision 1.47  2003/03/31 07:37:25  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.46  2003/01/28 09:47:45  rschmidt
+ *	Added defines for copper MDI/MDIX configuration
+ *	Added defines for LED Control Register
+ *	Editorial changes
+ *	
  *	Revision 1.45  2002/12/10 14:35:13  rschmidt
  *	Corrected defines for Extended PHY Specific Control
  *	Added defines for Ext. PHY Specific Ctrl 2 Reg. (Fiber specific)
@@ -925,9 +938,9 @@
 /*****  PHY_BCOM_NEPG_LP	16 bit r/o	Next Page Link Partner *****/
 /*****  PHY_LONE_NEPG_LP	16 bit r/o	Next Page Link Partner *****/
 #define PHY_NP_MORE		(1<<15)	/* Bit 15:	More, Next Pages to follow */
-#define PHY_NP_ACK1		(1<<14)	/* Bit 14: (ro)	Ack 1, for receiving a message*/
+#define PHY_NP_ACK1		(1<<14)	/* Bit 14: (ro)	Ack1, for receiving a message */
 #define PHY_NP_MSG_VAL	(1<<13)	/* Bit 13:	Message Page valid */
-#define PHY_NP_ACK2		(1<<12)	/* Bit 12:	Ack 2, comply with msg content*/
+#define PHY_NP_ACK2		(1<<12)	/* Bit 12:	Ack2, comply with msg content */
 #define PHY_NP_TOG		(1<<11)	/* Bit 11:	Toggle Bit, ensure sync */
 #define PHY_NP_MSG		0x07ff	/* Bit 10..0:	Message from/to Link Partner */
 
@@ -1118,7 +1131,7 @@
 #define PHY_L_1000S_MSF		(1<<15)	/* Bit 15:	Master/Slave Fault */
 #define PHY_L_1000S_MSR		(1<<14)	/* Bit 14:	Master/Slave Result */
 #define PHY_L_1000S_LRS		(1<<13)	/* Bit 13:	Local Receiver Status */
-#define PHY_L_1000S_RRS		(1<<12)	/* Bit 12:	Remote Receiver Status*/
+#define PHY_L_1000S_RRS		(1<<12)	/* Bit 12:	Remote Receiver Status */
 #define PHY_L_1000S_LP_FD	(1<<11)	/* Bit 11:	Link Partner can FD */
 #define PHY_L_1000S_LP_HD	(1<<10)	/* Bit 10:	Link Partner can HD */
 									/* Bit  9..8:	reserved */
@@ -1170,8 +1183,8 @@
 #define PHY_L_IS_AN_F		(1<<13)	/* Bit 13:	Auto-Negotiation fault */
 									/* Bit 12:	not described */
 #define PHY_L_IS_CROSS		(1<<11)	/* Bit 11:	Crossover used */
-#define PHY_L_IS_POL		(1<<10)	/* Bit 10:	Polarity correct. used*/
-#define PHY_L_IS_SS			(1<<9)	/* Bit  9:	Smart Speed Downgrade*/
+#define PHY_L_IS_POL		(1<<10)	/* Bit 10:	Polarity correct. used */
+#define PHY_L_IS_SS			(1<<9)	/* Bit  9:	Smart Speed Downgrade */
 #define PHY_L_IS_CFULL		(1<<8)	/* Bit  8:	Counter Full */
 #define PHY_L_IS_AN_C		(1<<7)	/* Bit  7:	AutoNeg Complete */
 #define PHY_L_IS_SPEED		(1<<6)	/* Bit  6:	Speed Changed */
@@ -1262,8 +1275,9 @@
  * Marvell-Specific
  */
 /*****  PHY_MARV_AUNE_ADV	16 bit r/w	Auto-Negotiation Advertisement *****/
+/*****  PHY_MARV_AUNE_LP	16 bit r/w	Link Part Ability Reg *****/
 #define PHY_M_AN_NXT_PG		BIT_15	/* Request Next Page */
-									/* Bit 14:	reserved */
+#define PHY_M_AN_ACK		BIT_14	/* (ro)	Acknowledge Received */
 #define PHY_M_AN_RF			BIT_13	/* Remote Fault */
 									/* Bit 12:	reserved */
 #define PHY_M_AN_ASP		BIT_11	/* Asymmetric Pause */
@@ -1309,6 +1323,10 @@
 #define PHY_M_PC_POL_R_DIS	(1<<1)	/* Bit  1:	Polarity Reversal Disabled */
 #define PHY_M_PC_DIS_JABBER	(1<<0)	/* Bit  0:	Disable Jabber */
 
+#define PHY_M_PC_MDI_XMODE(x)	SHIFT5(x)	
+#define PHY_M_PC_MAN_MDI	0    	/* 00 = Manual MDI configuration */
+#define PHY_M_PC_MAN_MDIX	1		/* 01 = Manual MDIX configuration */
+#define PHY_M_PC_ENA_AUTO	3		/* 11 = Enable Automatic Crossover */
 
 /*****  PHY_MARV_PHY_STAT	16 bit r/o	PHY Specific Status Reg *****/
 #define PHY_M_PS_SPEED_MSK	(3<<14)	/* Bit 15..14:	Speed Mask */
@@ -1366,26 +1384,35 @@
 
 /*****  PHY_MARV_LED_CTRL	16 bit r/w	LED Control Reg *****/
 #define PHY_M_LEDC_DIS_LED	(1<<15)	/* Bit 15:	Disable LED */
-
-#define PHY_M_LED_BL_RATE(x)	SHIFT12(x)	/* Bit 12..14:  Blink Rate */
-
-/* values for PHY_M_LED_BL_RATE() */
-#define	BL_DEFAULT	0		/* no pulse stretching */
-#define	BL_21MS		1		/* 21 ms to 42ms */
-#define BL_42MS		2		/* 42 ms to 84ms */
-#define BL_84MS		3		/* 84 ms to 170ms */
-#define BL_170MS	4		/* 170 ms to340ms */
-#define BL_340MS	5		/* 340 ms to670ms */
-#define BL_670MS	6		/* 670 ms to 1.3s */
-#define BL_1300MS	7		/* 1.3s to 2.7s */
-
+#define PHY_M_LEDC_PULS_MSK	(7<<12)	/* Bit 14..12:  Pulse Stretch Mask */
 #define PHY_M_LEDC_F_INT	(1<<11)	/* Bit 11:	Force Interrupt */
-
-#define PHY_M_LEDC_LINK_MSK	(3<<3)	/* Bit  4..3:	Link Control */
+#define PHY_M_LEDC_BL_R_MSK	(7<<8)	/* Bit 10.. 8:  Blink Rate Mask */
+									/* Bit  7.. 5:	reserved */
+#define PHY_M_LEDC_LINK_MSK	(3<<3)	/* Bit  4.. 3:	Link Control Mask */
 #define PHY_M_LEDC_DP_CTRL	(1<<2)	/* Bit  2:	Duplex Control */
 #define PHY_M_LEDC_RX_CTRL	(1<<1)	/* Bit  1:	Rx activity / Link */
 #define PHY_M_LEDC_TX_CTRL	(1<<0)	/* Bit  0:	Tx activity / Link */
 
+#define PHY_M_LED_PULS_DUR(x)	SHIFT12(x)	/* Pulse Stretch Duration */
+
+#define	PULS_NO_STR		0		/* no pulse stretching */
+#define	PULS_21MS		1		/* 21 ms to 42 ms */
+#define PULS_42MS		2		/* 42 ms to 84 ms */
+#define PULS_84MS		3		/* 84 ms to 170 ms */
+#define PULS_170MS		4		/* 170 ms to 340 ms */
+#define PULS_340MS		5		/* 340 ms to 670 ms */
+#define PULS_670MS		6		/* 670 ms to 1.3 s */
+#define PULS_1300MS		7		/* 1.3 s to 2.7 s */
+
+#define PHY_M_LED_BLINK_RT(x)	SHIFT8(x)	/* Blink Rate */
+
+#define BLINK_42MS		0		/* 42 ms */
+#define BLINK_84MS		1		/* 84 ms */
+#define BLINK_170MS		2		/* 170 ms */
+#define BLINK_340MS		3		/* 340 ms */
+#define BLINK_670MS		4		/* 670 ms */
+								/* values 5 - 7: reserved */
+
 /*****  PHY_MARV_LED_OVER	16 bit r/w	Manual LED Override Reg *****/
 #define PHY_M_LED_MO_DUP(x)		SHIFT10(x)	/* Bit 11..10:  Duplex */
 #define PHY_M_LED_MO_10(x)		SHIFT8(x)	/* Bit  9.. 8:  Link 10 */
@@ -1441,7 +1468,7 @@
 #define GM_GP_CTRL		0x0004		/* 16 bit r/w	General Purpose Control */
 #define GM_TX_CTRL		0x0008		/* 16 bit r/w	Transmit Control Reg. */
 #define GM_RX_CTRL		0x000c		/* 16 bit r/w	Receive Control Reg. */
-#define GM_TX_FLOW_CTRL	0x0010		/* 16 bit r/w	Transmit Flow Control */
+#define GM_TX_FLOW_CTRL	0x0010		/* 16 bit r/w	Transmit Flow-Control */
 #define GM_TX_PARAM		0x0014		/* 16 bit r/w	Transmit Parameter Reg. */
 #define GM_SERIAL_MODE	0x0018		/* 16 bit r/w	Serial Mode Register */
 
@@ -1582,7 +1609,7 @@
 
 #define GM_GPSR_SPEED		(1<<15) /* Bit 15:	Port Speed (1 = 100 Mbps) */
 #define GM_GPSR_DUPLEX		(1<<14) /* Bit 14:	Duplex Mode (1 = Full) */
-#define GM_GPSR_FC_TX_DIS	(1<<13) /* Bit 13:	Tx Flow Control Mode Disabled */
+#define GM_GPSR_FC_TX_DIS	(1<<13) /* Bit 13:	Tx Flow-Control Mode Disabled */
 #define GM_GPSR_LINK_UP		(1<<12)	/* Bit 12:	Link Up Status */
 #define GM_GPSR_PAUSE		(1<<11)	/* Bit 11:	Pause State */
 #define GM_GPSR_TX_ACTIVE	(1<<10)	/* Bit 10:	Tx in Progress */
@@ -1592,14 +1619,14 @@
 #define GM_GPSR_PHY_ST_CH	(1<<5)	/* Bit  5:	PHY Status Change */
 #define GM_GPSR_GIG_SPEED	(1<<4)	/* Bit  4:	Gigabit Speed (1 = 1000 Mbps) */
 #define GM_GPSR_PART_MODE	(1<<3)	/* Bit  3:	Partition mode */
-#define GM_GPSR_FC_RX_DIS	(1<<2)	/* Bit  2:	Rx Flow Control Mode Disabled */
+#define GM_GPSR_FC_RX_DIS	(1<<2)	/* Bit  2:	Rx Flow-Control Mode Disabled */
 #define GM_GPSR_PROM_EN		(1<<1)	/* Bit  1:	Promiscuous Mode Enabled */
 								/* Bit  0:	reserved */
 	
 /*	GM_GP_CTRL	16 bit r/w	General Purpose Control Register */
 								/* Bit 15:	reserved */
 #define GM_GPCR_PROM_ENA	(1<<14)	/* Bit 14:	Enable Promiscuous Mode */
-#define GM_GPCR_FC_TX_DIS	(1<<13) /* Bit 13:	Disable Tx Flow Control Mode */
+#define GM_GPCR_FC_TX_DIS	(1<<13) /* Bit 13:	Disable Tx Flow-Control Mode */
 #define GM_GPCR_TX_ENA		(1<<12) /* Bit 12:	Enable Transmit */
 #define GM_GPCR_RX_ENA		(1<<11) /* Bit 11:	Enable Receive */
 #define GM_GPCR_BURST_ENA	(1<<10)	/* Bit 10:	Enable Burst Mode */
@@ -1608,11 +1635,11 @@
 #define GM_GPCR_GIGS_ENA	(1<<7)	/* Bit  7:	Gigabit Speed (1000 Mbps) */
 #define GM_GPCR_FL_PASS		(1<<6)	/* Bit  6:	Force Link Pass */
 #define GM_GPCR_DUP_FULL	(1<<5)	/* Bit  5:	Full Duplex Mode */
-#define GM_GPCR_FC_RX_DIS	(1<<4)	/* Bit  4:	Disable Rx Flow Control Mode */
+#define GM_GPCR_FC_RX_DIS	(1<<4)	/* Bit  4:	Disable Rx Flow-Control Mode */
 #define GM_GPCR_SPEED_100	(1<<3)  /* Bit  3:	Port Speed 100 Mbps */
-#define GM_GPCR_AU_DUP_DIS	(1<<2)	/* Bit  2:	Disable Auto-Update for Duplex */
-#define GM_GPCR_AU_FCT_DIS	(1<<1)	/* Bit  1:	Disable Auto-Update for Flow-c. */
-#define GM_GPCR_AU_SPD_DIS	(1<<0)	/* Bit  0:	Disable Auto-Update for Speed */
+#define GM_GPCR_AU_DUP_DIS	(1<<2)	/* Bit  2:	Disable Auto-Update Duplex */
+#define GM_GPCR_AU_FCT_DIS	(1<<1)	/* Bit  1:	Disable Auto-Update Flow-C. */
+#define GM_GPCR_AU_SPD_DIS	(1<<0)	/* Bit  0:	Disable Auto-Update Speed */
 
 #define GM_GPCR_SPEED_1000	(GM_GPCR_GIGS_ENA | GM_GPCR_SPEED_100)
 #define GM_GPCR_AU_ALL_DIS	(GM_GPCR_AU_DUP_DIS | GM_GPCR_AU_FCT_DIS |\
@@ -1642,9 +1669,9 @@
 
 /*	GM_SERIAL_MODE			16 bit r/w	Serial Mode Register */
 #define GM_SMOD_DATABL_MSK	(0x1f<<11)	/* Bit 15..11:	Data Blinder */
-#define GM_SMOD_LIMIT_4		(1<<10)	/* Bit 10:	4 consecutive transmit trials */
-#define GM_SMOD_VLAN_ENA	(1<<9)	/* Bit  9:	Enable VLAN  (Max. Frame Length) */
-#define GM_SMOD_JUMBO_ENA	(1<<8)	/* Bit  8:	Enable Jumbo (Max. Frame Length) */
+#define GM_SMOD_LIMIT_4		(1<<10)	/* Bit 10:	4 consecutive Tx trials */
+#define GM_SMOD_VLAN_ENA	(1<<9)	/* Bit  9:	Enable VLAN  (Max. Frame Len) */
+#define GM_SMOD_JUMBO_ENA	(1<<8)	/* Bit  8:	Enable Jumbo (Max. Frame Len) */
 								/* Bit  7..5:	reserved */
 #define GM_SMOD_IPG_MSK		0x1f	/* Bit 4..0:	Inter-Packet Gap (IPG) */
 	
diff -Nru a/drivers/net/sk98lin/skaddr.c b/drivers/net/sk98lin/skaddr.c
--- a/drivers/net/sk98lin/skaddr.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skaddr.c	Wed Sep  3 22:38:48 2003
@@ -1,9 +1,9 @@
 /******************************************************************************
  *
  * Name:	skaddr.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.47 $
- * Date:	$Date: 2002/09/17 06:31:10 $
+ * Project:	Gigabit Ethernet Adapters, ADDR-Module
+ * Version:	$Revision: 1.52 $
+ * Date:	$Date: 2003/06/02 13:46:15 $
  * Purpose:	Manage Addresses (Multicast and Unicast) and Promiscuous Mode.
  *
  ******************************************************************************/
@@ -11,6 +11,7 @@
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,30 @@
  * History:
  *
  *	$Log: skaddr.c,v $
+ *	Revision 1.52  2003/06/02 13:46:15  tschilli
+ *	Editorial changes.
+ *	
+ *	Revision 1.51  2003/05/13 17:12:43  mkarl
+ *	Changes for SLIM Driver via SK_SLIM.
+ *	Changes for driver not using RLMT via SK_NO_RLMT.
+ *	Changes for driver not supporting MAC address override via SK_NO_MAO.
+ *	Separeted GENESIS and YUKON only code to reduce code size.
+ *	Editorial changes.
+ *	
+ *	Revision 1.50  2003/05/08 12:29:31  rschmidt
+ *	Replaced all if(GIChipId == CHIP_ID_GENESIS) with new entry GIGenesis.
+ *	Changed initialisation for Next0[SK_MAX_MACS] to avoid
+ *	compiler errors when SK_MAX_MACS=1.
+ *	Editorial changes.
+ *	
+ *	Revision 1.49  2003/04/15 09:30:51  tschilli
+ *	Copyright messages changed.
+ *	"#error C++ is not yet supported." removed.
+ *	
+ *	Revision 1.48  2003/02/12 17:09:37  tschilli
+ *	Fix in SkAddrOverride() to set both (physical and logical) MAC addresses
+ *	in case that both addresses are identical.
+ *	
  *	Revision 1.47  2002/09/17 06:31:10  tschilli
  *	Handling of SK_PROM_MODE_ALL_MC flag in SkAddrGmacMcUpdate()
  *	and SkAddrGmacPromiscuousChange() fixed.
@@ -214,15 +239,14 @@
  *
  ******************************************************************************/
 
-#ifndef	lint
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skaddr.c,v 1.47 2002/09/17 06:31:10 tschilli Exp $ (C) SysKonnect.";
-#endif	/* !defined(lint) */
+	"@(#) $Id: skaddr.c,v 1.52 2003/06/02 13:46:15 tschilli Exp $ (C) Marvell.";
+#endif /* DEBUG ||!LINT || !SK_SLIM */
 
 #define __SKADDR_C
 
 #ifdef __cplusplus
-#error C++ is not yet supported.
 extern "C" {
 #endif	/* cplusplus */
 
@@ -257,7 +281,7 @@
 /* local variables ************************************************************/
 
 #ifdef DEBUG
-static int	Next0[SK_MAX_MACS] = {0, 0};
+static int	Next0[SK_MAX_MACS] = {0};
 #endif	/* DEBUG */
 
 /* functions ******************************************************************/
@@ -309,7 +333,8 @@
 
 	switch (Level) {
 	case SK_INIT_DATA:
-		SK_MEMSET((char *) &pAC->Addr, 0, sizeof(SK_ADDR));
+		SK_MEMSET((char *) &pAC->Addr, (SK_U8) 0,
+            (SK_U16) sizeof(SK_ADDR));
 
 		for (i = 0; i < SK_MAX_MACS; i++) {
 			pAPort = &pAC->Addr.Port[i];
@@ -331,10 +356,12 @@
 		/* pAC->Addr.InitDone = SK_INIT_DATA; */
 		break;
 
-	case SK_INIT_IO:
+    case SK_INIT_IO:
+#ifndef SK_NO_RLMT
 		for (i = 0; i < SK_MAX_NETS; i++) {
 			pAC->Addr.Net[i].ActivePort = pAC->Rlmt.Net[i].ActivePort;
 		}
+#endif /* !SK_NO_RLMT */
 #ifdef xDEBUG
 		for (i = 0; i < SK_MAX_MACS; i++) {
 			if (pAC->Addr.Port[i].NextExactMatchRlmt <
@@ -418,13 +445,16 @@
 
 			/* Set port's current physical MAC address. */
 			OutAddr = (SK_U16 *) &pAPort->CurrentMacAddress.a[0];
-			
-			if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+#ifdef GENESIS
+			if (pAC->GIni.GIGenesis) {
 				XM_OUTADDR(IoC, i, XM_SA, OutAddr);
 			}
-			else {
+#endif /* GENESIS */
+#ifdef YUKON
+			if (!pAC->GIni.GIGenesis) {
 				GM_OUTADDR(IoC, i, GM_SRC_ADDR_1L, OutAddr);
 			}
+#endif /* YUKON */
 #ifdef DEBUG
 			SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_INIT,
 				("SkAddrInit: Permanent Physical MAC Address: %02X %02X %02X %02X %02X %02X\n",
@@ -443,7 +473,7 @@
 					pAPort->CurrentMacAddress.a[3],
 					pAPort->CurrentMacAddress.a[4],
 					pAPort->CurrentMacAddress.a[5]))
-#endif	/* DEBUG */
+#endif /* DEBUG */
 		}
 		/* pAC->Addr.InitDone = SK_INIT_IO; */
 		break;
@@ -469,6 +499,7 @@
 	
 }	/* SkAddrInit */
 
+#ifndef SK_SLIM
 
 /******************************************************************************
  *
@@ -504,7 +535,7 @@
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
 	
-	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+	if (pAC->GIni.GIGenesis) {
 		ReturnCode = SkAddrXmacMcClear(pAC, IoC, PortNumber, Flags);
 	}
 	else {
@@ -515,6 +546,9 @@
 
 }	/* SkAddrMcClear */
 
+#endif /* !SK_SLIM */
+
+#ifndef SK_SLIM
 
 /******************************************************************************
  *
@@ -568,6 +602,9 @@
 	
 }	/* SkAddrXmacMcClear */
 
+#endif /* !SK_SLIM */
+
+#ifndef SK_SLIM
 
 /******************************************************************************
  *
@@ -758,7 +795,7 @@
 
 }	/* SkGmacMcHash */
 
-#endif	/* not SK_ADDR_CHEAT */
+#endif	/* !SK_ADDR_CHEAT */
 
 /******************************************************************************
  *
@@ -797,7 +834,7 @@
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
 	
-	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+	if (pAC->GIni.GIGenesis) {
 		ReturnCode = SkAddrXmacMcAdd(pAC, IoC, PortNumber, pMc, Flags);
 	}
 	else {
@@ -888,7 +925,7 @@
 	}
 	else {
 		if (!(pMc->a[0] & SK_MC_BIT)) {
-			/* Hashing only possible with multicast addresses. */
+			/* Hashing only possible with multicast addresses */
 			return (SK_MC_ILLEGAL_ADDRESS);
 		}
 #ifndef SK_ADDR_CHEAT
@@ -951,7 +988,7 @@
 #endif	/* !defined(SK_ADDR_CHEAT) */
 		
 	if (!(pMc->a[0] & SK_MC_BIT)) {
-		/* Hashing only possible with multicast addresses. */
+		/* Hashing only possible with multicast addresses */
 		return (SK_MC_ILLEGAL_ADDRESS);
 	}
 	
@@ -1021,6 +1058,7 @@
 	
 }	/* SkAddrGmacMcAdd */
 
+#endif /* !SK_SLIM */
 
 /******************************************************************************
  *
@@ -1052,23 +1090,29 @@
 SK_U32	PortNumber)	/* Port Number */
 {
 	int ReturnCode;
-	
+#if (!defined(SK_SLIM) || defined(DEBUG))
 	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
-	
-	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+#endif /* !SK_SLIM || DEBUG */
+
+#ifdef GENESIS
+	if (pAC->GIni.GIGenesis) {
 		ReturnCode = SkAddrXmacMcUpdate(pAC, IoC, PortNumber);
 	}
-	else {
+#endif /* GENESIS */
+#ifdef YUKON
+	if (!pAC->GIni.GIGenesis) {
 		ReturnCode = SkAddrGmacMcUpdate(pAC, IoC, PortNumber);
 	}
-	
+#endif /* YUKON */
 	return (ReturnCode);
 
 }	/* SkAddrMcUpdate */
 
 
+#ifdef GENESIS
+
 /******************************************************************************
  *
  *	SkAddrXmacMcUpdate - update the HW MC address table and set the MAC address
@@ -1108,7 +1152,7 @@
 #ifdef DEBUG
 	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
 		("Next0 on Port %d: %d\n", PortNumber, Next0[PortNumber]))
-#endif	/* DEBUG */
+#endif /* DEBUG */
 
 	/* Start with 0 to also program the logical MAC address. */
 	for (i = 0; i < pAPort->NextExactMatchRlmt; i++) {
@@ -1146,7 +1190,7 @@
 		XM_OUTHASH(IoC, PortNumber, XM_HSM, &OnesHash);
 		
 		/* Enable Hashing */
-		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+		SkMacHashing(pAC, IoC, (int) PortNumber, SK_TRUE);
 	}
 	else if (Inexact != 0) {
 		
@@ -1154,11 +1198,11 @@
 		XM_OUTHASH(IoC, PortNumber, XM_HSM, &pAPort->InexactFilter.Bytes[0]);
 		
 		/* Enable Hashing */
-		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+		SkMacHashing(pAC, IoC, (int) PortNumber, SK_TRUE);
 	}
 	else {
 		/* Disable Hashing */
-		SkMacHashing(pAC, IoC, PortNumber, SK_FALSE);
+		SkMacHashing(pAC, IoC, (int) PortNumber, SK_FALSE);
 	}
 
 	if (pAPort->PromMode != SK_PROM_MODE_NONE) {
@@ -1198,7 +1242,7 @@
 				pAPort->Exact[i].a[4],
 				pAPort->Exact[i].a[5]))
 	}
-#endif	/* DEBUG */		
+#endif /* DEBUG */
 
 	/* Determine return value. */
 	if (Inexact == 0 && pAPort->PromMode == 0) {
@@ -1210,6 +1254,9 @@
 	
 }	/* SkAddrXmacMcUpdate */
 
+#endif  /* GENESIS */
+
+#ifdef YUKON
 
 /******************************************************************************
  *
@@ -1237,8 +1284,10 @@
 SK_IOC	IoC,		/* I/O context */
 SK_U32	PortNumber)	/* Port Number */
 {
+#ifndef SK_SLIM
 	SK_U32		i;
 	SK_U8		Inexact;
+#endif	/* not SK_SLIM */
 	SK_U16		*OutAddr;
 	SK_ADDR_PORT	*pAPort;
 
@@ -1250,8 +1299,9 @@
 #ifdef DEBUG
 	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
 		("Next0 on Port %d: %d\n", PortNumber, Next0[PortNumber]))
-#endif	/* DEBUG */
+#endif /* DEBUG */
 	
+#ifndef SK_SLIM
 	for (Inexact = 0, i = 0; i < 8; i++) {
 		Inexact |= pAPort->InexactFilter.Bytes[i];
 	}
@@ -1266,16 +1316,27 @@
 		GM_OUTHASH(IoC, PortNumber, GM_MC_ADDR_H1, &OnesHash);
 		
 		/* Enable Hashing */
-		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+		SkMacHashing(pAC, IoC, (int) PortNumber, SK_TRUE);
 	}
 	else {	
 		/* Enable Hashing. */
-		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+		SkMacHashing(pAC, IoC, (int) PortNumber, SK_TRUE);
 	}
 	
 	if (pAPort->PromMode != SK_PROM_MODE_NONE) {
 		(void) SkAddrGmacPromiscuousChange(pAC, IoC, PortNumber, pAPort->PromMode);
 	}
+#else /* SK_SLIM */
+
+	/* Set all bits in 64-bit hash register. */
+	GM_OUTHASH(IoC, PortNumber, GM_MC_ADDR_H1, &OnesHash);
+
+	/* Enable Hashing */
+	SkMacHashing(pAC, IoC, (int) PortNumber, SK_TRUE);
+	
+	(void) SkAddrGmacPromiscuousChange(pAC, IoC, PortNumber, pAPort->PromMode);
+	
+#endif /* SK_SLIM */
 	
 	/* Set port's current physical MAC address. */
 	OutAddr = (SK_U16 *) &pAPort->CurrentMacAddress.a[0];
@@ -1303,8 +1364,9 @@
 			pAPort->CurrentMacAddress.a[3],
 			pAPort->CurrentMacAddress.a[4],
 			pAPort->CurrentMacAddress.a[5]))
-#endif	/* DEBUG */
+#endif /* DEBUG */
 	
+#ifndef SK_SLIM
 	/* Determine return value. */
 	if (Inexact == 0 && pAPort->PromMode == 0) {
 		return (SK_MC_FILTERING_EXACT);
@@ -1312,9 +1374,15 @@
 	else {
 		return (SK_MC_FILTERING_INEXACT);
 	}
+#else /* SK_SLIM */
+	return (SK_MC_FILTERING_INEXACT);
+#endif /* SK_SLIM */
 	
 }	/* SkAddrGmacMcUpdate */
 
+#endif /* YUKON */
+
+#ifndef SK_NO_MAO
 
 /******************************************************************************
  *
@@ -1334,23 +1402,29 @@
  *	SK_ADDR_TOO_EARLY if SK_INIT_IO was not executed before.
  */
 int	SkAddrOverride(
-SK_AC		*pAC,		/* adapter context */
-SK_IOC		IoC,		/* I/O context */
-SK_U32		PortNumber,	/* Port Number */
-SK_MAC_ADDR	*pNewAddr,	/* new MAC address */
-int			Flags)		/* logical/physical MAC address */
+SK_AC		*pAC,				/* adapter context */
+SK_IOC		IoC,				/* I/O context */
+SK_U32		PortNumber,			/* Port Number */
+SK_MAC_ADDR	SK_FAR *pNewAddr,	/* new MAC address */
+int			Flags)				/* logical/physical MAC address */
 {
+#ifndef SK_NO_RLMT
 	SK_EVPARA	Para;
+#endif /* !SK_NO_RLMT */
 	SK_U32		NetNumber;
 	SK_U32		i;
-	SK_U16		*OutAddr;
+	SK_U16		SK_FAR *OutAddr;
 
+#ifndef SK_NO_RLMT
 	NetNumber = pAC->Rlmt.Port[PortNumber].Net->NetNumber;
-
+#else
+	NetNumber = 0;
+#endif /* SK_NO_RLMT */
+#if (!defined(SK_SLIM) || defined(DEBUG))
 	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
-
+#endif /* !SK_SLIM || DEBUG */
 	if (pNewAddr != NULL && (pNewAddr->a[0] & SK_MC_BIT) != 0) {
 		return (SK_ADDR_MULTICAST_ADDRESS);
 	}
@@ -1366,11 +1440,11 @@
 				return (SK_ADDR_TOO_EARLY);
 			}
 		}
-
+#ifndef SK_NO_RLMT
 		/* Set PortNumber to number of net's active port. */
 		PortNumber = pAC->Rlmt.Net[NetNumber].
 			Port[pAC->Addr.Net[NetNumber].ActivePort]->PortNumber;
-
+#endif /* !SK_NO_RLMT */
 		pAC->Addr.Port[PortNumber].Exact[0] =
 			pAC->Addr.Net[NetNumber].CurrentMacAddress;
 
@@ -1385,11 +1459,11 @@
 				return (SK_ADDR_TOO_EARLY);
 			}
 		}
-
+#ifndef SK_NO_RLMT
 		/* Set PortNumber to number of net's active port. */
 		PortNumber = pAC->Rlmt.Net[NetNumber].
 			Port[pAC->Addr.Net[NetNumber].ActivePort]->PortNumber;
-
+#endif /* !SK_NO_RLMT */
 		for (i = 0; i < SK_MAC_ADDR_LEN; i++ ) {
 			pAC->Addr.Port[PortNumber].Exact[0].a[i] = 0;
 		}
@@ -1424,19 +1498,24 @@
 		pAC->Addr.Port[PortNumber].CurrentMacAddress = *pNewAddr;
 
 		/* Change port's physical MAC address. */
-		OutAddr = (SK_U16 *) pNewAddr;
-		
-		if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+		OutAddr = (SK_U16 SK_FAR *) pNewAddr;
+#ifdef GENESIS
+		if (pAC->GIni.GIGenesis) {
 			XM_OUTADDR(IoC, PortNumber, XM_SA, OutAddr);
 		}
-		else {
+#endif /* GENESIS */
+#ifdef YUKON
+		if (!pAC->GIni.GIGenesis) {
 			GM_OUTADDR(IoC, PortNumber, GM_SRC_ADDR_1L, OutAddr);
 		}
+#endif /* YUKON */
 
+#ifndef SK_NO_RLMT
 		/* Report address change to RLMT. */
 		Para.Para32[0] = PortNumber;
 		Para.Para32[0] = -1;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_PORT_ADDR, Para);
+#endif /* !SK_NO_RLMT */
 	}
 	else {	/* Logical MAC address. */
 		if (SK_ADDR_EQUAL(pNewAddr->a,
@@ -1454,11 +1533,33 @@
 				return (SK_ADDR_DUPLICATE_ADDRESS);
 			}
 		}
-
+		
+		/*
+		 * In case that the physical and the logical MAC addresses are equal
+		 * we must also change the physical MAC address here.
+		 * In this case we have an adapter which initially was programmed with
+		 * two identical MAC addresses.
+		 */
+		if (SK_ADDR_EQUAL(pAC->Addr.Port[PortNumber].CurrentMacAddress.a,
+				pAC->Addr.Port[PortNumber].Exact[0].a)) {
+			
+			pAC->Addr.Port[PortNumber].PreviousMacAddress =
+				pAC->Addr.Port[PortNumber].CurrentMacAddress;
+			pAC->Addr.Port[PortNumber].CurrentMacAddress = *pNewAddr;
+			
+#ifndef SK_NO_RLMT
+			/* Report address change to RLMT. */
+			Para.Para32[0] = PortNumber;
+			Para.Para32[0] = -1;
+			SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_PORT_ADDR, Para);
+#endif /* !SK_NO_RLMT */
+		}
+		
+#ifndef SK_NO_RLMT
 		/* Set PortNumber to number of net's active port. */
 		PortNumber = pAC->Rlmt.Net[NetNumber].
 			Port[pAC->Addr.Net[NetNumber].ActivePort]->PortNumber;
-
+#endif /* !SK_NO_RLMT */
 		pAC->Addr.Net[NetNumber].CurrentMacAddress = *pNewAddr;
 		pAC->Addr.Port[PortNumber].Exact[0] = *pNewAddr;
 #ifdef DEBUG
@@ -1479,9 +1580,9 @@
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[3],
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[4],
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[5]))
-#endif	/* DEBUG */
+#endif /* DEBUG */
 
-		/* Write address to first exact match entry of active port. */
+        /* Write address to first exact match entry of active port. */
 		(void) SkAddrMcUpdate(pAC, IoC, PortNumber);
 	}
 
@@ -1490,6 +1591,8 @@
 }	/* SkAddrOverride */
 
 
+#endif /* SK_NO_MAO */
+
 /******************************************************************************
  *
  *	SkAddrPromiscuousChange - set promiscuous mode for given port
@@ -1519,22 +1622,30 @@
 int		NewPromMode)	/* new promiscuous mode */
 {
 	int ReturnCode;
-	
+#if (!defined(SK_SLIM) || defined(DEBUG))
 	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
-	
-	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
-		ReturnCode = SkAddrXmacPromiscuousChange(pAC, IoC, PortNumber, NewPromMode);
-	}
-	else {
-		ReturnCode = SkAddrGmacPromiscuousChange(pAC, IoC, PortNumber, NewPromMode);
+#endif /* !SK_SLIM || DEBUG */
+
+#ifdef GENESIS
+	if (pAC->GIni.GIGenesis) {
+		ReturnCode =
+			SkAddrXmacPromiscuousChange(pAC, IoC, PortNumber, NewPromMode);
+	}
+#endif /* GENESIS */
+#ifdef YUKON
+	if (!pAC->GIni.GIGenesis) {
+		ReturnCode =
+			SkAddrGmacPromiscuousChange(pAC, IoC, PortNumber, NewPromMode);
 	}
+#endif /* YUKON */
 
 	return (ReturnCode);
 
 }	/* SkAddrPromiscuousChange */
 
+#ifdef GENESIS
 
 /******************************************************************************
  *
@@ -1613,7 +1724,7 @@
 		XM_OUTHASH(IoC, PortNumber, XM_HSM, &OnesHash);
 
 		/* Enable Hashing */
-		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+		SkMacHashing(pAC, IoC, (int) PortNumber, SK_TRUE);
 	}
 	else if ((CurPromMode & SK_PROM_MODE_ALL_MC) &&
 		!(NewPromMode & SK_PROM_MODE_ALL_MC)) {	/* Norm MC. */
@@ -1622,7 +1733,7 @@
 		}
 		if (Inexact == 0) {
 			/* Disable Hashing */
-			SkMacHashing(pAC, IoC, PortNumber, SK_FALSE);
+			SkMacHashing(pAC, IoC, (int) PortNumber, SK_FALSE);
 		}
 		else {
 			/* Set 64-bit hash register to InexactFilter. */
@@ -1630,25 +1741,28 @@
 				&pAC->Addr.Port[PortNumber].InexactFilter.Bytes[0]);
 
 			/* Enable Hashing */
-			SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+			SkMacHashing(pAC, IoC, (int) PortNumber, SK_TRUE);
 		}
 	}
 
 	if ((NewPromMode & SK_PROM_MODE_LLC) &&
 		!(CurPromMode & SK_PROM_MODE_LLC)) {	/* Prom. LLC */
 		/* Set the MAC in Promiscuous Mode */
-		SkMacPromiscMode(pAC, IoC, PortNumber, SK_TRUE);
+		SkMacPromiscMode(pAC, IoC, (int) PortNumber, SK_TRUE);
 	}
 	else if ((CurPromMode & SK_PROM_MODE_LLC) &&
 		!(NewPromMode & SK_PROM_MODE_LLC)) {	/* Norm. LLC. */
 		/* Clear Promiscuous Mode */
-		SkMacPromiscMode(pAC, IoC, PortNumber, SK_FALSE);
+		SkMacPromiscMode(pAC, IoC, (int) PortNumber, SK_FALSE);
 	}
 	
 	return (SK_ADDR_SUCCESS);
 	
 }	/* SkAddrXmacPromiscuousChange */
 
+#endif /* GENESIS */
+
+#ifdef YUKON
 
 /******************************************************************************
  *
@@ -1703,7 +1817,7 @@
 		GM_OUTHASH(IoC, PortNumber, GM_MC_ADDR_H1, &OnesHash);
 		
 		/* Enable Hashing */
-		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+		SkMacHashing(pAC, IoC, (int) PortNumber, SK_TRUE);
 	}
 	
 	if ((CurPromMode & SK_PROM_MODE_ALL_MC) &&
@@ -1714,26 +1828,29 @@
 			&pAC->Addr.Port[PortNumber].InexactFilter.Bytes[0]);
 
 		/* Enable Hashing. */
-		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+		SkMacHashing(pAC, IoC, (int) PortNumber, SK_TRUE);
 	}
 
 	if ((NewPromMode & SK_PROM_MODE_LLC) &&
 		!(CurPromMode & SK_PROM_MODE_LLC)) {	/* Prom. LLC */
 		
 		/* Set the MAC to Promiscuous Mode. */
-		SkMacPromiscMode(pAC, IoC, PortNumber, SK_TRUE);
+		SkMacPromiscMode(pAC, IoC, (int) PortNumber, SK_TRUE);
 	}
 	else if ((CurPromMode & SK_PROM_MODE_LLC) &&
 		!(NewPromMode & SK_PROM_MODE_LLC)) {	/* Norm. LLC */
 		
 		/* Clear Promiscuous Mode. */
-		SkMacPromiscMode(pAC, IoC, PortNumber, SK_FALSE);
+		SkMacPromiscMode(pAC, IoC, (int) PortNumber, SK_FALSE);
 	}
 
 	return (SK_ADDR_SUCCESS);
 	
 }	/* SkAddrGmacPromiscuousChange */
 
+#endif /* YUKON */
+
+#ifndef SK_SLIM
 
 /******************************************************************************
  *
@@ -1805,7 +1922,7 @@
 	pAC->Addr.Port[FromPortNumber].PromMode = pAC->Addr.Port[ToPortNumber].PromMode;
 	pAC->Addr.Port[ToPortNumber].PromMode = i;
 	
-	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+	if (pAC->GIni.GIGenesis) {
 		DWord = pAC->Addr.Port[FromPortNumber].FirstExactMatchRlmt;
 		pAC->Addr.Port[FromPortNumber].FirstExactMatchRlmt =
 			pAC->Addr.Port[ToPortNumber].FirstExactMatchRlmt;
@@ -1844,6 +1961,8 @@
 	return (SK_ADDR_SUCCESS);
 	
 }	/* SkAddrSwap */
+
+#endif /* !SK_SLIM */
 
 #ifdef __cplusplus
 }
diff -Nru a/drivers/net/sk98lin/skcsum.c b/drivers/net/sk98lin/skcsum.c
--- a/drivers/net/sk98lin/skcsum.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skcsum.c	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,15 @@
  *
  * Name:	skcsum.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.10 $
- * Date:	$Date: 2002/04/11 10:02:04 $
+ * Version:	$Revision: 1.11 $
+ * Date:	$Date: 2003/03/11 14:05:55 $
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +26,10 @@
  * History:
  *
  *	$Log: skcsum.c,v $
+ *	Revision 1.11  2003/03/11 14:05:55  rschmidt
+ *	Replaced memset() by macro SK_MEMSET()
+ *	Editorial changes
+ *	
  *	Revision 1.10  2002/04/11 10:02:04  rwahl
  *	Fix in SkCsGetSendInfo():
  *	- function did not return ProtocolFlags in every case.
@@ -73,9 +77,8 @@
 #ifdef SK_USE_CSUM	/* Check if CSUM is to be used. */
 
 #ifndef lint
-static const char SysKonnectFileId[] = "@(#)"
-	"$Id: skcsum.c,v 1.10 2002/04/11 10:02:04 rwahl Exp $"
-	" (C) SysKonnect.";
+static const char SysKonnectFileId[] =
+	"@(#) $Id: skcsum.c,v 1.11 2003/03/11 14:05:55 rschmidt Exp $ (C) SysKonnect.";
 #endif	/* !lint */
 
 /******************************************************************************
@@ -107,8 +110,8 @@
  *
  *	"h/skdrv1st.h"
  *	"h/skcsum.h"
- *	 "h/sktypes.h"
- *	 "h/skqueue.h"
+ *	"h/sktypes.h"
+ *	"h/skqueue.h"
  *	"h/skdrv2nd.h"
  *
  ******************************************************************************/
@@ -173,7 +176,7 @@
  * little/big endian conversion on little endian machines only.
  */
 #ifdef SK_LITTLE_ENDIAN
-#define SKCS_HTON16(Val16)	(((unsigned) (Val16) >> 8) | (((Val16) & 0xFF) << 8))
+#define SKCS_HTON16(Val16)	(((unsigned) (Val16) >> 8) | (((Val16) & 0xff) << 8))
 #endif	/* SK_LITTLE_ENDIAN */
 #ifdef SK_BIG_ENDIAN
 #define SKCS_HTON16(Val16)	(Val16)
@@ -204,7 +207,7 @@
  *	zero.)
  *
  * Note:
- *	There is a bug in the ASIC which may lead to wrong checksums.
+ *	There is a bug in the GENESIS ASIC which may lead to wrong checksums.
  *
  * Arguments:
  *	pAc - A pointer to the adapter context struct.
@@ -603,7 +606,7 @@
 	NextLevelProtocol = *(SK_U8 *)
 		SKCS_IDX(pIpHeader, SKCS_OFS_IP_NEXT_LEVEL_PROTOCOL);
 
-	if (IpHeaderChecksum != 0xFFFF) {
+	if (IpHeaderChecksum != 0xffff) {
 		pAc->Csum.ProtoStats[NetNumber][SKCS_PROTO_STATS_IP].RxErrCts++;
 		/* the NDIS tester wants to know the upper level protocol too */
 		if (NextLevelProtocol == SKCS_PROTO_ID_TCP) {
@@ -721,7 +724,7 @@
 
 	/* Check if the TCP/UDP checksum is ok. */
 
-	if ((unsigned) NextLevelProtocolChecksum == 0xFFFF) {
+	if ((unsigned) NextLevelProtocolChecksum == 0xffff) {
 
 		/* TCP/UDP checksum ok. */
 
@@ -903,12 +906,12 @@
 		NetNumber = (int)Param.Para32[0];
 		if (ProtoIndex < 0) {	/* Clear for all protocols. */
 			if (NetNumber >= 0) {
-				memset(&pAc->Csum.ProtoStats[NetNumber][0], 0,
+				SK_MEMSET(&pAc->Csum.ProtoStats[NetNumber][0], 0,
 					sizeof(pAc->Csum.ProtoStats[NetNumber]));
 			}
 		}
 		else {					/* Clear for individual protocol. */
-			memset(&pAc->Csum.ProtoStats[NetNumber][ProtoIndex], 0,
+			SK_MEMSET(&pAc->Csum.ProtoStats[NetNumber][ProtoIndex], 0,
 				sizeof(pAc->Csum.ProtoStats[NetNumber][ProtoIndex]));
 		}
 		break;
diff -Nru a/drivers/net/sk98lin/skdim.c b/drivers/net/sk98lin/skdim.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/net/sk98lin/skdim.c	Wed Sep  3 22:38:49 2003
@@ -0,0 +1,737 @@
+/******************************************************************************
+ *
+ * Name:	skdim.c
+ * Project:	GEnesis, PCI Gigabit Ethernet Adapter
+ * Version:	$Revision: 1.2 $
+ * Date:	$Date: 2003/08/21 12:35:05 $
+ * Purpose:	All functions to maintain interrupt moderation
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ * History:
+ *	
+ *	$Log: skdim.c,v $
+ *	Revision 1.2  2003/08/21 12:35:05  mlindner
+ *	Fix: Corrected CPU detection and compile errors on single CPU machines
+ *	
+ *	Revision 1.1  2003/07/18 13:39:55  rroesler
+ *	Fix: Re-enter after CVS crash
+ *	
+ *	Revision 1.4  2003/07/07 09:45:47  rroesler
+ *	Fix: Compiler warnings corrected
+ *	
+ *	Revision 1.3  2003/06/10 09:16:40  rroesler
+ *	Adapt GetCurrentSystemLoad() to NOT access the kernels
+ *	kstat-structure in kernel 2.5/2.6. This must be done
+ *	due to a not exported symbol. Instead of evaluating the
+ *	SystemLoad directly, the nbr of interrupts is used as
+ *	a rough basis for the load.
+ *	
+ *
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ * Description:
+ *
+ * This module is intended to manage the dynamic interrupt moderation on both   
+ * GEnesis and Yukon adapters.
+ *
+ * Include File Hierarchy:
+ *
+ *	"skdrv1st.h"
+ *	"skdrv2nd.h"
+ *
+ ******************************************************************************/
+
+#ifndef	lint
+static const char SysKonnectFileId[] =
+	"@(#) $Id: skdim.c,v 1.2 2003/08/21 12:35:05 mlindner Exp $ (C) SysKonnect.";
+#endif
+
+#define __SKADDR_C
+
+#ifdef __cplusplus
+#error C++ is not yet supported.
+extern "C" {
+#endif
+
+/*******************************************************************************
+**
+** Includes
+**
+*******************************************************************************/
+
+#ifndef __INC_SKDRV1ST_H
+#include "h/skdrv1st.h"
+#endif
+
+#ifndef __INC_SKDRV2ND_H
+#include "h/skdrv2nd.h"
+#endif
+
+#include	<linux/kernel_stat.h>
+
+/*******************************************************************************
+**
+** Defines
+**
+*******************************************************************************/
+
+/*******************************************************************************
+**
+** Typedefs
+**
+*******************************************************************************/
+
+/*******************************************************************************
+**
+** Local function prototypes 
+**
+*******************************************************************************/
+
+static unsigned int GetCurrentSystemLoad(SK_AC *pAC);
+static SK_U64       GetIsrCalls(SK_AC *pAC);
+static SK_BOOL      IsIntModEnabled(SK_AC *pAC);
+static void         SetCurrIntCtr(SK_AC *pAC);
+static void         EnableIntMod(SK_AC *pAC); 
+static void         DisableIntMod(SK_AC *pAC);
+static void         ResizeDimTimerDuration(SK_AC *pAC);
+static void         DisplaySelectedModerationType(SK_AC *pAC);
+static void         DisplaySelectedModerationMask(SK_AC *pAC);
+static void         DisplayDescrRatio(SK_AC *pAC);
+
+/*******************************************************************************
+**
+** Global variables
+**
+*******************************************************************************/
+
+/*******************************************************************************
+**
+** Local variables
+**
+*******************************************************************************/
+
+/*******************************************************************************
+**
+** Global functions 
+**
+*******************************************************************************/
+
+/*******************************************************************************
+** Function     : SkDimModerate
+** Description  : Called in every ISR to check if moderation is to be applied
+**                or not for the current number of interrupts
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : void (!)
+** Notes        : -
+*******************************************************************************/
+
+void 
+SkDimModerate(SK_AC *pAC) {
+    unsigned int CurrSysLoad    = 0;  /* expressed in percent */
+    unsigned int LoadIncrease   = 0;  /* expressed in percent */
+    SK_U64       ThresholdInts  = 0;
+    SK_U64       IsrCallsPerSec = 0;
+
+#define M_DIMINFO pAC->DynIrqModInfo
+
+    if (!IsIntModEnabled(pAC)) {
+        if (M_DIMINFO.IntModTypeSelect == C_INT_MOD_DYNAMIC) {
+            CurrSysLoad = GetCurrentSystemLoad(pAC);
+            if (CurrSysLoad > 75) {
+                    /* 
+                    ** More than 75% total system load! Enable the moderation 
+                    ** to shield the system against too many interrupts.
+                    */
+                    EnableIntMod(pAC);
+            } else if (CurrSysLoad > M_DIMINFO.PrevSysLoad) {
+                LoadIncrease = (CurrSysLoad - M_DIMINFO.PrevSysLoad);
+                if (LoadIncrease > ((M_DIMINFO.PrevSysLoad *
+                                         C_INT_MOD_ENABLE_PERCENTAGE) / 100)) {
+                    if (CurrSysLoad > 10) {
+                        /* 
+                        ** More than 50% increase with respect to the 
+                        ** previous load of the system. Most likely this 
+                        ** is due to our ISR-proc...
+                        */
+                        EnableIntMod(pAC);
+                    }
+                }
+            } else {
+                /*
+                ** Neither too much system load at all nor too much increase
+                ** with respect to the previous system load. Hence, we can leave
+                ** the ISR-handling like it is without enabling moderation.
+                */
+            }
+            M_DIMINFO.PrevSysLoad = CurrSysLoad;
+        }   
+    } else {
+        if (M_DIMINFO.IntModTypeSelect == C_INT_MOD_DYNAMIC) {
+            ThresholdInts  = ((M_DIMINFO.MaxModIntsPerSec *
+                                   C_INT_MOD_DISABLE_PERCENTAGE) / 100);
+            IsrCallsPerSec = GetIsrCalls(pAC);
+            if (IsrCallsPerSec <= ThresholdInts) {
+                /* 
+                ** The number of interrupts within the last second is 
+                ** lower than the disable_percentage of the desried 
+                ** maxrate. Therefore we can disable the moderation.
+                */
+                DisableIntMod(pAC);
+                M_DIMINFO.MaxModIntsPerSec = 
+                   (M_DIMINFO.MaxModIntsPerSecUpperLimit +
+                    M_DIMINFO.MaxModIntsPerSecLowerLimit) / 2;
+            } else {
+                /*
+                ** The number of interrupts per sec is the same as expected.
+                ** Evalulate the descriptor-ratio. If it has changed, a resize 
+                ** in the moderation timer might be usefull
+                */
+                if (M_DIMINFO.AutoSizing) {
+                    ResizeDimTimerDuration(pAC);
+                }
+            }
+        }
+    }
+
+    /*
+    ** Some information to the log...
+    */
+    if (M_DIMINFO.DisplayStats) {
+        DisplaySelectedModerationType(pAC);
+        DisplaySelectedModerationMask(pAC);
+        DisplayDescrRatio(pAC);
+    }
+
+    M_DIMINFO.NbrProcessedDescr = 0; 
+    SetCurrIntCtr(pAC);
+}
+
+/*******************************************************************************
+** Function     : SkDimStartModerationTimer
+** Description  : Starts the audit-timer for the dynamic interrupt moderation
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : void (!)
+** Notes        : -
+*******************************************************************************/
+
+void 
+SkDimStartModerationTimer(SK_AC *pAC) {
+    SK_EVPARA    EventParam;   /* Event struct for timer event */
+ 
+    SK_MEMSET((char *) &EventParam, 0, sizeof(EventParam));
+    EventParam.Para32[0] = SK_DRV_MODERATION_TIMER;
+    SkTimerStart(pAC, pAC->IoBase, &pAC->DynIrqModInfo.ModTimer,
+                 SK_DRV_MODERATION_TIMER_LENGTH,
+                 SKGE_DRV, SK_DRV_TIMER, EventParam);
+}
+
+/*******************************************************************************
+** Function     : SkDimEnableModerationIfNeeded
+** Description  : Either enables or disables moderation
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : void (!)
+** Notes        : This function is called when a particular adapter is opened
+**                There is no Disable function, because when all interrupts 
+**                might be disable, the moderation timer has no meaning at all
+******************************************************************************/
+
+void
+SkDimEnableModerationIfNeeded(SK_AC *pAC) {
+
+    if (M_DIMINFO.IntModTypeSelect == C_INT_MOD_STATIC) {
+        EnableIntMod(pAC);   /* notification print in this function */
+    } else if (M_DIMINFO.IntModTypeSelect == C_INT_MOD_DYNAMIC) {
+        SkDimStartModerationTimer(pAC);
+        if (M_DIMINFO.DisplayStats) {
+            printk("Dynamic moderation has been enabled\n");
+        }
+    } else {
+        if (M_DIMINFO.DisplayStats) {
+            printk("No moderation has been enabled\n");
+        }
+    }
+}
+
+/*******************************************************************************
+** Function     : SkDimDisplayModerationSettings
+** Description  : Displays the current settings regaring interrupt moderation
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : void (!)
+** Notes        : -
+*******************************************************************************/
+
+void 
+SkDimDisplayModerationSettings(SK_AC *pAC) {
+    DisplaySelectedModerationType(pAC);
+    DisplaySelectedModerationMask(pAC);
+}
+
+/*******************************************************************************
+**
+** Local functions 
+**
+*******************************************************************************/
+
+/*******************************************************************************
+** Function     : GetCurrentSystemLoad
+** Description  : Retrieves the current system load of the system. This load
+**                is evaluated for all processors within the system.
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : unsigned int: load expressed in percentage
+** Notes        : The possible range being returned is from 0 up to 100.
+**                Whereas 0 means 'no load at all' and 100 'system fully loaded'
+**                It is impossible to determine what actually causes the system
+**                to be in 100%, but maybe that is due to too much interrupts.
+*******************************************************************************/
+
+static unsigned int
+GetCurrentSystemLoad(SK_AC *pAC) {
+	unsigned long jif         = jiffies;
+	unsigned int  UserTime    = 0;
+	unsigned int  SystemTime  = 0;
+	unsigned int  NiceTime    = 0;
+	unsigned int  IdleTime    = 0;
+	unsigned int  TotalTime   = 0;
+	unsigned int  UsedTime    = 0;
+	unsigned int  SystemLoad  = 0;
+#ifdef CONFIG_SMP
+	unsigned int  SKNumCpus   = smp_num_cpus;
+#else
+	unsigned int  SKNumCpus   = 1;
+#endif
+
+	unsigned int  NbrCpu      = 0;
+
+    for (NbrCpu = 0; NbrCpu < SKNumCpus; NbrCpu++) {
+        UserTime   = UserTime   + kstat.per_cpu_user[NbrCpu];
+        NiceTime   = NiceTime   + kstat.per_cpu_nice[NbrCpu];
+        SystemTime = SystemTime + kstat.per_cpu_system[NbrCpu];
+    }
+
+	UsedTime  = UserTime + NiceTime + SystemTime;
+
+	IdleTime  = jif * SKNumCpus - UsedTime;
+	TotalTime = UsedTime + IdleTime;
+
+	SystemLoad = ( 100 * (UsedTime  - M_DIMINFO.PrevUsedTime) ) /
+						(TotalTime - M_DIMINFO.PrevTotalTime);
+
+	if (M_DIMINFO.DisplayStats) {
+		printk("Current system load is: %u\n", SystemLoad);
+	}
+
+	M_DIMINFO.PrevTotalTime = TotalTime;
+	M_DIMINFO.PrevUsedTime  = UsedTime;
+
+	return (SystemLoad);
+}
+
+/*******************************************************************************
+** Function     : GetIsrCalls
+** Description  : Depending on the selected moderation mask, this function will
+**                return the number of interrupts handled in the previous time-
+**                frame. This evaluated number is based on the current number 
+**                of interrupts stored in PNMI-context and the previous stored 
+**                interrupts.
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : int:   the number of interrupts being executed in the last
+**                       timeframe
+** Notes        : It makes only sense to call this function, when dynamic 
+**                interrupt moderation is applied
+*******************************************************************************/
+
+static SK_U64
+GetIsrCalls(SK_AC *pAC) {
+    SK_U64   RxPort0IntDiff = 0;
+    SK_U64   RxPort1IntDiff = 0;
+    SK_U64   TxPort0IntDiff = 0;
+    SK_U64   TxPort1IntDiff = 0;
+
+    if (pAC->DynIrqModInfo.MaskIrqModeration == IRQ_MASK_TX_ONLY) {
+        if (pAC->GIni.GIMacsFound == 2) {
+            TxPort1IntDiff = pAC->Pnmi.Port[1].TxIntrCts - 
+                             pAC->DynIrqModInfo.PrevPort1TxIntrCts;
+        }
+        TxPort0IntDiff = pAC->Pnmi.Port[0].TxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort0TxIntrCts;
+    } else if (pAC->DynIrqModInfo.MaskIrqModeration == IRQ_MASK_RX_ONLY) {
+        if (pAC->GIni.GIMacsFound == 2) {
+            RxPort1IntDiff = pAC->Pnmi.Port[1].RxIntrCts - 
+                             pAC->DynIrqModInfo.PrevPort1RxIntrCts;
+        }
+        RxPort0IntDiff = pAC->Pnmi.Port[0].RxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort0RxIntrCts;
+    } else {
+        if (pAC->GIni.GIMacsFound == 2) {
+            RxPort1IntDiff = pAC->Pnmi.Port[1].RxIntrCts - 
+                             pAC->DynIrqModInfo.PrevPort1RxIntrCts;
+            TxPort1IntDiff = pAC->Pnmi.Port[1].TxIntrCts - 
+                             pAC->DynIrqModInfo.PrevPort1TxIntrCts;
+        } 
+        RxPort0IntDiff = pAC->Pnmi.Port[0].RxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort0RxIntrCts;
+        TxPort0IntDiff = pAC->Pnmi.Port[0].TxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort0TxIntrCts;
+    }
+
+    return (RxPort0IntDiff + RxPort1IntDiff + TxPort0IntDiff + TxPort1IntDiff);
+}
+
+/*******************************************************************************
+** Function     : GetRxCalls
+** Description  : This function will return the number of times a receive inter-
+**                rupt was processed. This is needed to evaluate any resizing 
+**                factor.
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : SK_U64: the number of RX-ints being processed
+** Notes        : It makes only sense to call this function, when dynamic 
+**                interrupt moderation is applied
+*******************************************************************************/
+
+static SK_U64
+GetRxCalls(SK_AC *pAC) {
+    SK_U64   RxPort0IntDiff = 0;
+    SK_U64   RxPort1IntDiff = 0;
+
+    if (pAC->GIni.GIMacsFound == 2) {
+        RxPort1IntDiff = pAC->Pnmi.Port[1].RxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort1RxIntrCts;
+    }
+    RxPort0IntDiff = pAC->Pnmi.Port[0].RxIntrCts - 
+                     pAC->DynIrqModInfo.PrevPort0RxIntrCts;
+
+    return (RxPort0IntDiff + RxPort1IntDiff);
+}
+
+/*******************************************************************************
+** Function     : SetCurrIntCtr
+** Description  : Will store the current number orf occured interrupts in the 
+**                adapter context. This is needed to evaluated the number of 
+**                interrupts within a current timeframe.
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : void (!)
+** Notes        : -
+*******************************************************************************/
+
+static void
+SetCurrIntCtr(SK_AC *pAC) {
+    if (pAC->GIni.GIMacsFound == 2) {
+        pAC->DynIrqModInfo.PrevPort1RxIntrCts = pAC->Pnmi.Port[1].RxIntrCts;
+        pAC->DynIrqModInfo.PrevPort1TxIntrCts = pAC->Pnmi.Port[1].TxIntrCts;
+    } 
+    pAC->DynIrqModInfo.PrevPort0RxIntrCts = pAC->Pnmi.Port[0].RxIntrCts;
+    pAC->DynIrqModInfo.PrevPort0TxIntrCts = pAC->Pnmi.Port[0].TxIntrCts;
+}
+
+/*******************************************************************************
+** Function     : IsIntModEnabled()
+** Description  : Retrieves the current value of the interrupts moderation
+**                command register. Its content determines whether any 
+**                moderation is running or not.
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : SK_TRUE  : if mod timer running
+**                SK_FALSE : if no moderation is being performed
+** Notes        : -
+*******************************************************************************/
+
+static SK_BOOL
+IsIntModEnabled(SK_AC *pAC) {
+    unsigned long CtrCmd;
+
+    SK_IN32(pAC->IoBase, B2_IRQM_CTRL, &CtrCmd);
+    if ((CtrCmd & TIM_START) == TIM_START) {
+       return SK_TRUE;
+    } else {
+       return SK_FALSE;
+    }
+}
+
+/*******************************************************************************
+** Function     : EnableIntMod()
+** Description  : Enables the interrupt moderation using the values stored in
+**                in the pAC->DynIntMod data structure
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : -
+** Notes        : -
+*******************************************************************************/
+
+static void
+EnableIntMod(SK_AC *pAC) {
+    unsigned long ModBase;
+
+    if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+       ModBase = C_CLK_FREQ_GENESIS / pAC->DynIrqModInfo.MaxModIntsPerSec;
+    } else {
+       ModBase = C_CLK_FREQ_YUKON / pAC->DynIrqModInfo.MaxModIntsPerSec;
+    }
+
+    SK_OUT32(pAC->IoBase, B2_IRQM_INI,  ModBase);
+    SK_OUT32(pAC->IoBase, B2_IRQM_MSK,  pAC->DynIrqModInfo.MaskIrqModeration);
+    SK_OUT32(pAC->IoBase, B2_IRQM_CTRL, TIM_START);
+    if (M_DIMINFO.DisplayStats) {
+        printk("Enabled interrupt moderation (%i ints/sec)\n",
+               M_DIMINFO.MaxModIntsPerSec);
+    }
+}
+
+/*******************************************************************************
+** Function     : DisableIntMod()
+** Description  : Disbles the interrupt moderation independent of what inter-
+**                rupts are running or not
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : -
+** Notes        : -
+*******************************************************************************/
+
+static void 
+DisableIntMod(SK_AC *pAC) {
+
+    SK_OUT32(pAC->IoBase, B2_IRQM_CTRL, TIM_STOP);
+    if (M_DIMINFO.DisplayStats) {
+        printk("Disabled interrupt moderation\n");
+    }
+} 
+
+/*******************************************************************************
+** Function     : ResizeDimTimerDuration();
+** Description  : Checks the current used descriptor ratio and resizes the 
+**                duration timer (longer/smaller) if possible. 
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : -
+** Notes        : There are both maximum and minimum timer duration value. 
+**                This function assumes that interrupt moderation is already
+**                enabled!
+*******************************************************************************/
+
+static void 
+ResizeDimTimerDuration(SK_AC *pAC) {
+    SK_BOOL IncreaseTimerDuration;
+    int     TotalMaxNbrDescr;
+    int     UsedDescrRatio;
+    int     RatioDiffAbs;
+    int     RatioDiffRel;
+    int     NewMaxModIntsPerSec;
+    int     ModAdjValue;
+    long    ModBase;
+
+    /*
+    ** Check first if we are allowed to perform any modification
+    */
+    if (IsIntModEnabled(pAC)) { 
+        if (M_DIMINFO.IntModTypeSelect != C_INT_MOD_DYNAMIC) {
+            return; 
+        } else {
+            if (M_DIMINFO.ModJustEnabled) {
+                M_DIMINFO.ModJustEnabled = SK_FALSE;
+                return;
+            }
+        }
+    }
+
+    /*
+    ** If we got until here, we have to evaluate the amount of the
+    ** descriptor ratio change...
+    */
+    TotalMaxNbrDescr = pAC->RxDescrPerRing * GetRxCalls(pAC);
+    UsedDescrRatio   = (M_DIMINFO.NbrProcessedDescr * 100) / TotalMaxNbrDescr;
+
+    if (UsedDescrRatio > M_DIMINFO.PrevUsedDescrRatio) {
+        RatioDiffAbs = (UsedDescrRatio - M_DIMINFO.PrevUsedDescrRatio);
+        RatioDiffRel = (RatioDiffAbs * 100) / UsedDescrRatio;
+        M_DIMINFO.PrevUsedDescrRatio = UsedDescrRatio;
+        IncreaseTimerDuration = SK_FALSE;  /* in other words: DECREASE */
+    } else if (UsedDescrRatio < M_DIMINFO.PrevUsedDescrRatio) {
+        RatioDiffAbs = (M_DIMINFO.PrevUsedDescrRatio - UsedDescrRatio);
+        RatioDiffRel = (RatioDiffAbs * 100) / M_DIMINFO.PrevUsedDescrRatio;
+        M_DIMINFO.PrevUsedDescrRatio = UsedDescrRatio;
+        IncreaseTimerDuration = SK_TRUE;   /* in other words: INCREASE */
+    } else {
+        RatioDiffAbs = (M_DIMINFO.PrevUsedDescrRatio - UsedDescrRatio);
+        RatioDiffRel = (RatioDiffAbs * 100) / M_DIMINFO.PrevUsedDescrRatio;
+        M_DIMINFO.PrevUsedDescrRatio = UsedDescrRatio;
+        IncreaseTimerDuration = SK_TRUE;   /* in other words: INCREASE */
+    }
+
+    /*
+    ** Now we can determine the change in percent
+    */
+    if ((RatioDiffRel >= 0) && (RatioDiffRel <= 5) ) {
+       ModAdjValue = 1;  /*  1% change - maybe some other value in future */
+    } else if ((RatioDiffRel > 5) && (RatioDiffRel <= 10) ) {
+       ModAdjValue = 1;  /*  1% change - maybe some other value in future */
+    } else if ((RatioDiffRel > 10) && (RatioDiffRel <= 15) ) {
+       ModAdjValue = 1;  /*  1% change - maybe some other value in future */
+    } else {
+       ModAdjValue = 1;  /*  1% change - maybe some other value in future */
+    }
+
+    if (IncreaseTimerDuration) {
+       NewMaxModIntsPerSec =  M_DIMINFO.MaxModIntsPerSec +
+                             (M_DIMINFO.MaxModIntsPerSec * ModAdjValue) / 100;
+    } else {
+       NewMaxModIntsPerSec =  M_DIMINFO.MaxModIntsPerSec -
+                             (M_DIMINFO.MaxModIntsPerSec * ModAdjValue) / 100;
+    }
+
+    /* 
+    ** Check if we exceed boundaries...
+    */
+    if ( (NewMaxModIntsPerSec > M_DIMINFO.MaxModIntsPerSecUpperLimit) ||
+         (NewMaxModIntsPerSec < M_DIMINFO.MaxModIntsPerSecLowerLimit)) {
+        if (M_DIMINFO.DisplayStats) {
+            printk("Cannot change ModTim from %i to %i ints/sec\n",
+                   M_DIMINFO.MaxModIntsPerSec, NewMaxModIntsPerSec);
+        }
+        return;
+    } else {
+        if (M_DIMINFO.DisplayStats) {
+            printk("Resized ModTim from %i to %i ints/sec\n",
+                   M_DIMINFO.MaxModIntsPerSec, NewMaxModIntsPerSec);
+        }
+    }
+
+    M_DIMINFO.MaxModIntsPerSec = NewMaxModIntsPerSec;
+
+    if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+        ModBase = C_CLK_FREQ_GENESIS / pAC->DynIrqModInfo.MaxModIntsPerSec;
+    } else {
+        ModBase = C_CLK_FREQ_YUKON / pAC->DynIrqModInfo.MaxModIntsPerSec;
+    }
+
+    /* 
+    ** We do not need to touch any other registers
+    */
+    SK_OUT32(pAC->IoBase, B2_IRQM_INI, ModBase);
+} 
+
+/*******************************************************************************
+** Function     : DisplaySelectedModerationType()
+** Description  : Displays what type of moderation we have
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : void!
+** Notes        : -
+*******************************************************************************/
+
+static void
+DisplaySelectedModerationType(SK_AC *pAC) {
+
+    if (pAC->DynIrqModInfo.DisplayStats) {
+        if (pAC->DynIrqModInfo.IntModTypeSelect == C_INT_MOD_STATIC) {
+             printk("Static int moderation runs with %i INTS/sec\n",
+                    pAC->DynIrqModInfo.MaxModIntsPerSec);
+        } else if (pAC->DynIrqModInfo.IntModTypeSelect == C_INT_MOD_DYNAMIC) {
+             if (IsIntModEnabled(pAC)) {
+                printk("Dynamic int moderation runs with %i INTS/sec\n",
+                       pAC->DynIrqModInfo.MaxModIntsPerSec);
+             } else {
+                printk("Dynamic int moderation currently not applied\n");
+             }
+        } else {
+             printk("No interrupt moderation selected!\n");
+        }
+    }
+}
+
+/*******************************************************************************
+** Function     : DisplaySelectedModerationMask()
+** Description  : Displays what interrupts are moderated
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : void!
+** Notes        : -
+*******************************************************************************/
+
+static void
+DisplaySelectedModerationMask(SK_AC *pAC) {
+
+    if (pAC->DynIrqModInfo.DisplayStats) {
+        if (pAC->DynIrqModInfo.IntModTypeSelect != C_INT_MOD_NONE) {
+            switch (pAC->DynIrqModInfo.MaskIrqModeration) {
+                case IRQ_MASK_TX_ONLY: 
+                   printk("Only Tx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_RX_ONLY: 
+                   printk("Only Rx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_SP_ONLY: 
+                   printk("Only special-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_TX_RX: 
+                   printk("Tx- and Rx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_SP_RX: 
+                   printk("Special- and Rx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_SP_TX: 
+                   printk("Special- and Tx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_RX_TX_SP:
+                   printk("All Rx-, Tx and special-interrupts are moderated\n");
+                   break;
+                default:
+                   printk("Don't know what is moderated\n");
+                   break;
+            }
+        } else {
+            printk("No specific interrupts masked for moderation\n");
+        }
+    } 
+}
+
+/*******************************************************************************
+** Function     : DisplayDescrRatio
+** Description  : Like the name states...
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : void!
+** Notes        : -
+*******************************************************************************/
+
+static void
+DisplayDescrRatio(SK_AC *pAC) {
+    int TotalMaxNbrDescr = 0;
+
+    if (pAC->DynIrqModInfo.DisplayStats) {
+        TotalMaxNbrDescr = pAC->RxDescrPerRing * GetRxCalls(pAC);
+        printk("Ratio descriptors: %i/%i\n",
+               M_DIMINFO.NbrProcessedDescr, TotalMaxNbrDescr);
+    }
+}
+
+/*******************************************************************************
+**
+** End of file
+**
+*******************************************************************************/
diff -Nru a/drivers/net/sk98lin/skge.c b/drivers/net/sk98lin/skge.c
--- a/drivers/net/sk98lin/skge.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skge.c	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,15 @@
  *
  * Name:    skge.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.43 $
- * Date:       	$Date: 2002/11/29 08:42:41 $
+ * Version:	$Revision: 1.11 $
+ * Date:       	$Date: 2003/08/26 16:05:19 $
  * Purpose:	The main driver source module
  *
  ******************************************************************************/
- 
+
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	Driver for SysKonnect Gigabit Ethernet Server Adapters:
  *
@@ -31,7 +31,7 @@
  *	SK-9843 (single link 1000Base-SX V2)
  *	SK-9821 (single link 1000Base-T V2)
  *
- *	Created 10-Feb-1999, based on Linux' acenic.c, 3c59x.c and 
+ *	Created 10-Feb-1999, based on Linux' acenic.c, 3c59x.c and
  *	SysKonnects GEnesis Solaris driver
  *	Author: Christoph Goos (cgoos@syskonnect.de)
  *	        Mirko Lindner (mlindner@syskonnect.de)
@@ -56,6 +56,114 @@
  * History:
  *
  *	$Log: skge.c,v $
+ *	Revision 1.11  2003/08/26 16:05:19  mlindner
+ *	Fix: Compiler warnings (void *)
+ *	
+ *	Revision 1.10  2003/08/25 09:24:08  mlindner
+ *	Add: Dynamic Interrupt Moderation (DIM) port up message
+ *	
+ *	Revision 1.9  2003/08/21 14:09:43  mlindner
+ *	Fix: Disable Half Duplex with Gigabit-Speed (Yukon). Enable Full Duplex.
+ *	
+ *	Revision 1.8  2003/08/19 15:09:18  mlindner
+ *	Fix: Ignore ConType parameter if empty value
+ *	
+ *	Revision 1.7  2003/08/13 12:00:35  mlindner
+ *	Fix: Removed useless defines
+ *	
+ *	Revision 1.6  2003/08/12 16:49:41  mlindner
+ *	Fix: UDP and TCP HW-CSum calculation (Kernel 2.5/2.6)
+ *	Fix: UDP and TCP Proto checks
+ *	Fix: Build without ProcFS
+ *	Fix: Kernel 2.6 editorial changes
+ *	
+ *	Revision 1.5  2003/08/07 12:25:07  mlindner
+ *	Fix: ConType parameter check and error detection
+ *	Fix: Insert various fixes applied to the kernel tree
+ *	
+ *	Revision 1.4  2003/08/07 10:50:21  mlindner
+ *	Add: Speed and HW-Csum support for Yukon Lite chipset
+ *	
+ *	Revision 1.3  2003/08/06 11:24:08  mlindner
+ *	Add: Kernel updates
+ *	
+ *	Revision 1.2  2003/07/21 08:28:47  rroesler
+ *	Fix: Handle padded bytes using skb_put()
+ *	
+ *	Revision 1.63  2003/07/15 09:26:23  rroesler
+ *	Fix: Removed memory leak when sending short padded frames
+ *	
+ *	Revision 1.62  2003/07/09 11:11:16  rroesler
+ *	Fix: Call of ReceiveIrq() performed with parameter SK_FALSE in
+ *	     order not to hang the system with multiple spinlocks
+ *	
+ *	Revision 1.61  2003/07/08 07:32:41  rroesler
+ *	Fix: Correct Kernel-version
+ *	
+ *	Revision 1.60  2003/07/07 15:42:30  rroesler
+ *	Fix: Removed function pci_present() for 2.5/2.6 kernels (deprecated)
+ *	Fix: Corrected warning in GetConfiguration()
+ *	
+ *	Revision 1.59  2003/07/07 09:44:32  rroesler
+ *	Add: HW checksumming on kernel 2.5/2.6
+ *	Add: padding of short frames (<60 bytes) with 0x00 instead of 0xaa
+ *	Add: ConType parameter combining multiple other parameters into one
+ *	Fix: Corrected bugreport #10721 (warning when changing MTU size)
+ *	Fix: Removed obsolete function SetQueueSize()
+ *	Fix: Function ChangeMtuSize() returns new MTU size in kernel 2.5/2.6
+ *	
+ *	Revision 1.58  2003/06/17 07:14:29  mlindner
+ *	Add: Disable checksum functionality
+ *	Fix: Unload module (Kernel 2.5)
+ *	
+ *	Revision 1.57  2003/06/05 14:55:27  mlindner
+ *	Fix: ProcFS creation (Kernel 2.2.x)
+ *	Fix: ProcFS OWNER (Kernel 2.2.x)
+ *	
+ *	Revision 1.56  2003/06/03 14:34:29  mlindner
+ *	Add: Additions for SK_SLIM
+ *	Fix: SkGeIoctl SK_IOCTL_GEN
+ *	
+ *	Revision 1.55  2003/05/26 13:00:52  mlindner
+ *	Add: Support for Kernel 2.5/2.6
+ *	Add: Support for new IO-control MIB data structure
+ *	Add: New SkOsGetTime function
+ *	Fix: Race condition with broken LM80 chip
+ *	Fix: Race condition with padded frames
+ *	
+ *	Revision 1.54  2003/04/28 13:07:27  mlindner
+ *	Fix: Delay race condition with some server machines
+ *	
+ *	Revision 1.53  2003/04/28 12:49:49  mlindner
+ *	Fix: Code optimization
+ *	
+ *	Revision 1.52  2003/04/28 12:24:32  mlindner
+ *	Fix: Disabled HW Error IRQ on 32-bit Yukon if sensor IRQ occurs
+ *	
+ *	Revision 1.51  2003/04/16 08:31:14  mlindner
+ *	Fix: Kernel 2.2 compilation
+ *	
+ *	Revision 1.49  2003/04/10 09:08:51  mlindner
+ *	Add: Blink mode verification
+ *	Fix: Checksum calculation
+ *	
+ *	Revision 1.48  2003/03/21 14:48:38  rroesler
+ *	Added code for interrupt moderation
+ *	
+ *	Revision 1.47  2003/03/12 13:56:15  mlindner
+ *	Fix: Mac update during SK_DRV_NET_UP
+ *	
+ *	Revision 1.46  2003/02/25 14:16:36  mlindner
+ *	Fix: Copyright statement
+ *	
+ *	Revision 1.45  2003/02/25 13:25:55  mlindner
+ *	Add: Performance improvements
+ *	Add: Support for various vendors
+ *	Fix: Init function
+ *	
+ *	Revision 1.44  2003/01/09 09:25:26  mlindner
+ *	Fix: Remove useless init_module/cleanup_module forward declarations
+ *	
  *	Revision 1.43  2002/11/29 08:42:41  mlindner
  *	Fix: Boot message
  *	
@@ -253,7 +361,7 @@
  *	Printing "ethX:" before adapter type at adapter init.
  *	
  *
- *	10-Feb-1999 cg	Created, based on Linux' acenic.c, 3c59x.c and 
+ *	10-Feb-1999 cg	Created, based on Linux' acenic.c, 3c59x.c and
  *			SysKonnects GEnesis Solaris driver
  *
  ******************************************************************************/
@@ -262,11 +370,11 @@
  *
  * Possible compiler options (#define xxx / -Dxxx):
  *
- *	debugging can be enable by changing SK_DEBUG_CHKMOD and 
+ *	debugging can be enable by changing SK_DEBUG_CHKMOD and
  *	SK_DEBUG_CHKCAT in makefile (described there).
  *
  ******************************************************************************/
- 
+
 /******************************************************************************
  *
  * Description:
@@ -330,39 +438,51 @@
  ******************************************************************************/
 
 #include	"h/skversion.h"
+
 #include	<linux/module.h>
 #include	<linux/init.h>
+
+#ifdef CONFIG_PROC_FS
 #include 	<linux/proc_fs.h>
+#endif
+
 #include	"h/skdrv1st.h"
 #include	"h/skdrv2nd.h"
 
+/*******************************************************************************
+ *
+ * Defines
+ *
+ ******************************************************************************/
 
-/* defines ******************************************************************/
 /* for debuging on x86 only */
 /* #define BREAKPOINT() asm(" int $3"); */
 
+/* use the transmit hw checksum driver functionality */
+#define USE_SK_TX_CHECKSUM
+
+/* use the receive hw checksum driver functionality */
+#define USE_SK_RX_CHECKSUM
+
 /* use the scatter-gather functionality with sendfile() */
 #define SK_ZEROCOPY
 
 /* use of a transmit complete interrupt */
 #define USE_TX_COMPLETE
 
-/* use interrupt moderation (for tx complete only) */
-#define USE_INT_MOD
-#define INTS_PER_SEC	1800
-
 /*
  * threshold for copying small receive frames
  * set to 0 to avoid copying, set to 9001 to copy all frames
  */
-#define SK_COPY_THRESHOLD	200
+#define SK_COPY_THRESHOLD	50
 
 /* number of adapters that can be configured via command line params */
 #define SK_MAX_CARD_PARAM	16
 
 
+
 /*
- * use those defines for a compile-in version of the driver instead 
+ * use those defines for a compile-in version of the driver instead
  * of command line parameters
  */
 // #define LINK_SPEED_A	{"Auto", }
@@ -376,23 +496,40 @@
 // #define ROLE_A	{"Auto", }
 // #define ROLE_B	{"Auto", }
 // #define PREF_PORT	{"A", }
+// #define CON_TYPE 	{"Auto", }
 // #define RLMT_MODE	{"CheckLinkState", }
 
 #define DEV_KFREE_SKB(skb) dev_kfree_skb(skb)
 #define DEV_KFREE_SKB_IRQ(skb) dev_kfree_skb_irq(skb)
 #define DEV_KFREE_SKB_ANY(skb) dev_kfree_skb_any(skb)
 
-/* function prototypes ******************************************************/
+
+/* Set blink mode*/
+#define OEM_CONFIG_VALUE (	SK_ACT_LED_BLINK | \
+				SK_DUP_LED_NORMAL | \
+				SK_LED_LINK100_ON)
+
+
+/* Isr return value */
+#define SkIsrRetVar	void
+#define SkIsrRetNone	NULL
+#define SkIsrRetHandled	NULL
+
+
+/*******************************************************************************
+ *
+ * Local Function Prototypes
+ *
+ ******************************************************************************/
+
 static void	FreeResources(struct SK_NET_DEVICE *dev);
 static int	SkGeBoardInit(struct SK_NET_DEVICE *dev, SK_AC *pAC);
 static SK_BOOL	BoardAllocMem(SK_AC *pAC);
 static void	BoardFreeMem(SK_AC *pAC);
 static void	BoardInitMem(SK_AC *pAC);
-static void	SetupRing(SK_AC*, void*, uintptr_t, RXD**, RXD**, RXD**,
-			int*, SK_BOOL);
-
-static void	SkGeIsr(int irq, void *dev_id, struct pt_regs *ptregs);
-static void	SkGeIsrOnePort(int irq, void *dev_id, struct pt_regs *ptregs);
+static void	SetupRing(SK_AC*, void*, uintptr_t, RXD**, RXD**, RXD**, int*, SK_BOOL);
+static SkIsrRetVar	SkGeIsr(int irq, void *dev_id, struct pt_regs *ptregs);
+static SkIsrRetVar	SkGeIsrOnePort(int irq, void *dev_id, struct pt_regs *ptregs);
 static int	SkGeOpen(struct SK_NET_DEVICE *dev);
 static int	SkGeClose(struct SK_NET_DEVICE *dev);
 static int	SkGeXmit(struct sk_buff *skb, struct SK_NET_DEVICE *dev);
@@ -407,33 +544,45 @@
 static void	FillRxRing(SK_AC*, RX_PORT*);
 static SK_BOOL	FillRxDescriptor(SK_AC*, RX_PORT*);
 static void	ReceiveIrq(SK_AC*, RX_PORT*, SK_BOOL);
-static void ClearAndStartRx(SK_AC*, int);
+static void	ClearAndStartRx(SK_AC*, int);
 static void	ClearTxIrq(SK_AC*, int, int);
 static void	ClearRxRing(SK_AC*, RX_PORT*);
 static void	ClearTxRing(SK_AC*, TX_PORT*);
-static void	SetQueueSizes(SK_AC	*pAC);
 static int	SkGeChangeMtu(struct SK_NET_DEVICE *dev, int new_mtu);
 static void	PortReInitBmu(SK_AC*, int);
 static int	SkGeIocMib(DEV_NET*, unsigned int, int);
+static void	StartDrvCleanupTimer(SK_AC *pAC);
+static void	StopDrvCleanupTimer(SK_AC *pAC);
 static int	XmitFrameSG(SK_AC*, TX_PORT*, struct sk_buff*);
 
-/*Extern */
+/*******************************************************************************
+ *
+ * Extern Function Prototypes
+ *
+ ******************************************************************************/
 
-/* external Proc function */
-extern int proc_read(
-	char	*buffer,
-	char	**buffer_location,
-	off_t	offset,
-	int		buffer_length,
-	int		*eof,
-	void	*data);
+#ifdef CONFIG_PROC_FS
+static const char 	SK_Root_Dir_entry[] = "sk98lin";
+static struct		proc_dir_entry *pSkRootDir;
+
+extern int 		sk_proc_read(	char   *buffer,
+					char	**buffer_location,
+					off_t	offset,
+					int	buffer_length,
+					int	*eof,
+					void	*data);
+#endif
+
+extern void SkDimEnableModerationIfNeeded(SK_AC *pAC);	
+extern void SkDimDisplayModerationSettings(SK_AC *pAC);
+extern void SkDimStartModerationTimer(SK_AC *pAC);
+extern void SkDimModerate(SK_AC *pAC);
 
 #ifdef DEBUG
 static void	DumpMsg(struct sk_buff*, char*);
 static void	DumpData(char*, int);
 static void	DumpLong(char*, int);
 #endif
-void dump_frag( SK_U8 *data, int length);
 
 /* global variables *********************************************************/
 static const char *BootString = BOOT_STRING;
@@ -445,10 +594,9 @@
 static uintptr_t RxQueueAddr[SK_MAX_MACS] = {0x400, 0x480};
 
 
-/* local variables **********************************************************/
-const char SK_Root_Dir_entry[8];
-
+#ifdef CONFIG_PROC_FS
 static struct proc_dir_entry	*pSkRootDir;
+#endif
 
 
 
@@ -467,35 +615,37 @@
  */
 static int __init skge_probe (void)
 {
-	int			proc_root_initialized = 0;
 	int			boards_found = 0;
+	int			vendor_flag = SK_FALSE;
 	SK_AC			*pAC;
 	DEV_NET			*pNet = NULL;
-	struct proc_dir_entry	*pProcFile;
 	struct pci_dev	*pdev = NULL;
 	unsigned long		base_address;
 	struct SK_NET_DEVICE *dev = NULL;
 	SK_BOOL DeviceFound = SK_FALSE;
 	SK_BOOL BootStringCount = SK_FALSE;
+#ifdef CONFIG_PROC_FS
+	int			proc_root_initialized = 0;
+	struct proc_dir_entry	*pProcFile;
+#endif
 
 	if (probed)
 		return -ENODEV;
 	probed++;
 
-	if (!pci_present())		/* is PCI support present? */
+	if (!pci_present()) {		/* is PCI support present? */
 		return -ENODEV;
+	}
 
-		while((pdev = pci_find_class(PCI_CLASS_NETWORK_ETHERNET << 8, pdev)))
-		{
+	while((pdev = pci_find_class(PCI_CLASS_NETWORK_ETHERNET << 8, pdev))) {
 
 		dev = NULL;
 		pNet = NULL;
 
-		if ((pdev->vendor != PCI_VENDOR_ID_SYSKONNECT) && 
-			((pdev->device != PCI_DEVICE_ID_SYSKONNECT_GE) || 
-			(pdev->device != PCI_DEVICE_ID_SYSKONNECT_YU))){
+
+		SK_PCI_ISCOMPLIANT(vendor_flag, pdev);
+		if (!vendor_flag)
 			continue;
-		}
 
 		/* Configure DMA attributes. */
 		if (pci_set_dma_mask(pdev, (u64) 0xffffffffffffffffULL) &&
@@ -556,12 +706,15 @@
 		dev->flags &= 		~IFF_RUNNING;
 
 #ifdef SK_ZEROCOPY
-		if (pAC->GIni.GIChipId == CHIP_ID_YUKON) {
+#ifdef USE_SK_TX_CHECKSUM
+
+		if (pAC->ChipsetType) {
 			/* Use only if yukon hardware */
 			/* SK and ZEROCOPY - fly baby... */
 			dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
 		}
 #endif
+#endif
 
 		/*
 		 * Dummy value.
@@ -609,6 +762,7 @@
 			(caddr_t) &pAC->Addr.Net[0].CurrentMacAddress, 6);
 
 		/* First adapter... Create proc and print message */
+#ifdef CONFIG_PROC_FS
 		if (!DeviceFound) {
 			DeviceFound = SK_TRUE;
 			SK_MEMCPY(&SK_Root_Dir_entry, BootString,
@@ -618,35 +772,37 @@
 			if(!proc_root_initialized) {
 				pSkRootDir = create_proc_entry(SK_Root_Dir_entry,
 					S_IFDIR | S_IWUSR | S_IRUGO | S_IXUGO, proc_net);
+				pSkRootDir->owner = THIS_MODULE;
 				proc_root_initialized = 1;
 			}
-
-			pSkRootDir->owner = THIS_MODULE;
 		}
 
-
-
 		/* Create proc file */
 		pProcFile = create_proc_entry(dev->name,
 			S_IFREG | S_IXUSR | S_IWGRP | S_IROTH,
 			pSkRootDir);
 
 		
-		pProcFile->read_proc = proc_read;
+		pProcFile->read_proc = sk_proc_read;
 		pProcFile->write_proc = NULL;
 		pProcFile->nlink = 1;
 		pProcFile->size = sizeof(dev->name + 1);
 		pProcFile->data = (void *)pProcFile;
+		pProcFile->owner = THIS_MODULE;
+#endif
 
 		pNet->PortNr = 0;
 		pNet->NetNr = 0;
 
+
 #ifdef SK_ZEROCOPY
-			if (pAC->GIni.GIChipId == CHIP_ID_YUKON) {
+#ifdef USE_SK_TX_CHECKSUM
+			if (pAC->ChipsetType) {
 				/* SG and ZEROCOPY - fly baby... */
 				dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
 			}
 #endif
+#endif
 
 		boards_found++;
 
@@ -677,22 +833,27 @@
 			dev->flags &= 		~IFF_RUNNING;
 
 #ifdef SK_ZEROCOPY
-			if (pAC->GIni.GIChipId == CHIP_ID_YUKON) {
+#ifdef USE_SK_TX_CHECKSUM
+			if (pAC->ChipsetType) {
 				/* SG and ZEROCOPY - fly baby... */
 				dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
 			}
 #endif
+#endif
 
+#ifdef CONFIG_PROC_FS
 			pProcFile = create_proc_entry(dev->name,
 				S_IFREG | S_IXUSR | S_IWGRP | S_IROTH,
 				pSkRootDir);
 
 		
-			pProcFile->read_proc = proc_read;
+			pProcFile->read_proc = sk_proc_read;
 			pProcFile->write_proc = NULL;
 			pProcFile->nlink = 1;
 			pProcFile->size = sizeof(dev->name + 1);
 			pProcFile->data = (void *)pProcFile;
+			pProcFile->owner = THIS_MODULE;
+#endif
 
 			memcpy((caddr_t) &dev->dev_addr,
 			(caddr_t) &pAC->Addr.Net[1].CurrentMacAddress, 6);
@@ -771,13 +932,20 @@
 MODULE_PARM(DupCap_B,   "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(FlowCtrl_A, "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(FlowCtrl_B, "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
-MODULE_PARM(Role_A,	    "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
-MODULE_PARM(Role_B,	    "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(Role_A,	"1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(Role_B,	"1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(ConType,	"1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(PrefPort,   "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(RlmtMode,   "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 /* not used, just there because every driver should have them: */
 MODULE_PARM(options,    "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "i");
 MODULE_PARM(debug,      "i");
+/* used for interrupt moderation */
+MODULE_PARM(IntsPerSec,     "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "i");
+MODULE_PARM(Moderation,     "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(Stats,          "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(ModerationMask, "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(AutoSizing,     "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 
 
 #ifdef LINK_SPEED_A
@@ -840,6 +1008,12 @@
 static char *Role_B[SK_MAX_CARD_PARAM] = {"", };
 #endif
 
+#ifdef CON_TYPE
+static char *ConType[SK_MAX_CARD_PARAM] = CON_TYPE;
+#else
+static char *ConType[SK_MAX_CARD_PARAM] = {"", };
+#endif
+
 #ifdef PREF_PORT
 static char *PrefPort[SK_MAX_CARD_PARAM] = PREF_PORT;
 #else
@@ -855,6 +1029,12 @@
 static int debug = 0; /* not used */
 static int options[SK_MAX_CARD_PARAM] = {0, }; /* not used */
 
+static int   IntsPerSec[SK_MAX_CARD_PARAM];
+static char *Moderation[SK_MAX_CARD_PARAM];
+static char *ModerationMask[SK_MAX_CARD_PARAM];
+static char *AutoSizing[SK_MAX_CARD_PARAM];
+static char *Stats[SK_MAX_CARD_PARAM];
+
 
 /*****************************************************************************
  *
@@ -878,7 +1058,7 @@
 
 	cards = skge_probe();
 	if (cards == 0) {
-		printk("No adapter found.\n");
+		printk("sk98lin: No adapter found.\n");
 	}
 	return cards ? 0 : -ENODEV;
 } /* skge_init_module */
@@ -910,7 +1090,7 @@
 		netif_stop_queue(SkGeRootDev);
 		SkGeYellowLED(pAC, pAC->IoBase, 0);
 
-		if(pAC->BoardLevel == 2) {
+		if(pAC->BoardLevel == SK_INIT_RUN) {
 			/* board is still alive */
 			spin_lock_irqsave(&pAC->SlowPathLock, Flags);
 			EvPara.Para32[0] = 0;
@@ -922,16 +1102,16 @@
 			SkEventDispatcher(pAC, pAC->IoBase);
 			/* disable interrupts */
 			SK_OUT32(pAC->IoBase, B0_IMSK, 0);
-			SkGeDeInit(pAC, pAC->IoBase); 
+			SkGeDeInit(pAC, pAC->IoBase);
 			spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
-			pAC->BoardLevel = 0;
+			pAC->BoardLevel = SK_INIT_DATA;
 			/* We do NOT check here, if IRQ was pending, of course*/
 		}
 
-		if(pAC->BoardLevel == 1) {
+		if(pAC->BoardLevel == SK_INIT_IO) {
 			/* board is still alive */
-			SkGeDeInit(pAC, pAC->IoBase); 
-			pAC->BoardLevel = 0;
+			SkGeDeInit(pAC, pAC->IoBase);
+			pAC->BoardLevel = SK_INIT_DATA;
 		}
 
 		if ((pAC->GIni.GIMacsFound == 2) && pAC->RlmtNets == 2){
@@ -942,7 +1122,7 @@
 		FreeResources(SkGeRootDev);
 
 		SkGeRootDev->get_stats = NULL;
-		/* 
+		/*
 		 * otherwise unregister_netdev calls get_stats with
 		 * invalid IO ...  :-(
 		 */
@@ -952,14 +1132,17 @@
 		SkGeRootDev = next;
 	}
 
+#ifdef CONFIG_PROC_FS
 	/* clear proc-dir */
 	remove_proc_entry(pSkRootDir->name, proc_net);
+#endif
 
 } /* skge_cleanup_module */
 
 module_init(skge_init_module);
 module_exit(skge_cleanup_module);
 
+
 /*****************************************************************************
  *
  * 	SkGeBoardInit - do level 0 and 1 initialization
@@ -1002,20 +1185,20 @@
 	
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
 	/* Does a RESET on board ...*/
-	if (SkGeInit(pAC, pAC->IoBase, 0) != 0) {
+	if (SkGeInit(pAC, pAC->IoBase, SK_INIT_DATA) != 0) {
 		printk("HWInit (0) failed.\n");
 		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 		return(-EAGAIN);
 	}
-	SkI2cInit(  pAC, pAC->IoBase, 0);
-	SkEventInit(pAC, pAC->IoBase, 0);
-	SkPnmiInit( pAC, pAC->IoBase, 0);
-	SkAddrInit( pAC, pAC->IoBase, 0);
-	SkRlmtInit( pAC, pAC->IoBase, 0);
-	SkTimerInit(pAC, pAC->IoBase, 0);
+	SkI2cInit(  pAC, pAC->IoBase, SK_INIT_DATA);
+	SkEventInit(pAC, pAC->IoBase, SK_INIT_DATA);
+	SkPnmiInit( pAC, pAC->IoBase, SK_INIT_DATA);
+	SkAddrInit( pAC, pAC->IoBase, SK_INIT_DATA);
+	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_DATA);
+	SkTimerInit(pAC, pAC->IoBase, SK_INIT_DATA);
 	
-	pAC->BoardLevel = 0;
-	pAC->RxBufSize = ETH_BUF_SIZE;
+	pAC->BoardLevel = SK_INIT_DATA;
+	pAC->RxBufSize  = ETH_BUF_SIZE;
 
 	SK_PNMI_SET_DRIVER_DESCR(pAC, DescrString);
 	SK_PNMI_SET_DRIVER_VER(pAC, VerStr);
@@ -1024,24 +1207,31 @@
 
 	/* level 1 init common modules here (HW init) */
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
-	if (SkGeInit(pAC, pAC->IoBase, 1) != 0) {
+	if (SkGeInit(pAC, pAC->IoBase, SK_INIT_IO) != 0) {
 		printk("HWInit (1) failed.\n");
 		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 		return(-EAGAIN);
 	}
-	SkI2cInit(  pAC, pAC->IoBase, 1);
-	SkEventInit(pAC, pAC->IoBase, 1);
-	SkPnmiInit( pAC, pAC->IoBase, 1);
-	SkAddrInit( pAC, pAC->IoBase, 1);
-	SkRlmtInit( pAC, pAC->IoBase, 1);
-	SkTimerInit(pAC, pAC->IoBase, 1);
+	SkI2cInit(  pAC, pAC->IoBase, SK_INIT_IO);
+	SkEventInit(pAC, pAC->IoBase, SK_INIT_IO);
+	SkPnmiInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkAddrInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkTimerInit(pAC, pAC->IoBase, SK_INIT_IO);
+
+	/* Set chipset type support */
+	pAC->ChipsetType = 0;
+	if ((pAC->GIni.GIChipId == CHIP_ID_YUKON) ||
+		(pAC->GIni.GIChipId == CHIP_ID_YUKON_LITE)) {
+		pAC->ChipsetType = 1;
+	}
 
 	GetConfiguration(pAC);
 	if (pAC->RlmtNets == 2) {
 		pAC->GIni.GIPortUsage = SK_MUL_LINK;
 	}
 
-	pAC->BoardLevel = 1;
+	pAC->BoardLevel = SK_INIT_IO;
 	spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 
 	if (pAC->GIni.GIMacsFound == 2) {
@@ -1074,9 +1264,6 @@
 	pAC->CsOfs = (pAC->CsOfs2 << 16) | pAC->CsOfs1;
 
 	BoardInitMem(pAC);
-#if 0
-	SetQueueSizes(pAC);
-#else
 	/* tschilling: New common function with minimum size check. */
 	DualNet = SK_FALSE;
 	if (pAC->RlmtNets == 2) {
@@ -1091,7 +1278,6 @@
 		printk("SkGeInitAssignRamToQueues failed.\n");
 		return(-EAGAIN);
 	}
-#endif
 
 	/* Print adapter specific string from vpd */
 	ProductStr(pAC);
@@ -1101,9 +1287,9 @@
 	printk("      PrefPort:%c  RlmtMode:%s\n",
 		'A' + pAC->Rlmt.Net[0].Port[pAC->Rlmt.Net[0].PrefPort]->PortNumber,
 		(pAC->RlmtMode==0)  ? "Check Link State" :
-		((pAC->RlmtMode==1) ? "Check Link State" : 
-		((pAC->RlmtMode==3) ? "Check Local Port" : 
-		((pAC->RlmtMode==7) ? "Check Segmentation" : 
+		((pAC->RlmtMode==1) ? "Check Link State" :
+		((pAC->RlmtMode==3) ? "Check Local Port" :
+		((pAC->RlmtMode==7) ? "Check Segmentation" :
 		((pAC->RlmtMode==17) ? "Dual Check Link State" :"Error")))));
 
 	SkGeYellowLED(pAC, pAC->IoBase, 1);
@@ -1306,7 +1492,7 @@
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
 		("Descriptor size: %d   Descriptor Number: %d\n",
 		DescrSize,DescrNum));
-
+	
 	pDescr = (RXD*) pMemArea;
 	pPrevDescr = NULL;
 	pNextDescr = (RXD*) (((char*)pDescr) + DescrSize);
@@ -1353,24 +1539,22 @@
 		("PortReInitBmu "));
 
 	/* set address of first descriptor of ring in BMU */
-	SK_OUT32(pAC->IoBase, TxQueueAddr[PortIndex][TX_PRIO_LOW]+
-		TX_Q_CUR_DESCR_LOW,
+	SK_OUT32(pAC->IoBase, TxQueueAddr[PortIndex][TX_PRIO_LOW]+ Q_DA_L,
 		(uint32_t)(((caddr_t)
 		(pAC->TxPort[PortIndex][TX_PRIO_LOW].pTxdRingHead) -
 		pAC->TxPort[PortIndex][TX_PRIO_LOW].pTxDescrRing +
 		pAC->TxPort[PortIndex][TX_PRIO_LOW].VTxDescrRing) &
 		0xFFFFFFFF));
-	SK_OUT32(pAC->IoBase, TxQueueAddr[PortIndex][TX_PRIO_LOW]+
-		TX_Q_DESCR_HIGH,
+	SK_OUT32(pAC->IoBase, TxQueueAddr[PortIndex][TX_PRIO_LOW]+ Q_DA_H,
 		(uint32_t)(((caddr_t)
 		(pAC->TxPort[PortIndex][TX_PRIO_LOW].pTxdRingHead) -
 		pAC->TxPort[PortIndex][TX_PRIO_LOW].pTxDescrRing +
 		pAC->TxPort[PortIndex][TX_PRIO_LOW].VTxDescrRing) >> 32));
-	SK_OUT32(pAC->IoBase, RxQueueAddr[PortIndex]+RX_Q_CUR_DESCR_LOW,
+	SK_OUT32(pAC->IoBase, RxQueueAddr[PortIndex]+Q_DA_L,
 		(uint32_t)(((caddr_t)(pAC->RxPort[PortIndex].pRxdRingHead) -
 		pAC->RxPort[PortIndex].pRxDescrRing +
 		pAC->RxPort[PortIndex].VRxDescrRing) & 0xFFFFFFFF));
-	SK_OUT32(pAC->IoBase, RxQueueAddr[PortIndex]+RX_Q_DESCR_HIGH,
+	SK_OUT32(pAC->IoBase, RxQueueAddr[PortIndex]+Q_DA_H,
 		(uint32_t)(((caddr_t)(pAC->RxPort[PortIndex].pRxdRingHead) -
 		pAC->RxPort[PortIndex].pRxDescrRing +
 		pAC->RxPort[PortIndex].VRxDescrRing) >> 32));
@@ -1389,7 +1573,7 @@
  * Returns: N/A
  *
  */
-static void SkGeIsr(int irq, void *dev_id, struct pt_regs *ptregs)
+static SkIsrRetVar SkGeIsr(int irq, void *dev_id, struct pt_regs *ptregs)
 {
 struct SK_NET_DEVICE *dev = (struct SK_NET_DEVICE *)dev_id;
 DEV_NET		*pNet;
@@ -1409,20 +1593,20 @@
 
 	while (((IntSrc & IRQ_MASK) & ~SPECIAL_IRQS) != 0) {
 #if 0 /* software irq currently not used */
-		if (IntSrc & IRQ_SW) {
+		if (IntSrc & IS_IRQ_SW) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("Software IRQ\n"));
 		}
 #endif
-		if (IntSrc & IRQ_EOF_RX1) {
+		if (IntSrc & IS_R1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF RX1 IRQ\n"));
 			ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
 			SK_PNMI_CNT_RX_INTR(pAC, 0);
 		}
-		if (IntSrc & IRQ_EOF_RX2) {
+		if (IntSrc & IS_R2_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF RX2 IRQ\n"));
@@ -1430,7 +1614,7 @@
 			SK_PNMI_CNT_RX_INTR(pAC, 1);
 		}
 #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
-		if (IntSrc & IRQ_EOF_AS_TX1) {
+		if (IntSrc & IS_XA1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF AS TX1 IRQ\n"));
@@ -1439,7 +1623,7 @@
 			FreeTxDescriptors(pAC, &pAC->TxPort[0][TX_PRIO_LOW]);
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
 		}
-		if (IntSrc & IRQ_EOF_AS_TX2) {
+		if (IntSrc & IS_XA2_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF AS TX2 IRQ\n"));
@@ -1449,7 +1633,7 @@
 			spin_unlock(&pAC->TxPort[1][TX_PRIO_LOW].TxDesRingLock);
 		}
 #if 0 /* only if sync. queues used */
-		if (IntSrc & IRQ_EOF_SY_TX1) {
+		if (IntSrc & IS_XS1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF SY TX1 IRQ\n"));
@@ -1459,7 +1643,7 @@
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
 			ClearTxIrq(pAC, 0, TX_PRIO_HIGH);
 		}
-		if (IntSrc & IRQ_EOF_SY_TX2) {
+		if (IntSrc & IS_XS2_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF SY TX2 IRQ\n"));
@@ -1473,19 +1657,20 @@
 #endif
 
 		/* do all IO at once */
-		if (IntSrc & IRQ_EOF_RX1)
+		if (IntSrc & IS_R1_F)
 			ClearAndStartRx(pAC, 0);
-		if (IntSrc & IRQ_EOF_RX2)
+		if (IntSrc & IS_R2_F)
 			ClearAndStartRx(pAC, 1);
 #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
-		if (IntSrc & IRQ_EOF_AS_TX1)
+		if (IntSrc & IS_XA1_F)
 			ClearTxIrq(pAC, 0, TX_PRIO_LOW);
-		if (IntSrc & IRQ_EOF_AS_TX2)
+		if (IntSrc & IS_XA2_F)
 			ClearTxIrq(pAC, 1, TX_PRIO_LOW);
 #endif
 		SK_IN32(pAC->IoBase, B0_ISRC, &IntSrc);
 	} /* while (IntSrc & IRQ_MASK != 0) */
 
+	IntSrc &= pAC->GIni.GIValIrqMask;
 	if ((IntSrc & SPECIAL_IRQS) || pAC->CheckQueue) {
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
 			("SPECIAL IRQ DP-Cards => %x\n", IntSrc));
@@ -1498,13 +1683,17 @@
 		spin_unlock(&pAC->SlowPathLock);
 	}
 	/*
-	 * do it all again is case we cleared an interrupt that 
+	 * do it all again is case we cleared an interrupt that
 	 * came in after handling the ring (OUTs may be delayed
 	 * in hardware buffers, but are through after IN)
-	 */
-
+	 *
+	 * rroesler: has been commented out and shifted to
+	 *           SkGeDrvEvent(), because it is timer
+	 *           guarded now
+	 *
 	ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
 	ReceiveIrq(pAC, &pAC->RxPort[1], SK_TRUE);
+	 */
 
 	if (pAC->CheckQueue) {
 		pAC->CheckQueue = SK_FALSE;
@@ -1513,11 +1702,10 @@
 		spin_unlock(&pAC->SlowPathLock);
 	}
 
-
 	/* IRQ is processed - Enable IRQs again*/
-	SK_OUT32(pAC->IoBase, B0_IMSK, IRQ_MASK);
+	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 
-	return;
+		return;
 } /* SkGeIsr */
 
 
@@ -1534,7 +1722,7 @@
  * Returns: N/A
  *
  */
-static void SkGeIsrOnePort(int irq, void *dev_id, struct pt_regs *ptregs)
+static SkIsrRetVar SkGeIsrOnePort(int irq, void *dev_id, struct pt_regs *ptregs)
 {
 struct SK_NET_DEVICE *dev = (struct SK_NET_DEVICE *)dev_id;
 DEV_NET		*pNet;
@@ -1554,13 +1742,13 @@
 	
 	while (((IntSrc & IRQ_MASK) & ~SPECIAL_IRQS) != 0) {
 #if 0 /* software irq currently not used */
-		if (IntSrc & IRQ_SW) {
+		if (IntSrc & IS_IRQ_SW) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("Software IRQ\n"));
 		}
 #endif
-		if (IntSrc & IRQ_EOF_RX1) {
+		if (IntSrc & IS_R1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF RX1 IRQ\n"));
@@ -1568,7 +1756,7 @@
 			SK_PNMI_CNT_RX_INTR(pAC, 0);
 		}
 #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
-		if (IntSrc & IRQ_EOF_AS_TX1) {
+		if (IntSrc & IS_XA1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF AS TX1 IRQ\n"));
@@ -1578,7 +1766,7 @@
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
 		}
 #if 0 /* only if sync. queues used */
-		if (IntSrc & IRQ_EOF_SY_TX1) {
+		if (IntSrc & IS_XS1_F) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF SY TX1 IRQ\n"));
@@ -1592,15 +1780,16 @@
 #endif
 
 		/* do all IO at once */
-		if (IntSrc & IRQ_EOF_RX1)
+		if (IntSrc & IS_R1_F)
 			ClearAndStartRx(pAC, 0);
 #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
-		if (IntSrc & IRQ_EOF_AS_TX1)
+		if (IntSrc & IS_XA1_F)
 			ClearTxIrq(pAC, 0, TX_PRIO_LOW);
 #endif
 		SK_IN32(pAC->IoBase, B0_ISRC, &IntSrc);
 	} /* while (IntSrc & IRQ_MASK != 0) */
 	
+	IntSrc &= pAC->GIni.GIValIrqMask;
 	if ((IntSrc & SPECIAL_IRQS) || pAC->CheckQueue) {
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
 			("SPECIAL IRQ SP-Cards => %x\n", IntSrc));
@@ -1613,16 +1802,21 @@
 		spin_unlock(&pAC->SlowPathLock);
 	}
 	/*
-	 * do it all again is case we cleared an interrupt that 
+	 * do it all again is case we cleared an interrupt that
 	 * came in after handling the ring (OUTs may be delayed
 	 * in hardware buffers, but are through after IN)
-	 */
+	 *
+	 * rroesler: has been commented out and shifted to
+	 *           SkGeDrvEvent(), because it is timer
+	 *           guarded now
+	 *
 	ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
+	 */
 
 	/* IRQ is processed - Enable IRQs again*/
-	SK_OUT32(pAC->IoBase, B0_IMSK, IRQ_MASK);
+	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 
-	return;
+		return;
 } /* SkGeIsrOnePort */
 
 
@@ -1657,34 +1851,39 @@
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeOpen: pAC=0x%lX:\n", (unsigned long)pAC));
 
-	if (pAC->BoardLevel == 0) {
+
+	/* Set blink mode */
+	if (pAC->PciDev->vendor == 0x1186)
+		pAC->GIni.GILedBlinkCtrl = OEM_CONFIG_VALUE;
+
+	if (pAC->BoardLevel == SK_INIT_DATA) {
 		/* level 1 init common modules here */
-		if (SkGeInit(pAC, pAC->IoBase, 1) != 0) {
+		if (SkGeInit(pAC, pAC->IoBase, SK_INIT_IO) != 0) {
 			printk("%s: HWInit (1) failed.\n", pAC->dev[pNet->PortNr]->name);
 			return (-1);
 		}
-		SkI2cInit	(pAC, pAC->IoBase, 1);
-		SkEventInit	(pAC, pAC->IoBase, 1);
-		SkPnmiInit	(pAC, pAC->IoBase, 1);
-		SkAddrInit	(pAC, pAC->IoBase, 1);
-		SkRlmtInit	(pAC, pAC->IoBase, 1);
-		SkTimerInit	(pAC, pAC->IoBase, 1);
-		pAC->BoardLevel = 1;
+		SkI2cInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkEventInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkPnmiInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkAddrInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkRlmtInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkTimerInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		pAC->BoardLevel = SK_INIT_IO;
 	}
 
-	if (pAC->BoardLevel != 2) {
+	if (pAC->BoardLevel != SK_INIT_RUN) {
 		/* tschilling: Level 2 init modules here, check return value. */
-		if (SkGeInit(pAC, pAC->IoBase, 2) != 0) {
+		if (SkGeInit(pAC, pAC->IoBase, SK_INIT_RUN) != 0) {
 			printk("%s: HWInit (2) failed.\n", pAC->dev[pNet->PortNr]->name);
 			return (-1);
 		}
-		SkI2cInit	(pAC, pAC->IoBase, 2);
-		SkEventInit	(pAC, pAC->IoBase, 2);
-		SkPnmiInit	(pAC, pAC->IoBase, 2);
-		SkAddrInit	(pAC, pAC->IoBase, 2);
-		SkRlmtInit	(pAC, pAC->IoBase, 2);
-		SkTimerInit	(pAC, pAC->IoBase, 2);
-		pAC->BoardLevel = 2;
+		SkI2cInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkEventInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkPnmiInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkAddrInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkRlmtInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkTimerInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		pAC->BoardLevel = SK_INIT_RUN;
 	}
 
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
@@ -1694,20 +1893,14 @@
 	}
 	SkGeYellowLED(pAC, pAC->IoBase, 1);
 
-#ifdef USE_INT_MOD
-/* moderate only TX complete interrupts (these are not time critical) */
-#define IRQ_MOD_MASK (IRQ_EOF_AS_TX1 | IRQ_EOF_AS_TX2)
-	{
-		unsigned long ModBase;
-		ModBase = 53125000 / INTS_PER_SEC;
-		SK_OUT32(pAC->IoBase, B2_IRQM_INI, ModBase);
-		SK_OUT32(pAC->IoBase, B2_IRQM_MSK, IRQ_MOD_MASK);
-		SK_OUT32(pAC->IoBase, B2_IRQM_CTRL, TIM_START);
-	}
-#endif
+	StartDrvCleanupTimer(pAC);
+	SkDimEnableModerationIfNeeded(pAC);	
+	SkDimDisplayModerationSettings(pAC);
+
+	pAC->GIni.GIValIrqMask &= IRQ_MASK;
 
 	/* enable Interrupts */
-	SK_OUT32(pAC->IoBase, B0_IMSK, IRQ_MASK);
+	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 	SK_OUT32(pAC->IoBase, B0_HWE_IMSK, IRQ_HWE_MASK);
 
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
@@ -1775,7 +1968,9 @@
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeClose: pAC=0x%lX ", (unsigned long)pAC));
 
-	/* 
+        StopDrvCleanupTimer(pAC);
+
+	/*
 	 * Clear multicast table, promiscuous mode ....
 	 */
 	SkAddrMcClear(pAC, pAC->IoBase, PortIdx, 0);
@@ -1793,7 +1988,7 @@
 		SK_OUT32(pAC->IoBase, B0_IMSK, 0);
 		/* stop the hardware */
 		SkGeDeInit(pAC, pAC->IoBase);
-		pAC->BoardLevel = 0;
+		pAC->BoardLevel = SK_INIT_DATA;
 		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 	} else {
 
@@ -1807,7 +2002,7 @@
 		/* Stop port */
 		spin_lock_irqsave(&pAC->TxPort[pNet->PortNr]
 			[TX_PRIO_LOW].TxDesRingLock, Flags);
-		SkGeStopPort(pAC, pAC->IoBase, pNet->PortNr, 
+		SkGeStopPort(pAC, pAC->IoBase, pNet->PortNr,
 			SK_STOP_ALL, SK_HARD_RST);
 		spin_unlock_irqrestore(&pAC->TxPort[pNet->PortNr]
 			[TX_PRIO_LOW].TxDesRingLock, Flags);
@@ -1832,8 +2027,8 @@
 
 	pAC->MaxPorts--;
 	pNet->Up = 0;
+
 	MOD_DEC_USE_COUNT;
-	
 	return (0);
 } /* SkGeClose */
 
@@ -1862,7 +2057,7 @@
 	pNet = (DEV_NET*) dev->priv;
 	pAC = pNet->pAC;
 
-	if ((!skb_shinfo(skb)->nr_frags) || 
+	if ((!skb_shinfo(skb)->nr_frags) ||
 		(pAC->GIni.GIChipId == CHIP_ID_GENESIS)) {
 		/* Don't activate scatter-gather and hardware checksum */
 
@@ -1929,24 +2124,29 @@
  *	< 0 - on failure: other problems ( -> return failure to upper layers)
  */
 static int XmitFrame(
-SK_AC 		*pAC,		/* pointer to adapter context */
+SK_AC 		*pAC,		/* pointer to adapter context           */
 TX_PORT		*pTxPort,	/* pointer to struct of port to send to */
-struct sk_buff	*pMessage)	/* pointer to send-message */
+struct sk_buff	*pMessage)	/* pointer to send-message              */
 {
-TXD		*pTxd;		/* the rxd to fill */
-unsigned long	Flags;
-SK_U64		PhysAddr;
-int		BytesSend;
+	TXD		*pTxd;		/* the rxd to fill */
+	TXD		*pOldTxd;
+	unsigned long	 Flags;
+	SK_U64		 PhysAddr;
+	int	 	 Protocol;
+	int		 IpHeaderLength;
+	int		 BytesSend = pMessage->len;
 
-	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
-		("X"));
+	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS, ("X"));
 
 	spin_lock_irqsave(&pTxPort->TxDesRingLock, Flags);
 #ifndef USE_TX_COMPLETE
 	FreeTxDescriptors(pAC, pTxPort);
 #endif
 	if (pTxPort->TxdRingFree == 0) {
-		/* no enough free descriptors in ring at the moment */
+		/* 
+		** no enough free descriptors in ring at the moment.
+		** Maybe free'ing some old one help?
+		*/
 		FreeTxDescriptors(pAC, pTxPort);
 		if (pTxPort->TxdRingFree == 0) {
 			spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
@@ -1954,59 +2154,104 @@
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_TX_PROGRESS,
 				("XmitFrame failed\n"));
-			/* this message can not be sent now */
-			/* Because tbusy seems to be set, the message should not be freed here */
-			/* It will be used by the scheduler of the ethernet handler */
+			/* 
+			** the desired message can not be sent
+			** Because tbusy seems to be set, the message 
+			** should not be freed here. It will be used 
+			** by the scheduler of the ethernet handler 
+			*/
 			return (-1);
 		}
 	}
-	/* advance head counter behind descriptor needed for this frame */
+
+	/*
+	** If the passed socket buffer is of smaller MTU-size than 60,
+	** copy everything into new buffer and fill all bytes between
+	** the original packet end and the new packet end of 60 with 0x00.
+	** This is to resolve faulty padding by the HW with 0xaa bytes.
+	*/
+	if (BytesSend < C_LEN_ETHERNET_MINSIZE) {
+	    skb_put(pMessage, (C_LEN_ETHERNET_MINSIZE-BytesSend));
+	    memset( ((int *)(pMessage->data))+BytesSend,
+	            0, C_LEN_ETHERNET_MINSIZE-BytesSend);
+	}
+
+	/* 
+	** advance head counter behind descriptor needed for this frame, 
+	** so that needed descriptor is reserved from that on. The next
+	** action will be to add the passed buffer to the TX-descriptor
+	*/
 	pTxd = pTxPort->pTxdRingHead;
 	pTxPort->pTxdRingHead = pTxd->pNextTxd;
 	pTxPort->TxdRingFree--;
-	/* the needed descriptor is reserved now */
-	
-	/* 
-	 * everything allocated ok, so add buffer to descriptor
-	 */
 
 #ifdef SK_DUMP_TX
 	DumpMsg(pMessage, "XmitFrame");
 #endif
 
-	/* set up descriptor and CONTROL dword */
+	/* 
+	** First step is to map the data to be sent via the adapter onto
+	** the DMA memory. Kernel 2.2 uses virt_to_bus(), but kernels 2.4
+	** and 2.6 need to use pci_map_page() for that mapping.
+	*/
 	PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
-		virt_to_page(pMessage->data),
-		((unsigned long) pMessage->data &
-		~PAGE_MASK),
-		pMessage->len,
-		PCI_DMA_TODEVICE);
-	pTxd->VDataLow = (SK_U32)  (PhysAddr & 0xffffffff);
+					virt_to_page(pMessage->data),
+					((unsigned long) pMessage->data & ~PAGE_MASK),
+					pMessage->len,
+					PCI_DMA_TODEVICE);
+	pTxd->VDataLow  = (SK_U32) (PhysAddr & 0xffffffff);
 	pTxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
-	pTxd->pMBuf = pMessage;
-	pTxd->TBControl = TX_CTRL_OWN_BMU | TX_CTRL_STF |
-		TX_CTRL_CHECK_DEFAULT | TX_CTRL_SOFTWARE |
+	pTxd->pMBuf     = pMessage;
+
+	if (pMessage->ip_summed == CHECKSUM_HW) {
+		Protocol = ((SK_U8)pMessage->data[C_OFFSET_IPPROTO] & 0xff);
+		if ((Protocol == C_PROTO_ID_UDP) && (pAC->GIni.GIChipRev != 0)) {
+			pTxd->TBControl = BMU_UDP_CHECK;
+		} else {
+			pTxd->TBControl = BMU_TCP_CHECK ;
+		}
+
+		IpHeaderLength  = (SK_U8)pMessage->data[C_OFFSET_IPHEADER];
+		IpHeaderLength  = (IpHeaderLength & 0xf) * 4;
+		pTxd->TcpSumOfs = 0; /* PH-Checksum already calculated */
+		pTxd->TcpSumSt  = C_LEN_ETHERMAC_HEADER + IpHeaderLength + 
+							(Protocol == C_PROTO_ID_UDP ?
+							C_OFFSET_UDPHEADER_UDPCS : 
+							C_OFFSET_TCPHEADER_TCPCS);
+		pTxd->TcpSumWr  = C_LEN_ETHERMAC_HEADER + IpHeaderLength;
+
+		pTxd->TBControl |= BMU_OWN | BMU_STF | 
+				   BMU_SW  | BMU_EOF |
 #ifdef USE_TX_COMPLETE
-		TX_CTRL_EOF | TX_CTRL_EOF_IRQ | pMessage->len;
-#else
-		TX_CTRL_EOF | pMessage->len;
+				   BMU_IRQ_EOF |
 #endif
-	
-	if ((pTxPort->pTxdRingPrev->TBControl & TX_CTRL_OWN_BMU) == 0) {
-		/* previous descriptor already done, so give tx start cmd */
-		/* StartTx(pAC, pTxPort->HwAddr); */
-		SK_OUT8(pTxPort->HwAddr, TX_Q_CTRL, TX_Q_CTRL_START);
+				   pMessage->len;
+        } else {
+		pTxd->TBControl = BMU_OWN | BMU_STF | BMU_CHECK | 
+				  BMU_SW  | BMU_EOF |
+#ifdef USE_TX_COMPLETE
+				   BMU_IRQ_EOF |
+#endif
+				   pMessage->len;
 	}
-	pTxPort->pTxdRingPrev = pTxd;
-	
-	
-	BytesSend = pMessage->len;
+
+	/* 
+	** If previous descriptor already done, give TX start cmd 
+	*/
+	pOldTxd = xchg(&pTxPort->pTxdRingPrev, pTxd);
+	if ((pOldTxd->TBControl & BMU_OWN) == 0) {
+		SK_OUT8(pTxPort->HwAddr, Q_CSR, CSR_START);
+	}	
+
+	/* 
+	** after releasing the lock, the skb may immediately be free'd 
+	*/
 	spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
-	/* after releasing the lock, the skb may be immidiately freed */
-	if (pTxPort->TxdRingFree != 0)
+	if (pTxPort->TxdRingFree != 0) {
 		return (BytesSend);
-	else
+	} else {
 		return (0);
+	}
 
 } /* XmitFrame */
 
@@ -2026,21 +2271,21 @@
  *	< 0 - on failure: other problems ( -> return failure to upper layers)
  */
 static int XmitFrameSG(
-SK_AC 		*pAC,			/* pointer to adapter context */
-TX_PORT		*pTxPort,		/* pointer to struct of port to send to */
-struct sk_buff	*pMessage)	/* pointer to send-message */
+SK_AC 		*pAC,		/* pointer to adapter context           */
+TX_PORT		*pTxPort,	/* pointer to struct of port to send to */
+struct sk_buff	*pMessage)	/* pointer to send-message              */
 {
 
-	int 		i;
-	int			BytesSend;
-	int			hlength;
-	int			protocol;
-	skb_frag_t		*sk_frag;
-	TXD			*pTxd;
-	TXD			*pTxdFst;
-	TXD			*pTxdLst;
-	SK_U64		PhysAddr;
-	unsigned long	Flags;
+	TXD		*pTxd;
+	TXD		*pTxdFst;
+	TXD		*pTxdLst;
+	int 	 	 CurrFrag;
+	int		 BytesSend;
+	int		 IpHeaderLength; 
+	int		 Protocol;
+	skb_frag_t	*sk_frag;
+	SK_U64		 PhysAddr;
+	unsigned long	 Flags;
 
 	spin_lock_irqsave(&pTxPort->TxDesRingLock, Flags);
 #ifndef USE_TX_COMPLETE
@@ -2059,114 +2304,120 @@
 		}
 	}
 
-
-	pTxd = pTxPort->pTxdRingHead;
-	pTxdFst = pTxd;
-	pTxdLst = pTxd;
+	pTxd      = pTxPort->pTxdRingHead;
+	pTxdFst   = pTxd;
+	pTxdLst   = pTxd;
 	BytesSend = 0;
-	protocol = 0;
+	Protocol  = 0;
 
-	/* map first fragment (header) */
+	/* 
+	** Map the first fragment (header) into the DMA-space
+	*/
 	PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
 			virt_to_page(pMessage->data),
 			((unsigned long) pMessage->data & ~PAGE_MASK),
 			skb_headlen(pMessage),
 			PCI_DMA_TODEVICE);
 
-	pTxd->VDataLow = (SK_U32)  (PhysAddr & 0xffffffff);
+	pTxd->VDataLow  = (SK_U32) (PhysAddr & 0xffffffff);
 	pTxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
 
-	/* HW checksum? */
+	/* 
+	** Does the HW need to evaluate checksum for TCP or UDP packets? 
+	*/
 	if (pMessage->ip_summed == CHECKSUM_HW) {
-		pTxd->TBControl = TX_CTRL_STF |
-				  TX_CTRL_ST_FWD |
-				  skb_headlen(pMessage);
-
-		/* We have to use the opcode for tcp here because the opcode for
-		udp is not working in the hardware yet (revision 2.0)*/
-		protocol = ((SK_U8)pMessage->data[23] & 0xf);
-		if ((protocol == 17) && (pAC->GIni.GIChipRev != 0))
-			pTxd->TBControl |=  BMU_UDP_CHECK;
-		else
+		pTxd->TBControl = BMU_STF | BMU_STFWD | skb_headlen(pMessage);
+		/* 
+		** We have to use the opcode for tcp here,  because the
+		** opcode for udp is not working in the hardware yet 
+		** (Revision 2.0)
+		*/
+		Protocol = ((SK_U8)pMessage->data[C_OFFSET_IPPROTO] & 0xff);
+		if ((Protocol == C_PROTO_ID_UDP) && (pAC->GIni.GIChipRev != 0)) {
+			pTxd->TBControl |= BMU_UDP_CHECK;
+		} else {
 			pTxd->TBControl |= BMU_TCP_CHECK ;
+		}
 
-		hlength = ((SK_U8)pMessage->data[14] & 0xf) * 4;
+		IpHeaderLength  = ((SK_U8)pMessage->data[C_OFFSET_IPHEADER] & 0xf)*4;
 		pTxd->TcpSumOfs = 0; /* PH-Checksum already claculated */
-		pTxd->TcpSumSt = 14+hlength+16;
-		pTxd->TcpSumWr = 14+hlength;
-	
+		pTxd->TcpSumSt  = C_LEN_ETHERMAC_HEADER + IpHeaderLength +
+						(Protocol == C_PROTO_ID_UDP ?
+						C_OFFSET_UDPHEADER_UDPCS :
+						C_OFFSET_TCPHEADER_TCPCS);
+		pTxd->TcpSumWr  = C_LEN_ETHERMAC_HEADER + IpHeaderLength;
 	} else {
-		pTxd->TBControl = TX_CTRL_CHECK_DEFAULT | 
-				  TX_CTRL_SOFTWARE |
-				  TX_CTRL_STF |
-				  skb_headlen(pMessage);
+		pTxd->TBControl = BMU_CHECK | BMU_SW | BMU_STF |
+					skb_headlen(pMessage);
 	}
 
 	pTxd = pTxd->pNextTxd;
 	pTxPort->TxdRingFree--;
 	BytesSend += skb_headlen(pMessage);
 
-
-	/* Map SG fragments */
-	for (i = 0; i < skb_shinfo(pMessage)->nr_frags; i++) {
-		sk_frag = &skb_shinfo(pMessage)->frags[i];
-		
-		/* we already have the proper value in entry */
+	/* 
+	** Browse over all SG fragments and map each of them into the DMA space
+	*/
+	for (CurrFrag = 0; CurrFrag < skb_shinfo(pMessage)->nr_frags; CurrFrag++) {
+		sk_frag = &skb_shinfo(pMessage)->frags[CurrFrag];
+		/* 
+		** we already have the proper value in entry
+		*/
 		PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
 						 sk_frag->page,
 						 sk_frag->page_offset,
 						 sk_frag->size,
 						 PCI_DMA_TODEVICE);
 
-		pTxd->VDataLow = (SK_U32)  (PhysAddr & 0xffffffff);
+		pTxd->VDataLow  = (SK_U32) (PhysAddr & 0xffffffff);
 		pTxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
-		pTxd->pMBuf = pMessage;
+		pTxd->pMBuf     = pMessage;
 		
-		/* HW checksum */
+		/* 
+		** Does the HW need to evaluate checksum for TCP or UDP packets? 
+		*/
 		if (pMessage->ip_summed == CHECKSUM_HW) {
-			pTxd->TBControl = TX_CTRL_OWN_BMU | 
-				  	  TX_CTRL_SOFTWARE |
-					  TX_CTRL_ST_FWD;
-
-			/* We have to use the opcode for tcp here because the opcode for
-			udp is not working in the hardware yet (revision 2.0)*/
-			if ((protocol == 17) && (pAC->GIni.GIChipRev != 0))
+			pTxd->TBControl = BMU_OWN | BMU_SW | BMU_STFWD;
+			/* 
+			** We have to use the opcode for tcp here because the 
+			** opcode for udp is not working in the hardware yet 
+			** (revision 2.0)
+			*/
+			if ( (Protocol == C_PROTO_ID_UDP) && 
+			     (pAC->GIni.GIChipRev != 0) ) {
 				pTxd->TBControl |= BMU_UDP_CHECK ;
-			else
+			} else {
 				pTxd->TBControl |= BMU_TCP_CHECK ;
-
+			}
 		} else {
-			pTxd->TBControl = TX_CTRL_CHECK_DEFAULT |
-					  TX_CTRL_SOFTWARE |
-					  TX_CTRL_OWN_BMU;
+			pTxd->TBControl = BMU_CHECK | BMU_SW | BMU_OWN;
 		}
 
-		/* Last fragment  */
-		if( (i+1) == skb_shinfo(pMessage)->nr_frags )  {
+		/* 
+		** Do we have the last fragment? 
+		*/
+		if( (CurrFrag+1) == skb_shinfo(pMessage)->nr_frags )  {
 #ifdef USE_TX_COMPLETE
-			pTxd->TBControl |= TX_CTRL_EOF |
-					   TX_CTRL_EOF_IRQ |
-					   sk_frag->size;
+			pTxd->TBControl |= BMU_EOF | BMU_IRQ_EOF | sk_frag->size;
 #else
-			pTxd->TBControl |= TX_CTRL_EOF |
-					   sk_frag->size;
+			pTxd->TBControl |= BMU_EOF | sk_frag->size;
 #endif
-			pTxdFst->TBControl |= TX_CTRL_OWN_BMU |
-					      TX_CTRL_SOFTWARE; 
+			pTxdFst->TBControl |= BMU_OWN | BMU_SW;
 
 		} else {
 			pTxd->TBControl |= sk_frag->size;
 		}
 		pTxdLst = pTxd;
-		pTxd = pTxd->pNextTxd;
+		pTxd    = pTxd->pNextTxd;
 		pTxPort->TxdRingFree--;
 		BytesSend += sk_frag->size;
 	}
 
-	if ((pTxPort->pTxdRingPrev->TBControl & TX_CTRL_OWN_BMU) == 0) {
-		/* previous descriptor already done, so give tx start cmd */
-		/* StartTx(pAC, pTxPort->HwAddr); */
-		SK_OUT8(pTxPort->HwAddr, TX_Q_CTRL, TX_Q_CTRL_START);
+	/* 
+	** If previous descriptor already done, give TX start cmd 
+	*/
+	if ((pTxPort->pTxdRingPrev->TBControl & BMU_OWN) == 0) {
+		SK_OUT8(pTxPort->HwAddr, Q_CSR, CSR_START);
 	}
 
 	pTxPort->pTxdRingPrev = pTxdLst;
@@ -2174,28 +2425,13 @@
 
 	spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
 
-	if (pTxPort->TxdRingFree > 0)
+	if (pTxPort->TxdRingFree > 0) {
 		return (BytesSend);
-	else
+	} else {
 		return (0);
+	}
 }
 
-
-void dump_frag( SK_U8 *data, int length)
-{
-        int i;
-
-        printk("Length: %d\n", length);                
-        for( i=0; i < length; i++ ) {
-                printk(" %02x", (SK_U8)*(data + i) );
-                if( !((i+1) % 20) )
-                  printk("\n");
-        }
-        printk("\n\n");
-
-}
-
-
 /*****************************************************************************
  *
  * 	FreeTxDescriptors - release descriptors from the descriptor ring
@@ -2224,44 +2460,48 @@
 SK_U64	PhysAddr;	/* address of DMA mapping */
 
 	pNewTail = pTxPort->pTxdRingTail;
-	pTxd = pNewTail;
-	/* 
-	 * loop forever; exits if TX_CTRL_SOFTWARE bit not set in start frame
-	 * or TX_CTRL_OWN_BMU bit set in any frame
-	 */
+	pTxd     = pNewTail;
+	/*
+	** loop forever; exits if BMU_SW bit not set in start frame
+	** or BMU_OWN bit set in any frame
+	*/
 	while (1) {
 		Control = pTxd->TBControl;
-		if ((Control & TX_CTRL_SOFTWARE) == 0) {
-			/* 
-			 * software controllable bit is set in first
-			 * fragment when given to BMU. Not set means that
-			 * this fragment was never sent or is already 
-			 * freed ( -> ring completely free now).
-			 */
+		if ((Control & BMU_SW) == 0) {
+			/*
+			** software controllable bit is set in first
+			** fragment when given to BMU. Not set means that
+			** this fragment was never sent or is already
+			** freed ( -> ring completely free now).
+			*/
 			pTxPort->pTxdRingTail = pTxd;
-			netif_start_queue(pAC->dev[pTxPort->PortIndex]);
+			netif_wake_queue(pAC->dev[pTxPort->PortIndex]);
 			return;
 		}
-		if (Control & TX_CTRL_OWN_BMU) {
+		if (Control & BMU_OWN) {
 			pTxPort->pTxdRingTail = pTxd;
 			if (pTxPort->TxdRingFree > 0) {
-				netif_start_queue(pAC->dev[pTxPort->PortIndex]);
+				netif_wake_queue(pAC->dev[pTxPort->PortIndex]);
 			}
 			return;
 		}
 		
-		/* release the DMA mapping */
+		/* 
+		** release the DMA mapping, because until not unmapped
+		** this buffer is considered being under control of the
+		** adapter card!
+		*/
 		PhysAddr = ((SK_U64) pTxd->VDataHigh) << (SK_U64) 32;
 		PhysAddr |= (SK_U64) pTxd->VDataLow;
 		pci_unmap_page(pAC->PciDev, PhysAddr,
 				 pTxd->pMBuf->len,
 				 PCI_DMA_TODEVICE);
 
-		if (Control & TX_CTRL_EOF)
+		if (Control & BMU_EOF)
 			DEV_KFREE_SKB_ANY(pTxd->pMBuf);	/* free message */
 
 		pTxPort->TxdRingFree++;
-		pTxd->TBControl &= ~TX_CTRL_SOFTWARE;
+		pTxd->TBControl &= ~BMU_SW;
 		pTxd = pTxd->pNextTxd; /* point behind fragment with EOF */
 	} /* while(forever) */
 } /* FreeTxDescriptors */
@@ -2340,11 +2580,15 @@
 		~PAGE_MASK),
 		pAC->RxBufSize - 2,
 		PCI_DMA_FROMDEVICE);
-	pRxd->VDataLow = (SK_U32) (PhysAddr & 0xffffffff);
+
+	pRxd->VDataLow  = (SK_U32) (PhysAddr & 0xffffffff);
 	pRxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
-	pRxd->pMBuf = pMsgBlock;
-	pRxd->RBControl = RX_CTRL_OWN_BMU | RX_CTRL_STF |
-		RX_CTRL_EOF_IRQ | RX_CTRL_CHECK_CSUM | Length;
+	pRxd->pMBuf     = pMsgBlock;
+	pRxd->RBControl = BMU_OWN       | 
+			  BMU_STF       | 
+			  BMU_IRQ_EOF   | 
+			  BMU_TCP_CHECK | 
+			  Length;
 	return (SK_TRUE);
 
 } /* FillRxDescriptor */
@@ -2375,15 +2619,18 @@
 	pRxPort->pRxdRingTail = pRxd->pNextRxd;
 	pRxPort->RxdRingFree--;
 	Length = pAC->RxBufSize;
-	pRxd->VDataLow = PhysLow;
+
+	pRxd->VDataLow  = PhysLow;
 	pRxd->VDataHigh = PhysHigh;
-	pRxd->pMBuf = pMsg;
-	pRxd->RBControl = RX_CTRL_OWN_BMU | RX_CTRL_STF |
-		RX_CTRL_EOF_IRQ | RX_CTRL_CHECK_CSUM | Length;
+	pRxd->pMBuf     = pMsg;
+	pRxd->RBControl = BMU_OWN       | 
+			  BMU_STF       |
+			  BMU_IRQ_EOF   | 
+			  BMU_TCP_CHECK | 
+			  Length;
 	return;
 } /* ReQueueRxBuffer */
 
-
 /*****************************************************************************
  *
  * 	ReceiveIrq - handle a receive IRQ
@@ -2405,6 +2652,7 @@
 struct sk_buff	*pMsg;			/* pointer to message holding frame */
 struct sk_buff	*pNewMsg;		/* pointer to a new message for copying frame */
 int				FrameLength;	/* total length of received frame */
+int				IpFrameLength;
 SK_MBUF			*pRlmtMbuf;		/* ptr to a buffer for giving a frame to rlmt */
 SK_EVPARA		EvPara;			/* an event parameter union */	
 unsigned long	Flags;			/* for spin lock */
@@ -2424,7 +2672,7 @@
 SK_U64			PhysAddr;
 
 rx_start:	
-	/* do forever; exit if RX_CTRL_OWN_BMU found */
+	/* do forever; exit if BMU_OWN found */
 	for ( pRxd = pRxPort->pRxdRingHead ;
 		  pRxPort->RxdRingFree < pAC->RxDescrPerRing ;
 		  pRxd = pRxd->pNextRxd,
@@ -2432,8 +2680,8 @@
 		  pRxPort->RxdRingFree ++) {
 
 		/*
-		 * For a better understanding of this loop 
-		 * Go through every descriptor beginning at the head 
+		 * For a better understanding of this loop
+		 * Go through every descriptor beginning at the head
 		 * Please note: the ring might be completely received so the OWN bit
 		 * set is not a good crirteria to leave that loop.
 		 * Therefore the RingFree counter is used.
@@ -2444,23 +2692,23 @@
 		Control = pRxd->RBControl;
 	
 		/* check if this descriptor is ready */
-		if ((Control & RX_CTRL_OWN_BMU) != 0) {
+		if ((Control & BMU_OWN) != 0) {
 			/* this descriptor is not yet ready */
 			/* This is the usual end of the loop */
 			/* We don't need to start the ring again */
 			FillRxRing(pAC, pRxPort);
 			return;
 		}
+                pAC->DynIrqModInfo.NbrProcessedDescr++;
 
 		/* get length of frame and check it */
-		FrameLength = Control & RX_CTRL_LEN_MASK;
+		FrameLength = Control & BMU_BBC;
 		if (FrameLength > pAC->RxBufSize) {
 			goto rx_failed;
 		}
 
 		/* check for STF and EOF */
-		if ((Control & (RX_CTRL_STF | RX_CTRL_EOF)) !=
-			(RX_CTRL_STF | RX_CTRL_EOF)) {
+		if ((Control & (BMU_STF | BMU_EOF)) != (BMU_STF | BMU_EOF)) {
 			goto rx_failed;
 		}
 
@@ -2497,7 +2745,7 @@
 		if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
 			IsBc = (FrameStat & XMR_FS_BC) != 0;
 			IsMc = (FrameStat & XMR_FS_MC) != 0;
-			IsBadFrame = (FrameStat & 
+			IsBadFrame = (FrameStat &
 				(XMR_FS_ANY_ERR | XMR_FS_2L_VLAN)) != 0;
 		} else {
 			IsBc = (FrameStat & GMR_FS_BC) != 0;
@@ -2514,8 +2762,7 @@
 			pRxPort->RxdRingFree));
 /* DumpMsg(pMsg, "Rx");	*/
 
-		if ((Control & RX_CTRL_STAT_VALID) != RX_CTRL_STAT_VALID ||
-			(IsBadFrame)) {
+		if ((Control & BMU_STAT_VAL) != BMU_STAT_VAL || (IsBadFrame)) {
 #if 0
 			(FrameStat & (XMR_FS_ANY_ERR | XMR_FS_2L_VLAN)) != 0) {
 #endif
@@ -2560,6 +2807,7 @@
 				FrameLength, 0);
 			ReQueueRxBuffer(pAC, pRxPort, pMsg,
 				pRxd->VDataHigh, pRxd->VDataLow);
+
 			pMsg = pNewMsg;
 
 		}
@@ -2582,33 +2830,65 @@
 			skb_put(pMsg, FrameLength);
 			/* hardware checksum */
 			Type = ntohs(*((short*)&pMsg->data[12]));
+
+#ifdef USE_SK_RX_CHECKSUM
 			if (Type == 0x800) {
 				Csum1=le16_to_cpu(pRxd->TcpSums & 0xffff);
 				Csum2=le16_to_cpu((pRxd->TcpSums >> 16) & 0xffff);
-				if ((((Csum1 & 0xfffe) && (Csum2 & 0xfffe)) &&
-					(pAC->GIni.GIChipId == CHIP_ID_GENESIS)) ||
-					(pAC->GIni.GIChipId == CHIP_ID_YUKON)) {
-					Result = SkCsGetReceiveInfo(pAC,
-						&pMsg->data[14], 
-						Csum1, Csum2, pRxPort->PortIndex);
-					if (Result ==
-						SKCS_STATUS_IP_FRAGMENT ||
-						Result ==
-						SKCS_STATUS_IP_CSUM_OK ||
-						Result ==
-						SKCS_STATUS_TCP_CSUM_OK ||
-						Result ==
-						SKCS_STATUS_UDP_CSUM_OK) {
-							pMsg->ip_summed =
-							CHECKSUM_UNNECESSARY;
-					} else {
-						SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
-						SK_DBGCAT_DRV_RX_PROGRESS,
-						("skge: CRC error. Frame dropped!\n"));
-						goto rx_failed;
-					}
-				}/* checksumControl calculation valid */
+				IpFrameLength = (int) ntohs((unsigned short)
+								((unsigned short *) pMsg->data)[8]);
+
+				/*
+				 * Test: If frame is padded, a check is not possible!
+				 * Frame not padded? Length difference must be 14 (0xe)!
+				 */
+				if ((FrameLength - IpFrameLength) != 0xe) {
+				/* Frame padded => TCP offload not possible! */
+					pMsg->ip_summed = CHECKSUM_NONE;
+				} else {
+				/* Frame not padded => TCP offload! */
+					if ((((Csum1 & 0xfffe) && (Csum2 & 0xfffe)) &&
+						(pAC->GIni.GIChipId == CHIP_ID_GENESIS)) ||
+						(pAC->ChipsetType)) {
+						Result = SkCsGetReceiveInfo(pAC,
+							&pMsg->data[14],
+							Csum1, Csum2, pRxPort->PortIndex);
+						if (Result ==
+							SKCS_STATUS_IP_FRAGMENT ||
+							Result ==
+							SKCS_STATUS_IP_CSUM_OK ||
+							Result ==
+							SKCS_STATUS_TCP_CSUM_OK ||
+							Result ==
+							SKCS_STATUS_UDP_CSUM_OK) {
+								pMsg->ip_summed =
+								CHECKSUM_UNNECESSARY;
+						}
+						else if (Result ==
+							SKCS_STATUS_TCP_CSUM_ERROR ||
+							Result ==
+							SKCS_STATUS_UDP_CSUM_ERROR ||
+							Result ==
+							SKCS_STATUS_IP_CSUM_ERROR_UDP ||
+							Result ==
+							SKCS_STATUS_IP_CSUM_ERROR_TCP ||
+							Result ==
+							SKCS_STATUS_IP_CSUM_ERROR ) {
+							/* HW Checksum error */
+							SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+							SK_DBGCAT_DRV_RX_PROGRESS,
+							("skge: CRC error. Frame dropped!\n"));
+							goto rx_failed;
+						} else {
+								pMsg->ip_summed =
+								CHECKSUM_NONE;
+						}
+					}/* checksumControl calculation valid */
+				} /* Frame length check */
 			} /* IP frame */
+#else
+			pMsg->ip_summed = CHECKSUM_NONE;	
+#endif
 		} /* frame > SK_COPY_TRESHOLD */
 		
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV,	1,("V"));
@@ -2622,7 +2902,7 @@
 #if 0
 			IsMc = (FrameStat & XMR_FS_MC)==XMR_FS_MC;
 #endif
-			SK_RLMT_LOOKAHEAD(pAC, PortIndex, 
+			SK_RLMT_LOOKAHEAD(pAC, PortIndex,
 				&pMsg->data[Offset],
 				IsBc, IsMc, &ForRlmt);
 		}
@@ -2647,7 +2927,7 @@
 			}
 			else {
 				/* drop frame */
-				SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 
+				SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 					SK_DBGCAT_DRV_RX_PROGRESS,
 					("D"));
 				DEV_KFREE_SKB(pMsg);
@@ -2656,7 +2936,7 @@
 		} /* if not for rlmt */
 		else {
 			/* packet for rlmt */
-			SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 
+			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_RX_PROGRESS, ("R"));
 			pRlmtMbuf = SkDrvAllocRlmtMbuf(pAC,
 				pAC->IoBase, FrameLength);
@@ -2684,14 +2964,14 @@
 					pAC->CheckQueue = SK_TRUE;
 				}
 
-				SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 
+				SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 					SK_DBGCAT_DRV_RX_PROGRESS,
 					("Q"));
 			}
-			if ((pAC->dev[pRxPort->PortIndex]->flags & 
+			if ((pAC->dev[pRxPort->PortIndex]->flags &
 				(IFF_PROMISC | IFF_ALLMULTI)) != 0 ||
-				(ForRlmt & SK_RLMT_RX_PROTOCOL) == 
-				SK_RLMT_RX_PROTOCOL) { 
+				(ForRlmt & SK_RLMT_RX_PROTOCOL) ==
+				SK_RLMT_RX_PROTOCOL) {
 				pMsg->dev = pAC->dev[pRxPort->PortIndex];
 				pMsg->protocol = eth_type_trans(pMsg,
 					pAC->dev[pRxPort->PortIndex]);
@@ -2708,7 +2988,7 @@
 	/* RXD ring is empty -> fill and restart */
 	FillRxRing(pAC, pRxPort);
 	/* do not start if called from Close */
-	if (pAC->BoardLevel > 0) {
+	if (pAC->BoardLevel > SK_INIT_DATA) {
 		ClearAndStartRx(pAC, PortIndex);
 	}
 	return;
@@ -2750,8 +3030,9 @@
 SK_AC	*pAC,		/* pointer to the adapter context */
 int	PortIndex)	/* index of the receive port (XMAC) */
 {
-	SK_OUT8(pAC->IoBase, RxQueueAddr[PortIndex]+RX_Q_CTRL,
-		RX_Q_CTRL_START | RX_Q_CTRL_CLR_I_EOF);
+	SK_OUT8(pAC->IoBase,
+		RxQueueAddr[PortIndex]+Q_CSR,
+		CSR_START | CSR_IRQ_CL_F);
 } /* ClearAndStartRx */
 
 
@@ -2770,8 +3051,9 @@
 int	PortIndex,	/* index of the transmit port (XMAC) */
 int	Prio)		/* priority or normal queue */
 {
-	SK_OUT8(pAC->IoBase, TxQueueAddr[PortIndex][Prio]+TX_Q_CTRL,
-		TX_Q_CTRL_CLR_I_EOF);
+	SK_OUT8(pAC->IoBase, 
+		TxQueueAddr[PortIndex][Prio]+Q_CSR,
+		CSR_IRQ_CL_F);
 } /* ClearTxIrq */
 
 
@@ -2810,7 +3092,7 @@
 			DEV_KFREE_SKB(pRxd->pMBuf);
 			pRxd->pMBuf = NULL;
 		}
-		pRxd->RBControl &= RX_CTRL_OWN_BMU;
+		pRxd->RBControl &= BMU_OWN;
 		pRxd = pRxd->pNextRxd;
 		pRxPort->RxdRingFree++;
 	} while (pRxd != pRxPort->pRxdRingTail);
@@ -2818,7 +3100,6 @@
 	spin_unlock_irqrestore(&pRxPort->RxDesRingLock, Flags);
 } /* ClearRxRing */
 
-
 /*****************************************************************************
  *
  *	ClearTxRing - remove all buffers from the transmit ring
@@ -2843,107 +3124,13 @@
 	spin_lock_irqsave(&pTxPort->TxDesRingLock, Flags);
 	pTxd = pTxPort->pTxdRingHead;
 	for (i=0; i<pAC->TxDescrPerRing; i++) {
-		pTxd->TBControl &= ~TX_CTRL_OWN_BMU;
+		pTxd->TBControl &= ~BMU_OWN;
 		pTxd = pTxd->pNextTxd;
 	}
 	FreeTxDescriptors(pAC, pTxPort);
 	spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
 } /* ClearTxRing */
 
-
-/*****************************************************************************
- *
- * 	SetQueueSizes - configure the sizes of rx and tx queues
- *
- * Description:
- *	This function assigns the sizes for active and passive port
- *	to the appropriate HWinit structure variables.
- *	The passive port(s) get standard values, all remaining RAM
- *	is given to the active port.
- *	The queue sizes are in kbyte and must be multiple of 8.
- *	The limits for the number of buffers filled into the rx rings
- *	is also set in this routine.
- *
- * Returns:
- *	none
- */
-static void SetQueueSizes(
-SK_AC	*pAC)	/* pointer to the adapter context */
-{
-int	StandbyRam;	/* adapter RAM used for a standby port */
-int	RemainingRam;	/* adapter RAM available for the active port */
-int	RxRam;		/* RAM used for the active port receive queue */
-int	i;		/* loop counter */
-
-if (pAC->RlmtNets == 1) {
-	StandbyRam = SK_RLMT_STANDBY_QRXSIZE + SK_RLMT_STANDBY_QXASIZE +
-		SK_RLMT_STANDBY_QXSSIZE;
-	RemainingRam = pAC->GIni.GIRamSize - 
-		(pAC->GIni.GIMacsFound-1) * StandbyRam;
-	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-		pAC->GIni.GP[i].PRxQSize = SK_RLMT_STANDBY_QRXSIZE;
-		pAC->GIni.GP[i].PXSQSize = SK_RLMT_STANDBY_QXSSIZE;
-		pAC->GIni.GP[i].PXAQSize = SK_RLMT_STANDBY_QXASIZE;
-	}
-	RxRam = (RemainingRam * 8 / 10) & ~7;
-	pAC->GIni.GP[pAC->ActivePort].PRxQSize = RxRam;
-	pAC->GIni.GP[pAC->ActivePort].PXSQSize = 0;
-	pAC->GIni.GP[pAC->ActivePort].PXAQSize =
-		(RemainingRam - RxRam) & ~7;
-	pAC->RxQueueSize = RxRam;
-	pAC->TxSQueueSize = 0;
-	pAC->TxAQueueSize = (RemainingRam - RxRam) & ~7;
-	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
-		("queue sizes settings - rx:%d  txA:%d txS:%d\n",
-		pAC->RxQueueSize,pAC->TxAQueueSize, pAC->TxSQueueSize));
-} else {
-	RemainingRam = pAC->GIni.GIRamSize/pAC->GIni.GIMacsFound;
-	RxRam = (RemainingRam * 8 / 10) & ~7;
-	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-		pAC->GIni.GP[i].PRxQSize = RxRam;
-		pAC->GIni.GP[i].PXSQSize = 0;
-		pAC->GIni.GP[i].PXAQSize = (RemainingRam - RxRam) & ~7;
-	}
-	
-	pAC->RxQueueSize = RxRam;
-	pAC->TxSQueueSize = 0;
-	pAC->TxAQueueSize = (RemainingRam - RxRam) & ~7;
-}
-	for (i=0; i<SK_MAX_MACS; i++) {
-		pAC->RxPort[i].RxFillLimit = pAC->RxDescrPerRing;
-	}
-
-	if (pAC->RlmtNets == 2) {
-		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-			pAC->RxPort[i].RxFillLimit = pAC->RxDescrPerRing - 100;
-		}
-	} else {
-		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-			pAC->RxPort[i].RxFillLimit = pAC->RxDescrPerRing - 100;
-		}
-		/*
-		 * Do not set the Limit to 0, because this could cause
-		 * wrap around with ReQueue'ed buffers (a buffer could
-		 * be requeued in the same position, made accessable to
-		 * the hardware, and the hardware could change its
-		 * contents!
-		 */
-		pAC->RxPort[pAC->ActivePort].RxFillLimit = 1;
-	}
-
-#ifdef DEBUG
-	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
-			("i: %d,  RxQSize: %d,  PXSQsize: %d, PXAQSize: %d\n",
-			i,
-			pAC->GIni.GP[i].PRxQSize,
-			pAC->GIni.GP[i].PXSQSize,
-			pAC->GIni.GP[i].PXAQSize));
-	}
-#endif
-} /* SetQueueSizes */
-
-
 /*****************************************************************************
  *
  * 	SkGeSetMacAddr - Set the hardware MAC address
@@ -3088,49 +3275,52 @@
 		("SkGeChangeMtu starts now...\n"));
 
 	pNet = (DEV_NET*) dev->priv;
-	pAC = pNet->pAC;
+	pAC  = pNet->pAC;
 
 	if ((NewMtu < 68) || (NewMtu > SK_JUMBO_MTU)) {
 		return -EINVAL;
 	}
 
-	if(pAC->BoardLevel != 2) {
+	if(pAC->BoardLevel != SK_INIT_RUN) {
 		return -EINVAL;
 	}
 
 	pNet->Mtu = NewMtu;
 	pOtherNet = (DEV_NET*)pAC->dev[1 - pNet->NetNr]->priv;
-	if ((pOtherNet->Mtu > 1500) && (NewMtu <= 1500) && (pOtherNet->Up==1)) {
+	if ((pOtherNet->Mtu>1500) && (NewMtu<=1500) && (pOtherNet->Up==1)) {
 		return(0);
 	}
 
-	EvPara.Para32[0] = pNet->NetNr;
-	EvPara.Para32[1] = -1;
-
 	pAC->RxBufSize = NewMtu + 32;
 	dev->mtu = NewMtu;
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("New MTU: %d\n", NewMtu));
 
-	/* prevent reconfiguration while changing the MTU */
-
-	/* disable interrupts */
+	/* 
+	** Prevent any reconfiguration while changing the MTU 
+	** by disabling any interrupts 
+	*/
 	SK_OUT32(pAC->IoBase, B0_IMSK, 0);
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
 
-	/* Found more than one port */
-	if ((pAC->GIni.GIMacsFound == 2 ) && 
-		(pAC->RlmtNets == 2)) {
-			/* Stop both ports */
-			EvPara.Para32[0] = 0;
-			SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
-			EvPara.Para32[0] = 1;
-			SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
+	/* 
+	** Notify RLMT that any ports are to be stopped
+	*/
+	EvPara.Para32[0] =  0;
+	EvPara.Para32[1] = -1;
+	if ((pAC->GIni.GIMacsFound == 2 ) && (pAC->RlmtNets == 2)) {
+		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
+		EvPara.Para32[0] =  1;
+		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
 	} else {
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_STOP, EvPara);
 	}
 
+	/*
+	** After calling the SkEventDispatcher(), RLMT is aware about
+	** the stopped ports -> configuration can take place!
+	*/
 	SkEventDispatcher(pAC, pAC->IoBase);
 
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
@@ -3140,140 +3330,132 @@
 
 	}
 
-	/* 
-	 * adjust number of rx buffers allocated
-	 */
+	/*
+	** Depending on the desired MTU size change, a different number of 
+	** RX buffers need to be allocated
+	*/
 	if (NewMtu > 1500) {
-		/* use less rx buffers */
-		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-			/* Found more than one port */
-			if ((pAC->GIni.GIMacsFound == 2 ) && 
-				(pAC->RlmtNets == 2)) {
-					pAC->RxPort[i].RxFillLimit = 
-						pAC->RxDescrPerRing - 100;
-			} else {
-				if (i == pAC->ActivePort)
-					pAC->RxPort[i].RxFillLimit =
-						pAC->RxDescrPerRing - 100;
-				else
-					pAC->RxPort[i].RxFillLimit =
-						pAC->RxDescrPerRing - 10;
-			}
+	    /* 
+	    ** Use less rx buffers 
+	    */
+	    for (i=0; i<pAC->GIni.GIMacsFound; i++) {
+		if ((pAC->GIni.GIMacsFound == 2 ) && (pAC->RlmtNets == 2)) {
+		    pAC->RxPort[i].RxFillLimit =  pAC->RxDescrPerRing -
+						 (pAC->RxDescrPerRing / 4);
+		} else {
+		    if (i == pAC->ActivePort) {
+			pAC->RxPort[i].RxFillLimit = pAC->RxDescrPerRing - 
+						    (pAC->RxDescrPerRing / 4);
+		    } else {
+			pAC->RxPort[i].RxFillLimit = pAC->RxDescrPerRing - 
+						    (pAC->RxDescrPerRing / 10);
+		    }
 		}
-	}
-	else {
-		/* use normal amount of rx buffers */
-		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-			/* Found more than one port */
-			if ((pAC->GIni.GIMacsFound == 2 ) && 
-				(pAC->RlmtNets == 2)) {
-					pAC->RxPort[i].RxFillLimit = 1;
-			} else {
-				if (i == pAC->ActivePort)
-					pAC->RxPort[i].RxFillLimit = 1;
-				else
-					pAC->RxPort[i].RxFillLimit =
-						pAC->RxDescrPerRing - 100;
-			}
+	    }
+	} else {
+	    /* 
+	    ** Use the normal amount of rx buffers 
+	    */
+	    for (i=0; i<pAC->GIni.GIMacsFound; i++) {
+		if ((pAC->GIni.GIMacsFound == 2 ) && (pAC->RlmtNets == 2)) {
+		    pAC->RxPort[i].RxFillLimit = 1;
+		} else {
+		    if (i == pAC->ActivePort) {
+			pAC->RxPort[i].RxFillLimit = 1;
+		    } else {
+			pAC->RxPort[i].RxFillLimit = pAC->RxDescrPerRing -
+						    (pAC->RxDescrPerRing / 4);
+		    }
 		}
+	    }
 	}
-	 
-	SkGeDeInit(pAC, pAC->IoBase); 
+	
+	SkGeDeInit(pAC, pAC->IoBase);
 
-	/* 
-	 * enable/disable hardware support for long frames
-	 */
+	/*
+	** enable/disable hardware support for long frames
+	*/
 	if (NewMtu > 1500) {
-//		pAC->JumboActivated = SK_TRUE; /* is never set back !!! */
+// pAC->JumboActivated = SK_TRUE; /* is never set back !!! */
 		pAC->GIni.GIPortUsage = SK_JUMBO_LINK;
-	}
-	else {
-		if ((pAC->GIni.GIMacsFound == 2 ) && 
-			(pAC->RlmtNets == 2)) {
-			pAC->GIni.GIPortUsage = SK_MUL_LINK;
-		} else {
-			pAC->GIni.GIPortUsage = SK_RED_LINK;
-		}
+	} else {
+	    if ((pAC->GIni.GIMacsFound == 2 ) && (pAC->RlmtNets == 2)) {
+		pAC->GIni.GIPortUsage = SK_MUL_LINK;
+	    } else {
+		pAC->GIni.GIPortUsage = SK_RED_LINK;
+	    }
 	}
 
-	SkGeInit(   pAC, pAC->IoBase, 1);
-	SkI2cInit(  pAC, pAC->IoBase, 1);
-	SkEventInit(pAC, pAC->IoBase, 1);
-	SkPnmiInit( pAC, pAC->IoBase, 1);
-	SkAddrInit( pAC, pAC->IoBase, 1);
-	SkRlmtInit( pAC, pAC->IoBase, 1);
-	SkTimerInit(pAC, pAC->IoBase, 1);
+	SkGeInit(   pAC, pAC->IoBase, SK_INIT_IO);
+	SkI2cInit(  pAC, pAC->IoBase, SK_INIT_IO);
+	SkEventInit(pAC, pAC->IoBase, SK_INIT_IO);
+	SkPnmiInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkAddrInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkTimerInit(pAC, pAC->IoBase, SK_INIT_IO);
 	
 	/*
-	 * tschilling:
-	 * Speed and others are set back to default in level 1 init!
-	 */
+	** tschilling:
+	** Speed and others are set back to default in level 1 init!
+	*/
 	GetConfiguration(pAC);
 	
-	SkGeInit(   pAC, pAC->IoBase, 2);
-	SkI2cInit(  pAC, pAC->IoBase, 2);
-	SkEventInit(pAC, pAC->IoBase, 2);
-	SkPnmiInit( pAC, pAC->IoBase, 2);
-	SkAddrInit( pAC, pAC->IoBase, 2);
-	SkRlmtInit( pAC, pAC->IoBase, 2);
-	SkTimerInit(pAC, pAC->IoBase, 2);
+	SkGeInit(   pAC, pAC->IoBase, SK_INIT_RUN);
+	SkI2cInit(  pAC, pAC->IoBase, SK_INIT_RUN);
+	SkEventInit(pAC, pAC->IoBase, SK_INIT_RUN);
+	SkPnmiInit( pAC, pAC->IoBase, SK_INIT_RUN);
+	SkAddrInit( pAC, pAC->IoBase, SK_INIT_RUN);
+	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_RUN);
+	SkTimerInit(pAC, pAC->IoBase, SK_INIT_RUN);
 
-	/* 
-	 * clear and reinit the rx rings here
-	 */
+	/*
+	** clear and reinit the rx rings here
+	*/
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
 		ReceiveIrq(pAC, &pAC->RxPort[i], SK_TRUE);
 		ClearRxRing(pAC, &pAC->RxPort[i]);
 		FillRxRing(pAC, &pAC->RxPort[i]);
 
-		/* Enable transmit descriptor polling. */
+		/* 
+		** Enable transmit descriptor polling
+		*/
 		SkGePollTxD(pAC, pAC->IoBase, i, SK_TRUE);
 		FillRxRing(pAC, &pAC->RxPort[i]);
 	};
 
 	SkGeYellowLED(pAC, pAC->IoBase, 1);
-
-#ifdef USE_INT_MOD
-	{
-		unsigned long ModBase;
-		ModBase = 53125000 / INTS_PER_SEC;
-		SK_OUT32(pAC->IoBase, B2_IRQM_INI, ModBase);
-		SK_OUT32(pAC->IoBase, B2_IRQM_MSK, IRQ_MOD_MASK);
-		SK_OUT32(pAC->IoBase, B2_IRQM_CTRL, TIM_START);
-	}
-#endif
+	SkDimEnableModerationIfNeeded(pAC);	
+	SkDimDisplayModerationSettings(pAC);
 
 	netif_start_queue(pAC->dev[pNet->PortNr]);
 	for (i=pAC->GIni.GIMacsFound-1; i>=0; i--) {
 		spin_unlock(&pAC->TxPort[i][TX_PRIO_LOW].TxDesRingLock);
 	}
 
-	/* enable Interrupts */
-	SK_OUT32(pAC->IoBase, B0_IMSK, IRQ_MASK);
+	/* 
+	** Enable Interrupts again 
+	*/
+	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 	SK_OUT32(pAC->IoBase, B0_HWE_IMSK, IRQ_HWE_MASK);
 
 	SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_START, EvPara);
 	SkEventDispatcher(pAC, pAC->IoBase);
 
-	/* Found more than one port */
-	if ((pAC->GIni.GIMacsFound == 2 ) && 
-		(pAC->RlmtNets == 2)) {
-			/* Start both ports */
-			EvPara.Para32[0] = pAC->RlmtNets;
-			EvPara.Para32[1] = -1;
-			SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_SET_NETS,
-				EvPara);
-			
+	/* 
+	** Notify RLMT about the changing and restarting one (or more) ports
+	*/
+	if ((pAC->GIni.GIMacsFound == 2 ) && (pAC->RlmtNets == 2)) {
+		EvPara.Para32[0] = pAC->RlmtNets;
+		EvPara.Para32[1] = -1;
+		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_SET_NETS, EvPara);
+		EvPara.Para32[0] = pNet->PortNr;
+		EvPara.Para32[1] = -1;
+		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_START, EvPara);
 			
-			EvPara.Para32[1] = -1;
-			EvPara.Para32[0] = pNet->PortNr;
+		if (pOtherNet->Up) {
+			EvPara.Para32[0] = pOtherNet->PortNr;
 			SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_START, EvPara);
-			
-			if (pOtherNet->Up) {
-				EvPara.Para32[0] = pOtherNet->PortNr;
-				SkEventQueue(pAC, SKGE_RLMT, 
-					SK_RLMT_START, EvPara);
-			}
+		}
 	} else {
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_START, EvPara);
 	}
@@ -3281,7 +3463,20 @@
 	SkEventDispatcher(pAC, pAC->IoBase);
 	spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 	
+	/*
+	** While testing this driver with latest kernel 2.5 (2.5.70), it 
+	** seems as if upper layers have a problem to handle a successful
+	** return value of '0'. If such a zero is returned, the complete 
+	** system hangs for several minutes (!), which is in acceptable.
+	**
+	** Currently it is not clear, what the exact reason for this problem
+	** is. The implemented workaround for 2.5 is to return the desired 
+	** new MTU size if all needed changes for the new MTU size where 
+	** performed. In kernels 2.2 and 2.4, a zero value is returned,
+	** which indicates the successful change of the mtu-size.
+	*/
 	return 0;
+
 } /* SkGeChangeMtu */
 
 
@@ -3375,10 +3570,14 @@
 {
 DEV_NET		*pNet;
 SK_AC		*pAC;
+void		*pMemBuf;
 
 SK_GE_IOCTL	Ioctl;
 unsigned int	Err = 0;
-int		Size;
+int		Size = 0;
+int             Ret = 0;
+unsigned int	Length = 0;
+int		HeaderLength = sizeof(SK_U32) + sizeof(SK_U32);
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeIoctl starts now...\n"));
@@ -3395,7 +3594,7 @@
 	case SK_IOCTL_PRESETMIB:
 		if (!capable(CAP_NET_ADMIN)) return -EPERM;
  	case SK_IOCTL_GETMIB:
-		if(copy_from_user(&pAC->PnmiStruct, Ioctl.pData, 
+		if(copy_from_user(&pAC->PnmiStruct, Ioctl.pData,
 			Ioctl.Len<sizeof(pAC->PnmiStruct)?
 			Ioctl.Len : sizeof(pAC->PnmiStruct))) {
 			return -EFAULT;
@@ -3410,10 +3609,36 @@
 			return -EFAULT;
 		}
 		break;
+	case SK_IOCTL_GEN:
+		if (Ioctl.Len < (sizeof(pAC->PnmiStruct) + HeaderLength)) {
+			Length = Ioctl.Len;
+		} else {
+			Length = sizeof(pAC->PnmiStruct) + HeaderLength;
+		}
+		if (NULL == (pMemBuf = kmalloc(Length, GFP_KERNEL))) {
+			return -EFAULT;
+		}
+		if(copy_from_user(pMemBuf, Ioctl.pData, Length)) {
+			return -EFAULT;
+		}
+		if ((Ret = SkPnmiGenIoctl(pAC, pAC->IoBase, pMemBuf, &Length, 0)) < 0) {
+			return -EFAULT;
+		}
+		if(copy_to_user(Ioctl.pData, pMemBuf, Length) ) {
+			return -EFAULT;
+		}
+		Ioctl.Len = Length;
+		if(copy_to_user(rq->ifr_data, &Ioctl, sizeof(SK_GE_IOCTL))) {
+			return -EFAULT;
+		}
+		kfree(pMemBuf); /* cleanup everything */
+		break;
 	default:
 		Err = -EOPNOTSUPP;
 	}
+
 	return(Err);
+
 } /* SkGeIoctl */
 
 
@@ -3485,12 +3710,19 @@
 SK_AC	*pAC)	/* pointer to the adapter context structure */
 {
 SK_I32	Port;		/* preferred port */
-int	LinkSpeed;	/* Link speed */
-int	AutoNeg;	/* auto negotiation off (0) or on (1) */
-int	DuplexCap;	/* duplex capabilities (0=both, 1=full, 2=half */
-int	MSMode;		/* master / slave mode selection */
 SK_BOOL	AutoSet;
 SK_BOOL DupSet;
+int	LinkSpeed          = SK_LSPEED_AUTO;	/* Link speed */
+int	AutoNeg            = 1;			/* autoneg off (0) or on (1) */
+int	DuplexCap          = 0;			/* 0=both,1=full,2=half */
+int	FlowCtrl           = SK_FLOW_MODE_SYM_OR_REM;	/* FlowControl  */
+int	MSMode             = SK_MS_MODE_AUTO;	/* master/slave mode    */
+
+SK_BOOL IsConTypeDefined   = SK_TRUE;
+SK_BOOL IsLinkSpeedDefined = SK_TRUE;
+SK_BOOL IsFlowCtrlDefined  = SK_TRUE;
+SK_BOOL IsRoleDefined      = SK_TRUE;
+SK_BOOL IsModeDefined      = SK_TRUE;
 /*
  *	The two parameters AutoNeg. and DuplexCap. map to one configuration
  *	parameter. The mapping is described by this table:
@@ -3503,109 +3735,227 @@
  *	-----------------------------------------------------------------
  *	Sense		|   AutoSense	|   AutoSense	|   AutoSense	|
  */
-int	Capabilities[3][3] = 
-		{ {		  -1, SK_LMODE_FULL,     SK_LMODE_HALF}, 
-		  {SK_LMODE_AUTOBOTH, SK_LMODE_AUTOFULL, SK_LMODE_AUTOHALF},
+int	Capabilities[3][3] =
+		{ {                -1, SK_LMODE_FULL     , SK_LMODE_HALF     },
+		  {SK_LMODE_AUTOBOTH , SK_LMODE_AUTOFULL , SK_LMODE_AUTOHALF },
 		  {SK_LMODE_AUTOSENSE, SK_LMODE_AUTOSENSE, SK_LMODE_AUTOSENSE} };
+
 #define DC_BOTH	0
 #define DC_FULL 1
 #define DC_HALF 2
 #define AN_OFF	0
 #define AN_ON	1
 #define AN_SENS	2
+#define M_CurrPort pAC->GIni.GP[Port]
+
+
+	/*
+	** Set the default values first for both ports!
+	*/
+	for (Port = 0; Port < SK_MAX_MACS; Port++) {
+		M_CurrPort.PLinkModeConf = Capabilities[AN_ON][DC_BOTH];
+		M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_SYM_OR_REM;
+		M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
+		M_CurrPort.PLinkSpeed    = SK_LSPEED_AUTO;
+	}
+
+	/*
+	** Check merged parameter ConType. If it has not been used,
+	** verify any other parameter (e.g. AutoNeg) and use default values. 
+	**
+	** Stating both ConType and other lowlevel link parameters is also
+	** possible. If this is the case, the passed ConType-parameter is 
+	** overwritten by the lowlevel link parameter.
+	**
+	** The following settings are used for a merged ConType-parameter:
+	**
+	** ConType   DupCap   AutoNeg   FlowCtrl      Role      Speed
+	** -------   ------   -------   --------   ----------   -----
+	**  Auto      Both      On      SymOrRem      Auto       Auto
+	**  100FD     Full      Off       None      <ignored>    100
+	**  100HD     Half      Off       None      <ignored>    100
+	**  10FD      Full      Off       None      <ignored>    10
+	**  10HD      Half      Off       None      <ignored>    10
+	** 
+	** This ConType parameter is used for all ports of the adapter!
+	*/
+        if ( (ConType != NULL)                && 
+	     (pAC->Index < SK_MAX_CARD_PARAM) &&
+	     (ConType[pAC->Index] != NULL) ) {
+
+			/* Check chipset family */
+			if ((!pAC->ChipsetType) && 
+				(strcmp(ConType[pAC->Index],"Auto")!=0) &&
+				(strcmp(ConType[pAC->Index],"")!=0)) {
+				/* Set the speed parameter back */
+					printk("%s: Illegal value \"%s\" " 
+							"for ConType."
+							" Using Auto.\n", 
+							pAC->dev[0]->name, 
+							ConType[pAC->Index]);
 
-	/* settings for port A */
-	/* settings link speed */
-	LinkSpeed = SK_LSPEED_AUTO; 	/* default: do auto select */
+					sprintf(ConType[pAC->Index], "Auto");	
+			}
+
+				if (strcmp(ConType[pAC->Index],"")==0) {
+			IsConTypeDefined = SK_FALSE; /* No ConType defined */
+				} else if (strcmp(ConType[pAC->Index],"Auto")==0) {
+		    for (Port = 0; Port < SK_MAX_MACS; Port++) {
+			M_CurrPort.PLinkModeConf = Capabilities[AN_ON][DC_BOTH];
+			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_SYM_OR_REM;
+			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
+			M_CurrPort.PLinkSpeed    = SK_LSPEED_AUTO;
+		    }
+                } else if (strcmp(ConType[pAC->Index],"100FD")==0) {
+		    for (Port = 0; Port < SK_MAX_MACS; Port++) {
+			M_CurrPort.PLinkModeConf = Capabilities[AN_OFF][DC_FULL];
+			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_NONE;
+			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
+			M_CurrPort.PLinkSpeed    = SK_LSPEED_100MBPS;
+		    }
+                } else if (strcmp(ConType[pAC->Index],"100HD")==0) {
+		    for (Port = 0; Port < SK_MAX_MACS; Port++) {
+			M_CurrPort.PLinkModeConf = Capabilities[AN_OFF][DC_HALF];
+			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_NONE;
+			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
+			M_CurrPort.PLinkSpeed    = SK_LSPEED_100MBPS;
+		    }
+                } else if (strcmp(ConType[pAC->Index],"10FD")==0) {
+		    for (Port = 0; Port < SK_MAX_MACS; Port++) {
+			M_CurrPort.PLinkModeConf = Capabilities[AN_OFF][DC_FULL];
+			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_NONE;
+			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
+			M_CurrPort.PLinkSpeed    = SK_LSPEED_10MBPS;
+		    }
+                } else if (strcmp(ConType[pAC->Index],"10HD")==0) {
+		    for (Port = 0; Port < SK_MAX_MACS; Port++) {
+			M_CurrPort.PLinkModeConf = Capabilities[AN_OFF][DC_HALF];
+			M_CurrPort.PFlowCtrlMode = SK_FLOW_MODE_NONE;
+			M_CurrPort.PMSMode       = SK_MS_MODE_AUTO;
+			M_CurrPort.PLinkSpeed    = SK_LSPEED_10MBPS;
+		    }
+                } else { 
+		    printk("%s: Illegal value \"%s\" for ConType\n", 
+			pAC->dev[0]->name, ConType[pAC->Index]);
+		    IsConTypeDefined = SK_FALSE; /* Wrong ConType defined */
+		}
+        } else {
+	    IsConTypeDefined = SK_FALSE; /* No ConType defined */
+	}
+
+	/*
+	** Parse any parameter settings for port A:
+	** a) any LinkSpeed stated?
+	*/
 	if (Speed_A != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		Speed_A[pAC->Index] != NULL) {
 		if (strcmp(Speed_A[pAC->Index],"")==0) {
-			LinkSpeed = SK_LSPEED_AUTO;
-		}
-		else if (strcmp(Speed_A[pAC->Index],"Auto")==0) {
-			LinkSpeed = SK_LSPEED_AUTO;
-		}
-		else if (strcmp(Speed_A[pAC->Index],"10")==0) {
-			LinkSpeed = SK_LSPEED_10MBPS;
-		}
-		else if (strcmp(Speed_A[pAC->Index],"100")==0) {
-			LinkSpeed = SK_LSPEED_100MBPS;
-		}
-		else if (strcmp(Speed_A[pAC->Index],"1000")==0) {
-			LinkSpeed = SK_LSPEED_1000MBPS;
+		    IsLinkSpeedDefined = SK_FALSE;
+		} else if (strcmp(Speed_A[pAC->Index],"Auto")==0) {
+		    LinkSpeed = SK_LSPEED_AUTO;
+		} else if (strcmp(Speed_A[pAC->Index],"10")==0) {
+		    LinkSpeed = SK_LSPEED_10MBPS;
+		} else if (strcmp(Speed_A[pAC->Index],"100")==0) {
+		    LinkSpeed = SK_LSPEED_100MBPS;
+		} else if (strcmp(Speed_A[pAC->Index],"1000")==0) {
+		    LinkSpeed = SK_LSPEED_1000MBPS;
+		} else {
+		    printk("%s: Illegal value \"%s\" for Speed_A\n",
+			pAC->dev[0]->name, Speed_A[pAC->Index]);
+		    IsLinkSpeedDefined = SK_FALSE;
 		}
-		else printk("%s: Illegal value for Speed_A\n",
-			pAC->dev[0]->name);
+	} else {
+	    IsLinkSpeedDefined = SK_FALSE;
 	}
 
-	/* Check speed parameter */
-	/* Only copper type adapter and GE V2 cards */
-	if (((pAC->GIni.GIChipId != CHIP_ID_YUKON) ||
-		(pAC->GIni.GICopperType != SK_TRUE)) &&
-		((LinkSpeed != SK_LSPEED_AUTO) && 
+	/* 
+	** Check speed parameter: 
+	**    Only copper type adapter and GE V2 cards 
+	*/
+	if (((!pAC->ChipsetType) || (pAC->GIni.GICopperType != SK_TRUE)) &&
+		((LinkSpeed != SK_LSPEED_AUTO) &&
 		(LinkSpeed != SK_LSPEED_1000MBPS))) {
 		printk("%s: Illegal value for Speed_A. "
 			"Not a copper card or GE V2 card\n    Using "
 			"speed 1000\n", pAC->dev[0]->name);
 		LinkSpeed = SK_LSPEED_1000MBPS;
 	}
-	pAC->GIni.GP[0].PLinkSpeed = LinkSpeed;
+	
+	/*	
+	** Decide whether to set new config value if somethig valid has
+	** been received.
+	*/
+	if (IsLinkSpeedDefined) {
+		pAC->GIni.GP[0].PLinkSpeed = LinkSpeed;
+	} 
 
-	/* Autonegotiation */
+	/* 
+	** b) Any Autonegotiation and DuplexCapabilities set?
+	**    Please note that both belong together...
+	*/
 	AutoNeg = AN_ON; /* tschilling: Default: Autonegotiation on! */
 	AutoSet = SK_FALSE;
 	if (AutoNeg_A != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		AutoNeg_A[pAC->Index] != NULL) {
 		AutoSet = SK_TRUE;
 		if (strcmp(AutoNeg_A[pAC->Index],"")==0) {
-			AutoSet = SK_FALSE;
-		}
-		else if (strcmp(AutoNeg_A[pAC->Index],"On")==0) {
-			AutoNeg = AN_ON;
-		}
-		else if (strcmp(AutoNeg_A[pAC->Index],"Off")==0) {
-			AutoNeg = AN_OFF;
-		}
-		else if (strcmp(AutoNeg_A[pAC->Index],"Sense")==0) {
-			AutoNeg = AN_SENS;
+		    AutoSet = SK_FALSE;
+		} else if (strcmp(AutoNeg_A[pAC->Index],"On")==0) {
+		    AutoNeg = AN_ON;
+		} else if (strcmp(AutoNeg_A[pAC->Index],"Off")==0) {
+		    AutoNeg = AN_OFF;
+		} else if (strcmp(AutoNeg_A[pAC->Index],"Sense")==0) {
+		    AutoNeg = AN_SENS;
+		} else {
+		    printk("%s: Illegal value \"%s\" for AutoNeg_A\n",
+			pAC->dev[0]->name, AutoNeg_A[pAC->Index]);
 		}
-		else printk("%s: Illegal value for AutoNeg_A\n",
-			pAC->dev[0]->name);
 	}
 
 	DuplexCap = DC_BOTH;
-	DupSet = SK_FALSE;
+	DupSet    = SK_FALSE;
 	if (DupCap_A != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		DupCap_A[pAC->Index] != NULL) {
 		DupSet = SK_TRUE;
 		if (strcmp(DupCap_A[pAC->Index],"")==0) {
-			DupSet = SK_FALSE;
-		}
-		else if (strcmp(DupCap_A[pAC->Index],"Both")==0) {
-			DuplexCap = DC_BOTH;
-		}
-		else if (strcmp(DupCap_A[pAC->Index],"Full")==0) {
-			DuplexCap = DC_FULL;
-		}
-		else if (strcmp(DupCap_A[pAC->Index],"Half")==0) {
-			DuplexCap = DC_HALF;
+		    DupSet = SK_FALSE;
+		} else if (strcmp(DupCap_A[pAC->Index],"Both")==0) {
+		    DuplexCap = DC_BOTH;
+		} else if (strcmp(DupCap_A[pAC->Index],"Full")==0) {
+		    DuplexCap = DC_FULL;
+		} else if (strcmp(DupCap_A[pAC->Index],"Half")==0) {
+		    DuplexCap = DC_HALF;
+		} else {
+		    printk("%s: Illegal value \"%s\" for DupCap_A\n",
+			pAC->dev[0]->name, DupCap_A[pAC->Index]);
 		}
-		else printk("%s: Illegal value for DupCap_A\n",
-			pAC->dev[0]->name);
 	}
 	
-	/* check for illegal combinations */
-	if (AutoSet && AutoNeg==AN_SENS && DupSet) {
+	/* 
+	** Check for illegal combinations 
+	*/
+	if ((LinkSpeed = SK_LSPEED_1000MBPS) &&
+		((DuplexCap == SK_LMODE_STAT_AUTOHALF) ||
+		(DuplexCap == SK_LMODE_STAT_HALF)) &&
+		(pAC->ChipsetType)) {
+		    printk("%s: Half Duplex not possible with Gigabit speed!\n"
+					"    Using Full Duplex.\n",
+				pAC->dev[0]->name);
+				DuplexCap = DC_FULL;
+	}
+
+	if ( AutoSet && AutoNeg==AN_SENS && DupSet) {
 		printk("%s, Port A: DuplexCapabilities"
 			" ignored using Sense mode\n", pAC->dev[0]->name);
 	}
+
 	if (AutoSet && AutoNeg==AN_OFF && DupSet && DuplexCap==DC_BOTH){
 		printk("%s, Port A: Illegal combination"
 			" of values AutoNeg. and DuplexCap.\n    Using "
 			"Full Duplex\n", pAC->dev[0]->name);
-
 		DuplexCap = DC_FULL;
 	}
+
 	if (AutoSet && AutoNeg==AN_OFF && !DupSet) {
 		DuplexCap = DC_FULL;
 	}
@@ -3618,151 +3968,194 @@
 		AutoNeg = AN_ON;
 	}
 	
-	/* set the desired mode */
-	pAC->GIni.GP[0].PLinkModeConf =
-		Capabilities[AutoNeg][DuplexCap];
+	/* 
+	** set the desired mode 
+	*/
+	if (AutoSet || DupSet) {
+	    pAC->GIni.GP[0].PLinkModeConf = Capabilities[AutoNeg][DuplexCap];
+	}
 	
-	pAC->GIni.GP[0].PFlowCtrlMode = SK_FLOW_MODE_SYM_OR_REM;
+	/* 
+	** c) Any Flowcontrol-parameter set?
+	*/
 	if (FlowCtrl_A != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		FlowCtrl_A[pAC->Index] != NULL) {
 		if (strcmp(FlowCtrl_A[pAC->Index],"") == 0) {
+		    IsFlowCtrlDefined = SK_FALSE;
+		} else if (strcmp(FlowCtrl_A[pAC->Index],"SymOrRem") == 0) {
+		    FlowCtrl = SK_FLOW_MODE_SYM_OR_REM;
+		} else if (strcmp(FlowCtrl_A[pAC->Index],"Sym")==0) {
+		    FlowCtrl = SK_FLOW_MODE_SYMMETRIC;
+		} else if (strcmp(FlowCtrl_A[pAC->Index],"LocSend")==0) {
+		    FlowCtrl = SK_FLOW_MODE_LOC_SEND;
+		} else if (strcmp(FlowCtrl_A[pAC->Index],"None")==0) {
+		    FlowCtrl = SK_FLOW_MODE_NONE;
+		} else {
+		    printk("%s: Illegal value \"%s\" for FlowCtrl_A\n",
+                        pAC->dev[0]->name, FlowCtrl_A[pAC->Index]);
+		    IsFlowCtrlDefined = SK_FALSE;
 		}
-		else if (strcmp(FlowCtrl_A[pAC->Index],"SymOrRem") == 0) {
-			pAC->GIni.GP[0].PFlowCtrlMode =
-				SK_FLOW_MODE_SYM_OR_REM;
-		}
-		else if (strcmp(FlowCtrl_A[pAC->Index],"Sym")==0) {
-			pAC->GIni.GP[0].PFlowCtrlMode =
-				SK_FLOW_MODE_SYMMETRIC;
-		}
-		else if (strcmp(FlowCtrl_A[pAC->Index],"LocSend")==0) {
-			pAC->GIni.GP[0].PFlowCtrlMode =
-				SK_FLOW_MODE_LOC_SEND;
-		}
-		else if (strcmp(FlowCtrl_A[pAC->Index],"None")==0) {
-			pAC->GIni.GP[0].PFlowCtrlMode =
-				SK_FLOW_MODE_NONE;
-		}
-		else printk("Illegal value for FlowCtrl_A\n");
+	} else {
+	   IsFlowCtrlDefined = SK_FALSE;
 	}
-	if (AutoNeg==AN_OFF && pAC->GIni.GP[0].PFlowCtrlMode!=
-		SK_FLOW_MODE_NONE) {
+
+	if (IsFlowCtrlDefined) {
+	    if ((AutoNeg == AN_OFF) && (FlowCtrl != SK_FLOW_MODE_NONE)) {
 		printk("%s, Port A: FlowControl"
 			" impossible without AutoNegotiation,"
 			" disabled\n", pAC->dev[0]->name);
-		pAC->GIni.GP[0].PFlowCtrlMode = SK_FLOW_MODE_NONE;
+		FlowCtrl = SK_FLOW_MODE_NONE;
+	    }
+	    pAC->GIni.GP[0].PFlowCtrlMode = FlowCtrl;
 	}
 
-	MSMode = SK_MS_MODE_AUTO; /* default: do auto select */
+	/*
+	** d) What is with the RoleParameter?
+	*/
 	if (Role_A != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		Role_A[pAC->Index] != NULL) {
 		if (strcmp(Role_A[pAC->Index],"")==0) {
+		   IsRoleDefined = SK_FALSE;
+		} else if (strcmp(Role_A[pAC->Index],"Auto")==0) {
+		    MSMode = SK_MS_MODE_AUTO;
+		} else if (strcmp(Role_A[pAC->Index],"Master")==0) {
+		    MSMode = SK_MS_MODE_MASTER;
+		} else if (strcmp(Role_A[pAC->Index],"Slave")==0) {
+		    MSMode = SK_MS_MODE_SLAVE;
+		} else {
+		    printk("%s: Illegal value \"%s\" for Role_A\n",
+			pAC->dev[0]->name, Role_A[pAC->Index]);
+		    IsRoleDefined = SK_FALSE;
 		}
-		else if (strcmp(Role_A[pAC->Index],"Auto")==0) {
-			MSMode = SK_MS_MODE_AUTO;
-		}
-		else if (strcmp(Role_A[pAC->Index],"Master")==0) {
-			MSMode = SK_MS_MODE_MASTER;
-		}
-		else if (strcmp(Role_A[pAC->Index],"Slave")==0) {
-			MSMode = SK_MS_MODE_SLAVE;
-		}
-		else printk("%s: Illegal value for Role_A\n",
-			pAC->dev[0]->name);
+	} else {
+	   IsRoleDefined = SK_FALSE;
+	}
+
+	if (IsRoleDefined == SK_TRUE) {
+	    pAC->GIni.GP[0].PMSMode = MSMode;
 	}
-	pAC->GIni.GP[0].PMSMode = MSMode;
 	
+
 	
-	/* settings for port B */
-	/* settings link speed */
-	LinkSpeed = SK_LSPEED_AUTO; 	/* default: do auto select */
+	/* 
+	** Parse any parameter settings for port B:
+	** a) any LinkSpeed stated?
+	*/
+	IsConTypeDefined   = SK_TRUE;
+	IsLinkSpeedDefined = SK_TRUE;
+	IsFlowCtrlDefined  = SK_TRUE;
+	IsModeDefined      = SK_TRUE;
+
 	if (Speed_B != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		Speed_B[pAC->Index] != NULL) {
 		if (strcmp(Speed_B[pAC->Index],"")==0) {
-			LinkSpeed = SK_LSPEED_AUTO;
-		}
-		else if (strcmp(Speed_B[pAC->Index],"Auto")==0) {
-			LinkSpeed = SK_LSPEED_AUTO;
-		}
-		else if (strcmp(Speed_B[pAC->Index],"10")==0) {
-			LinkSpeed = SK_LSPEED_10MBPS;
-		}
-		else if (strcmp(Speed_B[pAC->Index],"100")==0) {
-			LinkSpeed = SK_LSPEED_100MBPS;
-		}
-		else if (strcmp(Speed_B[pAC->Index],"1000")==0) {
-			LinkSpeed = SK_LSPEED_1000MBPS;
+		    IsLinkSpeedDefined = SK_FALSE;
+		} else if (strcmp(Speed_B[pAC->Index],"Auto")==0) {
+		    LinkSpeed = SK_LSPEED_AUTO;
+		} else if (strcmp(Speed_B[pAC->Index],"10")==0) {
+		    LinkSpeed = SK_LSPEED_10MBPS;
+		} else if (strcmp(Speed_B[pAC->Index],"100")==0) {
+		    LinkSpeed = SK_LSPEED_100MBPS;
+		} else if (strcmp(Speed_B[pAC->Index],"1000")==0) {
+		    LinkSpeed = SK_LSPEED_1000MBPS;
+		} else {
+		    printk("%s: Illegal value \"%s\" for Speed_B\n",
+			pAC->dev[1]->name, Speed_B[pAC->Index]);
+		    IsLinkSpeedDefined = SK_FALSE;
 		}
-		else printk("%s: Illegal value for Speed_B\n",
-			pAC->dev[1]->name);
+	} else {
+	    IsLinkSpeedDefined = SK_FALSE;
 	}
 
-	/* Check speed parameter */
-	/* Only copper type adapter and GE V2 cards */
-	if (((pAC->GIni.GIChipId != CHIP_ID_YUKON) ||
-		(pAC->GIni.GICopperType != SK_TRUE)) &&
-		((LinkSpeed != SK_LSPEED_AUTO) && 
+	/* 
+	** Check speed parameter:
+	**    Only copper type adapter and GE V2 cards 
+	*/
+	if (((!pAC->ChipsetType) || (pAC->GIni.GICopperType != SK_TRUE)) &&
+		((LinkSpeed != SK_LSPEED_AUTO) &&
 		(LinkSpeed != SK_LSPEED_1000MBPS))) {
 		printk("%s: Illegal value for Speed_B. "
 			"Not a copper card or GE V2 card\n    Using "
 			"speed 1000\n", pAC->dev[1]->name);
 		LinkSpeed = SK_LSPEED_1000MBPS;
 	}
-	pAC->GIni.GP[1].PLinkSpeed = LinkSpeed;
 
-	/* Auto negotiation */
+	/*      
+	** Decide whether to set new config value if somethig valid has
+	** been received.
+	*/
+        if (IsLinkSpeedDefined) {
+	    pAC->GIni.GP[1].PLinkSpeed = LinkSpeed;
+	}
+
+	/* 
+	** b) Any Autonegotiation and DuplexCapabilities set?
+	**    Please note that both belong together...
+	*/
 	AutoNeg = AN_SENS; /* default: do auto Sense */
 	AutoSet = SK_FALSE;
 	if (AutoNeg_B != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		AutoNeg_B[pAC->Index] != NULL) {
 		AutoSet = SK_TRUE;
 		if (strcmp(AutoNeg_B[pAC->Index],"")==0) {
-			AutoSet = SK_FALSE;
-		}
-		else if (strcmp(AutoNeg_B[pAC->Index],"On")==0) {
-			AutoNeg = AN_ON;
-		}
-		else if (strcmp(AutoNeg_B[pAC->Index],"Off")==0) {
-			AutoNeg = AN_OFF;
-		}
-		else if (strcmp(AutoNeg_B[pAC->Index],"Sense")==0) {
-			AutoNeg = AN_SENS;
+		    AutoSet = SK_FALSE;
+		} else if (strcmp(AutoNeg_B[pAC->Index],"On")==0) {
+		    AutoNeg = AN_ON;
+		} else if (strcmp(AutoNeg_B[pAC->Index],"Off")==0) {
+		    AutoNeg = AN_OFF;
+		} else if (strcmp(AutoNeg_B[pAC->Index],"Sense")==0) {
+		    AutoNeg = AN_SENS;
+		} else {
+		    printk("%s: Illegal value \"%s\" for AutoNeg_B\n",
+			pAC->dev[0]->name, AutoNeg_B[pAC->Index]);
 		}
-		else printk("Illegal value for AutoNeg_B\n");
 	}
 
 	DuplexCap = DC_BOTH;
-	DupSet = SK_FALSE;
+	DupSet    = SK_FALSE;
 	if (DupCap_B != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		DupCap_B[pAC->Index] != NULL) {
 		DupSet = SK_TRUE;
 		if (strcmp(DupCap_B[pAC->Index],"")==0) {
-			DupSet = SK_FALSE;
-		}
-		else if (strcmp(DupCap_B[pAC->Index],"Both")==0) {
-			DuplexCap = DC_BOTH;
-		}
-		else if (strcmp(DupCap_B[pAC->Index],"Full")==0) {
-			DuplexCap = DC_FULL;
-		}
-		else if (strcmp(DupCap_B[pAC->Index],"Half")==0) {
-			DuplexCap = DC_HALF;
+		    DupSet = SK_FALSE;
+		} else if (strcmp(DupCap_B[pAC->Index],"Both")==0) {
+		    DuplexCap = DC_BOTH;
+		} else if (strcmp(DupCap_B[pAC->Index],"Full")==0) {
+		    DuplexCap = DC_FULL;
+		} else if (strcmp(DupCap_B[pAC->Index],"Half")==0) {
+		    DuplexCap = DC_HALF;
+		} else {
+		    printk("%s: Illegal value \"%s\" for DupCap_B\n",
+			pAC->dev[0]->name, DupCap_B[pAC->Index]);
 		}
-		else printk("Illegal value for DupCap_B\n");
 	}
+
 	
-	/* check for illegal combinations */
+	/* 
+	** Check for illegal combinations 
+	*/
+	if ((LinkSpeed = SK_LSPEED_1000MBPS) &&
+		((DuplexCap == SK_LMODE_STAT_AUTOHALF) ||
+		(DuplexCap == SK_LMODE_STAT_HALF)) &&
+		(pAC->ChipsetType)) {
+		    printk("%s: Half Duplex not possible with Gigabit speed!\n"
+					"    Using Full Duplex.\n",
+				pAC->dev[1]->name);
+				DuplexCap = DC_FULL;
+	}
+
 	if (AutoSet && AutoNeg==AN_SENS && DupSet) {
 		printk("%s, Port B: DuplexCapabilities"
 			" ignored using Sense mode\n", pAC->dev[1]->name);
 	}
+
 	if (AutoSet && AutoNeg==AN_OFF && DupSet && DuplexCap==DC_BOTH){
 		printk("%s, Port B: Illegal combination"
 			" of values AutoNeg. and DuplexCap.\n    Using "
 			"Full Duplex\n", pAC->dev[1]->name);
-
 		DuplexCap = DC_FULL;
 	}
+
 	if (AutoSet && AutoNeg==AN_OFF && !DupSet) {
 		DuplexCap = DC_FULL;
 	}
@@ -3775,90 +4168,103 @@
 		AutoNeg = AN_ON;
 	}
 
-	/* set the desired mode */
-	pAC->GIni.GP[1].PLinkModeConf =
-		Capabilities[AutoNeg][DuplexCap];
+	/* 
+	** set the desired mode 
+	*/
+	if (AutoSet || DupSet) {
+	    pAC->GIni.GP[1].PLinkModeConf = Capabilities[AutoNeg][DuplexCap];
+	}
 
-	pAC->GIni.GP[1].PFlowCtrlMode = SK_FLOW_MODE_SYM_OR_REM;
+	/*
+	** c) Any FlowCtrl parameter set?
+	*/
 	if (FlowCtrl_B != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		FlowCtrl_B[pAC->Index] != NULL) {
 		if (strcmp(FlowCtrl_B[pAC->Index],"") == 0) {
+		    IsFlowCtrlDefined = SK_FALSE;
+		} else if (strcmp(FlowCtrl_B[pAC->Index],"SymOrRem") == 0) {
+		    FlowCtrl = SK_FLOW_MODE_SYM_OR_REM;
+		} else if (strcmp(FlowCtrl_B[pAC->Index],"Sym")==0) {
+		    FlowCtrl = SK_FLOW_MODE_SYMMETRIC;
+		} else if (strcmp(FlowCtrl_B[pAC->Index],"LocSend")==0) {
+		    FlowCtrl = SK_FLOW_MODE_LOC_SEND;
+		} else if (strcmp(FlowCtrl_B[pAC->Index],"None")==0) {
+		    FlowCtrl = SK_FLOW_MODE_NONE;
+		} else {
+		    printk("%s: Illegal value \"%s\" for FlowCtrl_B\n",
+			pAC->dev[0]->name, FlowCtrl_B[pAC->Index]);
+		    IsFlowCtrlDefined = SK_FALSE;
 		}
-		else if (strcmp(FlowCtrl_B[pAC->Index],"SymOrRem") == 0) {
-			pAC->GIni.GP[1].PFlowCtrlMode =
-				SK_FLOW_MODE_SYM_OR_REM;
-		}
-		else if (strcmp(FlowCtrl_B[pAC->Index],"Sym")==0) {
-			pAC->GIni.GP[1].PFlowCtrlMode =
-				SK_FLOW_MODE_SYMMETRIC;
-		}
-		else if (strcmp(FlowCtrl_B[pAC->Index],"LocSend")==0) {
-			pAC->GIni.GP[1].PFlowCtrlMode =
-				SK_FLOW_MODE_LOC_SEND;
-		}
-		else if (strcmp(FlowCtrl_B[pAC->Index],"None")==0) {
-			pAC->GIni.GP[1].PFlowCtrlMode =
-				SK_FLOW_MODE_NONE;
-		}
-		else printk("Illegal value for FlowCtrl_B\n");
+	} else {
+		IsFlowCtrlDefined = SK_FALSE;
 	}
-	if (AutoNeg==AN_OFF && pAC->GIni.GP[1].PFlowCtrlMode!=
-		SK_FLOW_MODE_NONE) {
+
+	if (IsFlowCtrlDefined) {
+	    if ((AutoNeg == AN_OFF) && (FlowCtrl != SK_FLOW_MODE_NONE)) {
 		printk("%s, Port B: FlowControl"
 			" impossible without AutoNegotiation,"
 			" disabled\n", pAC->dev[1]->name);
-		pAC->GIni.GP[1].PFlowCtrlMode = SK_FLOW_MODE_NONE;
+		FlowCtrl = SK_FLOW_MODE_NONE;
+	    }
+	    pAC->GIni.GP[1].PFlowCtrlMode = FlowCtrl;
 	}
 
-	MSMode = SK_MS_MODE_AUTO; /* default: do auto select */
+	/*
+	** d) What is the RoleParameter?
+	*/
 	if (Role_B != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		Role_B[pAC->Index] != NULL) {
 		if (strcmp(Role_B[pAC->Index],"")==0) {
+		    IsRoleDefined = SK_FALSE;
+		} else if (strcmp(Role_B[pAC->Index],"Auto")==0) {
+		    MSMode = SK_MS_MODE_AUTO;
+		} else if (strcmp(Role_B[pAC->Index],"Master")==0) {
+		    MSMode = SK_MS_MODE_MASTER;
+		} else if (strcmp(Role_B[pAC->Index],"Slave")==0) {
+		    MSMode = SK_MS_MODE_SLAVE;
+		} else {
+		    printk("%s: Illegal value \"%s\" for Role_B\n",
+			pAC->dev[1]->name, Role_B[pAC->Index]);
+		    IsRoleDefined = SK_FALSE;
 		}
-		else if (strcmp(Role_B[pAC->Index],"Auto")==0) {
-			MSMode = SK_MS_MODE_AUTO;
-		}
-		else if (strcmp(Role_B[pAC->Index],"Master")==0) {
-			MSMode = SK_MS_MODE_MASTER;
-		}
-		else if (strcmp(Role_B[pAC->Index],"Slave")==0) {
-			MSMode = SK_MS_MODE_SLAVE;
-		}
-		else printk("%s: Illegal value for Role_B\n",
-			pAC->dev[1]->name);
+	} else {
+	    IsRoleDefined = SK_FALSE;
+	}
+
+	if (IsRoleDefined) {
+	    pAC->GIni.GP[1].PMSMode = MSMode;
 	}
-	pAC->GIni.GP[1].PMSMode = MSMode;
-	
 	
-	/* settings for both ports */
+	/*
+	** Evaluate settings for both ports
+	*/
 	pAC->ActivePort = 0;
 	if (PrefPort != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		PrefPort[pAC->Index] != NULL) {
 		if (strcmp(PrefPort[pAC->Index],"") == 0) { /* Auto */
-			pAC->ActivePort = 0;
-			pAC->Rlmt.Net[0].Preference = -1; /* auto */
-			pAC->Rlmt.Net[0].PrefPort = 0;
-		}
-		else if (strcmp(PrefPort[pAC->Index],"A") == 0) {
-			/*
-			 * do not set ActivePort here, thus a port
-			 * switch is issued after net up.
-			 */
-			Port = 0;
-			pAC->Rlmt.Net[0].Preference = Port;
-			pAC->Rlmt.Net[0].PrefPort = Port;
-		}
-		else if (strcmp(PrefPort[pAC->Index],"B") == 0) {
-			/*
-			 * do not set ActivePort here, thus a port
-			 * switch is issued after net up.
-			 */
-			Port = 1;
-			pAC->Rlmt.Net[0].Preference = Port;
-			pAC->Rlmt.Net[0].PrefPort = Port;
+		    pAC->ActivePort             =  0;
+		    pAC->Rlmt.Net[0].Preference = -1; /* auto */
+		    pAC->Rlmt.Net[0].PrefPort   =  0;
+		} else if (strcmp(PrefPort[pAC->Index],"A") == 0) {
+		    /*
+		    ** do not set ActivePort here, thus a port
+		    ** switch is issued after net up.
+		    */
+		    Port                        = 0;
+		    pAC->Rlmt.Net[0].Preference = Port;
+		    pAC->Rlmt.Net[0].PrefPort   = Port;
+		} else if (strcmp(PrefPort[pAC->Index],"B") == 0) {
+		    /*
+		    ** do not set ActivePort here, thus a port
+		    ** switch is issued after net up.
+		    */
+		    Port                        = 1;
+		    pAC->Rlmt.Net[0].Preference = Port;
+		    pAC->Rlmt.Net[0].PrefPort   = Port;
+		} else {
+		    printk("%s: Illegal value \"%s\" for PrefPort\n",
+			pAC->dev[0]->name, PrefPort[pAC->Index]);
 		}
-		else printk("%s: Illegal value for PrefPort\n",
-			pAC->dev[0]->name);
 	}
 
 	pAC->RlmtNets = 1;
@@ -3867,33 +4273,126 @@
 		RlmtMode[pAC->Index] != NULL) {
 		if (strcmp(RlmtMode[pAC->Index], "") == 0) {
 			pAC->RlmtMode = 0;
-		}
-		else if (strcmp(RlmtMode[pAC->Index], "CheckLinkState") == 0) {
+		} else if (strcmp(RlmtMode[pAC->Index], "CheckLinkState") == 0) {
 			pAC->RlmtMode = SK_RLMT_CHECK_LINK;
-		}
-		else if (strcmp(RlmtMode[pAC->Index], "CheckLocalPort") == 0) {
+		} else if (strcmp(RlmtMode[pAC->Index], "CheckLocalPort") == 0) {
 			pAC->RlmtMode = SK_RLMT_CHECK_LINK |
-				SK_RLMT_CHECK_LOC_LINK;
-		}
-		else if (strcmp(RlmtMode[pAC->Index], "CheckSeg") == 0) {
-			pAC->RlmtMode = SK_RLMT_CHECK_LINK |
-				SK_RLMT_CHECK_LOC_LINK | 
-				SK_RLMT_CHECK_SEG;
-		}
-		else if ((strcmp(RlmtMode[pAC->Index], "DualNet") == 0) &&
+					SK_RLMT_CHECK_LOC_LINK;
+		} else if (strcmp(RlmtMode[pAC->Index], "CheckSeg") == 0) {
+			pAC->RlmtMode = SK_RLMT_CHECK_LINK     |
+					SK_RLMT_CHECK_LOC_LINK |
+					SK_RLMT_CHECK_SEG;
+		} else if ((strcmp(RlmtMode[pAC->Index], "DualNet") == 0) &&
 			(pAC->GIni.GIMacsFound == 2)) {
-				pAC->RlmtMode = SK_RLMT_CHECK_LINK;
-				pAC->RlmtNets = 2;
-		}
-		else {
-			printk("%s: Illegal value for"
-				" RlmtMode, using default\n", pAC->dev[0]->name);
+			pAC->RlmtMode = SK_RLMT_CHECK_LINK;
+			pAC->RlmtNets = 2;
+		} else {
+		    printk("%s: Illegal value \"%s\" for"
+			" RlmtMode, using default\n", 
+			pAC->dev[0]->name, RlmtMode[pAC->Index]);
 			pAC->RlmtMode = 0;
 		}
-	}
-	else {
+	} else {
 		pAC->RlmtMode = 0;
 	}
+	
+	/*
+	** Check the interrupt moderation parameters
+	*/
+	if (Moderation[pAC->Index] != NULL) {
+	    if (strcmp(Moderation[pAC->Index], "Static") == 0) {
+                pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_STATIC;
+	    } else if (strcmp(Moderation[pAC->Index], "Dynamic") == 0) {
+	        pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_DYNAMIC;
+	    } else {
+	        pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
+	    }
+	} else {
+	    pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
+	}
+
+	if (Stats[pAC->Index] != NULL) {
+	    if (strcmp(Stats[pAC->Index], "Yes") == 0) {
+	        pAC->DynIrqModInfo.DisplayStats = SK_TRUE;
+	    } else {
+		pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
+	    }
+	} else {
+	    pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
+	}
+
+        if (ModerationMask[pAC->Index] != NULL) {
+           if (strcmp(ModerationMask[pAC->Index], "Rx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
+           } else if (strcmp(ModerationMask[pAC->Index], "Tx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_ONLY;
+           } else if (strcmp(ModerationMask[pAC->Index], "Sp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_ONLY;
+           } else if (strcmp(ModerationMask[pAC->Index], "RxSp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
+           } else if (strcmp(ModerationMask[pAC->Index], "SpRx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
+           } else if (strcmp(ModerationMask[pAC->Index], "RxTx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+           } else if (strcmp(ModerationMask[pAC->Index], "TxRx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+           } else if (strcmp(ModerationMask[pAC->Index], "TxSp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
+           } else if (strcmp(ModerationMask[pAC->Index], "SpTx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
+           } else if (strcmp(ModerationMask[pAC->Index], "RxTxSp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "RxSpTx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "TxRxSp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "TxSpRx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "SpTxRx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "SpRxTx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else { /* some rubbish */
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
+           }
+        } else {  /* operator has stated nothing */
+           pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+        }
+
+        if (AutoSizing[pAC->Index] != NULL) {
+           if (strcmp(AutoSizing[pAC->Index], "On") == 0) {
+               pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+           } else {
+               pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+           }
+        } else {  /* operator has stated nothing */
+           pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+        }
+
+        if (IntsPerSec[pAC->Index] != 0) {
+           if ((IntsPerSec[pAC->Index]< 30)&&(IntsPerSec[pAC->Index]> 40000)) {
+              pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
+           } else {
+              pAC->DynIrqModInfo.MaxModIntsPerSec = IntsPerSec[pAC->Index];
+           }
+        } else {
+           pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
+        }
+
+        /*
+	** Evaluate upper and lower moderation threshold
+	*/
+        pAC->DynIrqModInfo.MaxModIntsPerSecUpperLimit =
+            pAC->DynIrqModInfo.MaxModIntsPerSec +
+            (pAC->DynIrqModInfo.MaxModIntsPerSec / 2);
+
+        pAC->DynIrqModInfo.MaxModIntsPerSecLowerLimit =
+            pAC->DynIrqModInfo.MaxModIntsPerSec -
+            (pAC->DynIrqModInfo.MaxModIntsPerSec / 2);
+
+        pAC->DynIrqModInfo.PrevTimeVal = jiffies;  /* initial value */
+
+
 } /* GetConfiguration */
 
 
@@ -3928,8 +4427,44 @@
 	}
 } /* ProductStr */
 
+/*****************************************************************************
+ *
+ *      StartDrvCleanupTimer - Start timer to check for descriptors which
+ *                             might be placed in descriptor ring, but
+ *                             havent been handled up to now
+ *
+ * Description:
+ *      This function requests a HW-timer fo the Yukon card. The actions to
+ *      perform when this timer expires, are located in the SkDrvEvent().
+ *
+ * Returns: N/A
+ */
+static void
+StartDrvCleanupTimer(SK_AC *pAC) {
+    SK_EVPARA    EventParam;   /* Event struct for timer event */
+
+    SK_MEMSET((char *) &EventParam, 0, sizeof(EventParam));
+    EventParam.Para32[0] = SK_DRV_RX_CLEANUP_TIMER;
+    SkTimerStart(pAC, pAC->IoBase, &pAC->DrvCleanupTimer,
+                 SK_DRV_RX_CLEANUP_TIMER_LENGTH,
+                 SKGE_DRV, SK_DRV_TIMER, EventParam);
+}
 
-
+/*****************************************************************************
+ *
+ *      StopDrvCleanupTimer - Stop timer to check for descriptors
+ *
+ * Description:
+ *      This function requests a HW-timer fo the Yukon card. The actions to
+ *      perform when this timer expires, are located in the SkDrvEvent().
+ *
+ * Returns: N/A
+ */
+static void
+StopDrvCleanupTimer(SK_AC *pAC) {
+    SkTimerStop(pAC, pAC->IoBase, &pAC->DrvCleanupTimer);
+    SK_MEMSET((char *) &pAC->DrvCleanupTimer, 0, sizeof(SK_TIMER));
+}
 
 /****************************************************************************/
 /* functions for common modules *********************************************/
@@ -3988,8 +4523,8 @@
  *	Nothing
  */
 void  SkDrvFreeRlmtMbuf(
-SK_AC		*pAC,		/* pointer to adapter context */  
-SK_IOC		IoC,		/* the IO-context */              
+SK_AC		*pAC,		/* pointer to adapter context */
+SK_IOC		IoC,		/* the IO-context */
 SK_MBUF		*pMbuf)		/* size of the requested buffer */
 {
 SK_MBUF		*pFreeMbuf;
@@ -4018,7 +4553,9 @@
  */
 SK_U64 SkOsGetTime(SK_AC *pAC)
 {
-	return jiffies;
+	SK_U64	PrivateJiffies;
+	SkOsGetTimeCurrent(pAC, &PrivateJiffies);
+	return PrivateJiffies;
 } /* SkOsGetTime */
 
 
@@ -4266,6 +4803,9 @@
 			printk("    speed:           unknown\n");
 		}
 
+		/* Mac update */
+		SkAddrMcUpdate(pAC,IoC, FromPort);
+
 		Stat = pAC->GIni.GP[FromPort].PLinkModeStatus;
 		if (Stat == SK_LMODE_STAT_AUTOHALF ||
 			Stat == SK_LMODE_STAT_AUTOFULL) {
@@ -4311,17 +4851,39 @@
 			}
 		}
 
+		/* 
+		   Display dim (dynamic interrupt moderation) 
+		   informations
+		 */
+		if (pAC->DynIrqModInfo.IntModTypeSelect == C_INT_MOD_STATIC)
+			printk("    irq moderation:  static (%d ints/sec)\n",
+					pAC->DynIrqModInfo.MaxModIntsPerSec);
+		else if (pAC->DynIrqModInfo.IntModTypeSelect == C_INT_MOD_DYNAMIC)
+			printk("    irq moderation:  dynamic (%d ints/sec)\n",
+					pAC->DynIrqModInfo.MaxModIntsPerSec);
+		else
+			printk("    irq moderation:  disabled\n");
+
+
 #ifdef SK_ZEROCOPY
-		if (pAC->GIni.GIChipId == CHIP_ID_YUKON)
+		if (pAC->ChipsetType)
+#ifdef USE_SK_TX_CHECKSUM
 			printk("    scatter-gather:  enabled\n");
+#else
+			printk("    tx-checksum:     disabled\n");
+#endif
 		else
 			printk("    scatter-gather:  disabled\n");
-
 #else
 			printk("    scatter-gather:  disabled\n");
 #endif
-		
-		if ((Param.Para32[0] != pAC->ActivePort) && 
+
+#ifndef USE_SK_RX_CHECKSUM
+			printk("    rx-checksum:     disabled\n");
+#endif
+
+	
+		if ((Param.Para32[0] != pAC->ActivePort) &&
 			(pAC->RlmtNets == 1)) {
 			NewPara.Para32[0] = pAC->ActivePort;
 			NewPara.Para32[1] = Param.Para32[0];
@@ -4376,7 +4938,7 @@
 		ClearTxRing(pAC, &pAC->TxPort[FromPort][TX_PRIO_LOW]);
 		ClearTxRing(pAC, &pAC->TxPort[ToPort][TX_PRIO_LOW]);
 		spin_lock_irqsave(
-			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock, 
+			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 		spin_lock_irqsave(
 			&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock, Flags);
@@ -4438,6 +5000,31 @@
 
 			DEV_KFREE_SKB_ANY(pMsg);
 		break;
+	case SK_DRV_TIMER:
+		if (Param.Para32[0] == SK_DRV_MODERATION_TIMER) {
+			/*
+			** expiration of the moderation timer implies that
+			** dynamic moderation is to be applied
+			*/
+			SkDimStartModerationTimer(pAC);
+			SkDimModerate(pAC);
+                        if (pAC->DynIrqModInfo.DisplayStats) {
+			    SkDimDisplayModerationSettings(pAC);
+                        }
+                } else if (Param.Para32[0] == SK_DRV_RX_CLEANUP_TIMER) {
+			/*
+			** check if we need to check for descriptors which
+			** haven't been handled the last millisecs
+			*/
+			StartDrvCleanupTimer(pAC);
+			if (pAC->GIni.GIMacsFound == 2) {
+				ReceiveIrq(pAC, &pAC->RxPort[1], SK_FALSE);
+			}
+			ReceiveIrq(pAC, &pAC->RxPort[0], SK_FALSE);
+		} else {
+			printk("Expiration of unknown timer\n");
+		}
+		break;
 	default:
 		break;
 	}
@@ -4545,7 +5132,7 @@
  *	DumpData - print a data area
  *
  * Description:
- *	This function prints a area of data to the system logfile/to the 
+ *	This function prints a area of data to the system logfile/to the
  *	console.
  *
  * Returns: N/A
@@ -4593,7 +5180,7 @@
  *	DumpLong - print a data area as long values
  *
  * Description:
- *	This function prints a area of data to the system logfile/to the 
+ *	This function prints a area of data to the system logfile/to the
  *	console.
  *
  * Returns: N/A
@@ -4647,9 +5234,8 @@
 
 #endif
 
-/*
- * Local variables:
- * compile-command: "make"
- * End:
- */
-
+/*******************************************************************************
+ *
+ * End of file
+ *
+ ******************************************************************************/
diff -Nru a/drivers/net/sk98lin/skgehwt.c b/drivers/net/sk98lin/skgehwt.c
--- a/drivers/net/sk98lin/skgehwt.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skgehwt.c	Wed Sep  3 22:38:48 2003
@@ -1,17 +1,17 @@
 /******************************************************************************
  *
  * Name:	skgehwt.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.13 $
- * Date:	$Date: 1999/11/22 13:31:12 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.14 $
+ * Date:	$Date: 2003/05/13 18:01:58 $
  * Purpose:	Hardware Timer.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: skgehwt.c,v $
+ *	Revision 1.14  2003/05/13 18:01:58  mkarl
+ *	Editorial changes.
+ *	
  *	Revision 1.13  1999/11/22 13:31:12  cgoos
  *	Changed license header to GPL.
  *	
@@ -76,8 +79,10 @@
 /*
 	Event queue and dispatcher
 */
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/skgehwt.c,v 1.13 1999/11/22 13:31:12 cgoos Exp $" ;
+	"$Header: /usr56/projects/ge/schedule/skgehwt.c,v 1.14 2003/05/13 18:01:58 mkarl Exp $" ;
+#endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
diff -Nru a/drivers/net/sk98lin/skgeinit.c b/drivers/net/sk98lin/skgeinit.c
--- a/drivers/net/sk98lin/skgeinit.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skgeinit.c	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skgeinit.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.82 $
- * Date:	$Date: 2002/12/05 13:40:21 $
- * Purpose:	Contains functions to initialize the GE HW
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.93 $
+ * Date:	$Date: 2003/05/28 15:44:43 $
+ * Purpose:	Contains functions to initialize the adapter
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,66 @@
  * History:
  *
  *	$Log: skgeinit.c,v $
+ *	Revision 1.93  2003/05/28 15:44:43  rschmidt
+ *	Added check for chip Id on WOL WA for chip Rev. A.
+ *	Added setting of GILevel in SkGeDeInit().
+ *	Minor changes to avoid LINT warnings.
+ *	Editorial changes.
+ *	
+ *	Revision 1.92  2003/05/13 17:42:26  mkarl
+ *	Added SK_FAR for PXE.
+ *	Separated code pathes not used for SLIM driver to reduce code size.
+ *	Removed calls to I2C for SLIM driver.
+ *	Removed currently unused function SkGeLoadLnkSyncCnt.
+ *	Editorial changes.
+ *	
+ *	Revision 1.91  2003/05/06 12:21:48  rschmidt
+ *	Added use of pAC->GIni.GIYukon for selection of YUKON branches.
+ *	Added defines around GENESIS resp. YUKON branches to reduce
+ *	code size for PXE.
+ *	Editorial changes.
+ *	
+ *	Revision 1.90  2003/04/28 09:12:20  rschmidt
+ *	Added init for GIValIrqMask (common IRQ mask).
+ *	Disabled HW Error IRQ on Yukon if sensor IRQ is set in SkGeInit1()
+ *	by changing the common mask stored in GIValIrqMask.
+ *	Editorial changes.
+ *	
+ *	Revision 1.89  2003/04/10 14:33:10  rschmidt
+ *	Fixed alignement error of patchable configuration parameter
+ *	in struct OemConfig caused by length of recognition string.
+ *	
+ *	Revision 1.88  2003/04/09 12:59:45  rschmidt
+ *	Added define around initialization of patchable OEM specific
+ *	configuration parameter.
+ *	
+ *	Revision 1.87  2003/04/08 16:46:13  rschmidt
+ *	Added configuration variable for OEMs and initialization for
+ *	GILedBlinkCtrl (LED Blink Control).
+ *	Improved detection for YUKON-Lite Rev. A1.
+ *	Editorial changes.
+ *	
+ *	Revision 1.86  2003/03/31 06:53:13  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.85  2003/02/05 15:30:33  rschmidt
+ *	Corrected setting of GIHstClkFact (Host Clock Factor) and
+ *	GIPollTimerVal (Descr. Poll Timer Init Value) for YUKON.
+ *	Editorial changes.
+ *	
+ *	Revision 1.84  2003/01/28 09:57:25  rschmidt
+ *	Added detection of YUKON-Lite Rev. A0 (stored in GIYukonLite).
+ *	Disabled Rx GMAC FIFO Flush for YUKON-Lite Rev. A0.
+ *	Added support for CLK_RUN (YUKON-Lite).
+ *	Added additional check of PME from D3cold for setting GIVauxAvail.
+ *	Editorial changes.
+ *	
+ *	Revision 1.83  2002/12/17 16:15:41  rschmidt
+ *	Added default setting of PhyType (Copper) for YUKON.
+ *	Added define around check for HW self test results.
+ *	Editorial changes.
+ *	
  *	Revision 1.82  2002/12/05 13:40:21  rschmidt
  *	Added setting of Rx GMAC FIFO Flush Mask register.
  *	Corrected PhyType with new define SK_PHY_MARV_FIBER when
@@ -383,8 +444,10 @@
 
 /* local variables ************************************************************/
 
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#)$Id: skgeinit.c,v 1.82 2002/12/05 13:40:21 rschmidt Exp $ (C) SK ";
+	"@(#) $Id: skgeinit.c,v 1.93 2003/05/28 15:44:43 rschmidt Exp $ (C) Marvell.";
+#endif
 
 struct s_QOffTab {
 	int	RxQOff;		/* Receive Queue Address Offset */
@@ -395,14 +458,27 @@
 	{Q_R1, Q_XS1, Q_XA1}, {Q_R2, Q_XS2, Q_XA2}
 };
 
+struct s_Config {
+	char	ScanString[8];
+	SK_U32	Value;
+};
+
+static struct s_Config OemConfig = {
+	{'O','E','M','_','C','o','n','f'},
+#ifdef SK_OEM_CONFIG
+	OEM_CONFIG_VALUE,
+#else
+	0,
+#endif
+};
 
 /******************************************************************************
  *
  *	SkGePollRxD() - Enable / Disable Descriptor Polling of RxD Ring
  *
  * Description:
- *	Enable or disable the descriptor polling the receive descriptor
- *	ring (RxD) of port 'Port'.
+ *	Enable or disable the descriptor polling of the receive descriptor
+ *	ring (RxD) for port 'Port'.
  *	The new configuration is *not* saved over any SkGeStopPort() and
  *	SkGeInitPort() calls.
  *
@@ -429,8 +505,8 @@
  *	SkGePollTxD() - Enable / Disable Descriptor Polling of TxD Rings
  *
  * Description:
- *	Enable or disable the descriptor polling the transmit descriptor
- *	ring(s) (TxD) of port 'Port'.
+ *	Enable or disable the descriptor polling of the transmit descriptor
+ *	ring(s) (TxD) for port 'Port'.
  *	The new configuration is *not* saved over any SkGeStopPort() and
  *	SkGeInitPort() calls.
  *
@@ -448,7 +524,7 @@
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	DWord = (PollTxD) ? CSR_ENA_POL : CSR_DIS_POL;
+	DWord = (SK_U32)(PollTxD ? CSR_ENA_POL : CSR_DIS_POL);
 
 	if (pPrt->PXSQSize != 0) {
 		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), DWord);
@@ -489,6 +565,7 @@
 }	/* SkGeYellowLED */
 
 
+#if (!defined(SK_SLIM) || defined(GENESIS))
 /******************************************************************************
  *
  *	SkGeXmitLED() - Modify the Operational Mode of a transmission LED.
@@ -544,6 +621,7 @@
 	 * (In this case it has to be added here. But we will see. XXX)
 	 */
 }	/* SkGeXmitLED */
+#endif	/* !SK_SLIM || GENESIS */
 
 
 /******************************************************************************
@@ -564,12 +642,12 @@
  *	1:	configuration error
  */
 static int DoCalcAddr(
-SK_AC		*pAC, 			/* adapter context */
-SK_GEPORT	*pPrt,			/* port index */
-int			QuSize,			/* size of the queue to configure in kB */
-SK_U32		*StartVal,		/* start value for address calculation */
-SK_U32		*QuStartAddr,	/* start addr to calculate */
-SK_U32		*QuEndAddr)		/* end address to calculate */
+SK_AC		*pAC, 				/* adapter context */
+SK_GEPORT	SK_FAR *pPrt,		/* port index */
+int			QuSize,				/* size of the queue to configure in kB */
+SK_U32		SK_FAR *StartVal,	/* start value for address calculation */
+SK_U32		SK_FAR *QuStartAddr,/* start addr to calculate */
+SK_U32		SK_FAR *QuEndAddr)	/* end address to calculate */
 {
 	SK_U32	EndVal;
 	SK_U32	NextStart;
@@ -644,7 +722,6 @@
 		return(2);
 	}
 
-
 	if (DualNet) {
 		/* every port gets the same amount of memory */
 		ActivePortKilobytes = pAC->GIni.GIRamSize / pAC->GIni.GIMacsFound;
@@ -746,14 +823,19 @@
 int		 Port)		/* port index */
 {
 	SK_GEPORT *pPrt;
-	int	UsedMem;	/* total memory used (max. found ports) */
 	int	i;
 	int	Rtv;
 	int	Rtv2;
 	SK_U32	StartAddr;
+#ifndef SK_SLIM
+	int	UsedMem;	/* total memory used (max. found ports) */
+#endif	
 
-	UsedMem = 0;
 	Rtv = 0;
+	
+#ifndef SK_SLIM
+
+	UsedMem = 0;
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
 		pPrt = &pAC->GIni.GP[i];
 
@@ -789,6 +871,7 @@
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E012, SKERR_HWI_E012MSG);
 		return(1);
 	}
+#endif	/* !SK_SLIM */
 
 	/* Now start address calculation */
 	StartAddr = pAC->GIni.GIRamOffs;
@@ -820,6 +903,7 @@
 }	/* SkGeCheckQSize */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkGeInitMacArb() - Initialize the MAC Arbiter
@@ -854,7 +938,7 @@
 	/* Fast Output Enable Mode was intended to use with Rev. B2, but now? */
 
 	/*
-	 * There is not start or enable button to push, therefore
+	 * There is no start or enable button to push, therefore
 	 * the MAC arbiter is configured and enabled now.
 	 */
 }	/* SkGeInitMacArb */
@@ -899,6 +983,7 @@
 		}
 	}
 }	/* SkGeInitPktArb */
+#endif /* GENESIS */
 
 
 /******************************************************************************
@@ -916,6 +1001,7 @@
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
+	SK_U16	Word;
 #ifdef VCPU
 	SK_U32	DWord;
 #endif /* VCPU */
@@ -927,6 +1013,9 @@
 	 *	- enable the FIFO
 	 */
 	
+	Word = (SK_U16)GMF_RX_CTRL_DEF;
+	
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* Configure Rx MAC FIFO */
 		SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_RST_CLR);
@@ -943,20 +1032,29 @@
 			SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_ENA_FLUSH);
 		}
 	}
-	else {
-		/* Configure Rx MAC FIFO */
-		SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8)GMF_RST_CLR);
-		SK_OUT32(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), GMF_RX_CTRL_DEF |
-			GMF_RX_F_FL_ON);		/* enable Rx GMAC FIFO Flush */
+#endif /* GENESIS */
 	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		/* set Rx GMAC FIFO Flush Mask */
 		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_FL_MSK), (SK_U16)RX_FF_FL_DEF_MSK);
 		
-		/* use Rx GMAC FIFO Flush Threshold default value (0x0a == 56 bytes) */
+		/* disable Rx GMAC FIFO Flush for YUKON-Lite Rev. A0 only */
+		if (pAC->GIni.GIYukonLite && pAC->GIni.GIChipId == CHIP_ID_YUKON) {
+
+			Word &= ~GMF_RX_F_FL_ON;
+		}
+		
+		/* Configure Rx MAC FIFO */
+		SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8)GMF_RST_CLR);
+		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), Word);
+		
+		/* set Rx GMAC FIFO Flush Threshold (default: 0x0a -> 56 bytes) */
+		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_FL_THR), RX_GMF_FL_THR_DEF);
 		
 		/* Configure Tx MAC FIFO */
 		SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U8)GMF_RST_CLR);
-		SK_OUT32(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), GMF_TX_CTRL_DEF);
+		SK_OUT16(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U16)GMF_TX_CTRL_DEF);
 		
 #ifdef VCPU
 		SK_IN32(IoC, MR_ADDR(Port, RX_GMF_AF_THR), &DWord);
@@ -966,9 +1064,11 @@
 		/* set Tx GMAC FIFO Almost Empty Threshold */
 /*		SK_OUT32(IoC, MR_ADDR(Port, TX_GMF_AE_THR), 0); */
 	}
-}	/* SkGeInitMacFifo */
+#endif /* YUKON */
 
+}	/* SkGeInitMacFifo */
 
+#ifdef	SK_LNK_SYNC_CNT
 /******************************************************************************
  *
  *	SkGeLoadLnkSyncCnt() - Load the Link Sync Counter and starts counting
@@ -1041,8 +1141,9 @@
 		SK_OUT32(IoC, B0_IMSK, OrgIMsk);
 	}
 }	/* SkGeLoadLnkSyncCnt*/
+#endif	/* SK_LNK_SYNC_CNT */
 
-
+#if defined(SK_DIAG) || defined(SK_CFG_SYNC)
 /******************************************************************************
  *
  *	SkGeCfgSync() - Configure synchronous bandwidth for this port.
@@ -1131,6 +1232,7 @@
 
 	return(0);
 }	/* SkGeCfgSync */
+#endif /* SK_DIAG || SK_CFG_SYNC*/
 
 
 /******************************************************************************
@@ -1196,7 +1298,7 @@
 			 * we NEED Store & Forward of the RAM buffer.
 			 */
 			if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK ||
-				!pAC->GIni.GIGenesis) {
+				pAC->GIni.GIYukon) {
 				/* enable Store & Forward Mode for the Tx Side */
 				SK_OUT8(IoC, RB_ADDR(QuIoOffs, RB_CTRL), RB_ENA_STFWD);
 			}
@@ -1401,7 +1503,7 @@
  * Example:
  *	1) A Link Down event was signaled for a port. Therefore the activity
  *	of this port should be stopped and a hardware reset should be issued
- *	to enable the workaround of XMAC errata #2. But the received frames
+ *	to enable the workaround of XMAC Errata #2. But the received frames
  *	should not be discarded.
  *		...
  *		SkGeStopPort(pAC, IoC, Port, SK_STOP_TX, SK_HARD_RST);
@@ -1468,8 +1570,8 @@
 	SK_U32	DWord;
 	SK_U32	XsCsr;
 	SK_U32	XaCsr;
-	int		i;
 	SK_U64	ToutStart;
+	int		i;
 	int		ToutCnt;
 
 	pPrt = &pAC->GIni.GP[Port];
@@ -1493,8 +1595,8 @@
 			 * Clear packet arbiter timeout to make sure
 			 * this loop will terminate.
 			 */
-			SK_OUT16(IoC, B3_PA_CTRL, (Port == MAC_1) ? PA_CLR_TO_TX1 :
-				PA_CLR_TO_TX2);
+			SK_OUT16(IoC, B3_PA_CTRL, (SK_U16)((Port == MAC_1) ?
+				PA_CLR_TO_TX1 : PA_CLR_TO_TX2));
 
 			/*
 			 * If the transfer stucks at the MAC the STOP command will not
@@ -1574,6 +1676,7 @@
 		SK_OUT8(IoC, RB_ADDR(pPrt->PXsQOff, RB_CTRL), RB_RST_SET);
 		
 		/* Reset Tx MAC FIFO */
+#ifdef GENESIS
 		if (pAC->GIni.GIGenesis) {
 			/* Note: MFF_RST_SET does NOT reset the XMAC ! */
 			SK_OUT8(IoC, MR_ADDR(Port, TX_MFF_CTRL2), MFF_RST_SET);
@@ -1582,10 +1685,14 @@
 			/* Link LED is switched off by the RLMT and the Diag itself */
 			SkGeXmitLED(pAC, IoC, MR_ADDR(Port, TX_LED_INI), SK_LED_DIS);
 		}
-		else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+		if (pAC->GIni.GIYukon) {
 			/* Reset TX MAC FIFO */
 			SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U8)GMF_RST_SET);
 		}
+#endif /* YUKON */
 	}
 
 	if ((Dir & SK_STOP_RX) != 0) {
@@ -1604,9 +1711,9 @@
 			 * Clear packet arbiter timeout to make sure
 			 * this loop will terminate
 			 */
-			SK_OUT16(IoC, B3_PA_CTRL, (Port == MAC_1) ? PA_CLR_TO_RX1 :
-				PA_CLR_TO_RX2);
-			
+			SK_OUT16(IoC, B3_PA_CTRL, (SK_U16)((Port == MAC_1) ?
+				PA_CLR_TO_RX1 : PA_CLR_TO_RX2));
+
 			DWord = TestStopBit(pAC, IoC, pPrt->PRxQOff);
 
 			/* timeout if i==0 (bug fix for #10748) */
@@ -1632,6 +1739,7 @@
 		SK_OUT8(IoC, RB_ADDR(pPrt->PRxQOff, RB_CTRL), RB_RST_SET);
 
 		/* Reset Rx MAC FIFO */
+#ifdef GENESIS
 		if (pAC->GIni.GIGenesis) {
 			
 			SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_RST_SET);
@@ -1639,10 +1747,14 @@
 			/* switch Rx LED off, stop the LED counter */
 			SkGeXmitLED(pAC, IoC, MR_ADDR(Port, RX_LED_INI), SK_LED_DIS);
 		}
-		else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+		if (pAC->GIni.GIYukon) {
 			/* Reset Rx MAC FIFO */
 			SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8)GMF_RST_SET);
 		}
+#endif /* YUKON */
 	}
 }	/* SkGeStopPort */
 
@@ -1679,27 +1791,29 @@
 		pPrt->PPrevRx = 0;
 		pPrt->PPrevFcs = 0;
 		pPrt->PRxLim = SK_DEF_RX_WA_LIM;
-		pPrt->PLinkMode = SK_LMODE_AUTOFULL;
-		pPrt->PLinkSpeedCap = SK_LSPEED_CAP_1000MBPS;
-		pPrt->PLinkSpeed = SK_LSPEED_1000MBPS;
-		pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_UNKNOWN;
-		pPrt->PLinkModeConf = SK_LMODE_AUTOSENSE;
-		pPrt->PFlowCtrlMode = SK_FLOW_MODE_SYM_OR_REM;
-		pPrt->PLinkBroken = SK_TRUE; /* See WA code */
-		pPrt->PLinkCap = (SK_LMODE_CAP_HALF | SK_LMODE_CAP_FULL |
-				SK_LMODE_CAP_AUTOHALF | SK_LMODE_CAP_AUTOFULL);
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_UNKNOWN;
-		pPrt->PFlowCtrlCap = SK_FLOW_MODE_SYM_OR_REM;
-		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
+		pPrt->PLinkMode = (SK_U8)SK_LMODE_AUTOFULL;
+		pPrt->PLinkSpeedCap = (SK_U8)SK_LSPEED_CAP_1000MBPS;
+		pPrt->PLinkSpeed = (SK_U8)SK_LSPEED_1000MBPS;
+		pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_UNKNOWN;
+		pPrt->PLinkModeConf = (SK_U8)SK_LMODE_AUTOSENSE;
+		pPrt->PFlowCtrlMode = (SK_U8)SK_FLOW_MODE_SYM_OR_REM;
+		pPrt->PLinkCap = (SK_U8)(SK_LMODE_CAP_HALF | SK_LMODE_CAP_FULL |
+			SK_LMODE_CAP_AUTOHALF | SK_LMODE_CAP_AUTOFULL);
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
+		pPrt->PFlowCtrlCap = (SK_U8)SK_FLOW_MODE_SYM_OR_REM;
+		pPrt->PFlowCtrlStatus = (SK_U8)SK_FLOW_STAT_NONE;
 		pPrt->PMSCap = 0;
-		pPrt->PMSMode = SK_MS_MODE_AUTO;
-		pPrt->PMSStatus = SK_MS_STAT_UNSET;
+		pPrt->PMSMode = (SK_U8)SK_MS_MODE_AUTO;
+		pPrt->PMSStatus = (SK_U8)SK_MS_STAT_UNSET;
+		pPrt->PLipaAutoNeg = (SK_U8)SK_LIPA_UNKNOWN;
 		pPrt->PAutoNegFail = SK_FALSE;
-		pPrt->PLipaAutoNeg = SK_LIPA_UNKNOWN;
 		pPrt->PHWLinkUp = SK_FALSE;
+		pPrt->PLinkBroken = SK_TRUE; /* See WA code */
 	}
 
 	pAC->GIni.GIPortUsage = SK_RED_LINK;
+	pAC->GIni.GILedBlinkCtrl = (SK_U16)OemConfig.Value;
+	pAC->GIni.GIValIrqMask = IS_ALL_MSK;
 
 }	/* SkGeInit0*/
 
@@ -1766,8 +1880,8 @@
 	SkPciReadCfgDWord(pAC, PCI_BASE_2ND, &Bp2);
 	SkPciReadCfgByte(pAC, PCI_LAT_TIM, &Lat);
 	
-	if (PciCmd != 0 || Cls != 0 || (Bp1 & 0xfffffff0L) != 0 || Bp2 != 1 ||
-		Lat != 0) {
+	if (PciCmd != 0 || Cls != (SK_U8)0 || Lat != (SK_U8)0 ||
+		(Bp1 & 0xfffffff0L) != 0 || Bp2 != 1) {
 		return(1);
 	}
 
@@ -1779,7 +1893,7 @@
 	return(0);
 }	/* SkGePciReset */
 
-#endif	/* SK_PCI_RESET */
+#endif /* SK_PCI_RESET */
 
 /******************************************************************************
  *
@@ -1808,22 +1922,27 @@
 {
 	SK_U8	Byte;
 	SK_U16	Word;
+	SK_U16	CtrlStat;
+	SK_U32	DWord;
 	int	RetVal;
 	int	i;
 
 	RetVal = 0;
 
+	/* save CLK_RUN bits (YUKON-Lite) */
+	SK_IN16(IoC, B0_CTST, &CtrlStat);
+
 #ifdef SK_PCI_RESET
 	(void)SkGePciReset(pAC, IoC);
-#endif	/* SK_PCI_RESET */
+#endif /* SK_PCI_RESET */
 
-	/* Do the SW-reset */
+	/* do the SW-reset */
 	SK_OUT8(IoC, B0_CTST, CS_RST_SET);
 
-	/* Release the SW-reset */
+	/* release the SW-reset */
 	SK_OUT8(IoC, B0_CTST, CS_RST_CLR);
 
-	/* Reset all error bits in the PCI STATUS register */
+	/* reset all error bits in the PCI STATUS register */
 	/*
 	 * Note: PCI Cfg cycles cannot be used, because they are not
 	 *		 available on some platforms after 'boot time'.
@@ -1831,31 +1950,47 @@
 	SK_IN16(IoC, PCI_C(PCI_STATUS), &Word);
 	
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
-	SK_OUT16(IoC, PCI_C(PCI_STATUS), Word | PCI_ERRBITS);
+	SK_OUT16(IoC, PCI_C(PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
-	/* Release Master Reset */
+	/* release Master Reset */
 	SK_OUT8(IoC, B0_CTST, CS_MRST_CLR);
 
-	/* Read Chip Identification Number */
+#ifdef CLK_RUN
+	CtrlStat |= CS_CLK_RUN_ENA;
+#endif /* CLK_RUN */
+
+	/* restore CLK_RUN bits */
+	SK_OUT16(IoC, B0_CTST, (SK_U16)(CtrlStat &
+		(CS_CLK_RUN_HOT | CS_CLK_RUN_RST | CS_CLK_RUN_ENA)));
+	
+	/* read Chip Identification Number */
 	SK_IN8(IoC, B2_CHIP_ID, &Byte);
 	pAC->GIni.GIChipId = Byte;
 	
-	/* Read number of MACs */
+	/* read number of MACs */
 	SK_IN8(IoC, B2_MAC_CFG, &Byte);
 	pAC->GIni.GIMacsFound = (Byte & CFG_SNG_MAC) ? 1 : 2;
 	
-	/* Get Chip Revision Number */
+	/* get Chip Revision Number */
 	pAC->GIni.GIChipRev = (SK_U8)((Byte & CFG_CHIP_R_MSK) >> 4);
 
-	/* Read the adapters external SRAM size */
+	/* get diff. PCI parameters */
+	SK_IN16(IoC, B0_CTST, &CtrlStat);
+	
+	/* read the adapters RAM size */
 	SK_IN8(IoC, B2_E_0, &Byte);
 	
+	pAC->GIni.GIGenesis = SK_FALSE;
+	pAC->GIni.GIYukon = SK_FALSE;
+	pAC->GIni.GIYukonLite = SK_FALSE;
+
+#ifdef GENESIS
 	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
 
 		pAC->GIni.GIGenesis = SK_TRUE;
 
-		if (Byte == 3) {						
+		if (Byte == (SK_U8)3) {						
 			/* special case: 4 x 64k x 36, offset = 0x80000 */
 			pAC->GIni.GIRamSize = 1024;
 			pAC->GIni.GIRamOffs = (SK_U32)512 * 1024;
@@ -1864,19 +1999,72 @@
 			pAC->GIni.GIRamSize = (int)Byte * 512;
 			pAC->GIni.GIRamOffs = 0;
 		}
+		/* all GE adapters work with 53.125 MHz host clock */
+		pAC->GIni.GIHstClkFact = SK_FACT_53;
+		
+		/* set Descr. Poll Timer Init Value to 250 ms */
+		pAC->GIni.GIPollTimerVal =
+			SK_DPOLL_DEF * (SK_U32)pAC->GIni.GIHstClkFact / 100;
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIChipId != CHIP_ID_GENESIS) {
+		
+		pAC->GIni.GIYukon = SK_TRUE;
+		
+		pAC->GIni.GIRamSize = (Byte == (SK_U8)0) ? 128 : (int)Byte * 4;
 		
-		pAC->GIni.GIGenesis = SK_FALSE;
-
-#ifndef VCPU
-		pAC->GIni.GIRamSize = (Byte == 0) ? 128 : (int)Byte * 4;
-#else
-		pAC->GIni.GIRamSize = 128;
-#endif		
 		pAC->GIni.GIRamOffs = 0;
 		
-		pAC->GIni.GIWolOffs = (pAC->GIni.GIChipRev == 0) ? WOL_REG_OFFS : 0;
+		/* WA for chip Rev. A */
+		pAC->GIni.GIWolOffs = (pAC->GIni.GIChipId == CHIP_ID_YUKON &&
+			pAC->GIni.GIChipRev == 0) ? WOL_REG_OFFS : 0;
+		
+		/* get PM Capabilities of PCI config space */
+		SK_IN16(IoC, PCI_C(PCI_PM_CAP_REG), &Word);
+
+		/* check if VAUX is available */
+		if (((CtrlStat & CS_VAUX_AVAIL) != 0) &&
+			/* check also if PME from D3cold is set */
+			((Word & PCI_PME_D3C_SUP) != 0)) {
+			/* set entry in GE init struct */
+			pAC->GIni.GIVauxAvail = SK_TRUE;
+		}
+		
+		if (pAC->GIni.GIChipId == CHIP_ID_YUKON_LITE) {
+			/* this is Rev. A1 */
+			pAC->GIni.GIYukonLite = SK_TRUE;
+		}
+		else {
+			/* save Flash-Address Register */
+			SK_IN32(IoC, B2_FAR, &DWord);
+
+			/* test Flash-Address Register */
+			SK_OUT8(IoC, B2_FAR + 3, 0xff);
+			SK_IN8(IoC, B2_FAR + 3, &Byte);
+
+			if (Byte != 0) {
+				/* this is Rev. A0 */
+				pAC->GIni.GIYukonLite = SK_TRUE;
+
+				/* restore Flash-Address Register */
+				SK_OUT32(IoC, B2_FAR, DWord);
+			}
+		}
+
+		/* read the Interrupt source */
+		SK_IN32(IoC, B0_ISRC, &DWord);
+		
+		if ((DWord & IS_HW_ERR) != 0) {
+			/* read the HW Error Interrupt source */
+			SK_IN32(IoC, B0_HWE_ISRC, &DWord);
+			
+			if ((DWord & IS_IRQ_SENSOR) != 0) {
+				/* disable HW Error IRQ */
+				pAC->GIni.GIValIrqMask &= ~IS_HW_ERR;
+			}
+		}
 		
 		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
 			/* set GMAC Link Control reset */
@@ -1885,90 +2073,100 @@
 			/* clear GMAC Link Control reset */
 			SK_OUT16(IoC, MR_ADDR(i, GMAC_LINK_CTRL), GMLC_RST_CLR);
 		}
+		/* all YU chips work with 78.125 MHz host clock */
+		pAC->GIni.GIHstClkFact = SK_FACT_78;
+		
+		pAC->GIni.GIPollTimerVal = SK_DPOLL_MAX;	/* 215 ms */
 	}
+#endif /* YUKON */
 
-	/* get diff. PCI parameters */
-	SK_IN16(IoC, B0_CTST, &Word);
-
-	/* Check if 64-bit PCI Slot is present */
-	pAC->GIni.GIPciSlot64 = (SK_BOOL)((Word & CS_BUS_SLOT_SZ) != 0);
+	/* check if 64-bit PCI Slot is present */
+	pAC->GIni.GIPciSlot64 = (SK_BOOL)((CtrlStat & CS_BUS_SLOT_SZ) != 0);
 	
-	/* Check if 66 MHz PCI Clock is active */
-	pAC->GIni.GIPciClock66 = (SK_BOOL)((Word & CS_BUS_CLOCK) != 0);
-
-	/* Check if VAUX is available */
-	pAC->GIni.GIVauxAvail = (SK_BOOL)((Word & CS_VAUX_AVAIL) != 0);
+	/* check if 66 MHz PCI Clock is active */
+	pAC->GIni.GIPciClock66 = (SK_BOOL)((CtrlStat & CS_BUS_CLOCK) != 0);
 
-	/* Read PCI HW Revision Id. */
+	/* read PCI HW Revision Id. */
 	SK_IN8(IoC, PCI_C(PCI_REV_ID), &Byte);
 	pAC->GIni.GIPciHwRev = Byte;
 
-	/* All known GE Adapters work with 53.125 MHz host clock */
-	pAC->GIni.GIHstClkFact = SK_FACT_53;
-	pAC->GIni.GIPollTimerVal =
-		SK_DPOLL_DEF * (SK_U32)pAC->GIni.GIHstClkFact / 100;
-	
-	/* Read the PMD type */
+	/* read the PMD type */
 	SK_IN8(IoC, B2_PMD_TYP, &Byte);
 	pAC->GIni.GICopperType = (SK_U8)(Byte == 'T');
 
-	/* Read the PHY type */
+	/* read the PHY type */
 	SK_IN8(IoC, B2_E_1, &Byte);
 
-#ifdef VCPU
-	if (!pAC->GIni.GIGenesis) {
-		pAC->GIni.GICopperType = SK_TRUE;
-		Byte = SK_PHY_MARV_COPPER;		/* this field is not initialized */
-	}
-#endif
-
 	Byte &= 0x0f;	/* the PHY type is stored in the lower nibble */
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
-		pAC->GIni.GP[i].PhyType = Byte;
-		switch (Byte) {
-		case SK_PHY_XMAC:
-			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_XMAC;
-			break;
-		case SK_PHY_BCOM:
-			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_BCOM;
-			pAC->GIni.GP[i].PMSCap =
-				SK_MS_CAP_AUTO | SK_MS_CAP_MASTER | SK_MS_CAP_SLAVE;
-			break;
-		case SK_PHY_MARV_COPPER:
+		
+#ifdef GENESIS
+		if (pAC->GIni.GIGenesis) {
+			switch (Byte) {
+			case SK_PHY_XMAC:
+				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_XMAC;
+				break;
+			case SK_PHY_BCOM:
+				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_BCOM;
+				pAC->GIni.GP[i].PMSCap = (SK_U8)(SK_MS_CAP_AUTO |
+					SK_MS_CAP_MASTER | SK_MS_CAP_SLAVE);
+				break;
+#ifdef OTHER_PHY
+			case SK_PHY_LONE:
+				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_LONE;
+				break;
+			case SK_PHY_NAT:
+				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_NAT;
+				break;
+#endif /* OTHER_PHY */
+			default:
+				/* ERROR: unexpected PHY type detected */
+				RetVal = 5;
+				break;
+			}
+		}
+#endif /* GENESIS */
+	
+#ifdef YUKON
+		if (pAC->GIni.GIYukon) {
+			
+			if (Byte < (SK_U8)SK_PHY_MARV_COPPER) {
+				/* if this field is not initialized */
+				Byte = (SK_U8)SK_PHY_MARV_COPPER;
+				
+				pAC->GIni.GICopperType = SK_TRUE;
+			}
+			
 			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_MARV;
+			
 			if (pAC->GIni.GICopperType) {
-				pAC->GIni.GP[i].PLinkSpeedCap = SK_LSPEED_CAP_AUTO |
+
+				pAC->GIni.GP[i].PLinkSpeedCap = (SK_U8)(SK_LSPEED_CAP_AUTO |
 					SK_LSPEED_CAP_10MBPS | SK_LSPEED_CAP_100MBPS |
-					SK_LSPEED_CAP_1000MBPS;
-				pAC->GIni.GP[i].PLinkSpeed = SK_LSPEED_AUTO;
-				pAC->GIni.GP[i].PMSCap =
-					SK_MS_CAP_AUTO | SK_MS_CAP_MASTER | SK_MS_CAP_SLAVE;
+					SK_LSPEED_CAP_1000MBPS);
+				
+				pAC->GIni.GP[i].PLinkSpeed = (SK_U8)SK_LSPEED_AUTO;
+				
+				pAC->GIni.GP[i].PMSCap = (SK_U8)(SK_MS_CAP_AUTO |
+					SK_MS_CAP_MASTER | SK_MS_CAP_SLAVE);
 			}
 			else {
-				pAC->GIni.GP[i].PhyType = SK_PHY_MARV_FIBER;
+				Byte = (SK_U8)SK_PHY_MARV_FIBER;
 			}
-			break;
-#ifdef OTHER_PHY
-		case SK_PHY_LONE:
-			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_LONE;
-			break;
-		case SK_PHY_NAT:
-			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_NAT;
-			break;
-#endif /* OTHER_PHY */
-		default:
-			/* ERROR: unexpected PHY type detected */
-			RetVal = 5;
-			break;
 		}
+#endif /* YUKON */
+		
+		pAC->GIni.GP[i].PhyType = (int)Byte;
 		
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
-			("PHY type: %d  PHY addr: %04x\n", pAC->GIni.GP[i].PhyType,
+			("PHY type: %d  PHY addr: %04x\n", Byte,
 			pAC->GIni.GP[i].PhyAddr));
 	}
 	
-	/* Get Mac Type & set function pointers dependent on */
+	/* get MAC Type & set function pointers dependent on */
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
+		
 		pAC->GIni.GIMacType = SK_MAC_XMAC;
 
 		pAC->GIni.GIFunc.pFnMacUpdateStats	= SkXmUpdateStats;
@@ -1976,24 +2174,30 @@
 		pAC->GIni.GIFunc.pFnMacResetCounter	= SkXmResetCounter;
 		pAC->GIni.GIFunc.pFnMacOverflow		= SkXmOverflowStatus;
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
+		
 		pAC->GIni.GIMacType = SK_MAC_GMAC;
 
 		pAC->GIni.GIFunc.pFnMacUpdateStats	= SkGmUpdateStats;
 		pAC->GIni.GIFunc.pFnMacStatistic	= SkGmMacStatistic;
 		pAC->GIni.GIFunc.pFnMacResetCounter	= SkGmResetCounter;
 		pAC->GIni.GIFunc.pFnMacOverflow		= SkGmOverflowStatus;
-		
-#ifndef VCPU
+
+#ifdef SPECIAL_HANDLING
 		if (pAC->GIni.GIChipId == CHIP_ID_YUKON) {
 			/* check HW self test result */
 			SK_IN8(IoC, B2_E_3, &Byte);
-			if ((Byte & B2_E3_RES_MASK) != 0) {
+			if (Byte & B2_E3_RES_MASK) {
 				RetVal = 6;
 			}
 		}
 #endif
 	}
+#endif /* YUKON */
+	
 	return(RetVal);
 }	/* SkGeInit1 */
 
@@ -2017,7 +2221,9 @@
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC)		/* IO context */
 {
+#ifdef GENESIS
 	SK_U32	DWord;
+#endif /* GENESIS */
 	int		i;
 
 	/* start the Descriptor Poll Timer */
@@ -2031,6 +2237,7 @@
 		SK_OUT8(IoC, B28_DPT_CTRL, DPT_START);
 	}
 
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* start the Blink Source Counter */
 		DWord = SK_BLK_DUR * (SK_U32)pAC->GIni.GIHstClkFact / 100;
@@ -2046,10 +2253,14 @@
 
 		SkGeInitPktArb(pAC, IoC);
 	}
-	else {
-		/* Start Time Stamp Timer */
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
+		/* start Time Stamp Timer */
 		SK_OUT8(IoC, GMAC_TI_ST_CTRL, (SK_U8)GMT_ST_START);
 	}
+#endif /* YUKON */
 
 	/* enable the Tx Arbiters */
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
@@ -2121,17 +2332,17 @@
 			break;
 		}
 
-		/* Check if the adapter seems to be accessible */
-		SK_OUT32(IoC, B2_IRQM_INI, 0x11335577L);
+		/* check if the adapter seems to be accessible */
+		SK_OUT32(IoC, B2_IRQM_INI, SK_TEST_VAL);
 		SK_IN32(IoC, B2_IRQM_INI, &DWord);
 		SK_OUT32(IoC, B2_IRQM_INI, 0L);
 		
-		if (DWord != 0x11335577L) {
+		if (DWord != SK_TEST_VAL) {
 			RetVal = 2;
 			break;
 		}
 
-		/* Check if the number of GIMacsFound matches SK_MAX_MACS */
+		/* check if the number of GIMacsFound matches SK_MAX_MACS */
 		if (pAC->GIni.GIMacsFound > SK_MAX_MACS) {
 			RetVal = 1;
 			break;
@@ -2168,7 +2379,7 @@
 
 /******************************************************************************
  *
- *	SkGeDeInit() - Deinitialize the adapter.
+ *	SkGeDeInit() - Deinitialize the adapter
  *
  * Description:
  *	All ports of the adapter will be stopped if not already done.
@@ -2184,12 +2395,12 @@
 	int	i;
 	SK_U16	Word;
 
-#ifndef VCPU
-	/* Ensure I2C is ready */
+#if (!defined(SK_SLIM) && !defined(VCPU))
+	/* ensure I2C is ready */
 	SkI2cWaitIrq(pAC, IoC);
-#endif
+#endif	
 
-	/* Stop all current transfer activity */
+	/* stop all current transfer activity */
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
 		if (pAC->GIni.GP[i].PState != SK_PRT_STOP &&
 			pAC->GIni.GP[i].PState != SK_PRT_RESET) {
@@ -2206,11 +2417,13 @@
 	SK_IN16(IoC, PCI_C(PCI_STATUS), &Word);
 	
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
-	SK_OUT16(IoC, PCI_C(PCI_STATUS), Word | PCI_ERRBITS);
+	SK_OUT16(IoC, PCI_C(PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
-	/* Do the reset, all LEDs are switched off now */
+	/* do the reset, all LEDs are switched off now */
 	SK_OUT8(IoC, B0_CTST, CS_RST_SET);
+	
+	pAC->GIni.GILevel = SK_INIT_DATA;
 }	/* SkGeDeInit */
 
 
@@ -2261,10 +2474,11 @@
 		return(2);
 	}
 
-	/* Configuration ok, initialize the Port now */
+	/* configuration ok, initialize the Port now */
 
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
-		/* Initialize Rx, Tx and Link LED */
+		/* initialize Rx, Tx and Link LED */
 		/*
 		 * If 1000BT Phy needs LED initialization than swap
 		 * LED and XMAC initialization order
@@ -2275,12 +2489,16 @@
 		
 		SkXmInitMac(pAC, IoC, Port);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 
 		SkGmInitMac(pAC, IoC, Port);
 	}
+#endif /* YUKON */
 	
-	/* Do NOT initialize the Link Sync Counter */
+	/* do NOT initialize the Link Sync Counter */
 
 	SkGeInitMacFifo(pAC, IoC, Port);
 	
@@ -2293,7 +2511,7 @@
 	
 	SkGeInitBmu(pAC, IoC, Port);
 
-	/* Mark port as initialized */
+	/* mark port as initialized */
 	pPrt->PState = SK_PRT_INIT;
 
 	return(0);
diff -Nru a/drivers/net/sk98lin/skgemib.c b/drivers/net/sk98lin/skgemib.c
--- a/drivers/net/sk98lin/skgemib.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skgemib.c	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgemib.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.7 $
- * Date:	$Date: 2002/12/16 09:04:34 $
+ * Version:	$Revision: 1.9 $
+ * Date:	$Date: 2003/05/23 12:55:20 $
  * Purpose:	Private Network Management Interface Management Database
  *
  ****************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,12 @@
  * History:
  *
  *	$Log: skgemib.c,v $
+ *	Revision 1.9  2003/05/23 12:55:20  tschilli
+ *	OID_SKGE_BOARDLEVEL added.
+ *	
+ *	Revision 1.8  2003/03/27 11:19:15  tschilli
+ *	Copyright messages changed.
+ *	
  *	Revision 1.7  2002/12/16 09:04:34  tschilli
  *	Code for VCT handling added.
  *	
@@ -100,8 +107,13 @@
 PNMI_STATIC int PowerManagement(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
 	char *pBuf, unsigned int *pLen, SK_U32 Instance,
 	unsigned int TableIndex, SK_U32 NetIndex);
-#endif
+#endif /* SK_POWER_MGMT */
 
+#ifdef SK_DIAG_SUPPORT
+PNMI_STATIC int DiagActions(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+#endif /* SK_DIAG_SUPPORT */
 
 
 /* defines *******************************************************************/
@@ -267,6 +279,13 @@
 		0,
 		SK_PNMI_RW, PowerManagement, 0},
 #endif /* SK_POWER_MGMT */
+#ifdef SK_DIAG_SUPPORT
+	{OID_SKGE_DIAG_MODE,
+		0,
+		0,
+		0,
+		SK_PNMI_RW, DiagActions, 0},
+#endif /* SK_DIAG_SUPPORT */
 	{OID_SKGE_MDB_VERSION,
 		1,
 		0,
@@ -1052,5 +1071,10 @@
 		0,
 		0,
 		SK_PNMI_RO, Vct, 0},
+	{OID_SKGE_BOARDLEVEL,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, General, 0},
 };
 
diff -Nru a/drivers/net/sk98lin/skgepnmi.c b/drivers/net/sk98lin/skgepnmi.c
--- a/drivers/net/sk98lin/skgepnmi.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skgepnmi.c	Wed Sep  3 22:38:48 2003
@@ -2,8 +2,8 @@
  *
  * Name:	skgepnmi.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.102 $
- * Date:	$Date: 2002/12/16 14:03:24 $
+ * Version:	$Revision: 1.109 $
+ * Date:	$Date: 2003/07/17 14:15:24 $
  * Purpose:	Private Network Management Interface
  *
  ****************************************************************************/
@@ -11,6 +11,7 @@
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,42 @@
  * History:
  *
  *	$Log: skgepnmi.c,v $
+ *	Revision 1.109  2003/07/17 14:15:24  tschilli
+ *	Bug in SkPnmiGenIoctl() fixed.
+ *	
+ *	Revision 1.108  2003/05/27 07:10:11  tschilli
+ *	Bug in SkPnmiGenIoctl() fixed.
+ *	
+ *	Revision 1.107  2003/05/23 13:01:10  tschilli
+ *	Code for DIAG support added (#define SK_DIAG_SUPPORT).
+ *	Code for generic PNMI IOCTL support added. The new function
+ *	SkPnmiGenIoctl() is used for this purpose.
+ *	Handling of OID_SKGE_BOARDLEVEL added.
+ *	Incorrect buffer size handling of OID_SKGE_MTU during GET action fixed.
+ *	Return code handling in PowerManagement() fixed.
+ *	Editorial changes.
+ *  
+ *	Revision 1.106  2003/04/10 14:47:31  rschmidt
+ *	Fixed handling for OID_GEN_RCV_OK and OID_GEN_XMIT_OK for YUKON's GMAC
+ *	in GetPhysStatVal().
+ *	Replaced macro PHY_READ() with function call SkXmPhyRead().
+ *	Made optimisations for readability and code size.
+ *	Editorial changes.
+ *	
+ *	Revision 1.105  2003/04/09 12:51:32  rschmidt
+ *	Fixed XMAC only handling for some events in SkPnmiEvent().
+ *	Fixed return value for OID_GEN_RCV_OK (SK_PNMI_HRX) in GetPhysStatVal().
+ *	Editorial changes.
+ *	
+ *	Revision 1.104  2003/03/27 11:18:21  tschilli
+ *	BRK statements from DEBUG code removed.
+ *	OID_GEN_XMIT_OK and OID_GEN_RCV_OK work with Yukon now.
+ *	Copyright messages changed.
+ *	
+ *	Revision 1.103  2002/12/20 09:57:13  tschilli
+ *	SK_PNMI_EVT_VCT_RESET event code changed.
+ *	Unused variable from Vct() removed.
+ *	
  *	Revision 1.102  2002/12/16 14:03:24  tschilli
  *	VCT code in Vct() changed.
  *	
@@ -84,7 +121,7 @@
  *	- Extended SIRQ event handler for both mac types.
  *	- Fixed rx short counter bug (#10620)
  *	- Added handler for oids SKGE_SPEED_MODE & SKGE_SPEED_STATUS.
- *	- Extendet GetPhysStatVal() for GMAC.
+ *	- Extended GetPhysStatVal() for GMAC.
  *	- Editorial changes.
  *	
  *	Revision 1.90  2002/05/22 08:56:25  rwahl
@@ -172,7 +209,7 @@
  *	Added state check to PHY_READ call (hanged if called during startup).
  *	
  *	Revision 1.67  1999/09/22 09:53:20  rwahl
- *	- Read Broadcom register for updating fcs error counter (1000Base-T).
+ *	- Read Broadcom register for updating FCS error counter (1000Base-T).
  *
  *	Revision 1.66  1999/08/26 13:47:56  rwahl
  *	Added SK_DRIVER_SENDEVENT when queueing RLMT_CHANGE_THRES trap.
@@ -432,9 +469,10 @@
  ****************************************************************************/
 
 
+#ifndef _lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skgepnmi.c,v 1.102 2002/12/16 14:03:24 tschilli Exp $"
-	" (C) SysKonnect.";
+	"@(#) $Id: skgepnmi.c,v 1.109 2003/07/17 14:15:24 tschilli Exp $ (C) Marvell.";
+#endif /* !_lint */
 
 #include "h/skdrv1st.h"
 #include "h/sktypes.h"
@@ -472,11 +510,13 @@
 	unsigned int *pLen, SK_U32 Instance, SK_U32 NetIndex);
 int SkPnmiGetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
-int SkPnmiPreSetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf, 
+int SkPnmiPreSetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
-int SkPnmiSetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf, 
+int SkPnmiSetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
 int SkPnmiEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event, SK_EVPARA Param);
+int SkPnmiGenIoctl(SK_AC *pAC, SK_IOC IoC, void * pBuf,
+	unsigned int * pLen, SK_U32 NetIndex);
 
 
 /*
@@ -530,7 +570,7 @@
 /*
  * Overflow status register bit table and corresponding counter
  * dependent on MAC type - the number relates to the size of overflow
- * mask returned by the pFnMacOverflow function 
+ * mask returned by the pFnMacOverflow function
  */
 PNMI_STATIC const SK_U16 StatOvrflwBit[][SK_PNMI_MAC_TYPES] = {
 /* Bit0  */	{ SK_PNMI_HTX, 				SK_PNMI_HTX_UNICAST},
@@ -694,7 +734,7 @@
 	/* SK_PNMI_HRX_FRAMING */
 	{{XM_RXF_FRA_ERR, SK_TRUE}, {0, SK_FALSE}},
 	/* SK_PNMI_HRX_UNDERSIZE */
-	{{0, SK_FALSE},{GM_RXF_SHT, SK_TRUE}},
+	{{0, SK_FALSE}, {GM_RXF_SHT, SK_TRUE}},
 	/* SK_PNMI_HRX_OVERFLOW */
 	{{XM_RXE_FIFO_OV, SK_TRUE}, {GM_RXE_FIFO_OV, SK_TRUE}},
 	/* SK_PNMI_HRX_JABBER */
@@ -768,7 +808,6 @@
 	SK_U16		Val16;		/* Multiple purpose 16 bit variable */
 	SK_U8		Val8;		/* Mulitple purpose 8 bit variable */
 	SK_EVPARA	EventParam;	/* Event struct for timer event */
-	SK_GEPORT	*pPrt;
 	SK_PNMI_VCT	*pVctBackupData;
 
 
@@ -797,7 +836,6 @@
 					   ("CounterOffset struct size (%d) differs from"
 						"SK_PNMI_MAX_IDX (%d)\n",
 						SK_PNMI_CNT_NO, SK_PNMI_MAX_IDX));
-			BRK;
 		}
 
 		if (SK_PNMI_MAX_IDX !=
@@ -808,10 +846,9 @@
 			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_INIT | SK_DBGCAT_FATAL,
 					   ("StatAddr table size (%d) differs from "
 						"SK_PNMI_MAX_IDX (%d)\n",
-						(sizeof(StatAddr) / 
+						(sizeof(StatAddr) /
 						 (sizeof(SK_PNMI_STATADDR) * SK_PNMI_MAC_TYPES)),
 						 SK_PNMI_MAX_IDX));
-			BRK;
 		}
 #endif /* SK_PNMI_CHECK */
 		break;
@@ -829,8 +866,7 @@
 		
 		/* Initialize DSP variables for Vct() to 0xff => Never written! */		
 		for (PortIndex = 0; PortIndex < PortMax; PortIndex ++) {
-			pPrt = &pAC->GIni.GP[PortIndex];
-			pPrt->PCableLen =0xff;
+			pAC->GIni.GP[PortIndex].PCableLen = 0xff;
 			pVctBackupData = &pAC->Pnmi.VctBackup[PortIndex];
 			pVctBackupData->PCableLen = 0xff;
 		}
@@ -958,14 +994,14 @@
 		default:
 			pAC->Pnmi.Connector = 1;
 			break;
-		}		
+		}
 		break;
-		
+
 	case SK_INIT_RUN:
 		/*
 		 * Start timer for RLMT change counter
 		 */
-		SK_MEMSET((char *) &EventParam, 0, sizeof(EventParam));
+		SK_MEMSET((char *)&EventParam, 0, sizeof(EventParam));
 		SkTimerStart(pAC, IoC, &pAC->Pnmi.RlmtChangeEstimate.EstTimer,
 			28125000, SKGE_PNMI, SK_PNMI_EVT_CHG_EST_TIMER,
 			EventParam);
@@ -994,17 +1030,17 @@
  *	                         the data.
  *	SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 int SkPnmiGetVar(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 SK_U32 Id,		/* Object ID that is to be processed */
-void *pBuf,		/* Buffer to which to mgmt data will be retrieved */
+void *pBuf,		/* Buffer to which the management data will be copied */
 unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
 		("PNMI: SkPnmiGetVar: Called, Id=0x%x, BufLen=%d, Instance=%d, NetIndex=%d\n",
@@ -1022,8 +1058,8 @@
  *	Calls a general sub-function for all this stuff. The preset does
  *	the same as a set, but returns just before finally setting the
  *	new value. This is usefull to check if a set might be successfull.
- *	If as instance a -1 is passed, an array of values is supposed and
- *	all instance of the OID will be set.
+ *	If the instance -1 is passed, an array of values is supposed and
+ *	all instances of the OID will be set.
  *
  * Returns:
  *	SK_PNMI_ERR_OK           The request was successfully performed.
@@ -1036,17 +1072,17 @@
  *	SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.
  *	SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown.
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 int SkPnmiPreSetVar(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 SK_U32 Id,		/* Object ID that is to be processed */
-void *pBuf,		/* Buffer which stores the mgmt data to be set */
-unsigned int *pLen,	/* Total length of mgmt data */
+void *pBuf,		/* Buffer to which the management data will be copied */
+unsigned int *pLen,	/* Total length of management data */
 SK_U32 Instance,	/* Instance (1..n) that is to be set or -1 */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
 		("PNMI: SkPnmiPreSetVar: Called, Id=0x%x, BufLen=%d, Instance=%d, NetIndex=%d\n",
@@ -1065,8 +1101,8 @@
  *	Calls a general sub-function for all this stuff. The preset does
  *	the same as a set, but returns just before finally setting the
  *	new value. This is usefull to check if a set might be successfull.
- *	If as instance a -1 is passed, an array of values is supposed and
- *	all instance of the OID will be set.
+ *	If the instance -1 is passed, an array of values is supposed and
+ *	all instances of the OID will be set.
  *
  * Returns:
  *	SK_PNMI_ERR_OK           The request was successfully performed.
@@ -1079,17 +1115,17 @@
  *	SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.
  *	SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown.
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 int SkPnmiSetVar(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 SK_U32 Id,		/* Object ID that is to be processed */
-void *pBuf,		/* Buffer which stores the mgmt data to be set */
-unsigned int *pLen,	/* Total length of mgmt data */
+void *pBuf,		/* Buffer to which the management data will be copied */
+unsigned int *pLen,	/* Total length of management data */
 SK_U32 Instance,	/* Instance (1..n) that is to be set or -1 */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
 		("PNMI: SkPnmiSetVar: Called, Id=0x%x, BufLen=%d, Instance=%d, NetIndex=%d\n",
@@ -1116,14 +1152,14 @@
  *	SK_PNMI_ERR_GENERAL      A general severe internal error occured
  *	SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to take
  *	                         the data.
- *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist 
+ *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist
  */
 int SkPnmiGetStruct(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-void *pBuf,		/* Buffer which will store the retrieved data */
+void *pBuf,		/* Buffer to which the management data will be copied. */
 unsigned int *pLen,	/* Length of buffer */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	int		Ret;
 	unsigned int	TableIndex;
@@ -1301,13 +1337,13 @@
 SK_IOC IoC,		/* IO context handle */
 void *pBuf,		/* Buffer which contains the data to be set */
 unsigned int *pLen,	/* Length of buffer */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
 		("PNMI: SkPnmiPreSetStruct: Called, BufLen=%d, NetIndex=%d\n",
 			*pLen, NetIndex));
 
-	return (PnmiStruct(pAC, IoC, SK_PNMI_PRESET, (char *)pBuf, 
+	return (PnmiStruct(pAC, IoC, SK_PNMI_PRESET, (char *)pBuf,
     					pLen, NetIndex));
 }
 
@@ -1339,13 +1375,13 @@
 SK_IOC IoC,		/* IO context handle */
 void *pBuf,		/* Buffer which contains the data to be set */
 unsigned int *pLen,	/* Length of buffer */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
 		("PNMI: SkPnmiSetStruct: Called, BufLen=%d, NetIndex=%d\n",
 			*pLen, NetIndex));
 
-	return (PnmiStruct(pAC, IoC, SK_PNMI_SET, (char *)pBuf, 
+	return (PnmiStruct(pAC, IoC, SK_PNMI_SET, (char *)pBuf,
     					pLen, NetIndex));
 }
 
@@ -1392,9 +1428,9 @@
  *	                              is now an active port. PNMI will now
  *	                              add the statistic data of this port to
  *	                              the virtual port.
- *	SK_PNMI_EVT_RLMT_SET_NETS     Notifies PNMI about the net mode. The first Parameter
+ *	SK_PNMI_EVT_RLMT_SET_NETS     Notifies PNMI about the net mode. The first parameter
  *	                              contains the number of nets. 1 means single net, 2 means
- *	                              dual net. The second Parameter is -1
+ *	                              dual net. The second parameter is -1
  *
  * Returns:
  *	Always 0
@@ -1406,7 +1442,7 @@
 SK_EVPARA Param)	/* Event dependent parameter */
 {
 	unsigned int	PhysPortIndex;
-	unsigned int	MaxNetNumber;
+    unsigned int	MaxNetNumber;
 	int			CounterIndex;
 	int			Ret;
 	SK_U16		MacStatus;
@@ -1436,7 +1472,7 @@
 			("PNMI: SkPnmiEvent: Called, Event=0x%x, Param=0x%x\n",
 			(unsigned int)Event, (unsigned int)Param.Para64));
 	}
-#endif
+#endif /* DEBUG */
 	SK_PNMI_CHECKFLAGS("SkPnmiEvent: On call");
 
 	MacType = pAC->GIni.GIMacType;
@@ -1455,18 +1491,18 @@
 				PhysPortIndex));
 			return (0);
 		}
-#endif
+#endif /* DEBUG */
 		OverflowStatus = 0;
 
 		/*
 		 * Check which source caused an overflow interrupt.
 		 */
-		if ((pAC->GIni.GIFunc.pFnMacOverflow(
-			 pAC, IoC, PhysPortIndex, MacStatus, &OverflowStatus) != 0) ||
+		if ((pAC->GIni.GIFunc.pFnMacOverflow(pAC, IoC, PhysPortIndex,
+				MacStatus, &OverflowStatus) != 0) ||
 			(OverflowStatus == 0)) {
 
 			SK_PNMI_CHECKFLAGS("SkPnmiEvent: On return");
-			return (0); 
+			return (0);
 		}
 
 		/*
@@ -1486,20 +1522,20 @@
 
 			case SK_PNMI_HTX_UTILUNDER:
 			case SK_PNMI_HTX_UTILOVER:
-				XM_IN16(IoC, PhysPortIndex, XM_TX_CMD,
-					&Register);
-				Register |= XM_TX_SAM_LINE;
-				XM_OUT16(IoC, PhysPortIndex, XM_TX_CMD,
-					Register);
+				if (MacType == SK_MAC_XMAC) {
+					XM_IN16(IoC, PhysPortIndex, XM_TX_CMD, &Register);
+					Register |= XM_TX_SAM_LINE;
+					XM_OUT16(IoC, PhysPortIndex, XM_TX_CMD, Register);
+				}
 				break;
 
 			case SK_PNMI_HRX_UTILUNDER:
 			case SK_PNMI_HRX_UTILOVER:
-				XM_IN16(IoC, PhysPortIndex, XM_RX_CMD,
-					&Register);
-				Register |= XM_RX_SAM_LINE;
-				XM_OUT16(IoC, PhysPortIndex, XM_RX_CMD,
-					Register);
+				if (MacType == SK_MAC_XMAC) {
+					XM_IN16(IoC, PhysPortIndex, XM_RX_CMD, &Register);
+					Register |= XM_RX_SAM_LINE;
+					XM_OUT16(IoC, PhysPortIndex, XM_RX_CMD, Register);
+				}
 				break;
 
 			case SK_PNMI_HTX_OCTETHIGH:
@@ -1540,7 +1576,8 @@
 				(unsigned int)Param.Para64));
 			return (0);
 		}
-#endif
+#endif /* DEBUG */
+
 		/*
 		 * Store a trap message in the trap buffer and generate
 		 * an event for user space applications with the
@@ -1556,11 +1593,12 @@
 		if ((unsigned int)Param.Para64 >= (unsigned int)pAC->I2c.MaxSens) {
 
 			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
-				("PNMI: ERR:SkPnmiEvent: SK_PNMI_EVT_SEN_WAR_UPP parameter wrong, SensorIndex=%d\n",
+				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_WAR_UPP parameter wrong, SensorIndex=%d\n",
 				(unsigned int)Param.Para64));
 			return (0);
 		}
-#endif
+#endif /* DEBUG */
+
 		/*
 		 * Store a trap message in the trap buffer and generate
 		 * an event for user space applications with the
@@ -1580,7 +1618,8 @@
 				(unsigned int)Param.Para64));
 			return (0);
 		}
-#endif
+#endif /* DEBUG */
+
 		/*
 		 * Store a trap message in the trap buffer and generate
 		 * an event for user space applications with the
@@ -1600,7 +1639,8 @@
 				(unsigned int)Param.Para64));
 			return (0);
 		}
-#endif
+#endif /* DEBUG */
+
 		/*
 		 * Store a trap message in the trap buffer and generate
 		 * an event for user space applications with the
@@ -1620,7 +1660,7 @@
 		 * Be careful in changing these values, on change check
 		 *   - typedef of SK_PNMI_ESTIMATE (Size of EstValue
 		 *     array one less than value number)
-		 *   - Timer initilization SkTimerStart() in SkPnmiInit
+		 *   - Timer initialization SkTimerStart() in SkPnmiInit
 		 *   - Delta value below must be multiplicated with
 		 *     power of 2
 		 *
@@ -1671,7 +1711,7 @@
 			(void)SK_DRIVER_SENDEVENT(pAC, IoC);
 		}
 
-		SK_MEMSET((char *) &EventParam, 0, sizeof(EventParam));
+		SK_MEMSET((char *)&EventParam, 0, sizeof(EventParam));
 		SkTimerStart(pAC, IoC, &pAC->Pnmi.RlmtChangeEstimate.EstTimer,
 			28125000, SKGE_PNMI, SK_PNMI_EVT_CHG_EST_TIMER,
 			EventParam);
@@ -1693,20 +1733,21 @@
 
 			return (0);
 		}
-#endif
+#endif /* DEBUG */
 
 		/*
-		 * Set all counters and timestamps to zero
+		 * Set all counters and timestamps to zero.
+		 * The according NetIndex is required as a
+		 * parameter of the event.
 		 */
-		ResetCounter(pAC, IoC, NetIndex); /* the according NetIndex is required
-												as a Parameter of the Event */ 
+		ResetCounter(pAC, IoC, NetIndex);
 		break;
 
 	case SK_PNMI_EVT_XMAC_RESET:
 		/*
 		 * To grant continuous counter values store the current
 		 * XMAC statistic values to the entries 1..n of the
-		 * CounterOffset array. XMAC Errata #2 
+		 * CounterOffset array. XMAC Errata #2
 		 */
 #ifdef DEBUG
 		if ((unsigned int)Param.Para64 >= SK_MAX_MACS) {
@@ -1742,11 +1783,10 @@
 				continue;
 			}
 
-			pAC->Pnmi.Port[PhysPortIndex].
-				CounterOffset[CounterIndex] = GetPhysStatVal(
-				pAC, IoC, PhysPortIndex, CounterIndex);
-			pAC->Pnmi.Port[PhysPortIndex].
-				CounterHigh[CounterIndex] = 0;
+			pAC->Pnmi.Port[PhysPortIndex].CounterOffset[CounterIndex] =
+				GetPhysStatVal(pAC, IoC, PhysPortIndex, CounterIndex);
+			
+			pAC->Pnmi.Port[PhysPortIndex].CounterHigh[CounterIndex] = 0;
 		}
 
 		pAC->Pnmi.MacUpdatedFlag --;
@@ -1763,7 +1803,8 @@
 
 			return (0);
 		}
-#endif
+#endif /* DEBUG */
+
 		/*
 		 * Store a trap message in the trap buffer and generate an event for
 		 * user space applications with the SK_DRIVER_SENDEVENT macro.
@@ -1772,8 +1813,7 @@
 		(void)SK_DRIVER_SENDEVENT(pAC, IoC);
 
 		/* Bugfix for XMAC errata (#10620)*/
-		if (pAC->GIni.GIMacType == SK_MAC_XMAC){
-
+		if (MacType == SK_MAC_XMAC) {
 			/* Add incremental difference to offset (#10620)*/
 			(void)pAC->GIni.GIFunc.pFnMacStatistic(pAC, IoC, PhysPortIndex,
 				XM_RXE_SHT_ERR, &Val32);
@@ -1800,20 +1840,22 @@
 
 			return (0);
 		}
-#endif
+#endif /* DEBUG */
+
 		/*
 		 * Store a trap message in the trap buffer and generate an event for
 		 * user space applications with the SK_DRIVER_SENDEVENT macro.
 		 */
 		QueueRlmtPortTrap(pAC, OID_SKGE_TRAP_RLMT_PORT_DOWN, PhysPortIndex);
 		(void)SK_DRIVER_SENDEVENT(pAC, IoC);
-        
+
 		/* Bugfix #10620 - get zero level for incremental difference */
-		if ((pAC->GIni.GIMacType == SK_MAC_XMAC)) {
+		if (MacType == SK_MAC_XMAC) {
 
 			(void)pAC->GIni.GIFunc.pFnMacStatistic(pAC, IoC, PhysPortIndex,
 				XM_RXE_SHT_ERR, &Val32);
-			pAC->Pnmi.Port[PhysPortIndex].RxShortZeroMark = 
+			
+			pAC->Pnmi.Port[PhysPortIndex].RxShortZeroMark =
 				(((SK_U64)pAC->Pnmi.Port[PhysPortIndex].
 				 CounterHigh[SK_PNMI_HRX_SHORTS] << 32) | (SK_U64)Val32);
 		}
@@ -1837,7 +1879,8 @@
 				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_ACTIVE_DOWN parameter too high, NetIndex=%d\n",
 				NetIndex));
 		}
-#endif
+#endif /* DEBUG */
+
 		/*
 		 * For now, ignore event if NetIndex != 0.
 		 */
@@ -1914,7 +1957,8 @@
 				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_ACTIVE_UP parameter too high, NetIndex=%d\n",
 				NetIndex));
 		}
-#endif
+#endif /* DEBUG */
+
 		/*
 		 * For now, ignore event if NetIndex != 0.
 		 */
@@ -1976,9 +2020,7 @@
 			pAC->Pnmi.VirtualCounterOffset[CounterIndex] -= Value;
 		}
 
-		/*
-		 * Set port to active
-		 */
+		/* Set port to active */
 		pAC->Pnmi.Port[PhysPortIndex].ActiveFlag = SK_TRUE;
 
 		pAC->Pnmi.MacUpdatedFlag --;
@@ -2020,47 +2062,56 @@
         break;
 
     case SK_PNMI_EVT_VCT_RESET:
-	PhysPortIndex = Param.Para32[0];
-	pPrt = &pAC->GIni.GP[PhysPortIndex];
-	pVctBackupData = &pAC->Pnmi.VctBackup[PhysPortIndex];
-	
-	if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_PENDING) {
-		RetCode = SkGmCableDiagStatus(pAC, IoC, PhysPortIndex, SK_FALSE);
-		if (RetCode == 2) {
-			/*
-			 * VCT test is still running.
-			 * Start VCT timer counter again.
-			 */
-			SK_MEMSET((char *) &Param, 0, sizeof(Param));
-			Param.Para32[0] = PhysPortIndex;
-			Param.Para32[1] = -1;
-			SkTimerStart(pAC, IoC, &pAC->Pnmi.VctTimeout[PhysPortIndex].VctTimer,
-				4000000, SKGE_PNMI, SK_PNMI_EVT_VCT_RESET, Param);
-			break;
-		}
-		pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_PENDING;
-		pAC->Pnmi.VctStatus[PhysPortIndex] |=
-			(SK_PNMI_VCT_NEW_VCT_DATA | SK_PNMI_VCT_TEST_DONE);
+		PhysPortIndex = Param.Para32[0];
+		pPrt = &pAC->GIni.GP[PhysPortIndex];
+		pVctBackupData = &pAC->Pnmi.VctBackup[PhysPortIndex];
 		
-		/* Copy results for later use to PNMI struct. */
-		for (i = 0; i < 4; i++)  {
-			if (pPrt->PMdiPairLen[i] > 35) {
-				CableLength = 1000 * (((175 * pPrt->PMdiPairLen[i]) / 210) - 28);
+		if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_PENDING) {
+			RetCode = SkGmCableDiagStatus(pAC, IoC, PhysPortIndex, SK_FALSE);
+			if (RetCode == 2) {
+				/*
+				 * VCT test is still running.
+				 * Start VCT timer counter again.
+				 */
+				SK_MEMSET((char *) &Param, 0, sizeof(Param));
+				Param.Para32[0] = PhysPortIndex;
+				Param.Para32[1] = -1;
+				SkTimerStart(pAC, IoC,
+					&pAC->Pnmi.VctTimeout[PhysPortIndex].VctTimer,
+				4000000, SKGE_PNMI, SK_PNMI_EVT_VCT_RESET, Param);
+				break;
 			}
-			else {
-				CableLength = 0;
+			pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_PENDING;
+			pAC->Pnmi.VctStatus[PhysPortIndex] |=
+				(SK_PNMI_VCT_NEW_VCT_DATA | SK_PNMI_VCT_TEST_DONE);
+			
+			/* Copy results for later use to PNMI struct. */
+			for (i = 0; i < 4; i++)  {
+				if (pPrt->PMdiPairSts[i] == SK_PNMI_VCT_NORMAL_CABLE) {
+					if ((pPrt->PMdiPairLen[i] > 35) &&
+						(pPrt->PMdiPairLen[i] < 0xff)) {
+						pPrt->PMdiPairSts[i] = SK_PNMI_VCT_IMPEDANCE_MISMATCH;
+					}
+				}
+				if ((pPrt->PMdiPairLen[i] > 35) &&
+					(pPrt->PMdiPairLen[i] != 0xff)) {
+					CableLength = 1000 *
+						(((175 * pPrt->PMdiPairLen[i]) / 210) - 28);
+				}
+				else {
+					CableLength = 0;
+				}
+				pVctBackupData->PMdiPairLen[i] = CableLength;
+				pVctBackupData->PMdiPairSts[i] = pPrt->PMdiPairSts[i];
 			}
-			pVctBackupData->PMdiPairLen[i] = CableLength;
-			pVctBackupData->PMdiPairSts[i] = pPrt->PMdiPairSts[i];
+			
+			Param.Para32[0] = PhysPortIndex;
+			Param.Para32[1] = -1;
+			SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_RESET, Param);
+			SkEventDispatcher(pAC, IoC);
 		}
 		
-		Param.Para32[0] = PhysPortIndex;
-		Param.Para32[1] = -1;
-		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_RESET, Param);
-		SkEventDispatcher(pAC, IoC);
-	}
-	
-	break;
+		break;
 
 	default:
 		break;
@@ -2088,19 +2139,19 @@
  *	SkGePnmiPreSetVar, or SkGePnmiSetVar.
  *
  * Returns:
- *	SK_PNMI_ERR_XXX. For details have a look to the description of the
+ *	SK_PNMI_ERR_XXX. For details have a look at the description of the
  *	calling functions.
- *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist 
+ *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist
  */
 PNMI_STATIC int PnmiVar(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer which stores the mgmt data to be set */
-unsigned int *pLen,	/* Total length of mgmt data */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* Total length of pBuf management data  */
 SK_U32 Instance,	/* Instance (1..n) that is to be set or -1 */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	unsigned int	TableIndex;
 	int		Ret;
@@ -2112,9 +2163,7 @@
 		return (SK_PNMI_ERR_UNKNOWN_OID);
 	}
 	
-    /* 
-     * Check NetIndex 
-     */
+    /* Check NetIndex */
 	if (NetIndex >= pAC->Rlmt.NumNets) {
 		return (SK_PNMI_ERR_UNKNOWN_NET);
 	}
@@ -2145,15 +2194,15 @@
  *
  * Returns:
  *	SK_PNMI_ERR_XXX. The codes are described in the calling functions.
- *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist 
+ *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist
  */
 PNMI_STATIC int PnmiStruct(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int  Action,		/* Set action to be performed */
-char *pBuf,		/* Buffer which contains the data to be set */
-unsigned int *pLen,	/* Length of buffer */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+int  Action,	/* PRESET/SET action to be performed */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* Length of pBuf management data buffer */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	int		Ret;
 	unsigned int	TableIndex;
@@ -2179,9 +2228,7 @@
 		return (SK_PNMI_ERR_TOO_SHORT);
 	}
 	
-    /* 
-     * Check NetIndex 
-     */
+    /* Check NetIndex */
 	if (NetIndex >= pAC->Rlmt.NumNets) {
 		return (SK_PNMI_ERR_UNKNOWN_NET);
 	}
@@ -2348,19 +2395,19 @@
  *	                         value range.
  *	SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int OidStruct(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	if (Id != OID_SKGE_ALL_DATA) {
 
@@ -2415,19 +2462,19 @@
  *	                         value range.
  *	SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int Perform(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	int	Ret;
 	SK_U32	ActionOp;
@@ -2546,19 +2593,19 @@
  *	                         the correct data (e.g. a 32bit value is
  *	                         needed, but a 16 bit value was passed).
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int Mac8023Stat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex,	/* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	int     Ret;
 	SK_U64  StatVal;
@@ -2583,9 +2630,7 @@
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Check length
-	 */
+	/* Check length */
 	switch (Id) {
 
 	case OID_802_3_PERMANENT_ADDRESS:
@@ -2606,9 +2651,7 @@
 
 #else /* SK_NDIS_64BIT_CTR */
 
-		/*
-		 * for compatibility, at least 32bit are required for oid
-		 */
+		/* for compatibility, at least 32bit are required for OID */
 		if (*pLen < sizeof(SK_U32)) {
 			/*
 			* but indicate handling for 64bit values,
@@ -2654,9 +2697,7 @@
 	default:
 		StatVal = GetStatVal(pAC, IoC, 0, IdTable[TableIndex].Param, NetIndex);
 
-		/*
-		 * by default 32bit values are evaluated
-		 */
+		/* by default 32bit values are evaluated */
 		if (!Is64BitReq) {
 			StatVal32 = (SK_U32)StatVal;
 			SK_PNMI_STORE_U32(pBuf, StatVal32);
@@ -2679,7 +2720,7 @@
  * MacPrivateStat - OID handler function of OID_SKGE_STAT_XXX
  *
  * Description:
- *	Retrieves the XMAC statistic data.
+ *	Retrieves the MAC statistic data.
  *
  * Returns:
  *	SK_PNMI_ERR_OK           The request was successfully performed.
@@ -2688,35 +2729,36 @@
  *	                         the correct data (e.g. a 32bit value is
  *	                         needed, but a 16 bit value was passed).
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int MacPrivateStat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	unsigned int	LogPortMax;
 	unsigned int	LogPortIndex;
 	unsigned int	PhysPortMax;
 	unsigned int	Limit;
 	unsigned int	Offset;
+	int				MacType;
 	int				Ret;
 	SK_U64			StatVal;
+	
+	
 
-
-	/*
-	 * Calculate instance if wished. MAC index 0 is the virtual
-	 * MAC.
-	 */
+	/* Calculate instance if wished. MAC index 0 is the virtual MAC */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
+	
+	MacType = pAC->GIni.GIMacType;
 
 	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* Dual net mode */
 		LogPortMax--;
@@ -2739,19 +2781,14 @@
 		Limit = LogPortMax;
 	}
 
-
-	/*
-	 * Check action
-	 */
+	/* Check action */
 	if (Action != SK_PNMI_GET) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Check length
-	 */
+	/* Check length */
 	if (*pLen < (Limit - LogPortIndex) * sizeof(SK_U64)) {
 
 		*pLen = (Limit - LogPortIndex) * sizeof(SK_U64);
@@ -2759,7 +2796,7 @@
 	}
 
 	/*
-	 * Update XMAC statistic and increment semaphore to indicate that
+	 * Update MAC statistic and increment semaphore to indicate that
 	 * an update was already done.
 	 */
 	Ret = MacUpdate(pAC, IoC, 0, pAC->GIni.GIMacsFound - 1);
@@ -2770,9 +2807,7 @@
 	}
 	pAC->Pnmi.MacUpdatedFlag ++;
 
-	/*
-	 * Get value
-	 */
+	/* Get value */
 	Offset = 0;
 	for (; LogPortIndex < Limit; LogPortIndex ++) {
 
@@ -2787,51 +2822,44 @@
 			return (SK_PNMI_ERR_GENERAL);
 */
 		case OID_SKGE_STAT_RX:
-		case OID_SKGE_STAT_TX:
-			switch (pAC->GIni.GIMacType) {
-			case SK_MAC_XMAC:
+			if (MacType == SK_MAC_GMAC) {
+				StatVal =
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HRX_BROADCAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HRX_MULTICAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HRX_UNICAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HRX_UNDERSIZE, NetIndex);
+			}
+			else {
 				StatVal = GetStatVal(pAC, IoC, LogPortIndex,
 					IdTable[TableIndex].Param, NetIndex);
-				break;
-
-			case SK_MAC_GMAC:
-				if (Id == OID_SKGE_STAT_TX) {
-
-					StatVal =
-						GetStatVal(pAC, IoC, LogPortIndex,
-								   SK_PNMI_HTX_BROADCAST, NetIndex) +
-						GetStatVal(pAC, IoC, LogPortIndex,
-								   SK_PNMI_HTX_MULTICAST, NetIndex) +
-						GetStatVal(pAC, IoC, LogPortIndex,
-								   SK_PNMI_HTX_UNICAST, NetIndex);
-				}
-				else {
-					StatVal =
-						GetStatVal(pAC, IoC, LogPortIndex,
-								   SK_PNMI_HRX_BROADCAST, NetIndex) +
-						GetStatVal(pAC, IoC, LogPortIndex,
-								   SK_PNMI_HRX_MULTICAST, NetIndex) +
-						GetStatVal(pAC, IoC, LogPortIndex,
-								   SK_PNMI_HRX_UNICAST, NetIndex) +
-						GetStatVal(pAC, IoC, LogPortIndex,
-								   SK_PNMI_HRX_UNDERSIZE, NetIndex);
-				}
-				break;
-
-			default:
-				StatVal = 0;
-				break;
 			}
+			break;
 
-			SK_PNMI_STORE_U64(pBuf + Offset, StatVal);
+		case OID_SKGE_STAT_TX:
+			if (MacType == SK_MAC_GMAC) {
+				StatVal =
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HTX_BROADCAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HTX_MULTICAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HTX_UNICAST, NetIndex);
+			}
+			else {
+				StatVal = GetStatVal(pAC, IoC, LogPortIndex,
+					IdTable[TableIndex].Param, NetIndex);
+			}
 			break;
 
 		default:
 			StatVal = GetStatVal(pAC, IoC, LogPortIndex,
 				IdTable[TableIndex].Param, NetIndex);
-			SK_PNMI_STORE_U64(pBuf + Offset, StatVal);
-			break;
 		}
+		SK_PNMI_STORE_U64(pBuf + Offset, StatVal);
 
 		Offset += sizeof(SK_U64);
 	}
@@ -2863,19 +2891,19 @@
  *	                         value range.
  *	SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int Addr(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	int		Ret;
 	unsigned int	LogPortMax;
@@ -2906,7 +2934,6 @@
 		LogPortIndex = SK_PNMI_PORT_INST2LOG(Instance);
 		Limit = LogPortIndex + 1;
 	}
-
 	else { /* Instance == (SK_U32)(-1), get all Instances of that OID */
 
 		LogPortIndex = 0;
@@ -2918,9 +2945,7 @@
 	 */
 	if (Action == SK_PNMI_GET) {
 
-		/*
-		 * Check length
-		*/
+		/* Check length */
 		if (*pLen < (Limit - LogPortIndex) * 6) {
 
 			*pLen = (Limit - LogPortIndex) * 6;
@@ -2996,9 +3021,7 @@
 			return (SK_PNMI_ERR_GENERAL);
 		}
 
-		/*
-		 * Check length
-		*/
+		/* Check length */
 		if (*pLen < (Limit - LogPortIndex) * 6) {
 
 			*pLen = (Limit - LogPortIndex) * 6;
@@ -3069,19 +3092,19 @@
  *	                         the correct data (e.g. a 32bit value is
  *	                         needed, but a 16 bit value was passed).
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int CsumStat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	unsigned int	Index;
 	unsigned int	Limit;
@@ -3116,9 +3139,7 @@
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Check length
-	 */
+	/* Check length */
 	if (*pLen < (Limit - Index) * sizeof(SK_U64)) {
 
 		*pLen = (Limit - Index) * sizeof(SK_U64);
@@ -3187,19 +3208,19 @@
  *	                         the correct data (e.g. a 32bit value is
  *	                         needed, but a 16 bit value was passed).
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int SensorStat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	unsigned int	i;
 	unsigned int	Index;
@@ -3238,9 +3259,7 @@
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Check length
-	 */
+	/* Check length */
 	switch (Id) {
 
 	case OID_SKGE_SENSOR_VALUE:
@@ -3434,19 +3453,19 @@
  *	                         value range.
  *	SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int Vpd(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	SK_VPD_STATUS	*pVpdStatus;
 	unsigned int	BufLen;
@@ -3465,8 +3484,7 @@
 	/*
 	 * Get array of all currently stored VPD keys
 	 */
-	Ret = GetVpdKeyArr(pAC, IoC, &KeyArr[0][0], sizeof(KeyArr),
-		&KeyNo);
+	Ret = GetVpdKeyArr(pAC, IoC, &KeyArr[0][0], sizeof(KeyArr), &KeyNo);
 	if (Ret != SK_PNMI_ERR_OK) {
 		*pLen = 0;
 		return (Ret);
@@ -3712,7 +3730,7 @@
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
-	} 
+	}
 	else {
 		/* The only OID which can be set is VPD_ACTION */
 		if (Id != OID_SKGE_VPD_ACTION) {
@@ -3909,19 +3927,19 @@
  *	                         the correct data (e.g. a 32bit value is
  *	                         needed, but a 16 bit value was passed).
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int General(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
+char *pBuf,		/* Buffer used for the management data transfer */
 unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	int		Ret;
 	unsigned int	Index;
@@ -3939,7 +3957,7 @@
 	int			MacType;
 
 	/*
-	 * Check instance. We only handle single instance variables
+	 * Check instance. We only handle single instance variables.
 	 */
 	if (Instance != (SK_U32)(-1) && Instance != 1) {
 
@@ -3990,6 +4008,14 @@
 #endif /* SK_NDIS_64BIT_CTR */
 		break;
 
+	case OID_SKGE_BOARDLEVEL:
+		if (*pLen < sizeof(SK_U32)) {
+
+			*pLen = sizeof(SK_U32);
+			return (SK_PNMI_ERR_TOO_SHORT);
+		}
+		break;
+
 	case OID_SKGE_PORT_NUMBER:
 	case OID_SKGE_DEVICE_TYPE:
 	case OID_SKGE_RESULT:
@@ -4085,10 +4111,10 @@
 			Val64RxHwErrs =
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_MISSED, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_FRAMING, NetIndex) +
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_OVERFLOW, NetIndex)+
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_OVERFLOW, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_JABBER, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_CARRIER, NetIndex) +
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_IRLENGTH, NetIndex)+
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_IRLENGTH, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_SYMBOL, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_SHORTS, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_RUNT, NetIndex) +
@@ -4102,8 +4128,8 @@
 		case OID_GEN_XMIT_ERROR:
 			Val64TxHwErrs =
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_EXCESS_COL, NetIndex) +
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_LATE_COL, NetIndex)+
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_UNDERRUN, NetIndex)+
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_LATE_COL, NetIndex) +
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_UNDERRUN, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_CARRIER, NetIndex);
 			break;
 		}
@@ -4130,6 +4156,12 @@
 		*pLen = Len;
 		break;
 
+	case OID_SKGE_BOARDLEVEL:
+		Val32 = (SK_U32)pAC->GIni.GILevel;
+		SK_PNMI_STORE_U32(pBuf, Val32);
+		*pLen = sizeof(SK_U32);
+		break;
+
 	case OID_SKGE_PORT_NUMBER:
 		Val32 = (SK_U32)pAC->GIni.GIMacsFound;
 		SK_PNMI_STORE_U32(pBuf, Val32);
@@ -4316,7 +4348,7 @@
 		break;
 
 	case OID_SKGE_TX_SW_QUEUE_LEN:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4345,7 +4377,7 @@
 
 
 	case OID_SKGE_TX_SW_QUEUE_MAX:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4373,7 +4405,7 @@
 		break;
 
 	case OID_SKGE_TX_RETRY:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4401,7 +4433,7 @@
 		break;
 
 	case OID_SKGE_RX_INTR_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4429,7 +4461,7 @@
 		break;
 
 	case OID_SKGE_TX_INTR_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4457,7 +4489,7 @@
 		break;
 
 	case OID_SKGE_RX_NO_BUF_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4485,7 +4517,7 @@
 		break;
 
 	case OID_SKGE_TX_NO_BUF_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4513,7 +4545,7 @@
 		break;
 
 	case OID_SKGE_TX_USED_DESCR_NO:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4541,7 +4573,7 @@
 		break;
 
 	case OID_SKGE_RX_DELIVERED_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4569,7 +4601,7 @@
 		break;
 
 	case OID_SKGE_RX_OCTETS_DELIV_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4607,7 +4639,7 @@
 		break;
 
 	case OID_SKGE_IN_ERRORS_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4615,7 +4647,7 @@
 			}
 			/* Single net mode */
 			else {
-				Val64 = Val64RxHwErrs + 
+				Val64 = Val64RxHwErrs +
 					pAC->Pnmi.BufPort[0].RxNoBufCts +
 					pAC->Pnmi.BufPort[1].RxNoBufCts;
 			}
@@ -4627,7 +4659,7 @@
 			}
 			/* Single net mode */
 			else {
-				Val64 = Val64RxHwErrs + 
+				Val64 = Val64RxHwErrs +
 					pAC->Pnmi.Port[0].RxNoBufCts +
 					pAC->Pnmi.Port[1].RxNoBufCts;
 			}
@@ -4637,7 +4669,7 @@
 		break;
 
 	case OID_SKGE_OUT_ERROR_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4645,7 +4677,7 @@
 			}
 			/* Single net mode */
 			else {
-				Val64 = Val64TxHwErrs + 
+				Val64 = Val64TxHwErrs +
 					pAC->Pnmi.BufPort[0].TxNoBufCts +
 					pAC->Pnmi.BufPort[1].TxNoBufCts;
 			}
@@ -4657,7 +4689,7 @@
 			}
 			/* Single net mode */
 			else {
-				Val64 = Val64TxHwErrs + 
+				Val64 = Val64TxHwErrs +
 					pAC->Pnmi.Port[0].TxNoBufCts +
 					pAC->Pnmi.Port[1].TxNoBufCts;
 			}
@@ -4667,7 +4699,7 @@
 		break;
 
 	case OID_SKGE_ERR_RECOVERY_CTS:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			/* Dual net mode */
 			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
@@ -4708,7 +4740,7 @@
 		break;
 
 	case OID_GEN_RCV_ERROR:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			Val64 = Val64RxHwErrs + pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
 		}
@@ -4731,7 +4763,7 @@
 		break;
 
 	case OID_GEN_XMIT_ERROR:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			Val64 = Val64TxHwErrs + pAC->Pnmi.BufPort[NetIndex].TxNoBufCts;
 		}
@@ -4754,7 +4786,7 @@
 		break;
 
 	case OID_GEN_RCV_NO_BUFFER:
-		/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
 		if (MacType == SK_MAC_XMAC) {
 			Val64 = pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
 		}
@@ -4820,19 +4852,19 @@
  *	                         value range.
  *	SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int Rlmt(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	int		Ret;
 	unsigned int	PhysPortIndex;
@@ -4852,7 +4884,7 @@
 	}
 
 	/*
-	 * Perform the requested action
+	 * Perform the requested action.
 	 */
 	if (Action == SK_PNMI_GET) {
 
@@ -5125,19 +5157,19 @@
  *	                         the correct data (e.g. a 32bit value is
  *	                         needed, but a 16 bit value was passed).
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int RlmtStat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	unsigned int	PhysPortMax;
 	unsigned int	PhysPortIndex;
@@ -5148,7 +5180,7 @@
 	SK_U64		Val64;
 
 	/*
-	 * Calculate the port indexes from the instance
+	 * Calculate the port indexes from the instance.
 	 */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 
@@ -5327,19 +5359,19 @@
  *	                         value range.
  *	SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int MacPrivateConf(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	unsigned int	PhysPortMax;
 	unsigned int	PhysPortIndex;
@@ -5348,14 +5380,13 @@
 	unsigned int	Limit;
 	unsigned int	Offset;
 	char		Val8;
-	int		Ret;
+	char 		*pBufPtr;
+	int			Ret;
 	SK_EVPARA	EventParam;
 	SK_U32		Val32;
 
-
 	/*
-	 * Calculate instance if wished. MAC index 0 is the virtual
-	 * MAC.
+	 * Calculate instance if wished. MAC index 0 is the virtual MAC.
 	 */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
@@ -5386,9 +5417,7 @@
 	 */
 	if (Action == SK_PNMI_GET) {
 
-		/*
-		 * Check length
-		 */
+		/* Check length */
 		switch (Id) {
 
 		case OID_SKGE_PMD:
@@ -5408,16 +5437,15 @@
 		case OID_SKGE_SPEED_STATUS:
 			if (*pLen < (Limit - LogPortIndex) * sizeof(SK_U8)) {
 
-				*pLen = (Limit - LogPortIndex) *
-					sizeof(SK_U8);
+				*pLen = (Limit - LogPortIndex) * sizeof(SK_U8);
 				return (SK_PNMI_ERR_TOO_SHORT);
 			}
 			break;
 
         case OID_SKGE_MTU:
-			if (*pLen < sizeof(SK_U32)) {
+			if (*pLen < (Limit - LogPortIndex) * sizeof(SK_U32)) {
 
-				*pLen = sizeof(SK_U32);
+				*pLen = (Limit - LogPortIndex) * sizeof(SK_U32);
 				return (SK_PNMI_ERR_TOO_SHORT);
 			}
 			break;
@@ -5446,343 +5474,297 @@
 		Offset = 0;
 		for (; LogPortIndex < Limit; LogPortIndex ++) {
 
+			pBufPtr = pBuf + Offset;
+			
 			switch (Id) {
 
 			case OID_SKGE_PMD:
-				*(pBuf + Offset) = pAC->Pnmi.PMD;
+				*pBufPtr = pAC->Pnmi.PMD;
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_CONNECTOR:
-				*(pBuf + Offset) = pAC->Pnmi.Connector;
+				*pBufPtr = pAC->Pnmi.Connector;
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_LINK_CAP:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf +
-							Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical ports */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PLinkCap;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkCap;
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 					
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PLinkCap;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkCap;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_LINK_MODE:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical ports */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PLinkModeConf;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkModeConf;
 					}
-					Offset += sizeof(char);
 				}
-				else { /* DualNetMode */ 
+				else { /* DualNetMode */
 				
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PLinkModeConf;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkModeConf;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_LINK_MODE_STATUS:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf +
-							Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical port */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 
-						*(pBuf + Offset) =
-							CalculateLinkModeStatus(pAC,
-								IoC, PhysPortIndex);
+						*pBufPtr =
+							CalculateLinkModeStatus(pAC, IoC, PhysPortIndex);
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
-					*(pBuf + Offset) = CalculateLinkModeStatus(pAC, IoC, NetIndex);
-					Offset += sizeof(char);
+					
+					*pBufPtr = CalculateLinkModeStatus(pAC, IoC, NetIndex);
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_LINK_STATUS:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf +
-							Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical ports */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
-						*(pBuf + Offset) =
-							CalculateLinkStatus(pAC,
-								IoC, PhysPortIndex);
+						*pBufPtr = CalculateLinkStatus(pAC, IoC, PhysPortIndex);
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 
-					*(pBuf + Offset) = CalculateLinkStatus(pAC, IoC, NetIndex);
-					Offset += sizeof(char);
+					*pBufPtr = CalculateLinkStatus(pAC, IoC, NetIndex);
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_FLOWCTRL_CAP:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf +
-							Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical ports */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PFlowCtrlCap;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PFlowCtrlCap;
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 				
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PFlowCtrlCap;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PFlowCtrlCap;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_FLOWCTRL_MODE:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf +
-							Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical port */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PFlowCtrlMode;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PFlowCtrlMode;
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PFlowCtrlMode;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PFlowCtrlMode;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_FLOWCTRL_STATUS:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf +
-							Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical port */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PFlowCtrlStatus;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PFlowCtrlStatus;
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PFlowCtrlStatus;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PFlowCtrlStatus;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_PHY_OPERATION_CAP:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf +
-							Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical ports */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PMSCap;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PMSCap;
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 				
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PMSCap;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PMSCap;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_PHY_OPERATION_MODE:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf + Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical port */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PMSMode;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PMSMode;
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 				
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PMSMode;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PMSMode;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_PHY_OPERATION_STATUS:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf + Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical port */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PMSStatus;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PMSStatus;
 					}
-					Offset += sizeof(char);
 				}
 				else {
 				
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PMSStatus;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PMSStatus;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_SPEED_CAP:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf +
-							Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical ports */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PLinkSpeedCap;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkSpeedCap;
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 				
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PLinkSpeedCap;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkSpeedCap;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_SPEED_MODE:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf + Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical port */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PLinkSpeed;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkSpeed;
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PLinkSpeed;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkSpeed;
 				}
+				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_SPEED_STATUS:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
-	
 						/* Get value for virtual port */
-						VirtualConf(pAC, IoC, Id, pBuf + Offset);
+						VirtualConf(pAC, IoC, Id, pBufPtr);
 					}
 					else {
 						/* Get value for physical port */
 						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
 							pAC, LogPortIndex);
 	
-						*(pBuf + Offset) = pAC->GIni.GP[
-							PhysPortIndex].PLinkSpeedUsed;
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkSpeedUsed;
 					}
-					Offset += sizeof(char);
 				}
 				else { /* DualNetMode */
 
-					*(pBuf + Offset) = pAC->GIni.GP[NetIndex].PLinkSpeedUsed;
-					Offset += sizeof(char);
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkSpeedUsed;
 				}
+				Offset += sizeof(char);
 				break;
 			
 			case OID_SKGE_MTU:
 				Val32 = SK_DRIVER_GET_MTU(pAC, IoC, NetIndex);
-				SK_PNMI_STORE_U32(pBuf + Offset, Val32);
+				SK_PNMI_STORE_U32(pBufPtr, Val32);
 				Offset += sizeof(SK_U32);
 				break;
 
@@ -6209,19 +6191,19 @@
  *	                         value range.
  *	SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
 PNMI_STATIC int Monitor(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
 unsigned int TableIndex, /* Index to the Id table */
-SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 	unsigned int	Index;
 	unsigned int	Limit;
@@ -6232,7 +6214,7 @@
 	/*
 	 * Calculate instance if wished.
 	 */
-/* XXX Not yet implemented. Return always an empty table. */
+	/* XXX Not yet implemented. Return always an empty table. */
 	Entries = 0;
 
 	if ((Instance != (SK_U32)(-1))) {
@@ -6331,21 +6313,23 @@
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf)		/* Buffer to which to mgmt data will be retrieved */
+char *pBuf)		/* Buffer used for the management data transfer */
 {
 	unsigned int	PhysPortMax;
 	unsigned int	PhysPortIndex;
 	SK_U8		Val8;
 	SK_BOOL		PortActiveFlag;
-
+	SK_GEPORT	*pPrt;
 
 	*pBuf = 0;
 	PortActiveFlag = SK_FALSE;
 	PhysPortMax = pAC->GIni.GIMacsFound;
-
+	
 	for (PhysPortIndex = 0; PhysPortIndex < PhysPortMax;
 		PhysPortIndex ++) {
 
+		pPrt = &pAC->GIni.GP[PhysPortIndex];
+
 		/* Check if the physical port is active */
 		if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
 
@@ -6364,14 +6348,14 @@
 			 * From a curious point of view the virtual port
 			 * is capable of all found capabilities.
 			 */
-			*pBuf |= pAC->GIni.GP[PhysPortIndex].PLinkCap;
+			*pBuf |= pPrt->PLinkCap;
 			break;
 
 		case OID_SKGE_LINK_MODE:
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].PLinkModeConf;
+				*pBuf = pPrt->PLinkModeConf;
 				continue;
 			}
 
@@ -6380,8 +6364,7 @@
 			 * mode than the first one we return a value that
 			 * indicates that the link mode is indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].PLinkModeConf
-				) {
+			if (*pBuf != pPrt->PLinkModeConf) {
 
 				*pBuf = SK_LMODE_INDETERMINATED;
 			}
@@ -6437,7 +6420,7 @@
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].PFlowCtrlCap;
+				*pBuf = pPrt->PFlowCtrlCap;
 				continue;
 			}
 
@@ -6445,14 +6428,14 @@
 			 * From a curious point of view the virtual port
 			 * is capable of all found capabilities.
 			 */
-			*pBuf |= pAC->GIni.GP[PhysPortIndex].PFlowCtrlCap;
+			*pBuf |= pPrt->PFlowCtrlCap;
 			break;
 
 		case OID_SKGE_FLOWCTRL_MODE:
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].PFlowCtrlMode;
+				*pBuf = pPrt->PFlowCtrlMode;
 				continue;
 			}
 
@@ -6461,7 +6444,7 @@
 			 * control mode than the first one, we return a value
 			 * that indicates that the mode is indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].PFlowCtrlMode) {
+			if (*pBuf != pPrt->PFlowCtrlMode) {
 
 				*pBuf = SK_FLOW_MODE_INDETERMINATED;
 			}
@@ -6471,7 +6454,7 @@
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].PFlowCtrlStatus;
+				*pBuf = pPrt->PFlowCtrlStatus;
 				continue;
 			}
 
@@ -6481,7 +6464,7 @@
 			 * value that indicates that the status is
 			 * indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].PFlowCtrlStatus) {
+			if (*pBuf != pPrt->PFlowCtrlStatus) {
 
 				*pBuf = SK_FLOW_STAT_INDETERMINATED;
 			}
@@ -6491,7 +6474,7 @@
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].PMSCap;
+				*pBuf = pPrt->PMSCap;
 				continue;
 			}
 
@@ -6499,14 +6482,14 @@
 			 * From a curious point of view the virtual port
 			 * is capable of all found capabilities.
 			 */
-			*pBuf |= pAC->GIni.GP[PhysPortIndex].PMSCap;
+			*pBuf |= pPrt->PMSCap;
 			break;
 
 		case OID_SKGE_PHY_OPERATION_MODE:
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].PMSMode;
+				*pBuf = pPrt->PMSMode;
 				continue;
 			}
 
@@ -6515,7 +6498,7 @@
 			 * slave mode than the first one, we return a value
 			 * that indicates that the mode is indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].PMSMode) {
+			if (*pBuf != pPrt->PMSMode) {
 
 				*pBuf = SK_MS_MODE_INDETERMINATED;
 			}
@@ -6525,7 +6508,7 @@
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].PMSStatus;
+				*pBuf = pPrt->PMSStatus;
 				continue;
 			}
 
@@ -6535,7 +6518,7 @@
 			 * value that indicates that the status is
 			 * indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].PMSStatus) {
+			if (*pBuf != pPrt->PMSStatus) {
 
 				*pBuf = SK_MS_STAT_INDETERMINATED;
 			}
@@ -6545,7 +6528,7 @@
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].PLinkSpeed;
+				*pBuf = pPrt->PLinkSpeed;
 				continue;
 			}
 
@@ -6554,7 +6537,7 @@
 			 * control mode than the first one, we return a value
 			 * that indicates that the mode is indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].PLinkSpeed) {
+			if (*pBuf != pPrt->PLinkSpeed) {
 
 				*pBuf = SK_LSPEED_INDETERMINATED;
 			}
@@ -6564,7 +6547,7 @@
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].PLinkSpeedUsed;
+				*pBuf = pPrt->PLinkSpeedUsed;
 				continue;
 			}
 
@@ -6574,7 +6557,7 @@
 			 * value that indicates that the status is
 			 * indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].PLinkSpeedUsed) {
+			if (*pBuf != pPrt->PLinkSpeedUsed) {
 
 				*pBuf = SK_LSPEED_STAT_INDETERMINATED;
 			}
@@ -6662,7 +6645,6 @@
 {
 	SK_U8	Result;
 
-
 	if (!pAC->GIni.GP[PhysPortIndex].PHWLinkUp) {
 
 		Result = SK_PNMI_RLMT_LSTAT_PHY_DOWN;
@@ -6702,7 +6684,6 @@
 {
 	SK_U8	Result;
 
-
 	/* Get the current mode, which can be full or half duplex */
 	Result = pAC->GIni.GP[PhysPortIndex].PLinkModeStatus;
 
@@ -6710,7 +6691,7 @@
 	if (Result < SK_LMODE_STAT_HALF) {
 
 		Result = SK_LMODE_STAT_UNKNOWN;
-	} 
+	}
 	else if (pAC->GIni.GP[PhysPortIndex].PLinkMode >= SK_LMODE_AUTOHALF) {
 
 		/*
@@ -6913,8 +6894,8 @@
  *
  * Description:
  *	The XMAC holds its statistic internally. To obtain the current
- *	values we send a command so that the statistic data will
- *	be written to apredefined memory area on the adapter. 
+ *	values we must send a command so that the statistic data will
+ *	be written to a predefined memory area on the adapter.
  *
  * Returns:
  *	SK_PNMI_ERR_OK	     Task successfully performed.
@@ -6941,16 +6922,16 @@
 	for (MacIndex = FirstMac; MacIndex <= LastMac; MacIndex ++) {
 
 		/*
-		 * 2002-09-13 pweber:	Freeze the current sw counters. 
-		 *                      (That should be done as close as 
-		 *                      possible to the update of the 
-		 *                      hw counters)
+		 * 2002-09-13 pweber:	Freeze the current SW counters.
+		 *                      (That should be done as close as
+		 *                      possible to the update of the
+		 *                      HW counters)
 		 */
 		if (pAC->GIni.GIMacType == SK_MAC_XMAC) {
 			pAC->Pnmi.BufPort[MacIndex] = pAC->Pnmi.Port[MacIndex];
 		}
 			
-		/* 2002-09-13 pweber:  Update the hw counter  */
+		/* 2002-09-13 pweber:  Update the HW counter  */
 		if (pAC->GIni.GIFunc.pFnMacUpdateStats(pAC, IoC, MacIndex) != 0) {
 
 			return (SK_PNMI_ERR_GENERAL);
@@ -6991,6 +6972,7 @@
 	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {	/* Dual net mode */
 
 		PhysPortIndex = NetIndex;
+		
 		Val = GetPhysStatVal(pAC, IoC, PhysPortIndex, StatIndex);
 	}
 	else {	/* Single Net mode */
@@ -7005,8 +6987,7 @@
 
 				if (pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
 
-					Val += GetPhysStatVal(pAC, IoC, PhysPortIndex,
-						StatIndex);
+					Val += GetPhysStatVal(pAC, IoC, PhysPortIndex, StatIndex);
 				}
 			}
 
@@ -7016,6 +6997,7 @@
 		else {
 			/* Get counter value of physical port */
 			PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
+			
 			Val = GetPhysStatVal(pAC, IoC, PhysPortIndex, StatIndex);
 		}
 	}
@@ -7049,14 +7031,18 @@
 	SK_U32	HighVal = 0;
 	SK_U16	Word;
 	int		MacType;
+	unsigned int HelpIndex;
+	SK_GEPORT	*pPrt;
 	
 	SK_PNMI_PORT	*pPnmiPrt;
 	SK_GEMACFUNC	*pFnMac;
 	
+	pPrt = &pAC->GIni.GP[PhysPortIndex];
+	
 	MacType = pAC->GIni.GIMacType;
 	
-	/* 2002-09-17 pweber: For XMAC, use the frozen sw counters (BufPort) */
-	if (pAC->GIni.GIMacType == SK_MAC_XMAC) {
+	/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+	if (MacType == SK_MAC_XMAC) {
 		pPnmiPrt = &pAC->Pnmi.BufPort[PhysPortIndex];
 	}
 	else {
@@ -7067,15 +7053,46 @@
 
 	switch (StatIndex) {
 	case SK_PNMI_HTX:
+		if (MacType == SK_MAC_GMAC) {
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HTX_BROADCAST][MacType].Reg,
+							&LowVal);
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HTX_MULTICAST][MacType].Reg,
+							&HighVal);
+			LowVal += HighVal;
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HTX_UNICAST][MacType].Reg,
+							&HighVal);
+			LowVal += HighVal;
+		}
+		else {
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+										  StatAddr[StatIndex][MacType].Reg,
+										  &LowVal);
+		}
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		break;
+	
 	case SK_PNMI_HRX:
-		/* Not supported by GMAC */
 		if (MacType == SK_MAC_GMAC) {
-			return (Val); 
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HRX_BROADCAST][MacType].Reg,
+							&LowVal);
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HRX_MULTICAST][MacType].Reg,
+							&HighVal);
+			LowVal += HighVal;
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HRX_UNICAST][MacType].Reg,
+							&HighVal);
+			LowVal += HighVal;
+		}
+		else {
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+										  StatAddr[StatIndex][MacType].Reg,
+										  &LowVal);
 		}
-			
-		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
-									  StatAddr[StatIndex][MacType].Reg,
-									  &LowVal);
 		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		break;
 
@@ -7106,14 +7123,16 @@
 	case SK_PNMI_HTX_MACC:
 		/* GMAC only supports PAUSE MAC control frames */
 		if (MacType == SK_MAC_GMAC) {
-			Val = GetPhysStatVal(pAC, IoC, PhysPortIndex, SK_PNMI_HTX_PMACC);
-
-			return (Val); 
+			HelpIndex = SK_PNMI_HTX_PMACC;
 		}
-
+		else {
+			HelpIndex = StatIndex;
+		}
+		
 		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
-									  StatAddr[StatIndex][MacType].Reg,
-									  &LowVal);
+								StatAddr[HelpIndex][MacType].Reg,
+								&LowVal);
+
 		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		break;
 
@@ -7130,12 +7149,10 @@
 		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		break;
 
-
-
 	case SK_PNMI_HTX_DEFFERAL:
 		/* Not supported by GMAC */
 		if (MacType == SK_MAC_GMAC) {
-			return (Val); 
+			return (Val);
 		}
 		
 		/*
@@ -7144,16 +7161,16 @@
 		 *
 		 * In full-duplex mode the counter remains constant!
 		 */
-		if ((pAC->GIni.GP[PhysPortIndex].PLinkModeStatus == SK_LMODE_STAT_AUTOFULL) ||
-			(pAC->GIni.GP[PhysPortIndex].PLinkModeStatus == SK_LMODE_STAT_FULL)) {
+		if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOFULL) ||
+			(pPrt->PLinkModeStatus == SK_LMODE_STAT_FULL)) {
 
 			LowVal = 0;
 			HighVal = 0;
 		}
 		else {
-			/* Otherwise get contents of hardware register. */
+			/* Otherwise get contents of hardware register */
 			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
-										  StatAddr[SK_PNMI_HTX_DEFFERAL][MacType].Reg,
+										  StatAddr[StatIndex][MacType].Reg,
 										  &LowVal);
 			HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		}
@@ -7181,7 +7198,7 @@
 	case SK_PNMI_HRX_LONGFRAMES:
 		/* For XMAC the SW counter is managed by PNMI */
 		if (MacType == SK_MAC_XMAC) {
-			return (pPnmiPrt->StatRxLongFrameCts); 
+			return (pPnmiPrt->StatRxLongFrameCts);
 		}
 		
 		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
@@ -7192,19 +7209,17 @@
 		
 	case SK_PNMI_HRX_TOO_LONG:
 		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
-						StatAddr[StatIndex][MacType].Reg,
+								StatAddr[StatIndex][MacType].Reg,
 								&LowVal);
 		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		
 		Val = (((SK_U64)HighVal << 32) | (SK_U64)LowVal);
 
-		switch (MacType) {
-		case SK_MAC_GMAC:
+		if (MacType == SK_MAC_GMAC) {
 			/* For GMAC the SW counter is additionally managed by PNMI */
 			Val += pPnmiPrt->StatRxFrameTooLongCts;
-			break;
-
-		case SK_MAC_XMAC:
+		}
+		else {
 			/*
 			 * Frames longer than IEEE 802.3 frame max size are counted
 			 * by XMAC in frame_too_long counter even reception of long
@@ -7212,10 +7227,6 @@
 			 * So correct the value by subtracting RxLongFrame counter.
 			 */
 			Val -= pPnmiPrt->StatRxLongFrameCts;
-			break;
-
-		default:
-			break;
 		}
 
 		LowVal = (SK_U32)Val;
@@ -7226,7 +7237,7 @@
 		/* Not supported by GMAC */
 		if (MacType == SK_MAC_GMAC) {
 			/* GM_RXE_FRAG?? */
-			return (Val); 
+			return (Val);
 		}
 		
 		/*
@@ -7234,7 +7245,7 @@
 		 *
 		 * If link-down the counter remains constant
 		 */
-		if (pAC->GIni.GP[PhysPortIndex].PLinkModeStatus != SK_LMODE_STAT_UNKNOWN) {
+		if (pPrt->PLinkModeStatus != SK_LMODE_STAT_UNKNOWN) {
 
 			/* Otherwise get incremental difference */
 			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
@@ -7261,8 +7272,7 @@
 	case SK_PNMI_HRX_CEXT:
 		/* Not supported by GMAC */
 		if (MacType == SK_MAC_GMAC) {
-			/* GM_RXE_FRAG?? */
-			return (Val); 
+			return (Val);
 		}
 
 		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
@@ -7274,7 +7284,7 @@
 	case SK_PNMI_HRX_PMACC_ERR:
 		/* For GMAC the SW counter is managed by PNMI */
 		if (MacType == SK_MAC_GMAC) {
-			return (pPnmiPrt->StatRxPMaccErr); 
+			return (pPnmiPrt->StatRxPMaccErr);
 		}
 		
 		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
@@ -7296,16 +7306,14 @@
 		break;
 
 	case SK_PNMI_HRX_FCS:
-		/* 
-		 * Broadcom filters fcs errors and counts it in 
+		/*
+		 * Broadcom filters FCS errors and counts it in
 		 * Receive Error Counter register
 		 */
-		if (pAC->GIni.GP[PhysPortIndex].PhyType == SK_PHY_BCOM) {
+		if (pPrt->PhyType == SK_PHY_BCOM) {
 			/* do not read while not initialized (PHY_READ hangs!)*/
-			if (pAC->GIni.GP[PhysPortIndex].PState) {
-				PHY_READ(IoC, &pAC->GIni.GP[PhysPortIndex],
-						 PhysPortIndex, PHY_BCOM_RE_CTR,
-						 &Word);
+			if (pPrt->PState != SK_PRT_RESET) {
+				SkXmPhyRead(pAC, IoC, PhysPortIndex, PHY_BCOM_RE_CTR, &Word);
 				
 				LowVal = Word;
 			}
@@ -7375,8 +7383,8 @@
 	EventParam.Para32[1] = (SK_U32)-1;
 	SkEventQueue(pAC, SKGE_CSUM, SK_CSUM_EVENT_CLEAR_PROTO_STATS,
 		EventParam);
-#endif
-
+#endif /* SK_USE_CSUM */
+	
 	/* Clear XMAC statistic */
 	for (PhysPortIndex = 0; PhysPortIndex <
 		(unsigned int)pAC->GIni.GIMacsFound; PhysPortIndex ++) {
@@ -7492,18 +7500,18 @@
 		End -= EntrySize;
 #ifdef DEBUG
 		SK_MEMSET(pBuf + End, (char)(-1), EntrySize);
-#endif
+#endif /* DEBUG */
 		if (End == BufPad) {
 #ifdef DEBUG
 			SK_MEMSET(pBuf, (char)(-1), End);
-#endif
+#endif /* DEBUG */
 			BufFree += End;
 			End = 0;
 			BufPad = 0;
 		}
 	}
 
-	/* 
+	/*
 	 * Insert new entry as first entry. Newest entries are
 	 * stored at the beginning of the queue.
 	 */
@@ -7772,7 +7780,6 @@
 	}
 }
 
-
 #ifdef SK_POWER_MGMT
 /*****************************************************************************
  *
@@ -7814,45 +7821,50 @@
 		*pLen = 0;
 		return (SK_PNMI_ERR_UNKNOWN_INST);
 	}
+	
+    
+    /* Check length */
+    switch (Id) {
 
-	/*
-	 * Perform action
-	 */
-	if (Action == SK_PNMI_GET) {
+    case OID_PNP_CAPABILITIES:
+        if (*pLen < sizeof(SK_PNP_CAPABILITIES)) {
 
-		/*
-		 * Check length
-		 */
-		switch (Id) {
+            *pLen = sizeof(SK_PNP_CAPABILITIES);
+            return (SK_PNMI_ERR_TOO_SHORT);
+        }
+        break;
 
-		case OID_PNP_CAPABILITIES:
-			if (*pLen < sizeof(SK_PNP_CAPABILITIES)) {
+	case OID_PNP_SET_POWER:
+    case OID_PNP_QUERY_POWER:
+    	if (*pLen < sizeof(SK_DEVICE_POWER_STATE))
+    	{
+    		*pLen = sizeof(SK_DEVICE_POWER_STATE);
+    		return (SK_PNMI_ERR_TOO_SHORT);
+    	}
+        break;
 
-				*pLen = sizeof(SK_PNP_CAPABILITIES);
-				return (SK_PNMI_ERR_TOO_SHORT);
-			}
-			break;
+    case OID_PNP_ADD_WAKE_UP_PATTERN:
+    case OID_PNP_REMOVE_WAKE_UP_PATTERN:
+		if (*pLen < sizeof(SK_PM_PACKET_PATTERN)) {
 
-		case OID_PNP_QUERY_POWER:
-		case OID_PNP_ENABLE_WAKE_UP:
-			if (*pLen < sizeof(SK_U32)) {
+			*pLen = sizeof(SK_PM_PACKET_PATTERN);
+			return (SK_PNMI_ERR_TOO_SHORT);
+		}
+		break;
 
-				*pLen = sizeof(SK_U32);
-				return (SK_PNMI_ERR_TOO_SHORT);
-			}
-			break;
+    case OID_PNP_ENABLE_WAKE_UP:
+        if (*pLen < sizeof(SK_U32)) {
 
-		case OID_PNP_SET_POWER:
-		case OID_PNP_ADD_WAKE_UP_PATTERN:
-		case OID_PNP_REMOVE_WAKE_UP_PATTERN:
-			break;
-		
-		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR040,
-				SK_PNMI_ERR040MSG);
-			*pLen = 0;
-			return (SK_PNMI_ERR_GENERAL);
-		}
+            *pLen = sizeof(SK_U32);
+            return (SK_PNMI_ERR_TOO_SHORT);
+        }
+        break;
+    }
+	
+    /*
+	 * Perform action
+	 */
+	if (Action == SK_PNMI_GET) {
 
 		/*
 		 * Get value
@@ -7865,11 +7877,12 @@
 
 		case OID_PNP_QUERY_POWER:
 			/* The Windows DDK describes: An OID_PNP_QUERY_POWER requests
-			 the miniport to indicate whether it can transition its NIC 
-			 to the low-power state. 
+			 the miniport to indicate whether it can transition its NIC
+			 to the low-power state.
 			 A miniport driver must always return NDIS_STATUS_SUCCESS
 			 to a query of OID_PNP_QUERY_POWER. */
-			RetCode = SK_PNMI_ERR_OK;
+			*pLen = sizeof(SK_DEVICE_POWER_STATE);;
+            RetCode = SK_PNMI_ERR_OK;
 			break;
 
 			/* NDIS handles these OIDs as write-only.
@@ -7880,7 +7893,7 @@
 		case OID_PNP_ADD_WAKE_UP_PATTERN:
 		case OID_PNP_REMOVE_WAKE_UP_PATTERN:
 			*pLen = 0;	
-			RetCode = SK_PNMI_ERR_OK;
+            RetCode = SK_PNMI_ERR_NOT_SUPPORTED;
 			break;
 
 		case OID_PNP_ENABLE_WAKE_UP:
@@ -7892,41 +7905,9 @@
 			break;
 		}
 
-		return (RetCode); 
+		return (RetCode);
 	}
 	
-	/*
-	 * From here SET or PRESET action. Check if the passed
-	 * buffer length is plausible.
-	 */
-	switch (Id) {
-	case OID_PNP_SET_POWER:
-	case OID_PNP_ENABLE_WAKE_UP:
-		if (*pLen < sizeof(SK_U32)) {
-
-			*pLen = sizeof(SK_U32);
-			return (SK_PNMI_ERR_TOO_SHORT);
-		}
-		if (*pLen != sizeof(SK_U32)) {
-
-			*pLen = 0;
-			return (SK_PNMI_ERR_BAD_VALUE);
-		}
-		break;
-
-	case OID_PNP_ADD_WAKE_UP_PATTERN:
-	case OID_PNP_REMOVE_WAKE_UP_PATTERN:
-		if (*pLen < sizeof(SK_PM_PACKET_PATTERN)) {
-
-			*pLen = 0;
-			return (SK_PNMI_ERR_BAD_VALUE); 
-		}
-		break;
-
-    default:
-		*pLen = 0;
-		return (SK_PNMI_ERR_READ_ONLY);
-	}
 
 	/*
 	 * Perform preset or set
@@ -7934,7 +7915,7 @@
 	
 	/* POWER module does not support PRESET action */
 	if (Action == SK_PNMI_PRESET) {
-		return (SK_PNMI_ERR_OK); 
+		return (SK_PNMI_ERR_OK);
 	}
 
 	switch (Id) {
@@ -7955,13 +7936,148 @@
 		break;
 		
 	default:
-		RetCode = SK_PNMI_ERR_GENERAL;
+		RetCode = SK_PNMI_ERR_READ_ONLY;
 	}
 	
 	return (RetCode);
 }
 #endif /* SK_POWER_MGMT */
 
+#ifdef SK_DIAG_SUPPORT
+/*****************************************************************************
+ *
+ * DiagActions - OID handler function of Diagnostic driver 
+ *
+ * Description:
+ *	The code is simple. No description necessary.
+ *
+ * Returns:
+ *	SK_PNMI_ERR_OK           The request was successfully performed.
+ *	SK_PNMI_ERR_GENERAL      A general severe internal error occured.
+ *	SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain
+ *	                         the correct data (e.g. a 32bit value is
+ *	                         needed, but a 16 bit value was passed).
+ *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
+ *                           exist (e.g. port instance 3 on a two port
+ *	                         adapter.
+ */
+
+PNMI_STATIC int DiagActions(
+SK_AC *pAC,		/* Pointer to adapter context */
+SK_IOC IoC,		/* IO context handle */
+int Action,		/* GET/PRESET/SET action */
+SK_U32 Id,		/* Object ID that is to be processed */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
+SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
+unsigned int TableIndex, /* Index to the Id table */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
+{
+
+	SK_U32	RetCode = SK_PNMI_ERR_GENERAL;
+
+	/*
+	 * Check instance. We only handle single instance variables.
+	 */
+	if (Instance != (SK_U32)(-1) && Instance != 1) {
+
+		*pLen = 0;
+		return (SK_PNMI_ERR_UNKNOWN_INST);
+	}
+
+	/*
+	 * Check length.
+	 */
+	switch (Id) {
+
+	case OID_SKGE_DIAG_MODE:
+		if (*pLen < sizeof(SK_U32)) {
+
+			*pLen = sizeof(SK_U32);
+			return (SK_PNMI_ERR_TOO_SHORT);
+		}
+		break;
+
+	default:
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR040, SK_PNMI_ERR040MSG);
+		*pLen = 0;
+		return (SK_PNMI_ERR_GENERAL);
+	}
+
+	/* Perform action. */
+
+	/* GET value. */
+	if (Action == SK_PNMI_GET) {
+
+		switch (Id) {
+
+		case OID_SKGE_DIAG_MODE:
+			SK_PNMI_STORE_U32(pBuf, pAC->DiagModeActive);
+			*pLen = sizeof(SK_U32);	
+			RetCode = SK_PNMI_ERR_OK;
+			break;
+
+		default:
+			*pLen = 0;	
+			RetCode = SK_PNMI_ERR_GENERAL;
+			break;
+		}
+
+		return (RetCode); 
+	}
+
+	/* From here SET or PRESET value. */
+	
+	/* PRESET value is not supported. */
+	if (Action == SK_PNMI_PRESET) {
+		return (SK_PNMI_ERR_OK); 
+	}
+
+	/* SET value. */
+	switch (Id) {
+		case OID_SKGE_DIAG_MODE:
+
+			/* Handle the SET. */
+			switch (*pBuf) {
+		
+				/* Enter the DIAG mode in the driver. */
+				case 1:
+					/* If DiagMode is not active, we can enter it. */
+					if (!pAC->DiagModeActive) {
+
+						RetCode = SkDrvEnterDiagMode(pAC);	
+					}
+					else {
+
+						RetCode = SK_PNMI_ERR_GENERAL;
+					}
+					break;
+
+				/* Leave the DIAG mode in the driver. */
+				case 0:
+					RetCode = SkDrvLeaveDiagMode(pAC);	
+					break;
+
+				default:
+					RetCode = SK_PNMI_ERR_BAD_VALUE;
+					break;
+			}
+			break;
+
+		default:
+			RetCode = SK_PNMI_ERR_GENERAL;
+	}
+
+	if (RetCode == SK_PNMI_ERR_OK) {
+		*pLen = sizeof(SK_U32);
+	}
+	else {
+
+		*pLen = 0;
+	}
+	return (RetCode);
+}
+#endif /* SK_DIAG_SUPPORT */
 
 /*****************************************************************************
  *
@@ -7977,7 +8093,7 @@
  *	                         the correct data (e.g. a 32bit value is
  *	                         needed, but a 16 bit value was passed).
  *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
- *                               exist (e.g. port instance 3 on a two port
+ *                           exist (e.g. port instance 3 on a two port
  *	                         adapter).
  *	SK_PNMI_ERR_READ_ONLY	 Only the Get action is allowed.
  *
@@ -7986,10 +8102,10 @@
 PNMI_STATIC int Vct(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
-int Action,		/* Get/PreSet/Set action */
+int Action,		/* GET/PRESET/SET action */
 SK_U32 Id,		/* Object ID that is to be processed */
-char *pBuf,		/* Buffer to which the mgmt data will be copied */
-unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+char *pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,	/* On call: pBuf buffer length. On return: used buffer */
 SK_U32 Instance,	/* Instance (-1,2..n) that is to be queried */
 unsigned int TableIndex, /* Index to the Id table */
 SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
@@ -8001,7 +8117,6 @@
 	SK_U32		PhysPortIndex;
 	SK_U32		Limit;
 	SK_U32		Offset;
-
 	SK_BOOL		Link;
 	SK_U32		RetCode = SK_PNMI_ERR_GENERAL;
 	int		i;
@@ -8034,7 +8149,8 @@
 		}
 		Limit = PhysPortIndex + 1;
 	}
-	else {	/*
+	else {
+		/*
 		 * Instance == (SK_U32) (-1), get all Instances of that OID.
 		 *
 		 * Not implemented yet. May be used in future releases.
@@ -8051,9 +8167,7 @@
 		Link = SK_FALSE;
 	}
 	
-	/*
-	 * Check MAC type.
-	 */
+	/* Check MAC type */
 	if (pPrt->PhyType != SK_PHY_MARV_COPPER) {
 		*pLen = 0;
 		return (SK_PNMI_ERR_GENERAL);
@@ -8062,13 +8176,9 @@
 	/* Initialize backup data pointer. */
 	pVctBackupData = &pAC->Pnmi.VctBackup[PhysPortIndex];
 	
-	/*
-	 * Check action type.
-	 */
+	/* Check action type */
 	if (Action == SK_PNMI_GET) {
-		/*
-		 * Check length.
-		 */
+		/* Check length */
 		switch (Id) {
 		
 		case OID_SKGE_VCT_GET:
@@ -8090,14 +8200,12 @@
 			return (SK_PNMI_ERR_GENERAL);
 		}	
 		
-		/*
-		 * Get value.
-		 */
+		/* Get value */
 		Offset = 0;
 		for (; PhysPortIndex < Limit; PhysPortIndex++) {
 			switch (Id) {
 			
-			case OID_SKGE_VCT_GET:		
+			case OID_SKGE_VCT_GET:
 				if ((Link == SK_FALSE) &&
 					(pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_PENDING)) {
 					RetCode = SkGmCableDiagStatus(pAC, IoC, PhysPortIndex, SK_FALSE);
@@ -8171,9 +8279,7 @@
 	 * buffer length is plausible.
 	 */
 	
-	/*
-	 * Check length.
-	 */
+	/* Check length */
 	switch (Id) {
 	case OID_SKGE_VCT_SET:
 		if (*pLen < (Limit - PhysPortIndex) * sizeof(SK_U32)) {
@@ -8254,7 +8360,6 @@
 	SK_GEPORT 	*pPrt;
 	SK_PNMI_VCT	*pVctData;
 	SK_U32		RetCode;
-	SK_U8		LinkSpeedUsed;
 	
 	pPrt = &pAC->GIni.GP[PhysPortIndex];
 	
@@ -8297,10 +8402,93 @@
 		}
 		
 		/* DSP only valid in 100/1000 modes. */
-		LinkSpeedUsed = pAC->GIni.GP[PhysPortIndex].PLinkSpeedUsed;
-		if (LinkSpeedUsed != SK_LSPEED_STAT_10MBPS) {	
+		if (pAC->GIni.GP[PhysPortIndex].PLinkSpeedUsed !=
+			SK_LSPEED_STAT_10MBPS) {	
 			pVctData->VctStatus |= SK_PNMI_VCT_NEW_DSP_DATA;
 		}
 	}
-
 } /* CheckVctStatus */
+
+
+/*****************************************************************************
+ *
+ *      SkPnmiGenIoctl - Handles new generic PNMI IOCTL, calls the needed
+ *                       PNMI function depending on the subcommand and
+ *                       returns all data belonging to the complete database
+ *                       or OID request.
+ *
+ * Description:
+ *	Looks up the requested subcommand, calls the corresponding handler
+ *	function and passes all required parameters to it.
+ *	The function is called by the driver. It is needed to handle the new
+ *  generic PNMI IOCTL. This IOCTL is given to the driver and contains both
+ *  the OID and a subcommand to decide what kind of request has to be done.
+ *
+ * Returns:
+ *	SK_PNMI_ERR_OK           The request was successfully performed
+ *	SK_PNMI_ERR_GENERAL      A general severe internal error occured
+ *	SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to take
+ *	                         the data.
+ *	SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown
+ *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
+ *                           exist (e.g. port instance 3 on a two port
+ *	                         adapter.
+ */
+int SkPnmiGenIoctl(
+SK_AC		*pAC,		/* Pointer to adapter context struct */
+SK_IOC		IoC,		/* I/O context */
+void		*pBuf,		/* Buffer used for the management data transfer */
+unsigned int *pLen,		/* Length of buffer */
+SK_U32		NetIndex)	/* NetIndex (0..n), in single net mode always zero */
+{
+SK_I32	Mode;			/* Store value of subcommand. */
+SK_U32	Oid;			/* Store value of OID. */
+int		ReturnCode;		/* Store return value to show status of PNMI action. */
+int 	HeaderLength;	/* Length of desired action plus OID. */
+
+	ReturnCode = SK_PNMI_ERR_GENERAL;
+	
+	SK_MEMCPY(&Mode, pBuf, sizeof(SK_I32));
+	SK_MEMCPY(&Oid, (char *) pBuf + sizeof(SK_I32), sizeof(SK_U32));
+	HeaderLength = sizeof(SK_I32) + sizeof(SK_U32);
+	*pLen = *pLen - HeaderLength;
+	SK_MEMCPY((char *) pBuf + sizeof(SK_I32), (char *) pBuf + HeaderLength, *pLen);
+	
+	switch(Mode) {
+	case SK_GET_SINGLE_VAR:
+		ReturnCode = SkPnmiGetVar(pAC, IoC, Oid, 
+				(char *) pBuf + sizeof(SK_I32), pLen,
+				((SK_U32) (-1)), NetIndex);
+		SK_PNMI_STORE_U32(pBuf, ReturnCode);
+		*pLen = *pLen + sizeof(SK_I32);
+		break;
+	case SK_PRESET_SINGLE_VAR:
+		ReturnCode = SkPnmiPreSetVar(pAC, IoC, Oid, 
+				(char *) pBuf + sizeof(SK_I32), pLen,
+				((SK_U32) (-1)), NetIndex);
+		SK_PNMI_STORE_U32(pBuf, ReturnCode);
+		*pLen = *pLen + sizeof(SK_I32);
+		break;
+	case SK_SET_SINGLE_VAR:
+		ReturnCode = SkPnmiSetVar(pAC, IoC, Oid, 
+				(char *) pBuf + sizeof(SK_I32), pLen,
+				((SK_U32) (-1)), NetIndex);
+		SK_PNMI_STORE_U32(pBuf, ReturnCode);
+		*pLen = *pLen + sizeof(SK_I32);
+		break;
+	case SK_GET_FULL_MIB:
+		ReturnCode = SkPnmiGetStruct(pAC, IoC, pBuf, pLen, NetIndex);
+		break;
+	case SK_PRESET_FULL_MIB:
+		ReturnCode = SkPnmiPreSetStruct(pAC, IoC, pBuf, pLen, NetIndex);
+		break;
+	case SK_SET_FULL_MIB:
+		ReturnCode = SkPnmiSetStruct(pAC, IoC, pBuf, pLen, NetIndex);
+		break;
+	default:
+		break;
+	}
+	
+	return (ReturnCode);
+
+} /* SkGeIocGen */
diff -Nru a/drivers/net/sk98lin/skgesirq.c b/drivers/net/sk98lin/skgesirq.c
--- a/drivers/net/sk98lin/skgesirq.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skgesirq.c	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skgesirq.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.81 $
- * Date:	$Date: 2002/12/05 10:49:51 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.91 $
+ * Date:	$Date: 2003/07/04 12:46:22 $
  * Purpose:	Special IRQ module
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,60 @@
  * History:
  *
  *	$Log: skgesirq.c,v $
+ *	Revision 1.91  2003/07/04 12:46:22  rschmidt
+ *	Added debug messages in SkGePortCheckUpGmac().
+ *	Added error log message and new driver event SK_DRV_DOWNSHIFT_DET
+ *	for Downshift detection (Yukon-Copper).
+ *	Editorial changes.
+ *	
+ *	Revision 1.90  2003/05/28 15:35:45  rschmidt
+ *	Added parameter AutoNeg in all SkGePortCheckUp...() to save code.
+ *	Added setting for AutoNeg only once in SkGePortCheckUp().
+ *	Moved defines for return codes of SkGePortCheckUp() to header file.
+ *	Editorial changes.
+ *	
+ *	Revision 1.89  2003/05/13 17:32:20  mkarl
+ *	Removed links to RLMT and PNMI for SLIM driver (SK_SLIM).
+ *	Separated GENESIS and YUKON only code to reduce code size.
+ *	
+ *	Revision 1.88  2003/05/06 13:20:34  rschmidt
+ *	Changed workaround for Tx hang in half duplex only for Genesis.
+ *	Replaced SkPnmiGetVar() calls for Tx Octets Counter
+ *	with SkXmMacStatistic() in SkGeSirqIsr().
+ *	Added defines around GENESIS resp. YUKON branches to reduce
+ *	code size for PXE.
+ *	Editorial changes.
+ *	
+ *	Revision 1.87  2003/04/28 09:18:31  rschmidt
+ *	Added increment for GITimeStampCnt (high dword for
+ *	Time Stamp Timer counter), when overflow IRQ occurs.
+ *	Disabled HW Error IRQ on 32-bit Yukon if sensor IRQ occurs
+ *	by changing the common mask stored in GIValIrqMask.
+ *	Changed handling for HW Error IRQ in SkGeSirqIsr().
+ *	Added clearing of the software forced IRQ in SkGeSirqIsr().
+ *	Editorial changes.
+ *	
+ *	Revision 1.86  2003/04/09 13:03:24  rschmidt
+ *	Added workaround for configuration of GPHY's Auto-negotiation
+ *	advertisement register after link down event in SkPhyIsrGmac().
+ *	
+ *	Revision 1.85  2003/04/08 16:39:02  rschmidt
+ *	Changed handling for different PhyTypes for source code
+ *	portability to PXE, UNDI.
+ *	Editorial changes.
+ *	
+ *	Revision 1.84  2003/03/31 07:01:43  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.83  2003/02/05 15:10:59  rschmidt
+ *	Fixed setting of PLinkSpeedUsed in SkHWLinkUp() when
+ *	auto-negotiation is disabled.
+ *	Editorial changes.
+ *	
+ *	Revision 1.82  2003/01/29 13:34:33  rschmidt
+ *	Added some typecasts to avoid compiler warnings.
+ *	
  *	Revision 1.81  2002/12/05 10:49:51  rschmidt
  *	Fixed missing Link Down Event for fiber (Bug Id #10768)
  *	Added reading of cable length when link is up
@@ -132,7 +187,7 @@
  *	Added workaround for half duplex hangup.
  *	
  *	Revision 1.58  2000/09/28 13:06:04  gklug
- *	fix: BCOM may NOT be touched if XMAC is in RESET state
+ *	fix: BCom may NOT be touched if XMAC is in RESET state
  *	
  *	Revision 1.57  2000/09/08 12:38:39  cgoos
  *	Added forgotten variable declaration.
@@ -353,26 +408,35 @@
  *
  */
 
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"$Id: skgesirq.c,v 1.81 2002/12/05 10:49:51 rschmidt Exp $" ;
+	"@(#) $Id: skgesirq.c,v 1.91 2003/07/04 12:46:22 rschmidt Exp $ (C) Marvell.";
+#endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
+#ifndef SK_SLIM
 #include "h/skgepnmi.h"		/* PNMI Definitions */
 #include "h/skrlmt.h"		/* RLMT Definitions */
+#endif
 #include "h/skdrv2nd.h"		/* Adapter Control and Driver specific Def. */
 
 /* local function prototypes */
-static int	SkGePortCheckUpXmac(SK_AC*, SK_IOC, int);
-static int	SkGePortCheckUpBcom(SK_AC*, SK_IOC, int);
-static int	SkGePortCheckUpGmac(SK_AC*, SK_IOC, int);
+#ifdef GENESIS
+static int	SkGePortCheckUpXmac(SK_AC*, SK_IOC, int, SK_BOOL);
+static int	SkGePortCheckUpBcom(SK_AC*, SK_IOC, int, SK_BOOL);
 static void	SkPhyIsrBcom(SK_AC*, SK_IOC, int, SK_U16);
+#endif /* GENESIS */
+#ifdef YUKON
+static int	SkGePortCheckUpGmac(SK_AC*, SK_IOC, int, SK_BOOL);
 static void	SkPhyIsrGmac(SK_AC*, SK_IOC, int, SK_U16);
+#endif /* YUKON */
 #ifdef OTHER_PHY
-static int	SkGePortCheckUpLone(SK_AC*, SK_IOC, int);
-static int	SkGePortCheckUpNat(SK_AC*, SK_IOC, int);
+static int	SkGePortCheckUpLone(SK_AC*, SK_IOC, int, SK_BOOL);
+static int	SkGePortCheckUpNat(SK_AC*, SK_IOC, int, SK_BOOL);
 static void	SkPhyIsrLone(SK_AC*, SK_IOC, int, SK_U16);
 #endif /* OTHER_PHY */
 
+#ifdef GENESIS
 /*
  * array of Rx counter from XMAC which are checked
  * in AutoSense mode to check whether a link is not able to auto-negotiate.
@@ -385,6 +449,7 @@
 	XM_RXF_1023B,
 	XM_RXF_MAX_SZ
 } ;
+#endif /* GENESIS */
 
 #ifdef __C2MAN__
 /*
@@ -397,20 +462,13 @@
 {}
 #endif
 
-/* Define return codes of SkGePortCheckUp and CheckShort */
-#define	SK_HW_PS_NONE		0	/* No action needed */
-#define	SK_HW_PS_RESTART	1	/* Restart needed */
-#define	SK_HW_PS_LINK		2	/* Link Up actions needed */
-
 /******************************************************************************
  *
  *	SkHWInitDefSense() - Default Autosensing mode initialization
  *
- * Description:
- *	This function sets the PLinkMode for HWInit
- *
- * Note:
+ * Description: sets the PLinkMode for HWInit
  *
+ * Returns: N/A
  */
 static void SkHWInitDefSense(
 SK_AC	*pAC,	/* adapter context */
@@ -438,17 +496,17 @@
 }	/* SkHWInitDefSense */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
- *	SkHWSenseGetNext() - GetNextAutosensing Mode
+ *	SkHWSenseGetNext() - Get Next Autosensing Mode
  *
- * Description:
- *	This function handles the AutoSensing
+ * Description: gets the appropriate next mode
  *
  * Note:
  *
  */
-SK_U8 SkHWSenseGetNext(
+static SK_U8 SkHWSenseGetNext(
 SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* IO context */
 int		Port)	/* Port Index (MAC_1 + n) */
@@ -459,18 +517,18 @@
 
 	pPrt->PAutoNegTimeOut = 0;
 
-	if (pPrt->PLinkModeConf != SK_LMODE_AUTOSENSE) {
+    if (pPrt->PLinkModeConf != (SK_U8)SK_LMODE_AUTOSENSE) {
 		/* Leave all as configured */
 		return(pPrt->PLinkModeConf);
 	}
 
-	if (pPrt->PLinkMode == SK_LMODE_AUTOFULL) {
+    if (pPrt->PLinkMode == (SK_U8)SK_LMODE_AUTOFULL) {
 		/* Return next mode AUTOBOTH */
-		return(SK_LMODE_AUTOBOTH);
+        return ((SK_U8)SK_LMODE_AUTOBOTH);
 	}
 
 	/* Return default autofull */
-	return(SK_LMODE_AUTOFULL);
+    return ((SK_U8)SK_LMODE_AUTOFULL);
 }	/* SkHWSenseGetNext */
 
 
@@ -478,13 +536,11 @@
  *
  *	SkHWSenseSetNext() - Autosensing Set next mode
  *
- * Description:
- *	This function sets the appropriate next mode.
- *
- * Note:
+ * Description:	sets the appropriate next mode
  *
+ * Returns: N/A
  */
-void SkHWSenseSetNext(
+static void SkHWSenseSetNext(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port,		/* Port Index (MAC_1 + n) */
@@ -496,7 +552,7 @@
 
 	pPrt->PAutoNegTimeOut = 0;
 
-	if (pPrt->PLinkModeConf != SK_LMODE_AUTOSENSE) {
+    if (pPrt->PLinkModeConf != (SK_U8)SK_LMODE_AUTOSENSE) {
 		return;
 	}
 
@@ -508,17 +564,16 @@
 
 	return;
 }	/* SkHWSenseSetNext */
+#endif /* GENESIS */
 
 
 /******************************************************************************
  *
  *	SkHWLinkDown() - Link Down handling
  *
- * Description:
- *	This function handles the Hardware link down signal
- *
- * Note:
+ * Description: handles the hardware link down signal
  *
+ * Returns: N/A
  */
 void SkHWLinkDown(
 SK_AC	*pAC,		/* adapter context */
@@ -538,7 +593,7 @@
 	/* Init default sense mode */
 	SkHWInitDefSense(pAC, IoC, Port);
 
-	if (!pPrt->PHWLinkUp) {
+	if (pPrt->PHWLinkUp == SK_FALSE) {
 		return;
 	}
 
@@ -549,8 +604,8 @@
 	pPrt->PHWLinkUp = SK_FALSE;
 
 	/* Reset Port stati */
-	pPrt->PLinkModeStatus = SK_LMODE_STAT_UNKNOWN;
-	pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
+    pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
+    pPrt->PFlowCtrlStatus = (SK_U8)SK_FLOW_STAT_NONE;
 	pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_INDETERMINATED;
 
 	/* Re-init Phy especially when the AutoSense default is set now */
@@ -568,11 +623,9 @@
  *
  *	SkHWLinkUp() - Link Up handling
  *
- * Description:
- *	This function handles the Hardware link up signal
- *
- * Note:
+ * Description: handles the hardware link up signal
  *
+ * Returns: N/A
  */
 void SkHWLinkUp(
 SK_AC	*pAC,	/* adapter context */
@@ -590,39 +643,52 @@
 
 	pPrt->PHWLinkUp = SK_TRUE;
 	pPrt->PAutoNegFail = SK_FALSE;
-	pPrt->PLinkModeStatus = SK_LMODE_STAT_UNKNOWN;
+    pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
 
-	if (pPrt->PLinkMode != SK_LMODE_AUTOHALF &&
-	    pPrt->PLinkMode != SK_LMODE_AUTOFULL &&
-	    pPrt->PLinkMode != SK_LMODE_AUTOBOTH) {
+    if (pPrt->PLinkMode != (SK_U8)SK_LMODE_AUTOHALF &&
+        pPrt->PLinkMode != (SK_U8)SK_LMODE_AUTOFULL &&
+        pPrt->PLinkMode != (SK_U8)SK_LMODE_AUTOBOTH) {
 		/* Link is up and no Auto-negotiation should be done */
 
-		/* Configure Port */
-		
-		/* link speed should be the configured one */
-		pPrt->PLinkSpeedUsed = pPrt->PLinkSpeed;
+		/* Link speed should be the configured one */
+		switch (pPrt->PLinkSpeed) {
+		case SK_LSPEED_AUTO:
+			/* default is 1000 Mbps */
+		case SK_LSPEED_1000MBPS:
+			pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_1000MBPS;
+			break;
+		case SK_LSPEED_100MBPS:
+			pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_100MBPS;
+			break;
+		case SK_LSPEED_10MBPS:
+			pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_10MBPS;
+			break;
+		}
 
 		/* Set Link Mode Status */
 		if (pPrt->PLinkMode == SK_LMODE_FULL) {
 			pPrt->PLinkModeStatus = SK_LMODE_STAT_FULL;
 		}
 		else {
-			pPrt->PLinkModeStatus = SK_LMODE_STAT_HALF;
+            pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_HALF;
 		}
 
 		/* No flow control without auto-negotiation */
-		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
+        pPrt->PFlowCtrlStatus = (SK_U8)SK_FLOW_STAT_NONE;
 
 		/* enable Rx/Tx */
-		SkMacRxTxEnable(pAC, IoC, Port);
+        (void)SkMacRxTxEnable(pAC, IoC, Port);
 	}
 }	/* SkHWLinkUp */
 
 
 /******************************************************************************
  *
- * SkMacParity	- does everything to handle MAC parity errors correctly
+ *	SkMacParity() - MAC parity workaround
  *
+ * Description: handles MAC parity errors correctly
+ *
+ * Returns: N/A
  */
 static void SkMacParity(
 SK_AC	*pAC,	/* adapter context */
@@ -631,21 +697,29 @@
 {
 	SK_EVPARA	Para;
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
-	SK_U32		TxMax;		/* TxMax Counter */
+	SK_U32		TxMax;		/* Tx Max Size Counter */
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	/* Clear IRQ Tx Parity Error */
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
+
 		SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_CLR_PERR);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		/* HW-Bug #8: cleared by GMF_CLI_TX_FC instead of GMF_CLI_TX_PE */
 		SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T),
-			(SK_U8)((pAC->GIni.GIChipRev == 0) ? GMF_CLI_TX_FC : GMF_CLI_TX_PE));
+			(SK_U8)((pAC->GIni.GIChipId == CHIP_ID_YUKON &&
+			pAC->GIni.GIChipRev == 0) ? GMF_CLI_TX_FC : GMF_CLI_TX_PE));
 	}
-
+#endif /* YUKON */
+	
 	if (pPrt->PCheckPar) {
+
 		if (Port == MAC_1) {
 			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E016, SKERR_SIRQ_E016MSG);
 		}
@@ -654,6 +728,7 @@
 		}
 		Para.Para64 = Port;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
+		
 		Para.Para32[0] = Port;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 
@@ -661,15 +736,21 @@
 	}
 
 	/* Check whether frames with a size of 1k were sent */
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* Snap statistic counters */
 		(void)SkXmUpdateStats(pAC, IoC, Port);
 		
 		(void)SkXmMacStatistic(pAC, IoC, Port, XM_TXF_MAX_SZ, &TxMax);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
+
 		(void)SkGmMacStatistic(pAC, IoC, Port, GM_TXF_1518B, &TxMax);
 	}
+#endif /* YUKON */
 	
 	if (TxMax > 0) {
 		/* From now on check the parity */
@@ -680,11 +761,11 @@
 
 /******************************************************************************
  *
- *	Hardware Error service routine
+ *	SkGeHwErr() - Hardware Error service routine
  *
- * Description:
+ * Description: handles all HW Error interrupts
  *
- * Notes:
+ * Returns: N/A
  */
 static void SkGeHwErr(
 SK_AC	*pAC,		/* adapter context */
@@ -707,50 +788,62 @@
 		SK_IN16(IoC, PCI_C(PCI_STATUS), &Word);
 		
 		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
-		SK_OUT16(IoC, PCI_C(PCI_STATUS), Word | PCI_ERRBITS);
+        SK_OUT16(IoC, PCI_C(PCI_STATUS), (SK_U16)(Word | PCI_ERRBITS));
 		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
 		Para.Para64 = 0;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
 	}
 
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
+
 		if ((HwStatus & IS_NO_STAT_M1) != 0) {
 			/* Ignore it */
 			/* This situation is also indicated in the descriptor */
 			SK_OUT16(IoC, MR_ADDR(MAC_1, RX_MFF_CTRL1), MFF_CLR_INSTAT);
 		}
-	
+
 		if ((HwStatus & IS_NO_STAT_M2) != 0) {
 			/* Ignore it */
 			/* This situation is also indicated in the descriptor */
 			SK_OUT16(IoC, MR_ADDR(MAC_2, RX_MFF_CTRL1), MFF_CLR_INSTAT);
 		}
-	
+
 		if ((HwStatus & IS_NO_TIST_M1) != 0) {
 			/* Ignore it */
 			/* This situation is also indicated in the descriptor */
 			SK_OUT16(IoC, MR_ADDR(MAC_1, RX_MFF_CTRL1), MFF_CLR_INTIST);
 		}
-	
+
 		if ((HwStatus & IS_NO_TIST_M2) != 0) {
 			/* Ignore it */
 			/* This situation is also indicated in the descriptor */
 			SK_OUT16(IoC, MR_ADDR(MAC_2, RX_MFF_CTRL1), MFF_CLR_INTIST);
 		}
 	}
-	else {	/* YUKON */
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		/* This is necessary only for Rx timing measurements */
 		if ((HwStatus & IS_IRQ_TIST_OV) != 0) {
+			/* increment Time Stamp Timer counter (high) */
+			pAC->GIni.GITimeStampCnt++;
+
 			/* Clear Time Stamp Timer IRQ */
 			SK_OUT8(IoC, GMAC_TI_ST_CTRL, (SK_U8)GMT_ST_CLR_IRQ);
 		}
 
 		if ((HwStatus & IS_IRQ_SENSOR) != 0) {
-			/* Clear I2C IRQ */
-			SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
+			/* no sensors on 32-bit Yukon */
+			if (pAC->GIni.GIYukon32Bit) {
+				/* disable HW Error IRQ */
+				pAC->GIni.GIValIrqMask &= ~IS_HW_ERR;
+			}
 		}
 	}
+#endif /* YUKON */
 
 	if ((HwStatus & IS_RAM_RD_PAR) != 0) {
 		SK_OUT16(IoC, B3_RI_CTRL, RI_CLR_RD_PERR);
@@ -781,6 +874,7 @@
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E018, SKERR_SIRQ_E018MSG);
 		Para.Para64 = MAC_1;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
+		
 		Para.Para32[0] = MAC_1;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
@@ -792,6 +886,7 @@
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E019, SKERR_SIRQ_E019MSG);
 		Para.Para64 = MAC_2;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
+		
 		Para.Para32[0] = MAC_2;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
@@ -800,11 +895,11 @@
 
 /******************************************************************************
  *
- *	Interrupt service routine
+ *	SkGeSirqIsr() - Special Interrupt Service Routine
  *
- * Description:
+ * Description: handles all non data transfer specific interrupts (slow path)
  *
- * Notes:
+ * Returns: N/A
  */
 void SkGeSirqIsr(
 SK_AC	*pAC,		/* adapter context */
@@ -814,13 +909,10 @@
 	SK_EVPARA	Para;
 	SK_U32		RegVal32;	/* Read register value */
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
-	unsigned 	Len;
-	SK_U64		Octets;
 	SK_U16 		PhyInt;
-	SK_U16 		PhyIMsk;
 	int			i;
 
-	if ((Istatus & IS_HW_ERR) != 0) {
+	if (((Istatus & IS_HW_ERR) & pAC->GIni.GIValIrqMask) != 0) {
 		/* read the HW Error Interrupt source */
 		SK_IN32(IoC, B0_HWE_ISRC, &RegVal32);
 		
@@ -866,32 +958,47 @@
 		/* May be a normal situation in a server with a slow network */
 		SK_OUT16(IoC, B3_PA_CTRL, PA_CLR_TO_TX1);
 
-		/*
-		 * workaround: if in half duplex mode, check for Tx hangup.
-		 * Read number of TX'ed bytes, wait for 10 ms, then compare
-		 * the number with current value. If nothing changed, we assume
-		 * that Tx is hanging and do a FIFO flush (see event routine).
-		 */
-		if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF ||
-		    pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) &&
-		    !pPrt->HalfDupTimerActive) {
+#ifdef GENESIS
+		if (pAC->GIni.GIGenesis) {
 			/*
-			 * many more pack. arb. timeouts may come in between,
-			 * we ignore those
+			 * workaround: if in half duplex mode, check for Tx hangup.
+			 * Read number of TX'ed bytes, wait for 10 ms, then compare
+			 * the number with current value. If nothing changed, we assume
+			 * that Tx is hanging and do a FIFO flush (see event routine).
 			 */
-			pPrt->HalfDupTimerActive = SK_TRUE;
+			if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF ||
+				pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) &&
+				!pPrt->HalfDupTimerActive) {
+				/*
+				 * many more pack. arb. timeouts may come in between,
+				 * we ignore those
+				 */
+				pPrt->HalfDupTimerActive = SK_TRUE;
+#ifdef XXX
+				Len = sizeof(SK_U64);
+				SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
+					&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, 0),
+					pAC->Rlmt.Port[0].Net->NetNumber);
+				
+				pPrt->LastOctets = Octets;
+#endif /* XXX */
+				/* Snap statistic counters */
+				(void)SkXmUpdateStats(pAC, IoC, 0);
 
-			Len = sizeof(SK_U64);
-			SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
-				&Len, (SK_U32) SK_PNMI_PORT_PHYS2INST(pAC, 0),
-				pAC->Rlmt.Port[0].Net->NetNumber);
-			
-			pPrt->LastOctets = Octets;
-			
-			Para.Para32[0] = 0;
-			SkTimerStart(pAC, IoC, &pPrt->HalfDupChkTimer, SK_HALFDUP_CHK_TIME,
-				SKGE_HWAC, SK_HWEV_HALFDUP_CHK, Para);
+				(void)SkXmMacStatistic(pAC, IoC, 0, XM_TXO_OK_HI, &RegVal32);
+
+				pPrt->LastOctets = (SK_U64)RegVal32 << 32;
+				
+				(void)SkXmMacStatistic(pAC, IoC, 0, XM_TXO_OK_LO, &RegVal32);
+
+				pPrt->LastOctets += RegVal32;
+				
+				Para.Para32[0] = 0;
+				SkTimerStart(pAC, IoC, &pPrt->HalfDupChkTimer, SK_HALFDUP_CHK_TIME,
+					SKGE_HWAC, SK_HWEV_HALFDUP_CHK, Para);
+			}
 		}
+#endif /* GENESIS */
 	}
 
 	if ((Istatus & IS_PA_TO_TX2) != 0) {
@@ -901,23 +1008,38 @@
 		/* May be a normal situation in a server with a slow network */
 		SK_OUT16(IoC, B3_PA_CTRL, PA_CLR_TO_TX2);
 
-		/* workaround: see above */
-		if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF ||
-		     pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) &&
-		    !pPrt->HalfDupTimerActive) {
-			pPrt->HalfDupTimerActive = SK_TRUE;
-
-			Len = sizeof(SK_U64);
-			SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
-				&Len, (SK_U32) SK_PNMI_PORT_PHYS2INST(pAC, 1),
-				pAC->Rlmt.Port[1].Net->NetNumber);
-			
-			pPrt->LastOctets = Octets;
-			
-			Para.Para32[0] = 1;
-			SkTimerStart(pAC, IoC, &pPrt->HalfDupChkTimer, SK_HALFDUP_CHK_TIME,
-				SKGE_HWAC, SK_HWEV_HALFDUP_CHK, Para);
+#ifdef GENESIS
+		if (pAC->GIni.GIGenesis) {
+			/* workaround: see above */
+			if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF ||
+				 pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) &&
+				!pPrt->HalfDupTimerActive) {
+				pPrt->HalfDupTimerActive = SK_TRUE;
+#ifdef XXX
+				Len = sizeof(SK_U64);
+				SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
+					&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, 1),
+					pAC->Rlmt.Port[1].Net->NetNumber);
+				
+				pPrt->LastOctets = Octets;
+#endif /* XXX */
+				/* Snap statistic counters */
+				(void)SkXmUpdateStats(pAC, IoC, 1);
+
+				(void)SkXmMacStatistic(pAC, IoC, 1, XM_TXO_OK_HI, &RegVal32);
+
+				pPrt->LastOctets = (SK_U64)RegVal32 << 32;
+				
+				(void)SkXmMacStatistic(pAC, IoC, 1, XM_TXO_OK_LO, &RegVal32);
+
+				pPrt->LastOctets += RegVal32;
+				
+				Para.Para32[0] = 1;
+				SkTimerStart(pAC, IoC, &pPrt->HalfDupChkTimer, SK_HALFDUP_CHK_TIME,
+					SKGE_HWAC, SK_HWEV_HALFDUP_CHK, Para);
+			}
 		}
+#endif /* GENESIS */
 	}
 
 	/* Check interrupts of the particular queues */
@@ -998,59 +1120,69 @@
 				continue;
 			}
 			
-			switch (pPrt->PhyType) {
-			
-			case SK_PHY_XMAC:
-				break;
-			
-			case SK_PHY_BCOM:
-				SkXmPhyRead(pAC, IoC, i, PHY_BCOM_INT_STAT, &PhyInt);
-				SkXmPhyRead(pAC, IoC, i, PHY_BCOM_INT_MASK, &PhyIMsk);
-
-				if ((PhyInt & ~PhyIMsk) != 0) {
-					SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-						("Port %d Bcom Int: 0x%04X Mask: 0x%04X\n",
-						i, PhyInt, PhyIMsk));
-					SkPhyIsrBcom(pAC, IoC, i, PhyInt);
+#ifdef GENESIS
+			if (pAC->GIni.GIGenesis) {
+				
+				switch (pPrt->PhyType) {
+				
+				case SK_PHY_XMAC:
+					break;
+				
+				case SK_PHY_BCOM:
+					SkXmPhyRead(pAC, IoC, i, PHY_BCOM_INT_STAT, &PhyInt);
+	
+					if ((PhyInt & ~PHY_B_DEF_MSK) != 0) {
+						SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+							("Port %d Bcom Int: 0x%04X\n",
+							i, PhyInt));
+						SkPhyIsrBcom(pAC, IoC, i, PhyInt);
+					}
+					break;
+#ifdef OTHER_PHY
+				case SK_PHY_LONE:
+					SkXmPhyRead(pAC, IoC, i, PHY_LONE_INT_STAT, &PhyInt);
+					
+					if ((PhyInt & PHY_L_DEF_MSK) != 0) {
+						SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+							("Port %d Lone Int: %x\n",
+							i, PhyInt));
+						SkPhyIsrLone(pAC, IoC, i, PhyInt);
+					}
+					break;
+#endif /* OTHER_PHY */
 				}
-				break;
-			
-			case SK_PHY_MARV_COPPER:
-			case SK_PHY_MARV_FIBER:
+			}
+#endif /* GENESIS */
+	
+#ifdef YUKON
+			if (pAC->GIni.GIYukon) {
+				/* Read PHY Interrupt Status */
 				SkGmPhyRead(pAC, IoC, i, PHY_MARV_INT_STAT, &PhyInt);
-				SkGmPhyRead(pAC, IoC, i, PHY_MARV_INT_MASK, &PhyIMsk);
 
-				if ((PhyInt & PhyIMsk) != 0) {
+				if ((PhyInt & PHY_M_DEF_MSK) != 0) {
 					SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-						("Port %d Marv Int: 0x%04X Mask: 0x%04X\n",
-						i, PhyInt, PhyIMsk));
+						("Port %d Marv Int: 0x%04X\n",
+						i, PhyInt));
 					SkPhyIsrGmac(pAC, IoC, i, PhyInt);
 				}
-				break;
-
-#ifdef OTHER_PHY
-			case SK_PHY_LONE:
-				SkXmPhyRead(pAC, IoC, i, PHY_LONE_INT_STAT, &PhyInt);
-				SkXmPhyRead(pAC, IoC, i, PHY_LONE_INT_ENAB, &PhyIMsk);
-				
-				if ((PhyInt & PhyIMsk) != 0) {
-					SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-						("Port %d Lone Int: %x Mask: %x\n",
-						i, PhyInt, PhyIMsk));
-					SkPhyIsrLone(pAC, IoC, i, PhyInt);
-				}
-				break;
-			case SK_PHY_NAT:
-				/* todo: National */
-				break;
-#endif /* OTHER_PHY */
 			}
+#endif /* YUKON */
 		}
 	}
 
 	/* I2C Ready interrupt */
 	if ((Istatus & IS_I2C_READY) != 0) {
+#ifdef SK_SLIM
+        SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
+#else		
 		SkI2cIsr(pAC, IoC);
+#endif		
+	}
+
+	/* SW forced interrupt */
+	if ((Istatus & IS_IRQ_SW) != 0) {
+		/* clear the software IRQ */
+		SK_OUT8(IoC, B0_CTST, CS_CL_SW_IRQ);
 	}
 
 	if ((Istatus & IS_LNK_SYNC_M1) != 0) {
@@ -1085,20 +1217,30 @@
 
 	/* Timer interrupt (served last) */
 	if ((Istatus & IS_TIMINT) != 0) {
+		/* check for HW Errors */
+		if (((Istatus & IS_HW_ERR) & ~pAC->GIni.GIValIrqMask) != 0) {
+			/* read the HW Error Interrupt source */
+			SK_IN32(IoC, B0_HWE_ISRC, &RegVal32);
+
+			SkGeHwErr(pAC, IoC, RegVal32);
+		}
+
 		SkHwtIsr(pAC, IoC);
 	}
+
 }	/* SkGeSirqIsr */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
- * SkGePortCheckShorts - Implementing XMAC Workaround Errata # 2
+ * SkGePortCheckShorts() - Implementing XMAC Workaround Errata # 2
  *
  * return:
  *	0	o.k. nothing needed
  *	1	Restart needed on this port
  */
-static int	SkGePortCheckShorts(
+static int SkGePortCheckShorts(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
 int		Port)		/* Which port should be checked */
@@ -1123,13 +1265,15 @@
 	(void)SkXmMacStatistic(pAC, IoC, Port, XM_RXE_SHT_ERR, &Shorts);
 
 	/*
-	 * Read Rx counter (packets seen on the network and not necessarily
+	 * Read Rx counters (packets seen on the network and not necessarily
 	 * really received.
 	 */
 	RxCts = 0;
 
 	for (i = 0; i < sizeof(SkGeRxRegs)/sizeof(SkGeRxRegs[0]); i++) {
+		
 		(void)SkXmMacStatistic(pAC, IoC, Port, SkGeRxRegs[i], &RxTmp);
+		
 		RxCts += (SK_U64)RxTmp;
 	}
 
@@ -1199,44 +1343,76 @@
 
 	return(Rtv);
 }	/* SkGePortCheckShorts */
+#endif /* GENESIS */
 
 
 /******************************************************************************
  *
- * SkGePortCheckUp - Implementation of the Workaround for Errata #2
+ * SkGePortCheckUp() - Check if the link is up
  *
  * return:
  *	0	o.k. nothing needed
  *	1	Restart needed on this port
  *	2	Link came up
  */
-static int	SkGePortCheckUp(
+static int SkGePortCheckUp(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
 int		Port)		/* Which port should be checked */
 {
-	switch (pAC->GIni.GP[Port].PhyType) {
-	case SK_PHY_XMAC:
-		return(SkGePortCheckUpXmac(pAC, IoC, Port));
-	case SK_PHY_BCOM:
-		return(SkGePortCheckUpBcom(pAC, IoC, Port));
-	case SK_PHY_MARV_COPPER:
-	case SK_PHY_MARV_FIBER:
-		return(SkGePortCheckUpGmac(pAC, IoC, Port));
+	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
+	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
+	int			Rtv;		/* Return value */
+
+	Rtv = SK_HW_PS_NONE;
+	
+	pPrt = &pAC->GIni.GP[Port];
+
+	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
+		AutoNeg = SK_FALSE;
+	}
+	else {
+		AutoNeg = SK_TRUE;
+	}
+
+#ifdef GENESIS
+	if (pAC->GIni.GIGenesis) {
+
+		switch (pPrt->PhyType) {
+		
+		case SK_PHY_XMAC:
+			Rtv = SkGePortCheckUpXmac(pAC, IoC, Port, AutoNeg);
+			break;
+		case SK_PHY_BCOM:
+			Rtv = SkGePortCheckUpBcom(pAC, IoC, Port, AutoNeg);
+			break;
 #ifdef OTHER_PHY
-	case SK_PHY_LONE:
-		return(SkGePortCheckUpLone(pAC, IoC, Port));
-	case SK_PHY_NAT:
-		return(SkGePortCheckUpNat(pAC, IoC, Port));
+		case SK_PHY_LONE:
+			Rtv = SkGePortCheckUpLone(pAC, IoC, Port, AutoNeg);
+			break;
+		case SK_PHY_NAT:
+			Rtv = SkGePortCheckUpNat(pAC, IoC, Port, AutoNeg);
+			break;
 #endif /* OTHER_PHY */
+		}
 	}
-	return(SK_HW_PS_NONE);
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
+		
+		Rtv = SkGePortCheckUpGmac(pAC, IoC, Port, AutoNeg);
+	}
+#endif /* YUKON */
+
+	return(Rtv);	
 }	/* SkGePortCheckUp */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
- * SkGePortCheckUpXmac - Implementing of the Workaround Errata # 2
+ * SkGePortCheckUpXmac() - Implementing of the Workaround Errata # 2
  *
  * return:
  *	0	o.k. nothing needed
@@ -1246,7 +1422,8 @@
 static int SkGePortCheckUpXmac(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
-int		Port)		/* Which port should be checked */
+int		Port,		/* Which port should be checked */
+SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	SK_U32		Shorts;		/* Short Event Counter */
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
@@ -1257,7 +1434,6 @@
 	SK_U16		LpAb;		/* Link Partner Ability */
 	SK_U16		ResAb;		/* Resolved Ability */
 	SK_U16		ExtStat;	/* Extended Status Register */
-	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
 	SK_U8		NextMode;	/* Next AutoSensing Mode */
 
 	pPrt = &pAC->GIni.GP[Port];
@@ -1275,13 +1451,6 @@
 	pPrt->PIsave = 0;
 
 	/* Now wait for each port's link */
-	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
-		AutoNeg = SK_FALSE;
-	}
-	else {
-		AutoNeg = SK_TRUE;
-	}
-
 	if (pPrt->PLinkBroken) {
 		/* Link was broken */
 		XM_IN32(IoC, Port, XM_GP_PORT, &GpReg);
@@ -1291,6 +1460,7 @@
 			XM_IN16(IoC, Port, XM_ISRC, &Isrc);
 			IsrcSum |= Isrc;
 			SkXmAutoNegLipaXmac(pAC, IoC, Port, IsrcSum);
+			
 			if ((Isrc & XM_IS_INP_ASS) == 0) {
 				/* It has been in sync since last time */
 				/* Restart the PORT */
@@ -1329,7 +1499,7 @@
 					("Do NOT restart on Port %d %x %x\n", Port, Isrc, IsrcSum));
 			}
 			else {
-				pPrt->PIsave = IsrcSum & XM_IS_AND;
+				pPrt->PIsave = (SK_U16)(IsrcSum & XM_IS_AND);
 				
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("Save Sync/nosync Port %d %x %x\n", Port, Isrc, IsrcSum));
@@ -1370,6 +1540,7 @@
 		}
 		else {
 			SkXmAutoNegLipaXmac(pAC, IoC, Port, Isrc);
+			
 			if (SkGePortCheckShorts(pAC, IoC, Port) == SK_HW_PS_RESTART) {
 				return(SK_HW_PS_RESTART);
 			}
@@ -1389,7 +1560,7 @@
 	if ((GpReg & XM_GP_INP_ASS) != 0 || (IsrcSum & XM_IS_INP_ASS) != 0) {
 		if ((GpReg & XM_GP_INP_ASS) == 0) {
 			/* Save Auto-negotiation Done interrupt only if link is in sync */
-			pPrt->PIsave = IsrcSum & XM_IS_AND;
+			pPrt->PIsave = (SK_U16)(IsrcSum & XM_IS_AND);
 		}
 #ifdef DEBUG
 		if ((pPrt->PIsave & XM_IS_AND) != 0) {
@@ -1497,7 +1668,7 @@
 
 /******************************************************************************
  *
- * SkGePortCheckUpBcom - Check, if the link is up
+ * SkGePortCheckUpBcom() - Check if the link is up on Bcom PHY
  *
  * return:
  *	0	o.k. nothing needed
@@ -1505,9 +1676,10 @@
  *	2	Link came up
  */
 static int SkGePortCheckUpBcom(
-SK_AC	*pAC,	/* Adapter Context */
-SK_IOC	IoC,	/* IO Context */
-int		Port)	/* Which port should be checked */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* IO Context */
+int		Port,		/* Which port should be checked */
+SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	int			Done;
@@ -1519,7 +1691,6 @@
 	SK_U16		LpAb;
 	SK_U16		ExtStat;
 #endif /* DEBUG */
-	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
 
 	pPrt = &pAC->GIni.GP[Port];
 
@@ -1596,7 +1767,7 @@
 
 	if ((Isrc & (PHY_B_IS_NO_HDCL /* | PHY_B_IS_NO_HDC */)) != 0) {
 		/*
-		 * Workaround BCOM Errata:
+		 * Workaround BCom Errata:
 		 *	enable and disable loopback mode if "NO HCD" occurs.
 		 */
 		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_CTRL, &Ctrl);
@@ -1689,14 +1860,6 @@
 	}
 #endif /* DEBUG */
 
-	/* Now wait for each port's link */
-	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
-		AutoNeg = SK_FALSE;
-	}
-	else {
-		AutoNeg = SK_TRUE;
-	}
-
 	/*
 	 * Here we usually can check whether the link is in sync and
 	 * auto-negotiation is done.
@@ -1707,7 +1870,7 @@
 	SkMacAutoNegLipaPhy(pAC, IoC, Port, PhyStat);
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNeg: %d, PhyStat: 0x%04x\n", AutoNeg, PhyStat));
+		("AutoNeg: %d, PhyStat: 0x%04X\n", AutoNeg, PhyStat));
 
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ResAb);
 
@@ -1715,6 +1878,7 @@
 		/* Error */
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("Master/Slave Fault port %d\n", Port));
+		
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
 		
@@ -1729,7 +1893,7 @@
 		SK_MS_STAT_MASTER : SK_MS_STAT_SLAVE;
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNeg: %d, PhyStat: 0x%04x\n", AutoNeg, PhyStat));
+		("Port %d, ResAb: 0x%04X\n", Port, ResAb));
 
 	if (AutoNeg) {
 		if ((PhyStat & PHY_ST_AN_OVER) != 0) {
@@ -1793,16 +1957,19 @@
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 			("Link sync(GP), Port %d\n", Port));
 		SkHWLinkUp(pAC, IoC, Port);
+		
 		return(SK_HW_PS_LINK);
 	}
 
 	return(SK_HW_PS_NONE);
 }	/* SkGePortCheckUpBcom */
+#endif /* GENESIS */
 
 
+#ifdef YUKON
 /******************************************************************************
  *
- * SkGePortCheckUpGmac - Check, if the link is up
+ * SkGePortCheckUpGmac() - Check if the link is up on Marvell PHY
  *
  * return:
  *	0	o.k. nothing needed
@@ -1810,44 +1977,43 @@
  *	2	Link came up
  */
 static int SkGePortCheckUpGmac(
-SK_AC	*pAC,	/* Adapter Context */
-SK_IOC	IoC,	/* IO Context */
-int		Port)	/* Which port should be checked */
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* IO Context */
+int		Port,		/* Which port should be checked */
+SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	int			Done;
-	SK_U16		Isrc;		/* Interrupt source */
-	SK_U16		PhyStat;	/* Phy Status */
-	SK_U16		PhySpecStat;/* Phy Specific Status */
+	SK_U16		PhyIsrc;	/* PHY Interrupt source */
+	SK_U16		PhyStat;	/* PPY Status */
+	SK_U16		PhySpecStat;/* PHY Specific Status */
 	SK_U16		ResAb;		/* Master/Slave resolution */
-	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
+	SK_EVPARA	Para;
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	/* Read PHY Interrupt Status */
-	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_INT_STAT, &Isrc);
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_INT_STAT, &PhyIsrc);
 
-	if ((Isrc & PHY_M_IS_AN_COMPL) != 0) {
-		/* TBD */
+	if ((PhyIsrc & PHY_M_IS_AN_COMPL) != 0) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Auto-Negotiation Completed, PhyIsrc: 0x%04X\n", PhyIsrc));
 	}
 
-	if (pPrt->PHWLinkUp) {
-		return(SK_HW_PS_NONE);
+	if ((PhyIsrc & PHY_M_IS_LSP_CHANGE) != 0) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Link Speed Changed, PhyIsrc: 0x%04X\n", PhyIsrc));
 	}
 
-	/* Now wait for each port's link */
-	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
-		AutoNeg = SK_FALSE;
-	}
-	else {
-		AutoNeg = SK_TRUE;
+	if (pPrt->PHWLinkUp) {
+		return(SK_HW_PS_NONE);
 	}
 
 	/* Read PHY Status */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_STAT, &PhyStat);
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNeg: %d, PhyStat: 0x%04x\n", AutoNeg, PhyStat));
+		("AutoNeg: %d, PhyStat: 0x%04X\n", AutoNeg, PhyStat));
 
 	SkMacAutoNegLipaPhy(pAC, IoC, Port, PhyStat);
 	
@@ -1857,6 +2023,7 @@
 		/* Error */
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("Master/Slave Fault port %d\n", Port));
+		
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
 		
@@ -1867,12 +2034,24 @@
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &PhySpecStat);
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNeg: %d, PhySpecStat: 0x%04x\n", AutoNeg, PhySpecStat));
+		("AutoNeg: %d, PhySpecStat: 0x%04X\n", AutoNeg, PhySpecStat));
 
 	if ((PhySpecStat & PHY_M_PS_LINK_UP) == 0) {
 		return(SK_HW_PS_NONE);
 	}
 	
+	if ((PhySpecStat & PHY_M_PS_DOWNS_STAT) != 0 ||
+		(PhyIsrc & PHY_M_IS_DOWNSH_DET) != 0) {
+		/* Downshift detected */
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E025, SKERR_SIRQ_E025MSG);
+		
+		Para.Para64 = Port;
+		SkEventQueue(pAC, SKGE_DRV, SK_DRV_DOWNSHIFT_DET, Para);
+		
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Downshift detected, PhyIsrc: 0x%04X\n", PhyIsrc));
+	}
+
 	pPrt->PMSStatus = ((ResAb & PHY_B_1000S_MSR) != 0) ?
 		SK_MS_STAT_MASTER : SK_MS_STAT_SLAVE;
 	
@@ -1913,12 +2092,13 @@
 
 	return(SK_HW_PS_NONE);
 }	/* SkGePortCheckUpGmac */
+#endif /* YUKON */
 
 
 #ifdef OTHER_PHY
 /******************************************************************************
  *
- * SkGePortCheckUpLone - Check if the link is up
+ * SkGePortCheckUpLone() - Check if the link is up on Level One PHY
  *
  * return:
  *	0	o.k. nothing needed
@@ -1928,7 +2108,8 @@
 static int SkGePortCheckUpLone(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
-int		Port)		/* Which port should be checked */
+int		Port,		/* Which port should be checked */
+SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	int			Done;
@@ -1937,7 +2118,6 @@
 	SK_U16		ExtStat;	/* Extended Status Register */
 	SK_U16		PhyStat;	/* Phy Status Register */
 	SK_U16		StatSum;
-	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
 	SK_U8		NextMode;	/* Next AutoSensing Mode */
 
 	pPrt = &pAC->GIni.GP[Port];
@@ -1949,14 +2129,6 @@
 	StatSum = pPrt->PIsave;
 	pPrt->PIsave = 0;
 
-	/* Now wait for each ports link */
-	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
-		AutoNeg = SK_FALSE;
-	}
-	else {
-		AutoNeg = SK_TRUE;
-	}
-
 	/*
 	 * here we usually can check whether the link is in sync and
 	 * auto-negotiation is done.
@@ -2049,6 +2221,7 @@
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 			("Link sync(GP), Port %d\n", Port));
 		SkHWLinkUp(pAC, IoC, Port);
+		
 		return(SK_HW_PS_LINK);
 	}
 
@@ -2058,7 +2231,7 @@
 
 /******************************************************************************
  *
- * SkGePortCheckUpNat - Check if the link is up
+ * SkGePortCheckUpNat() - Check if the link is up on National PHY
  *
  * return:
  *	0	o.k. nothing needed
@@ -2068,7 +2241,8 @@
 static int SkGePortCheckUpNat(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
-int		Port)		/* Which port should be checked */
+int		Port,		/* Which port should be checked */
+SK_BOOL	AutoNeg)	/* Is Auto-negotiation used ? */
 {
 	/* todo: National */
 	return(SK_HW_PS_NONE);
@@ -2078,7 +2252,7 @@
 
 /******************************************************************************
  *
- *	Event service routine
+ *	SkGeSirqEvent() - Event Service Routine
  *
  * Description:
  *
@@ -2090,13 +2264,14 @@
 SK_U32		Event,		/* Module specific Event */
 SK_EVPARA	Para)		/* Event specific Parameter */
 {
-	SK_U64		Octets;
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	SK_U32		Port;
-	SK_U32		Time;
-	unsigned	Len;
+	SK_U32		Val32;
 	int			PortStat;
 	SK_U8		Val8;
+#ifdef GENESIS
+	SK_U64		Octets;
+#endif /* GENESIS */
 
 	Port = Para.Para32[0];
 	pPrt = &pAC->GIni.GP[Port];
@@ -2104,15 +2279,13 @@
 	switch (Event) {
 	case SK_HWEV_WATIM:
 		/* Check whether port came up */
-		PortStat = SkGePortCheckUp(pAC, IoC, Port);
+		PortStat = SkGePortCheckUp(pAC, IoC, (int)Port);
 
 		switch (PortStat) {
 		case SK_HW_PS_RESTART:
 			if (pPrt->PHWLinkUp) {
-				/*
-				 * Set Link to down.
-				 */
-				SkHWLinkDown(pAC, IoC, Port);
+				/* Set Link to down */
+				SkHWLinkDown(pAC, IoC, (int)Port);
 
 				/*
 				 * Signal directly to RLMT to ensure correct
@@ -2129,20 +2302,19 @@
 			/* Signal to RLMT */
 			SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_UP, Para);
 			break;
-
 		}
 		
 		/* Start again the check Timer */
 		if (pPrt->PHWLinkUp) {
-			Time = SK_WA_ACT_TIME;
+			Val32 = SK_WA_ACT_TIME;
 		}
 		else {
-			Time = SK_WA_INA_TIME;
+			Val32 = SK_WA_INA_TIME;
 		}
 
 		/* Todo: still needed for non-XMAC PHYs??? */
 		/* Start workaround Errata #2 timer */
-		SkTimerStart(pAC, IoC, &pPrt->PWaTimer, Time,
+		SkTimerStart(pAC, IoC, &pPrt->PWaTimer, Val32,
 			SKGE_HWAC, SK_HWEV_WATIM, Para);
 		break;
 
@@ -2155,7 +2327,7 @@
 			SkRlmtEvent(pAC, IoC, SK_RLMT_LINK_DOWN, Para);
 		}
 
-		SkHWLinkDown(pAC, IoC, Port);
+		SkHWLinkDown(pAC, IoC, (int)Port);
 
 		/* Schedule Port RESET */
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_RESET, Para);
@@ -2177,7 +2349,7 @@
 		/* Stop Workaround Timer */
 		SkTimerStop(pAC, IoC, &pPrt->PWaTimer);
 
-		SkHWLinkDown(pAC, IoC, Port);
+		SkHWLinkDown(pAC, IoC, (int)Port);
 		break;
 
 	case SK_HWEV_UPDATE_STAT:
@@ -2224,7 +2396,7 @@
 		}
 		Val8 = (SK_U8)Para.Para32[1];
 		if (pPrt->PMSMode != Val8) {
-			/* Set New link mode */
+			/* Set New Role (Master/Slave) mode */
 			pPrt->PMSMode = Val8;
 
 			/* Restart Port */
@@ -2248,26 +2420,41 @@
 		}
 		break;
 
+#ifdef GENESIS
 	case SK_HWEV_HALFDUP_CHK:
-		/*
-		 * half duplex hangup workaround.
-		 * See packet arbiter timeout interrupt for description
-		 */
-		pPrt->HalfDupTimerActive = SK_FALSE;
-		if (pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF ||
-		    pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) {
-			
-			Len = sizeof(SK_U64);
-			SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
-				&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, Port),
-				pAC->Rlmt.Port[Port].Net->NetNumber);
-			
-			if (pPrt->LastOctets == Octets) {
-				/* Tx hanging, a FIFO flush restarts it */
-				SkMacFlushTxFifo(pAC, IoC, Port);
+		if (pAC->GIni.GIGenesis) {
+			/*
+			 * half duplex hangup workaround.
+			 * See packet arbiter timeout interrupt for description
+			 */
+			pPrt->HalfDupTimerActive = SK_FALSE;
+			if (pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF ||
+				pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) {
+#ifdef XXX
+				Len = sizeof(SK_U64);
+				SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
+					&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, Port),
+					pAC->Rlmt.Port[Port].Net->NetNumber);
+#endif /* XXX */
+				/* Snap statistic counters */
+				(void)SkXmUpdateStats(pAC, IoC, Port);
+
+				(void)SkXmMacStatistic(pAC, IoC, Port, XM_TXO_OK_HI, &Val32);
+
+				Octets = (SK_U64)Val32 << 32;
+				
+				(void)SkXmMacStatistic(pAC, IoC, Port, XM_TXO_OK_LO, &Val32);
+
+				Octets += Val32;
+				
+				if (pPrt->LastOctets == Octets) {
+					/* Tx hanging, a FIFO flush restarts it */
+					SkMacFlushTxFifo(pAC, IoC, Port);
+				}
 			}
 		}
 		break;
+#endif /* GENESIS */
 	
 	default:
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_SIRQ_E001, SKERR_SIRQ_E001MSG);
@@ -2278,11 +2465,12 @@
 }	/* SkGeSirqEvent */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
- *	SkPhyIsrBcom - PHY interrupt service routine
+ *	SkPhyIsrBcom() - PHY interrupt service routine
  *
- * Description: handle all interrupts from BCOM PHY
+ * Description: handles all interrupts from BCom PHY
  *
  * Returns: N/A
  */
@@ -2299,15 +2487,15 @@
 
 	if ((IStatus & PHY_B_IS_PSE) != 0) {
 		/* Incorrectable pair swap error */
-		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E022,
+		SK_ERR_LOG(pAC, SK_ERRCL_HW | SK_ERRCL_INIT, SKERR_SIRQ_E022,
 			SKERR_SIRQ_E022MSG);
 	}
 	
 	if ((IStatus & (PHY_B_IS_AN_PR | PHY_B_IS_LST_CHANGE)) != 0) {
-		Para.Para32[0] = (SK_U32)Port;
 
 		SkHWLinkDown(pAC, IoC, Port);
 
+		Para.Para32[0] = (SK_U32)Port;
 		/* Signal to RLMT */
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 
@@ -2317,13 +2505,15 @@
 	}
 
 }	/* SkPhyIsrBcom */
+#endif /* GENESIS */
 
 
+#ifdef YUKON
 /******************************************************************************
  *
- *	SkPhyIsrGmac - PHY interrupt service routine
+ *	SkPhyIsrGmac() - PHY interrupt service routine
  *
- * Description: handle all interrupts from Marvell PHY
+ * Description: handles all interrupts from Marvell PHY
  *
  * Returns: N/A
  */
@@ -2335,14 +2525,27 @@
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 	SK_EVPARA	Para;
+	SK_U16		Word;
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	if ((IStatus & (PHY_M_IS_AN_PR | PHY_M_IS_LST_CHANGE)) != 0) {
-		Para.Para32[0] = (SK_U32)Port;
 
 		SkHWLinkDown(pAC, IoC, Port);
 
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_ADV, &Word);
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNeg.Adv: 0x%04X\n", Word));
+		
+		/* Set Auto-negotiation advertisement */
+		if (pPrt->PFlowCtrlMode == SK_FLOW_MODE_SYM_OR_REM) {
+			/* restore Asymmetric Pause bit */
+			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_AUNE_ADV,
+				(SK_U16)(Word | PHY_M_AN_ASP));
+		}
+		
+		Para.Para32[0] = (SK_U32)Port;
 		/* Signal to RLMT */
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
@@ -2352,23 +2555,21 @@
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E023, SKERR_SIRQ_E023MSG);
 	}
 	
-	if ((IStatus & PHY_M_IS_LSP_CHANGE) != 0) {
-		/* TBD */
-	}
-	
 	if ((IStatus & PHY_M_IS_FIFO_ERROR) != 0) {
 		/* FIFO Overflow/Underrun Error */
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E024, SKERR_SIRQ_E024MSG);
 	}
+	
 }	/* SkPhyIsrGmac */
+#endif /* YUKON */
 
 
 #ifdef OTHER_PHY
 /******************************************************************************
  *
- *	SkPhyIsrLone - PHY interrupt service routine
+ *	SkPhyIsrLone() - PHY interrupt service routine
  *
- * Description: handle all interrupts from LONE PHY
+ * Description: handles all interrupts from LONE PHY
  *
  * Returns: N/A
  */
@@ -2381,10 +2582,11 @@
 	SK_EVPARA	Para;
 
 	if (IStatus & (PHY_L_IS_DUP | PHY_L_IS_ISOL)) {
+		
 		SkHWLinkDown(pAC, IoC, Port);
 
-		/* Signal to RLMT */
 		Para.Para32[0] = (SK_U32)Port;
+		/* Signal to RLMT */
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
 
diff -Nru a/drivers/net/sk98lin/ski2c.c b/drivers/net/sk98lin/ski2c.c
--- a/drivers/net/sk98lin/ski2c.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/ski2c.c	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,15 @@
  *
  * Name:	ski2c.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.56 $
- * Date:	$Date: 2002/12/19 14:20:41 $
+ * Version:	$Revision: 1.57 $
+ * Date:	$Date: 2003/01/28 09:17:38 $
  * Purpose:	Functions to access Voltage and Temperature Sensor
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +26,10 @@
  * History:
  *
  *	$Log: ski2c.c,v $
+ *	Revision 1.57  2003/01/28 09:17:38  rschmidt
+ *	Fixed handling for sensors on YUKON Fiber.
+ *	Editorial changes.
+ *	
  *	Revision 1.56  2002/12/19 14:20:41  rschmidt
  *	Added debugging code in SkI2cWait().
  *	Replaced all I2C-write operations with function SkI2cWrite().
@@ -228,7 +232,7 @@
  *	I2C Protocol
  */
 static const char SysKonnectFileId[] =
-	"$Id: ski2c.c,v 1.56 2002/12/19 14:20:41 rschmidt Exp $";
+	"$Id: ski2c.c,v 1.57 2003/01/28 09:17:38 rschmidt Exp $";
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/lm80.h"
@@ -249,7 +253,7 @@
 	The Genesis has 2 I2C buses. One for the EEPROM which holds
 	the VPD Data and one for temperature and voltage sensor.
 	The following picture shows the I2C buses, I2C devices and
-	there control registers.
+	their control registers.
 
 	Note: The VPD functions are in skvpd.c
 .
@@ -314,23 +318,23 @@
  * If new devices are added to the I2C bus the timing values have to be checked.
  */
 #ifndef I2C_SLOW_TIMING
-#define	T_CLK_LOW		1300L	/* clock low time in ns */
-#define	T_CLK_HIGH		 600L	/* clock high time in ns */
+#define	T_CLK_LOW			1300L	/* clock low time in ns */
+#define	T_CLK_HIGH		 	 600L	/* clock high time in ns */
 #define T_DATA_IN_SETUP		 100L	/* data in Set-up Time */
 #define T_START_HOLD		 600L	/* start condition hold time */
 #define T_START_SETUP		 600L	/* start condition Set-up time */
 #define	T_STOP_SETUP		 600L	/* stop condition Set-up time */
-#define T_BUS_IDLE		1300L	/* time the bus must free after Tx */
+#define T_BUS_IDLE			1300L	/* time the bus must free after Tx */
 #define	T_CLK_2_DATA_OUT	 900L	/* max. clock low to data output valid */
 #else	/* I2C_SLOW_TIMING */
 /* I2C Standard Mode Timing */
-#define	T_CLK_LOW		4700L	/* clock low time in ns */
-#define	T_CLK_HIGH		4000L	/* clock high time in ns */
+#define	T_CLK_LOW			4700L	/* clock low time in ns */
+#define	T_CLK_HIGH			4000L	/* clock high time in ns */
 #define T_DATA_IN_SETUP		 250L	/* data in Set-up Time */
 #define T_START_HOLD		4000L	/* start condition hold time */
 #define T_START_SETUP		4700L	/* start condition Set-up time */
 #define	T_STOP_SETUP		4000L	/* stop condition Set-up time */
-#define T_BUS_IDLE		4700L	/* time the bus must free after Tx */
+#define T_BUS_IDLE			4700L	/* time the bus must free after Tx */
 #endif	/* !I2C_SLOW_TIMING */
 
 #define NS2BCLK(x)	(((x)*125)/10000)
@@ -858,18 +862,18 @@
 	
 	pPrt = &pAC->GIni.GP[0];
 	
-    switch (pPrt->PhyType) {
-	case SK_PHY_BCOM:
-		if (pAC->GIni.GIMacsFound == 1) {
-			pAC->I2c.MaxSens += 1;
-		}
-		else {
-			pAC->I2c.MaxSens += 3;
+	if (pAC->GIni.GIGenesis) {
+		if (pPrt->PhyType == SK_PHY_BCOM) {
+			if (pAC->GIni.GIMacsFound == 1) {
+				pAC->I2c.MaxSens += 1;
+			}
+			else {
+				pAC->I2c.MaxSens += 3;
+			}
 		}
-		break;
-	case SK_PHY_MARV_COPPER:
+	}
+	else {
 		pAC->I2c.MaxSens += 3;
-		break;
 	}
 	
 	for (i = 0; i < pAC->I2c.MaxSens; i++) {
@@ -912,14 +916,23 @@
 			pAC->I2c.SenTable[i].SenReg = LM80_VT2_IN;
 			break;
 		case 4:
-			if (pPrt->PhyType == SK_PHY_BCOM) {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY A PLL";
-				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
-				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
-				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
-				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
+			if (pAC->GIni.GIGenesis) {
+				if (pPrt->PhyType == SK_PHY_BCOM) {
+					pAC->I2c.SenTable[i].SenDesc = "Voltage PHY A PLL";
+					pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
+					pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
+				}
+				else {
+					pAC->I2c.SenTable[i].SenDesc = "Voltage PMA";
+					pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
+					pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
+				}
 			}
-			else if (pPrt->PhyType == SK_PHY_MARV_COPPER) {
+			else {
 				pAC->I2c.SenTable[i].SenDesc = "Voltage VAUX";
 				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_VAUX_3V3_HIGH_ERR;
 				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_VAUX_3V3_HIGH_WARN;
@@ -932,40 +945,33 @@
 					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VAUX_0V_WARN_ERR;
 				}
 			}
-			else {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage PMA";
-				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
-				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
-				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
-				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
-			}
 			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
 			pAC->I2c.SenTable[i].SenReg = LM80_VT3_IN;
 			break;
 		case 5:
-			if (pPrt->PhyType == SK_PHY_MARV_COPPER) {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage ASIC-Co 1V5";
-				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_CORE_1V5_HIGH_ERR;
-				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_CORE_1V5_HIGH_WARN;
-				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_CORE_1V5_LOW_WARN;
-				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_CORE_1V5_LOW_ERR;
-			}
-			else {
+			if (pAC->GIni.GIGenesis) {
 				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
 				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PHY_2V5_HIGH_ERR;
 				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PHY_2V5_HIGH_WARN;
 				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PHY_2V5_LOW_WARN;
 				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
 			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage ASIC-Co 1V5";
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_CORE_1V5_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_CORE_1V5_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_CORE_1V5_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_CORE_1V5_LOW_ERR;
+			}
 			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
 			pAC->I2c.SenTable[i].SenReg = LM80_VT4_IN;
 			break;
 		case 6:
-			if (pPrt->PhyType == SK_PHY_MARV_COPPER) {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 3V3";
+			if (pAC->GIni.GIGenesis) {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY B PLL";
 			}
 			else {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY B PLL";
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 3V3";
 			}
 			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
 			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
@@ -975,16 +981,7 @@
 			pAC->I2c.SenTable[i].SenReg = LM80_VT5_IN;
 			break;
 		case 7:
-			if (pPrt->PhyType == SK_PHY_MARV_COPPER) {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
-				pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PHY_2V5_HIGH_ERR;
-				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PHY_2V5_HIGH_WARN;
-				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PHY_2V5_LOW_WARN;
-				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
-				pAC->I2c.SenTable[i].SenReg = LM80_VT6_IN;
-			}
-			else {
+			if (pAC->GIni.GIGenesis) {
 				pAC->I2c.SenTable[i].SenDesc = "Speed Fan";
 				pAC->I2c.SenTable[i].SenType = SK_SEN_FAN;
 				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_FAN_HIGH_ERR;
@@ -992,6 +989,15 @@
 				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_FAN_LOW_WARN;
 				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_FAN_LOW_ERR;
 				pAC->I2c.SenTable[i].SenReg = LM80_FAN2_IN;
+			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
+				pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PHY_2V5_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PHY_2V5_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PHY_2V5_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
+				pAC->I2c.SenTable[i].SenReg = LM80_VT6_IN;
 			}
 			break;
 		default:
diff -Nru a/drivers/net/sk98lin/skproc.c b/drivers/net/sk98lin/skproc.c
--- a/drivers/net/sk98lin/skproc.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skproc.c	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,15 @@
  *
  * Name:    skproc.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.3 $
- * Date:    $Date: 2002/10/02 12:59:51 $
+ * Version:	$Revision: 1.2 $
+ * Date:    $Date: 2003/08/12 16:45:29 $
  * Purpose:	Funktions to display statictic data
  *
  ******************************************************************************/
  
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -28,6 +28,28 @@
  * History:
  *
  *	$Log: skproc.c,v $
+ *	Revision 1.2  2003/08/12 16:45:29  mlindner
+ *	Add: Removed SkNumber and SkDoDiv
+ *	Add: Counter output as (unsigned long long)
+ *	
+ *	Revision 1.1  2003/07/18 13:39:57  rroesler
+ *	Fix: Re-enter after CVS crash
+ *	
+ *	Revision 1.8  2003/06/27 14:41:42  rroesler
+ *	Corrected compiler-warning kernel 2.2
+ *	
+ *	Revision 1.7  2003/06/27 12:09:51  rroesler
+ *	corrected minor edits
+ *	
+ *	Revision 1.6  2003/05/26 12:58:53  mlindner
+ *	Add: Support for Kernel 2.5/2.6
+ *	
+ *	Revision 1.5  2003/03/19 14:40:47  mlindner
+ *	Fix: Editorial changes
+ *	
+ *	Revision 1.4  2003/02/25 14:16:37  mlindner
+ *	Fix: Copyright statement
+ *	
  *	Revision 1.3  2002/10/02 12:59:51  mlindner
  *	Add: Support for Yukon
  *	Add: Speed check and setup
@@ -71,29 +93,22 @@
 
 #include "h/skdrv1st.h"
 #include "h/skdrv2nd.h"
-#define ZEROPAD		1		/* pad with zero */
-#define SIGN		2		/* unsigned/signed long */
-#define PLUS		4		/* show plus */
-#define SPACE		8		/* space if plus */
-#define LEFT		16		/* left justified */
-#define SPECIALX	32		/* 0x */
-#define LARGE		64
-
-extern SK_AC				*pACList;
-extern struct net_device 	*SkGeRootDev;
-
-extern char * SkNumber(
-	char * str,
-	long long num,
-	int base,
-	int size,
-	int precision,
-	int type);
+
+	extern struct net_device	*SkGeRootDev;
+
+
+int sk_proc_read(char *buffer,
+				char **buffer_location,
+				off_t offset,
+				int buffer_length,
+				int *eof,
+				void *data);
+
 
 
 /*****************************************************************************
  *
- * 	proc_read - print "summaries" entry 
+ * 	sk_proc_read - print "summaries" entry 
  *
  * Description:
  *  This function fills the proc entry with statistic data about 
@@ -103,7 +118,7 @@
  * Returns: buffer with statistic data
  *	
  */
-int proc_read(char *buffer,
+int sk_proc_read(char *buffer,
 char **buffer_location,
 off_t offset,
 int buffer_length,
@@ -115,9 +130,8 @@
 	int i;
 	DEV_NET					*pNet;
 	SK_AC					*pAC;
-	char 					test_buf[100];
 	char					sens_msg[50];
-	unsigned long			Flags;		
+	unsigned long			Flags;	
 	unsigned int			Size;
 	struct SK_NET_DEVICE 		*next;
 	struct SK_NET_DEVICE 		*SkgeProcDev = SkGeRootDev;
@@ -225,13 +239,11 @@
 				"\nReceive statistics\n\n");
 
 				len += sprintf(buffer + len,
-					"Received bytes                 %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxOctetsOkCts,
-					10,0,-1,0));
-				len += sprintf(buffer + len,
-					"Received packets               %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxOkCts,
-					10,0,-1,0));
+					"Received bytes                 %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxOctetsOkCts);
+				len += sprintf(buffer + len,
+					"Received packets               %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxOkCts);
 #if 0
 				if (pAC->GIni.GP[0].PhyType == SK_PHY_XMAC && 
 					pAC->HWRevision < 12) {
@@ -245,71 +257,56 @@
 						pPnmiStat->StatRxTooLongCts;
 
 				len += sprintf(buffer + len,
-					"Receive errors                 %s\n",
-					SkNumber(test_buf, pPnmiStruct->InErrorsCts,
-					10,0,-1,0));
-				len += sprintf(buffer + len,
-					"Receive drops                  %s\n",
-					SkNumber(test_buf, pPnmiStruct->RxNoBufCts,
-					10,0,-1,0));
-				len += sprintf(buffer + len,
-					"Received multicast             %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxMulticastOkCts,
-					10,0,-1,0));
+					"Receive errors                 %Ld\n",
+					(unsigned long long) pPnmiStruct->InErrorsCts);
+				len += sprintf(buffer + len,
+					"Receive dropped                %Ld\n",
+					(unsigned long long) pPnmiStruct->RxNoBufCts);
+				len += sprintf(buffer + len,
+					"Received multicast             %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxMulticastOkCts);
 				len += sprintf(buffer + len,
 					"Receive error types\n");
 				len += sprintf(buffer + len,
-					"   length                      %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxRuntCts,
-					10, 0, -1, 0));
-				len += sprintf(buffer + len,
-					"   buffer overflow             %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxFifoOverflowCts,
-					10, 0, -1, 0));
-				len += sprintf(buffer + len,
-					"   bad crc                     %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxFcsCts,
-					10, 0, -1, 0));
-				len += sprintf(buffer + len,
-					"   framing                     %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxFramingCts,
-					10, 0, -1, 0));
-				len += sprintf(buffer + len,
-					"   missed frames               %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxMissedCts,
-					10, 0, -1, 0));
+					"   length                      %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxRuntCts);
+				len += sprintf(buffer + len,
+					"   buffer overflow             %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxFifoOverflowCts);
+				len += sprintf(buffer + len,
+					"   bad crc                     %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxFcsCts);
+				len += sprintf(buffer + len,
+					"   framing                     %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxFramingCts);
+				len += sprintf(buffer + len,
+					"   missed frames               %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxMissedCts);
 
 				if (pNet->Mtu > 1500)
 					pPnmiStat->StatRxTooLongCts = 0;
 
 				len += sprintf(buffer + len,
-					"   too long                    %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxTooLongCts,
-					10, 0, -1, 0));					
-				len += sprintf(buffer + len,
-					"   carrier extension           %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxCextCts,
-					10, 0, -1, 0));				
-				len += sprintf(buffer + len,
-					"   too short                   %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxShortsCts,
-					10, 0, -1, 0));				
-				len += sprintf(buffer + len,
-					"   symbol                      %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxSymbolCts,
-					10, 0, -1, 0));				
-				len += sprintf(buffer + len,
-					"   LLC MAC size                %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxIRLengthCts,
-					10, 0, -1, 0));				
-				len += sprintf(buffer + len,
-					"   carrier event               %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxCarrierCts,
-					10, 0, -1, 0));				
-				len += sprintf(buffer + len,
-					"   jabber                      %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxJabberCts,
-					10, 0, -1, 0));				
+					"   too long                    %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxTooLongCts);					
+				len += sprintf(buffer + len,
+					"   carrier extension           %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxCextCts);				
+				len += sprintf(buffer + len,
+					"   too short                   %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxShortsCts);				
+				len += sprintf(buffer + len,
+					"   symbol                      %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxSymbolCts);				
+				len += sprintf(buffer + len,
+					"   LLC MAC size                %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxIRLengthCts);				
+				len += sprintf(buffer + len,
+					"   carrier event               %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxCarrierCts);				
+				len += sprintf(buffer + len,
+					"   jabber                      %Ld\n",
+					(unsigned long long) pPnmiStat->StatRxJabberCts);				
 
 
 				/*Transmit statistics */
@@ -317,42 +314,34 @@
 				"\nTransmit statistics\n\n");
 				
 				len += sprintf(buffer + len,
-					"Transmited bytes               %s\n",
-					SkNumber(test_buf, pPnmiStat->StatTxOctetsOkCts,
-					10,0,-1,0));
-				len += sprintf(buffer + len,
-					"Transmited packets             %s\n",
-					SkNumber(test_buf, pPnmiStat->StatTxOkCts,
-					10,0,-1,0));
-				len += sprintf(buffer + len,
-					"Transmit errors                %s\n",
-					SkNumber(test_buf, pPnmiStat->StatTxSingleCollisionCts,
-					10,0,-1,0));
-				len += sprintf(buffer + len,
-					"Transmit dropped               %s\n",
-					SkNumber(test_buf, pPnmiStruct->TxNoBufCts,
-					10,0,-1,0));
-				len += sprintf(buffer + len,
-					"Transmit collisions            %s\n",
-					SkNumber(test_buf, pPnmiStat->StatTxSingleCollisionCts,
-					10,0,-1,0));
+					"Transmited bytes               %Ld\n",
+					(unsigned long long) pPnmiStat->StatTxOctetsOkCts);
 				len += sprintf(buffer + len,
-					"Transmit errors types\n");
+					"Transmited packets             %Ld\n",
+					(unsigned long long) pPnmiStat->StatTxOkCts);
+				len += sprintf(buffer + len,
+					"Transmit errors                %Ld\n",
+					(unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
+				len += sprintf(buffer + len,
+					"Transmit dropped               %Ld\n",
+					(unsigned long long) pPnmiStruct->TxNoBufCts);
+				len += sprintf(buffer + len,
+					"Transmit collisions            %Ld\n",
+					(unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
+				len += sprintf(buffer + len,
+					"Transmit error types\n");
 				len += sprintf(buffer + len,
 					"   excessive collision         %ld\n",
 					pAC->stats.tx_aborted_errors);
 				len += sprintf(buffer + len,
-					"   carrier                     %s\n",
-					SkNumber(test_buf, pPnmiStat->StatTxCarrierCts,
-					10, 0, -1, 0));
-				len += sprintf(buffer + len,
-					"   fifo underrun               %s\n",
-					SkNumber(test_buf, pPnmiStat->StatTxFifoUnderrunCts,
-					10, 0, -1, 0));
-				len += sprintf(buffer + len,
-					"   heartbeat                   %s\n",
-					SkNumber(test_buf, pPnmiStat->StatTxCarrierCts,
-					10, 0, -1, 0));
+					"   carrier                     %Ld\n",
+					(unsigned long long) pPnmiStat->StatTxCarrierCts);
+				len += sprintf(buffer + len,
+					"   fifo underrun               %Ld\n",
+					(unsigned long long) pPnmiStat->StatTxFifoUnderrunCts);
+				len += sprintf(buffer + len,
+					"   heartbeat                   %Ld\n",
+					(unsigned long long) pPnmiStat->StatTxCarrierCts);
 				len += sprintf(buffer + len,
 					"   window                      %ld\n",
 					pAC->stats.tx_window_errors);
@@ -372,141 +361,5 @@
 	}
 	return (min_t(int, buffer_length, len - offset));
 }
-
-
-
-
-
-/*****************************************************************************
- *
- * SkDoDiv - convert 64bit number
- *
- * Description:
- *	This function "converts" a long long number.
- *
- * Returns:
- *	remainder of division
- */
-static long SkDoDiv (long long Dividend, int Divisor, long long *pErg)
-{
- long   	Rest;
- long long 	Ergebnis;
- long   	Akku;
-
-
- Akku  = Dividend >> 32;
-
- Ergebnis = ((long long) (Akku / Divisor)) << 32;
- Rest = Akku % Divisor ;
-
- Akku = Rest << 16;
- Akku |= ((Dividend & 0xFFFF0000) >> 16);
-
-
- Ergebnis += ((long long) (Akku / Divisor)) << 16;
- Rest = Akku % Divisor ;
-
- Akku = Rest << 16;
- Akku |= (Dividend & 0xFFFF);
-
- Ergebnis += (Akku / Divisor);
- Rest = Akku % Divisor ;
-
- *pErg = Ergebnis;
- return (Rest);
-}
-
-
-#if 0
-#define do_div(n,base) ({ \
-long long __res; \
-__res = ((unsigned long long) n) % (unsigned) base; \
-n = ((unsigned long long) n) / (unsigned) base; \
-__res; })
-
-#endif
-
-
-/*****************************************************************************
- *
- * SkNumber - Print results
- *
- * Description:
- *	This function converts a long long number into a string.
- *
- * Returns:
- *	number as string
- */
-char * SkNumber(char * str, long long num, int base, int size, int precision
-	,int type)
-{
-	char c,sign,tmp[66], *strorg = str;
-	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
-	int i;
-
-	if (type & LARGE)
-		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
-	if (type & LEFT)
-		type &= ~ZEROPAD;
-	if (base < 2 || base > 36)
-		return 0;
-	c = (type & ZEROPAD) ? '0' : ' ';
-	sign = 0;
-	if (type & SIGN) {
-		if (num < 0) {
-			sign = '-';
-			num = -num;
-			size--;
-		} else if (type & PLUS) {
-			sign = '+';
-			size--;
-		} else if (type & SPACE) {
-			sign = ' ';
-			size--;
-		}
-	}
-	if (type & SPECIALX) {
-		if (base == 16)
-			size -= 2;
-		else if (base == 8)
-			size--;
-	}
-	i = 0;
-	if (num == 0)
-		tmp[i++]='0';
-	else while (num != 0)
-		tmp[i++] = digits[SkDoDiv(num,base, &num)];
-
-	if (i > precision)
-		precision = i;
-	size -= precision;
-	if (!(type&(ZEROPAD+LEFT)))
-		while(size-->0)
-			*str++ = ' ';
-	if (sign)
-		*str++ = sign;
-	if (type & SPECIALX) {
-		if (base==8)
-			*str++ = '0';
-		else if (base==16) {
-			*str++ = '0';
-			*str++ = digits[33];
-		}
-	}
-	if (!(type & LEFT))
-		while (size-- > 0)
-			*str++ = c;
-	while (i < precision--)
-		*str++ = '0';
-	while (i-- > 0)
-		*str++ = tmp[i];
-	while (size-- > 0)
-		*str++ = ' ';
-	
-	str[0] = '\0';
-	
-	return strorg;
-}
-
 
 
diff -Nru a/drivers/net/sk98lin/skqueue.c b/drivers/net/sk98lin/skqueue.c
--- a/drivers/net/sk98lin/skqueue.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skqueue.c	Wed Sep  3 22:38:48 2003
@@ -1,17 +1,17 @@
 /******************************************************************************
  *
  * Name:	skqueue.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.18 $
- * Date:	$Date: 2002/05/07 14:11:11 $
+ * Project:	Gigabit Ethernet Adapters, Schedule-Modul
+ * Version:	$Revision: 1.19 $
+ * Date:	$Date: 2003/05/13 18:00:07 $
  * Purpose:	Management of an event queue.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +27,10 @@
  * History:
  *
  *	$Log: skqueue.c,v $
+ *	Revision 1.19  2003/05/13 18:00:07  mkarl
+ *	Removed calls to RLMT, TWSI, and PNMI for SLIM driver (SK_SLIM).
+ *	Editorial changes.
+ *	
  *	Revision 1.18  2002/05/07 14:11:11  rwahl
  *	Fixed Watcom Precompiler error.
  *	
@@ -90,8 +94,10 @@
 /*
 	Event queue and dispatcher
 */
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/skqueue.c,v 1.18 2002/05/07 14:11:11 rwahl Exp $" ;
+	"$Header: /usr56/projects/ge/schedule/skqueue.c,v 1.19 2003/05/13 18:00:07 mkarl Exp $" ;
+#endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skqueue.h"		/* Queue Definitions */
@@ -171,7 +177,8 @@
 	while (pEv != pAC->Event.EvPut) {
 		PRINTF("dispatch Class %d Event %d\n",pEv->Class,pEv->Event) ;
 		switch(Class = pEv->Class) {
-#ifndef SK_USE_LAC_EV        
+#ifndef SK_USE_LAC_EV
+#ifndef SK_SLIM
 		case SKGE_RLMT :	/* RLMT Event */
 			Rtv = SkRlmtEvent(pAC,Ioc,pEv->Event,pEv->Para);
 			break ;
@@ -181,7 +188,8 @@
 		case SKGE_PNMI :
 			Rtv = SkPnmiEvent(pAC,Ioc,pEv->Event,pEv->Para);
 			break ;
-#endif /* SK_USE_LAC_EV */
+#endif	/* not SK_SLIM */
+#endif	/* not SK_USE_LAC_EV */
 		case SKGE_DRV :		/* Driver Event */
 			Rtv = SkDrvEvent(pAC,Ioc,pEv->Event,pEv->Para);
 			break ;
diff -Nru a/drivers/net/sk98lin/skrlmt.c b/drivers/net/sk98lin/skrlmt.c
--- a/drivers/net/sk98lin/skrlmt.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skrlmt.c	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skrlmt.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.65 $
- * Date:	$Date: 2002/07/22 14:29:48 $
+ * Version:	$Revision: 1.69 $
+ * Date:	$Date: 2003/04/15 09:39:22 $
  * Purpose:	Manage links on SK-NET Adapters, esp. redundant ones.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,20 @@
  * History:
  *
  *	$Log: skrlmt.c,v $
+ *	Revision 1.69  2003/04/15 09:39:22  tschilli
+ *	Copyright messages changed.
+ *	"#error C++ is not yet supported." removed.
+ *	
+ *	Revision 1.68  2003/01/31 15:26:56  rschmidt
+ *	Added init for local variables in RlmtInit().
+ *	
+ *	Revision 1.67  2003/01/31 14:12:41  mkunz
+ *	single port adapter runs now with two identical MAC addresses
+ *	
+ *	Revision 1.66  2002/09/23 15:14:19  rwahl
+ *	- Reset broadcast timestamp on link down.
+ *	- Editorial corrections.
+ *	
  *	Revision 1.65  2002/07/22 14:29:48  rwahl
  *	- Removed BRK statement from debug check.
  *	
@@ -272,13 +287,12 @@
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skrlmt.c,v 1.65 2002/07/22 14:29:48 rwahl Exp $ (C) SysKonnect.";
+	"@(#) $Id: skrlmt.c,v 1.69 2003/04/15 09:39:22 tschilli Exp $ (C) Marvell.";
 #endif	/* !defined(lint) */
 
 #define __SKRLMT_C
 
 #ifdef __cplusplus
-#error C++ is not yet supported.
 extern "C" {
 #endif	/* cplusplus */
 
@@ -578,6 +592,10 @@
 	SK_U32		i, j;
 	SK_U64		Random;
 	SK_EVPARA	Para;
+    SK_MAC_ADDR		VirtualMacAddress;
+    SK_MAC_ADDR		PhysicalAMacAddress;
+    SK_BOOL		VirtualMacAddressSet;
+    SK_BOOL		PhysicalAMacAddressSet;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_INIT,
 		("RLMT Init level %d.\n", Level))
@@ -625,7 +643,7 @@
 		pAC->Rlmt.Net[0].NumPorts = pAC->GIni.GIMacsFound;
 
 		/* Initialize HW registers? */
-		if (pAC->GIni.GIMacsFound < 2) {
+		if (pAC->GIni.GIMacsFound == 1) {
 			Para.Para32[0] = SK_RLMT_MODE_CLS;
 			Para.Para32[1] = 0;
 			(void)SkRlmtEvent(pAC, IoC, SK_RLMT_MODE_CHANGE, Para);
@@ -661,6 +679,38 @@
 
 			(void)SkAddrMcUpdate(pAC, IoC, i);
 		}
+
+    	VirtualMacAddressSet = SK_FALSE;
+		/* Read virtual MAC address from Control Register File. */
+		for (j = 0; j < SK_MAC_ADDR_LEN; j++) {
+			
+            SK_IN8(IoC, B2_MAC_1 + j, &VirtualMacAddress.a[j]);
+            VirtualMacAddressSet |= VirtualMacAddress.a[j];
+		}
+    	
+        PhysicalAMacAddressSet = SK_FALSE;
+		/* Read physical MAC address for MAC A from Control Register File. */
+		for (j = 0; j < SK_MAC_ADDR_LEN; j++) {
+			
+            SK_IN8(IoC, B2_MAC_2 + j, &PhysicalAMacAddress.a[j]);
+            PhysicalAMacAddressSet |= PhysicalAMacAddress.a[j];
+		}
+
+        /* check if the two mac addresses contain reasonable values */
+        if (!VirtualMacAddressSet || !PhysicalAMacAddressSet) {
+
+            pAC->Rlmt.RlmtOff = SK_TRUE;
+        }
+
+        /* if the two mac addresses are equal switch off the RLMT_PRE_LOOKAHEAD
+           and the RLMT_LOOKAHEAD macros */
+        else if (SK_ADDR_EQUAL(PhysicalAMacAddress.a, VirtualMacAddress.a)) {
+
+            pAC->Rlmt.RlmtOff = SK_TRUE;
+        }
+		else {
+			pAC->Rlmt.RlmtOff = SK_FALSE;
+		}
 		break;
 
 	default:	/* error */
@@ -760,7 +810,7 @@
 	}
 #endif	/* DEBUG */
 
-	return;       
+	return;
 }	/* SkRlmtBuildCheckChain */
 
 
@@ -847,7 +897,7 @@
 		}
 	}
 
-	return (pMb);       
+	return (pMb);
 }	/* SkRlmtBuildPacket */
 
 
@@ -929,7 +979,7 @@
 		pAC->Rlmt.Port[PortNumber].TxSpHelloReqCts++;
 	}
 
-	return (pMb);       
+	return (pMb);
 }	/* SkRlmtBuildSpanningTreePacket */
 
 
@@ -996,8 +1046,8 @@
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_TX,
 				("SkRlmtSend: BPDU Packet on Port %u.\n", PortNumber))
 		}
-	}   
-	return;   
+	}
+	return;
 }	/* SkRlmtSend */
 
 
@@ -1337,7 +1387,7 @@
 					pRPort->Root.Id[0], pRPort->Root.Id[1],
 					pRPort->Root.Id[2], pRPort->Root.Id[3],
 					pRPort->Root.Id[4], pRPort->Root.Id[5],
-					pRPort->Root.Id[6], pRPort->Root.Id[7]))      
+					pRPort->Root.Id[6], pRPort->Root.Id[7]))
 		}
 
 		SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
@@ -1500,10 +1550,10 @@
 			SkRlmtCheckSwitch(pAC, IoC, pRPort->Net->NetNumber);
 		}
 
-		NewTimeout = SK_RLMT_DEF_TO_VAL;              
+		NewTimeout = SK_RLMT_DEF_TO_VAL;
 	}
 
-	return (NewTimeout);       
+	return (NewTimeout);
 }	/* SkRlmtCheckPort */
 
 
@@ -1537,13 +1587,14 @@
 	
 	/* Select port with the latest TimeStamp. */
 	for (i = 0; i < (SK_U32)pAC->GIni.GIMacsFound; i++) {
-#ifdef DEBUG
+
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("TimeStamp Port %d: %08x %08x.\n",
+			("TimeStamp Port %d (Down: %d, NoRx: %d): %08x %08x.\n",
 				i,
+   				pAC->Rlmt.Port[i].PortDown, pAC->Rlmt.Port[i].PortNoRx,
 				*((SK_U32*)(&pAC->Rlmt.Port[i].BcTimeStamp) + OFFS_HI32),
 				*((SK_U32*)(&pAC->Rlmt.Port[i].BcTimeStamp) + OFFS_LO32)))
-#endif	/* DEBUG */
+
 		if (!pAC->Rlmt.Port[i].PortDown && !pAC->Rlmt.Port[i].PortNoRx) {
 			if (!PortFound || pAC->Rlmt.Port[i].BcTimeStamp > BcTimeStamp) {
 				BcTimeStamp = pAC->Rlmt.Port[i].BcTimeStamp;
@@ -1568,10 +1619,9 @@
 				pAC->Rlmt.Port[i].BcTimeStamp +
 				 SK_RLMT_BC_DELTA > BcTimeStamp)) {
 				PortFound = SK_FALSE;
-#ifdef DEBUG
+				
 				SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 					("Port %d received a broadcast at a similar time.\n", i))
-#endif	/* DEBUG */
 				break;
 			}
 		}
@@ -1580,8 +1630,8 @@
 #ifdef DEBUG
 	if (PortFound) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_CHECK_SWITCH found Port %d receiving the substantially "
-			 "latest broadcast (%d).\n",
+			("SK_RLMT_SELECT_BCRX found Port %d receiving the substantially "
+			 "latest broadcast (%u).\n",
 				*pSelect,
 				BcTimeStamp - pAC->Rlmt.Port[1 - *pSelect].BcTimeStamp))
 	}
@@ -1631,7 +1681,7 @@
 			}
 			PortFound = SK_TRUE;
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_CHECK_SWITCH found Port %d up and not check RX.\n",
+				("SK_RLMT_SELECT_NOTSUSPECT found Port %d up and not check RX.\n",
 					*pSelect))
 			break;
 		}
@@ -1681,7 +1731,7 @@
 			}
 			PortFound = SK_TRUE;
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_CHECK_SWITCH found Port %d up.\n", *pSelect))
+				("SK_RLMT_SELECT_UP found Port %d up.\n", *pSelect))
 			break;
 		}
 	}
@@ -1742,7 +1792,7 @@
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_CHECK_SWITCH found Port %d going up.\n", *pSelect))
+		("SK_RLMT_SELECT_GOINGUP found Port %d going up.\n", *pSelect))
 	return (SK_TRUE);
 }	/* SkRlmtSelectGoingUp */
 
@@ -1788,7 +1838,7 @@
 			}
 			PortFound = SK_TRUE;
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_CHECK_SWITCH found Port %d down.\n", *pSelect))
+				("SK_RLMT_SELECT_DOWN found Port %d down.\n", *pSelect))
 			break;
 		}
 	}
@@ -2426,6 +2476,7 @@
 	pRPort->PacketsPerTimeSlot = 0;
 	/* pRPort->DataPacketsPerTimeSlot = 0; */
 	pRPort->BpduPacketsPerTimeSlot = 0;
+	pRPort->BcTimeStamp = 0;
 
 	/*
 	 * RA;:;: To be checked:
@@ -2696,7 +2747,7 @@
 	}
 
 	/* Stop RLMT timers. */
-	SkTimerStop(pAC, IoC, &pAC->Rlmt.Net[Para.Para32[0]].LocTimer); 
+	SkTimerStop(pAC, IoC, &pAC->Rlmt.Net[Para.Para32[0]].LocTimer);
 	SkTimerStop(pAC, IoC, &pAC->Rlmt.Net[Para.Para32[0]].SegTimer);
 
 	/* Stop net. */
@@ -2896,7 +2947,7 @@
 		}
 	}
 #endif	/* xDEBUG */
-				   
+				
 	SkRlmtCheckSeg(pAC, IoC, Para.Para32[0]);
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
@@ -3284,7 +3335,7 @@
 
 	Para.Para32[0] |= SK_RLMT_CHECK_LINK;
 
-	if (pAC->Rlmt.Net[Para.Para32[1]].NumPorts < 2 &&
+	if ((pAC->Rlmt.Net[Para.Para32[1]].NumPorts == 1) &&
 		Para.Para32[0] != SK_RLMT_MODE_CLS) {
 		pAC->Rlmt.Net[Para.Para32[1]].RlmtMode = SK_RLMT_MODE_CLS;
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
@@ -3447,7 +3498,7 @@
 		break;
 	}	/* switch() */
 
-	return (0);       
+	return (0);
 }	/* SkRlmtEvent */
 
 #ifdef __cplusplus
diff -Nru a/drivers/net/sk98lin/sktimer.c b/drivers/net/sk98lin/sktimer.c
--- a/drivers/net/sk98lin/sktimer.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/sktimer.c	Wed Sep  3 22:38:48 2003
@@ -1,17 +1,17 @@
 /******************************************************************************
  *
  * Name:	sktimer.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.12 $
- * Date:	$Date: 1999/11/22 13:38:51 $
+ * Project:	Gigabit Ethernet Adapters, Schedule-Modul
+ * Version:	$Revision: 1.13 $
+ * Date:	$Date: 2003/05/13 18:01:01 $
  * Purpose:	High level timer functions.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: sktimer.c,v $
+ *	Revision 1.13  2003/05/13 18:01:01  mkarl
+ *	Editorial changes.
+ *	
  *	Revision 1.12  1999/11/22 13:38:51  cgoos
  *	Changed license header to GPL.
  *	
@@ -75,8 +78,10 @@
 /*
 	Event queue and dispatcher
 */
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/sktimer.c,v 1.12 1999/11/22 13:38:51 cgoos Exp $" ;
+	"$Header: /usr56/projects/ge/schedule/sktimer.c,v 1.13 2003/05/13 18:01:01 mkarl Exp $" ;
+#endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
diff -Nru a/drivers/net/sk98lin/skvpd.c b/drivers/net/sk98lin/skvpd.c
--- a/drivers/net/sk98lin/skvpd.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skvpd.c	Wed Sep  3 22:38:48 2003
@@ -2,15 +2,15 @@
  *
  * Name:	skvpd.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.32 $
- * Date:	$Date: 2002/10/14 16:04:29 $
+ * Version:	$Revision: 1.37 $
+ * Date:	$Date: 2003/01/13 10:42:45 $
  * Purpose:	Shared software to read and write VPD data
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +26,21 @@
  * History:
  *
  *	$Log: skvpd.c,v $
+ *	Revision 1.37  2003/01/13 10:42:45  rschmidt
+ *	Replaced check for PCI device Id from YUKON with GENESIS
+ *	to set the VPD size in VpdInit()
+ *	Editorial changes
+ *	
+ *	Revision 1.36  2002/11/14 15:16:56  gheinig
+ *	Added const specifier to key and buf parameters for VpdPara, VpdRead
+ *	and VpdWrite for Diag 7 GUI
+ *	
+ *	Revision 1.35  2002/10/21 14:31:59  gheinig
+ *	Took out CVS web garbage at head of file
+ *	
+ *	Revision 1.34  2002/10/21 11:47:24  gheinig
+ *	Reverted to version 1.32 due to unwanted commit
+ *	
  *	Revision 1.32  2002/10/14 16:04:29  rschmidt
  *	Added saving of VPD ROM Size from PCI_OUR_REG_2
  *	Avoid reading of PCI_OUR_REG_2 in VpdTransferBlock()
@@ -95,7 +110,7 @@
  *	chg: VPD_IN/OUT names conform to SK_IN/OUT
  *	add: usage of VPD_IN/OUT8 macros
  *	add: VpdRead/Write Stream functions to r/w a stream of data
- *	fix: VpdTransferBlock swapped illeagal
+ *	fix: VpdTransferBlock swapped illegal
  *	add: VpdMayWrite
  *	
  *	Revision 1.13  1998/10/22 10:02:37  gklug
@@ -111,7 +126,7 @@
  *	Remove CvsId by SysKonnectFileId.
  *	
  *	Revision 1.9  1998/09/16 07:33:52  malthoff
- *	remove memcmp() by SK_MEMCMP and
+ *	replace memcmp() by SK_MEMCMP and
  *	memcpy() by SK_MEMCPY() to be
  *	independent from the 'C' Standard Library.
  *	
@@ -119,7 +134,7 @@
  *	compiler fix: use SK_VPD_KEY instead of S_VPD.
  *	
  *	Revision 1.7  1998/08/19 08:14:01  gklug
- *	fix: remove struct keyword as much as possible from the c-code (see CCC)
+ *	fix: remove struct keyword as much as possible from the C-code (see CCC)
  *	
  *	Revision 1.6  1998/08/18 13:03:58  gklug
  *	SkOsGetTime now returns SK_U64
@@ -149,7 +164,7 @@
 	Please refer skvpd.txt for infomation how to include this module
  */
 static const char SysKonnectFileId[] =
-	"@(#)$Id: skvpd.c,v 1.32 2002/10/14 16:04:29 rschmidt Exp $ (C) SK";
+	"@(#)$Id: skvpd.c,v 1.37 2003/01/13 10:42:45 rschmidt Exp $ (C) SK";
 
 #include "h/skdrv1st.h"
 #include "h/sktypes.h"
@@ -162,7 +177,7 @@
 #ifndef SK_KR_PROTO
 static SK_VPD_PARA	*vpd_find_para(
 	SK_AC	*pAC,
-	char	*key,
+	const char	*key,
 	SK_VPD_PARA *p);
 #else	/* SK_KR_PROTO */
 static SK_VPD_PARA	*vpd_find_para();
@@ -175,7 +190,7 @@
  * returns	0:	success, transfer completes
  *		error	exit(9) with a error message
  */
-static int	VpdWait(
+static int VpdWait(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	IoC,	/* IO Context */
 int		event)	/* event to wait for (VPD_READ / VPD_write) completion*/
@@ -187,7 +202,7 @@
 		("VPD wait for %s\n", event?"Write":"Read"));
 	start_time = SkOsGetTime(pAC);
 	do {
-		if (SkOsGetTime(pAC) - start_time > SK_TICKS_PER_SEC/16) {
+		if (SkOsGetTime(pAC) - start_time > SK_TICKS_PER_SEC) {
 
 			/* Bug fix AF: Thu Mar 28 2002
 			 * Do not call: VPD_STOP(pAC, IoC);
@@ -205,7 +220,9 @@
 				("ERROR:VPD wait timeout\n"));
 			return(1);
 		}
+		
 		VPD_IN16(pAC, IoC, PCI_VPD_ADR_REG, &state);
+		
 		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
 			("state = %x, event %x\n",state,event));
 	} while((int)(state & PCI_VPD_FLAG) == event);
@@ -319,7 +336,7 @@
  *
  * Returns number of bytes read / written.
  */
-static int	VpdWriteStream(
+static int VpdWriteStream(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	IoC,	/* IO Context */
 char	*buf,	/* data buffer */
@@ -391,7 +408,9 @@
 			}
 
 			for (j = 0; j <= (int)(i%sizeof(SK_U32)); j++, pComp++) {
+				
 				VPD_IN8(pAC, IoC, PCI_VPD_DAT_REG + j, &Data);
+				
 				if (Data != *pComp) {
 					/* Verify Error */
 					SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
@@ -412,7 +431,7 @@
  *
  * Returns number of bytes read / written.
  */
-static int	VpdReadStream(
+static int VpdReadStream(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	IoC,	/* IO Context */
 char	*buf,	/* data buffer */
@@ -451,7 +470,7 @@
  *
  * Returns number of bytes read / written.
  */
-static int	VpdTransferBlock(
+static int VpdTransferBlock(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	IoC,	/* IO Context */
 char	*buf,	/* data buffer */
@@ -501,7 +520,7 @@
  *
  * Returns number of bytes read.
  */
-int		VpdReadBlock(
+int VpdReadBlock(
 SK_AC	*pAC,	/* pAC pointer */
 SK_IOC	IoC,	/* IO Context */
 char	*buf,	/* buffer were the data should be stored */
@@ -516,7 +535,7 @@
  *
  * Returns number of bytes writes.
  */
-int		VpdWriteBlock(
+int VpdWriteBlock(
 SK_AC	*pAC,	/* pAC pointer */
 SK_IOC	IoC,	/* IO Context */
 char	*buf,	/* buffer, holds the data to write */
@@ -536,7 +555,7 @@
  * return	0:	success
  *		1:	fatal VPD error
  */
-static int	VpdInit(
+static int VpdInit(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	IoC)	/* IO Context */
 {
@@ -544,12 +563,12 @@
 	int		i;
 	unsigned char	x;
 	int		vpd_size;
-	SK_U16	word;
+	SK_U16	dev_id;
 	SK_U32	our_reg2;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_INIT, ("VpdInit .. "));
 	
-	VPD_IN16(pAC, IoC, PCI_DEVICE_ID, &word);
+	VPD_IN16(pAC, IoC, PCI_DEVICE_ID, &dev_id);
 	
 	VPD_IN32(pAC, IoC, PCI_OUR_REG_2, &our_reg2);
 	
@@ -560,9 +579,9 @@
 	 * therefore we cannot always trust in GIChipId
 	 */
 	if (((pAC->vpd.v.vpd_status & VPD_VALID) == 0 &&
-		word == VPD_PCI_ID_YUKON) ||
+		dev_id != VPD_DEV_ID_GENESIS) ||
 		((pAC->vpd.v.vpd_status & VPD_VALID) != 0 &&
-		!(pAC->GIni.GIGenesis))) {
+		!pAC->GIni.GIGenesis)) {
 
 		/* for Yukon the VPD size is always 256 */
 		vpd_size = VPD_SIZE_YUKON;
@@ -603,7 +622,7 @@
 	pAC->vpd.v.vpd_free_ro = r->p_len - 1;
 
 	/* test the checksum */
-	for (i = 0, x = 0; (unsigned)i<=(unsigned)vpd_size/2 - r->p_len; i++) {
+	for (i = 0, x = 0; (unsigned)i <= (unsigned)vpd_size/2 - r->p_len; i++) {
 		x += pAC->vpd.vpd_buf[i];
 	}
 	
@@ -648,9 +667,9 @@
  *		0:	parameter was not found or VPD encoding error
  */
 static SK_VPD_PARA *vpd_find_para(
-SK_AC *pAC,	/* common data base */
-char *key,		/* keyword to find (e.g. "MN") */
-SK_VPD_PARA *p)	/* parameter description struct */
+SK_AC		*pAC,	/* common data base */
+const char	*key,	/* keyword to find (e.g. "MN") */
+SK_VPD_PARA *p)		/* parameter description struct */
 {
 	char *v	;	/* points to VPD buffer */
 	int max;	/* Maximum Number of Iterations */
@@ -719,9 +738,9 @@
  * returns nothing
  */
 static void vpd_move_para(
-char *start,		/* start of memory block */
-char *end,		/* end of memory block to move */
-int n)			/* number of bytes the memory block has to be moved */
+char	*start,		/* start of memory block */
+char	*end,		/* end of memory block to move */
+int		n)			/* number of bytes the memory block has to be moved */
 {
 	char *p;
 	int i;		/* number of byte copied */
@@ -752,10 +771,10 @@
  * returns nothing
  */
 static void vpd_insert_key(
-char *key,		/* keyword to insert */
-char *buf,		/* buffer with the keyword value */
-int len,		/* length of the value string */
-char *ip)		/* inseration point */
+const char	*key,	/* keyword to insert */
+const char	*buf,	/* buffer with the keyword value */
+int		len,		/* length of the value string */
+char	*ip)		/* inseration point */
 {
 	SK_VPD_KEY *p;
 
@@ -774,8 +793,8 @@
  *		1:	encoding error
  */
 static int vpd_mod_endtag(
-SK_AC *pAC,	/* common data base */
-char *etp)		/* end pointer input position */
+SK_AC	*pAC,		/* common data base */
+char	*etp)		/* end pointer input position */
 {
 	SK_VPD_KEY *p;
 	unsigned char	x;
@@ -839,11 +858,11 @@
  */
 int	VpdSetupPara(
 SK_AC	*pAC,		/* common data base */
-char	*key,		/* keyword to insert */
-char	*buf,		/* buffer with the keyword value */
-int	len,		/* length of the keyword value */
-int	type,		/* VPD_RO_KEY or VPD_RW_KEY */
-int	op)			/* operation to do: ADD_KEY or OWR_KEY */
+const char	*key,	/* keyword to insert */
+const char	*buf,	/* buffer with the keyword value */
+int		len,		/* length of the keyword value */
+int		type,		/* VPD_RO_KEY or VPD_RW_KEY */
+int		op)			/* operation to do: ADD_KEY or OWR_KEY */
 {
 	SK_VPD_PARA vp;
 	char	*etp;		/* end tag position */
@@ -930,12 +949,12 @@
  * return:	A pointer to the vpd_status structure. The structure contains
  *		this fields.
  */
-SK_VPD_STATUS	*VpdStat(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC)	/* IO Context */
+SK_VPD_STATUS *VpdStat(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC)	/* IO Context */
 {
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		(void)VpdInit(pAC,IoC);
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		(void)VpdInit(pAC, IoC);
 	}
 	return(&pAC->vpd.v);
 }
@@ -963,10 +982,10 @@
  *		*len =		30
  *		*elements =	 9
  */
-int		VpdKeys(
-SK_AC		*pAC,		/* common data base */
-SK_IOC		IoC,		/* IO Context */
-char		*buf,		/* buffer where to copy the keywords */
+int VpdKeys(
+SK_AC	*pAC,		/* common data base */
+SK_IOC	IoC,		/* IO Context */
+char	*buf,		/* buffer where to copy the keywords */
 int		*len,		/* buffer length */
 int		*elements)	/* number of keywords returned */
 {
@@ -975,8 +994,8 @@
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_RX, ("list VPD keys .. "));
 	*elements = 0;
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
 			*len = 0;
 			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
 				("VPD Init Error, terminated\n"));
@@ -1049,18 +1068,18 @@
  *		3:	VPD transfer timeout
  *		6:	fatal VPD error
  */
-int		VpdRead(
+int VpdRead(
 SK_AC		*pAC,	/* common data base */
 SK_IOC		IoC,	/* IO Context */
-char		*key,	/* keyword to read (e.g. "MN") */
+const char	*key,	/* keyword to read (e.g. "MN") */
 char		*buf,	/* buffer where to copy the keyword value */
-int		*len)	/* buffer length */
+int			*len)	/* buffer length */
 {
 	SK_VPD_PARA *p, vp;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_RX, ("VPD read %s .. ", key));
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
 			*len = 0;
 			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
 				("VPD init error\n"));
@@ -1095,8 +1114,8 @@
  *	SK_TRUE		Yes it may be written
  *	SK_FALSE	No it may be written
  */
-SK_BOOL		VpdMayWrite(
-char		*key)	/* keyword to write (allowed values "Yx", "Vx") */
+SK_BOOL VpdMayWrite(
+char	*key)	/* keyword to write (allowed values "Yx", "Vx") */
 {
 	if ((*key != 'Y' && *key != 'V') ||
 		key[1] < '0' || key[1] > 'Z' ||
@@ -1120,14 +1139,14 @@
  *		5:	keyword cannot be written
  *		6:	fatal VPD error
  */
-int		VpdWrite(
+int VpdWrite(
 SK_AC		*pAC,	/* common data base */
 SK_IOC		IoC,	/* IO Context */
-char		*key,	/* keyword to write (allowed values "Yx", "Vx") */
-char		*buf)	/* buffer where the keyword value can be read from */
+const char	*key,	/* keyword to write (allowed values "Yx", "Vx") */
+const char	*buf)	/* buffer where the keyword value can be read from */
 {
-	int len;			/* length of the keyword to write */
-	int rtv;			/* return code */
+	int len;		/* length of the keyword to write */
+	int rtv;		/* return code */
 	int rtv2;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX,
@@ -1142,8 +1161,8 @@
 		return(5);
 	}
 
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
 			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
 				("VPD init error\n"));
 			return(6);
@@ -1157,9 +1176,9 @@
 		len = VPD_MAX_LEN;
 		rtv = 2;
 		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
-			("keyword to long, cut after %d bytes\n",VPD_MAX_LEN));
+			("keyword too long, cut after %d bytes\n",VPD_MAX_LEN));
 	}
-	if ((rtv2 = VpdSetupPara(pAC, key,buf, len, VPD_RW_KEY, OWR_KEY)) != 0) {
+	if ((rtv2 = VpdSetupPara(pAC, key, buf, len, VPD_RW_KEY, OWR_KEY)) != 0) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
 			("VPD write error\n"));
 		return(rtv2);
@@ -1180,10 +1199,10 @@
  *		5:	keyword cannot be deleted
  *		6:	fatal VPD error
  */
-int		VpdDelete(
-SK_AC		*pAC,	/* common data base */
-SK_IOC		IoC,	/* IO Context */
-char		*key)	/* keyword to read (e.g. "MN") */
+int VpdDelete(
+SK_AC	*pAC,	/* common data base */
+SK_IOC	IoC,	/* IO Context */
+char	*key)	/* keyword to read (e.g. "MN") */
 {
 	SK_VPD_PARA *p, vp;
 	char *etp;
@@ -1192,8 +1211,8 @@
 	vpd_size = pAC->vpd.vpd_size;
 
 	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_TX,("VPD delete key %s\n",key));
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
 			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
 				("VPD init error\n"));
 			return(6);
@@ -1235,16 +1254,16 @@
  * returns	0:	success
  *		3:	VPD transfer timeout
  */
-int		VpdUpdate(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC)	/* IO Context */
+int VpdUpdate(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC)	/* IO Context */
 {
 	int vpd_size;
 
 	vpd_size = pAC->vpd.vpd_size;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX, ("VPD update .. "));
-	if (pAC->vpd.v.vpd_status & VPD_VALID) {
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) != 0) {
 		if (VpdTransferBlock(pAC, IoC, pAC->vpd.vpd_buf + vpd_size/2,
 			vpd_size/2, vpd_size/2, VPD_WRITE) != vpd_size/2) {
 
@@ -1269,18 +1288,18 @@
  *
  * returns nothing, errors will be ignored.
  */
-void		VpdErrLog(
-SK_AC		*pAC,	/* common data base */
-SK_IOC		IoC,	/* IO Context */
-char		*msg)	/* error log message */
+void VpdErrLog(
+SK_AC	*pAC,	/* common data base */
+SK_IOC	IoC,	/* IO Context */
+char	*msg)	/* error log message */
 {
 	SK_VPD_PARA *v, vf;	/* VF */
 	int len;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX,
-		("VPD error log msg %s\n",msg));
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
+		("VPD error log msg %s\n", msg));
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
 			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
 				("VPD init error\n"));
 			return;
@@ -1298,7 +1317,7 @@
 	}
 	else {
 		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX, ("write VF\n"));
-		(void)VpdSetupPara(pAC, VPD_VF, msg,len, VPD_RW_KEY, ADD_KEY);
+		(void)VpdSetupPara(pAC, VPD_VF, msg, len, VPD_RW_KEY, ADD_KEY);
 	}
 
 	(void)VpdUpdate(pAC, IoC);
diff -Nru a/drivers/net/sk98lin/skxmac2.c b/drivers/net/sk98lin/skxmac2.c
--- a/drivers/net/sk98lin/skxmac2.c	Wed Sep  3 22:38:48 2003
+++ b/drivers/net/sk98lin/skxmac2.c	Wed Sep  3 22:38:48 2003
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skxmac2.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.87 $
- * Date:	$Date: 2002/12/10 14:39:05 $
+ * Project:	Gigabit Ethernet Adapters, Common Modules
+ * Version:	$Revision: 1.99 $
+ * Date:	$Date: 2003/07/11 12:19:33 $
  * Purpose:	Contains functions to initialize the MACs and PHYs
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,75 @@
  * History:
  *
  *	$Log: skxmac2.c,v $
+ *	Revision 1.99  2003/07/11 12:19:33  rschmidt
+ *	Reduced init values for Master & Slave downshift counters to
+ *	minimum values.
+ *	Editorial changes.
+ *	
+ *	Revision 1.98  2003/07/04 12:53:56  rschmidt
+ *	Changed setting of downshift feature in SkGmInitPhyMarv().
+ *	Enabled downshift feature only for para 'Speed' set to 'Auto'.
+ *	Changed init values for Master & Slave downshift counters.
+ *	Editorial changes.
+ *	
+ *	Revision 1.97  2003/05/28 15:53:47  rschmidt
+ *	Removed setting of Yukon PHY's 'force link good' in loopback mode.
+ *	Replaced call pFnMacOverflow() with SkXmOverflowStatus() resp.
+ *	SkGmOverflowStatus().
+ *	Editorial changes.
+ *	
+ *	Revision 1.96  2003/05/13 17:37:11  mkarl
+ *	Removed calls to PNMI for SLIM driver.
+ *	Added SK_FAR for PXE.
+ *	Separated code pathes not used for SLIM driver.
+ *	Some further separations for YUKON and GENESIS.
+ *	Editorial changes.
+ *	
+ *	Revision 1.95  2003/05/06 13:09:53  rschmidt
+ *	Changed init sequence for auto-negotiation disabled in SkGmInitMac().
+ *	Added defines around GENESIS resp. YUKON branches to reduce
+ *	code size for PXE.
+ *	Editorial changes.
+ *	
+ *	Revision 1.94  2003/04/10 14:36:40  rschmidt
+ *	Fixed define for debug code in SkGmInitPhyMarv().
+ *	
+ *	Revision 1.93  2003/04/08 16:58:16  rschmidt
+ *	Changed initialisation of GMAC and GPHY for disabling
+ *	Flow-Control with parameter 'none' (Bug Id #10769).
+ *	Changed init for blinking active LED and normal duplex LED
+ *	depending on value from GILedBlinkCtrl (LED Blink Control).
+ *	Added control for Link100 LED.
+ *	Changed handling for different PhyTypes for source code
+ *	portability to PXE, UNDI.
+ *	Editorial changes.
+ *	
+ *	Revision 1.92  2003/03/31 07:12:33  mkarl
+ *	Restore PHY_MARV_AUNE_ADV after writing to GM_GP_CTRL in order to make
+ *	auto-negotiation of limited flow-control possible.
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.91  2003/02/05 15:09:34  rschmidt
+ *	Removed setting of 'Collision Test'-bit in SkGmInitPhyMarv().
+ *	Disabled auto-update for speed, duplex and flow-control when
+ *	auto-negotiation is not enabled (Bug Id #10766).
+ *	Editorial changes.
+ *	
+ *	Revision 1.90  2003/01/29 13:35:19  rschmidt
+ *	Increment Rx FIFO Overflow counter only in DEBUG-mode.
+ *	Corrected define for blinking active LED.
+ *	
+ *	Revision 1.89  2003/01/28 16:37:45  rschmidt
+ *	Changed init for blinking active LED
+ *	
+ *	Revision 1.88  2003/01/28 10:09:38  rschmidt
+ *	Added debug outputs in SkGmInitMac().
+ *	Added customized init of LED registers in SkGmInitPhyMarv(),
+ *	for blinking active LED (#ifdef ACT_LED_BLINK) and
+ *	for normal duplex LED (#ifdef DUP_LED_NORMAL).
+ *	Editorial changes.
+ *	
  *	Revision 1.87  2002/12/10 14:39:05  rschmidt
  *	Improved initialization of GPHY in SkGmInitPhyMarv().
  *	Editorial changes.
@@ -34,7 +104,7 @@
  *	Added setup of Ext. PHY Specific Ctrl Reg (downshift feature).
  *	
  *	Revision 1.85  2002/12/05 14:09:16  rschmidt
- *	Improved avoiding endless loop in SkGmPhyWrite(), SkGmPhyWrite().
+ *	Improved avoiding endless loop in SkGmPhyRead(), SkGmPhyWrite().
  *	Added additional advertising for 10Base-T when 100Base-T is selected.
  *	Added case SK_PHY_MARV_FIBER for YUKON Fiber adapter.
  *	Editorial changes.
@@ -402,9 +472,13 @@
 } BCOM_HACK;
 
 /* local variables ************************************************************/
+
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#)$Id: skxmac2.c,v 1.87 2002/12/10 14:39:05 rschmidt Exp $ (C) SK ";
+	"@(#) $Id: skxmac2.c,v 1.99 2003/07/11 12:19:33 rschmidt Exp $ (C) Marvell.";
+#endif
 
+#ifdef GENESIS
 BCOM_HACK BcomRegA1Hack[] = {
  { 0x18, 0x0c20 }, { 0x17, 0x0012 }, { 0x15, 0x1104 }, { 0x17, 0x0013 },
  { 0x15, 0x0404 }, { 0x17, 0x8006 }, { 0x15, 0x0132 }, { 0x17, 0x8006 },
@@ -416,14 +490,19 @@
  { 0x15, 0x0A04 }, { 0x18, 0x0420 },
  { 0, 0 }
 };
+#endif
 
 /* function prototypes ********************************************************/
+#ifdef GENESIS
 static void	SkXmInitPhyXmac(SK_AC*, SK_IOC, int, SK_BOOL);
 static void	SkXmInitPhyBcom(SK_AC*, SK_IOC, int, SK_BOOL);
-static void	SkGmInitPhyMarv(SK_AC*, SK_IOC, int, SK_BOOL);
 static int	SkXmAutoNegDoneXmac(SK_AC*, SK_IOC, int);
 static int	SkXmAutoNegDoneBcom(SK_AC*, SK_IOC, int);
+#endif /* GENESIS */
+#ifdef YUKON
+static void	SkGmInitPhyMarv(SK_AC*, SK_IOC, int, SK_BOOL);
 static int	SkGmAutoNegDoneMarv(SK_AC*, SK_IOC, int);
+#endif /* YUKON */
 #ifdef OTHER_PHY
 static void	SkXmInitPhyLone(SK_AC*, SK_IOC, int, SK_BOOL);
 static void	SkXmInitPhyNat (SK_AC*, SK_IOC, int, SK_BOOL);
@@ -432,7 +511,7 @@
 #endif /* OTHER_PHY */
 
 
-
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmPhyRead() - Read from XMAC PHY register
@@ -443,11 +522,11 @@
  *	nothing
  */
 void SkXmPhyRead(
-SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* I/O Context */
-int		Port,		/* Port Index (MAC_1 + n) */
-int		PhyReg,		/* Register Address (Offset) */
-SK_U16	*pVal)		/* Pointer to Value */
+SK_AC	*pAC,			/* Adapter Context */
+SK_IOC	IoC,			/* I/O Context */
+int		Port,			/* Port Index (MAC_1 + n) */
+int		PhyReg,			/* Register Address (Offset) */
+SK_U16	SK_FAR *pVal)	/* Pointer to Value */
 {
 	SK_U16		Mmu;
 	SK_GEPORT	*pPrt;
@@ -513,8 +592,10 @@
 		} while ((Mmu & XM_MMU_PHY_BUSY) != 0);
 	}
 }	/* SkXmPhyWrite */
+#endif /* GENESIS */
 
 
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkGmPhyRead() - Read from GPHY register
@@ -525,11 +606,11 @@
  *	nothing
  */
 void SkGmPhyRead(
-SK_AC	*pAC,		/* Adapter Context */
-SK_IOC	IoC,		/* I/O Context */
-int		Port,		/* Port Index (MAC_1 + n) */
-int		PhyReg,		/* Register Address (Offset) */
-SK_U16	*pVal)		/* Pointer to Value */
+SK_AC	*pAC,			/* Adapter Context */
+SK_IOC	IoC,			/* I/O Context */
+int		Port,			/* Port Index (MAC_1 + n) */
+int		PhyReg,			/* Register Address (Offset) */
+SK_U16	SK_FAR *pVal)	/* Pointer to Value */
 {
 	SK_U16	Ctrl;
 	SK_GEPORT	*pPrt;
@@ -545,8 +626,8 @@
 	pPrt = &pAC->GIni.GP[Port];
 	
 	/* set PHY-Register offset and 'Read' OpCode (= 1) */
-	*pVal = GM_SMI_CT_PHY_AD(pPrt->PhyAddr) | GM_SMI_CT_REG_AD(PhyReg) |
-		GM_SMI_CT_OP_RD;
+	*pVal = (SK_U16)(GM_SMI_CT_PHY_AD(pPrt->PhyAddr) |
+		GM_SMI_CT_REG_AD(PhyReg) | GM_SMI_CT_OP_RD);
 
 	GM_OUT16(IoC, Port, GM_SMI_CTRL, *pVal);
 
@@ -578,6 +659,7 @@
 	VCPUprintf(0, "VCPUgetTime(), SimCyle=%u, SimLowTime=%u\n",
 		SimCyle, SimLowTime);
 #endif /* VCPU */
+
 }	/* SkGmPhyRead */
 
 
@@ -646,9 +728,12 @@
 	VCPUprintf(0, "VCPUgetTime(), SimCyle=%u, SimLowTime=%u\n",
 		SimCyle, SimLowTime);
 #endif /* VCPU */
+
 }	/* SkGmPhyWrite */
+#endif /* YUKON */
 
 
+#ifdef SK_DIAG
 /******************************************************************************
  *
  *	SkGePhyRead() - Read from PHY register
@@ -705,6 +790,7 @@
 	
 	w_func(pAC, IoC, Port, PhyReg, Val);
 }	/* SkGePhyWrite */
+#endif /* SK_DIAG */
 
 
 /******************************************************************************
@@ -724,9 +810,14 @@
 int		Port,	/* Port Index (MAC_1 + n) */
 SK_BOOL	Enable)	/* Enable / Disable */
 {
+#ifdef YUKON
 	SK_U16	RcReg;
+#endif
+#ifdef GENESIS
 	SK_U32	MdReg;
+#endif	
 
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		
 		XM_IN32(IoC, Port, XM_MODE, &MdReg);
@@ -740,7 +831,10 @@
 		/* setup Mode Register */
 		XM_OUT32(IoC, Port, XM_MODE, MdReg);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		
 		GM_IN16(IoC, Port, GM_RX_CTRL, &RcReg);
 		
@@ -754,6 +848,8 @@
 		/* setup Receive Control Register */
 		GM_OUT16(IoC, Port, GM_RX_CTRL, RcReg);
 	}
+#endif /* YUKON */
+
 }	/* SkMacPromiscMode*/
 
 
@@ -774,9 +870,14 @@
 int		Port,	/* Port Index (MAC_1 + n) */
 SK_BOOL	Enable)	/* Enable / Disable */
 {
+#ifdef YUKON
 	SK_U16	RcReg;
+#endif	
+#ifdef GENESIS
 	SK_U32	MdReg;
+#endif
 
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		
 		XM_IN32(IoC, Port, XM_MODE, &MdReg);
@@ -790,7 +891,10 @@
 		/* setup Mode Register */
 		XM_OUT32(IoC, Port, XM_MODE, MdReg);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		
 		GM_IN16(IoC, Port, GM_RX_CTRL, &RcReg);
 		
@@ -804,6 +908,8 @@
 		/* setup Receive Control Register */
 		GM_OUT16(IoC, Port, GM_RX_CTRL, RcReg);
 	}
+#endif /* YUKON */
+
 }	/* SkMacHashing*/
 
 
@@ -903,7 +1009,7 @@
  * Description:
  *	The features
  *	 - FCS (CRC) stripping,				SK_STRIP_FCS_ON/OFF
- *	 - don't set XMR_FS_ERR in status	SK_BIG_PK_OK_ON/OFF
+ *	 - don't set GMR_FS_LONG_ERR		SK_BIG_PK_OK_ON/OFF
  *	   for frames > 1514 bytes
  *   - enable Rx of own packets         SK_SELF_RX_ON/OFF
  *
@@ -986,6 +1092,7 @@
 		
 		SkGmSetRxCmd(pAC, IoC, Port, Mode);
 	}
+
 }	/* SkMacSetRxCmd */
 
 
@@ -1017,7 +1124,7 @@
 			Word |= XM_TX_NO_CRC;
 		}
 		/* setup Tx Command Register */
-		XM_OUT16(pAC, Port, XM_TX_CMD, Word);
+		XM_OUT16(IoC, Port, XM_TX_CMD, Word);
 	}
 	else {
 		
@@ -1032,11 +1139,13 @@
 		/* setup Tx Control Register */
 		GM_OUT16(IoC, Port, GM_TX_CTRL, Word);
 	}
+
 }	/* SkMacCrcGener*/
 
 #endif /* SK_DIAG */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmClrExactAddr() - Clear Exact Match Address Registers
@@ -1070,6 +1179,7 @@
 		XM_OUTADDR(IoC, Port, XM_EXM(i), &ZeroAddr[0]);
 	}
 }	/* SkXmClrExactAddr */
+#endif /* GENESIS */
 
 
 /******************************************************************************
@@ -1087,6 +1197,7 @@
 SK_IOC	IoC,	/* IO context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
+#ifdef GENESIS
 	SK_U32	MdReg;
 
 	if (pAC->GIni.GIGenesis) {
@@ -1095,10 +1206,15 @@
 
 		XM_OUT32(IoC, Port, XM_MODE, MdReg | XM_MD_FTF);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		/* no way to flush the FIFO we have to issue a reset */
 		/* TBD */
 	}
+#endif /* YUKON */
+
 }	/* SkMacFlushTxFifo */
 
 
@@ -1117,6 +1233,7 @@
 SK_IOC	IoC,	/* IO context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
+#ifdef GENESIS
 	SK_U32	MdReg;
 
 	if (pAC->GIni.GIGenesis) {
@@ -1125,13 +1242,19 @@
 
 		XM_OUT32(IoC, Port, XM_MODE, MdReg | XM_MD_FRF);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		/* no way to flush the FIFO we have to issue a reset */
 		/* TBD */
 	}
+#endif /* YUKON */
+
 }	/* SkMacFlushRxFifo */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmSoftRst() - Do a XMAC software reset
@@ -1280,8 +1403,10 @@
 	}
 
 }	/* SkXmHardRst */
+#endif /* GENESIS */
 
 
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkGmSoftRst() - Do a GMAC software reset
@@ -1310,13 +1435,13 @@
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK, 0);
 	
 	/* clear the Hash Register */
-	GM_OUTHASH(IoC, Port, GM_MC_ADDR_H1, &EmptyHash);
+	GM_OUTHASH(IoC, Port, GM_MC_ADDR_H1, EmptyHash);
 
 	/* Enable Unicast and Multicast filtering */
 	GM_IN16(IoC, Port, GM_RX_CTRL, &RxCtrl);
 	
 	GM_OUT16(IoC, Port, GM_RX_CTRL,
-		RxCtrl | GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA);
+		(SK_U16)(RxCtrl | GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA));
 
 }	/* SkGmSoftRst */
 
@@ -1346,6 +1471,7 @@
 	SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
 
 }	/* SkGmHardRst */
+#endif /* YUKON */
 
 
 /******************************************************************************
@@ -1369,14 +1495,19 @@
 	/* disable receiver and transmitter */
 	SkMacRxTxDisable(pAC, IoC, Port);
 
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		
 		SkXmSoftRst(pAC, IoC, Port);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		
 		SkGmSoftRst(pAC, IoC, Port);
 	}
+#endif /* YUKON */
 
 	/* flush the MAC's Rx and Tx FIFOs */
 	SkMacFlushTxFifo(pAC, IoC, Port);
@@ -1403,21 +1534,26 @@
 int		Port)	/* Port Index (MAC_1 + n) */
 {
 	
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		
 		SkXmHardRst(pAC, IoC, Port);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		
 		SkGmHardRst(pAC, IoC, Port);
 	}
+#endif /* YUKON */
 
 	pAC->GIni.GP[Port].PState = SK_PRT_RESET;
 
 }	/* SkMacHardRst */
 
 
-
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmInitMac() - Initialize the XMAC II
@@ -1542,10 +1678,10 @@
 		 */
 		SkMacInitPhy(pAC, IoC, Port, SK_FALSE);
 
-#if 0
+#ifdef TEST_ONLY
 		/* temp. code: enable signal detect */
 		/* WARNING: do not override GMII setting above */
-		XM_OUT16(pAC, Port, XM_HW_CFG, XM_HW_COM4SIG);
+		XM_OUT16(IoC, Port, XM_HW_CFG, XM_HW_COM4SIG);
 #endif
 	}
 
@@ -1605,7 +1741,7 @@
 		SWord |= XM_RX_BIG_PK_OK;
 	}
 
-	if (pPrt->PLinkModeConf == SK_LMODE_HALF) {
+	if (pPrt->PLinkMode == SK_LMODE_HALF) {
 		/*
 		 * If in manual half duplex mode the other side might be in
 		 * full duplex mode, so ignore if a carrier extension is not seen
@@ -1651,7 +1787,10 @@
 	 * has been completed successfully.
 	 */
 }	/* SkXmInitMac */
+#endif /* GENESIS */
+
 
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkGmInitMac() - Initialize the GMAC
@@ -1698,11 +1837,13 @@
 		/* set GMAC Control reset */
 		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
 
+#ifdef XXX
 		/* clear GMAC Control reset */
 		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_CLR);
 
 		/* set GMAC Control reset */
 		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
+#endif /* XXX */
 
 		/* set HWCFG_MODE */
 		DWord = GPC_INT_POL_HI | GPC_DIS_FC | GPC_DIS_SLEEP |
@@ -1716,10 +1857,76 @@
 		/* release GPHY Control reset */
 		SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_CLR);
 
+#ifdef VCPU
+		VCpuWait(9000);
+#endif /* VCPU */
+
 		/* clear GMAC Control reset */
 		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_PAUSE_ON | GMC_RST_CLR);
 
-		/* Dummy read the Interrupt source register */
+#ifdef VCPU
+		VCpuWait(2000);
+#endif /* VCPU */
+
+		/* Auto-negotiation ? */
+		if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
+			/* Auto-negotiation disabled */
+
+			/* get General Purpose Control */
+			GM_IN16(IoC, Port, GM_GP_CTRL, &SWord);
+
+			/* disable auto-update for speed, duplex and flow-control */
+			SWord |= GM_GPCR_AU_ALL_DIS;
+			
+			/* setup General Purpose Control Register */
+			GM_OUT16(IoC, Port, GM_GP_CTRL, SWord);
+			
+			SWord = GM_GPCR_AU_ALL_DIS;
+		}
+		else {
+			SWord = 0;
+		}
+
+		/* speed settings */
+		switch (pPrt->PLinkSpeed) {
+		case SK_LSPEED_AUTO:
+		case SK_LSPEED_1000MBPS:
+			SWord |= GM_GPCR_SPEED_1000 | GM_GPCR_SPEED_100;
+			break;
+		case SK_LSPEED_100MBPS:
+			SWord |= GM_GPCR_SPEED_100;
+			break;
+		case SK_LSPEED_10MBPS:
+			break;
+		}
+
+		/* duplex settings */
+		if (pPrt->PLinkMode != SK_LMODE_HALF) {
+			/* set full duplex */
+			SWord |= GM_GPCR_DUP_FULL;
+		}
+
+		switch (pPrt->PFlowCtrlMode) {
+		case SK_FLOW_MODE_NONE:
+			/* set Pause Off */
+			SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_PAUSE_OFF);
+			/* disable Tx & Rx flow-control */
+			SWord |= GM_GPCR_FC_TX_DIS | GM_GPCR_FC_RX_DIS | GM_GPCR_AU_FCT_DIS;
+			break;
+		case SK_FLOW_MODE_LOC_SEND:
+			/* disable Rx flow-control */
+			SWord |= GM_GPCR_FC_RX_DIS | GM_GPCR_AU_FCT_DIS;
+			break;
+		case SK_FLOW_MODE_SYMMETRIC:
+		case SK_FLOW_MODE_SYM_OR_REM:
+			/* enable Tx & Rx flow-control */
+			break;
+		}
+
+		/* setup General Purpose Control Register */
+		GM_OUT16(IoC, Port, GM_GP_CTRL, SWord);
+
+		/* dummy read the Interrupt Source Register */
 		SK_IN16(IoC, GMAC_IRQ_SRC, &SWord);
 		
 #ifndef VCPU
@@ -1732,50 +1939,6 @@
 
 	(void)SkGmResetCounter(pAC, IoC, Port);
 
-	SWord =  0;
-
-	/* speed settings */
-	switch (pPrt->PLinkSpeed) {
-	case SK_LSPEED_AUTO:
-		/* auto update for speed is already set */
-		break;
-	case SK_LSPEED_1000MBPS:
-		SWord |= GM_GPCR_SPEED_1000;
-		break;
-	case SK_LSPEED_100MBPS:
-		SWord |= GM_GPCR_SPEED_100;
-		break;
-	case SK_LSPEED_10MBPS:
-		break;
-	}
-	
-	/* duplex settings */
-	if (pPrt->PLinkModeConf == SK_LMODE_FULL ||
-		pPrt->PLinkModeConf == SK_LMODE_AUTOSENSE) {
-		
-		SWord |= GM_GPCR_DUP_FULL;
-	}
-
-	/* flow control settings */
-	switch (pPrt->PFlowCtrlMode) {
-	case SK_FLOW_MODE_NONE:
-		/* disable auto-neg of flow control */
-		SWord |= GM_GPCR_FC_TX_DIS | GM_GPCR_FC_RX_DIS;
-		break;
-	case SK_FLOW_MODE_LOC_SEND:
-		SWord |= GM_GPCR_FC_RX_DIS;
-		break;
-	case SK_FLOW_MODE_SYMMETRIC:
-		/* TBD */
-	case SK_FLOW_MODE_SYM_OR_REM:
-		/* do nothing means to enable autoneg for flowcontrol and */
-		/* enable rx and tx of pause frames */
-		break;
-	}
-
-	/* setup General Purpose Control Register */
-	GM_OUT16(IoC, Port, GM_GP_CTRL, SWord);
-
 	/* setup Transmit Control Register */
 	GM_OUT16(IoC, Port, GM_TX_CTRL, GM_TXCR_COL_THR);
 
@@ -1791,7 +1954,7 @@
 	GM_IN16(IoC, Port, GM_TX_PARAM, &SWord);
 #endif /* VCPU */
 
-	SWord = JAM_LEN_VAL(3) | JAM_IPG_VAL(11) | IPG_JAM_DATA(26);
+    SWord = (SK_U16)(JAM_LEN_VAL(3) | JAM_IPG_VAL(11) | IPG_JAM_DATA(26));
 	
 	GM_OUT16(IoC, Port, GM_TX_PARAM, SWord);
 
@@ -1827,7 +1990,7 @@
 
 #ifdef WA_DEV_16
 		/* WA for deviation #16 */
-		if (pAC->GIni.GIChipRev == 0) {
+		if (pAC->GIni.GIChipId == CHIP_ID_YUKON && pAC->GIni.GIChipRev == 0) {
 			/* swap the address bytes */
 			SWord = ((SWord & 0xff00) >> 8)	| ((SWord & 0x00ff) << 8);
 
@@ -1845,12 +2008,12 @@
 		SK_IN16(IoC, (B2_MAC_1 + Port * 8 + i * 2), &SWord);
 
 		GM_OUT16(IoC, Port, (GM_SRC_ADDR_2L + i * 4), SWord);
+		
+		/* reset Multicast filtering Hash registers 1-3 */
+		GM_OUT16(IoC, Port, GM_MC_ADDR_H1 + 4*i, 0);
 	}
 
-	/* reset all Multicast filtering Hash registers */
-	GM_OUT16(IoC, Port, GM_MC_ADDR_H1, 0);
-	GM_OUT16(IoC, Port, GM_MC_ADDR_H2, 0);
-	GM_OUT16(IoC, Port, GM_MC_ADDR_H3, 0);
+	/* reset Multicast filtering Hash register 4 */
 	GM_OUT16(IoC, Port, GM_MC_ADDR_H4, 0);
 
 	/* enable interrupt mask for counter overflows */
@@ -1858,13 +2021,21 @@
 	GM_OUT16(IoC, Port, GM_RX_IRQ_MSK, 0);
 	GM_OUT16(IoC, Port, GM_TR_IRQ_MSK, 0);
 
-#ifdef VCPU
 	/* read General Purpose Status */
 	GM_IN16(IoC, Port, GM_GP_STAT, &SWord);
-#endif /* VCPU */
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("MAC Stat Reg=0x%04X\n", SWord));
+
+#ifdef SK_DIAG
+	c_print("MAC Stat Reg=0x%04X\n", SWord);
+#endif /* SK_DIAG */
+
 }	/* SkGmInitMac */
+#endif /* YUKON */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmInitDupMd() - Initialize the XMACs Duplex Mode
@@ -2209,7 +2380,7 @@
 	/* Write AutoNeg Advertisement Register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUNE_ADV, Ctrl3);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("Auto-Neg. Adv. Reg=0x%04X\n", Ctrl3));
+		("Auto-Neg.Adv.Reg=0x%04X\n", Ctrl3));
 	
 	if (DoLoop) {
 		/* Set the Phy Loopback bit, too */
@@ -2234,8 +2405,10 @@
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("PHY Control Reg=0x%04X\n", Ctrl1));
 }	/* SkXmInitPhyBcom */
+#endif /* GENESIS */
 
 
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkGmInitPhyMarv() - Initialize the Marvell Phy registers
@@ -2255,43 +2428,66 @@
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		PhyCtrl;
-	SK_U16		PhyStat;
-	SK_U16		PhyStat1;
-	SK_U16		PhySpec;
 	SK_U16		C1000BaseT;
 	SK_U16		AutoNegAdv;
 	SK_U16		ExtPhyCtrl;
+	SK_U16		LedCtrl;
+	SK_BOOL		AutoNeg;
+#if defined(SK_DIAG) || defined(DEBUG)
+	SK_U16		PhyStat;
+	SK_U16		PhyStat1;
+	SK_U16		PhySpecStat;
+#endif /* SK_DIAG || DEBUG */
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	/* Auto-negotiation ? */
+	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
+		AutoNeg = SK_FALSE;
+	}
+	else {
+		AutoNeg = SK_TRUE;
+	}
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("InitPhyMarv: Port %d, auto-negotiation %s\n",
+		 Port, AutoNeg ? "ON" : "OFF"));
 
 #ifdef VCPU
 	VCPUprintf(0, "SkGmInitPhyMarv(), Port=%u, DoLoop=%u\n",
 		Port, DoLoop);
 #else /* VCPU */
 	
-	if (!DoLoop) {
+	if (DoLoop) {
+		/* Set 'MAC Power up'-bit, set Manual MDI configuration */
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL,
+			PHY_M_PC_MAC_POW_UP);
+	}
+	else if (AutoNeg && pPrt->PLinkSpeed == SK_LSPEED_AUTO) {
 		/* Read Ext. PHY Specific Control */
 		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_EXT_CTRL, &ExtPhyCtrl);
 		
 		ExtPhyCtrl &= ~(PHY_M_EC_M_DSC_MSK | PHY_M_EC_S_DSC_MSK |
 			PHY_M_EC_MAC_S_MSK);
 		
-		ExtPhyCtrl |= PHY_M_EC_M_DSC(1) | PHY_M_EC_S_DSC(1) |
-			PHY_M_EC_MAC_S(MAC_TX_CLK_25_MHZ);
+		ExtPhyCtrl |= PHY_M_EC_MAC_S(MAC_TX_CLK_25_MHZ) |
+			PHY_M_EC_M_DSC(0) | PHY_M_EC_S_DSC(1);
 	
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_CTRL, ExtPhyCtrl);
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("Ext.PHYCtrl=0x%04X\n", ExtPhyCtrl));
-		
-		/* Read PHY Control */
-		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &PhyCtrl);
-		
-		/* Assert software reset */
-		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, PhyCtrl | PHY_CT_RESET);
+			("Ext. PHY Ctrl=0x%04X\n", ExtPhyCtrl));
 	}
-#endif /* VCPU */
 
-	pPrt = &pAC->GIni.GP[Port];
+	/* Read PHY Control */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &PhyCtrl);
+
+	PhyCtrl |= PHY_CT_RESET;
+	/* Assert software reset */
+	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, PhyCtrl);
+
+#endif /* VCPU */
 
-	PhyCtrl = PHY_CT_COL_TST;
+	PhyCtrl = 0 /* PHY_CT_COL_TST */;
 	C1000BaseT = 0;
 	AutoNegAdv = PHY_SEL_TYPE;
 
@@ -2306,9 +2502,7 @@
 	}
 	
 	/* Auto-negotiation ? */
-	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("InitPhyMarv: no auto-negotiation Port %d\n", Port));
+	if (!AutoNeg) {
 		
 		if (pPrt->PLinkMode == SK_LMODE_FULL) {
 			/* Set Full Duplex Mode */
@@ -2345,9 +2539,6 @@
 		 */
 	}
 	else {
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("InitPhyMarv: with auto-negotiation Port %d\n", Port));
-		
 		PhyCtrl |= PHY_CT_ANE;
 		
 		if (pAC->GIni.GICopperType) {
@@ -2459,12 +2650,7 @@
 	 */
 	
 	/* Program PHY register 30 as 16'h0708 for simulation speed up */
-	SkGmPhyWrite(pAC, IoC, Port, 30, 0x0708);
-	
-#if 0
-	/* Program PHY register 20 as 16'h2070 */
-	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_CTRL, 0x2070);
-#endif /* 0 */
+	SkGmPhyWrite(pAC, IoC, Port, 30, 0x0700 /* 0x0708 */);
 	
 	VCpuWait(2000);
 
@@ -2485,38 +2671,63 @@
 		/* Set the PHY Loopback bit */
 		PhyCtrl |= PHY_CT_LOOP;
 
+#ifdef XXX
 		/* Program PHY register 16 as 16'h0400 to force link good */
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, PHY_M_PC_FL_GOOD);
+#endif /* XXX */
 
-#if 0
+#ifndef VCPU
 		if (pPrt->PLinkSpeed != SK_LSPEED_AUTO) {
 			/* Write Ext. PHY Specific Control */
 			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_CTRL,
 				(SK_U16)((pPrt->PLinkSpeed + 2) << 4));
 		}
+#endif /* VCPU */
 	}
+#ifdef TEST_ONLY
 	else if (pPrt->PLinkSpeed == SK_LSPEED_10MBPS) {
 			/* Write PHY Specific Control */
-			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, PHY_M_PC_EN_DET_MSK);
-		}
-#endif /* 0 */
+			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL,
+				PHY_M_PC_EN_DET_MSK);
 	}
+#endif
 
 	/* Write to the PHY Control register */
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, PhyCtrl);
 
 #ifdef VCPU
 	VCpuWait(2000);
-#endif /* VCPU */
+#else
+
+	LedCtrl = PHY_M_LED_PULS_DUR(PULS_170MS) | PHY_M_LED_BLINK_RT(BLINK_84MS);
+
+	if ((pAC->GIni.GILedBlinkCtrl & SK_ACT_LED_BLINK) != 0) {
+		LedCtrl |= PHY_M_LEDC_RX_CTRL | PHY_M_LEDC_TX_CTRL;
+	}
+
+	if ((pAC->GIni.GILedBlinkCtrl & SK_DUP_LED_NORMAL) != 0) {
+		LedCtrl |= PHY_M_LEDC_DP_CTRL;
+	}
+	
+	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_LED_CTRL, LedCtrl);
+
+	if ((pAC->GIni.GILedBlinkCtrl & SK_LED_LINK100_ON) != 0) {
+		/* only in forced 100Mbps mode */
+		if (!AutoNeg && pPrt->PLinkSpeed == SK_LSPEED_100MBPS) {
+
+			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_LED_OVER,
+				PHY_M_LED_MO_100(MO_LED_ON));
+		}
+	}
 
 #ifdef SK_DIAG
-	c_print("PHY Ctrl Val=0x%04X\n", PhyCtrl);
-	c_print("1000 B-T Val=0x%04X\n", C1000BaseT);
-	c_print("Auto-Neg Val=0x%04X\n", AutoNegAdv);
-	c_print("Ext Ctrl Val=0x%04X\n", ExtPhyCtrl);
+	c_print("Set PHY Ctrl=0x%04X\n", PhyCtrl);
+	c_print("Set 1000 B-T=0x%04X\n", C1000BaseT);
+	c_print("Set Auto-Neg=0x%04X\n", AutoNegAdv);
+	c_print("Set Ext Ctrl=0x%04X\n", ExtPhyCtrl);
 #endif /* SK_DIAG */
 
-#ifndef VCPU
+#if defined(SK_DIAG) || defined(DEBUG)
 	/* Read PHY Control */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &PhyCtrl);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
@@ -2535,7 +2746,7 @@
 	/* Read Ext. PHY Specific Control */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_EXT_CTRL, &ExtPhyCtrl);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("Ext PHY Ctrl=0x%04X\n", ExtPhyCtrl));
+		("Ext. PHY Ctrl=0x%04X\n", ExtPhyCtrl));
 	
 	/* Read PHY Status */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_STAT, &PhyStat);
@@ -2546,10 +2757,10 @@
 		("PHY Stat Reg.=0x%04X\n", PhyStat1));
 	
 	/* Read PHY Specific Status */
-	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &PhySpec);
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &PhySpecStat);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("PHY Spec Stat=0x%04X\n", PhySpec));
-#endif /* VCPU */
+		("PHY Spec Stat=0x%04X\n", PhySpecStat));
+#endif /* SK_DIAG || DEBUG */
 
 #ifdef SK_DIAG
 	c_print("PHY Ctrl Reg=0x%04X\n", PhyCtrl);
@@ -2558,10 +2769,13 @@
 	c_print("Ext Ctrl Reg=0x%04X\n", ExtPhyCtrl);
 	c_print("PHY Stat Reg=0x%04X\n", PhyStat);
 	c_print("PHY Stat Reg=0x%04X\n", PhyStat1);
-	c_print("PHY Spec Reg=0x%04X\n", PhySpec);
+	c_print("PHY Spec Reg=0x%04X\n", PhySpecStat);
 #endif /* SK_DIAG */
 
+#endif /* VCPU */
+
 }	/* SkGmInitPhyMarv */
+#endif /* YUKON */
 
 
 #ifdef OTHER_PHY
@@ -2666,10 +2880,6 @@
 
 	}
 	
-	/* Initialize LED register here ? */
-	/* No. Please do it in SkDgXmitLed() (if required) and swap
-	   init order of LEDs and XMAC. (MAl) */
-	
 	/* Write 1000Base-T Control Register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_1000T_CTRL, Ctrl2);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
@@ -2678,8 +2888,7 @@
 	/* Write AutoNeg Advertisement Register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_AUNE_ADV, Ctrl3);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("Auto-Neg. Adv. Reg=0x%04X\n", Ctrl3));
-	
+		("Auto-Neg.Adv.Reg=0x%04X\n", Ctrl3));
 
 	if (DoLoop) {
 		/* Set the Phy Loopback bit, too */
@@ -2736,89 +2945,39 @@
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	switch (pPrt->PhyType) {
-	case SK_PHY_XMAC:
-		SkXmInitPhyXmac(pAC, IoC, Port, DoLoop);
-		break;
-	case SK_PHY_BCOM:
-		SkXmInitPhyBcom(pAC, IoC, Port, DoLoop);
-		break;
-	case SK_PHY_MARV_COPPER:
-	case SK_PHY_MARV_FIBER:
-		SkGmInitPhyMarv(pAC, IoC, Port, DoLoop);
-		break;
+#ifdef GENESIS
+	if (pAC->GIni.GIGenesis) {
+		
+		switch (pPrt->PhyType) {
+		case SK_PHY_XMAC:
+			SkXmInitPhyXmac(pAC, IoC, Port, DoLoop);
+			break;
+		case SK_PHY_BCOM:
+			SkXmInitPhyBcom(pAC, IoC, Port, DoLoop);
+			break;
 #ifdef OTHER_PHY
-	case SK_PHY_LONE:
-		SkXmInitPhyLone(pAC, IoC, Port, DoLoop);
-		break;
-	case SK_PHY_NAT:
-		SkXmInitPhyNat(pAC, IoC, Port, DoLoop);
-		break;
+		case SK_PHY_LONE:
+			SkXmInitPhyLone(pAC, IoC, Port, DoLoop);
+			break;
+		case SK_PHY_NAT:
+			SkXmInitPhyNat(pAC, IoC, Port, DoLoop);
+			break;
 #endif /* OTHER_PHY */
+		}
 	}
-}	/* SkMacInitPhy */
-
-
-#ifndef SK_DIAG
-/******************************************************************************
- *
- *	SkXmAutoNegLipaXmac() - Decides whether Link Partner could do auto-neg
- *
- *	This function analyses the Interrupt status word. If any of the
- *	Auto-negotiating interrupt bits are set, the PLipaAutoNeg variable
- *	is set true.
- */
-void SkXmAutoNegLipaXmac(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-int		Port,		/* Port Index (MAC_1 + n) */
-SK_U16	IStatus)	/* Interrupt Status word to analyse */
-{
-	SK_GEPORT	*pPrt;
-
-	pPrt = &pAC->GIni.GP[Port];
-
-	if (pPrt->PLipaAutoNeg != SK_LIPA_AUTO &&
-		(IStatus & (XM_IS_LIPA_RC | XM_IS_RX_PAGE | XM_IS_AND)) != 0) {
-
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("AutoNegLipa: AutoNeg detected on Port %d, IStatus=0x%04x\n",
-			Port, IStatus));
-		pPrt->PLipaAutoNeg = SK_LIPA_AUTO;
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
+		
+		SkGmInitPhyMarv(pAC, IoC, Port, DoLoop);
 	}
-}	/* SkXmAutoNegLipaXmac */
-
+#endif /* YUKON */
 
-/******************************************************************************
- *
- *	SkMacAutoNegLipaPhy() - Decides whether Link Partner could do auto-neg
- *
- *	This function analyses the PHY status word.
- *  If any of the Auto-negotiating bits are set, the PLipaAutoNeg variable
- *	is set true.
- */
-void SkMacAutoNegLipaPhy(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-int		Port,		/* Port Index (MAC_1 + n) */
-SK_U16	PhyStat)	/* PHY Status word to analyse */
-{
-	SK_GEPORT	*pPrt;
-
-	pPrt = &pAC->GIni.GP[Port];
-
-	if (pPrt->PLipaAutoNeg != SK_LIPA_AUTO &&
-		(PhyStat & PHY_ST_AN_OVER) != 0) {
-
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("AutoNegLipa: AutoNeg detected on Port %d, PhyStat=0x%04x\n",
-			Port, PhyStat));
-		pPrt->PLipaAutoNeg = SK_LIPA_AUTO;
-	}
-}	/* SkMacAutoNegLipaPhy */
-#endif /* SK_DIAG */
+}	/* SkMacInitPhy */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmAutoNegDoneXmac() - Auto-negotiation handling
@@ -2841,7 +3000,7 @@
 	SK_U16		LPAb;		/* Link Partner Ability */
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNegDoneXmac, Port %d\n",Port));
+		("AutoNegDoneXmac, Port %d\n", Port));
 
 	pPrt = &pAC->GIni.GP[Port];
 
@@ -2923,7 +3082,7 @@
 	SK_U16		LPAb;		/* Link Partner Ability */
 	SK_U16		AuxStat;	/* Auxiliary Status */
 
-#if 0
+#ifdef TEST_ONLY
 01-Sep-2000 RA;:;:
 	SK_U16		ResAb;		/* Resolved Ability */
 #endif	/* 0 */
@@ -2934,7 +3093,7 @@
 
 	/* Get PHY parameters */
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_LP, &LPAb);
-#if 0
+#ifdef TEST_ONLY
 01-Sep-2000 RA;:;:
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ResAb);
 #endif	/* 0 */
@@ -2964,7 +3123,7 @@
 		return(SK_AND_DUP_CAP);
 	}
 	
-#if 0
+#ifdef TEST_ONLY
 01-Sep-2000 RA;:;:
 	/* Check Master/Slave resolution */
 	if ((ResAb & PHY_B_1000S_MSF) != 0) {
@@ -2979,7 +3138,7 @@
 		SK_MS_STAT_MASTER : SK_MS_STAT_SLAVE;
 #endif	/* 0 */
 
-	/* Check PAUSE mismatch */
+	/* Check PAUSE mismatch ??? */
 	/* We are using IEEE 802.3z/D5.0 Table 37-4 */
 	if ((AuxStat & PHY_B_AS_PAUSE_MSK) == PHY_B_AS_PAUSE_MSK) {
 		/* Symmetric PAUSE */
@@ -3001,8 +3160,10 @@
 
 	return(SK_AND_OK);
 }	/* SkXmAutoNegDoneBcom */
+#endif /* GENESIS */
 
 
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkGmAutoNegDoneMarv() - Auto-negotiation handling
@@ -3032,7 +3193,7 @@
 	/* Get PHY parameters */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_LP, &LPAb);
 	
-	if ((LPAb & PHY_B_AN_RF) != 0) {
+	if ((LPAb & PHY_M_AN_RF) != 0) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("AutoNegFail: Remote fault bit set Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
@@ -3059,7 +3220,7 @@
 	/* Check Speed & Duplex resolved */
 	if ((AuxStat & PHY_M_PS_SPDUP_RES) == 0) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("AutoNegFail: Speed & Duplex not resolved Port %d\n", Port));
+			("AutoNegFail: Speed & Duplex not resolved, Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PLinkModeStatus = SK_LMODE_STAT_UNKNOWN;
 		return(SK_AND_DUP_CAP);
@@ -3072,7 +3233,7 @@
 		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOHALF;
 	}
 	
-	/* Check PAUSE mismatch */
+	/* Check PAUSE mismatch ??? */
 	/* We are using IEEE 802.3z/D5.0 Table 37-4 */
 	if ((AuxStat & PHY_M_PS_PAUSE_MSK) == PHY_M_PS_PAUSE_MSK) {
 		/* Symmetric PAUSE */
@@ -3105,6 +3266,7 @@
 
 	return(SK_AND_OK);
 }	/* SkGmAutoNegDoneMarv */
+#endif /* YUKON */
 
 
 #ifdef OTHER_PHY
@@ -3131,7 +3293,7 @@
 	SK_U16		QuickStat;	/* Auxiliary Status */
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNegDoneLone, Port %d\n",Port));
+		("AutoNegDoneLone, Port %d\n", Port));
 	pPrt = &pAC->GIni.GP[Port];
 
 	/* Get PHY parameters */
@@ -3255,30 +3417,41 @@
 	SK_GEPORT	*pPrt;
 	int	Rtv;
 
+	Rtv = SK_AND_OK;
+
 	pPrt = &pAC->GIni.GP[Port];
 
-	switch (pPrt->PhyType) {
-	case SK_PHY_XMAC:
-		Rtv = SkXmAutoNegDoneXmac(pAC, IoC, Port);
-		break;
-	case SK_PHY_BCOM:
-		Rtv = SkXmAutoNegDoneBcom(pAC, IoC, Port);
-		break;
-	case SK_PHY_MARV_COPPER:
-	case SK_PHY_MARV_FIBER:
-		Rtv = SkGmAutoNegDoneMarv(pAC, IoC, Port);
-		break;
+#ifdef GENESIS
+	if (pAC->GIni.GIGenesis) {
+		
+		switch (pPrt->PhyType) {
+		
+		case SK_PHY_XMAC:
+			Rtv = SkXmAutoNegDoneXmac(pAC, IoC, Port);
+			break;
+		case SK_PHY_BCOM:
+			Rtv = SkXmAutoNegDoneBcom(pAC, IoC, Port);
+			break;
 #ifdef OTHER_PHY
-	case SK_PHY_LONE:
-		Rtv = SkXmAutoNegDoneLone(pAC, IoC, Port);
-		break;
-	case SK_PHY_NAT:
-		Rtv = SkXmAutoNegDoneNat(pAC, IoC, Port);
-		break;
+		case SK_PHY_LONE:
+			Rtv = SkXmAutoNegDoneLone(pAC, IoC, Port);
+			break;
+		case SK_PHY_NAT:
+			Rtv = SkXmAutoNegDoneNat(pAC, IoC, Port);
+			break;
 #endif /* OTHER_PHY */
-	default:
-		return(SK_AND_OTHER);
+		default:
+			return(SK_AND_OTHER);
+		}
 	}
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
+		
+		Rtv = SkGmAutoNegDoneMarv(pAC, IoC, Port);
+	}
+#endif /* YUKON */
 	
 	if (Rtv != SK_AND_OK) {
 		return(Rtv);
@@ -3293,6 +3466,7 @@
 }	/* SkMacAutoNegDone */
 
 
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmSetRxTxEn() - Special Set Rx/Tx Enable and some features in XMAC
@@ -3346,8 +3520,10 @@
 	XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
 
 }	/* SkXmSetRxTxEn */
+#endif /* GENESIS */
 
 
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkGmSetRxTxEn() - Special Set Rx/Tx Enable and some features in GMAC
@@ -3386,14 +3562,17 @@
 		break;
 	}
 	
-	GM_OUT16(IoC, Port, GM_GP_CTRL, Ctrl | GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);
+    GM_OUT16(IoC, Port, GM_GP_CTRL, (SK_U16)(Ctrl | GM_GPCR_RX_ENA |
+		GM_GPCR_TX_ENA));
 
 	/* dummy read to ensure writing */
 	GM_IN16(IoC, Port, GM_GP_CTRL, &Ctrl);
 
 }	/* SkGmSetRxTxEn */
+#endif /* YUKON */
 
 
+#ifndef SK_SLIM
 /******************************************************************************
  *
  *	SkMacSetRxTxEn() - Special Set Rx/Tx Enable and parameters
@@ -3408,16 +3587,22 @@
 int		Port,		/* Port Index (MAC_1 + n) */
 int		Para)
 {
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		
 		SkXmSetRxTxEn(pAC, IoC, Port, Para);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		
 		SkGmSetRxTxEn(pAC, IoC, Port, Para);
 	}
+#endif /* YUKON */
 
 }	/* SkMacSetRxTxEn */
+#endif /* !SK_SLIM */
 
 
 /******************************************************************************
@@ -3438,7 +3623,9 @@
 	SK_GEPORT	*pPrt;
 	SK_U16		Reg;		/* 16-bit register value */
 	SK_U16		IntMask;	/* MAC interrupt mask */
+#ifdef GENESIS
 	SK_U16		SWord;
+#endif
 
 	pPrt = &pAC->GIni.GP[Port];
 
@@ -3455,6 +3642,7 @@
 		return(0);
 	}
 
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* set Duplex Mode and Pause Mode */
 		SkXmInitDupMd(pAC, IoC, Port);
@@ -3502,7 +3690,8 @@
 			SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &SWord);
 			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUX_CTRL,
 				(SK_U16)(SWord & ~PHY_B_AC_DIS_PM));
-			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_INT_MASK, PHY_B_DEF_MSK);
+            SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_INT_MASK,
+				(SK_U16)PHY_B_DEF_MSK);
 			break;
 #ifdef OTHER_PHY
 		case SK_PHY_LONE:
@@ -3519,7 +3708,10 @@
 		/* enable Rx/Tx */
 		XM_OUT16(IoC, Port, XM_MMU_CMD, Reg | XM_MMU_ENA_RX | XM_MMU_ENA_TX);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		/*
 		 * Initialize the Interrupt Mask Register. Default IRQs are...
 		 *	- Rx Counter Event Overflow
@@ -3545,13 +3737,16 @@
 		}
 		
 		/* enable Rx/Tx */
-		GM_OUT16(IoC, Port, GM_GP_CTRL, Reg | GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);
+        GM_OUT16(IoC, Port, GM_GP_CTRL, (SK_U16)(Reg | GM_GPCR_RX_ENA |
+			GM_GPCR_TX_ENA));
 
 #ifndef VCPU
 		/* Enable all PHY interrupts */
-		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK, PHY_M_DEF_MSK);
+        SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK,
+			(SK_U16)PHY_M_DEF_MSK);
 #endif /* VCPU */
 	}
+#endif /* YUKON */
 					
 	return(0);
 
@@ -3573,6 +3768,7 @@
 {
 	SK_U16	Word;
 
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		
 		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
@@ -3582,15 +3778,21 @@
 		/* dummy read to ensure writing */
 		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		
 		GM_IN16(IoC, Port, GM_GP_CTRL, &Word);
 
-		GM_OUT16(IoC, Port, GM_GP_CTRL, Word & ~(GM_GPCR_RX_ENA | GM_GPCR_TX_ENA));
+        GM_OUT16(IoC, Port, GM_GP_CTRL, (SK_U16)(Word & ~(GM_GPCR_RX_ENA |
+			GM_GPCR_TX_ENA)));
 
 		/* dummy read to ensure writing */
 		GM_IN16(IoC, Port, GM_GP_CTRL, &Word);
 	}
+#endif /* YUKON */
+
 }	/* SkMacRxTxDisable */
 
 
@@ -3608,10 +3810,13 @@
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
+#ifdef GENESIS
 	SK_U16		Word;
+#endif
 
 	pPrt = &pAC->GIni.GP[Port];
 
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		
 		/* disable all XMAC IRQs */
@@ -3642,7 +3847,10 @@
 #endif /* OTHER_PHY */
 		}
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		/* disable all GMAC IRQs */
 		SK_OUT8(IoC, GMAC_IRQ_MSK, 0);
 		
@@ -3651,6 +3859,8 @@
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK, 0);
 #endif /* VCPU */
 	}
+#endif /* YUKON */
+
 }	/* SkMacIrqDisable */
 
 
@@ -3683,7 +3893,8 @@
 	/* setup Mode Register */
 	XM_OUT32(IoC, Port, XM_MODE, MdReg);
 
-}	/* SkXmSendCont*/
+}	/* SkXmSendCont */
+
 
 /******************************************************************************
  *
@@ -3724,12 +3935,74 @@
 			TimeCtrl = GMT_ST_STOP | GMT_ST_CLR_IRQ;
 		}
 		/* Start/Stop Time Stamp Timer */
-		SK_OUT8(pAC, GMAC_TI_ST_CTRL, TimeCtrl);
+		SK_OUT8(IoC, GMAC_TI_ST_CTRL, TimeCtrl);
 	}
+
 }	/* SkMacTimeStamp*/
 
-#else /* SK_DIAG */
+#else /* !SK_DIAG */
+
+#ifdef GENESIS
+/******************************************************************************
+ *
+ *	SkXmAutoNegLipaXmac() - Decides whether Link Partner could do auto-neg
+ *
+ *	This function analyses the Interrupt status word. If any of the
+ *	Auto-negotiating interrupt bits are set, the PLipaAutoNeg variable
+ *	is set true.
+ */
+void SkXmAutoNegLipaXmac(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+SK_U16	IStatus)	/* Interrupt Status word to analyse */
+{
+	SK_GEPORT	*pPrt;
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	if (pPrt->PLipaAutoNeg != SK_LIPA_AUTO &&
+		(IStatus & (XM_IS_LIPA_RC | XM_IS_RX_PAGE | XM_IS_AND)) != 0) {
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNegLipa: AutoNeg detected on Port %d, IStatus=0x%04X\n",
+			Port, IStatus));
+		pPrt->PLipaAutoNeg = SK_LIPA_AUTO;
+	}
+}	/* SkXmAutoNegLipaXmac */
+#endif /* GENESIS */
+
+
+/******************************************************************************
+ *
+ *	SkMacAutoNegLipaPhy() - Decides whether Link Partner could do auto-neg
+ *
+ *	This function analyses the PHY status word.
+ *  If any of the Auto-negotiating bits are set, the PLipaAutoNeg variable
+ *	is set true.
+ */
+void SkMacAutoNegLipaPhy(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+SK_U16	PhyStat)	/* PHY Status word to analyse */
+{
+	SK_GEPORT	*pPrt;
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	if (pPrt->PLipaAutoNeg != SK_LIPA_AUTO &&
+		(PhyStat & PHY_ST_AN_OVER) != 0) {
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNegLipa: AutoNeg detected on Port %d, PhyStat=0x%04X\n",
+			Port, PhyStat));
+		pPrt->PLipaAutoNeg = SK_LIPA_AUTO;
+	}
+}	/* SkMacAutoNegLipaPhy */
 
+
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmIrq() - Interrupt Service Routine
@@ -3758,6 +4031,9 @@
 	SK_EVPARA	Para;
 	SK_U16		IStatus;	/* Interrupt status read from the XMAC */
 	SK_U16		IStatus2;
+#ifdef SK_SLIM
+    SK_U64      OverflowStatus;
+#endif	
 
 	pPrt = &pAC->GIni.GP[Port];
 	
@@ -3775,7 +4051,7 @@
 	}
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-		("XmacIrq Port %d Isr 0x%04x\n", Port, IStatus));
+		("XmacIrq Port %d Isr 0x%04X\n", Port, IStatus));
 
 	if (!pPrt->PHWLinkUp) {
 		/* Spurious XMAC interrupt */
@@ -3789,7 +4065,7 @@
 		XM_IN16(IoC, Port, XM_ISRC, &IStatus2);
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-			("SkXmIrq: Link async. Double check Port %d 0x%04x 0x%04x\n",
+			("SkXmIrq: Link async. Double check Port %d 0x%04X 0x%04X\n",
 			 Port, IStatus, IStatus2));
 		IStatus &= ~XM_IS_INP_ASS;
 		IStatus |= IStatus2;
@@ -3838,14 +4114,20 @@
 
 	/* Combined Tx & Rx Counter Overflow SIRQ Event */
 	if ((IStatus & (XM_IS_RXC_OV | XM_IS_TXC_OV)) != 0) {
+#ifdef SK_SLIM
+		SkXmOverflowStatus(pAC, IoC, Port, IStatus, &OverflowStatus);
+#else
 		Para.Para32[0] = (SK_U32)Port;
 		Para.Para32[1] = (SK_U32)IStatus;
 		SkPnmiEvent(pAC, IoC, SK_PNMI_EVT_SIRQ_OVERFLOW, Para);
+#endif /* SK_SLIM */
 	}
 
 	if ((IStatus & XM_IS_RXF_OV) != 0) {
 		/* normal situation -> no effect */
+#ifdef DEBUG
 		pPrt->PRxOverCnt++;
+#endif /* DEBUG */
 	}
 
 	if ((IStatus & XM_IS_TXF_UR) != 0) {
@@ -3861,8 +4143,10 @@
 		/* not served here */
 	}
 }	/* SkXmIrq */
+#endif /* GENESIS */
 
 
+#ifdef YUKON
 /******************************************************************************
  *
  *	SkGmIrq() - Interrupt Service Routine
@@ -3880,32 +4164,43 @@
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
-	SK_EVPARA	Para;
 	SK_U8		IStatus;	/* Interrupt status */
+#ifdef SK_SLIM
+    SK_U64      OverflowStatus;
+#else
+	SK_EVPARA	Para;
+#endif	
 
 	pPrt = &pAC->GIni.GP[Port];
 	
 	SK_IN8(IoC, GMAC_IRQ_SRC, &IStatus);
 	
+#ifdef XXX
 	/* LinkPartner Auto-negable? */
 	SkMacAutoNegLipaPhy(pAC, IoC, Port, IStatus);
+#endif /* XXX */
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-		("GmacIrq Port %d Isr 0x%04x\n", Port, IStatus));
+		("GmacIrq Port %d Isr 0x%04X\n", Port, IStatus));
 
 	/* Combined Tx & Rx Counter Overflow SIRQ Event */
 	if (IStatus & (GM_IS_RX_CO_OV | GM_IS_TX_CO_OV)) {
 		/* these IRQs will be cleared by reading GMACs register */
+#ifdef SK_SLIM
+        SkGmOverflowStatus(pAC, IoC, Port, IStatus, &OverflowStatus);
+#else
 		Para.Para32[0] = (SK_U32)Port;
 		Para.Para32[1] = (SK_U32)IStatus;
 		SkPnmiEvent(pAC, IoC, SK_PNMI_EVT_SIRQ_OVERFLOW, Para);
+#endif		
 	}
 
 	if (IStatus & GM_IS_RX_FF_OR) {
 		/* clear GMAC Rx FIFO Overrun IRQ */
 		SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8)GMF_CLI_RX_FO);
-
+#ifdef DEBUG
 		pPrt->PRxOverCnt++;
+#endif /* DEBUG */
 	}
 
 	if (IStatus & GM_IS_TX_FF_UR) {
@@ -3923,6 +4218,8 @@
 		/* not served here */
 	}
 }	/* SkGmIrq */
+#endif /* YUKON */
+
 
 /******************************************************************************
  *
@@ -3938,19 +4235,25 @@
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
-
+#ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* IRQ from XMAC */
 		SkXmIrq(pAC, IoC, Port);
 	}
-	else {
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
 		/* IRQ from GMAC */
 		SkGmIrq(pAC, IoC, Port);
 	}
+#endif /* YUKON */
+
 }	/* SkMacIrq */
 
 #endif /* !SK_DIAG */
 
+#ifdef GENESIS
 /******************************************************************************
  *
  *	SkXmUpdateStats() - Force the XMAC to output the current statistic
@@ -4000,24 +4303,6 @@
 	return(0);
 }	/* SkXmUpdateStats */
 
-/******************************************************************************
- *
- *	SkGmUpdateStats() - Force the GMAC to output the current statistic
- *
- * Description:
- *	Empty function for GMAC. Statistic data is accessible in direct way.
- *
- * Returns:
- *	0:  success
- *	1:  something went wrong
- */
-int SkGmUpdateStats(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-unsigned int Port)	/* Port Index (MAC_1 + n) */
-{
-	return(0);
-}
 
 /******************************************************************************
  *
@@ -4033,11 +4318,11 @@
  *	1:  something went wrong
  */
 int SkXmMacStatistic(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-unsigned int Port,	/* Port Index (MAC_1 + n) */
-SK_U16	StatAddr,	/* MIB counter base address */
-SK_U32	*pVal)		/* ptr to return statistic value */
+SK_AC	*pAC,			/* adapter context */
+SK_IOC	IoC,			/* IO context */
+unsigned int Port,		/* Port Index (MAC_1 + n) */
+SK_U16	StatAddr,		/* MIB counter base address */
+SK_U32	SK_FAR *pVal)	/* ptr to return statistic value */
 {
 	if ((StatAddr < XM_TXF_OK) || (StatAddr > XM_RXF_MAX_SZ)) {
 		
@@ -4051,63 +4336,137 @@
 	return(0);
 }	/* SkXmMacStatistic */
 
+
 /******************************************************************************
  *
- *	SkGmMacStatistic() - Get GMAC counter value
+ *	SkXmResetCounter() - Clear MAC statistic counter
  *
  * Description:
- *	Gets the 32bit counter value. Except for the octet counters
- *	the lower 32bit are counted in hardware and the upper 32bit
- *	must be counted in software by monitoring counter overflow interrupts.
+ *	Force the XMAC to clear its statistic counter.
  *
  * Returns:
  *	0:  success
  *	1:  something went wrong
  */
-int SkGmMacStatistic(
+int SkXmResetCounter(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
-unsigned int Port,	/* Port Index (MAC_1 + n) */
-SK_U16	StatAddr,	/* MIB counter base address */
-SK_U32	*pVal)		/* ptr to return statistic value */
+unsigned int Port)	/* Port Index (MAC_1 + n) */
 {
+	XM_OUT16(IoC, Port, XM_STAT_CMD, XM_SC_CLR_RXC | XM_SC_CLR_TXC);
+	/* Clear two times according to Errata #3 */
+	XM_OUT16(IoC, Port, XM_STAT_CMD, XM_SC_CLR_RXC | XM_SC_CLR_TXC);
 
-	if ((StatAddr < GM_RXF_UC_OK) || (StatAddr > GM_TXE_FIFO_UR)) {
-		
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E022, SKERR_HWI_E022MSG);
-		
-		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("SkGmMacStat: wrong MIB counter 0x%04X\n", StatAddr));
-		return(1);
+	return(0);
+}	/* SkXmResetCounter */
+
+
+/******************************************************************************
+ *
+ *	SkXmOverflowStatus() - Gets the status of counter overflow interrupt
+ *
+ * Description:
+ *	Checks the source causing an counter overflow interrupt. On success the
+ *	resulting counter overflow status is written to <pStatus>, whereas the
+ *	upper dword stores the XMAC ReceiveCounterEvent register and the lower
+ *	dword the XMAC TransmitCounterEvent register.
+ *
+ * Note:
+ *	For XMAC the interrupt source is a self-clearing register, so the source
+ *	must be checked only once. SIRQ module does another check to be sure
+ *	that no interrupt get lost during process time.
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkXmOverflowStatus(
+SK_AC	*pAC,				/* adapter context */
+SK_IOC	IoC,				/* IO context */
+unsigned int Port,			/* Port Index (MAC_1 + n) */
+SK_U16	IStatus,			/* Interupt Status from MAC */
+SK_U64	SK_FAR *pStatus)	/* ptr for return overflow status value */
+{
+	SK_U64	Status;	/* Overflow status */
+	SK_U32	RegVal;
+
+	Status = 0;
+
+	if ((IStatus & XM_IS_RXC_OV) != 0) {
+
+		XM_IN32(IoC, Port, XM_RX_CNT_EV, &RegVal);
+		Status |= (SK_U64)RegVal << 32;
 	}
-		
-	GM_IN32(IoC, Port, StatAddr, pVal);
+	
+	if ((IStatus & XM_IS_TXC_OV) != 0) {
+
+		XM_IN32(IoC, Port, XM_TX_CNT_EV, &RegVal);
+		Status |= (SK_U64)RegVal;
+	}
+
+	*pStatus = Status;
 
 	return(0);
-}	/* SkGmMacStatistic */
+}	/* SkXmOverflowStatus */
+#endif /* GENESIS */
 
+
+#ifdef YUKON
 /******************************************************************************
  *
- *	SkXmResetCounter() - Clear MAC statistic counter
+ *	SkGmUpdateStats() - Force the GMAC to output the current statistic
  *
  * Description:
- *	Force the XMAC to clear its statistic counter.
+ *	Empty function for GMAC. Statistic data is accessible in direct way.
  *
  * Returns:
  *	0:  success
  *	1:  something went wrong
  */
-int SkXmResetCounter(
+int SkGmUpdateStats(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 unsigned int Port)	/* Port Index (MAC_1 + n) */
 {
-	XM_OUT16(IoC, Port, XM_STAT_CMD, XM_SC_CLR_RXC | XM_SC_CLR_TXC);
-	/* Clear two times according to Errata #3 */
-	XM_OUT16(IoC, Port, XM_STAT_CMD, XM_SC_CLR_RXC | XM_SC_CLR_TXC);
+	return(0);
+}
+
+
+/******************************************************************************
+ *
+ *	SkGmMacStatistic() - Get GMAC counter value
+ *
+ * Description:
+ *	Gets the 32bit counter value. Except for the octet counters
+ *	the lower 32bit are counted in hardware and the upper 32bit
+ *	must be counted in software by monitoring counter overflow interrupts.
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkGmMacStatistic(
+SK_AC	*pAC,			/* adapter context */
+SK_IOC	IoC,			/* IO context */
+unsigned int Port,		/* Port Index (MAC_1 + n) */
+SK_U16	StatAddr,		/* MIB counter base address */
+SK_U32	SK_FAR *pVal)	/* ptr to return statistic value */
+{
+
+	if ((StatAddr < GM_RXF_UC_OK) || (StatAddr > GM_TXE_FIFO_UR)) {
+		
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E022, SKERR_HWI_E022MSG);
+		
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("SkGmMacStat: wrong MIB counter 0x%04X\n", StatAddr));
+		return(1);
+	}
+		
+	GM_IN32(IoC, Port, StatAddr, pVal);
 
 	return(0);
-}	/* SkXmResetCounter */
+}	/* SkGmMacStatistic */
+
 
 /******************************************************************************
  *
@@ -4131,7 +4490,6 @@
 
 	GM_IN16(IoC, Port, GM_PHY_ADDR, &Reg);
 
-#ifndef VCPU
 	/* set MIB Clear Counter Mode */
 	GM_OUT16(IoC, Port, GM_PHY_ADDR, Reg | GM_PAR_MIB_CLR);
 	
@@ -4143,59 +4501,10 @@
 	
 	/* clear MIB Clear Counter Mode */
 	GM_OUT16(IoC, Port, GM_PHY_ADDR, Reg);
-#endif /* !VCPU */
 	
 	return(0);
 }	/* SkGmResetCounter */
 
-/******************************************************************************
- *
- *	SkXmOverflowStatus() - Gets the status of counter overflow interrupt
- *
- * Description:
- *	Checks the source causing an counter overflow interrupt. On success the
- *	resulting counter overflow status is written to <pStatus>, whereas the
- *	upper dword stores the XMAC ReceiveCounterEvent register and the lower
- *	dword the XMAC TransmitCounterEvent register.
- *
- * Note:
- *	For XMAC the interrupt source is a self-clearing register, so the source
- *	must be checked only once. SIRQ module does another check to be sure
- *	that no interrupt get lost during process time.
- *
- * Returns:
- *	0:  success
- *	1:  something went wrong
- */
-int SkXmOverflowStatus(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-unsigned int Port,	/* Port Index (MAC_1 + n) */
-SK_U16  IStatus,	/* Interupt Status from MAC */
-SK_U64	*pStatus)	/* ptr for return overflow status value */
-{
-	SK_U64	Status;	/* Overflow status */
-	SK_U32	RegVal;
-
-	Status = 0;
-
-	if ((IStatus & XM_IS_RXC_OV) != 0) {
-
-		XM_IN32(IoC, Port, XM_RX_CNT_EV, &RegVal);
-		Status |= (SK_U64)RegVal << 32;
-	}
-	
-	if ((IStatus & XM_IS_TXC_OV) != 0) {
-
-		XM_IN32(IoC, Port, XM_TX_CNT_EV, &RegVal);
-		Status |= (SK_U64)RegVal;
-	}
-
-	*pStatus = Status;
-
-	return(0);
-}	/* SkXmOverflowStatus */
-
 
 /******************************************************************************
  *
@@ -4217,11 +4526,11 @@
  *	1:  something went wrong
  */
 int SkGmOverflowStatus(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-unsigned int Port,	/* Port Index (MAC_1 + n) */
-SK_U16  IStatus,	/* Interupt Status from MAC */
-SK_U64	*pStatus)	/* ptr for return overflow status value */
+SK_AC	*pAC,				/* adapter context */
+SK_IOC	IoC,				/* IO context */
+unsigned int Port,			/* Port Index (MAC_1 + n) */
+SK_U16	IStatus,			/* Interupt Status from MAC */
+SK_U64	SK_FAR *pStatus)	/* ptr for return overflow status value */
 {
 	SK_U64	Status;		/* Overflow status */
 	SK_U16	RegVal;
@@ -4252,6 +4561,8 @@
 	return(0);
 }	/* SkGmOverflowStatus */
 
+
+#ifndef SK_SLIM
 /******************************************************************************
  *
  *	SkGmCableDiagStatus() - Starts / Gets status of cable diagnostic test
@@ -4305,7 +4616,7 @@
 
 		/* start Cable Diagnostic Test */
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CABLE_DIAG,
-			RegVal | PHY_M_CABD_ENA_TEST);
+			(SK_U16)(RegVal | PHY_M_CABD_ENA_TEST));
 	
 		return(0);
 	}
@@ -4336,5 +4647,7 @@
 
 	return(0);
 }	/* SkGmCableDiagStatus */
+#endif /* !SK_SLIM */
+#endif /* YUKON */
 
 /* End of file */
diff -Nru a/drivers/pci/pci.ids b/drivers/pci/pci.ids
--- a/drivers/pci/pci.ids	Wed Sep  3 22:38:48 2003
+++ b/drivers/pci/pci.ids	Wed Sep  3 22:38:48 2003
@@ -2281,6 +2281,9 @@
 	1006  MINI PCI type 3B Data Fax Modem
 	1007  Mini PCI 56k Winmodem
 		10b7 615c  Mini PCI 56K Modem
+	1700  Gigabit Ethernet Adapter
+		10b7 0010  3Com 3C940 Gigabit LOM Ethernet Adapter
+		10b7 0020  3Com 3C941 Gigabit LOM Ethernet Adapter
 	3390  3c339 TokenLink Velocity
 	3590  3c359 TokenLink Velocity XL
 		10b7 3590  TokenLink Velocity XL Adapter (3C359/359B)
@@ -3385,24 +3388,39 @@
 		1148 5843  FDDI SK-5843 (SK-NET FDDI-LP64)
 		1148 5844  FDDI SK-5844 (SK-NET FDDI-LP64 DAS)
 	4200  Token Ring adapter
-	4300  Gigabit Ethernet
-		1148 9821  SK-9821 (1000Base-T single link)
-		1148 9822  SK-9822 (1000Base-T dual link)
-		1148 9841  SK-9841 (1000Base-LX single link)
-		1148 9842  SK-9842 (1000Base-LX dual link)
-		1148 9843  SK-9843 (1000Base-SX single link)
-		1148 9844  SK-9844 (1000Base-SX dual link)
-		1148 9861  SK-9861 (1000Base-SX VF45 single link)
-		1148 9862  SK-9862 (1000Base-SX VF45 dual link)
+	4300  SK-98xx Gigabit Ethernet Server Adapter
+		1148 9821  SK-9821 Gigabit Ethernet Server Adapter (SK-NET GE-T)
+		1148 9822  SK-9822 Gigabit Ethernet Server Adapter (SK-NET GE-T dual link)
+		1148 9841  SK-9841 Gigabit Ethernet Server Adapter (SK-NET GE-LX)
+		1148 9842  SK-9842 Gigabit Ethernet Server Adapter (SK-NET GE-LX dual link)
+		1148 9843  SK-9843 Gigabit Ethernet Server Adapter (SK-NET GE-SX)
+		1148 9844  SK-9844 Gigabit Ethernet Server Adapter (SK-NET GE-SX dual link)
+		1148 9861  SK-9861 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition)
+		1148 9862  SK-9862 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition dual link)
 # Information got from SysKonnekt
-		1148 9871  SK-9871 (1000Base-ZX single link)
+		1148 9871  SK-9871 Gigabit Ethernet Server Adapter (SK-NET GE-ZX)
 # Information got from SysKonnekt
-		1148 9872  SK-9872 (1000Base-ZX dual link)
-		1259 2970  AT-2970SX [Allied Telesyn]
-		1259 2972  AT-2970T [Allied Telesyn]
-		1259 2975  AT-2970SX [Allied Telesyn]
-		1259 2977  AT-2970T [Allied Telesyn]
-	4320  SK-98xx Gigabit Ethernet Server Adapter
+		1148 9872  SK-9872 Gigabit Ethernet Server Adapter (SK-NET GE-ZX dual link)
+		1259 2970  Allied Telesyn AT-2970SX Gigabit Ethernet Adapter
+		1259 2971  Allied Telesyn AT-2970LX Gigabit Ethernet Adapter
+		1259 2972  Allied Telesyn AT-2970TX Gigabit Ethernet Adapter
+		1259 2973  Allied Telesyn AT-2971SX Gigabit Ethernet Adapter
+		1259 2974  Allied Telesyn AT-2971T Gigabit Ethernet Adapter
+		1259 2975  Allied Telesyn AT-2970SX/2SC Gigabit Ethernet Adapter
+		1259 2976  Allied Telesyn AT-2970LX/2SC Gigabit Ethernet Adapter
+		1259 2977  Allied Telesyn AT-2970TX/2TX Gigabit Ethernet Adapter
+	4320  SK-98xx V2.0 Gigabit Ethernet Adapter
+		1148 0121  Marvell RDK-8001 Adapter
+		1148 0221  Marvell RDK-8002 Adapter
+		1148 0321  Marvell RDK-8003 Adapter
+		1148 0421  Marvell RDK-8004 Adapter
+		1148 0621  Marvell RDK-8006 Adapter
+		1148 0721  Marvell RDK-8007 Adapter
+		1148 0821  Marvell RDK-8008 Adapter
+		1148 0921  Marvell RDK-8009 Adapter
+		1148 1121  Marvell RDK-8011 Adapter
+		1148 1221  Marvell RDK-8012 Adapter
+		1148 3221  SK-9521 V2.0 10/100/1000Base-T Adapter
 		1148 5021  SK-9821 V2.0 Gigabit Ethernet 10/100/1000Base-T Adapter
 		1148 5041  SK-9841 V2.0 Gigabit Ethernet 1000Base-LX Adapter
 		1148 5043  SK-9843 V2.0 Gigabit Ethernet 1000Base-SX Adapter
@@ -3628,6 +3646,8 @@
 	1340  DFE-690TXD CardBus PC Card
 	1561  DRP-32TXD Cardbus PC Card
 	4000  DL2K Ethernet
+	4c00  Gigabit Ethernet Adapter
+		1186 4c00  DGE-530T Gigabit Ethernet Adapter
 1187  Advanced Technology Laboratories, Inc.
 1188  Shima Seiki Manufacturing Ltd.
 1189  Matsushita Electronics Co Ltd
@@ -3705,6 +3725,8 @@
 11aa  Actel
 11ab  Galileo Technology Ltd.
 	0146  GT-64010/64010A System Controller
+	4320  Gigabit Ethernet Adapter
+		11ab 9521  Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Adapter
 	4611  GT-64115 System Controller
 	4620  GT-64120/64120A/64121A System Controller
 	4801  GT-48001
@@ -4935,6 +4957,8 @@
 136f  Applied Magic Inc
 1370  ATL Products
 1371  CNet Technology Inc
+	434e  GigaCard Network Adapter
+		1371 434e  N-Way PCI-Bus Giga-Card 1000/100/10Mbps(L)
 1373  Silicon Vision Inc
 1374  Silicom Ltd
 1375  Argosystems Inc
@@ -6070,6 +6094,10 @@
 170c  YottaYotta Inc.
 172a  Accelerated Encryption
 1737  Linksys
+	1032  Gigabit Network Adapter
+		1737 0015  EG1032 v2 Instant Gigabit Network Adapter
+	1064  Gigabit Network Adapter
+		1737 0016  EG1064 v2 Instant Gigabit Network Adapter
 173b  Altima (nee Broadcom)
 	03e8  AC1000 Gigabit Ethernet
 	03e9  AC1001 Gigabit Ethernet
