diff -ruNp linux-2.4.20/drivers/usb/bt819-new.c linux-2.4.20/drivers/usb.np/bt819-new.c
--- linux-2.4.20/drivers/usb/bt819-new.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb.np/bt819-new.c	2003-04-16 03:54:09.000000000 +0200
@@ -0,0 +1,601 @@
+/*
+    bt819 - BT819A VideoStream Decoder (Rockwell Part)
+
+    Copyright (C) 1999 Mike Bernson <mike@mlb.org>
+    Copyright (C) 1998 Dave Perks <dperks@ibm.net>
+
+    Modifications for LML33/DC10plus unified driver
+    Copyright (C) 2000 Serguei Miridonov <mirsev@cicese.mx>
+    
+    This code was modify/ported from the saa7111 driver written
+    by Dave Perks.
+
+	Quick conversion to the new i2c driver by Joerg Heckenbach
+	
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/videodev.h>
+#include <linux/video_decoder.h>
+
+#define DEBUG(x)       x	/* Debug driver */
+
+/* Addresses to scan */
+#define I2C_BT819     0x8A
+static unsigned short normal_i2c[] = {
+	I2C_BT819 >> 1,
+	I2C_CLIENT_END
+};
+static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
+static unsigned short probe[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short probe_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short force[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static struct i2c_client_address_data addr_data = {
+	normal_i2c, normal_i2c_range,
+	probe, probe_range,
+	ignore, ignore_range,
+	force
+};
+
+static struct i2c_driver driver;
+static struct i2c_client client_template;
+
+
+/* ----------------------------------------------------------------------- */
+
+struct bt819 {
+	unsigned char reg[32];
+
+	int initialized;
+	int norm;
+	int input;
+	int enable;
+	int bright;
+	int contrast;
+	int hue;
+	int sat;
+};
+
+struct timing {
+	int hactive;
+	int hdelay;
+	int vactive;
+	int vdelay;
+	int hscale;
+	int vscale;
+};
+
+struct timing timing_data[] = {
+	{864 - 24, 2, 623, 1, 0x0504, 0x0000},
+	{858 - 24, 2, 523, 1, 0x00f8, 0x0000},
+//      { 858-68, 64, 523, 1, 0x00f8, 0x0000 },
+};
+
+#define   I2C_DELAY   10
+
+/* ----------------------------------------------------------------------- */
+
+static int bt819_write(struct i2c_client *client, unsigned char subaddr,
+		       unsigned char data)
+{
+	unsigned char buffer[2];
+	struct bt819 *decoder = client->data;
+
+	buffer[0] = subaddr;
+	buffer[1] = data;
+	if (2 != i2c_master_send(client, buffer, 2)) {
+		printk(KERN_WARNING
+		       "bt819: I/O error, trying (write %d 0x%x)\n",
+		       subaddr, data);
+		return -1;
+	}
+	decoder->reg[subaddr] = data;
+	return 0;
+	
+/*	int ack;
+
+	LOCK_I2C_BUS(dev->bus);
+	i2c_start(dev->bus);
+	i2c_sendbyte(dev->bus, dev->addr, I2C_DELAY);
+	i2c_sendbyte(dev->bus, subaddr, I2C_DELAY);
+	ack = i2c_sendbyte(dev->bus, data, I2C_DELAY);
+	dev->reg[subaddr] = data;
+	i2c_stop(dev->bus);
+	UNLOCK_I2C_BUS(dev->bus);
+	return ack;*/
+}
+
+static int bt819_setbit(struct i2c_client *client, int subaddr, int bit, int data)
+{
+	struct bt819 *decoder = client->data;
+
+	return bt819_write(client, subaddr, (decoder->reg[subaddr] & ~(1 << bit)) | (data ? (1 << bit) : 0));
+}
+
+static int bt819_write_block(struct i2c_client *client, unsigned const char *data,
+			     unsigned int len)
+{
+	int idx;
+	struct bt819 *decoder = client->data;
+	
+	if (len != i2c_master_send(client, data, len)) {
+		printk(KERN_WARNING "bt819: I/O error, trying write\n");
+		return -1;
+	}
+	for (idx = 0; idx < len; idx += 2) {
+		decoder->reg[data[idx]] = data[idx+1];
+	}
+	return 0;
+
+/*	int ack;
+	unsigned subaddr;
+
+	ack = 0;
+	while (len > 1) {
+		LOCK_I2C_BUS(dev->bus);
+		i2c_start(dev->bus);
+		i2c_sendbyte(dev->bus, dev->addr, I2C_DELAY);
+		ack = i2c_sendbyte(dev->bus, (subaddr = *data++), I2C_DELAY);
+		ack = i2c_sendbyte(dev->bus, (dev->reg[subaddr] = *data++),
+				 I2C_DELAY);
+		len -= 2;
+		while (len > 1 && *data == ++subaddr) {
+			data++;
+			ack =
+			    i2c_sendbyte(dev->bus, (dev->reg[subaddr] = *data++), I2C_DELAY);
+			len -= 2;
+		}
+		i2c_stop(dev->bus);
+		UNLOCK_I2C_BUS(dev->bus);
+	}
+	return ack;*/
+}
+
+static int bt819_read(struct i2c_client *client, unsigned char subaddr)
+{
+	unsigned char buffer;
+
+	if (1 != i2c_master_send(client, &subaddr, 1)) {
+		printk(KERN_WARNING
+		       "bt819: I/O error, trying (write %d)\n", subaddr);
+		return -1;
+	}
+	if (1 != i2c_master_recv(client, &buffer, 1)) {
+		printk(KERN_WARNING "bt819: I/O error, trying (read)\n");
+		return -1;
+	}
+	printk(KERN_WARNING "bt819_read 0x%02X\n", buffer);
+	return buffer;
+
+
+/*	int data;
+
+	LOCK_I2C_BUS(dev->bus);
+	i2c_start(dev->bus);
+	i2c_sendbyte(dev->bus, dev->addr, I2C_DELAY);
+	i2c_sendbyte(dev->bus, subaddr, I2C_DELAY);
+	i2c_start(dev->bus);
+	i2c_sendbyte(dev->bus, dev->addr | 1, I2C_DELAY);
+	data = i2c_readbyte(dev->bus, 1);
+	i2c_stop(dev->bus);
+	UNLOCK_I2C_BUS(dev->bus);
+	return data;*/
+}
+
+static int bt819_init(struct i2c_client *client)
+{
+	struct bt819 *decoder;
+
+	static unsigned char init[] = {
+		//0x1f, 0x00,     /* Reset */
+		0x01, 0x59,	/* 0x01 input format */
+		0x02, 0x00,	/* 0x02 temporal decimation */
+		0x03, 0x12,	/* 0x03 Cropping msb */
+		0x04, 0x16,	/* 0x04 Vertical Delay, lsb */
+		0x05, 0xe0,	/* 0x05 Vertical Active lsb */
+		0x06, 0x80,	/* 0x06 Horizontal Delay lsb */
+		0x07, 0xd0,	/* 0x07 Horizontal Active lsb */
+		0x08, 0x00,	/* 0x08 Horizontal Scaling msb */
+		0x09, 0xf8,	/* 0x09 Horizontal Scaling lsb */
+		0x0a, 0x00,	/* 0x0a Brightness control */
+		0x0b, 0x30,	/* 0x0b Miscellaneous control */
+		0x0c, 0xd8,	/* 0x0c Luma Gain lsb */
+		0x0d, 0xfe,	/* 0x0d Chroma Gain (U) lsb */
+		0x0e, 0xb4,	/* 0x0e Chroma Gain (V) msb */
+		0x0f, 0x00,	/* 0x0f Hue control */
+		0x12, 0x04,	/* 0x12 Output Format */
+		0x13, 0x20,	/* 0x13 Vertial Scaling msb 0x60, */
+		0x14, 0x00,	/* 0x14 Vertial Scaling lsb */
+		0x16, 0x04,	/* 0x16 Video Timing Polarity 0x02, */
+		0x18, 0x68,	/* 0x18 AGC Delay */
+		0x19, 0x5d,	/* 0x19 Burst Gate Delay */
+		0x1a, 0x80,	/* 0x1a ADC Interface */
+	};
+
+	struct timing *timing;
+
+	DEBUG(printk(KERN_INFO "%s: init\n", client->name));		
+	
+	decoder = client->data;
+	timing = &timing_data[decoder->norm];
+
+	init[3 * 2 - 1] = (((timing->vdelay >> 8) & 0x03) << 6) |
+	    (((timing->vactive >> 8) & 0x03) << 4) |
+	    (((timing->hdelay >> 8) & 0x03) << 2) |
+	    ((timing->hactive >> 8) & 0x03);
+	init[4 * 2 - 1] = timing->vdelay & 0xff;
+	init[5 * 2 - 1] = timing->vactive & 0xff;
+	init[6 * 2 - 1] = timing->hdelay & 0xff;
+	init[7 * 2 - 1] = timing->hactive & 0xff;
+	init[8 * 2 - 1] = timing->hscale >> 8;
+	init[9 * 2 - 1] = timing->hscale & 0xff;
+
+	bt819_write(client, 0x1f, 0x00);
+	mdelay(1);
+	return bt819_write_block(client, init, sizeof(init));
+
+}
+
+/* ----------------------------------------------------------------------- */
+
+static int bt819_attach(struct i2c_adapter *adap, int addr,
+			  unsigned short flags, int kind)
+{
+	int i;
+	struct bt819 *decoder;
+	struct i2c_client *client;
+	
+	MOD_INC_USE_COUNT;
+
+	DEBUG(printk(KERN_INFO "bt819: attach\n"));		
+	
+	client = kmalloc(sizeof *client, GFP_KERNEL);
+	if (!client)
+		MOD_DEC_USE_COUNT;
+		return -ENOMEM;
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adap;
+	client->addr = addr;
+	strcpy(client->name, "bt819");
+
+	client->data = decoder = kmalloc(sizeof(struct bt819), GFP_KERNEL);
+	if (decoder == NULL) {
+		kfree(client);
+		MOD_DEC_USE_COUNT;
+		return -ENOMEM;
+	}
+
+	memset(decoder, 0, sizeof(struct bt819));
+	decoder->norm = VIDEO_MODE_NTSC;
+	decoder->input = 0;
+	decoder->enable = 1;
+	decoder->bright = 32768;
+	decoder->contrast = 32768;
+	decoder->hue = 32768;
+	decoder->sat = 32768;
+	decoder->initialized = 0;
+
+	i = bt819_init(client);
+	if (i < 0) {
+		printk(KERN_ERR "%s: bt819_attach: init status %d\n",
+		       client->name, i);
+	} else {
+		printk(KERN_INFO "%s: bt819_attach: chip version %x\n",
+		       client->name, bt819_read(client, 0x17) & 0x0f);
+	}
+	return 0;
+}
+
+static int bt819_probe(struct i2c_adapter *adap)
+{
+	int ret;
+	
+	ret = i2c_probe(adap, &addr_data, bt819_attach);
+	DEBUG(printk(KERN_INFO "bt819: i2c_probe=%d\n", ret));		
+	return ret;
+}
+
+static int bt819_detach(struct i2c_client *client)
+{
+	struct bt819 *decoder = client->data;
+
+	i2c_detach_client(client);
+	
+	kfree(decoder);
+	kfree(client);
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static int bt819_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	int temp;
+	struct bt819 *decoder = client->data;
+
+	if (!decoder->initialized) {	// First call to bt819_init could be
+		bt819_init(client);	// without #FRST = 0
+		decoder->initialized = 1;
+	}
+
+	switch (cmd) {
+
+	case DECODER_GET_CAPABILITIES:
+		{
+			struct video_decoder_capability *cap = arg;
+
+			cap->flags
+			    = VIDEO_DECODER_PAL
+			    | VIDEO_DECODER_NTSC | VIDEO_DECODER_CCIR;
+			cap->inputs = 8;
+			cap->outputs = 1;
+		}
+		break;
+
+	case DECODER_GET_STATUS:
+		{
+			int *iarg = arg;
+			int status;
+			int res;
+
+			status = bt819_read(client, 0x00);
+			res = 0;
+			if ((status & 0x80)) {
+				res |= DECODER_STATUS_GOOD;
+			}
+			switch (decoder->norm) {
+			case VIDEO_MODE_NTSC:
+				res |= DECODER_STATUS_NTSC;
+				break;
+			case VIDEO_MODE_PAL:
+				res |= DECODER_STATUS_PAL;
+				break;
+			default:
+			case VIDEO_MODE_AUTO:
+				if ((status & 0x10)) {
+					res |= DECODER_STATUS_PAL;
+				} else {
+					res |= DECODER_STATUS_NTSC;
+				}
+				break;
+			}
+			res |= DECODER_STATUS_COLOR;
+			*iarg = res;
+
+			DEBUG(printk(KERN_INFO "%s-bt819: get status %x\n",
+				     client->name, *iarg));
+		}
+		break;
+
+	case DECODER_SET_NORM:
+		{
+			int *iarg = arg;
+			struct timing *timing;
+
+			DEBUG(printk(KERN_INFO "%s-bt819: set norm %x\n",
+				     client->name, *iarg));
+
+			if (*iarg == VIDEO_MODE_NTSC) {
+				bt819_setbit(client, 0x01, 0, 1);
+				bt819_setbit(client, 0x01, 1, 0);
+				bt819_write(client, 0x18, 0x68);
+				bt819_write(client, 0x19, 0x5d);
+				//bt819_setbit(client, 0x1a,  5, 1);
+				timing = &timing_data[VIDEO_MODE_NTSC];
+			} else {
+				bt819_setbit(client, 0x01, 0, 1);
+				bt819_setbit(client, 0x01, 1, 1);
+				bt819_write(client, 0x18, 0x7f);
+				bt819_write(client, 0x19, 0x72);
+				//bt819_setbit(client, 0x1a,  5, 0);
+				timing = &timing_data[VIDEO_MODE_PAL];
+			}
+
+			bt819_write(client, 0x03,
+				    (((timing->vdelay >> 8) & 0x03) << 6) |
+				    (((timing->
+				       vactive >> 8) & 0x03) << 4) |
+				    (((timing->
+				       hdelay >> 8) & 0x03) << 2) |
+				    ((timing->hactive >> 8) & 0x03));
+			bt819_write(client, 0x04, timing->vdelay & 0xff);
+			bt819_write(client, 0x05, timing->vactive & 0xff);
+			bt819_write(client, 0x06, timing->hdelay & 0xff);
+			bt819_write(client, 0x07, timing->hactive & 0xff);
+			bt819_write(client, 0x08, timing->hscale >> 8);
+			bt819_write(client, 0x09, timing->hscale & 0xff);
+			decoder->norm = *iarg;
+		}
+		break;
+
+	case DECODER_SET_INPUT:
+		{
+			int *iarg = arg;
+
+			DEBUG(printk(KERN_INFO "%s-bt819: set input %x\n",
+				     client->name, *iarg));
+
+			if (*iarg < 0 || *iarg > 7) {
+				return -EINVAL;
+			}
+
+			if (decoder->input != *iarg) {
+				decoder->input = *iarg;
+				/* select mode */
+				if (decoder->input == 0) {
+					bt819_setbit(client, 0x0b, 6, 0);
+					bt819_setbit(client, 0x1a, 1, 1);
+				} else {
+					bt819_setbit(client, 0x0b, 6, 1);
+					bt819_setbit(client, 0x1a, 1, 0);
+				}
+			}
+		}
+		break;
+
+	case DECODER_SET_OUTPUT:
+		{
+			int *iarg = arg;
+
+			DEBUG(printk(KERN_INFO "%s-bt819: set output %x\n",
+				     client->name, *iarg));
+
+			/* not much choice of outputs */
+			if (*iarg != 0) {
+				return -EINVAL;
+			}
+		}
+		break;
+
+	case DECODER_ENABLE_OUTPUT:
+		{
+			int *iarg = arg;
+			int enable = (*iarg != 0);
+
+			DEBUG(printk
+			      (KERN_INFO "%s-bt819: enable output %x\n",
+			       client->name, *iarg));
+
+			if (decoder->enable != enable) {
+				decoder->enable = enable;
+
+				if (decoder->enable) {
+					bt819_setbit(client, 0x16, 7, 0);
+				} else {
+					bt819_setbit(client, 0x16, 7, 1);
+				}
+			}
+		}
+		break;
+
+	case DECODER_SET_PICTURE:
+		{
+			struct video_picture *pic = arg;
+
+			DEBUG(printk
+			      (KERN_INFO
+			       "%s-bt819: set picture brightness %d contrast %d colour %d\n",
+			       client->name, pic->brightness,
+			       pic->contrast, pic->colour));
+
+
+			if (decoder->bright != pic->brightness) {
+				/* We want -128 to 127 we get 0-65535 */
+				decoder->bright = pic->brightness;
+				bt819_write(client, 0x0a,
+					    (decoder->bright >> 8) - 128);
+			}
+
+			if (decoder->contrast != pic->contrast) {
+				/* We want 0 to 511 we get 0-65535 */
+				decoder->contrast = pic->contrast;
+				bt819_write(client, 0x0c,
+					    (decoder->
+					     contrast >> 7) & 0xff);
+				bt819_setbit(client, 0x0b, 2,
+					     ((decoder->
+					       contrast >> 15) & 0x01));
+			}
+
+			if (decoder->sat != pic->colour) {
+				/* We want 0 to 511 we get 0-65535 */
+				decoder->sat = pic->colour;
+				bt819_write(client, 0x0d,
+					    (decoder->sat >> 7) & 0xff);
+				bt819_setbit(client, 0x0b, 1,
+					     ((decoder->
+					       sat >> 15) & 0x01));
+
+				temp = (decoder->sat * 201) / 237;
+				bt819_write(client, 0x0e,
+					    (temp >> 7) & 0xff);
+				bt819_setbit(client, 0x0b, 0,
+					     (temp >> 15) & 0x01);
+			}
+
+			if (decoder->hue != pic->hue) {
+				/* We want -128 to 127 we get 0-65535 */
+				decoder->hue = pic->hue;
+				bt819_write(client, 0x0f,
+					    128 - (decoder->hue >> 8));
+			}
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static struct i2c_driver driver = {
+	"i2c bt819 driver",		/* name */
+	I2C_DRIVERID_BT819,	/* ID */
+	I2C_DF_NOTIFY, 
+	bt819_probe,
+	bt819_detach,
+	bt819_command
+};
+
+static struct i2c_client client_template = {
+	"(unset)",		/* name */
+	-1,
+	0,
+	0,
+	NULL,
+	&driver
+};
+
+EXPORT_NO_SYMBOLS;
+
+#ifdef MODULE
+int init_module(void)
+#else
+int bt819_init(void)
+#endif
+{
+	i2c_add_driver(&driver);
+	return 0;
+}
+
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	i2c_del_driver(&driver);
+}
+#endif
+
+MODULE_LICENSE("GPL");
+
+//module_init(bt819_setup);
+//module_exit(bt819_exit);
diff -ruNp linux-2.4.20/drivers/usb/Config.in linux-2.4.20/drivers/usb.np/Config.in
--- linux-2.4.20/drivers/usb/Config.in	2003-04-16 03:56:17.000000000 +0200
+++ linux-2.4.20/drivers/usb.np/Config.in	2003-04-16 03:54:09.000000000 +0200
@@ -80,6 +80,7 @@ if [ ! "$CONFIG_USB" = "n" ]; then
       dep_tristate '  USB STV680 (Pencam) Camera support' CONFIG_USB_STV680 $CONFIG_USB $CONFIG_VIDEO_DEV
       dep_tristate '  USB 3com HomeConnect (aka vicam) support (EXPERIMENTAL)' CONFIG_USB_VICAM $CONFIG_USB $CONFIG_VIDEO_DEV $CONFIG_EXPERIMENTAL
       dep_tristate '  D-Link USB FM radio support (EXPERIMENTAL)' CONFIG_USB_DSBR $CONFIG_USB $CONFIG_VIDEO_DEV $CONFIG_EXPERIMENTAL
+      dep_tristate '  Nogatech USBVISION video support' CONFIG_USB_USBVISION $CONFIG_USB $CONFIG_VIDEO_DEV $CONFIG_EXPERIMENTAL
       dep_tristate '  DABUSB driver' CONFIG_USB_DABUSB $CONFIG_USB
    fi
 
diff -ruNp linux-2.4.20/drivers/usb/i2c-algo-usb.c linux-2.4.20/drivers/usb.np/i2c-algo-usb.c
--- linux-2.4.20/drivers/usb/i2c-algo-usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb.np/i2c-algo-usb.c	2003-04-16 03:54:10.000000000 +0200
@@ -0,0 +1,238 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+
+#include <linux/i2c.h>
+#include "i2c-algo-usb.h"
+
+static inline int try_write_address(struct i2c_adapter *i2c_adap,
+				    unsigned char addr, int retries)
+{
+	struct i2c_algo_usb_data *adap = i2c_adap->algo_data;
+	int i, ret = -1;
+	char buf[4];
+
+	buf[0] = 0x00;
+	for (i = 0; i <= retries; i++) {
+		ret = (adap->outb(i2c_adap->data, addr, buf, 1));
+		// ret = i2c_outb(adap, addr, 0);
+		if (ret == 1)
+			break;	/* success! */
+		udelay(5 /*adap->udelay */ );
+		if (i == retries)	/* no success */
+			break;
+		udelay(adap->udelay);
+	}
+	if (i)
+		printk("i2c-algo-usb.o: needed %d retries for %d\n",
+		       i, addr);
+	return ret;
+}
+
+static inline int try_read_address(struct i2c_adapter *i2c_adap,
+				   unsigned char addr, int retries)
+{
+	struct i2c_algo_usb_data *adap = i2c_adap->algo_data;
+	int i, ret = -1;
+	char buf[4];
+
+	for (i = 0; i <= retries; i++) {
+		ret = (adap->inb(i2c_adap->data, addr, buf, 1));
+		// ret = i2c_outb(adap, addr, 0);
+		if (ret == 1)
+			break;	/* success! */
+		udelay(5 /*adap->udelay */ );
+		if (i == retries)	/* no success */
+			break;
+		udelay(adap->udelay);
+	}
+	if (i)
+		printk("i2c-algo-usb.o: needed %d retries for %d\n",
+		       i, addr);
+	return ret;
+}
+
+static inline int usb_find_address(struct i2c_adapter *i2c_adap,
+				   struct i2c_msg *msg, int retries,
+				   unsigned char *add)
+{
+	unsigned short flags = msg->flags;
+	//struct i2c_algo_usb_data *adap = i2c_adap->algo_data;
+
+	unsigned char addr;
+	int ret;
+	if ((flags & I2C_M_TEN)) {
+		/* a ten bit address */
+		addr = 0xf0 | ((msg->addr >> 7) & 0x03);
+		/* try extended address code... */
+		ret = try_write_address(i2c_adap, addr, retries);
+		if (ret != 1) {
+			printk("died at extended address code.\n");
+			return -EREMOTEIO;
+		}
+		add[0] = addr;
+		if (flags & I2C_M_RD) {
+			/* okay, now switch into reading mode */
+			addr |= 0x01;
+			ret = try_read_address(i2c_adap, addr, retries);
+			if (ret != 1) {
+				printk("died at extended address code.\n");
+				return -EREMOTEIO;
+			}
+		}
+
+	} else {		/* normal 7bit address  */
+		addr = (msg->addr << 1);
+		if (flags & I2C_M_RD)
+			addr |= 1;
+		if (flags & I2C_M_REV_DIR_ADDR)
+			addr ^= 1;
+
+		add[0] = addr;
+		if (flags & I2C_M_RD)
+			ret = try_read_address(i2c_adap, addr, retries);
+		else
+			ret = try_write_address(i2c_adap, addr, retries);
+
+		if (ret != 1) {
+			return -EREMOTEIO;
+		}
+	}
+	return 0;
+}
+
+static int
+usb_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
+{
+	struct i2c_msg *pmsg;
+	struct i2c_algo_usb_data *adap = i2c_adap->algo_data;
+
+	int i, ret;
+	unsigned char addr;
+
+	for (i = 0; i < num; i++) {
+		pmsg = &msgs[i];
+		ret = usb_find_address(i2c_adap, pmsg, i2c_adap->retries,
+				       &addr);
+		if (ret != 0) {
+			printk
+			    ("i2c-algo-usb: NAK from device adr %#2x msg #%d\n",
+			     msgs[i].addr, i);
+			return (ret < 0) ? ret : -EREMOTEIO;
+		}
+
+		if (pmsg->flags & I2C_M_RD) {
+			/* read bytes into buffer */
+			ret = (adap->inb(i2c_adap->data, addr, pmsg->buf,
+					 pmsg->len));
+			if (ret < pmsg->len) {
+				return (ret < 0) ? ret : -EREMOTEIO;
+			}
+		} else {
+			/* write bytes from buffer */
+			ret = (adap->outb(i2c_adap->data, addr, pmsg->buf,
+					  pmsg->len));
+			if (ret < pmsg->len) {
+				return (ret < 0) ? ret : -EREMOTEIO;
+			}
+		}
+	}
+	return num;
+}
+
+static int algo_control(struct i2c_adapter *adapter,
+			unsigned int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+static u32 usb_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR |
+	    I2C_FUNC_PROTOCOL_MANGLING;
+}
+
+
+/* -----exported algorithm data: -------------------------------------	*/
+
+static struct i2c_algorithm i2c_usb_algo = {
+	"USB algorithm",
+	I2C_ALGO_BIT,		/* FIXME */
+	usb_xfer,
+	NULL,
+	NULL,			/* slave_xmit           */
+	NULL,			/* slave_recv           */
+	algo_control,		/* ioctl                */
+	usb_func,		/* functionality        */
+};
+
+/* 
+ * registering functions to load algorithms at runtime 
+ */
+int i2c_usb_add_bus(struct i2c_adapter *adap)
+{
+	printk("i2c-algo-usb.o: hw routines for %s registered.\n",
+	       adap->name);
+
+	/* register new adapter to i2c module... */
+
+	adap->id |= i2c_usb_algo.id;
+	adap->algo = &i2c_usb_algo;
+
+	adap->timeout = 100;	/* default values, should       */
+	adap->retries = 3;	/* be replaced by defines       */
+
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+	i2c_add_adapter(adap);
+
+	return 0;
+}
+
+
+int i2c_usb_del_bus(struct i2c_adapter *adap)
+{
+
+	i2c_del_adapter(adap);
+
+	printk("i2c-algo-usb.o: adapter unregistered: %s\n", adap->name);
+
+#ifdef MODULE
+	MOD_DEC_USE_COUNT;
+#endif
+	return 0;
+}
+
+int __init i2c_algo_usb_init(void)
+{
+	printk("i2c-algo-usb.o: i2c usb algorithm module\n");
+	return 0;
+}
+
+
+
+EXPORT_SYMBOL(i2c_usb_add_bus);
+EXPORT_SYMBOL(i2c_usb_del_bus);
+
+#ifdef MODULE
+
+int init_module(void)
+{
+	return i2c_algo_usb_init();
+}
+
+void cleanup_module(void)
+{
+}
+#endif
+
+MODULE_LICENSE("GPL");
+
diff -ruNp linux-2.4.20/drivers/usb/i2c-algo-usb.h linux-2.4.20/drivers/usb.np/i2c-algo-usb.h
--- linux-2.4.20/drivers/usb/i2c-algo-usb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb.np/i2c-algo-usb.h	2003-04-16 03:54:10.000000000 +0200
@@ -0,0 +1,22 @@
+#ifndef I2C_ALGO_USB_H
+#define I2C_ALGO_USB_H 1
+
+#include <linux/i2c.h>
+
+struct i2c_algo_usb_data {
+	void *data;		/* private data for lowlevel routines */
+	int (*inb) (void *data, unsigned char addr, char *buf, short len);
+	int (*outb) (void *data, unsigned char addr, char *buf, short len);
+
+	/* local settings */
+	int udelay;
+	int mdelay;
+	int timeout;
+};
+
+#define I2C_USB_ADAP_MAX	16
+
+int i2c_usb_add_bus(struct i2c_adapter *);
+int i2c_usb_del_bus(struct i2c_adapter *);
+
+#endif
diff -uNp t1/drivers/usb/Makefile.du11.orig t1/drivers/usb/Makefile
--- t1/drivers/usb/Makefile.du11.orig	2003-08-01 16:35:52.000000000 +0200
+++ t1/drivers/usb/Makefile	2003-08-01 16:38:44.000000000 +0200
@@ -10,7 +10,8 @@ O_TARGET	:= usbdrv.o
 
 # Objects that export symbols.
 
-export-objs		:= hcd.o usb.o pwc-uncompress.o
+export-objs		:= hcd.o usb.o pwc-uncompress.o bt819-new.o \
+			i2c-algo-usb.o saa7111-new.o
 
 # Multipart objects.
 
@@ -119,7 +120,8 @@ obj-$(CONFIG_USB_AUERSWALD)	+= auerswald
 obj-$(CONFIG_USB_BRLVGER)	+= brlvger.o
 obj-$(CONFIG_USB_LCD)		+= usblcd.o
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= speedtch.o
-
+obj-$(CONFIG_USB_USBVISION)	+= usbvision.o i2c-algo-usb.o \
+ 				saa7111-new.o saa7113-new.o bt819-new.o
 # Object files in subdirectories
 mod-subdirs	:= serial host ov511
 
diff -ruNp linux-2.4.20/drivers/usb/saa7111-new.c linux-2.4.20/drivers/usb.np/saa7111-new.c
--- linux-2.4.20/drivers/usb/saa7111-new.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb.np/saa7111-new.c	2003-04-16 03:54:10.000000000 +0200
@@ -0,0 +1,504 @@
+/*
+   saa7111 - Philips SAA7111A video decoder driver version 0.0.3
+
+   - Quick conversion to the new I2C driver by Jose Ignacio Gijon
+   - Colour detection for SECAM by Joerg Heckenbach
+   
+   Copyright (C) 1998 Dave Perks <dperks@ibm.net>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/videodev.h>
+#include <linux/video_decoder.h>
+
+#define DEBUG(x)		/* Debug driver */
+
+//addresses to scan
+static unsigned short normal_i2c[] 	  = { I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { 0x48>>1, 0x4A>>1, I2C_CLIENT_END };
+static unsigned short probe[2]		  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short probe_range[2]  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore[2] 	  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short force[2] 		  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static struct i2c_client_address_data addr_data = {
+	normal_i2c, normal_i2c_range,
+	probe, probe_range,
+	ignore, ignore_range,
+	force
+};
+
+static struct i2c_driver saa7111_driver;
+static struct i2c_client client_template;
+
+/* ----------------------------------------------------------------------- */
+
+struct saa7111 {
+//      struct i2c_bus *bus;
+//      int addr;
+	unsigned char reg[32];
+
+	int norm;
+	int input;
+	int enable;
+	int bright;
+	int contrast;
+	int hue;
+	int sat;
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int saa7111_write(struct i2c_client *client, unsigned char subaddr,
+			 unsigned char data)
+{
+	unsigned char buffer[2];
+
+	buffer[0] = subaddr;
+	buffer[1] = data;
+	if (2 != i2c_master_send(client, buffer, 2)) {
+		printk(KERN_WARNING
+		       "saa7111: I/O error, trying (write %d 0x%x)\n",
+		       subaddr, data);
+		return -1;
+	}
+	return 0;
+}
+
+static int saa7111_write_block(struct i2c_client *client,
+			       unsigned const char *data, unsigned int len)
+{
+	if (len != i2c_master_send(client, data, len)) {
+		printk(KERN_WARNING "saa7111: I/O error, trying write\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int saa7111_read(struct i2c_client *client, unsigned char subaddr)
+{
+	unsigned char buffer;
+
+	if (1 != i2c_master_send(client, &subaddr, 1)) {
+		printk(KERN_WARNING
+		       "saa7111: I/O error, trying (write %d)\n", subaddr);
+		return -1;
+	}
+	if (1 != i2c_master_recv(client, &buffer, 1)) {
+		printk(KERN_WARNING "saa7111: I/O error, trying (read)\n");
+		return -1;
+	}
+	printk(KERN_WARNING "saa7111_read 0x%02X\n", buffer);
+	return buffer;
+
+}
+
+/* ----------------------------------------------------------------------- */
+
+static int saa7111_attach(struct i2c_adapter *adap, int addr,
+			  unsigned short flags, int kind)
+{
+	int i;
+	struct saa7111 *decoder;
+	struct i2c_client *client;
+	
+	static const unsigned char init[] = {
+		0x00, 0x00,	/* 00 - ID byte */
+		0x01, 0x00,	/* 01 - IDEL=8 */
+
+		/*front end */
+		0x02, 0xd0,	/* 02 - FUSE=3, GUDL=2, MODE=0 */
+		0x03, 0x23,	/* 03 - HLNRS=0, VBSL=1, WPOFF=0, HOLDG=0, GAFIX=0, GAI1=256, GAI2=256 */
+		0x04, 0x00,	/* 04 - GAI1=256 */
+		0x05, 0x00,	/* 05 - GAI2=256 */
+
+		/* decoder */
+		0x06, 0xEC, 	/* 06 - HSB at  13(50Hz) /  17(60Hz) pixels after end of last line */
+		0x07, 0xE0, 	/* 07 - HSS at 113(50Hz) / 117(60Hz) pixels after end of last line */
+		0x08, 0xc8,	/* 08 - AUFD=1, FSEL=1, EXFIL=0, VTRC=1, HPLL=0, VNOI=0 */
+		0x09, 0x01,	/* 09 - BYPS=0, PREF=0, BPSS=0, VBLB=0, UPTCV=0, APER=1 */
+		0x0a, 0x80,	/* 0a - BRIG=128 */
+		0x0b, 0x47,	/* 0b - CONT=1.109 */
+		0x0c, 0x40,	/* 0c - SATN=1.0 */
+		0x0d, 0x00,	/* 0d - HUE=0 */
+		0x0e, 0x01,	/* 0e - CDTO=0, CSTD=0, DCCF=0, FCTC=0, CHBW=1 */
+		0x0f, 0x00,	/* 0f - reserved */
+		0x10, 0x48,	/* 10 - OFTS=1, HDEL=0, VRLN=1, YDEL=0 */
+		0x11, 0x1c,	/* 11 - GPSW=0, CM99=0, FECO=0, COMPO=1, OEYC=1, OEHV=1, VIPB=0, COLO=0 */
+		0x12, 0x00,	/* 12 - output control 2 */
+		0x13, 0x00,	/* 13 - output control 3 */
+		0x14, 0x00,	/* 14 - reserved */
+		0x15, 0x00,	/* 15 - VBI */
+		0x16, 0x00,	/* 16 - VBI */
+		0x17, 0x00,	/* 17 - VBI */
+	};
+
+	
+	client = kmalloc(sizeof *client, GFP_KERNEL);
+	if (!client)
+		return -ENOMEM;
+	memcpy(client, &client_template, sizeof(struct i2c_client));
+	client->adapter = adap;
+	client->addr = addr;
+	strcpy(client->name, "saa7111");
+
+	client->data = decoder = kmalloc(sizeof *decoder, GFP_KERNEL);
+	if (!decoder)
+		return -ENOMEM;
+	memset(decoder, 0, sizeof *decoder);
+
+	decoder->norm = VIDEO_MODE_NTSC;
+	decoder->input = 0;
+	decoder->enable = 1;
+	decoder->bright = 32768;
+	decoder->contrast = 32768;
+	decoder->hue = 32768;
+	decoder->sat = 32768;
+
+//                printk(KERN_INFO "%s_attach: chip version %x\n", client->name,
+//                                saa7111_read(client, 0x00));
+
+	i = saa7111_write_block(client, init, sizeof(init));
+	if (i < 0) {
+		printk(KERN_ERR "%s_attach: init status %d\n",
+		       client->name, i);
+	} else {
+		printk(KERN_INFO "%s_attach: chip version %x\n",
+		       client->name, saa7111_read(client, 0x00));
+	}
+
+	MOD_INC_USE_COUNT;
+	printk(KERN_INFO "saa7111: init\n");
+
+	i2c_attach_client(client);
+	return 0;
+}
+
+static int saa7111_probe(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, saa7111_attach);
+}
+
+static int saa7111_detach(struct i2c_client *client)
+{
+	struct saa7111 *s = client->data;
+
+	i2c_detach_client(client);
+
+	kfree(s);
+	kfree(client);
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static int saa7111_command(struct i2c_client *client,
+			   unsigned int cmd, void *arg)
+{
+	struct saa7111 *decoder = client->data;
+
+	switch (cmd) {
+
+#if defined(DECODER_DUMP)
+	case DECODER_DUMP:
+		{
+			int i;
+
+			for (i = 0; i < 32; i += 16) {
+				int j;
+
+				printk("KERN_DEBUG %s: %03x", client->name,
+				       i);
+				for (j = 0; j < 16; ++j) {
+					printk(" %02x",
+					       saa7111_read(client,
+							    i + j));
+				}
+				printk("\n");
+			}
+		}
+		break;
+#endif				/* defined(DECODER_DUMP) */
+
+	case DECODER_GET_CAPABILITIES:
+		{
+			struct video_decoder_capability *cap = arg;
+
+			cap->flags
+			    = VIDEO_DECODER_PAL
+			    | VIDEO_DECODER_SECAM
+			    | VIDEO_DECODER_NTSC
+			    | VIDEO_DECODER_AUTO | VIDEO_DECODER_CCIR;
+			cap->inputs = 8;
+			cap->outputs = 1;
+		}
+		break;
+
+	case DECODER_GET_STATUS:
+		{
+			int *iarg = arg;
+			int status;
+			int res;
+
+			status = saa7111_read(client, 0x1f);
+			res = 0;
+			if ((status & (1 << 6)) == 0) {
+				res |= DECODER_STATUS_GOOD;
+			}
+			switch (decoder->norm) {
+			case VIDEO_MODE_NTSC:
+				res |= DECODER_STATUS_NTSC;
+				break;
+			case VIDEO_MODE_PAL:
+				res |= DECODER_STATUS_PAL;
+				break;
+			case VIDEO_MODE_SECAM:
+				res |= DECODER_STATUS_SECAM;
+				break;
+			default:
+			case VIDEO_MODE_AUTO:
+				if ((status & (1 << 5)) != 0) {
+					res |= DECODER_STATUS_NTSC;
+				} else {
+					res |= DECODER_STATUS_PAL;
+				}
+				break;
+			}
+			if ((status & (1 << 0)) != 0) {
+				res |= DECODER_STATUS_COLOR;
+			}
+			*iarg = res;
+		}
+		break;
+
+	case DECODER_SET_NORM:
+		{
+			int *iarg = arg;
+
+			switch (*iarg) {
+
+			case VIDEO_MODE_SECAM:
+				//Field selection 50Hz
+				saa7111_write(client, 0x08,
+					(decoder->reg[0x08] & 0x3F) | 0x00);
+				//Colour standard PAL/SECAM
+				saa7111_write(client, 0x0E,
+					(decoder->reg[0x0E] & 0x8F) | 0x50);
+				break;	
+			case VIDEO_MODE_NTSC:
+				//Field selection 60Hz
+				saa7111_write(client, 0x08,
+					(decoder->reg[0x08] & 0x3f) | 0x40);
+				//Colour standard PAL_BGHI/NTSC_MJ
+				saa7111_write(client, 0x0E,
+					(decoder->reg[0x0E] & 0x8F) | 0x00);
+				break;
+
+			case VIDEO_MODE_PAL:
+				//Field selection 50Hz
+				saa7111_write(client, 0x08,
+					(decoder->reg[0x08] & 0x3f) | 0x00);
+				//Colour standard PAL_BGHI/NTSC_MJ
+				saa7111_write(client, 0x0E,
+					(decoder->reg[0x0E] & 0x8F) | 0x00);
+				break;
+
+			case VIDEO_MODE_AUTO:
+				//Field selection auto
+				saa7111_write(client, 0x08,
+					(decoder->reg[0x08] & 0x3f) | 0x80);
+				//Colour standard PAL_BGHI/NTSC_MJ
+				saa7111_write(client, 0x0E,
+					(decoder->reg[0x0E] & 0x8F) | 0x00);
+				break;
+
+			default:
+				return -EINVAL;
+
+			}
+			decoder->norm = *iarg;
+		}
+		break;
+
+	case DECODER_SET_INPUT:
+		{
+			int *iarg = arg;
+
+			if (*iarg < 0 || *iarg > 7) {
+				return -EINVAL;
+			}
+			if (decoder->input != *iarg) {
+				decoder->input = *iarg;
+				/* select mode */
+				saa7111_write(client, 0x02,
+					      (decoder->reg[0x02] & 0xf8) |
+					      decoder->input);
+				/* bypass chrominance trap for modes 4..7 */
+				saa7111_write(client, 0x09,
+					      (decoder->reg[0x09] & 0x7f) |
+					      ((decoder->input > 3) ? 0x80 : 0));
+			}
+		}
+		break;
+
+	case DECODER_SET_OUTPUT:
+		{
+			int *iarg = arg;
+
+			/* not much choice of outputs */
+			if (*iarg != 0) {
+				return -EINVAL;
+			}
+		}
+		break;
+
+	case DECODER_ENABLE_OUTPUT:
+		{
+			int *iarg = arg;
+			int enable = (*iarg != 0);
+
+			if (decoder->enable != enable) {
+				decoder->enable = enable;
+
+//RJ:If output should be disabled (for playing videos), we also need a open PLL.
+//     The input is set to 0 (where no input source is connected), although this
+//     is not necessary.
+//
+//     If output should be enabled, we have to reverse the above.
+
+				if (decoder->enable) {
+					saa7111_write(client, 0x02,
+						      (decoder->
+						       reg[0x02] & 0xf8) |
+						      decoder->input);
+					saa7111_write(client, 0x08,
+						      (decoder->
+						       reg[0x08] & 0xfb));
+					saa7111_write(client, 0x11,
+						      (decoder->
+						       reg[0x11] & 0xf3) |
+						      0x0c);
+				} else {
+					saa7111_write(client, 0x02,
+						      (decoder->
+						       reg[0x02] & 0xf8));
+					saa7111_write(client, 0x08,
+						      (decoder->
+						       reg[0x08] & 0xfb) |
+						      0x04);
+					saa7111_write(client, 0x11,
+						      (decoder->
+						       reg[0x11] & 0xf3));
+				}
+			}
+		}
+		break;
+
+	case DECODER_SET_PICTURE:
+		{
+			struct video_picture *pic = arg;
+
+			if (decoder->bright != pic->brightness) {
+				/* We want 0 to 255 we get 0-65535 */
+				decoder->bright = pic->brightness;
+				saa7111_write(client, 0x0a,
+					      decoder->bright >> 8);
+			}
+			if (decoder->contrast != pic->contrast) {
+				/* We want 0 to 127 we get 0-65535 */
+				decoder->contrast = pic->contrast;
+				saa7111_write(client, 0x0b,
+					      decoder->contrast >> 9);
+			}
+			if (decoder->sat != pic->colour) {
+				/* We want 0 to 127 we get 0-65535 */
+				decoder->sat = pic->colour;
+				saa7111_write(client, 0x0c,
+					      decoder->sat >> 9);
+			}
+			if (decoder->hue != pic->hue) {
+				/* We want -128 to 127 we get 0-65535 */
+				decoder->hue = pic->hue;
+				saa7111_write(client, 0x0d ,
+					      (decoder->hue - 32768) >> 8);
+			}
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static struct i2c_driver saa7111_driver = {
+	"SAA7111",
+	I2C_DRIVERID_SAA7111A,	/* ????? */
+	I2C_DF_NOTIFY,
+	saa7111_probe,
+	saa7111_detach,
+	saa7111_command,
+};
+
+static struct i2c_client client_template = {
+	"(unset)",		/* name */
+	I2C_DRIVERID_SAA7111A,
+	0,
+	0,
+	NULL,
+	&saa7111_driver
+};
+
+
+EXPORT_NO_SYMBOLS;
+
+#ifdef MODULE
+int init_module(void)
+#else
+int saa7111_init(void)
+#endif
+{
+	i2c_add_driver(&saa7111_driver);
+	return 0;
+}
+
+
+
+#ifdef MODULE
+
+void cleanup_module(void)
+{
+	i2c_del_driver(&saa7111_driver);
+}
+
+#endif
+
+MODULE_LICENSE("GPL");
+
diff -ruNp linux-2.4.20/drivers/usb/saa7113-new.c linux-2.4.20/drivers/usb.np/saa7113-new.c
--- linux-2.4.20/drivers/usb/saa7113-new.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb.np/saa7113-new.c	2003-04-16 03:54:10.000000000 +0200
@@ -0,0 +1,539 @@
+/*
+    SAA7113 - Philips video decoder driver
+
+    Copyright (C) 2000 Ralph Metzler <ralph@convergence.de>
+                  for Convergence Integrated Media GmbH
+
+    based on the SAAA7110 and SAA7111 drivers by:
+
+    Copyright (C) 1998 Pauline Middelink <middelin@polyware.nl>
+
+    Copyright (C) 1998 Dave Perks <dperks@ibm.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/    
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/wrapper.h>
+#include <linux/video_decoder.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/segment.h>
+
+#include <linux/videodev.h>
+#include "saa7113-new.h"
+#include <linux/i2c.h>
+#include <linux/video_decoder.h>
+
+#define DEBUG(x)			/* remove when no long debugging */
+
+#define	I2C_DELAY		10	/* 10 us or 100khz */
+
+//addresses to scan
+static unsigned short normal_i2c[]	  = { I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { 0x48>>1, 0x4A>>1, I2C_CLIENT_END };
+static unsigned short probe[2]		  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short probe_range[2]  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore[2]	 	  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short force[2]		  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static struct i2c_client_address_data addr_data = {
+	normal_i2c, normal_i2c_range,
+	probe, probe_range,
+	ignore, ignore_range,
+	force
+};
+
+
+static struct i2c_client client_template;
+
+struct saa7113 {
+        struct i2c_client *client;
+        int addr;
+	unsigned char reg[0x62];
+
+	int norm;
+	int input;
+	int enable;
+	int bright;
+	int contrast;
+	int hue;
+	int sat;
+};
+
+static int saa7113_write(struct i2c_client *client, 
+                    unsigned char reg, unsigned char data)
+{
+        int ret;
+        unsigned char msg[] = {0x1f, 0x00};
+
+        msg[0]=reg; msg[1]=data;
+        ret=i2c_master_send(client, msg, 2);
+        if (ret!=2) 
+                printk("saa7113_write error\n");
+        ((struct saa7113 *) client->data)->reg[reg]=data;
+        return ret;
+}
+
+static int saa7113_write_block(struct i2c_client *client, const unsigned char *regs)
+{
+        unsigned char reg, data;
+
+        while (*regs!=0xff) {
+                reg =*(regs++);
+                data=*(regs++);
+                if (saa7113_write(client, reg, data)<0)
+                        return -1;
+        }
+        return 0;
+}
+
+static int saa7113_read(struct i2c_client *client, unsigned char subaddr)
+{
+	unsigned char buffer;
+
+	if (1 != i2c_master_send(client, &subaddr, 1)) {
+		printk(KERN_WARNING
+		       "saa7113: I/O error, trying (write %d)\n", subaddr);
+		return -1;
+	}
+	if (1 != i2c_master_recv(client, &buffer, 1)) {
+		printk(KERN_WARNING "saa7113: I/O error, trying (read)\n");
+		return -1;
+	}
+	printk(KERN_WARNING "saa7113_read 0x%02X\n", buffer);
+	return (int)buffer;
+
+}
+/*{
+        struct i2c_adapter *adap=client->adapter;
+        unsigned char mm1[] = {0x1e};
+        unsigned char mm2[] = {0x00};
+        struct i2c_msg msgs[2];
+        
+        msgs[0].flags=0;
+        msgs[1].flags=I2C_M_RD;
+        msgs[0].addr=msgs[1].addr=client->addr;
+        mm1[0]=reg;
+        msgs[0].len=1; msgs[1].len=1;
+        msgs[0].buf=mm1; msgs[1].buf=mm2;
+        i2c_transfer(adap, msgs, 2);
+        
+        return mm2[0];
+}*/
+
+static const unsigned char init_saa7113[] = {
+        0x01, 0x08, 
+        0x02, 0xc0, /* c7 s-video */ 
+        0x03, 0x23, 
+        0x04, 0x00, 
+        0x05, 0x00, 
+        0x06, 0xe9, /* Start of hsync */
+        0x07, 0x0d, /* End of hsync */
+
+        0x08, 0x88, 
+        0x09, 0x00, 
+        0x0a, 0x80, 
+        0x0b, 0x47, 
+        0x0c, 0x40, 
+        0x0d, 0x00,
+        0x0e, 0x01, 
+        0x0f, 0x2a, /* Use automatic chromance gain */
+
+        0x10, 0x28,
+        0x11, 0x1C, 
+        0x12, 0xc8, /* RTS0 -> programmable HS, RTS1 -> V123., don't know about RTS1 */ 
+        0x13, 0x00,
+        0x15, 0x00,
+        0x16, 0x00, 
+        0x17, 0x00,
+
+        0x40, 0x82,
+        0x58, 0x00,
+        0x59, 0x54,
+        0x5a, 0x0a,
+        0x5b, 0x83,
+        0x5e, 0x00,
+
+        0xff
+};
+
+
+void init(struct i2c_client *client)
+{
+    struct saa7113 *decoder=(struct saa7113 *) client->data;
+
+	decoder->addr = client->addr;
+	decoder->norm = VIDEO_MODE_AUTO;
+	decoder->input = 0;
+	decoder->enable = 1;
+	decoder->bright = 32768;
+	decoder->contrast = 32768;
+	decoder->hue = 32768;
+	decoder->sat = 32768;
+
+        decoder->client=client;
+
+        saa7113_write_block(client, init_saa7113);
+        printk("saa7113: status=%02x\n", saa7113_read(client, 0x1f));
+}
+
+
+static int saa7113_attach(struct i2c_adapter *adap, int addr, 
+				unsigned short flags, int kind)
+{
+        struct saa7113 *decoder;
+        struct i2c_client *client;
+
+		client = kmalloc(sizeof *client, GFP_KERNEL);
+		if (!client)
+			return -ENOMEM;
+		memcpy(client, &client_template, sizeof(struct i2c_client));
+
+        client->adapter = adap;
+		client->addr = addr;
+		strcpy(client->name, "saa7113");
+		
+        client->data=decoder=kmalloc(sizeof(struct saa7113),GFP_KERNEL);
+        if (decoder==NULL) {
+                kfree(client);
+                return -ENOMEM;
+        }
+		memset(decoder, 0, sizeof(struct saa7113));
+        init(client);
+
+        printk("saa7113: version=%02x\n", saa7113_read(client, 0x00));
+
+		MOD_INC_USE_COUNT;
+        printk("saa7113: attaching SAA7113 at 0x%02x\n", (client->addr)<<1);
+        i2c_attach_client(client);
+
+        printk("saa7113: attached to adapter %s\n", adap->name);
+        return 0;
+}
+/* ----------------------------------------------------------------------- */
+
+
+static int saa7113_probe(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, saa7113_attach);
+}
+
+
+int saa7113_detach(struct i2c_client *client)
+{
+        i2c_detach_client(client);
+        kfree(client->data);
+        kfree(client);
+		MOD_DEC_USE_COUNT;
+        return 0;
+}
+
+static int saa7113_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+        struct saa7113 *decoder= (struct saa7113 *) client->data;
+        int v;
+                
+        switch (cmd) {
+
+        case DECODER_GET_CAPABILITIES:
+                {
+                        struct video_decoder_capability *dc = arg;
+			dc->flags = VIDEO_DECODER_PAL
+				  | VIDEO_DECODER_NTSC
+				  | VIDEO_DECODER_SECAM
+				  | VIDEO_DECODER_AUTO
+				  | VIDEO_DECODER_CCIR;
+			dc->inputs = 2;
+			dc->outputs = 1;
+		}
+		break;
+
+	case DECODER_GET_STATUS:
+		{
+			int *iarg = arg;
+			int status;
+			int res;
+
+			status = saa7113_read(client, 0x1f);
+			res = 0;
+			if ((status & (1 << 6)) == 0) {
+				res |= DECODER_STATUS_GOOD;
+			}
+			switch (decoder->norm) {
+			case VIDEO_MODE_NTSC:
+				res |= DECODER_STATUS_NTSC;
+				break;
+			case VIDEO_MODE_PAL:
+				res |= DECODER_STATUS_PAL;
+				break;
+			case VIDEO_MODE_SECAM:
+				res |= DECODER_STATUS_SECAM;
+				break;
+			default:
+			case VIDEO_MODE_AUTO:
+				if ((status & (1 << 5)) != 0) {
+					res |= DECODER_STATUS_NTSC;
+				} else {
+					res |= DECODER_STATUS_PAL;
+				}
+				break;
+			}
+			if ((status & (1 << 0)) != 0) {
+				res |= DECODER_STATUS_COLOR;
+			}
+			*iarg = res;
+		}
+		break;
+
+
+        case DECODER_SET_NORM:
+                v = *(int*)arg;
+
+                switch (v) {
+                case VIDEO_MODE_NTSC:
+			//Field selection 60Hz
+                        saa7113_write(client, 0x08,
+                                 (decoder->reg[0x08] & 0x3f) | 0x40);
+			//Colour standard NTSC_MJ
+			saa7113_write(client, 0x0E,
+				 (decoder->reg[0x0E] & 0x8F) | 0x00);
+                        break;
+                        
+                case VIDEO_MODE_PAL:
+			//Field selection 50Hz
+                        saa7113_write(client, 0x08,
+                                 (decoder->reg[0x08] & 0x3f) | 0x00);
+			//Colour standard PAL_BGHI
+		        saa7113_write(client, 0x0E,
+                                 (decoder->reg[0x0E] & 0x8F) | 0x00);
+                        break;
+
+		case VIDEO_MODE_SECAM:
+			 //Field selection 50Hz
+                         saa7113_write(client, 0x08,
+                                 (decoder->reg[0x08] & 0x3F) | 0x00);
+			 //Colour standard PAL/SECAM
+			 saa7113_write(client, 0x0E,
+                                 (decoder->reg[0x0E] & 0x8F) | 0x50);
+                         break;
+
+                case VIDEO_MODE_AUTO:
+			//Field selection auto
+                        saa7113_write(client, 0x08,
+                                 (decoder->reg[0x08] & 0x3f) | 0x80);
+			//Colour standard PAL_BGHI/NTSC_MJ
+			saa7113_write(client, 0x0E,
+			         (decoder->reg[0x0E] & 0x8F) | 0x00);
+                        break;
+
+                default:
+                  	return -EINVAL;
+                  
+                }
+                decoder->norm = v;
+                
+                break;
+
+	case DECODER_SET_INPUT:
+		{
+			int *iarg = arg;
+
+			if (*iarg < 0 || *iarg > 7) {
+				return -EINVAL;
+			}
+			if (decoder->input != *iarg) {
+				decoder->input = *iarg;
+				/* select mode */
+				saa7113_write(client, 0x02, 
+                                         (decoder->reg[0x02] & 0xf8) | decoder->input);
+				/* bypass chrominance trap for modes 4..7 */
+				saa7113_write(client, 0x09, 
+                                         (decoder->reg[0x09] & 0x7f) | 
+                                         ((decoder->input > 3) ? 0x80 : 0));
+			}
+		}
+		break;
+
+
+	 case DECODER_SET_OUTPUT:
+		v = *(int*)arg;
+		/* not much choice of outputs */
+		if (v != 0)
+			return -EINVAL;
+		break;
+
+	case DECODER_ENABLE_OUTPUT:
+		{
+			int *iarg = arg;
+			int enable = (*iarg != 0);
+
+			if (decoder->enable != enable) {
+				decoder->enable = enable;
+
+// RJ: If output should be disabled (for playing videos), we also need a open PLL.
+				//     The input is set to 0 (where no input source is connected), although this
+				//     is not necessary.
+				//
+				//     If output should be enabled, we have to reverse the above.
+
+				if (decoder->enable) {
+					saa7113_write(client, 0x02, 
+                                                 (decoder->reg[0x02] & 0xf8) | 
+                                                 decoder->input);
+					saa7113_write(client, 0x08, 
+                                                 (decoder->reg[0x08] & 0xfb));
+					saa7113_write(client, 0x11, (decoder->reg[0x11] & 0xf3) | 0x0c);
+				} else {
+					saa7113_write(client, 0x02, (decoder->reg[0x02] & 0xf8));
+					saa7113_write(client, 0x08, (decoder->reg[0x08] & 0xfb) | 0x04);
+					saa7113_write(client, 0x11, (decoder->reg[0x11] & 0xf3));
+				}
+			}
+		}
+		break;
+
+	case DECODER_SET_PICTURE:
+		{
+			struct video_picture *pic = arg;
+
+			if (decoder->bright != pic->brightness) {
+				/* We want 0 to 255 we get 0-65535 */
+				decoder->bright = pic->brightness;
+				saa7113_write(client, 0x0a, decoder->bright >> 8);
+			}
+			if (decoder->contrast != pic->contrast) {
+				/* We want 0 to 127 we get 0-65535 */
+				decoder->contrast = pic->contrast;
+				saa7113_write(client, 0x0b, decoder->contrast >> 9);
+			}
+			if (decoder->sat != pic->colour) {
+				/* We want 0 to 127 we get 0-65535 */
+				decoder->sat = pic->colour;
+				saa7113_write(client, 0x0c, decoder->sat >> 9);
+			}
+			if (decoder->hue != pic->hue) {
+				/* We want -128 to 127 we get 0-65535 */
+				decoder->hue = pic->hue;
+				saa7113_write(client, 0x0d, (decoder->hue - 32768) >> 8);
+			}
+		}
+		break;
+
+	 default:            
+		return -EINVAL;
+        }
+        
+        return 0;
+} 
+
+
+void inc_use (struct i2c_client *client)
+{
+#ifdef MODULE
+        MOD_INC_USE_COUNT;
+#endif
+}
+
+void dec_use (struct i2c_client *client)
+{
+#ifdef MODULE
+        MOD_DEC_USE_COUNT;
+#endif
+}
+
+static struct i2c_driver saa7113_driver = {
+        "SAA7113",
+        I2C_DRIVERID_SAA7113,
+        I2C_DF_NOTIFY,
+        saa7113_probe,
+        saa7113_detach,
+        saa7113_command,
+};
+
+static struct i2c_client client_template = {
+        "(unset)",
+        I2C_DRIVERID_SAA7113,
+        0,
+        0,
+        NULL,
+        &saa7113_driver,
+};
+
+
+#ifdef MODULE
+int init_module(void)
+#else
+int saa7113_init(void)
+#endif
+{
+        int res;
+        
+        if ((res = i2c_add_driver(&saa7113_driver))) 
+        {
+                printk("saa7113: Driver registration failed, module not inserted.\n");
+                return res;
+        }
+        
+        printk("saa7113: init_module\n");
+        return 0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+        int res;
+        
+        if ((res = i2c_del_driver(&saa7113_driver))) 
+        {
+                printk("saa7113: Driver deregistration failed, "
+                       "module not removed.\n");
+        }
+}
+#endif
+
+MODULE_LICENSE("GPL");
+
+
+/*
+ * Local variables:
+ * c-indent-level: 8
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -8
+ * c-argdecl-indent: 8
+ * c-label-offset: -8
+ * c-continued-statement-offset: 8
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
+
diff -ruNp linux-2.4.20/drivers/usb/saa7113-new.h linux-2.4.20/drivers/usb.np/saa7113-new.h
--- linux-2.4.20/drivers/usb/saa7113-new.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb.np/saa7113-new.h	2003-04-16 03:54:10.000000000 +0200
@@ -0,0 +1,168 @@
+#ifndef __SAA711X_H__
+#define __SAA711X_H__
+
+
+#define PH7113_CHIP_VERSION                   0x00 
+// (READ ONLY) 
+// ID07 ID06 ID05 ID04 - - - -
+
+#define PH7113_INCREMENT_DELAY                0x01 
+// (1) (1) (1) (1) IDEL3 IDEL2 IDELL1 IDEL0
+
+#define PH7113_ANALOG_INPUT_CONTR_1           0x02 
+// FUSE1 FUSE0 GUDL1 GUDL0 MODE3 MODE2 MODE1 MODE0
+
+#define PH7113_ANALOG_INPUT_CONTR_2           0x03 
+// (1) HLNRS VBSL WPOFF HOLDG GAFIX GAI28 GAI18
+
+#define PH7113_ANALOG_INPUT_CONTR_3           0x04 
+// GAI17 GAI16 GAI15 GAI14 GAI13 GAI12 GAI11 GAI10
+
+#define PH7113_ANALOG_INPUT_CONTR_4           0x05 
+// GAI27 GAI26 GAI25 GAI24 GAI23 GAI22 GAI21 GAI20
+
+#define PH7113_HORIZONTAL_SYNC_START          0x06 
+// HSB7 HSB6 HSB5 HSB4 HSB3 HSB2 HSB1 HSB0
+
+#define PH7113_HORIZONTAL_SYNC_STOP           0x07 
+// HSS7 HSS6 HSS5 HSS4 HSS3 HSS2 HSS1 HSS0
+
+#define PH7113_SYNC_CONTROL                   0x08 
+// AUFD FSEL FOET HTC1 HTC0 HPLL VNOI1 VNOI0
+
+#define PH7113_LUMINANCE_CONTROL              0x09 
+// BYPS PREF BPSS1 BPSS0 VBLB UPTCV APER1 APER0
+
+#define PH7113_LUMINANCE_BRIGHTNESS           0x0A 
+// BRIG7 BRIG6 BRIG5 BRIG4 BRIG3 BRIG2 BRIG1 BRIG0
+
+#define PH7113_LUMINANCE_CONTRAST             0x0B 
+// CONT7 CONT6 CONT5 CONT4 CONT3 CONT2 CONT1 CONT0
+
+#define PH7113_CHROMA_SATURATION              0x0C 
+// SATN7 SATN6 SATN5 SATN4 SATN3 SATN2 SATN1 SATN0
+
+#define PH7113_CHROMA_HUE_CONTROL             0x0D 
+// HUEC7 HUEC6 HUEC5 HUEC4 HUEC3 HUEC2 HUEC1 HUEC0
+
+#define PH7113_CHROMA_CONTROL                 0x0E
+// CDTO CSTD2 CSTD1 CSTD0 DCCF FCTC CHBW1 CHBW0
+
+#define PH7113_CHROMA_GAIN_CONTROL            0x0F 
+// ACGC CGAIN6 CGAIN5 CGAIN4 CGAIN3 CGAIN2 CGAIN1 CGAIN0
+
+#define PH7113_FORMAT_DELAY_CONTROL           0x10 
+// OFTS1 OFTS0 HDEL1 HDEL0 VRLN YDEL2 YDEL1 YDEL0
+
+#define PH7113_OUTPUT_CONTROL_1               0x11 
+// GPSW1 CM99 GPSW0 HLSEL OEYC OERT VIPB COLO
+
+#define PH7113_OUTPUT_CONTROL_2               0x12 
+// RTSE13 RTSE12 RTSE11 RTSE10 RTSE03 RTSE02 RTSE01 RTSE00
+
+#define PH7113_OUTPUT_CONTROL_3               0x13 
+// ADLSB (1) (1) OLDSB FIDP (1) AOSL1 AOSL0
+
+// RESERVED 14 
+// (1) (1) (1) (1) (1) (1) (1) (1)
+
+#define PH7113_V_GATE1_START                  0x15 
+// VSTA7 VSTA6 VSTA5 VSTA4 VSTA3 VSTA2 VSTA1 VSTA0
+
+#define PH7113_V_GATE1_STOP                   0x16 
+// VSTO7 VSTO6 VSTO5 VSTO4 VSTO3 VSTO2 VSTO1 VSTO0
+
+#define PH7113_V_GATE1_MSB                    0x17 
+// (1) (1) (1) (1) (1) (1) VSTO8 VSTA8
+
+// RESERVED 18-1E 
+// (1) (1) (1) (1) (1) (1) (1) (1)
+
+#define PH7113_STATUS_BYTE_0                  0x1F 
+// (READ ONLY, OLDSB=0) 
+// INTL HLVLN FIDT GLIMT GLIMB WIPA COPRO RDCAP
+#define DETECT_COLOR_SIGNAL               0x01
+#define HOR_FREQUENCY_LOCKED              0x40
+
+#define PH7113_STATUS_BYTE_1                  0x1F 
+ // (READ ONLY, OLDSB=1) 
+// INTL HLCK FIDT GLIMT GLIMB WIPA SLTCA CODE
+
+// 20H TO 3FH RESERVED 20 -3F 
+// (1) (1) (1) (1) (1) (1) (1) (1)
+
+#define PH7113_AC1                            0x40 
+// FISET HAM_N FCE HUNT_N (1) CLKSEL1 CLKSEL0 (1)
+
+#define PH7113_LCR2                           0x41 
+// LCR02_7 LCR02_6 LCR02_5 LCR02_4 LCR02_3 LCR02_2 LCR02_1 LCR02_0
+
+#define PH7113_LCR3                           0x42
+#define PH7113_LCR4                           0x43 
+#define PH7113_LCR5                           0x44 
+#define PH7113_LCR6                           0x45 
+#define PH7113_LCR7                           0x46 
+#define PH7113_LCR8                           0x47 
+#define PH7113_LCR9                           0x48 
+#define PH7113_LCR10                          0x49 
+#define PH7113_LCR11                          0x4A 
+#define PH7113_LCR12                          0x4B 
+#define PH7113_LCR13                          0x4C
+#define PH7113_LCR14                          0x4D 
+#define PH7113_LCR15                          0x4E 
+#define PH7113_LCR16                          0x4F
+#define PH7113_LCR17                          0x50
+#define PH7113_LCR18                          0x51
+#define PH7113_LCR19                          0x52 
+#define PH7113_LCR20                          0x53 
+#define PH7113_LCR21                          0x54 
+#define PH7113_LCR22                          0x55 
+#define PH7113_LCR23                          0x56 
+// LCRN_7 LCRN_6 LCRN_5 LCRN_4 LCRN_3 LCRN_2 LCRN_1 LCRN_0
+
+#define PH7113_LCR24                          0x57 
+// LCR24_7 LCR24_6 LCR24_5 LCR24_4 LCR24_3 LCR24_2 LCR24_1 LCR24_0
+
+#define PH7113_FC                             0x58 
+// FC7 FC6 FC5 FC4 FC3 FC2 FC1 FC0
+
+#define PH7113_HOFF                           0x59 
+// HOFF7 HOFF6 HOFF5 HOFF4 HOFF3 HOFF2 HOFF1 HOFF0
+
+#define PH7113_VOFF                           0x5A 
+// VOFF7 VOFF6 VOFF5 VOFF4 VOFF3 VOFF2 VOFF1 VOFF0
+
+#define PH7113_HVOFF                          0x5B 
+// FOFF (1) (1) VOFF8 (1) HOFF10 HOFF9 HOFF8
+
+//( FOR TESTABILITY ) 5C (1) (1) (1) (1) (1) (1) (1) (1)
+
+//RESERVED 5D 
+// (1) (1) (1) (1) (1) (1) (1) (1)
+
+#define PH7113_SLICED_DATA_ID_CODE            0x5E 
+// (1) (1) SDID5 SDID4 SDID3 SDID2 SDID1 SDID0
+
+// RESERVED 5F 
+// (1) (1) (1) (1) (1) (1) (1) (1)
+
+#define PH7113_DR                             0x60 
+// (READ ONLY) 
+// FC8V FC7V VPSV PPV CCV - - -
+
+#define PH7113_LN1                            0x61 
+// (READ ONLY) 
+// - - F21_N LN8 LN7 LN6 LN5 LN4
+
+#define PH7113_LN2                            0x62 
+// (READ ONLY) 
+// LN3 LN2 LN1 LN0 DT3 DT2 DT1 DT0
+
+//RESERVED FOR FUTURE EXTENSIONS 63 TO FF
+// (1) (1) (1) (1) (1) (1) (1) (1)
+
+#define PH7113_MAX_PARAMS                     PH7113_LN2
+
+// 1. All unused control bits must be programmed with logic 0 to ensure compatibility to future enhancements
+
+#endif    // __PHILLIPS_SAA7113_H__
diff -ruNp linux-2.4.20/drivers/usb/usbvision.c linux-2.4.20/drivers/usb.np/usbvision.c
--- linux-2.4.20/drivers/usb/usbvision.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb.np/usbvision.c	2003-04-16 03:54:10.000000000 +0200
@@ -0,0 +1,4243 @@
+/*
+ * USB USBVISION Video device driver 0.3.3-test3 (For Kernel > 2.4.6) 
+ *
+ * Let's call the version 0.... until compression decoding is implemented.
+ *
+ * This driver is written by Jose Ignacio Gijon and Joerg Heckenbach.
+ * It was based on USB CPiA driver written by Peter Pregler,
+ * Scott J. Bertin and Johannes Erdfelt
+ * Ideas are taken from bttv driver by Ralph Metzler, Marcus Metzler &
+ * Gerd Knorr and zoran 36120/36125 driver by Pauline Middelink
+ *
+ * History:
+ *
+ * Mar. 2000 - 15.12.2000:  (0.0.0 - 0.2.0)
+ *     Several alpha drivers and the first beta. 
+ * 	
+ * Since Dec. 2000:  (0.2.1) or (v2.1)
+ *     Code changes or updates by Dwaine Garden and every other person.
+ *
+ *     Added: New Hauppauge TV device  Vendor  ID: 0x0573
+ *                                     Product ID: 0x4D01
+ *            (Thanks to Giovanni Garberoglio)
+ *
+ *     Added: UK Hauppauge WinTV-USB   Vendor  ID: 0x0573
+ *                                     Product ID: 0x4D02
+ *            (Thanks to Derek Freeman-Jones)
+ *
+ * Feb, 2001 - Apr 08, 2001:  (0.3.0)
+ *     - Some fixes. Driver is now more stable.
+ *     - Scratch is organized as ring-buffer now for better performance
+ *     - DGA (overlay) is now supported. 
+ *       !!!!Danger!!!! Clipping is not yet implemented. Your system will
+ *       crash if your video window leaves the screen!!!
+ *     - Max. Framesize is set to 320x240. There isn't more memory on the
+ *       nt1003 video device for the FIFO.
+ *     - Supported video palettes: RGB565, RGB555, RGB24, RGB32
+ *
+ * 
+ * Apr 15, 2001:  (0.3.1-test...)
+ *     - Clipping is implemented
+ *     - NTSC is now coloured (Thanks to Dwaine Garden)
+ *     - Added SECAM colour detection in saa7111-new
+ *     - Added: French Hauppauge WinTV USB  Vendor ID: 0x0573
+ *                                          Product ID: 0x4D03
+ *              (Thanks to Julius Hrivnac)
+ *     - Added: US Hauppauge WINTV USB  Vendor ID: 0x0573
+ *                                      Product ID: 0x4D00
+ *              (Thanks to  Derrick J Brashear)
+ *     - Changes for adding new devices. There's now a table in usbvision.h.
+ *       Adding your devices data to the usbvision_device_data table is all
+ *       you need to add a new device, I hope.
+ *
+ * May 11, 2001: (0.3.2-test...) (Thanks to Derek Freeman-Jones)
+ *     - Support YUV422 raw format for people with hardware scaling.
+ *     - Only power on the device when opened (use option PowerOnAtOpen=0 to disable it).
+ *     - Turn off audio so we can listen to Line In.
+ *
+ * July 5, 2001 - (Patch the driver to run with Kernel 2.4.6)
+ *     - Fixed a problem with the number of parameters passed to video_register_device.
+ *
+ * July 6, 2001 - Added: HAUPPAUGE WINTV-USB FM USA Vendor  ID: 0x0573
+ *                                              	Product ID: 0x4D10
+ *		(Thanks to Braddock Gaskill)
+ *                Added: USBGear USBG-V1 resp. HAMA USB
+ *                						Vendor  ID: 0x0573
+ *                                      Product ID: 0x0003
+ *		(Thanks to Bradley A. Singletary and Juergen Weigert)
+ *
+ * Jan 24, 2002 - (0.3.3-test...)
+ *     - Moved all global variables that are device specific the usb_usbvision struct
+ *     - Fixed the 64x48 unchangable image in xawtv when starting it with overlay
+ *     - Add VideoNorm and TunerType to the usb_device_data table 
+ *     - Checked the audio channels and mute for HAUPPAUGE WinTV USB FM 
+ *     - Implemented the power on when opening the device. But some software opens 
+ *       the device several times when starting. So the i2c parts are just registered
+ *       by an open, when they become deregistered by the next close. You can speed
+ *       up tuner detection, when adding "options tuner addr=your_addr" to /etc/modules.conf
+ *     - Begin to resize the frame in width and height. So it will be possible to watch i.e. 
+ *       384x288 pixels at 23 fps. 
+ *
+ * Feb 10, 2002 
+ *     - Added radio device
+ *
+ *
+ * Jul 30, 2002 - (Thanks Cameron Maxwell)
+ *     - Changes to usbvision.h --fixed usbvision device data structure, incorrectly had (0x0573, 0x4d21) for WinTV-USB II, should be 0x4d20.
+ *     - Changes for device WinTV-USB II (0x0573. 0x4D21).  It does not have a FM tuner.
+ *     - Added the real device HAUPPAUGE WINTV-USB II (PAL) to the device structure in usbvision.h.
+ *     - Changes to saa7113-new, the video is 8 bit data for the Phillips SAA7113 not 16bit like SAA7113.
+ *     - Tuned lots of setup registers for the Phillips SAA7113 video chipset.
+ *     - Changes to the supplied makefile. (Dwaine Garden) Still needs to be fixed so it will compile modules on different distrubutions.
+ *
+ *
+ * Aug 10, 2002 - (Thanks Mike Klinke)
+ *     - Changes to usbvision.txt -- Fixed instructions on the location to copy the contents of the tgz file.
+ *     - Added device WinTV-USB FM Model 621 (0x0573. 0x4D30). There is another device which carries the same name. Kept that device in the device structure.
+ *
+ * Aug 12, 2002 - Dwaine Garden
+ *     - Added the ability to read the NT100x chip for the MaxISOPacketLength and USB Bandwidth Setting of the video device.
+ *     - Adjustments to the SAA7113H code for proper video output.
+ *     - Changes to usbvision.h, so all the devices with FM tuners are working.
+ *
+ * TODO:
+ *     - Fix memory settings for nt1004. It is 4 times as big as the
+ *       nt1003 memory.
+ *     - Implement the decompression algorithm.
+ *     - Add audio on endpoint 3 for nt1004 chip.
+ *     - Clean up the driver.
+ *     - optimization for performance.
+ *     - Add Videotext capability (VBI)
+ *	   - Add interpolating to the resizing of frames (if resizing is useful)
+ *	   - Check audio for other devices
+ *     - Check USBVISION_SUPPORTED_PALETTES and the format checking
+ *     - Supplied Makefile changes.  Needs to compile on multiple linux distrubutions.
+ *     
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/videodev.h>
+#include <linux/vmalloc.h>
+#include <linux/wrapper.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/usb.h>
+#include <asm/io.h>
+#include <linux/video_decoder.h>
+#include <linux/i2c.h>
+#include "i2c-algo-usb.h"
+#include "../drivers/media/video/tuner.h"					/* Arhggggggggggggg !!!!!!!!!!! */
+#include "../drivers/media/video/audiochip.h"  					/*another Arhggggggggg!!!!!!! */
+
+#ifdef CONFIG_KMOD
+#include <linux/kmod.h>
+#endif
+
+#include "usbvision.h"
+
+#define	ENABLE_HEXDUMP	0							/* Enable if you need it */
+
+#define DEBUG(x...) 								/* General Debug */
+#define IODEBUG(x...) 								/* Debug IO */
+#define RIODEBUG(x...) 								/* Debug IO for a radio device */
+#define IRQDEBUG(x...) 								/* Debug IRQ */
+#define OVDEBUG(x...) 								/* Debug overlay */
+#define MDEBUG(x...)								/* Debug memory management */
+
+static int video_nr = -1;							/* Number of Video Devices Initalized */
+static int radio_nr = -1;							/* Number of Radio Devices Initalized */
+static int verbose = 1;								/* Turn the driver into chat mode */
+
+/* Completion states of the data parser */
+typedef enum {
+	scan_Continue,								/* Just parse next item */
+	scan_NextFrame,								/* Frame done, send it to V4L */
+	scan_Out,								/* Not enough data for frame */
+	scan_EndParse								/* End parsing */
+} scan_state_t;
+
+static const int max_imgwidth = MAX_FRAME_WIDTH;
+static const int max_imgheight = MAX_FRAME_HEIGHT;
+static const int min_imgwidth = MIN_FRAME_WIDTH;
+static const int min_imgheight = MIN_FRAME_HEIGHT;
+
+#define FRAMERATE_MIN	0
+#define FRAMERATE_MAX	31
+
+static int usbbandwidth = 0;
+
+enum {
+	VIDEOFORMAT_YUV422 = 0x03,
+	VIDEOFORMAT_YUV420 = 0x14,
+	VIDEOFORMAT_COMPRESS = 0x60,
+};
+
+/*
+ * The value of 'scratch_buf_size' affects quality of the picture
+ * in many ways. Shorter buffers may cause loss of data when client
+ * is too slow. Larger buffers are memory-consuming and take longer
+ * to work with. This setting can be adjusted, but the default value
+ * should be OK for most desktop users.
+ */
+#define DEFAULT_SCRATCH_BUF_SIZE	(0x20000)				/* 128 k Memory Scratch Buffer*/
+static const int scratch_buf_size = DEFAULT_SCRATCH_BUF_SIZE;
+
+static int init_brightness = 128;						/* Initalize the brightness of the video device */
+static int init_contrast = 192;							/* Initalize the contrast of the video device */
+static int init_color = 128;							/* Initalize the color mode of the video device */
+static int init_hue = 128;							/* Initalize the Hue settings of the video device */
+static int hue_correction = 128;
+
+
+static int usbvision_restart_isoc(struct usb_usbvision *usbvision);
+static int usbvision_begin_streaming(struct usb_usbvision *usbvision);
+static int usbvision_muxsel(struct usb_usbvision *usbvision, int channel, int norm);
+static int usbvision_i2c_write(void *data, unsigned char addr, char *buf, short len);
+static int usbvision_i2c_read(void *data, unsigned char addr, char *buf, short len);
+
+/* Bit flags (options) */
+#define FLAGS_RETRY_VIDIOCSYNC		(1 << 0)
+#define	FLAGS_MONOCHROME		(1 << 1)
+#define FLAGS_DISPLAY_HINTS		(1 << 2)
+#define FLAGS_OSD_STATS			(1 << 3)
+#define FLAGS_FORCE_TESTPATTERN		(1 << 4)
+#define FLAGS_SEPARATE_FRAMES		(1 << 5)
+#define FLAGS_CLEAN_FRAMES		(1 << 6)
+
+/* Default Initalization of Device Driver Parameters */
+static int flags = 0;								/* Set the default Overlay Display mode of the device driver */
+static int debug = 0;								/* Set the default Debug Mode of the device driver */
+static int videoformat = VIDEOFORMAT_YUV420; 					/* Set the default video format of the video device */
+static int dga = 1;								/* Set the default Direct Graphic Access */
+static int PowerOnAtOpen = 1;							/* Set the default device to power on at startup */
+
+/* Grab parameters for the device driver */
+MODULE_PARM(flags, "i");							/* Grab the Overlay Display mode of the device driver */
+MODULE_PARM(debug, "i");							/* Grab the Debug Mode of the device driver */
+MODULE_PARM(videoformat, "i");							/* Grab the video format of the video device */
+MODULE_PARM(dga, "i");								/* Grab the Direct Graphic Access */
+MODULE_PARM(PowerOnAtOpen, "i");						/* Grab the device to power on at startup */
+
+/* Misc Stuff */
+MODULE_AUTHOR("module author");
+MODULE_DESCRIPTION("USBVISION USB Video device Driver for Linux");
+MODULE_LICENSE("GPL");
+
+#ifdef MODULE
+static unsigned int autoload = 1;
+#else
+static unsigned int autoload = 0;
+#endif
+
+#define MAX_USBVISION	4							/* Max number of devices supported - Due to USB bus limits */
+
+struct usb_usbvision vdevs[MAX_USBVISION];
+
+
+
+/* Memory management functions */
+
+static struct usb_driver usbvision_driver;
+static void usbvision_release(struct usb_usbvision *usbvision);
+
+
+/* Given PGD from the address space's page table, return the kernel virtual mapping of the physical memory mapped at ADR. */
+static inline unsigned long uvirt_to_kva(pgd_t * pgd, unsigned long adr)
+{
+	unsigned long ret = 0UL;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+	if (!pgd_none(*pgd)) {
+		pmd = pmd_offset(pgd, adr);
+		if (!pmd_none(*pmd)) {
+			ptep = pte_offset(pmd, adr);
+			pte = *ptep;
+			if (pte_present(pte))
+				ret = (unsigned long)
+				    page_address(pte_page(pte));
+			ret |= (adr & (PAGE_SIZE - 1));
+		}
+	}
+	MDEBUG(printk("uv2kva(%lx-->%lx)", adr, ret);)
+	return ret;
+}
+
+static inline unsigned long uvirt_to_bus(unsigned long adr)
+{
+	unsigned long kva, ret;
+	kva = uvirt_to_kva(pgd_offset(current->mm, adr), adr);
+	ret = virt_to_bus((void *) kva);
+	MDEBUG(printk("uv2b(%lx-->%lx)", adr, ret);)
+	return ret;
+}
+
+static inline unsigned long kvirt_to_bus(unsigned long adr)
+{
+	unsigned long va, kva, ret;
+
+	va = VMALLOC_VMADDR(adr);
+	kva = uvirt_to_kva(pgd_offset_k(va), va);
+	ret = virt_to_bus((void *) kva);
+	MDEBUG(printk("kv2b(%lx-->%lx)", adr, ret);)
+	return ret;
+}
+
+/* Here we want the physical address of the memory. This is used when initializing the contents of the */
+/* area and marking the pages as reserved. */
+static inline unsigned long kvirt_to_pa(unsigned long adr)
+{
+	unsigned long va, kva, ret;
+
+	va = VMALLOC_VMADDR(adr);
+	kva = uvirt_to_kva(pgd_offset_k(va), va);
+	ret = __pa(kva);
+	MDEBUG(printk("kv2pa(%lx-->%lx)", adr, ret);)
+	return ret;
+}
+
+static void *rvmalloc(unsigned long size)
+{
+	void *mem;
+	unsigned long adr, page;
+										/* Round it off to PAGE_SIZE */
+	size += (PAGE_SIZE - 1);
+	size &= ~(PAGE_SIZE - 1);
+	mem = vmalloc(size);
+	if (!mem)
+		return NULL;
+	memset(mem, 0, size);							/* Clear the ram out, no junk to the user */
+	adr = (unsigned long) mem;
+	while (size > 0) {
+		page = kvirt_to_pa(adr);
+		mem_map_reserve(virt_to_page(__va(page)));
+		adr += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return mem;
+}
+
+static void rvfree(void *mem, unsigned long size)
+{
+	unsigned long adr, page;
+
+	if (!mem)
+		return;
+
+	size += (PAGE_SIZE - 1);
+	size &= ~(PAGE_SIZE - 1);
+
+	adr = (unsigned long) mem;
+	while (size > 0) {
+		page = kvirt_to_pa(adr);
+		mem_map_unreserve(virt_to_page(__va(page)));
+		adr += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+	vfree(mem);
+}
+
+#if ENABLE_HEXDUMP
+static void usbvision_hexdump(const unsigned char *data, int len)
+{
+	char tmp[80];
+	int i, k;
+
+	for (i = k = 0; len > 0; i++, len--) {
+		if (i > 0 && (i % 16 == 0)) {
+			printk("%s\n", tmp);
+			k = 0;
+		}
+		k += sprintf(&tmp[k], "%02x ", data[i]);
+	}
+	if (k > 0)
+		printk("%s\n", tmp);
+}
+#endif
+
+
+/* These procedures handle the scratch ring buffer */
+int scratch_len(struct usb_usbvision *usbvision)				/*This returns the amount of data actually in the buffer */
+{
+	int len = usbvision->scratch_write_ptr - usbvision->scratch_read_ptr;
+	if (len < 0) {
+		len += scratch_buf_size;
+	}
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_len() = %d\n", len);
+	}
+	return len;
+}
+
+
+/* This returns the free space left in the buffer */
+int scratch_free(struct usb_usbvision *usbvision)
+{
+	int free = usbvision->scratch_read_ptr - usbvision->scratch_write_ptr;
+	if (free <= 0) {
+		free += scratch_buf_size;
+	}
+	if (free) {
+		free -= 1;							/* at least one byte in the buffer must */
+										/* left blank, otherwise there is no chance to differ between full and empty */
+	}
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_free() = %d\n", free);
+	}
+	return free;
+}
+
+
+void *debug_memcpy(void *dest, void *src, size_t len)
+{
+	printk(KERN_DEBUG "memcpy(%p, %p, %d);\n", dest, src, len);
+	return memcpy(dest, src, len);
+}
+
+
+/* This puts data into the buffer */
+int scratch_put(struct usb_usbvision *usbvision, unsigned char *data, int len)
+{
+	int len_part;
+
+	if (usbvision->scratch_write_ptr + len < scratch_buf_size) {
+		memcpy(usbvision->scratch + usbvision->scratch_write_ptr, data, len);
+		usbvision->scratch_write_ptr += len;
+	}
+	else {
+		len_part = scratch_buf_size - usbvision->scratch_write_ptr;
+		memcpy(usbvision->scratch + usbvision->scratch_write_ptr, data, len_part);
+		if (len == len_part) {
+			usbvision->scratch_write_ptr = 0;			/* just set write_ptr to zero */
+		}
+		else {
+			memcpy(usbvision->scratch, data + len_part, len - len_part);
+			usbvision->scratch_write_ptr = len - len_part;
+		}
+	}
+
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_put(), len=%d, new write_ptr=%d\n",
+				len, usbvision->scratch_write_ptr);
+	}
+
+	return len;
+}
+
+/* This marks the write_ptr as position of new frame header */
+void scratch_mark_header(struct usb_usbvision *usbvision)
+{
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_mark_header() at write_ptr=%d\n",
+				usbvision->scratch_headermarker_write_ptr);
+	}
+
+	usbvision->scratch_headermarker[usbvision->scratch_headermarker_write_ptr] =
+		usbvision->scratch_write_ptr;
+	usbvision->scratch_headermarker_write_ptr += 1;
+	usbvision->scratch_headermarker_write_ptr %= USBVISION_NUM_HEADERMARKER;
+}
+
+/* This gets data from the buffer at the given "ptr" position */
+int scratch_get_extra(struct usb_usbvision *usbvision, unsigned char *data, int *ptr, int len)
+{
+	int len_part;
+	if (*ptr + len < scratch_buf_size) {
+		memcpy(data, usbvision->scratch + *ptr, len);
+		*ptr += len;
+	}
+	else {
+		len_part = scratch_buf_size - *ptr;
+		memcpy(data, usbvision->scratch + *ptr, len_part);
+		if (len == len_part) {
+			*ptr = 0;							/* just set the y_ptr to zero */
+		}
+		else {
+			memcpy(data + len_part, usbvision->scratch, len - len_part);
+			*ptr = len - len_part;
+		}
+	}
+
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_get_extra(), len=%d, new ptr=%d\n",
+				len, *ptr);
+	}
+
+	return len;
+}
+
+
+/* This sets the scratch extra read pointer */
+void scratch_set_extra_ptr(struct usb_usbvision *usbvision, int *ptr, int len)
+{
+	*ptr = (usbvision->scratch_read_ptr + len)%scratch_buf_size;
+
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_get_extra_ptr(): ptr=%d\n",
+				*ptr);
+	}
+
+}
+
+
+/*This increments the scratch extra read pointer */
+void scratch_inc_extra_ptr(int *ptr, int len)
+{
+	*ptr = (*ptr + len) % scratch_buf_size;
+}
+
+
+/* This gets data from the buffer */
+int scratch_get(struct usb_usbvision *usbvision, unsigned char *data, int len)
+{
+	int len_part;
+	if (usbvision->scratch_read_ptr + len < scratch_buf_size) {
+		memcpy(data, usbvision->scratch + usbvision->scratch_read_ptr, len);
+		usbvision->scratch_read_ptr += len;
+	}
+	else {
+		len_part = scratch_buf_size - usbvision->scratch_read_ptr;
+		memcpy(data, usbvision->scratch + usbvision->scratch_read_ptr, len_part);
+		if (len == len_part) {
+			usbvision->scratch_read_ptr = 0;				/* just set the read_ptr to zero */
+		}
+		else {
+			memcpy(data + len_part, usbvision->scratch, len - len_part);
+			usbvision->scratch_read_ptr = len - len_part;
+		}
+	}
+
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_get(), len=%d, new read_ptr=%d\n",
+				len, usbvision->scratch_read_ptr);
+	}
+
+	return len;
+}
+
+
+/* This sets read pointer to next header and returns it */
+int scratch_get_header(struct usb_usbvision *usbvision,struct usbvision_frame_header *header)
+{
+	int rc=0;
+
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_get_header() from read_ptr=%d\n",
+				usbvision->scratch_headermarker_read_ptr);
+	}
+
+	while (usbvision->scratch_headermarker_write_ptr -
+		usbvision->scratch_headermarker_read_ptr != 0) {
+		usbvision->scratch_read_ptr =
+			usbvision->scratch_headermarker[usbvision->scratch_headermarker_read_ptr];
+		usbvision->scratch_headermarker_read_ptr += 1;
+		usbvision->scratch_headermarker_read_ptr %= USBVISION_NUM_HEADERMARKER;
+		scratch_get(usbvision, (unsigned char *)header, USBVISION_HEADER_LENGTH);
+		if ((header->vid_frm_patt == USBVISION_MAGIC)
+			 && (header->header_length == USBVISION_HEADER_LENGTH)) {
+			rc = USBVISION_HEADER_LENGTH;
+			break;
+		}
+	}
+
+	return rc;
+}
+
+
+/*This removes len bytes of old data from the buffer */
+void scratch_rm_old(struct usb_usbvision *usbvision, int len)
+{
+
+	usbvision->scratch_read_ptr += len;
+	usbvision->scratch_read_ptr %= scratch_buf_size;
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_rm_old(), read_ptr is now %d\n",
+				usbvision->scratch_read_ptr);
+	}
+}
+
+
+/*This resets the buffer - kills all data in it too */
+void scratch_reset(struct usb_usbvision *usbvision)
+{
+	if (debug >=3) {
+		printk(KERN_DEBUG "scratch_reset()\n");
+	}
+	usbvision->scratch_read_ptr = 0;
+	usbvision->scratch_write_ptr = 0;
+	usbvision->scratch_headermarker_read_ptr = 0;
+	usbvision->scratch_headermarker_write_ptr = 0;
+	usbvision->isocstate = ISOC_NOFRAME;
+}
+
+
+
+/* Here comes the OVERLAY stuff */
+
+/* Tell the interrupt handler what to to.  */
+static
+void usbvision_cap(struct usb_usbvision* usbvision, int on)
+{
+	DEBUG(printk(KERN_DEBUG "usbvision_cap: overlay was %d, set it to %d\n", usbvision->overlay, on);)
+
+	if (on) {
+		usbvision->overlay = 1;
+	}
+	else {
+		usbvision->overlay = 0;
+	}
+}
+
+
+
+
+/* append a new clipregion to the vector of video_clips */
+static
+void usbvision_new_clip(struct video_window* vw, struct video_clip* vcp, int x, int y, int w, int h)
+{
+	vcp[vw->clipcount].x = x;
+	vcp[vw->clipcount].y = y;
+	vcp[vw->clipcount].width = w;
+	vcp[vw->clipcount].height = h;
+	vw->clipcount++;
+}
+
+
+#define mark_pixel(x,y)  usbvision->clipmask[((x) + (y) * MAX_FRAME_WIDTH)/32] |= 0x00000001<<((x)%32)
+#define clipped_pixel(index) usbvision->clipmask[(index)/32] & (0x00000001<<((index)%32))
+
+static
+void usbvision_built_overlay(struct usb_usbvision* usbvision, int count, struct video_clip *vcp)
+{
+	usbvision->overlay_win = usbvision->overlay_base +
+		(signed int)usbvision->vid_win.x * usbvision->vid_buf.depth / 8 +
+		(signed int)usbvision->vid_win.y * usbvision->vid_buf.bytesperline;
+
+		IODEBUG(printk(KERN_DEBUG "built_overlay base=%p, win=%p, bpl=%d, clips=%d, size=%dx%d\n",
+					usbvision->overlay_base, usbvision->overlay_win,
+					usbvision->vid_buf.bytesperline, count,
+					usbvision->vid_win.width, usbvision->vid_win.height);)
+
+
+	/* Add here generation of clipping mask */
+{
+	int x_start, x_end, y_start, y_end;
+	int clip_index, x, y;
+
+	memset(usbvision->clipmask, 0, USBVISION_CLIPMASK_SIZE);
+
+	OVDEBUG(printk(KERN_DEBUG "clips = %d\n", count);)
+
+	for(clip_index = 0; clip_index < count; clip_index++) {
+		OVDEBUG(printk(KERN_DEBUG "clip: %d,%d,%d,%d\n", vcp[clip_index].x,
+				vcp[clip_index].y,
+				vcp[clip_index].width,
+				vcp[clip_index].height);)
+
+		x_start = vcp[clip_index].x;
+		if(x_start >= (int)usbvision->vid_win.width) {
+			OVDEBUG(printk(KERN_DEBUG "x_start=%d\n", x_start);)
+			continue; //clipping window is right of overlay window
+		}
+		x_end	= x_start + vcp[clip_index].width;
+		if(x_end <= 0) {
+			OVDEBUG(printk(KERN_DEBUG "x_end=%d\n", x_end);)
+			continue; //clipping window is left of overlay window
+		}
+		
+		y_start = vcp[clip_index].y;
+		if(y_start >= (int)usbvision->vid_win.height) {
+			OVDEBUG(printk(KERN_DEBUG "y_start=%d\n", y_start);)
+			continue; //clipping window is below overlay window
+		}
+		y_end   = y_start + vcp[clip_index].height;
+		if(y_end <= 0) {
+			OVDEBUG(printk(KERN_DEBUG "y_end=%d\n", y_end);)
+			continue; //clipping window is above overlay window
+		}
+
+		//clip the clipping window
+		if (x_start < 0) {
+			x_start = 0;
+		}
+		if (x_end > usbvision->vid_win.width) {
+			x_end = usbvision->vid_win.width;
+		}
+		if (y_start < 0) {
+			y_start = 0;
+		}
+		if (y_end > usbvision->vid_win.height) {
+			y_end = usbvision->vid_win.height;
+		}
+
+		OVDEBUG(printk(KERN_DEBUG "clip_o: %d,%d,%d,%d\n", x_start,	y_start, x_end, y_end);)
+
+
+
+		for(y = y_start; y < y_end; y++) {
+			for(x = x_start; x < x_end; x++) {
+				mark_pixel(x,y);
+			}
+		}
+	}
+}
+
+}
+
+
+
+void usbvision_osd_char(struct usb_usbvision *usbvision,
+			struct usbvision_frame *frame, int x, int y, int ch)
+{
+	static const unsigned short digits[16] = {
+		0xF6DE,		/* 0 */
+		0x2492,		/* 1 */
+		0xE7CE,		/* 2 */
+		0xE79E,		/* 3 */
+		0xB792,		/* 4 */
+		0xF39E,		/* 5 */
+		0xF3DE,		/* 6 */
+		0xF492,		/* 7 */
+		0xF7DE,		/* 8 */
+		0xF79E,		/* 9 */
+		0x77DA,		/* a */
+		0xD75C,		/* b */
+		0xF24E,		/* c */
+		0xD6DC,		/* d */
+		0xF34E,		/* e */
+		0xF348		/* f */
+	};
+	unsigned short digit;
+	int ix, iy;
+
+	if ((usbvision == NULL) || (frame == NULL))
+		return;
+
+	if (ch >= '0' && ch <= '9')
+		ch -= '0';
+	else if (ch >= 'A' && ch <= 'F')
+		ch = 10 + (ch - 'A');
+	else if (ch >= 'a' && ch <= 'f')
+		ch = 10 + (ch - 'a');
+	else
+		return;
+	digit = digits[ch];
+
+	for (iy = 0; iy < 5; iy++) {
+		for (ix = 0; ix < 3; ix++) {
+			if (digit & 0x8000) {
+			//	USBVISION_PUTPIXEL(frame, x + ix, y + iy,
+			//			0xFF, 0xFF, 0xFF);
+			}
+			digit = digit << 1;
+		}
+	}
+}
+
+
+void usbvision_osd_string(struct usb_usbvision *usbvision,
+			  struct usbvision_frame *frame,
+			  int x, int y, const char *str)
+{
+	while (*str) {
+		usbvision_osd_char(usbvision, frame, x, y, *str);
+		str++;
+		x += 4;		/* 3 pixels character + 1 space */
+	}
+}
+
+/*
+ * usb_usbvision_osd_stats()
+ *
+ * On screen display of important debugging information.
+ *
+ */
+void usbvision_osd_stats(struct usb_usbvision *usbvision,
+			 struct usbvision_frame *frame)
+{
+	const int y_diff = 8;
+	char tmp[16];
+	int x = 10;
+	int y = 10;
+
+	sprintf(tmp, "%8x", usbvision->frame_num);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->urb_count);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->urb_length);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->data_count);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->header_count);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->scratch_ovf_count);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->iso_skip_count);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->iso_err_count);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8x", usbvision->vpic.colour);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8x", usbvision->vpic.hue);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8x", usbvision->vpic.brightness >> 8);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8x", usbvision->vpic.contrast >> 12);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8d", usbvision->vpic.whiteness >> 8);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+}
+
+/*
+ * usbvision_testpattern()
+ *
+ * Procedure forms a test pattern (yellow grid on blue background).
+ *
+ * Parameters:
+ * fullframe:   if TRUE then entire frame is filled, otherwise the procedure
+ *	        continues from the current scanline.
+ * pmode	0: fill the frame with solid blue color (like on VCR or TV)
+ *	        1: Draw a colored grid
+ *
+ */
+void usbvision_testpattern(struct usb_usbvision *usbvision, int fullframe,
+			int pmode)
+{
+	static const char proc[] = "usbvision_testpattern";
+	struct usbvision_frame *frame;
+	unsigned char *f;
+	int num_cell = 0;
+	int scan_length = 0;
+	static int num_pass = 0;
+
+	if (usbvision == NULL) {
+		printk(KERN_ERR "%s: usbvision == NULL\n", proc);
+		return;
+	}
+	if ((usbvision->curframe < 0)
+	    || (usbvision->curframe >= USBVISION_NUMFRAMES)) {
+		printk(KERN_ERR "%s: usbvision->curframe=%d.\n", proc,
+		       usbvision->curframe);
+		return;
+	}
+
+	/* Grab the current frame */
+	frame = &usbvision->frame[usbvision->curframe];
+
+	/* Optionally start at the beginning */
+	if (fullframe) {
+		frame->curline = 0;
+		frame->scanlength = 0;
+	}
+
+	/* Form every scan line */
+	for (; frame->curline < frame->frmheight; frame->curline++) {
+		int i;
+
+		f = frame->data + (usbvision->curwidth * 3 * frame->curline);
+		for (i = 0; i < usbvision->curwidth; i++) {
+			unsigned char cb = 0x80;
+			unsigned char cg = 0;
+			unsigned char cr = 0;
+
+			if (pmode == 1) {
+				if (frame->curline % 32 == 0)
+					cb = 0, cg = cr = 0xFF;
+				else if (i % 32 == 0) {
+					if (frame->curline % 32 == 1)
+						num_cell++;
+					cb = 0, cg = cr = 0xFF;
+				} else {
+					cb =
+					    ((num_cell * 7) +
+					     num_pass) & 0xFF;
+					cg =
+					    ((num_cell * 5) +
+					     num_pass * 2) & 0xFF;
+					cr =
+					    ((num_cell * 3) +
+					     num_pass * 3) & 0xFF;
+				}
+			} else {
+				/* Just the blue screen */
+			}
+
+			*f++ = cb;
+			*f++ = cg;
+			*f++ = cr;
+			scan_length += 3;
+		}
+	}
+
+	frame->grabstate = FRAME_DONE;
+	frame->scanlength += scan_length;
+	++num_pass;
+
+	/* We do this unconditionally, regardless of FLAGS_OSD_STATS */
+	usbvision_osd_stats(usbvision, frame);
+}
+
+/*
+ * Here comes the data parsing stuff that is run as interrupt
+ */
+
+/*
+ * usbvision_find_header()
+ *
+ * Locate one of supported header markers in the scratch buffer.
+ */
+static scan_state_t usbvision_find_header(struct usb_usbvision *usbvision)
+{
+	struct usbvision_frame *frame;
+
+	if (usbvision->overlay) {
+		frame = &usbvision->overlay_frame;
+	}
+	else {
+		frame = &usbvision->frame[usbvision->curframe];
+	}
+	
+	if (scratch_get_header(usbvision, &frame->usb_header)==USBVISION_HEADER_LENGTH) {
+		// found header in scratch
+#undef DUMP_HEADER
+#ifdef DUMP_HEADER
+		printk
+		    ("Header: %04x %d %d %d %d %d %02x %u %u\n",
+		     frame->usb_header.vid_frm_patt,
+		     frame->usb_header.header_length,
+		     frame->usb_header.frame_numb,
+		     frame->usb_header.frame_phase,
+		     frame->usb_header.frame_latency,
+		     frame->usb_header.data_format,
+		     frame->usb_header.format_param,
+		     frame->usb_header.frame_width,
+		     frame->usb_header.frame_height);
+#endif
+
+		frame->frmwidth = frame->usb_header.frame_width * usbvision->stretch_width;
+		frame->frmheight = frame->usb_header.frame_height * usbvision->stretch_height;
+		frame->v4l_linesize = frame->frmwidth * usbvision_v4l_format[frame->v4l_format].bytes_per_pixel;
+
+		if (debug > 2) {
+			printk(KERN_DEBUG "Header found! w:%d h:%d\n",
+			       frame->frmwidth, frame->frmheight);
+		}
+	}
+	else { // no header found
+		if (debug > 2) {
+			printk(KERN_DEBUG "Skipping scratch data, no header\n");
+		}
+		scratch_reset(usbvision);
+		return scan_EndParse;
+	}
+
+	/* Header found */
+	usbvision->has_hdr = 1;
+	usbvision->header_count++;
+	frame->scanstate = STATE_LINES;
+	frame->curline = 0;
+
+	if (flags & FLAGS_FORCE_TESTPATTERN) {
+		usbvision_testpattern(usbvision, 1, 1);
+		return scan_NextFrame;
+	}
+	return scan_Continue;
+}
+
+static scan_state_t usbvision_parse_lines_422(struct usb_usbvision *usbvision,
+					   long *pcopylen)
+{
+	volatile struct usbvision_frame *frame;
+	unsigned char *f; 
+	int len;
+	int i;
+	unsigned char yuyv[4]={180, 128, 10, 128}; // YUV components
+	unsigned char rv, gv, bv;	// RGB components
+	int clipmask_index, bytes_per_pixel;
+	int overlay = usbvision->overlay;
+	int stretch_bytes, clipmask_add;
+	
+	if (overlay) {
+		frame  = &usbvision->overlay_frame;
+		if (usbvision->overlay_base == NULL) {
+			//video_buffer is not set yet
+			return scan_NextFrame;
+		}
+		f = usbvision->overlay_win + frame->curline *
+			usbvision->vid_buf.bytesperline;
+	}
+	else {
+		frame  = &usbvision->frame[usbvision->curframe];
+		f = frame->data + (frame->v4l_linesize * frame->curline);
+	}
+	
+	/* Make sure there's enough data for the entire line */
+	len = (frame->usb_header.frame_width * 2)+5;
+	if (scratch_len(usbvision) < len) {
+		if (debug >= 2) {
+			printk(KERN_DEBUG
+			       "out of data in line %d, need %u.\n",
+			       frame->curline, len);
+		}
+		return scan_Out;
+	}
+
+	if ((frame->curline + 1) >= frame->frmheight) {
+		return scan_NextFrame;
+	}
+
+	bytes_per_pixel = usbvision_v4l_format[frame->v4l_format].bytes_per_pixel;
+	stretch_bytes = (usbvision->stretch_width - 1) * bytes_per_pixel;
+	clipmask_index = frame->curline * MAX_FRAME_WIDTH;
+	clipmask_add = usbvision->stretch_width;
+	
+	for (i = 0; i < frame->frmwidth; i+=(2 * usbvision->stretch_width)) {
+
+		scratch_get(usbvision, &yuyv[0], 4);
+		
+		if((overlay) && (clipped_pixel(clipmask_index))) {
+			f += bytes_per_pixel;
+		}
+		else if (frame->v4l_format == VIDEO_PALETTE_YUV422) {
+			*f++ = yuyv[0]; // Y
+			*f++ = yuyv[3]; // U 
+		}		
+		else {
+
+			YUV_TO_RGB_BY_THE_BOOK(yuyv[0], yuyv[1], yuyv[3], rv, gv, bv);
+			switch (frame->v4l_format) {
+				case VIDEO_PALETTE_RGB565:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 3));
+					*f++ = (0x07 & (gv >> 5)) | (0xF8 &  rv);
+					break;
+				case VIDEO_PALETTE_RGB24:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					break;
+				case VIDEO_PALETTE_RGB32:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					f++;
+					break;
+				case VIDEO_PALETTE_RGB555:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 2));
+					*f++ = (0x03 & (gv >> 6)) | (0x7C & (rv >> 1));
+					break;				
+			}
+		}
+		clipmask_index += clipmask_add;
+		f += stretch_bytes;
+
+		if((overlay) && (clipped_pixel(clipmask_index))) {
+			f += bytes_per_pixel;
+		}
+		else if (frame->v4l_format == VIDEO_PALETTE_YUV422) {
+			*f++ = yuyv[2]; // Y
+			*f++ = yuyv[1]; // V	
+		}
+		else {
+
+			YUV_TO_RGB_BY_THE_BOOK(yuyv[2], yuyv[1], yuyv[3], rv, gv, bv);
+			switch (frame->v4l_format) {
+				case VIDEO_PALETTE_RGB565:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 3));
+					*f++ = (0x07 & (gv >> 5)) | (0xF8 &  rv);
+					break;
+				case VIDEO_PALETTE_RGB24:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					break;
+				case VIDEO_PALETTE_RGB32:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					f++;
+					break;
+				case VIDEO_PALETTE_RGB555:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 2));
+					*f++ = (0x03 & (gv >> 6)) | (0x7C & (rv >> 1));
+					break;			
+			}
+		}
+		clipmask_index += clipmask_add;
+		f += stretch_bytes;
+	}
+	
+	frame->curline += usbvision->stretch_height;
+	*pcopylen += frame->v4l_linesize * usbvision->stretch_height;
+
+	if (frame->curline >= frame->frmheight) {
+		return scan_NextFrame;
+	}
+	else {
+		return scan_Continue;
+	}
+}
+
+
+/*
+ * usbvision_parse_compress()
+ *
+ * Parse compressed frame from the scratch buffer, put 
+ * decoded RGB value into the current frame buffer and add the written
+ * number of bytes (RGB) to the *pcopylen.
+ * 
+ */
+static scan_state_t usbvision_parse_compress(struct usb_usbvision *usbvision,
+					   long *pcopylen)
+{
+#define USBVISION_STRIP_MAGIC		0x5A
+#define USBVISION_STRIP_LEN_MAX		400
+#define USBVISION_STRIP_HEADER_LEN	10
+	
+	struct usbvision_frame *frame;
+	unsigned char *f;
+	unsigned char strip_data[USBVISION_STRIP_LEN_MAX];
+	unsigned char strip_header[USBVISION_STRIP_HEADER_LEN];
+	int i, i_end, strip_len, strip_ptr;
+	int clipmask_index, bytes_per_pixel;
+	int overlay = usbvision->overlay;
+	
+	if (overlay) {
+		frame  = &usbvision->overlay_frame;
+		if (usbvision->overlay_base == NULL) {
+			//video_buffer is not set yet
+			return scan_NextFrame;
+		}
+		f = usbvision->overlay_win + frame->curline *
+			 usbvision->vid_buf.bytesperline;
+	}
+	else {
+		frame  = &usbvision->frame[usbvision->curframe];
+		f = frame->data + (frame->v4l_linesize * frame->curline);
+	}
+
+	if ((frame->curline + 1) >= frame->frmheight) {
+		return scan_NextFrame;
+	}
+
+	if (scratch_len(usbvision) < USBVISION_STRIP_HEADER_LEN) {
+		return scan_Out;
+	}
+	
+	if (frame->usb_header.format_param & USBVISION_FRAME_FORMAT_PARAM_INTRA) {
+
+		//get strip header without changing the scratch_read_ptr
+		scratch_set_extra_ptr(usbvision, &strip_ptr, 0);
+		scratch_get_extra(usbvision, &strip_header[0], &strip_ptr, 
+				USBVISION_STRIP_HEADER_LEN);
+			
+		if (strip_header[0] != USBVISION_STRIP_MAGIC) {
+			return scan_NextFrame;
+		}
+
+		if (strip_header[2] != frame->curline) {
+			printk(KERN_DEBUG "usbvision_parse_compress: line number error\n");
+		}
+			
+		strip_len = 2 * (unsigned int)strip_header[1];
+		if (scratch_len(usbvision) < strip_len) {
+			//there is not enough data for the strip
+			return scan_Out;
+		}
+		
+		bytes_per_pixel = usbvision_v4l_format[frame->v4l_format].bytes_per_pixel;
+		clipmask_index = frame->curline * MAX_FRAME_WIDTH;
+
+		memset(strip_data, 0, USBVISION_STRIP_LEN_MAX);
+		scratch_get(usbvision, strip_data, strip_len);
+			
+		i_end = frame->frmwidth;
+		if (frame->v4l_format == VIDEO_PALETTE_GREY) {
+			i_end = USBVISION_STRIP_LEN_MAX;
+		}
+		
+		for(i = 0; i < i_end; i++) { 
+			if((overlay) && (clipped_pixel(clipmask_index))) {
+				f += bytes_per_pixel;
+			}
+			else {
+				switch (frame->v4l_format) {
+					case VIDEO_PALETTE_GREY:
+						*f++ = strip_data[i];
+						break;
+					case VIDEO_PALETTE_RGB565:
+					case VIDEO_PALETTE_RGB555:
+						*f++ = strip_data[i];
+						*f++ = strip_data[i];
+						break;
+					case VIDEO_PALETTE_RGB24:
+						*f++ = strip_data[i];
+						*f++ = strip_data[i];
+						*f++ = strip_data[i];
+						break;
+					case VIDEO_PALETTE_RGB32:
+						*f++ = strip_data[i];
+						*f++ = strip_data[i];
+						*f++ = strip_data[i];
+						f++;
+						break;					
+				}
+			}
+			clipmask_index++;
+		}
+		*pcopylen += frame->v4l_linesize;
+
+		frame->curline += 1;
+
+	}
+	else {
+		//it wasn't an INTRA Frame
+		return scan_NextFrame;
+	}
+
+	if (frame->curline >= frame->frmheight) {
+		return scan_NextFrame;
+	}
+	else {
+		return scan_Continue;
+	}
+
+}
+
+/*
+ * usbvision_parse_lines_420()
+ *
+ * Parse two lines from the scratch buffer, put 
+ * decoded RGB value into the current frame buffer and add the written
+ * number of bytes (RGB) to the *pcopylen.
+ * 
+ */
+static scan_state_t usbvision_parse_lines_420(struct usb_usbvision *usbvision,
+					   long *pcopylen)
+{
+	struct usbvision_frame *frame;
+	unsigned char *f_even = NULL, *f_odd = NULL;
+	unsigned int pixel_per_line;
+	int block, pixel, block_split;
+	int y_ptr, u_ptr, v_ptr, y_odd_offset;
+	const int   y_block_size = 128;
+	const int  uv_block_size = 64;
+	const int sub_block_size = 32;
+	const int y_step[] = { 0, 0, 0, 2 },  y_step_size = 4;
+	const int uv_step[]= { 0, 0, 0, 4 }, uv_step_size = 4;
+	unsigned char y[2], u, v;	/* YUV components */
+	int y_, u_, v_, vb, uvg, ur;
+	int r_, g_, b_;			/* RGB components */
+	unsigned char g;
+	int clipmask_even_index, clipmask_odd_index, bytes_per_pixel;
+	int clipmask_add, stretch_bytes;
+	int overlay = usbvision->overlay;
+	
+	if (overlay) {
+		frame  = &usbvision->overlay_frame;
+		if (usbvision->overlay_base == NULL) {
+			//video_buffer is not set yet
+			return scan_NextFrame;
+		}
+		f_even = usbvision->overlay_win + frame->curline *
+			 usbvision->vid_buf.bytesperline;
+		f_odd  = f_even + usbvision->vid_buf.bytesperline * usbvision->stretch_height;
+	}
+	else {
+		frame  = &usbvision->frame[usbvision->curframe];
+		f_even = frame->data + (frame->v4l_linesize * frame->curline);
+		f_odd  = f_even + frame->v4l_linesize * usbvision->stretch_height;
+	}
+	
+	/* Make sure there's enough data for the entire line */
+	/* In this mode usbvision transfer 3 bytes for every 2 pixels */
+	/* I need two lines to decode the color */
+	bytes_per_pixel = usbvision_v4l_format[frame->v4l_format].bytes_per_pixel;
+	stretch_bytes = (usbvision->stretch_width - 1) * bytes_per_pixel;
+	clipmask_even_index = frame->curline * MAX_FRAME_WIDTH;
+	clipmask_odd_index  = clipmask_even_index + MAX_FRAME_WIDTH;
+	clipmask_add = usbvision->stretch_width;
+	pixel_per_line = frame->usb_header.frame_width;
+	
+	if (scratch_len(usbvision) < pixel_per_line * 3) {
+		//printk(KERN_DEBUG "out of data, need %d\n", len);
+		return scan_Out;
+	}
+
+	if ((frame->curline + 1) >= frame->frmheight) {
+		return scan_NextFrame;
+	}
+
+	block_split = (pixel_per_line%y_block_size) ? 1 : 0;	//are some blocks splitted 
+															//into different lines?
+	
+	y_odd_offset = (pixel_per_line / y_block_size) * (y_block_size + uv_block_size)
+			+ block_split * uv_block_size;
+	
+	scratch_set_extra_ptr(usbvision, &y_ptr, y_odd_offset);
+	scratch_set_extra_ptr(usbvision, &u_ptr, y_block_size);
+	scratch_set_extra_ptr(usbvision, &v_ptr, y_odd_offset 
+			+ (4 - block_split) * sub_block_size);
+	
+	for (block = 0; block < (pixel_per_line / sub_block_size);
+	     block++) {
+		
+	
+		for (pixel = 0; pixel < sub_block_size; pixel +=2) {
+			scratch_get(usbvision, &y[0], 2);
+			scratch_get_extra(usbvision, &u, &u_ptr, 1);
+			scratch_get_extra(usbvision, &v, &v_ptr, 1);
+
+			//I don't use the YUV_TO_RGB macro for better performance
+			v_ = v - 128;
+			u_ = u - 128;
+			vb =              132252 * v_;
+			uvg= -53281 * u_ - 25625 * v_;
+			ur = 104595 * u_;
+			
+			if((overlay) && (clipped_pixel(clipmask_even_index))) {
+				f_even += bytes_per_pixel;
+			}
+			else {
+				y_ = 76284 * (y[0] - 16);
+			
+				b_ = (y_ + vb) >> 16;
+				g_ = (y_ + uvg)>> 16;
+				r_ = (y_ + ur) >> 16;
+		
+				switch (frame->v4l_format) {
+					case VIDEO_PALETTE_RGB565:
+						g = LIMIT_RGB(g_);
+						*f_even++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 3));
+						*f_even++ = (0x07 & (          g   >> 5)) | (0xF8 & LIMIT_RGB(r_));
+						break;
+					case VIDEO_PALETTE_RGB24:
+						*f_even++ = LIMIT_RGB(b_);
+						*f_even++ = LIMIT_RGB(g_);
+						*f_even++ = LIMIT_RGB(r_);
+						break;
+					case VIDEO_PALETTE_RGB32:
+						*f_even++ = LIMIT_RGB(b_);
+						*f_even++ = LIMIT_RGB(g_);
+						*f_even++ = LIMIT_RGB(r_);
+						f_even++;
+						break;
+					case VIDEO_PALETTE_RGB555:
+						g = LIMIT_RGB(g_);
+						*f_even++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 2));
+						*f_even++ = (0x03 & (          g   >> 6)) | 
+							    (0x7C & (LIMIT_RGB(r_) >> 1));
+						break;				
+				}
+			}
+			clipmask_even_index += clipmask_add;
+			f_even += stretch_bytes;
+			
+			if((overlay) && (clipped_pixel(clipmask_even_index))) {
+				f_even += bytes_per_pixel;
+			}
+			else {
+				y_ = 76284 * (y[1] - 16);
+			
+				b_ = (y_ + vb) >> 16;
+				g_ = (y_ + uvg)>> 16;
+				r_ = (y_ + ur) >> 16;
+			
+				switch (frame->v4l_format) {
+					case VIDEO_PALETTE_RGB565:
+						g = LIMIT_RGB(g_);
+						*f_even++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 3));
+						*f_even++ = (0x07 & (          g   >> 5)) | (0xF8 & LIMIT_RGB(r_));
+						break;
+					case VIDEO_PALETTE_RGB24:
+						*f_even++ = LIMIT_RGB(b_);
+						*f_even++ = LIMIT_RGB(g_);
+						*f_even++ = LIMIT_RGB(r_);
+						break;
+					case VIDEO_PALETTE_RGB32:
+						*f_even++ = LIMIT_RGB(b_);
+						*f_even++ = LIMIT_RGB(g_);
+						*f_even++ = LIMIT_RGB(r_);
+						f_even++;
+						break;
+					case VIDEO_PALETTE_RGB555:
+						g = LIMIT_RGB(g_);
+						*f_even++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 2));
+						*f_even++ = (0x03 & (          g   >> 6)) | 
+							    (0x7C & (LIMIT_RGB(r_) >> 1));
+						break;					
+				}
+			}		
+			clipmask_even_index += clipmask_add;
+			f_even += stretch_bytes;
+			
+			scratch_get_extra(usbvision, &y[0], &y_ptr, 2);
+			
+			if ((overlay) && (clipped_pixel(clipmask_odd_index))) {
+				f_odd += bytes_per_pixel;
+			}
+			else {
+				y_ = 76284 * (y[0] - 16);
+			
+				b_ = (y_ + vb) >> 16;
+				g_ = (y_ + uvg)>> 16;
+				r_ = (y_ + ur) >> 16;
+			
+				switch (frame->v4l_format) {
+					case VIDEO_PALETTE_RGB565:
+						g = LIMIT_RGB(g_);
+						*f_odd++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 3));
+						*f_odd++ = (0x07 & (          g   >> 5)) | (0xF8 & LIMIT_RGB(r_));
+						break;
+					case VIDEO_PALETTE_RGB24:
+						*f_odd++ = LIMIT_RGB(b_);
+						*f_odd++ = LIMIT_RGB(g_);
+						*f_odd++ = LIMIT_RGB(r_);
+						break;
+					case VIDEO_PALETTE_RGB32:
+						*f_odd++ = LIMIT_RGB(b_);
+						*f_odd++ = LIMIT_RGB(g_);
+						*f_odd++ = LIMIT_RGB(r_);
+						f_odd++;
+						break;
+					case VIDEO_PALETTE_RGB555:
+						g = LIMIT_RGB(g_);
+						*f_odd++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 2));
+						*f_odd++ = (0x03 & (          g   >> 6)) | 
+							   (0x7C & (LIMIT_RGB(r_) >> 1));
+						break;					
+				}
+			}
+			clipmask_odd_index += clipmask_add;
+			f_odd += stretch_bytes;
+			
+			if((overlay) && (clipped_pixel(clipmask_odd_index))) {
+				f_odd += bytes_per_pixel;
+			}
+			else {
+				y_ = 76284 * (y[1] - 16);
+			
+				b_ = (y_ + vb) >> 16;
+				g_ = (y_ + uvg)>> 16;
+				r_ = (y_ + ur) >> 16;
+		
+				switch (frame->v4l_format) {
+					case VIDEO_PALETTE_RGB565:
+						g = LIMIT_RGB(g_);
+						*f_odd++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 3));
+						*f_odd++ = (0x07 & (          g   >> 5)) | (0xF8 & LIMIT_RGB(r_));
+						break;
+					case VIDEO_PALETTE_RGB24:
+						*f_odd++ = LIMIT_RGB(b_);
+						*f_odd++ = LIMIT_RGB(g_);
+						*f_odd++ = LIMIT_RGB(r_);
+						break;
+					case VIDEO_PALETTE_RGB32:
+						*f_odd++ = LIMIT_RGB(b_);
+						*f_odd++ = LIMIT_RGB(g_);
+						*f_odd++ = LIMIT_RGB(r_);
+						f_odd++;
+						break;
+					case VIDEO_PALETTE_RGB555:
+						g = LIMIT_RGB(g_);
+						*f_odd++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 2));
+						*f_odd++ = (0x03 & (          g   >> 6)) | 
+							   (0x7C & (LIMIT_RGB(r_) >> 1));
+						break;					
+				}
+			}
+			clipmask_odd_index += clipmask_add;
+			f_odd += stretch_bytes;
+		}
+		
+		scratch_rm_old(usbvision,y_step[block % y_step_size] * sub_block_size); 
+		scratch_inc_extra_ptr(&y_ptr, y_step[(block + 2 * block_split) % y_step_size]
+				* sub_block_size);
+		scratch_inc_extra_ptr(&u_ptr, uv_step[block % uv_step_size]
+				* sub_block_size);
+		scratch_inc_extra_ptr(&v_ptr, uv_step[(block + 2 * block_split) % uv_step_size]
+				* sub_block_size);
+	}
+
+	scratch_rm_old(usbvision, pixel_per_line * 3 / 2 
+			+ block_split * sub_block_size);
+	
+	frame->curline += 2 * usbvision->stretch_height;
+	*pcopylen += frame->v4l_linesize * 2 * usbvision->stretch_height;
+
+	if (frame->curline >= frame->frmheight)
+		return scan_NextFrame;
+	else
+		return scan_Continue;
+}
+
+/*
+ * usbvision_parse_data()
+ *
+ * Generic routine to parse the scratch buffer. It employs either
+ * usbvision_find_header() or usbvision_parse_lines() to do most
+ * of work.
+ *
+ */
+static void usbvision_parse_data(struct usb_usbvision *usbvision)
+{
+	struct usbvision_frame *frame;
+	scan_state_t newstate;
+	long copylen = 0;
+
+	/* Grab the current frame and the previous frame */
+	if (usbvision->overlay) {
+		frame = &usbvision->overlay_frame;
+	}
+	else {
+		frame = &usbvision->frame[usbvision->curframe];
+	}
+	
+//	printk(KERN_DEBUG "frame=%p\n", frame);
+	if (debug >=1) {
+		printk(KERN_DEBUG "parsing len=%d\n", scratch_len(usbvision));
+	}
+
+
+	
+	while (1) {
+
+		newstate = scan_Out;
+		if (scratch_len(usbvision)) {
+			if (frame->scanstate == STATE_SCANNING) {
+				newstate = usbvision_find_header(usbvision);
+			}
+			else if (frame->scanstate == STATE_LINES) {
+				if (usbvision->videoformat == VIDEOFORMAT_YUV420) {
+					newstate = usbvision_parse_lines_420(usbvision, &copylen);
+				}
+				else if (usbvision->videoformat == VIDEOFORMAT_YUV422) {
+					newstate = usbvision_parse_lines_422(usbvision, &copylen);
+				}
+				else if (usbvision->videoformat == VIDEOFORMAT_COMPRESS) {
+					newstate = usbvision_parse_compress(usbvision, &copylen);
+				}
+
+			}
+		}
+		if (newstate == scan_Continue) {
+			continue;
+		}
+		else if ((newstate == scan_NextFrame) || (newstate == scan_Out)) {
+			break;
+		}
+		else {
+			return;	/* scan_EndParse */
+		}
+	}
+
+	if (newstate == scan_NextFrame) {
+		frame->grabstate = FRAME_DONE;
+		if (usbvision->overlay) {
+			frame->grabstate = FRAME_GRABBING;
+			frame->scanstate = STATE_SCANNING;
+			frame->scanlength = 0;
+			copylen = 0;
+		}
+		else {
+			usbvision->curframe = -1;
+		}
+		usbvision->frame_num++;
+
+		/* Optionally display statistics on the screen */
+		if (flags & FLAGS_OSD_STATS)
+			usbvision_osd_stats(usbvision, frame);
+
+		/* This will cause the process to request another frame. */
+//	if (usbvision->overlay == 0) {
+			if (waitqueue_active(&frame->wq)) {
+				wake_up_interruptible(&frame->wq);
+			}
+//		}
+	}
+
+	/* Update the frame's uncompressed length. */
+	frame->scanlength += copylen;
+}
+
+
+/*
+ * Make all of the blocks of data contiguous
+ */
+static int usbvision_compress_isochronous(struct usb_usbvision *usbvision,
+				       struct urb *urb)
+{
+	unsigned char *packet_data;
+	int i, totlen = 0;
+
+	for (i = 0; i < urb->number_of_packets; i++) {
+		int packet_len = urb->iso_frame_desc[i].actual_length;
+		int packet_stat = urb->iso_frame_desc[i].status;
+
+		packet_data =
+		    urb->transfer_buffer + urb->iso_frame_desc[i].offset;
+
+		/* Detect and ignore errored packets */
+		if (packet_stat) {	// packet_stat != 0 ?????????????
+			if (debug >= 1) {
+				printk(KERN_ERR
+				       "usbvision data error: [%d] len=%d, status=%X\n",
+				       i, packet_len, packet_stat);
+			}
+			usbvision->iso_err_count++;
+			continue;
+		}
+
+		/* Detect and ignore empty packets */
+		if (packet_len < 0) {
+			if (debug >= 2) {
+				printk(KERN_DEBUG
+				       "usbvision error packet [%d]\n", i);
+			}
+			usbvision->iso_skip_count++;
+			continue;
+		} 
+		else if (packet_len == 0) {	/* Frame end ????? */
+			if (debug >= 2) {
+				printk(KERN_DEBUG
+				       "usbvision null packet [%d]\n", i);
+			}
+			usbvision->isocstate=ISOC_NOFRAME;
+			usbvision->iso_skip_count++;
+			continue;
+		}
+		else if (packet_len > usbvision->iso_packet_len) {
+			printk(KERN_DEBUG "usbvision packet[%d] > iso_packet_len\n", i);
+			usbvision->iso_skip_count++;
+			continue;
+		}
+		
+		if (debug >= 2) {
+			printk(KERN_DEBUG "usbvision packet ok [%d] len=%d\n", i, packet_len);
+		}
+		
+		if (usbvision->isocstate==ISOC_NOFRAME) { //new frame begins
+			usbvision->isocstate=ISOC_INFRAME;
+			scratch_mark_header(usbvision);
+			if (debug >= 2) {
+				printk(KERN_DEBUG "usbvision packet with header\n");
+			}
+		}
+			
+		/*
+		 * If usbvision continues to feed us with data but there is no
+		 * consumption (if, for example, V4L client fell asleep) we
+		 * may overflow the buffer. We have to move old data over to
+		 * free room for new data. This is bad for old data. If we
+		 * just drop new data then it's bad for new data... choose
+		 * your favorite evil here.
+		 */
+		if (scratch_free(usbvision) < packet_len) {
+
+			usbvision->scratch_ovf_count++;
+			if (debug >= 2) {
+				printk(KERN_ERR
+				       "usbvision: scratch buf overflow! "
+				       "scr_len: %d, n: %d\n",
+				       scratch_len(usbvision), packet_len);
+			}
+			scratch_rm_old(usbvision, packet_len - scratch_free(usbvision));
+		}
+
+		/* Now we know that there is enough room in scratch buffer */
+		scratch_put(usbvision, packet_data, packet_len);
+		totlen += packet_len;
+
+	}
+#if ENABLE_HEXDUMP
+	if (totlen > 0) {
+		static int foo = 0;
+		if (foo < 1) {
+			printk(KERN_DEBUG "+%d.\n", usbvision->scratchlen);
+			usbvision_hexdump(data0, (totlen > 64) ? 64 : totlen);
+			++foo;
+		}
+	}
+#endif
+	return totlen;
+}
+
+static void usbvision_isoc_irq(struct urb *urb)
+{
+	IRQDEBUG(static const char proc[]="usbvision_isoc_irq: ";)
+	int len;
+	struct usb_usbvision *usbvision = urb->context;
+	struct usbvision_sbuf *sbuf;
+	int i;
+
+	/* We don't want to do anything if we are about to be removed! */
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return;
+
+	if (!usbvision->streaming) {
+		IRQDEBUG(printk(KERN_DEBUG "%soops, not streaming, but interrupt\n", proc);)
+		return;
+	}
+
+	sbuf = &usbvision->sbuf[usbvision->cursbuf];
+
+	/* Copy the data received into our scratch buffer */
+	len = usbvision_compress_isochronous(usbvision, urb);
+
+	usbvision->urb_count++;
+	usbvision->urb_length = len;
+	usbvision->data_count += len;
+
+	/* If we collected enough data let's parse! */
+	if (scratch_len(usbvision) > USBVISION_HEADER_LENGTH) {	/* 12 == header_length */
+		/*If we don't have a frame we're current working on, complain */
+		if ((usbvision->curframe >= 0) || (usbvision->overlay))
+			usbvision_parse_data(usbvision);
+		else {
+			IRQDEBUG(printk(KERN_DEBUG "%sreceived data, but no frame\n", proc);)
+			scratch_reset(usbvision);
+		}
+	}
+
+	for (i = 0; i < FRAMES_PER_DESC; i++) {
+		sbuf->urb->iso_frame_desc[i].status = 0;
+		sbuf->urb->iso_frame_desc[i].actual_length = 0;
+	}
+
+	/* Move to the next sbuf */
+	usbvision->cursbuf = (usbvision->cursbuf + 1) % USBVISION_NUMSBUF;
+
+	return;
+}
+
+/*************************************/
+/* Low level usbvision access functions */
+/*************************************/
+
+/*
+ * usbvision_read_reg()
+ *
+ * return  < 0 -> Error
+ *        >= 0 -> Data
+ */
+
+static int usbvision_read_reg(struct usb_usbvision *usbvision, unsigned char reg)
+{
+	static const char proc[] = "usbvision_read_reg";
+	int rc;
+	unsigned char buffer[1];
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -1;
+
+	rc = usb_control_msg(usbvision->dev, usb_rcvctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_IN | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0, (__u16) reg, buffer, 1,
+			     HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%s: ERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+		return rc;
+	}
+	return buffer[0];
+}
+
+/*
+ * usbvision_write_reg()
+ *
+ * return 1 -> Reg written
+ *        0 -> usbvision is not yet ready
+ *       -1 -> Something went wrong
+ */
+
+static int usbvision_write_reg(struct usb_usbvision *usbvision, unsigned char reg,
+			    unsigned char value)
+{
+	static const char proc[] = "usbvision_write_reg";
+	int rc;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0, (__u16) reg, &value, 1,
+			     HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%s: ERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+	}
+	return rc;
+}
+
+/* ----------------------------------------------------------------------- */
+/* I2C functions                                                           */
+/* ----------------------------------------------------------------------- */
+
+static void usbvision_inc_use(struct i2c_adapter *adap)
+{
+	MOD_INC_USE_COUNT;
+}
+
+static void usbvision_dec_use(struct i2c_adapter *adap)
+{
+	MOD_DEC_USE_COUNT;
+}
+
+static void call_i2c_clients(struct usb_usbvision *usbvision, unsigned int cmd,
+			     void *arg)
+{
+	int i;
+
+	for (i = 0; i < I2C_CLIENTS_MAX; i++) {
+		if (NULL == usbvision->i2c_clients[i])
+			continue;
+		if (NULL == usbvision->i2c_clients[i]->driver->command)
+			continue;
+		usbvision->i2c_clients[i]->driver->command(usbvision->
+							i2c_clients[i],
+							cmd, arg);
+	}
+}
+
+static int attach_inform(struct i2c_client *client)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) client->adapter->data;
+	int i;
+
+	for (i = 0; i < I2C_CLIENTS_MAX; i++) {
+		if (usbvision->i2c_clients[i] == NULL ||
+		    usbvision->i2c_clients[i]->driver->id ==
+		    client->driver->id) {
+			usbvision->i2c_clients[i] = client;
+			break;
+		}
+	}
+
+	if ((usbvision->have_tuner) && (usbvision->tuner_type != -1)) {
+			
+		call_i2c_clients(usbvision, TUNER_SET_TYPE, &usbvision->tuner_type);
+		call_i2c_clients(usbvision, VIDIOCSCHAN, &usbvision->vchan);
+	}
+	call_i2c_clients(usbvision, DECODER_SET_PICTURE, &usbvision->vpic);
+/*	usbvision_muxsel(usbvision, usbvision->channel, usbvision->vchan.norm);
+*/
+	if (verbose)
+		printk("usbvision: device %d: i2c attach [%s]\n", usbvision->nr,
+		       client->name);
+
+	return 0;
+}
+
+static int detach_inform(struct i2c_client *client)
+{
+	struct usb_usbvision *usbvision =
+	    (struct usb_usbvision *) client->adapter->data;
+	int i;
+
+	if (verbose)
+		printk("usbvision: device %d: i2c detach [%s]\n", usbvision->nr,
+		       client->name);
+	for (i = 0; i < I2C_CLIENTS_MAX; i++) {
+		if (NULL != usbvision->i2c_clients[i] &&
+		    usbvision->i2c_clients[i]->driver->id ==
+		    client->driver->id) {
+			usbvision->i2c_clients[i] = NULL;
+			break;
+		}
+	}
+	return 0;
+}
+
+static int
+usbvision_i2c_read_max4(struct usb_usbvision *usbvision, unsigned char addr,
+		     char *buf, short len)
+{
+	int rc, retries;
+
+	for (retries = 5;;) {
+		rc = usbvision_write_reg(usbvision, USBVISION_SER_ADRS, addr);
+		if (rc < 0)
+			return rc;
+
+		/* Initiate byte read cycle                    */
+		/* USBVISION_SER_CONT <- d0-d2 n. of bytes to r/w */
+		/*                    d3 0=Wr 1=Rd             */
+		rc = usbvision_write_reg(usbvision, USBVISION_SER_CONT,
+				      (len & 0x07) | 0x18);
+		if (rc < 0)
+			return rc;
+
+		/* Test for Busy and ACK */
+		do {
+			/* USBVISION_SER_CONT -> d4 == 0 busy */
+			rc = usbvision_read_reg(usbvision, USBVISION_SER_CONT);
+		} while (rc > 0 && ((rc & 0x10) != 0));	/* Retry while busy */
+		if (rc < 0)
+			return rc;
+
+		/* USBVISION_SER_CONT -> d5 == 1 Not ack */
+		if ((rc & 0x20) == 0)	/* Ack? */
+			break;
+
+		/* I2C abort */
+		rc = usbvision_write_reg(usbvision, USBVISION_SER_CONT, 0x00);
+		if (rc < 0)
+			return rc;
+
+		if (--retries < 0)
+			return -1;
+	}
+
+	switch (len) {
+	case 4:
+		buf[3] = usbvision_read_reg(usbvision, USBVISION_SER_DAT4);
+	case 3:
+		buf[2] = usbvision_read_reg(usbvision, USBVISION_SER_DAT3);
+	case 2:
+		buf[1] = usbvision_read_reg(usbvision, USBVISION_SER_DAT2);
+	case 1:
+		buf[0] = usbvision_read_reg(usbvision, USBVISION_SER_DAT1);
+		break;
+	default:
+		printk(KERN_ERR
+		       "usbvision_i2c_read_max4: buffer length > 4\n");
+	}
+
+	return len;
+}
+
+
+static int usbvision_i2c_write_max4(struct usb_usbvision *usbvision,
+				 unsigned char addr, const char *buf,
+				 short len)
+{
+	int rc, retries;
+	int i;
+	unsigned char value[6];
+	unsigned char ser_cont;
+
+	ser_cont = (len & 0x07) | 0x10;
+
+	value[0] = addr;
+	value[1] = ser_cont;
+	for (i = 0; i < len; i++)
+		value[i + 2] = buf[i];
+
+	for (retries = 5;;) {
+		rc = usb_control_msg(usbvision->dev,
+				     usb_sndctrlpipe(usbvision->dev, 1),
+				     USBVISION_OP_CODE,
+				     USB_DIR_OUT | USB_TYPE_VENDOR |
+				     USB_RECIP_ENDPOINT, 0,
+				     (__u16) USBVISION_SER_ADRS, value,
+				     len + 2, HZ);
+
+		if (rc < 0)
+			return rc;
+
+		rc = usbvision_write_reg(usbvision, USBVISION_SER_CONT,
+				      (len & 0x07) | 0x10);
+		if (rc < 0)
+			return rc;
+
+		/* Test for Busy and ACK */
+		do {
+			rc = usbvision_read_reg(usbvision, USBVISION_SER_CONT);
+		} while (rc > 0 && ((rc & 0x10) != 0));	/* Retry while busy */
+		if (rc < 0)
+			return rc;
+
+		if ((rc & 0x20) == 0)	/* Ack? */
+			break;
+
+		/* I2C abort */
+		usbvision_write_reg(usbvision, USBVISION_SER_CONT, 0x00);
+
+		if (--retries < 0)
+			return -1;
+
+	}
+
+	return len;
+}
+
+static int usbvision_i2c_write(void *data, unsigned char addr, char *buf,
+			    short len)
+{
+	char *bufPtr = buf;
+	int retval;
+	int wrcount = 0;
+	int count;
+	int maxLen = 2;
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) data;
+
+	/* When writing in the SAA7111 have to write pairs
+	 * sub-addr, value. If not the usbvision does not write
+	 * in the right address */
+	/*if ((addr == USBVISION_SAA7111_ADDR)||(addr == USBVISION_BT819_ADDR))
+		maxLen = 2;
+	else
+		maxLen = 4;*/	/* 4 is the max USBVISION is able to write */
+
+	while (len > 0) {
+		count = (len > maxLen) ? maxLen : len;
+		retval = usbvision_i2c_write_max4(usbvision, addr, bufPtr, count);
+		if (retval > 0) {
+			len -= count;
+			bufPtr += count;
+			wrcount += count;
+		} else
+			return (retval < 0) ? retval : -EFAULT;
+	}
+	return wrcount;
+}
+
+static int usbvision_i2c_read(void *data, unsigned char addr, char *buf,
+			   short len)
+{
+	char temp[4];
+	int retval, i;
+	int rdcount = 0;
+	int count;
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) data;
+
+	while (len > 0) {
+		count = (len > 3) ? 4 : len;
+		retval = usbvision_i2c_read_max4(usbvision, addr, temp, count);
+		if (retval > 0) {
+			for (i = 0; i < len; i++)
+				buf[rdcount + i] = temp[i];
+			len -= count;
+			rdcount += count;
+		} else
+			return (retval < 0) ? retval : -EFAULT;
+	}
+	return rdcount;
+}
+
+static struct i2c_algo_usb_data i2c_algo_template = {
+	NULL,
+	usbvision_i2c_read,
+	usbvision_i2c_write,
+	10, 10, 100,
+};
+
+static struct i2c_adapter i2c_adap_template = {
+	"usbvision",
+	I2C_HW_B_BT848,		/* FIXME */
+	NULL,
+	NULL,
+	usbvision_inc_use,
+	usbvision_dec_use,
+	attach_inform,
+	detach_inform,
+	NULL,
+};
+
+static struct i2c_client i2c_client_template = {
+	"usbvision internal",
+	-1,
+	0,
+	0,
+	NULL,
+	NULL
+};
+
+static int usbvision_init_i2c(struct usb_usbvision *usbvision)
+{
+	memcpy(&usbvision->i2c_adap, &i2c_adap_template,
+	       sizeof(struct i2c_adapter));
+	memcpy(&usbvision->i2c_algo, &i2c_algo_template,
+	       sizeof(struct i2c_algo_usb_data));
+	memcpy(&usbvision->i2c_client, &i2c_client_template,
+	       sizeof(struct i2c_client));
+
+	sprintf(usbvision->i2c_adap.name + strlen(usbvision->i2c_adap.name),
+		" #%d", usbvision->nr);
+	usbvision->i2c_algo.data = usbvision;
+	usbvision->i2c_adap.data = usbvision;
+	usbvision->i2c_adap.algo_data = &usbvision->i2c_algo;
+	usbvision->i2c_client.adapter = &usbvision->i2c_adap;
+
+	if (usbvision_write_reg(usbvision, USBVISION_SER_MODE, USBVISION_IIC_LRNACK) < 0) {
+		printk(KERN_ERR "usbvision_init_i2c: can't wirte reg\n");
+		return -EBUSY;
+	}
+
+	/* Request the load of the i2c modules we need */
+	if (autoload) {
+		switch (usbvision_device_data[usbvision->DevModel].Codec) {
+			case CODEC_SAA7113:
+				request_module("saa7113-new");
+				break;
+			case CODEC_SAA7111:
+				request_module("saa7111-new");
+				break;
+			case CODEC_BT819:
+				request_module("bt819-new");
+				break;
+		}
+		if (usbvision_device_data[usbvision->DevModel].Tuner == 1) {
+	    	request_module("tuner");
+		}
+	}
+	
+	usbvision->i2c_ok = i2c_usb_add_bus(&usbvision->i2c_adap);
+
+	return usbvision->i2c_ok;
+
+}
+
+
+/****************************/
+/* usbvision utility functions */
+/****************************/
+
+static int usbvision_power_off(struct usb_usbvision *usbvision)
+{
+	printk(KERN_DEBUG "usbvision_power_off\n");
+	return (usbvision_write_reg(usbvision, USBVISION_PWR_REG, USBVISION_SSPND_EN));
+}
+
+/*
+ * usbvision_set_video_format()
+ *
+ */
+
+static int usbvision_set_video_format(struct usb_usbvision *usbvision, int format)
+{
+	static const char proc[] = "usbvision_set_video_format";
+	int rc;
+	unsigned char value[2];
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	if ((format != VIDEOFORMAT_YUV422)
+	    && (format != VIDEOFORMAT_YUV420)
+	    && (format != VIDEOFORMAT_COMPRESS)) {
+		printk(KERN_ERR "usbvision: unknown video format %02x, using default YUV420",
+		       format);
+		format = VIDEOFORMAT_YUV420;
+	}
+	value[0] = 0x0A;  //TODO: See the effect of the filter
+	value[1] = format;
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_FILT_CONT, value, 2, HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%s: ERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+	}
+	usbvision->videoformat = format;
+	return rc;
+}
+
+/*
+ * usbvision_set_output()
+ *
+ */
+
+static int usbvision_set_output(struct usb_usbvision *usbvision, int width,
+				  int height)
+{
+	static const char proc[] = "usbvision_set_output: ";
+	int rc;
+	int UsbWidth, UsbHeight;
+	unsigned int framerate=0, frame_drop_factor=0;
+	unsigned char value[4];
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+	
+	if (width > MAX_USB_WIDTH) {
+		UsbWidth = width / 2;
+		usbvision->stretch_width = 2;
+	}
+	else {
+		UsbWidth = width;
+		usbvision->stretch_width = 1;
+	}
+	
+	if (height > MAX_USB_HEIGHT) {
+		UsbHeight = height / 2;
+		usbvision->stretch_height = 2;
+	}
+	else {
+		UsbHeight = height;
+		usbvision->stretch_height = 1;
+	}
+
+	RESTRICT_TO_RANGE(UsbWidth, MIN_FRAME_WIDTH, MAX_USB_WIDTH);
+	UsbWidth &= ~(MIN_FRAME_WIDTH-1);
+	RESTRICT_TO_RANGE(UsbHeight, MIN_FRAME_HEIGHT, MAX_USB_HEIGHT);
+	UsbHeight &= ~(1);
+	
+	DEBUG(printk(KERN_DEBUG "%susb %dx%d; screen %dx%d; stretch %dx%d\n", 
+							proc, UsbWidth, UsbHeight, width, height,
+							usbvision->stretch_width, usbvision->stretch_height);)
+		
+	/* I'll not rewrite the same values */
+	if ((UsbWidth != usbvision->curwidth) || (UsbHeight != usbvision->curheight)) {
+		value[0] = UsbWidth & 0xff;		//LSB
+		value[1] = (UsbWidth >> 8) & 0xff;		//MSB
+		value[2] = UsbHeight & 0xff;		//LSB
+		value[3] = (UsbHeight >> 8) & 0xff;	//MSB
+
+		rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_LXSIZE_O, value, 4, HZ);
+
+		if (rc < 0) {
+			printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+		    		   "reconnect or reload driver.\n", proc, rc);
+			return rc;
+		}
+		usbvision->curwidth = usbvision->stretch_width * UsbWidth;
+		usbvision->curheight = usbvision->stretch_height * UsbHeight;
+	}
+	
+	if (usbvision->videoformat == VIDEOFORMAT_YUV422) {
+		framerate = (usbvision->iso_packet_len * 1000) / (UsbWidth * UsbHeight * 2);
+	}
+	else if (usbvision->videoformat == VIDEOFORMAT_YUV420) {
+		framerate = (usbvision->iso_packet_len * 1000) / ((UsbWidth * UsbHeight * 12) / 8);
+	}
+	else {
+		framerate = 31;
+	}
+
+	if ((usbvision->vchan.norm == VIDEO_MODE_PAL) ||
+	    (usbvision->vchan.norm == VIDEO_MODE_SECAM)) {
+ 		frame_drop_factor = framerate * 32 / 25 - 1;
+	}
+	else if (usbvision->vchan.norm == VIDEO_MODE_NTSC) {
+		frame_drop_factor = framerate * 32 / 30 - 1;
+	}
+
+	RESTRICT_TO_RANGE(frame_drop_factor, FRAMERATE_MIN, FRAMERATE_MAX);
+	
+	DEBUG(printk(KERN_DEBUG "%sframe rate %d fps\n", proc, framerate);) 
+			
+	frame_drop_factor = FRAMERATE_MAX; 	// We can allow the maximum here, because dropping is controlled 
+										// by BUF_THR automatically
+	
+	return usbvision_write_reg(usbvision, USBVISION_FRM_RATE, frame_drop_factor);
+}
+
+
+/*
+ * usbvision_set_compress_params()
+ *
+ */
+
+static int usbvision_set_compress_params(struct usb_usbvision *usbvision)
+{
+	static const char proc[] = "usbvision_set_compresion_params: ";
+	int rc;
+	unsigned char value[6];
+
+	value[0] = 0x02; //by hec 0x0F;	// Intra-Compression cycle
+	value[1] = 0x01;    // Reg.45 Strip-Size
+	value[2] = 0x01;    // Reg.46 Force intra mode on all new frames
+	value[3] = 0x00;    // Reg.47 FORCE_UP <- 0 normal operation (not force)
+	value[4] = 0xA2;    // Reg.48 BUF_THR I'm not sure if this does something in not compressed mode.
+//      value[5] = 0x00;    // Reg.49 DVI_YUV This has nothing to do with compression
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_INTRA_CYC, value, 5, HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+		return rc;
+	}
+	
+	
+	value[0] = 0x04;	// PCM Threshold 1
+	value[1] = 0x04;	// PCM Threshold 2
+	value[2] = 0x02;	// Distorsion Threshold d7-d0
+	value[3] = 0x00;	// Distorsion Threshold d11-d8
+	value[4] = 0x00;	// Max Distorsion d7-d0
+	value[5] = 0x00;	// Max Distorsion d8
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_PCM_THR1, value, 6, HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+		return rc;
+	}
+
+
+	return rc;
+
+}
+
+/*
+ * usbvision_set_input()
+ *
+ * Set the input (saa7111) size x y and other misc input params
+ * I've no idea if this parameters are right
+ *
+ */
+
+static int usbvision_set_input(struct usb_usbvision *usbvision)
+{
+	static const char proc[] = "usbvision_set_input: ";
+	int rc;
+	unsigned char value[8];
+
+        if (usbvision_device_data[usbvision->DevModel].Vin_Reg1 >= 0) {
+                value[0]=usbvision_device_data[usbvision->DevModel].Vin_Reg1 & 0xff;
+		rc = usbvision_write_reg(usbvision,USBVISION_VIN_REG1,value[0]);
+		if (rc < 0) {
+		        printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+			       "reconnect or reload driver.\n", proc, rc);
+			return rc;
+		}
+	}
+
+	if (usbvision_device_data[usbvision->DevModel].Vin_Reg2 >= 0) {
+	        value[0]=usbvision_device_data[usbvision->DevModel].Vin_Reg2 & 0xff;
+		rc = usbvision_write_reg(usbvision,USBVISION_VIN_REG2,value[0]);
+		if (rc < 0) {
+		        printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+			       "reconnect or reload driver.\n", proc, rc);
+			return rc;
+		}
+	}
+
+	if (usbvision->vchan.norm == VIDEO_MODE_PAL) {
+		value[0] = 0xC0;
+		value[1] = 0x02;	//0x02C0 -> 704 Input video line length
+		value[2] = 0x20;
+		value[3] = 0x01;	//0x0120 -> 288 Input video n. of lines
+		value[4] = 0x60;
+		value[5] = 0x00;	//0x0060 -> 96 Input video h offset
+		value[6] = 0x16;
+		value[7] = 0x00;	//0x0016 -> 22 Input video v offset
+	} else if (usbvision->vchan.norm == VIDEO_MODE_SECAM) {
+		value[0] = 0xC0;
+		value[1] = 0x02;	//0x02C0 -> 704 Input video line length
+		value[2] = 0x20;
+		value[3] = 0x01;	//0x0120 -> 288 Input video n. of lines
+		value[4] = 0x01;
+		value[5] = 0x00;	//0x0001 -> 01 Input video h offset
+		value[6] = 0x01;
+		value[7] = 0x00;	//0x0001 -> 01 Input video v offset
+	} else {	/* VIDEO_MODE_NTSC */
+		value[0] = 0xD0;
+		value[1] = 0x02;	//0x02D0 -> 720 Input video line length
+		value[2] = 0xF0;
+		value[3] = 0x00;	//0x00F0 -> 240 Input video number of lines
+		value[4] = 0x50;
+		value[5] = 0x00;	//0x0050 -> 80 Input video h offset
+		value[6] = 0x10;
+		value[7] = 0x00;	//0x0010 -> 16 Input video v offset
+	}
+
+	if (usbvision_device_data[usbvision->DevModel].X_Offset >= 0) {
+	        value[4]=usbvision_device_data[usbvision->DevModel].X_Offset & 0xff;
+		value[5]=(usbvision_device_data[usbvision->DevModel].X_Offset & 0xff00) >> 8;
+	}
+
+	if (usbvision_device_data[usbvision->DevModel].Y_Offset >= 0) {
+	        value[6]=usbvision_device_data[usbvision->DevModel].Y_Offset & 0xff;
+		value[7]=(usbvision_device_data[usbvision->DevModel].Y_Offset & 0xff00) >> 8;
+	}
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,	/* USBVISION specific code */
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_LXSIZE_I, value, 8, HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+		return rc;
+	}
+
+	if(usbvision_device_data[usbvision->DevModel].Dvi_yuv >= 0){
+	        return (usbvision_write_reg(usbvision, USBVISION_DVI_YUV, usbvision_device_data[usbvision->DevModel].Dvi_yuv & 0xff));
+	}
+	else if(usbvision_device_data[usbvision->DevModel].Codec == CODEC_SAA7113)
+        {
+        	/* This changes as the fine sync control changes. Further investigation necessary */
+		return (usbvision_write_reg(usbvision, USBVISION_DVI_YUV, 0x06));
+        }
+        else
+        {
+		/* U comes after V, Ya comes after U/V, Yb comes after Yb */
+		return (usbvision_write_reg(usbvision, USBVISION_DVI_YUV, 0x00));
+        }
+
+}
+
+/*
+ * usbvision_set_dram_settings()
+ *
+ * Set the buffer address needed by the usbvision dram to operate
+ * This values has been taken with usbsnoop.
+ *
+ */
+
+static int usbvision_set_dram_settings(struct usb_usbvision *usbvision)
+{
+	static const char proc[] = "usbvision_set_dram_settings: ";
+	int rc;
+	unsigned char value[8];
+	
+	if (usbvision->videoformat == VIDEOFORMAT_COMPRESS) {
+		value[0] = 0x42;
+		value[1] = 0x71;
+		value[2] = 0xff;
+		value[3] = 0x00;
+		value[4] = 0x98;
+		value[5] = 0xe0;
+		value[6] = 0x71;
+		value[7] = 0xff;
+		// UR:  0x0E200-0x3FFFF = 204288 Byte
+		// FDL: 0x00000-0x0E099 =  57498 Byte
+		// VDW: 0x0E3FF-0x3FFFF
+		printk(KERN_DEBUG "%scompressed\n", proc);
+	}
+	else {
+		value[0] = 0x42;
+		value[1] = 0x00;
+		value[2] = 0xff;
+		value[3] = 0x00;
+		value[4] = 0x00;
+		value[5] = 0x00;
+		value[6] = 0x00;
+		value[7] = 0xff;
+	}
+	/* These are the values of the address of the video buffer,
+	 * they have to be loaded into the USBVISION_DRM_PRM1-8
+	 *
+	 * Start address of video output buffer for read: 	drm_prm1-2 -> 0x00000
+	 * End address of video output buffer for read: 	drm_prm1-3 -> 0x1ffff
+	 * Start address of video frame delay buffer: 		drm_prm1-4 -> 0x20000
+	 *    Only used in compressed mode
+	 * End address of video frame delay buffer: 		drm_prm1-5-6 -> 0x3ffff
+	 *    Only used in compressed mode
+	 * Start address of video output buffer for write: 	drm_prm1-7 -> 0x00000
+	 * End address of video output buffer for write: 	drm_prm1-8 -> 0x1ffff
+	 */
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,	/* USBVISION specific code */
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_DRM_PRM1, value, 8, HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+		return rc;
+	}
+
+	/* Restart the video buffer logic */
+	if ((rc = usbvision_write_reg(usbvision, USBVISION_DRM_CONT, USBVISION_RES_UR |
+				   USBVISION_RES_FDL | USBVISION_RES_VDW)) < 0)
+		return rc;
+	rc = usbvision_write_reg(usbvision, USBVISION_DRM_CONT, 0x00);
+
+	return rc;
+}
+
+/*
+ * usbvision_power_on()
+ *
+ * Power on the device, enables suspend-resume logic 
+ * &  reset the isoc End-Point
+ *
+ */
+
+static int usbvision_power_on(struct usb_usbvision *usbvision)
+{
+	usbvision_write_reg(usbvision, USBVISION_PWR_REG, USBVISION_SSPND_EN);
+	usbvision_write_reg(usbvision, USBVISION_PWR_REG,
+			 USBVISION_SSPND_EN | USBVISION_RES2);
+	/* Set input format expected from decoder, should this be moved to usbvision_set_input() ?? */
+        if(usbvision_device_data[usbvision->DevModel].Codec == CODEC_SAA7113)
+        {
+		/* SAA7113 uses 8 bit output */
+		usbvision_write_reg(usbvision, USBVISION_VIN_REG1, USBVISION_8_422_SYNC);
+        }
+        else
+        {
+		/* I'm sure only about d2-d0 [010] 16 bit 4:2:2 usin sync pulses
+		 * as that is how saa7111 is configured */
+		usbvision_write_reg(usbvision, USBVISION_VIN_REG1, USBVISION_16_422_SYNC);
+		/* | USBVISION_VSNC_POL | USBVISION_VCLK_POL);*/
+        }
+
+	usbvision_write_reg(usbvision, USBVISION_PWR_REG,
+			 USBVISION_SSPND_EN | USBVISION_PWR_VID);
+	printk(KERN_DEBUG "usbvision_power_on\n");
+	return (usbvision_write_reg
+		(usbvision, USBVISION_PWR_REG,
+		 USBVISION_SSPND_EN | USBVISION_PWR_VID | USBVISION_RES2));
+}
+
+/*
+ * usbvision_begin_streaming()
+ * Sure you have to put bit 7 to 0, if not incoming frames are droped, but no
+ * idea about the rest
+ */
+
+static int usbvision_begin_streaming(struct usb_usbvision *usbvision)
+{
+
+	return (usbvision_write_reg(usbvision, USBVISION_VIN_REG2, USBVISION_NOHVALID));
+
+	return 0;
+}
+
+/*
+ * usbvision_restart_isoc()
+ * Not sure yet if touching here PWR_REG make loose the config
+ */
+
+static int usbvision_restart_isoc(struct usb_usbvision *usbvision)
+{
+	int ret;
+
+	if (
+	    (ret =
+	     usbvision_write_reg(usbvision, USBVISION_PWR_REG,
+			      USBVISION_SSPND_EN | USBVISION_PWR_VID)) < 0)
+		return ret;
+	if (
+	    (ret =
+	     usbvision_write_reg(usbvision, USBVISION_PWR_REG,
+			      USBVISION_SSPND_EN | USBVISION_PWR_VID |
+			      USBVISION_RES2)) < 0)
+		return ret;
+	if (
+	    (ret =
+	     usbvision_write_reg(usbvision, USBVISION_VIN_REG2,
+			      USBVISION_KEEP_BLANK|USBVISION_NOHVALID)) < 0) return ret;
+
+	/* TODO: schedule timeout */
+	while ((usbvision_read_reg(usbvision, USBVISION_STATUS_REG) && 0x01) != 1);
+
+	return 0;
+}
+
+static int usbvision_audio_on(struct usb_usbvision *usbvision)
+{
+	if (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, usbvision->AudioChannel) < 0) {
+		printk(KERN_ERR "usbvision_audio_on: can't wirte reg\n");
+		return -1;
+	}
+	DEBUG(printk(KERN_DEBUG "usbvision_audio_on: channel %d\n", usbvision->AudioChannel));
+	usbvision->AudioMute = 0;
+	return 0;
+}
+
+static int usbvision_audio_mute(struct usb_usbvision *usbvision)
+{
+	if (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, 0x03) < 0) {
+		printk(KERN_ERR "usbvision_audio_mute: can't wirte reg\n");
+		return -1;
+	}
+	DEBUG(printk(KERN_DEBUG "usbvision_audio_mute: audio mute\n"));
+	usbvision->AudioMute = 1;
+	return 0;
+}
+
+static int usbvision_audio_off(struct usb_usbvision *usbvision)
+{
+	if (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, USBVISION_AUDIO_MUTE) < 0) {
+		printk(KERN_ERR "usbvision_audio_off: can't wirte reg\n");
+		return -1;
+	}
+	DEBUG(printk(KERN_DEBUG "usbvision_audio_off: audio off\n"));
+	usbvision->AudioMute = 0;
+	usbvision->AudioChannel = USBVISION_AUDIO_MUTE;
+	return 0;
+}
+
+static int usbvision_set_audio(struct usb_usbvision *usbvision, int AudioChannel)
+{
+	if (!usbvision->AudioMute) {
+		if (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, AudioChannel) < 0) {
+			printk(KERN_ERR "usbvision_set_audio: can't write iopin register for audio switching\n");
+			return -1;
+		}
+	}
+	DEBUG(printk(KERN_DEBUG "usbvision_set_audio: channel %d\n", AudioChannel));
+	usbvision->AudioChannel = AudioChannel;
+	return 0;
+}
+
+static int usbvision_setup(struct usb_usbvision *usbvision)
+{
+	usbvision_set_video_format(usbvision, videoformat);
+	usbvision_set_dram_settings(usbvision);
+	usbvision_set_compress_params(usbvision);
+	usbvision_set_input(usbvision);
+	usbvision_set_output(usbvision, MAX_USB_WIDTH, MAX_USB_HEIGHT);
+	usbvision_restart_isoc(usbvision);
+	usbvision_begin_streaming(usbvision);
+
+	/* cosas del PCM */
+
+	return USBVISION_IS_OPERATIONAL(usbvision);
+}
+
+
+/*
+ * usbvision_init_isoc()
+ *
+ */
+static int usbvision_init_isoc(struct usb_usbvision *usbvision)
+{
+	IRQDEBUG(static const char proc[]="usbvision_init_isoc: ";)
+	struct usb_device *dev = usbvision->dev;
+	int i, err;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -EFAULT;
+
+	usbvision->curframe = -1;
+	usbvision->cursbuf = 0;
+	scratch_reset(usbvision);
+
+	/* Alternate interface 1 is is the biggest frame size */
+	i = usb_set_interface(dev, usbvision->iface, usbvision->ifaceAltActive);
+	if (i < 0) {
+		printk(KERN_ERR "usb_set_interface error\n");
+		usbvision->last_error = i;
+		return -EBUSY;
+	}
+
+	/* We double buffer the Iso lists */
+
+	for (i = 0; i < USBVISION_NUMSBUF; i++) {
+		int j, k;
+		struct urb *urb;
+
+		urb = usb_alloc_urb(FRAMES_PER_DESC);
+		if (urb == NULL) {
+			printk(KERN_ERR
+			       "usbvision_init_isoc: usb_init_isoc() failed.\n");
+			return -ENOMEM;
+		}
+		usbvision->sbuf[i].urb = urb;
+		urb->dev = dev;
+		urb->context = usbvision;
+		urb->pipe = usb_rcvisocpipe(dev, usbvision->video_endp);
+		urb->transfer_flags = USB_ISO_ASAP;
+		urb->transfer_buffer = usbvision->sbuf[i].data;
+		urb->complete = usbvision_isoc_irq;
+		urb->number_of_packets = FRAMES_PER_DESC;
+		urb->transfer_buffer_length =
+		    usbvision->iso_packet_len * FRAMES_PER_DESC;
+		for (j = k = 0; j < FRAMES_PER_DESC; j++,
+		     k += usbvision->iso_packet_len) {
+			urb->iso_frame_desc[j].offset = k;
+			urb->iso_frame_desc[j].length =
+			    usbvision->iso_packet_len;
+		}
+	}
+
+	/* Link URBs into a ring so that they invoke each other infinitely */
+	for (i = 0; i < USBVISION_NUMSBUF; i++) {
+		if ((i + 1) < USBVISION_NUMSBUF)
+			usbvision->sbuf[i].urb->next =
+			    usbvision->sbuf[i + 1].urb;
+		else
+			usbvision->sbuf[i].urb->next = usbvision->sbuf[0].urb;
+	}
+
+	/* Submit all URBs */
+	for (i = 0; i < USBVISION_NUMSBUF; i++) {
+		err = usb_submit_urb(usbvision->sbuf[i].urb);
+		if (err)
+			printk(KERN_ERR
+			       "usbvision_init_isoc: usb_run_isoc(%d) ret %d\n",
+			       i, err);
+	}
+
+
+	usbvision->streaming = 1;
+	IRQDEBUG(printk(KERN_DEBUG "%sstreaming=1 usbvision->video_endp=$%02x\n", 
+			proc, usbvision->video_endp);)
+	return 0;
+}
+
+/*
+ * usbvision_stop_isoc()
+ *
+ * This procedure stops streaming and deallocates URBs. Then it
+ * activates zero-bandwidth alt. setting of the video interface.
+ *
+ */
+static void usbvision_stop_isoc(struct usb_usbvision *usbvision)
+{
+	static const char proc[] = "usbvision_stop_isoc: ";
+	int i, j;
+
+	if (!usbvision->streaming || (usbvision->dev == NULL))
+		return;
+
+	/* Unschedule all of the iso td's */
+	for (i = 0; i < USBVISION_NUMSBUF; i++) {
+		j = usb_unlink_urb(usbvision->sbuf[i].urb);
+		if (j < 0)
+			printk(KERN_ERR "%susb_unlink_urb() error %d.\n", proc, j);
+	}
+	DEBUG(printk(KERN_DEBUG "%sstreaming=0\n", proc);)
+	usbvision->streaming = 0;
+
+	/* Delete them all */
+	for (i = 0; i < USBVISION_NUMSBUF; i++)
+		usb_free_urb(usbvision->sbuf[i].urb);
+
+	if (!usbvision->remove_pending) {
+
+		/* Set packet size to 0 */
+		j = usb_set_interface(usbvision->dev, usbvision->iface,
+				      usbvision->ifaceAltInactive);
+		if (j < 0) {
+			printk(KERN_ERR "%s: usb_set_interface() error %d.\n", proc, j);
+			usbvision->last_error = j;
+		}
+	}
+}
+
+/*
+ * usbvision_new_frame()
+ *
+ */
+static int usbvision_new_frame(struct usb_usbvision *usbvision, int framenum)
+{
+	struct usbvision_frame *frame;
+	int n; //byhec  , width, height;
+
+	/* If we're not grabbing a frame right now and the other frame is */
+	/*  ready to be grabbed into, then use it instead */
+	if (usbvision->curframe != -1)
+		return 0;
+
+	n = (framenum - 1 + USBVISION_NUMFRAMES) % USBVISION_NUMFRAMES;
+	if (usbvision->frame[n].grabstate == FRAME_READY)
+		framenum = n;
+
+	frame = &usbvision->frame[framenum];
+
+	frame->grabstate = FRAME_GRABBING;
+	frame->scanstate = STATE_SCANNING;
+	frame->scanlength = 0;	/* Accumulated in usbvision_parse_data() */
+	usbvision->curframe = framenum;
+
+	/*
+	 * Normally we would want to copy previous frame into the current one
+	 * before we even start filling it with data; this allows us to stop
+	 * filling at any moment; top portion of the frame will be new and
+	 * bottom portion will stay as it was in previous frame. If we don't
+	 * do that then missing chunks of video stream will result in flickering
+	 * portions of old data whatever it was before.
+	 *
+	 * If we choose not to copy previous frame (to, for example, save few
+	 * bus cycles - the frame can be pretty large!) then we have an option
+	 * to clear the frame before using. If we experience losses in this
+	 * mode then missing picture will be black (flickering).
+	 *
+	 * Finally, if user chooses not to clean the current frame before
+	 * filling it with data then the old data will be visible if we fail
+	 * to refill entire frame with new data.
+	 */
+	if (!(flags & FLAGS_SEPARATE_FRAMES)) {
+		/* This copies previous frame into this one to mask losses */
+		memmove(frame->data, usbvision->frame[1 - framenum].data,
+			MAX_FRAME_SIZE);
+	} else {
+		if (flags & FLAGS_CLEAN_FRAMES) {
+			/*This provides a "clean" frame but slows things down */
+			memset(frame->data, 0, MAX_FRAME_SIZE);
+		}
+	}
+	return 0;
+}
+
+static int usbvision_muxsel(struct usb_usbvision *usbvision, int channel, int norm)
+{
+	int mode[] = {0, 1, 7}; //modes of saa7111  fix me (this is only for Hauppauge WinTV)
+	int audio[]= {1, 0, 0};	//channel 0 is TV with audiochannel 1 (tuner mono)
+							//channel 1 is Composite with audio channel 0 (line in)
+							//channel 2 is S-Video with audio channel 0 (line in)
+
+	RESTRICT_TO_RANGE(channel, 0, usbvision->video_inputs);
+	/* set the new video norm */
+	if (usbvision->vchan.norm != norm) {
+		int video_command = norm; //VIDEO_MODE_AUTO;
+		call_i2c_clients(usbvision, DECODER_SET_NORM, &video_command);	//set norm in video-codec
+		call_i2c_clients(usbvision, VIDIOCSCHAN, &usbvision->vchan);	//set norm in tuner
+		video_command = 1;
+		call_i2c_clients(usbvision, DECODER_ENABLE_OUTPUT,
+				 &video_command);
+		usbvision->vchan.norm = norm;
+	}
+
+	/* set the new channel */
+	call_i2c_clients(usbvision, DECODER_SET_INPUT, &mode[channel]);
+	usbvision->channel = channel;
+	usbvision_set_audio(usbvision, audio[channel]);
+	return 0;
+}
+
+
+/*
+ * usbvision_open()
+ *
+ * This is part of Video 4 Linux API. The driver can be opened by one
+ * client only (checks internal counter 'usbvision->user'). The procedure
+ * then allocates buffers needed for video processing.
+ *
+ */
+static int usbvision_open(struct video_device *dev, int flags)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+	const int sb_size = FRAMES_PER_DESC * usbvision->iso_packet_len;
+	/* sb_size should be FR_PER_DESC * max_packet_len if wanna change 
+	 * packet len dinamically for bw management
+	 */
+	int i, err = 0;
+
+	MOD_INC_USE_COUNT;
+	
+	if(PowerOnAtOpen) {
+		usbvision_power_on(usbvision);
+		usbvision_init_i2c(usbvision);
+	}
+
+	IODEBUG(printk(KERN_DEBUG "usbvision_open: usbvision = %p\n", usbvision);)
+	down(&usbvision->lock);
+
+	if (usbvision->user)
+		err = -EBUSY;
+	else {
+		/* Clean pointers so we know if we allocated something */
+		for (i = 0; i < USBVISION_NUMSBUF; i++)
+			usbvision->sbuf[i].data = NULL;
+
+		/* Allocate memory for the frame buffers */
+		usbvision->fbuf_size = USBVISION_NUMFRAMES * MAX_FRAME_SIZE;
+		usbvision->fbuf = rvmalloc(usbvision->fbuf_size);
+		usbvision->scratch = kmalloc(scratch_buf_size, GFP_KERNEL);
+		scratch_reset(usbvision);
+		if ((usbvision->fbuf == NULL) || (usbvision->scratch == NULL)) {
+			printk(KERN_ERR "usbvision_open: unable to allocate memory for frame buffer and scratch\n");
+			err = -ENOMEM;
+		}
+		else {
+			/* Allocate all buffers */
+			for (i = 0; i < USBVISION_NUMFRAMES; i++) {
+				usbvision->frame[i].grabstate = FRAME_UNUSED;
+				usbvision->frame[i].data = usbvision->fbuf +
+				    i * MAX_FRAME_SIZE;
+				/*
+				 * Set default sizes in case IOCTL
+				 * (VIDIOCMCAPTURE)
+				 * is not used (using read() instead).
+				 */
+				usbvision->stretch_width = 1;
+				usbvision->stretch_height = 1;
+				usbvision->frame[i].width = usbvision->curwidth;
+				usbvision->frame[i].height = usbvision->curheight;
+				usbvision->frame[i].bytes_read = 0;
+			}
+			if (dga) { //set default for DGA
+				usbvision->overlay_frame.grabstate = FRAME_UNUSED;
+				usbvision->overlay_frame.scanstate = STATE_SCANNING;
+				usbvision->overlay_frame.data = NULL;
+				usbvision->overlay_frame.width = usbvision->curwidth;
+				usbvision->overlay_frame.height = usbvision->curheight;
+				usbvision->overlay_frame.bytes_read = 0;
+			}
+			
+			for (i = 0; i < USBVISION_NUMSBUF; i++) {
+				usbvision->sbuf[i].data =
+				    kmalloc(sb_size, GFP_KERNEL);
+				if (usbvision->sbuf[i].data == NULL) {
+					err = -ENOMEM;
+					break;
+				}
+			}
+		}
+		if (err) {
+			/* Have to free all that memory */
+			if (usbvision->fbuf != NULL) {
+				rvfree(usbvision->fbuf, usbvision->fbuf_size);
+				usbvision->fbuf = NULL;
+			}
+			if (usbvision->scratch != NULL) {
+				kfree(usbvision->scratch);
+				usbvision->scratch = NULL;
+			}
+			for (i = 0; i < USBVISION_NUMSBUF; i++) {
+				if (usbvision->sbuf[i].data != NULL) {
+					kfree(usbvision->sbuf[i].data);
+					usbvision->sbuf[i].data = NULL;
+				}
+			}
+			if (PowerOnAtOpen) {
+				i2c_usb_del_bus(&usbvision->i2c_adap);
+				usbvision_power_off(usbvision);
+				usbvision->initialized = 0;
+			}
+		}
+	}
+
+	/* If so far no errors then we shall start the camera */
+	if (!err) {
+		/* Send init sequence only once, it's large! */
+		if (!usbvision->initialized) {
+			int setup_ok = 0;
+			setup_ok = usbvision_setup(usbvision);
+			if (setup_ok)
+				usbvision->initialized = 1;
+			else
+				err = -EBUSY;
+		}
+		if (!err) {
+			usbvision_begin_streaming(usbvision);
+			err = usbvision_init_isoc(usbvision);
+			usbvision->user++;
+		}
+	}
+	up(&usbvision->lock);
+	if (err)
+		MOD_DEC_USE_COUNT;
+	return err;
+}
+
+/*
+ * usbvision_close()
+ *
+ * This is part of Video 4 Linux API. The procedure
+ * stops streaming and deallocates all buffers that were earlier
+ * allocated in usbvision_open().
+ *
+ */
+static void usbvision_close(struct video_device *dev)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+	int i;
+
+	down(&usbvision->lock);
+
+	usbvision_audio_off(usbvision);
+	usbvision_restart_isoc(usbvision);
+	usbvision_stop_isoc(usbvision);
+//      usbvision->initialized=0;
+
+	rvfree(usbvision->fbuf, usbvision->fbuf_size);
+	kfree(usbvision->scratch);
+	for (i = 0; i < USBVISION_NUMSBUF; i++)
+		kfree(usbvision->sbuf[i].data);
+
+	usbvision->user--;
+
+	if (usbvision->remove_pending) {
+		printk(KERN_INFO "usbvision_close: Final disconnect.\n");
+		usbvision_release(usbvision);
+	}
+	
+	if (PowerOnAtOpen) {
+		i2c_usb_del_bus(&usbvision->i2c_adap);
+		usbvision_power_off(usbvision);
+		usbvision->initialized = 0;
+	}
+	
+	up(&usbvision->lock);
+	
+	IODEBUG(printk(KERN_DEBUG "usbvision_close: usbvision = %p\n", usbvision);)
+
+	MOD_DEC_USE_COUNT;
+}
+
+static int usbvision_init_done(struct video_device *dev)
+{
+	return 0;
+}
+
+static long
+usbvision_write(struct video_device *dev, const char *buf,
+	     unsigned long count, int noblock)
+{
+	return -EINVAL;
+}
+
+/*
+ * usbvision_ioctl()
+ *
+ * This is part of Video 4 Linux API. The procedure handles ioctl() calls.
+ *
+ */
+static int
+usbvision_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
+{
+	static const char proc[] = "usbvision_ioctl: ";
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -EFAULT;
+
+	switch (cmd) {
+	case VIDIOCGCAP:
+	{
+		if (copy_to_user(arg, &usbvision->vcap,
+				 sizeof(usbvision->vcap)))
+			    return -EFAULT;
+		return 0;
+	}
+	case VIDIOCGCHAN:
+	{
+		int chan;
+		struct video_channel v;
+
+		if (copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+		v.flags = usbvision->vchan.flags;
+		v.tuners = usbvision->vchan.tuners;
+		v.type = usbvision->vchan.type;
+		v.norm = usbvision->vchan.norm;
+		if (v.channel >= usbvision->video_inputs)
+			return -EINVAL;
+		if (usbvision->have_tuner) {
+			chan = v.channel;
+		}
+		else {
+			chan = v.channel + 1; //skip Television string
+		}
+		switch(chan) {
+			case 0:
+				strcpy(v.name, "Television");
+				v.flags |= VIDEO_VC_TUNER;
+				v.type = VIDEO_TYPE_TV;
+				v.tuners = usbvision->have_tuner;
+				break;
+			case 1:
+				strcpy(v.name, "Composite 1");
+				break;
+			case 2:
+				strcpy(v.name, "S-Video");
+				break;			
+		}
+
+		if (copy_to_user(arg, &v, sizeof(v)))
+			return -EFAULT;
+		
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCGCHAN name=%s\n", proc, v.name);)
+		return 0;
+	}
+	case VIDIOCSCHAN:
+	{
+		struct video_channel v;
+		if (copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCSCHAN channel=%d\n", proc, v.channel);)
+
+		if (v.channel > usbvision->video_inputs)
+			return -EINVAL;
+
+		usbvision->vchan.channel = v.channel;
+		//usbvision->vchan.norm = v.norm; <- this will be done in usbvision_muxsel()
+		down(&usbvision->lock);
+		
+		usbvision_muxsel(usbvision, v.channel, v.norm);
+		usbvision_set_input(usbvision);
+		usbvision_set_output(usbvision, usbvision->curwidth, usbvision->curheight); 
+		up(&usbvision->lock);
+		
+		return 0;
+	}
+	case VIDIOCGPICT:
+	{
+		if (copy_to_user(arg, &usbvision->vpic,
+				 sizeof(usbvision->vpic)))
+			    return -EFAULT;
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCGPICT depth=%d, palette=%d\n", proc, 
+					usbvision->vpic.depth, usbvision->vpic.palette);)
+		return 0;
+	}
+	case VIDIOCSPICT:
+	{
+		struct video_picture p;
+		if (copy_from_user(&p, arg, sizeof(p)))
+			return -EFAULT;
+		call_i2c_clients(usbvision, DECODER_SET_PICTURE, &p);
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCSPICT depth=%d, palette=%d\n",
+					proc, p.depth, p.palette);)
+		return 0;
+	}
+	case VIDIOCGMBUF:
+	{
+		struct video_mbuf vm;
+
+		memset(&vm, 0, sizeof(vm));
+		vm.size = MAX_FRAME_SIZE * 2;
+		vm.frames = 2;
+		vm.offsets[0] = 0;
+		vm.offsets[1] = MAX_FRAME_SIZE;
+
+		if (copy_to_user ((void *) arg, (void *) &vm, sizeof(vm)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case VIDIOCMCAPTURE:
+	{
+		struct video_mmap vm;
+		struct usbvision_frame *frame;
+
+		if (copy_from_user ((void *) &vm, (void *) arg, sizeof(vm)))
+			return -EFAULT;
+
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCMCAPTURE frame=%d, size=%dx%d, format=%d\n",
+			       proc, vm.frame, vm.width, vm.height, vm.format);)
+
+		if ((vm.format >= USBVISION_SUPPORTED_PALETTES) || 
+		    (usbvision_v4l_format[vm.format].supported == 0)) {	
+		    printk(KERN_ERR "%sVIDIOCMCAPTURE format %d not supported\n", proc, vm.format);
+			return -EINVAL;
+		}
+		else
+			
+		if (vm.frame >= USBVISION_NUMFRAMES)
+			return -EINVAL;
+		
+		frame = &usbvision->frame[vm.frame];
+		
+		if (frame->grabstate == FRAME_GRABBING)
+			return -EBUSY;
+
+		usbvision_set_output(usbvision, vm.width, vm.height);
+
+		frame->width = vm.width;
+		frame->height = vm.height;
+		frame->v4l_format = vm.format;
+		/* Mark it as ready */
+		frame->grabstate = FRAME_READY;
+
+		return usbvision_new_frame(usbvision, vm.frame);
+	}
+	case VIDIOCSYNC:
+	{
+		int frame, ret = 0;
+
+		DECLARE_WAITQUEUE(wait, current);
+
+		if (copy_from_user ((void *) &frame, arg, sizeof(int)))
+			return -EFAULT;
+
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCSYNC frame=%d, grabstate=%d\n",
+			       proc, frame, usbvision->frame[frame].grabstate);)
+
+		switch (usbvision->frame[frame].grabstate) {
+		case FRAME_UNUSED:
+			ret = -EINVAL;
+			break;
+		case FRAME_GRABBING:
+			add_wait_queue(&usbvision->frame [frame].wq, &wait);
+			current->state = TASK_INTERRUPTIBLE;
+			while (usbvision->frame[frame].
+			       grabstate == FRAME_GRABBING) {
+				schedule();
+				if (signal_pending(current)) {
+					remove_wait_queue
+						(&usbvision->frame[frame].wq,
+						 &wait);
+					current->state = TASK_RUNNING;
+					return -EINTR;
+				}
+			}
+			remove_wait_queue(&usbvision->frame [frame].wq, &wait);
+			current->state = TASK_RUNNING;
+		case FRAME_READY:
+		case FRAME_ERROR:
+		case FRAME_DONE:
+			ret = (usbvision->frame[frame].grabstate == 
+					FRAME_ERROR) ? -EIO : 0;
+			usbvision->frame[frame].grabstate = FRAME_UNUSED;
+			break;
+		}
+
+		usbvision->frame[frame].grabstate = FRAME_UNUSED;
+
+		return ret;
+	}
+	case VIDIOCGFBUF:
+	{
+//		IODEBUG(printk(KERN_DEBUG "%sVIDIOCGFBUF\n", proc);)
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCGFBUF(%p,%d,%d,%d,%d)\n",
+				proc, usbvision->vid_buf.base, 
+				usbvision->vid_buf.width,usbvision->vid_buf.height,
+				usbvision->vid_buf.depth,usbvision->vid_buf.bytesperline);)
+
+
+		if (dga) {
+			if (copy_to_user ((void *) arg, (void *) &usbvision->vid_buf,
+					sizeof(usbvision->vid_buf))) {
+				return -EFAULT;
+			}
+		}
+		else {
+			struct video_buffer vb;
+
+			memset(&vb, 0, sizeof(vb));
+			vb.base = NULL;	//dga not supported, not used
+			if (copy_to_user ((void *) arg, (void *) &vb, sizeof(vb))) {
+				return -EFAULT;
+			}
+		}		
+		return 0;
+	}
+	case VIDIOCSFBUF:
+	{
+		struct video_buffer vb;
+		int format_index;
+		
+		if (dga == 0) {
+			return -EINVAL;
+		}
+	
+		if(!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_ADMIN))
+			return -EPERM;
+		
+		if (copy_from_user(&vb,arg,sizeof(vb)))
+			return -EFAULT;
+		
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCSFBUF(%p,%d,%d,%d,%d)\n",
+				proc, vb.base, vb.width,vb.height,vb.depth,vb.bytesperline);)
+		
+		for (format_index=0; format_index <= USBVISION_SUPPORTED_PALETTES; format_index++) {
+			if (format_index == USBVISION_SUPPORTED_PALETTES) {
+				return -EINVAL; // no matching video_format
+			}
+			if ((vb.depth == usbvision_v4l_format[format_index].depth) &&
+			    (usbvision_v4l_format[format_index].supported)) {
+				break; //found matching video_format
+			}
+		}
+		
+		if (vb.bytesperline<1)
+			return -EINVAL;
+		if (usbvision->overlay)
+			return -EBUSY;
+		
+		down(&usbvision->lock);
+		if (usbvision->overlay_base) {
+			vfree(usbvision->overlay_base);
+		}
+		usbvision->overlay_base = ioremap((ulong)vb.base, vb.height * vb.bytesperline);
+		
+		memcpy(&usbvision->vid_buf, &vb, sizeof(vb));
+		usbvision->vid_buf.base = vb.base;
+		usbvision->overlay_frame.v4l_format = format_index;
+		up(&usbvision->lock);
+		return 0;
+	}
+	case VIDIOCGWIN:
+	{
+		struct video_window vw;
+	
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCGWIN\n", proc);)
+		
+		if (dga == 0) {
+			return -EINVAL;
+		}
+	
+		down(&usbvision->lock);
+		vw.x      = usbvision->vid_win.x;
+		vw.y      = usbvision->vid_win.y;
+		vw.width  = usbvision->vid_win.width;
+		vw.height = usbvision->vid_win.height;
+		vw.chromakey= usbvision->vid_win.chromakey;
+		vw.flags  = usbvision->vid_win.flags;
+		up(&usbvision->lock);
+		
+		if (copy_to_user(arg, &vw, sizeof(vw))) {
+			return -EFAULT;
+		}
+		break;
+	 }
+	 case VIDIOCSWIN:
+	 {
+		struct video_window vw;
+		struct video_clip *vcp;
+		int on;
+		
+		if (dga == 0) {
+			return -EINVAL;
+		}
+		
+		if (copy_from_user(&vw,arg,sizeof(vw)))
+			return -EFAULT;
+		
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCSWIN(%d,%d,%d,%d,%x,%x,%d)\n", proc, 
+				vw.x, vw.y, vw.width, vw.height, vw.chromakey, 
+				vw.flags, vw.clipcount);)
+
+		if (vw.flags)
+			return -EINVAL;
+
+		if (vw.clipcount>256)
+			return -EDOM;   /* Too many! */
+
+		/*
+		 *      Do any clips.
+		 */
+		vcp = vmalloc(sizeof(struct video_clip)*(vw.clipcount+4));
+		if (vcp==NULL)
+			return -ENOMEM;
+		if (vw.clipcount && copy_from_user(vcp,vw.clips,sizeof(struct video_clip)*vw.clipcount))
+			return -EFAULT;
+
+		on = usbvision->overlay;
+		if (on)
+			usbvision_cap(usbvision, 0);
+
+		// strange, it seems xawtv sometimes calls us with 0
+		// width and/or height. Ignore these values
+		 
+		if (vw.x == 0)
+			vw.x = usbvision->vid_win.x;
+		if (vw.y == 0)
+			vw.y = usbvision->vid_win.y;
+
+		// by now we are committed to the new data...
+		down(&usbvision->lock);
+		usbvision->vid_win.x = vw.x;
+		usbvision->vid_win.y = vw.y;
+		RESTRICT_TO_RANGE(vw.width, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);
+		RESTRICT_TO_RANGE(vw.height, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
+		usbvision_set_output(usbvision, vw.width, vw.height);
+		
+		usbvision->vid_win.width = vw.width;
+		usbvision->vid_win.height = vw.height;
+		usbvision->overlay_frame.width = vw.width;
+		usbvision->overlay_frame.height = vw.height;
+		usbvision->vid_win.chromakey = vw.chromakey;
+		usbvision->vid_win.flags = vw.flags;
+		up(&usbvision->lock);
+
+
+		/*
+		 *      Impose display clips
+		 */
+		if (vw.x+vw.width > usbvision->vid_buf.width)
+			usbvision_new_clip(&vw, vcp, usbvision->vid_buf.width-vw.x, 0,
+					vw.width-1, vw.height-1);
+		if (vw.y+vw.height > usbvision->vid_buf.height)
+			usbvision_new_clip(&vw, vcp, 0, usbvision->vid_buf.height-vw.y, 
+					vw.width-1, vw.height-1);
+
+		/* built the requested clipping zones */
+		usbvision_built_overlay(usbvision, vw.clipcount, vcp);
+		vfree(vcp);
+
+		/* if we were on, restart the video engine */
+		if (on)
+			usbvision_cap(usbvision, 1);
+		break;
+	}
+	case VIDIOCKEY:
+	{
+		return 0;
+	}
+	case VIDIOCCAPTURE:
+	{
+		int v;
+	
+		if (dga == 0) {
+			return -EINVAL;
+		}
+		
+		if (get_user(v, (int *)arg)) {
+			return -EFAULT;
+		}
+		
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCCAPTURE(%d)\n",proc, v);)
+
+		if (v==0) {
+			usbvision_cap(usbvision, 0);
+		}
+		else {
+			// is VIDIOCSFBUF, VIDIOCSWIN done?
+			if (usbvision->vid_buf.base  ==0 || 
+			    usbvision->vid_win.width ==0 || 
+			    usbvision->vid_win.height==0 ||
+			    usbvision->overlay_base  ==0) {
+				return -EINVAL;
+			}
+			usbvision_cap(usbvision, 1);
+		}
+		return 0;
+
+	}
+	case VIDIOCGTUNER:
+	{
+		struct video_tuner v;
+		if (copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+
+		if (!usbvision->have_tuner || v.tuner)	// Only tuner 0
+			return -EINVAL;
+
+		strcpy(v.name, "Television");
+		v.rangelow = 0;
+		v.rangehigh = ~0;
+		v.flags = VIDEO_TUNER_PAL | VIDEO_TUNER_NTSC |
+			VIDEO_TUNER_SECAM;
+		v.mode = usbvision->vchan.norm;
+		v.signal = 0xFFFF;	/* unknown */
+
+		call_i2c_clients(usbvision, cmd, &v);
+
+		if (copy_to_user(arg, &v, sizeof(v)))
+			return -EFAULT;
+
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCGTUNER\n",proc);)
+		return 0;
+	}
+	case VIDIOCSTUNER:
+	{
+		struct video_tuner v;
+		if (copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+		/* Only no or one tuner for now */
+		if (!usbvision->have_tuner || v.tuner)
+			return -EINVAL;
+
+		/* and it only has certain valid modes */
+		if (v.mode != VIDEO_MODE_PAL && v.mode != VIDEO_MODE_NTSC &&
+		    v.mode != VIDEO_MODE_SECAM)
+			return -EOPNOTSUPP;
+
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCSTUNER tuner=%d, mode=%d\n",proc, v.tuner, v.mode);)
+		return usbvision_muxsel(usbvision, v.tuner, v.mode);
+
+	}
+	case VIDIOCGFREQ:
+	{
+		unsigned long v = usbvision->freq;
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCGFREQ freq=0x%lX\n",proc, v);)
+		RIODEBUG(printk(KERN_DEBUG "usbvision_radio_ioctl: VIDIOCGFREQ freq=0x%lX\n", v);)
+		if (copy_to_user(arg, &v, sizeof(v)))
+			return -EFAULT;
+		return 0;
+	}
+	case VIDIOCSFREQ:
+	{
+		unsigned long v;
+		if (copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+		usbvision->freq = v;
+		call_i2c_clients(usbvision, cmd, &v);
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCSFREQ freq=0x%lX\n",proc, v);)
+		RIODEBUG(printk(KERN_DEBUG "usbvision_radio_ioctl: VIDIOCSFREQ freq=0x%lX\n", v);)
+		return 0;
+	}
+	case VIDIOCGAUDIO:
+	{
+		struct video_audio v;
+		memset(&v,0, sizeof(v));
+		v.flags|=VIDEO_AUDIO_MUTABLE;
+		v.mode=VIDEO_SOUND_MONO;
+		v.volume=1;
+		v.step=1;
+		strcpy(v.name, "TV");
+		if(copy_to_user(arg,&v, sizeof(v)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case VIDIOCSAUDIO:
+	{
+		struct video_audio v;
+		if(copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+		if(v.audio)
+			return -EINVAL;
+
+		IODEBUG(printk(KERN_DEBUG "%sVIDIOCSAUDIO(flags:0x%x)\n",proc, v.flags);)
+		
+		if(v.flags&VIDEO_AUDIO_MUTE) {
+			if (usbvision_audio_mute(usbvision))
+				return -EFAULT;
+		}
+		else
+			if (usbvision_audio_on(usbvision))
+				return -EFAULT;
+		return 0;
+	}
+
+	/* Should I do CGCAPTURE and CSCAPTURE */
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+static long
+usbvision_read(struct video_device *dev, char *buf, unsigned long count,
+	    int noblock)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+	int frmx = -1;
+	volatile struct usbvision_frame *frame;
+
+	if (debug >= 1)
+		printk(KERN_DEBUG "usbvision_read: %ld bytes, noblock=%d\n",
+		       count, noblock);
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision) || (buf == NULL))
+		return -EFAULT;
+
+	//code for testing compression
+	if (usbvision->videoformat == VIDEOFORMAT_COMPRESS) {
+		usbvision->frame[0].v4l_format = VIDEO_PALETTE_GREY;
+		usbvision->frame[1].v4l_format = VIDEO_PALETTE_GREY;
+	}
+	
+	/* See if a frame is completed, then use it. */
+	if (usbvision->frame[0].grabstate >= FRAME_DONE) /* _DONE or _ERROR */
+		frmx = 0;
+	else if (usbvision->frame[1].grabstate >= FRAME_DONE)/*_DONE or _ERROR*/
+		frmx = 1;
+
+	if (noblock && (frmx == -1))
+		return -EAGAIN;
+
+	/* If no FRAME_DONE, look for a FRAME_GRABBING state. */
+	/* See if a frame is in process (grabbing), then use it. */
+	if (frmx == -1) {
+		if (usbvision->frame[0].grabstate == FRAME_GRABBING)
+			frmx = 0;
+		else if (usbvision->frame[1].grabstate == FRAME_GRABBING)
+			frmx = 1;
+	}
+
+	/* If no frame is active, start one. */
+	if (frmx == -1)
+		usbvision_new_frame(usbvision, frmx = 0);
+
+	frame = &usbvision->frame[frmx];
+	
+      restart:
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -EIO;
+	while (frame->grabstate == FRAME_GRABBING) {
+		interruptible_sleep_on((void *) &frame->wq);
+		if (signal_pending(current))
+			return -EINTR;
+	}
+
+	if (frame->grabstate == FRAME_ERROR) {
+		frame->bytes_read = 0;
+		if (usbvision_new_frame(usbvision, frmx))
+			printk(KERN_ERR
+			       "usbvision_read: usbvision_new_frame error\n");
+		goto restart;
+	}
+
+	if (debug >= 1)
+		printk(KERN_DEBUG
+		       "usbvision_read: frmx=%d, bytes_read=%ld, scanlength=%ld\n",
+		       frmx, frame->bytes_read, frame->scanlength);
+
+	/* copy bytes to user space; we allow for partials reads */
+	if ((count + frame->bytes_read) > frame->scanlength)
+		count = frame->scanlength - frame->bytes_read;
+
+	if (copy_to_user(buf, frame->data + frame->bytes_read, count))
+		return -EFAULT;
+
+	frame->bytes_read += count;
+	if (debug >= 1)
+		printk(KERN_DEBUG
+		       "usbvision_read: {copy} count used=%ld, new bytes_read=%ld\n",
+		       count, frame->bytes_read);
+
+	if (frame->bytes_read >= frame->scanlength) {/*All data has been read */
+		frame->bytes_read = 0;
+
+		/* Mark it as available to be used again. */
+		usbvision->frame[frmx].grabstate = FRAME_UNUSED;
+		if (usbvision_new_frame(usbvision, frmx ? 0 : 1))
+			printk(KERN_ERR
+			       "usbvision_read: usbvision_new_frame returned error\n");
+	}
+
+	return count;
+}
+
+static int
+usbvision_mmap(struct video_device *dev, const char *adr, unsigned long size)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+	unsigned long start = (unsigned long) adr;
+	unsigned long page, pos;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -EFAULT;
+
+	if (size >
+	    (((2 * MAX_FRAME_SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)))
+		    return -EINVAL;
+
+	pos = (unsigned long) usbvision->fbuf;
+	while (size > 0) {
+		page = kvirt_to_pa(pos);
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return 0;
+}
+
+static struct video_device usbvision_template = {
+	name:           "USBVision USB Video",
+	type:           VID_TYPE_TUNER | VID_TYPE_CAPTURE,
+	hardware:       VID_HARDWARE_USBVISION,    
+	open:           usbvision_open,
+	close:          usbvision_close,
+	read:           usbvision_read,
+	write:          usbvision_write,
+	ioctl:          usbvision_ioctl,
+	mmap:           usbvision_mmap,
+	initialize:     usbvision_init_done,
+};
+
+
+/* 
+ * Here comes the stuff for radio on usbvision based devices
+ *
+ */
+
+static int usbvision_radio_open(struct video_device *dev, int flags)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *)dev->priv;
+	unsigned long v;
+	int err = 0;
+
+	RIODEBUG(printk(KERN_DEBUG "usbvision_radio_open\n");)
+			
+	down(&usbvision->lock);
+	MOD_INC_USE_COUNT;
+	
+	if(PowerOnAtOpen) {
+		usbvision_power_on(usbvision);
+		usbvision_init_i2c(usbvision);
+	}
+
+	
+
+
+	if (usbvision->user) {
+		err = -EBUSY;
+		if (PowerOnAtOpen) {
+			i2c_usb_del_bus(&usbvision->i2c_adap);
+			usbvision_power_off(usbvision);
+			usbvision->initialized = 0;
+		}
+	}
+
+	/* If so far no errors then we shall start the radio */
+	if (!err) {
+		usbvision->radio = 1;
+		v = 400*16;
+		call_i2c_clients(usbvision,VIDIOCSFREQ,&v);
+		call_i2c_clients(usbvision,AUDC_SET_RADIO,&usbvision->tuner_type);
+		usbvision_set_audio(usbvision, USBVISION_AUDIO_RADIO);
+		usbvision->user++;
+	}
+	up(&usbvision->lock);
+	if (err)
+		MOD_DEC_USE_COUNT;
+	return err;
+}
+
+
+static void usbvision_radio_close(struct video_device *dev)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *)dev->priv;
+
+	RIODEBUG(printk(KERN_DEBUG "usbvision_radio_close\n");)
+			
+	down(&usbvision->lock);
+	usbvision_audio_off(usbvision);
+    usbvision->radio=0;
+	usbvision->user--;
+
+	if (usbvision->remove_pending) {
+		printk(KERN_INFO "usbvision_radio_close: Final disconnect.\n");
+		usbvision_release(usbvision);
+	}
+	
+	if (PowerOnAtOpen) {
+		i2c_usb_del_bus(&usbvision->i2c_adap);
+		usbvision_power_off(usbvision);
+		usbvision->initialized = 0;
+	}
+	
+	up(&usbvision->lock);
+	MOD_DEC_USE_COUNT;
+}
+
+static long usbvision_radio_write(struct video_device *dev, const char *buf, unsigned long count, int nonblock)
+{
+	RIODEBUG(printk(KERN_DEBUG "usbvision_radio_write\n");)
+	return -EINVAL;
+}
+
+
+static long usbvision_radio_read(struct video_device *dev, char *buf, unsigned long count, int nonblock)
+{
+	RIODEBUG(printk(KERN_DEBUG "usbvision_radio_read\n");)
+	return -EINVAL;
+}
+
+
+static int usbvision_radio_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
+{
+	RIODEBUG(char proc[]="usbvision_radio_ioctl: ";)
+	struct usb_usbvision *usbvision=(struct usb_usbvision *)dev->priv;
+	switch (cmd) {	
+	case VIDIOCGCAP:
+	{
+		struct video_capability v;
+		strcpy(v.name,usbvision->vcap.name);
+		v.type = VID_TYPE_TUNER;
+		v.channels = 1;
+		v.audios = 1;
+		/* No we don't do pictures */
+		v.maxwidth = 0;
+		v.maxheight = 0;
+		v.minwidth = 0;
+		v.minheight = 0;
+		RIODEBUG(printk(KERN_DEBUG "%sVIDIOCGCAP\n",proc);)
+		if (copy_to_user(arg, &v, sizeof(v)))
+			return -EFAULT;
+		return 0;
+		break;
+	}
+	case VIDIOCGTUNER:
+	{
+		struct video_tuner v;
+		if(copy_from_user(&v,arg,sizeof(v))!=0)
+			return -EFAULT;
+		if(v.tuner||usbvision->channel)	/* Only tuner 0 */
+			return -EINVAL;
+		strcpy(v.name, "Radio");
+		/* japan:          76.0 MHz -  89.9 MHz
+		   western europe: 87.5 MHz - 108.0 MHz
+		   russia:         65.0 MHz - 108.0 MHz */
+		v.rangelow=(int)(65*16);
+		v.rangehigh=(int)(108*16);
+		v.flags= 0;
+		v.mode = 0;
+		call_i2c_clients(usbvision,cmd,&v);
+		RIODEBUG(printk(KERN_DEBUG "%sVIDIOCGTUNER signal=%d\n",proc, v.signal);)
+		if(copy_to_user(arg,&v,sizeof(v)))
+			return -EFAULT;
+		return 0;
+	}
+	case VIDIOCSTUNER:
+	{
+		struct video_tuner v;
+		RIODEBUG(printk(KERN_DEBUG "%sVIDIOCSTUNER\n",proc);)
+		if(copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+		/* Only channel 0 has a tuner */
+		if(v.tuner || usbvision->channel)
+			return -EINVAL;
+
+		RIODEBUG(printk(KERN_DEBUG "%sVIDIOCSTUNER ok\n",proc);)
+		return 0;
+	}
+	case VIDIOCGAUDIO:
+	{
+		struct video_audio v;
+		memset(&v,0, sizeof(v));
+		call_i2c_clients(usbvision, cmd, &v);
+		v.flags|=VIDEO_AUDIO_MUTABLE;
+		v.volume=1;
+		v.step=1;
+		strcpy(v.name, "Radio");
+		RIODEBUG(printk(KERN_DEBUG "%sVIDIOCGAUDIO\n",proc);)
+		if(copy_to_user(arg,&v, sizeof(v)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case VIDIOCSAUDIO:
+	{
+		struct video_audio v;
+		RIODEBUG(printk(KERN_DEBUG "%sVIDIOCSAUDIO\n",proc);)
+		if(copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+		if(v.audio)
+			return -EINVAL;
+
+		if(v.flags&VIDEO_AUDIO_MUTE) {
+			if (usbvision_audio_mute(usbvision))
+				return -EFAULT;
+		}
+		else
+			if (usbvision_audio_on(usbvision))
+				return -EFAULT;
+		RIODEBUG(printk(KERN_DEBUG "%sVIDIOCSAUDIO(flags:0x%x)\n",proc, v.flags);)
+		return 0;
+	}
+	case VIDIOCGFREQ:
+	case VIDIOCSFREQ:
+		usbvision_ioctl((struct video_device *)usbvision,cmd,arg);
+		break;
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+static struct video_device usbvision_radio_template=
+{
+	owner:		THIS_MODULE,
+	name:		"USBVision USB Radio",
+	type:		VID_TYPE_TUNER,
+	hardware:	VID_HARDWARE_USBVISION, 		
+	open:		usbvision_radio_open,
+	close:		usbvision_radio_close,
+	read:		usbvision_radio_read,	/* just returns -EINVAL */
+	write:		usbvision_radio_write,	/* just returns -EINVAL */
+	ioctl:		usbvision_radio_ioctl,
+	minor:		-1,
+};
+
+
+static void usbvision_configure_video(struct usb_usbvision *usbvision)
+{
+	int model = usbvision->DevModel;
+	
+	if (usbvision == NULL)
+		return;
+
+	RESTRICT_TO_RANGE(init_brightness, 0, 255);
+	RESTRICT_TO_RANGE(init_contrast, 0, 255);
+	RESTRICT_TO_RANGE(init_color, 0, 255);
+	RESTRICT_TO_RANGE(init_hue, 0, 255);
+	RESTRICT_TO_RANGE(hue_correction, 0, 255);
+
+	memset(&usbvision->vpic, 0, sizeof(usbvision->vpic));
+
+	usbvision->vpic.colour = init_color << 8;
+	usbvision->vpic.hue = init_hue << 8;
+	usbvision->vpic.brightness = init_brightness << 8;
+	usbvision->vpic.contrast = init_contrast << 8;
+	usbvision->vpic.whiteness = 105 << 8;	/* This one isn't used */
+	usbvision->vpic.depth = 24;
+	usbvision->vpic.palette = VIDEO_PALETTE_RGB24;
+	
+	memset(&usbvision->vcap, 0, sizeof(usbvision->vcap));
+	strcpy(usbvision->vcap.name, "USBVision USB Video");
+	usbvision->vcap.type = VID_TYPE_CAPTURE | 
+		(dga ? (VID_TYPE_CLIPPING | VID_TYPE_OVERLAY) : 0) |
+		(usbvision->have_tuner ? VID_TYPE_TUNER : 0);
+	
+	usbvision->vcap.channels = usbvision_device_data[model].VideoChannels;
+	usbvision->vcap.audios = usbvision_device_data[model].AudioChannels;
+	usbvision->vcap.maxwidth = max_imgwidth;
+	usbvision->vcap.maxheight = max_imgheight;
+	usbvision->vcap.minwidth = min_imgwidth;
+	usbvision->vcap.minheight = min_imgheight;
+
+	memset(&usbvision->vchan, 0, sizeof(usbvision->vchan));
+	usbvision->vchan.flags = VIDEO_VC_AUDIO;
+	usbvision->vchan.tuners = 0;
+	usbvision->vchan.channel = 0;
+	usbvision->vchan.type = VIDEO_TYPE_CAMERA;
+	usbvision->vchan.norm = usbvision_device_data[model].VideoNorm;
+
+	usbvision->video_inputs = usbvision->vcap.channels;
+
+	/* This should be here to make i2c clients to be able to register */
+	usbvision_audio_off(usbvision);	//first switch off audio
+	if (!PowerOnAtOpen) {
+		usbvision_power_on(usbvision);	//and then power up the noisy tuner
+		usbvision_init_i2c(usbvision);
+	}
+}
+
+/*
+ * usbvision_find_struct()
+ *
+ * This code searches the array of preallocated (static) structures
+ * and returns index of the first one that isn't in use. Returns -1
+ * if there are no free structures.
+ *
+ */
+static int usbvision_find_struct(void)
+{
+	int i, u;
+
+	for (u = 0; u < MAX_USBVISION; u++) {
+		struct usb_usbvision *usbvision = &vdevs[u];
+		if (!usbvision->usbvision_used) {	/* This one is free */
+			usbvision->usbvision_used = 1;	/* In use now */
+			for (i = 0; i < USBVISION_NUMFRAMES; i++) {
+				init_waitqueue_head(&usbvision->frame[i].wq);
+			}
+			init_waitqueue_head(&usbvision->overlay_frame.wq);
+			init_MUTEX(&usbvision->lock);	/* to 1 == available */
+			usbvision->dev = NULL;
+			memcpy(&usbvision->vdev, &usbvision_template, sizeof(usbvision_template));
+			memcpy(&usbvision->rdev, &usbvision_radio_template, sizeof(usbvision_radio_template));
+			
+			return u;
+		}
+	}
+	return -1;
+}
+
+/*
+ * usbvision_probe()
+ *
+ * This procedure queries device descriptor and accepts the interface
+ * if it looks like USBVISION video device
+ *
+ */
+static void *usbvision_probe(struct usb_device *dev, unsigned int ifnum,
+				const struct usb_device_id *id)
+{
+	struct usb_usbvision *usbvision = NULL;
+	const struct usb_interface_descriptor *interface;
+	const struct usb_endpoint_descriptor *endpoint;
+	int devnum;
+	int model;
+	
+	if (debug >= 1)
+		printk(KERN_DEBUG "usbvision_probe(%p,%u.)\n", dev, ifnum);
+
+	/* We don't handle multi-config */
+	/*
+	if (dev->descriptor.bNumConfigurations != 1)
+		return NULL;
+	*/
+
+	/* Is it an USBVISION video dev? */
+	model = 0;
+	for(model = 0; usbvision_device_data[model].idVendor; model++) {
+		if (dev->descriptor.idVendor  != usbvision_device_data[model].idVendor) {
+			continue;
+		}
+		if (dev->descriptor.idProduct != usbvision_device_data[model].idProduct) {
+			continue;
+		}
+		
+		printk(KERN_INFO "usbvision: %s found\n", 
+			usbvision_device_data[model].ModelString);
+		break;
+	}
+	if (usbvision_device_data[model].idVendor == 0) {
+		return NULL; //no matching device
+	}
+	
+	if (usbvision_device_data[model].Interface >= 0) {
+		interface = &dev->actconfig->interface[usbvision_device_data[model].Interface].altsetting[0];
+	}
+	else {
+		interface = &dev->actconfig->interface[ifnum].altsetting[0];
+	}
+	/* The nt1004 have 3 or 4 endpoints
+	if (interface->bNumEndpoints != 2) {
+		printk(KERN_ERR
+		       "USBVISION: interface %d. has %u. endpoints!\n", ifnum,
+		       (unsigned) (interface->bNumEndpoints));
+		return NULL;
+	}
+	*/
+
+	endpoint = &interface->endpoint[1];
+	if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_ISOC) {
+		printk(KERN_ERR "USBVISION: interface %d. has non-ISO endpoint!\n", ifnum);
+		printk(KERN_ERR "USBVISION: Endpoint attribures %d\n", endpoint->bmAttributes);
+		return NULL;
+	}
+	if ((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) {
+		printk(KERN_ERR
+		       "USBVISION: interface %d. has ISO OUT endpoint!\n",
+		       ifnum);
+		return NULL;
+	}
+
+	/* Code below may sleep, need to lock module while we are here */
+	MOD_INC_USE_COUNT;
+
+	devnum = usbvision_find_struct();
+	if (devnum == -1) {
+		printk(KERN_INFO "USBVISION USB driver: Too many devices!\n");
+		MOD_DEC_USE_COUNT;
+		return NULL;
+	}
+	usbvision = &vdevs[devnum];
+	usbvision->nr = devnum;
+
+	usbvision->have_tuner = usbvision_device_data[model].Tuner;
+	if (usbvision->have_tuner) {
+		usbvision->tuner_type = usbvision_device_data[model].TunerType;
+	}
+
+	down(&usbvision->lock);
+	usbvision->DevModel = model;
+	usbvision->remove_pending = 0;
+	usbvision->last_error = 0;
+	usbvision->dev = dev;
+	usbvision->iface = ifnum;
+	usbvision->ifaceAltInactive = 0;
+	usbvision->ifaceAltActive = 1;
+	usbvision->video_endp = endpoint->bEndpointAddress;
+
+	usbvision->iso_packet_len = ((16 - usbvision_read_reg(usbvision, USBVISION_ALTER_REG)) * 64) - 1;
+	printk(KERN_INFO "USBVision Maxium ISO Packet Length:%d\n", usbvision->iso_packet_len);
+
+	usbbandwidth = (16 - usbvision_read_reg(usbvision, USBVISION_ALTER_REG)) * 0.5;
+	printk(KERN_INFO "USBVision USB Bandwidth Usage: %dMbit/Sec\n", usbbandwidth);
+
+
+	usbvision->user = 0;
+
+	usbvision_configure_video(usbvision);
+	up(&usbvision->lock);
+
+	usbvision->vdev.priv = usbvision;
+	if (video_register_device(&usbvision->vdev, VFL_TYPE_GRABBER, video_nr) < 0) {
+		printk(KERN_ERR "video_register_device() failed\n");
+		usbvision = NULL;
+	}
+	if (debug > 1)
+		printk(KERN_DEBUG "video_register_device() successful\n");
+
+	if (usbvision_device_data[model].Radio) {
+		usbvision->rdev.priv = usbvision;	
+		if (video_register_device(&usbvision->rdev, VFL_TYPE_RADIO, radio_nr) < 0) {
+			printk(KERN_ERR "video_register_device(radio) failed\n");
+			video_unregister_device(&usbvision->vdev);
+			usbvision = NULL;
+		}
+		if (debug > 1)
+			printk(KERN_DEBUG "video_register_device(radio) successful\n");
+	}
+
+	MOD_DEC_USE_COUNT;
+	return usbvision;
+}
+
+/*
+ * usbvision_release()
+ *
+ * This code does final release of struct usb_usbvision. This happens
+ * after the device is disconnected -and- all clients closed their files.
+ *
+ */
+static void usbvision_release(struct usb_usbvision *usbvision)
+{
+	if (usbvision_device_data[usbvision->DevModel].Radio) {
+		video_unregister_device(&usbvision->rdev);
+	}
+	video_unregister_device(&usbvision->vdev);
+
+	if (!PowerOnAtOpen) {
+		i2c_usb_del_bus(&usbvision->i2c_adap);
+		usbvision_power_off(usbvision);
+	}
+	
+	if (debug > 0)
+		printk(KERN_DEBUG
+		       "usb_usbvision_release: Video unregistered.\n");
+	usbvision->usbvision_used = 0;
+	usbvision->initialized = 0;
+}
+
+/*
+ * usbvision_disconnect()
+ *
+ * This procedure stops all driver activity, deallocates interface-private
+ * structure (pointed by 'ptr') and after that driver should be removable
+ * with no ill consequences.
+ *
+ */
+static void usbvision_disconnect(struct usb_device *dev, void *ptr)
+{
+	static const char proc[] = "usbvision_disconnect";
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) ptr;
+
+	MOD_INC_USE_COUNT;
+
+	if (debug > 0)
+		printk(KERN_DEBUG "%s(%p,%p.)\n", proc, dev, ptr);
+
+	down(&usbvision->lock);
+	usbvision->remove_pending = 1;	/* Now all ISO data will be ignored */
+
+	/* At this time we ask to cancel outstanding URBs */
+	usbvision_stop_isoc(usbvision);
+
+	usbvision->dev = NULL;	/* USB device is no more */
+
+	if (usbvision->user)
+		printk(KERN_INFO "%s: In use, disconnect pending.\n",
+		       proc);
+	else
+		usbvision_release(usbvision);
+	up(&usbvision->lock);
+	printk(KERN_INFO "USBVISION USB video disconnected.\n");
+
+	MOD_DEC_USE_COUNT;
+}
+
+MODULE_DEVICE_TABLE (usb, usbvision_table);
+
+static struct usb_driver usbvision_driver = {
+	name:		"USBVision Video Capture",
+	probe:		usbvision_probe,
+	disconnect:	usbvision_disconnect,
+	id_table:	usbvision_table
+};
+
+/*
+ * usbvision_init()
+ *
+ * This code is run to initialize the driver.
+ *
+ */
+static int __init usbvision_init(void)
+{
+	unsigned u;
+
+	/* Initialize struct */
+	for (u = 0; u < MAX_USBVISION; u++) {
+		struct usb_usbvision *usbvision = &vdevs[u];
+		memset(usbvision, 0, sizeof(struct usb_usbvision));
+	}
+	return usb_register(&usbvision_driver);
+}
+
+static void usbvision_cleanup(void)
+{
+	unsigned int dev_index;
+	
+	printk(KERN_DEBUG "usbvision_cleanup\n");
+
+	/* Power off devices */
+	for (dev_index = 0; dev_index < MAX_USBVISION; dev_index++) {
+		struct usb_usbvision *usbvision = &vdevs[dev_index];
+	if (!PowerOnAtOpen) usbvision_power_off(usbvision);
+	}
+	
+	usb_deregister(&usbvision_driver);
+}
+
+module_init(usbvision_init);
+module_exit(usbvision_cleanup);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -ruNp linux-2.4.20/drivers/usb/usbvision.h linux-2.4.20/drivers/usb.np/usbvision.h
--- linux-2.4.20/drivers/usb/usbvision.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb.np/usbvision.h	2003-04-16 03:54:10.000000000 +0200
@@ -0,0 +1,472 @@
+#ifndef __LINUX_USBVISION_H
+#define __LINUX_USBVISION_H
+
+#include <linux/list.h>
+
+#define USBVISION_PWR_REG		0x00
+	#define USBVISION_SSPND_EN		(1 << 1)
+	#define USBVISION_RES2			(1 << 2)
+	#define USBVISION_PWR_VID		(1 << 5)
+        #define USBVISION_E2_EN			(1 << 7)
+#define USBVISION_CONFIG_REG		0x01
+#define USBVISION_ADRS_REG		0x02
+#define USBVISION_ALTER_REG		0x03
+#define USBVISION_FORCE_ALTER_REG	0x04
+#define USBVISION_STATUS_REG		0x05
+#define USBVISION_IOPIN_REG		0x06
+	#define USBVISION_IO_1			(1 << 0)
+	#define USBVISION_IO_2			(1 << 1)
+	#define USBVISION_AUDIO_IN		0
+	#define USBVISION_AUDIO_TV		1
+	#define USBVISION_AUDIO_RADIO		2
+	#define USBVISION_AUDIO_MUTE		3
+#define USBVISION_SER_MODE		0x07
+#define USBVISION_SER_ADRS		0x08
+#define USBVISION_SER_CONT		0x09
+#define USBVISION_SER_DAT1		0x0A
+#define USBVISION_SER_DAT2		0x0B
+#define USBVISION_SER_DAT3		0x0C
+#define USBVISION_SER_DAT4		0x0D
+#define USBVISION_EE_DATA		0x0E
+#define USBVISION_EE_LSBAD		0x0F
+#define USBVISION_EE_CONT		0x10
+#define USBVISION_DRM_CONT			0x12
+	#define USBVISION_REF			(1 << 0)
+	#define USBVISION_RES_UR		(1 << 2)
+	#define USBVISION_RES_FDL		(1 << 3)
+	#define USBVISION_RES_VDW		(1 << 4)
+#define USBVISION_DRM_PRM1		0x13
+#define USBVISION_DRM_PRM2		0x14
+#define USBVISION_DRM_PRM3		0x15
+#define USBVISION_DRM_PRM4		0x16
+#define USBVISION_DRM_PRM5		0x17
+#define USBVISION_DRM_PRM6		0x18
+#define USBVISION_DRM_PRM7		0x19
+#define USBVISION_DRM_PRM8		0x1A
+#define USBVISION_VIN_REG1		0x1B
+	#define USBVISION_8_422_SYNC		0x01
+	#define USBVISION_16_422_SYNC		0x02
+	#define USBVISION_VSNC_POL		(1 << 3)
+	#define USBVISION_HSNC_POL		(1 << 4)
+	#define USBVISION_FID_POL		(1 << 5)
+	#define USBVISION_HVALID_PO		(1 << 6)
+	#define USBVISION_VCLK_POL		(1 << 7)
+#define USBVISION_VIN_REG2		0x1C
+	#define USBVISION_AUTO_FID		(1 << 0)
+	#define USBVISION_NONE_INTER		(1 << 1)
+	#define USBVISION_NOHVALID		(1 << 2)
+	#define USBVISION_UV_ID			(1 << 3)
+	#define USBVISION_FIX_2C		(1 << 4)
+	#define USBVISION_SEND_FID		(1 << 5)
+	#define USBVISION_KEEP_BLANK		(1 << 7)
+#define USBVISION_LXSIZE_I		0x1D
+#define USBVISION_MXSIZE_I		0x1E
+#define USBVISION_LYSIZE_I		0x1F
+#define USBVISION_MYSIZE_I		0x20
+#define USBVISION_LX_OFFST		0x21
+#define USBVISION_MX_OFFST		0x22
+#define USBVISION_LY_OFFST		0x23
+#define USBVISION_MY_OFFST		0x24
+#define USBVISION_FRM_RATE		0x25
+#define USBVISION_LXSIZE_O		0x26
+#define USBVISION_MXSIZE_O		0x27
+#define USBVISION_LYSIZE_O		0x28
+#define USBVISION_MYSIZE_O		0x29
+#define USBVISION_FILT_CONT		0x2A
+#define USBVISION_VO_MODE		0x2B
+#define USBVISION_INTRA_CYC		0x2C
+#define USBVISION_STRIP_SZ		0x2D
+#define USBVISION_FORCE_INTRA		0x2E
+#define USBVISION_FORCE_UP		0x2F
+#define USBVISION_BUF_THR		0x30
+#define USBVISION_DVI_YUV		0x31
+#define USBVISION_PCM_THR1		0x38
+#define USBVISION_PCM_THR2		0x39
+#define USBVISION_DIST_THR_L		0x3A
+#define USBVISION_DIST_THR_H		0x3B
+#define USBVISION_MAX_DIST_L		0x3C
+#define USBVISION_MAX_DIST_H		0x3D
+#define USBVISION_OP_CODE		0x33
+
+#define MAX_BYTES_PER_PIXEL     	4
+
+#define MIN_FRAME_WIDTH			64
+#define MAX_USB_WIDTH			320
+#define MAX_FRAME_WIDTH			384			/*streching sometimes causes crashes*/
+
+#define MIN_FRAME_HEIGHT		48
+#define MAX_USB_HEIGHT			240
+#define MAX_FRAME_HEIGHT		288			/*Streching sometimes causes crashes*/
+
+#define MAX_WIDTH_STRETCH		(MAX_FRAME_WIDTH / MAX_USB_WIDTH)
+#define MAX_HEIGHT_STRETCH		(MAX_FRAME_HEIGHT / MAX_USB_HEIGHT)
+#define MAX_FRAME_SIZE     		(MAX_FRAME_WIDTH * MAX_FRAME_HEIGHT * MAX_BYTES_PER_PIXEL)
+#define USBVISION_CLIPMASK_SIZE		(MAX_FRAME_WIDTH *MAX_FRAME_HEIGHT / 8) //bytesize of clipmask
+
+#define USBVISION_URB_FRAMES       	32
+#define USBVISION_MAX_ISO_PACKET   	1023			/*SAA7111A Specs Document say 1023*/
+
+#define USBVISION_NUM_HEADERMARKER	20
+#define USBVISION_NUMFRAMES		2
+#define USBVISION_NUMSBUF		2
+
+#define FRAMES_PER_DESC			(USBVISION_URB_FRAMES)
+#define FRAME_SIZE_PER_DESC		(USBVISION_MAX_ISO_PACKET)
+
+/* This macro restricts an int variable to an inclusive range */
+#define RESTRICT_TO_RANGE(v,mi,ma) { if ((v) < (mi)) (v) = (mi); else if ((v) > (ma)) (v) = (ma); }
+
+#if 0
+/*
+ * This macro performs bounds checking - use it when working with
+ * new formats, or else you may get oopses all over the place.
+ * If pixel falls out of bounds then it gets shoved back (as close
+ * to place of offence as possible) and is painted bright red.
+ */
+#define USBVISION_PUTPIXEL(fr, ix, iy, vr, vg, vb) { \
+	register unsigned char *pf; \
+	int limiter = 0, mx, my; \
+	mx = ix; \
+	my = iy; \
+	if (mx < 0) { \
+		mx=0; \
+		limiter++; \
+	} else if (mx >= 352) { \
+		mx=351; \
+		limiter++; \
+	} \
+	if (my < 0) { \
+		my = 0; \
+		limiter++; \
+	} else if (my >= V4L_FRAME_HEIGHT) { \
+		my = V4L_FRAME_HEIGHT - 1; \
+		limiter++; \
+	} \
+	pf = (fr)->data + V4L_BYTES_PER_PIXEL*((iy)*352 + (ix)); \
+	if (limiter) { \
+		*pf++ = 0; \
+		*pf++ = 0; \
+		*pf++ = 0xFF; \
+	} else { \
+		*pf++ = (vb); \
+		*pf++ = (vg); \
+		*pf++ = (vr); \
+	} \
+}
+#endif
+
+/*
+ * We use macros to do YUV -> RGB conversion because this is
+ * very important for speed and totally unimportant for size.
+ *
+ * YUV -> RGB Conversion
+ * ---------------------
+ *
+ * B = 1.164*(Y-16)		    + 2.018*(V-128)
+ * G = 1.164*(Y-16) - 0.813*(U-128) - 0.391*(V-128)
+ * R = 1.164*(Y-16) + 1.596*(U-128)
+ *
+ * If you fancy integer arithmetics (as you should), hear this:
+ *
+ * 65536*B = 76284*(Y-16)		  + 132252*(V-128)
+ * 65536*G = 76284*(Y-16) -  53281*(U-128) -  25625*(V-128)
+ * 65536*R = 76284*(Y-16) + 104595*(U-128)
+ *
+ * Make sure the output values are within [0..255] range.
+ */
+#define LIMIT_RGB(x) (((x) <= 0) ? 1 : (((x) > 255) ? 255 : (x)))
+#define YUV_TO_RGB_BY_THE_BOOK(my,mu,mv,mr,mg,mb) { \
+    int mm_y, mm_yc, mm_u, mm_v, mm_r, mm_g, mm_b; \
+    mm_y = (my) - 16;  \
+    mm_u = (mu) - 128; \
+    mm_v = (mv) - 128; \
+    mm_yc= mm_y * 76284; \
+    mm_b = (mm_yc		+ 132252*mm_v	) >> 16; \
+    mm_g = (mm_yc -  53281*mm_u -  25625*mm_v	) >> 16; \
+    mm_r = (mm_yc + 104595*mm_u			) >> 16; \
+    mb = LIMIT_RGB(mm_b); \
+    mg = LIMIT_RGB(mm_g); \
+    mr = LIMIT_RGB(mm_r); \
+}
+
+/* Debugging aid */
+#define USBVISION_SAY_AND_WAIT(what) { \
+	wait_queue_head_t wq; \
+	init_waitqueue_head(&wq); \
+	printk(KERN_INFO "Say: %s\n", what); \
+	interruptible_sleep_on_timeout (&wq, HZ*3); \
+}
+
+/*
+ * This macro checks if usbvision is still operational. The 'usbvision'
+ * pointer must be valid, usbvision->dev must be valid, we are not
+ * removing the device and the device has not erred on us.
+ */
+#define USBVISION_IS_OPERATIONAL(udevice) (\
+	(udevice != NULL) && \
+	((udevice)->dev != NULL) && \
+	((udevice)->last_error == 0) && \
+	(!(udevice)->remove_pending))
+
+enum {
+	STATE_SCANNING,		/* Scanning for header */
+	STATE_LINES,		/* Parsing lines */
+};
+
+enum {
+	FRAME_UNUSED,		/* Unused (no MCAPTURE) */
+	FRAME_READY,		/* Ready to start grabbing */
+	FRAME_GRABBING,		/* In the process of being grabbed into */
+	FRAME_DONE,		/* Finished grabbing, but not been synced yet */
+	FRAME_ERROR,		/* Something bad happened while processing */
+};
+
+enum {
+	ISOC_INFRAME,		/* Isoc packet is member of frame */
+	ISOC_NOFRAME,		/* Isoc packet is not member of any frame */
+};
+
+struct usb_device;
+
+struct usbvision_sbuf {
+	char *data;
+	struct urb *urb;
+};
+
+#define USBVISION_MAGIC_1      		0xAA
+#define USBVISION_MAGIC_2      		0x55
+#define USBVISION_MAGIC		  	0xAA55
+#define USBVISION_HEADER_LENGTH		0x0c
+#define USBVISION_SAA7111_ADDR		0x48
+#define USBVISION_SAA7113_ADDR		0x4a
+#define USBVISION_BT819_ADDR		0x89
+#define USBVISION_IIC_LRACK		0x20
+#define USBVISION_IIC_LRNACK		0x30
+
+#define USBVISION_FRAME_FORMAT_PARAM_INTRA	(1<<7)
+
+struct usbvision_frame_header {
+	unsigned short vid_frm_patt;			/* 0 - 1  magic */
+	unsigned char header_length;			/* 2 */
+	unsigned char frame_numb;			/* 3 */
+	unsigned char frame_phase;			/* 4 */
+	unsigned char frame_latency;			/* 5 */
+	unsigned char data_format;			/* 6 */
+	unsigned char format_param;			/* 7 */
+	__u16 frame_width;				/* 8 - 9 */
+	__u16 frame_height;				/* 10 - 11 */
+};
+
+struct usbvision_regvals {
+	unsigned char reg;
+	unsigned char value;
+};
+
+struct usbvision_frame {
+	char *data;					/* Frame buffer */
+	struct usbvision_frame_header usb_header;	/* Header from stream */
+
+	int width;					/* Width application is expecting */
+	int height;					/* Height */
+
+	int frmwidth;					/* Width the frame actually is */
+	int frmheight;					/* Height */
+
+	volatile int grabstate;				/* State of grabbing */
+	int scanstate;					/* State of scanning */
+
+	int curline;					/* Line of frame we're working on */
+
+	long scanlength;				/* uncompressed, raw data length of frame */
+	long bytes_read;				/* amount of scanlength that has been read from data */
+	int v4l_format;					/* format the user needs*/
+	int v4l_linesize;				/* bytes for one videoline*/
+
+	wait_queue_head_t wq;				/* Processes waiting */
+};
+
+#define CODEC_SAA7113	7113
+#define CODEC_SAA7111	7111
+#define CODEC_BT819	819
+
+
+/* Supported Devices: A table for usbvision.c*/
+
+static struct usbvision_device_data_st {
+	int idVendor;
+	int idProduct;
+        int Interface;					/* to handle special interface number like BELKIN and Hauppauge WinTV-USB II */
+	int Codec;
+	int VideoChannels;
+	int VideoNorm;
+	int AudioChannels;
+	int Radio;
+	int Tuner;
+	int TunerType;
+        int Vin_Reg1;
+        int Vin_Reg2;
+        int X_Offset;
+        int Y_Offset;
+        int Dvi_yuv;
+	char *ModelString;
+} usbvision_device_data[] = {
+        {0x050D, 0x0208,  0, CODEC_SAA7113, 2, VIDEO_MODE_NTSC,  1, 0, 0, 0,                        -1, -1, -1, -1, -1, "Belkin USBView II"},
+	{0x0573, 0x0003, -1, CODEC_SAA7111, 2, VIDEO_MODE_NTSC,  1, 0, 0, 0,                        -1, -1, -1, -1, -1, "USBGear USBG-V1 resp. HAMA USB"},
+	{0x0573, 0x2000, -1, CODEC_SAA7111, 2, VIDEO_MODE_NTSC,  1, 0, 0, 0,                        -1, -1, -1, 20, -1, "X10 USB Camera"},
+        {0x0573, 0x4100, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 1, 1, 0,                        -1, -1, -1, 20, -1, "Nogatech USB-TV FM (NTSC)"},
+	{0x0573, 0x4D00, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 0, 1, 0,                        -1, -1, -1, 20, -1, "Hauppauge WinTv-USB USA"},
+	{0x0573, 0x4D01, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 0, 1, 0,                        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB"},
+	{0x0573, 0x4D02, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 0, 1, 0,                        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB UK"},
+	{0x0573, 0x4D03, -1, CODEC_SAA7111, 3, VIDEO_MODE_SECAM, 1, 0, 1, 0,                        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB France"},
+	{0x0573, 0x4D10, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 1, 1, 0,                        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB FM USA"},
+	{0x0573, 0x4D11, -1, CODEC_SAA7111, 3, VIDEO_MODE_PAL,   1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB (PAL) FM"},
+	{0x0573, 0x4D12, -1, CODEC_SAA7111, 3, VIDEO_MODE_PAL,   1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB UK FM"},
+	{0x0573, 0x4D20,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB II (PAL) FM"},
+	{0x0573, 0x4D21,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 0, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB II (PAL)"},
+	{0x0573, 0x4D22,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 0, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB II (PAL) MODEL 566"},
+	{0x0573, 0x4D23, -1, CODEC_SAA7113, 3, VIDEO_MODE_SECAM, 1, 0, 1, TUNER_PHILIPS_SECAM,      -1, -1, -1, -1, -1, "Hauppauge WinTv-USB France 4D23"},
+	{0x0573, 0x4D30, -1, CODEC_SAA7113, 3, VIDEO_MODE_NTSC,  1, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1, -1, -1, -1, "Hauppauge WinTv-USB FM USA Model 621"},
+	{0x0573, 0x4D31,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB III (PAL) FM Model 568"},
+	{0x2304, 0x0109, -1, CODEC_SAA7111, 3, VIDEO_MODE_SECAM, 1, 0, 1, TUNER_PHILIPS_SECAM,      -1, -1, -1, -1, -1, "Pinnacle Studio PCTV USB (SECAM)"},
+	{0x2304, 0x0111, -1, CODEC_SAA7111, 3, VIDEO_MODE_PAL,   1, 0, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Miro PCTV USB"},
+	{0x2304, 0x0112, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1, -1, -1, -1, "Pinnacle Studio PCTV USB (NTSC) FM"},
+	{0x2304, 0x0210, -1, CODEC_SAA7111, 3, VIDEO_MODE_PAL,   1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Pinnacle Studio PCTV USB (PAL) FM"},
+	{0x2304, 0x0212, -1, CODEC_SAA7113, 3, VIDEO_MODE_NTSC,  1, 0, 1, TUNER_TEMIC_4039FR5_NTSC, -1, -1, -1, -1, -1, "Pinnacle Studio PCTV USB (NTSC)"},
+	{0x2304, 0x0300, -1, CODEC_SAA7113, 2, VIDEO_MODE_NTSC,  1, 0, 0, 0,                        -1, -1,  0,  3,  7, "Pinnacle Studio Linx Video input cable (NTSC)"},
+	{ }  /* Terminating entry */
+};
+
+
+/* Supported Devices: A table for the usb.c*/
+
+static struct usb_device_id usbvision_table [] = {
+	{ USB_DEVICE(0x050d, 0x0208) },  /* Belkin USBView II */
+	{ USB_DEVICE(0x0573, 0x0003) },  /* USBGear USBG-V1 */
+	{ USB_DEVICE(0x0573, 0x2000) },  /* X10 USB Camera */
+        { USB_DEVICE(0x0573, 0x4100) },  /* Nogatech USB-TV FM (NTSC) */
+	{ USB_DEVICE(0x0573, 0x4d00) },  /* Hauppauge WINTV-USB USA */
+	{ USB_DEVICE(0x0573, 0x4d01) },  /* Hauppauge WINTV-USB */
+	{ USB_DEVICE(0x0573, 0x4d02) },  /* Hauppauge WINTV-USB UK */
+	{ USB_DEVICE(0x0573, 0x4d03) },  /* Hauppauge WINTV-USB France */
+	{ USB_DEVICE(0x0573, 0x4d10) },  /* Hauppauge WINTV-USB with FM USA radio */
+	{ USB_DEVICE(0x0573, 0x4d11) },  /* Hauppauge WINTV-USB (PAL) with FM radio */
+        { USB_DEVICE(0x0573, 0x4d12) },  /* Hauppauge WINTV-USB UK with FM Radio */
+	{ USB_DEVICE(0x0573, 0x4d20) },  /* Hauppauge WINTV-USB II (PAL) with FM radio */
+	{ USB_DEVICE(0x0573, 0x4d21) },  /* Hauppauge WINTV-USB II (PAL) */
+        { USB_DEVICE(0x0573, 0x4d22) },  /* Hauppauge WINTV-USB II (PAL) Model 566 */
+	{ USB_DEVICE(0x0573, 0x4d23) },  /* Hauppauge WINTV-USB France 4D23*/
+	{ USB_DEVICE(0x0573, 0x4d30) },  /* Hauppauge WINTV-USB with FM USA radio Model 602*/
+	{ USB_DEVICE(0x0573, 0x4d31) },  /* Hauppauge WINTV-USB III (PAL) with FM radio Model 568*/
+        { USB_DEVICE(0x2304, 0x0109) },  /* Pinnacle Studio PCTV USB (SECAM) */
+	{ USB_DEVICE(0x2304, 0x0111) },  /* Miro PCTV USB */
+	{ USB_DEVICE(0x2304, 0x0112) },  /* Pinnacle Studio PCTV USB (NTSC) with FM radio*/
+	{ USB_DEVICE(0x2304, 0x0210) },  /* Pinnacle Studio PCTV USB (PAL) with FM radio*/
+	{ USB_DEVICE(0x2304, 0x0212) },  /* Pinnacle Studio PCTV USB (NTSC)*/
+	{ USB_DEVICE(0x2304, 0x0300) },  /* Pinnacle Studio Linx Video input cable (NTSC)*/ 
+	{ }  /* Terminating entry */
+};
+
+
+#define I2C_CLIENTS_MAX		8
+
+struct usb_usbvision {
+	struct video_device vdev;         				/* Video Device */
+        struct video_device rdev;               			/* Radio Device */
+	struct video_audio audio_dev;	        			/* Current audio params */
+
+	/* i2c Decloration Section*/
+	struct i2c_adapter i2c_adap;
+	struct i2c_algo_usb_data i2c_algo;
+	struct i2c_client i2c_client;
+	int i2c_state, i2c_ok;
+	struct i2c_client *i2c_clients[I2C_CLIENTS_MAX];
+	int have_tuner;
+	int tuner_type;
+	int channel;
+	int radio;
+	int video_inputs;						/* # of inputs */
+	unsigned long freq;
+	int AudioMute;
+	int AudioChannel;
+	int videoformat;						/*format of video data for the usb isoc-transfer*/
+	unsigned int nr;						/* Number of the device < MAX_USBVISION */
+
+	/* Device structure */
+	struct usb_device *dev;
+	unsigned char iface;						/* Video interface number */
+	unsigned char ifaceAltActive, ifaceAltInactive;			/* Alt settings */
+	struct semaphore lock;
+	int user;							/* user count for exclusive use */
+	int usbvision_used;						/* Is this structure in use? */
+	int initialized;						/* Had we already sent init sequence? */
+	int DevModel;							/* What type of USBVISION device we got? */
+	int streaming;							/* Are we streaming Isochronous? */
+	int grabbing;							/* Are we grabbing? */
+	int last_error;							/* What calamity struck us? */
+	int curwidth;							/* width of the frame the device is currently set to*/
+	int curheight;      						/* height of the frame the device is currently set to*/
+	int stretch_width;						/* stretch-factor for frame width (from usb to screen)*/
+	int stretch_height;						/* stretch-factor for frame height (from usb to screen)*/
+	char *fbuf;							/* Videodev buffer area for mmap*/
+	int fbuf_size;							/* Videodev buffer size */
+	int curframe;							/* Device current frame*/
+	struct usbvision_frame frame[USBVISION_NUMFRAMES];		/* Double buffering */
+	int cursbuf;							/* Current receiving sbuf */
+	struct usbvision_sbuf sbuf[USBVISION_NUMSBUF];			/* Double buffering */
+	volatile int remove_pending;					/* If set then about to exit */
+
+	/* Scratch space from the Isochronous Pipe.*/
+	unsigned char *scratch;
+	int scratch_read_ptr;
+	int scratch_write_ptr;
+	int scratch_headermarker[USBVISION_NUM_HEADERMARKER];
+	int scratch_headermarker_read_ptr;
+	int scratch_headermarker_write_ptr;
+	int isocstate;
+	struct video_picture vpic;					/* Picture settings */
+	struct video_capability vcap;					/* Video capabilities */
+	struct video_channel vchan;					/* May be used for tuner support */
+	unsigned char video_endp;					/* 0x82 for USBVISION devices based */
+	int has_hdr;
+	int frame_num;
+	int iso_packet_len;						/* Videomode-dependent, saves bus bandwidth */
+
+	/* OVERLAY stuff */
+	struct video_buffer vid_buf;
+	struct video_window vid_win;
+	int	overlay;						/*Status: Are we overlaying? */
+	unsigned int 	clipmask[USBVISION_CLIPMASK_SIZE / 4];
+	unsigned char   *overlay_base;					/* Virtual base address of video buffer */
+	unsigned char   *overlay_win;					/* virt start address of overlay window */
+	struct usbvision_frame overlay_frame;
+
+	/* Statistics that can be overlayed on the screen */
+	unsigned long urb_count;					/* How many URBs we received so far */
+	unsigned long urb_length;					/* Length of last URB */
+	unsigned long data_count;					/* How many bytes we received */
+	unsigned long header_count;					/* How many frame headers we found */
+	unsigned long scratch_ovf_count;				/* How many times we overflowed scratch */
+	unsigned long iso_skip_count;					/* How many empty ISO packets received */
+	unsigned long iso_err_count;					/* How many bad ISO packets received */
+};
+
+static struct usbvision_v4l_format_st {
+    int           supported;
+    int	          bytes_per_pixel;
+    int           depth;
+    int           format;
+} usbvision_v4l_format[] = {
+    { 0 },
+    { 0, 1,  8, VIDEO_PALETTE_GREY   },
+    { 0, 0,  0, VIDEO_PALETTE_HI240  },
+    { 1, 2, 16, VIDEO_PALETTE_RGB565 },
+    { 1, 3, 24, VIDEO_PALETTE_RGB24  },
+    { 1, 4, 32, VIDEO_PALETTE_RGB32  },
+    { 1, 2, 16, VIDEO_PALETTE_RGB555 },
+    { 0 /* END OF LIST */ },
+};
+#define USBVISION_SUPPORTED_PALETTES 7
+
+#endif									/* __LINUX_USBVISION_H */
+
+
