--- linux-2.4.22/kernel/sysctl.c.cc25.orig	2003-08-28 03:03:56.000000000 +0200
+++ linux-2.4.22/kernel/sysctl.c	2003-08-28 03:07:06.000000000 +0200
@@ -284,6 +284,8 @@ static ctl_table vm_table[] = {
 	 &vm_cache_scan_ratio, sizeof(int), 0644, NULL, &proc_dointvec},
 	{VM_MAPPED_RATIO, "vm_mapped_ratio", 
 	 &vm_mapped_ratio, sizeof(int), 0644, NULL, &proc_dointvec},
+	{VM_ANON_LRU, "vm_anon_lru", 
+	 &vm_anon_lru, sizeof(int), 0644, NULL, &proc_dointvec},
 	{VM_LRU_BALANCE_RATIO, "vm_lru_balance_ratio", 
 	 &vm_lru_balance_ratio, sizeof(int), 0644, NULL, &proc_dointvec},
 	{VM_PASSES, "vm_passes", 
--- linux-2.4.22/mm/memory.c.cc25.orig	2003-08-28 03:05:52.000000000 +0200
+++ linux-2.4.22/mm/memory.c	2003-08-28 03:07:06.000000000 +0200
@@ -993,7 +993,8 @@ static int do_wp_page(struct mm_struct *
 		if (PageReserved(old_page))
 			++mm->rss;
 		break_cow(vma, new_page, address, page_table);
-		lru_cache_add(new_page);
+		if (vm_anon_lru)
+			lru_cache_add(new_page);
 
 		/* Free the old page.. */
 		new_page = old_page;
@@ -1222,7 +1223,8 @@ static int do_anonymous_page(struct mm_s
 		mm->rss++;
 		flush_page_to_ram(page);
 		entry = pte_mkwrite(pte_mkdirty(mk_pte(page, vma->vm_page_prot)));
-		lru_cache_add(page);
+		if (vm_anon_lru)
+			lru_cache_add(page);
 	}
 
 	set_pte(page_table, entry);
@@ -1276,7 +1278,8 @@ static int do_no_page(struct mm_struct *
 		}
 		copy_user_highpage(page, new_page, address);
 		page_cache_release(new_page);
-		lru_cache_add(page);
+		if (vm_anon_lru)
+			lru_cache_add(page);
 		new_page = page;
 	}
 
--- linux-2.4.22/mm/vmscan.c.cc25.orig	2003-08-28 03:05:52.000000000 +0200
+++ linux-2.4.22/mm/vmscan.c	2003-08-28 03:07:06.000000000 +0200
@@ -66,6 +66,27 @@ int vm_lru_balance_ratio = 2;
 int vm_vfs_scan_ratio = 6;
 
 /*
+ * "vm_anon_lru" select if to immdiatly insert anon pages in the
+ * lru. Immediatly means as soon as they're allocated during the
+ * page faults.
+ *
+ * If this is set to 0, they're inserted only after the first
+ * swapout.
+ *
+ * Having anon pages immediatly inserted in the lru allows the
+ * VM to know better when it's worthwhile to start swapping
+ * anonymous ram, it will start to swap earlier and it should
+ * swap smoother and faster, but it will decrease scalability
+ * on the >16-ways of an order of magnitude. Big SMP/NUMA
+ * definitely can't take an hit on a global spinlock at
+ * every anon page allocation. So this is off by default.
+ *
+ * Low ram machines that swaps all the time want to turn
+ * this on (i.e. set to 1).
+ */
+int vm_anon_lru = 0;
+
+/*
  * The swap-out function returns 1 if it successfully
  * scanned all the pages it was asked to (`count').
  * It returns zero if it couldn't do anything,
--- linux-2.4.22/include/linux/swap.h.cc25.orig	2003-08-28 03:05:52.000000000 +0200
+++ linux-2.4.22/include/linux/swap.h	2003-08-28 03:07:06.000000000 +0200
@@ -115,7 +115,7 @@ extern void swap_setup(void);
 extern wait_queue_head_t kswapd_wait;
 extern int FASTCALL(try_to_free_pages_zone(zone_t *, unsigned int));
 extern int FASTCALL(try_to_free_pages(unsigned int));
-extern int vm_vfs_scan_ratio, vm_cache_scan_ratio, vm_lru_balance_ratio, vm_passes, vm_gfp_debug, vm_mapped_ratio;
+extern int vm_vfs_scan_ratio, vm_cache_scan_ratio, vm_lru_balance_ratio, vm_passes, vm_gfp_debug, vm_mapped_ratio, vm_anon_lru;
 
 /* linux/mm/page_io.c */
 extern void rw_swap_page(int, struct page *);
--- linux-2.4.22/include/linux/sysctl.h.cc25.orig	2003-08-28 03:06:59.000000000 +0200
+++ linux-2.4.22/include/linux/sysctl.h	2003-08-28 03:08:11.000000000 +0200
@@ -157,6 +157,7 @@ enum
 	VM_GFP_DEBUG=22,	/* debug GFP failures */
 	VM_CACHE_SCAN_RATIO=23,	/* part of the inactive cache list to scan */
 	VM_MAPPED_RATIO=24,	/* amount of unfreeable pages that triggers swapout */
+	VM_ANON_LRU=25,		/* immediatly insert anon pages in the vm page lru */
 };
 
 
