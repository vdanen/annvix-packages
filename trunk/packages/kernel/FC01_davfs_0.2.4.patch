diff -ruN linux/fs.orig/Config.in linux/fs/Config.in
--- linux/fs.orig/Config.in	2002-07-22 16:50:53.000000000 +0200
+++ linux/fs/Config.in	2002-07-22 17:24:01.000000000 +0200
@@ -147,6 +148,9 @@
       # for fs/nls/Config.in
       define_bool CONFIG_NCPFS_NLS n
    fi
+
+   dep_tristate 'DAV file system support (Web-based Distributed Authoring and Versioning)' CONFIG_DAV_FS $CONFIG_INET
+
    endmenu
 
 else
diff -ruN linux/fs.orig/davfs/cache.c linux/fs/davfs/cache.c
--- linux/fs.orig/davfs/cache.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/cache.c	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,235 @@
+/*
+ *  cache.c
+ *
+ * Copyright (C) 1997 by Bill Hawes
+ *
+ * Routines to support directory cacheing using the page cache.
+ * This cache code is almost directly taken from ncpfs.
+ *
+ * Please add a note about your changes to davfs in the ChangeLog file.
+ */
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/dirent.h>
+#include <linux/pagemap.h>
+#include <linux/smp_lock.h>
+
+#include <asm/page.h>
+
+#include "davfs.h"
+#include "dav_debug.h"
+
+/*
+ * Force the next attempt to use the cache to be a timeout.
+ * If we can't find the page that's fine, it will cause a refresh.
+ */
+void
+dav_invalid_dir_cache(struct inode * dir)
+{
+	struct dav_sb_info *server = dav_server_from_inode(dir);
+	union  dav_dir_cache *cache = NULL;
+	struct page *page = NULL;
+
+	TRACE();
+
+	page = grab_cache_page(&dir->i_data, 0);
+	if (!page)
+		goto out;
+
+	if (!Page_Uptodate(page))
+		goto out_unlock;
+
+	cache = kmap(page);
+	cache->head.time = jiffies - DAV_MAX_AGE(server);
+
+	kunmap(page);
+	SetPageUptodate(page);
+out_unlock:
+	UnlockPage(page);
+	page_cache_release(page);
+out:
+	return;
+}
+
+/*
+ * Mark all dentries for 'parent' as invalid, forcing them to be re-read
+ */
+void
+dav_invalidate_dircache_entries(struct dentry *parent)
+{
+	struct dav_sb_info *server = dav_server_from_dentry(parent);
+	struct list_head *next;
+	struct dentry *dentry;
+
+	TRACE();
+
+	spin_lock(&dcache_lock);
+	next = parent->d_subdirs.next;
+	while (next != &parent->d_subdirs) {
+		dentry = list_entry(next, struct dentry, d_child);
+		dentry->d_fsdata = NULL;
+		dav_age_dentry(server, dentry);
+		next = next->next;
+	}
+	spin_unlock(&dcache_lock);
+}
+
+/*
+ * dget, but require that fpos and parent matches what the dentry contains.
+ * dentry is not known to be a valid pointer at entry.
+ */
+struct dentry *
+dav_dget_fpos(struct dentry *dentry, struct dentry *parent, unsigned long fpos)
+{
+	struct dentry *dent = dentry;
+	struct list_head *next;
+
+	TRACE();
+
+	/*
+	** kernel 2.4.2 or too few arg error
+	** use this function 
+	*/
+ 	/*
+	  if (d_validate(dent, dent->d_parent, dent->d_name.hash, dent->d_name.len)) { 
+	*/
+
+	if (d_validate(dent, parent)) {
+		if (dent->d_name.len <= DAV_MAXPATHLEN &&
+		    (unsigned long)dent->d_fsdata == fpos) {
+			if (!dent->d_inode) {
+				dput(dent);
+				dent = NULL;
+			}
+			return dent;
+		}
+		dput(dent);
+	}
+
+	/* If a pointer is invalid, we search the dentry. */
+	spin_lock(&dcache_lock);
+	next = parent->d_subdirs.next;
+	while (next != &parent->d_subdirs) {
+		dent = list_entry(next, struct dentry, d_child);
+		if ((unsigned long)dent->d_fsdata == fpos) {
+			if (dent->d_inode)
+				dget_locked(dent);
+			else
+				dent = NULL;
+			goto out_unlock;
+		}
+		next = next->next;
+	}
+	dent = NULL;
+out_unlock:
+	spin_unlock(&dcache_lock);
+	return dent;
+}
+
+
+/*
+ * Create dentry/inode for this file and add it to the dircache.
+ */
+int
+dav_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
+	       struct dav_cache_control *ctrl, struct qstr *qname,
+	       struct dav_fattr *entry)
+{
+	struct dentry *newdent, *dentry = filp->f_dentry;
+	struct inode *newino, *inode = dentry->d_inode;
+	struct dav_cache_control ctl = *ctrl;
+	int valid = 0;
+	int hashed = 0;
+	ino_t ino = 0;
+
+	TRACE();
+
+	qname->hash = full_name_hash(qname->name, qname->len);
+
+	if (dentry->d_op && dentry->d_op->d_hash)
+		if (dentry->d_op->d_hash(dentry, qname) != 0)
+			goto end_advance;
+
+	newdent = d_lookup(dentry, qname);
+
+	if (!newdent) {
+		newdent = d_alloc(dentry, qname);
+		if (!newdent)
+			goto end_advance;
+	} else {
+		hashed = 1;
+		memcpy((char *) newdent->d_name.name, qname->name,
+		       newdent->d_name.len);
+	}
+
+	if (!newdent->d_inode) {
+		dav_renew_times(newdent);
+		entry->f_ino = iunique(inode->i_sb, 2);
+		newino = dav_iget(inode->i_sb, entry);
+		if (newino) {
+			dav_new_dentry(newdent);
+			d_instantiate(newdent, newino);
+			if (!hashed)
+				d_rehash(newdent);
+		}
+	} else
+		dav_set_inode_attr(newdent->d_inode, entry);
+
+        if (newdent->d_inode) {
+		ino = newdent->d_inode->i_ino;
+		newdent->d_fsdata = (void *) ctl.fpos;
+		dav_new_dentry(newdent);
+	}
+
+	if (ctl.idx >= DAV_DIRCACHE_SIZE) {
+		if (ctl.page) {
+			kunmap(ctl.page);
+			SetPageUptodate(ctl.page);
+			UnlockPage(ctl.page);
+			page_cache_release(ctl.page);
+		}
+		ctl.cache = NULL;
+		ctl.idx  -= DAV_DIRCACHE_SIZE;
+		ctl.ofs  += 1;
+		ctl.page  = grab_cache_page(&inode->i_data, ctl.ofs);
+		if (ctl.page)
+			ctl.cache = kmap(ctl.page);
+	}
+	if (ctl.cache) {
+		ctl.cache->dentry[ctl.idx] = newdent;
+		valid = 1;
+	}
+	dput(newdent);
+
+end_advance:
+	if (!valid)
+		ctl.valid = 0;
+	if (!ctl.filled && (ctl.fpos == filp->f_pos)) {
+		if (!ino)
+			ino = find_inode_number(dentry, qname);
+		if (!ino)
+			ino = iunique(inode->i_sb, 2);
+		ctl.filled = filldir(dirent, qname->name, qname->len,
+				     filp->f_pos, ino, DT_UNKNOWN);
+		if (!ctl.filled)
+			filp->f_pos += 1;
+	}
+	ctl.fpos += 1;
+	ctl.idx  += 1;
+	*ctrl = ctl;
+	return (ctl.valid || !ctl.filled);
+}
+
+
+
+
+
+
+
+
+
+
+
diff -ruN linux/fs.orig/davfs/config.h linux/fs/davfs/config.h
--- linux/fs.orig/davfs/config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/config.h	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,134 @@
+/* config.h.  Generated automatically by configure.  */
+/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+#ifndef __PVFS_AUTOCONFIG_H
+#define __PVFS_AUTOCONFIG_H
+/* from config.h.top */
+
+/* Define to empty if the keyword does not work.  */
+/* #undef const */
+
+/* Define as __inline if that's what the C compiler calls it.  */
+/* #undef inline */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
+/* #undef size_t */
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS 1
+
+/* Define if you can safely include both <sys/time.h> and <time.h>.  */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define if you have the select function.  */
+#define HAVE_SELECT 1
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <linux/devfs_fs_kernel.h> header file.  */
+#define HAVE_LINUX_DEVFS_FS_KERNEL_H 1
+
+/* Define if you have the <linux/highmem.h> header file.  */
+#define HAVE_LINUX_HIGHMEM_H 1
+
+/* Define if you have the <linux/iobuf.h> header file.  */
+#define HAVE_LINUX_IOBUF_H 1
+
+/* Define if you have the <linux/locks.h> header file.  */
+#define HAVE_LINUX_LOCKS_H 1
+
+/* Define if you have the <linux/pagemap.h> header file.  */
+#define HAVE_LINUX_PAGEMAP_H 1
+
+/* Define if you have the <linux/posix_types.h> header file.  */
+#define HAVE_LINUX_POSIX_TYPES_H 1
+
+/* Define if you have the <linux/sched.h> header file.  */
+#define HAVE_LINUX_SCHED_H 1
+
+/* Define if you have the <linux/slab.h> header file.  */
+#define HAVE_LINUX_SLAB_H 1
+
+/* Define if you have the <linux/smp_lock.h> header file.  */
+#define HAVE_LINUX_SMP_LOCK_H 1
+
+/* Define if you have the <linux/tqueue.h> header file.  */
+#define HAVE_LINUX_TQUEUE_H 1
+
+/* Define if you have the <linux/vmalloc.h> header file.  */
+#define HAVE_LINUX_VMALLOC_H 1
+
+/* Define if you have the <malloc.h> header file.  */
+#define HAVE_MALLOC_H 1
+
+/* Define if you have the <sys/ioctl.h> header file.  */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define if you have the <sys/time.h> header file.  */
+#define HAVE_SYS_TIME_H 1
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H 1
+
+/* Define if you have the minipvfs library (-lminipvfs).  */
+#define HAVE_LIBMINIPVFS 1
+
+/* Define if kiovec symbols are present */
+#define HAVE_KIOVEC_SYMS 1
+
+/* Define if kiovec locking functions are present */
+#define HAVE_KIOVEC_LOCK 1
+
+/* Define if PVFS kernel patch is applied */
+/* #undef HAVE_PVFS_KERNEL_PATCH */
+
+/* Define if devfs is enabled */
+/* #undef HAVE_DEVFS_SYMS */
+
+/* Define if linux struct task_struct has a pending member */
+/* #undef HAVE_LINUX_STRUCT_TASK_STRUCT_PENDING */
+
+/* Define if pagelist member of kiobuf structure exists */
+/* #undef HAVE_PAGELIST */
+
+/* Define if linux struct file_operations has an owner member */
+#define HAVE_LINUX_STRUCT_FILE_OPERATIONS_OWNER 1
+
+/* Define if struct inode has an i_fop member */
+#define HAVE_LINUX_STRUCT_INODE_I_FOP 1
+
+/* Define if struct address_space_operations is defined */
+#define HAVE_LINUX_STRUCT_ADDRESS_SPACE_OPERATIONS 1
+
+/* Define if filldir function should take six parameters */
+#define HAVE_LINUX_6_PARAM_FILLDIR 1
+
+/* Define if statfs member function of struct super_operations takes 3 params */
+/* #undef HAVE_LINUX_3_PARAM_SUPER_STATFS */
+
+/* Define if fsync member function of struct file_operations takes 3 params */
+#define HAVE_LINUX_3_PARAM_FILE_FSYNC 1
+
+/* Define if linux struct page has an offset member */
+/* #undef HAVE_LINUX_STRUCT_PAGE_OFFSET */
+
+/* Define if DECLARE_WAIT_QUEUE_HEAD macro is available */
+#define HAVE_DECLARE_WAIT_QUEUE_HEAD 1
+
+/* Define if DECLARE_WAITQUEUE macro is available */
+#define HAVE_DECLARE_WAITQUEUE 1
+
+/* Define if DECLARE_MUTEX macro is available */
+#define HAVE_DECLARE_MUTEX 1
+
+/* Define if kmap function or macro exists */
+#define HAVE_KMAP 1
+
+/* Define if UnlockPage macro is available */
+#define HAVE_UNLOCKPAGE 1
+
+/* from config.h.bot */
+#endif
diff -ruN linux/fs.orig/davfs/dav_debug.h linux/fs/davfs/dav_debug.h
--- linux/fs.orig/davfs/dav_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/dav_debug.h	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,51 @@
+/*
+ * Defines some debug macros for smbfs.
+ */
+
+/* This makes a dentry parent/child name pair. Useful for debugging printk's */
+#define DENTRY_PATH(dentry) \
+	(dentry)->d_parent->d_name.name,(dentry)->d_name.name
+
+/*
+ * safety checks that should never happen ??? 
+ * these are normally enabled.
+ */
+#ifdef SMBFS_PARANOIA
+#define PARANOIA(x...) printk(KERN_NOTICE __FUNCTION__ ": " x)
+#else
+#define PARANOIA(x...) do { ; } while(0)
+#endif
+
+/* lots of debug messages */
+#ifdef SMBFS_DEBUG_VERBOSE
+#define VERBOSE(x...) printk(KERN_DEBUG __FUNCTION__ ": " x)
+#else
+#define VERBOSE(x...) do { ; } while(0)
+#endif
+
+/*
+ * "normal" debug messages, but not with a normal DEBUG define ... way
+ * too common name.
+ */
+#ifdef SMBFS_TRACE
+#define TRACE() printk(KERN_DEBUG __FUNCTION__ "--trace--\n")
+#else
+#define TRACE() do { ; } while(0)
+#endif
+
+#ifdef SMBFS_DEBUG
+#define DEBUG1(x...) printk(KERN_DEBUG __FUNCTION__ ": " x)
+#else
+#define DEBUG1(x...) do { ; } while(0)
+#endif
+
+#ifdef SMBFS_DEBUG2
+#define DEBUG2(x...) printk(KERN_DEBUG __FUNCTION__ ": " x)
+#else
+#define DEBUG2(x...) do { ; } while(0)
+#endif
+
+#define PRINT_INODE(inode) printk("imode_%d uid_%d gid_%d\n",\
+	 inode->i_mode, inode->i_uid, inode->i_gid) 
+
+#define PRINT_DENTRY(x) do { ; } while(0)
diff -ruN linux/fs.orig/davfs/davfs.h linux/fs/davfs/davfs.h
--- linux/fs.orig/davfs/davfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/davfs.h	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,380 @@
+/*
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/locks.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/file.h>
+#include <linux/dcache.h>
+#include <linux/smp_lock.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+enum {
+        PVFSHOSTLEN = 64,
+        PVFSDIRLEN = 1023
+};
+
+enum {
+	DAV_SUPER_MAGIC = 0x7890abcd
+};
+
+
+enum {
+        DAV_HOSTLEN = 1024,
+        DAV_PATHLEN = 1024,
+	DAV_IDLEN = 80,
+	DAV_PASSLEN = 80,
+};
+
+/*
+ * Data from mount.davfs command
+ * 
+ * You should keep same copy of mount module
+ */
+struct dav_mount_data {
+    unsigned info_magic;
+    int flags;
+    int port;
+    char host[DAV_HOSTLEN];
+    char path[DAV_PATHLEN];
+    char id  [DAV_IDLEN];
+    char pass[DAV_PASSLEN];
+    char mpoint[DAV_PATHLEN];
+    /* 'r' or 'rw' */
+    char amode[3];
+    /* socket */
+    unsigned int dav_fd;
+
+    /* mount demonized pid */
+    long pid;
+
+    /* user id ang group id */
+    umode_t         mode;
+    uid_t           uid;
+    gid_t           gid;
+
+    /* SSL mode */
+    int ssl_mode;
+
+    /* for Proxy */
+    char proxy[DAV_HOSTLEN];
+};
+
+struct dav_sb_info {
+    int flags;
+
+    /* Initial path */
+    char *path;
+    
+    /* server */
+    int  state;
+    struct file * sock_file;
+    struct socket *sock;
+    pid_t conn_pid;
+    struct smb_conn_opt opt;
+
+    /* general buff */
+    char *req;
+    char *buf;
+
+    char *connect;
+    int ret_code;
+    int length;
+
+    int ttl;
+    
+    struct semaphore sem;
+    wait_queue_head_t wait;
+
+    struct super_block *sb;
+    int rcls, err;
+
+    uid_t           uid;
+    gid_t           gid;
+
+    umode_t         file_mode;
+    umode_t         dir_mode;
+  
+};
+
+struct dav_i_info {
+    /*
+     * file handles are local to a connection. A file is open if
+     * (open == generation).
+     */ 
+    unsigned int open;      /* open generation */
+    unsigned long fileid;   /* What id to handle a file with? */
+    __u16 attr;             /* Attribute fields, DOS value */
+    
+    __u16 access;           /* Access mode */
+    __u16 flags;            /* status flags */
+    unsigned long oldmtime; /* last time refreshed */
+    unsigned long closed;   /* timestamp when closed */
+    unsigned openers;       /* number of fileid users */
+};
+
+/* metadata associated defines */
+typedef uint64_t pvfs_handle_t;
+typedef uint64_t pvfs_off_t;
+typedef uint64_t pvfs_size_t;
+typedef time_t pvfs_time_t;
+typedef uint32_t pvfs_uid_t;
+typedef uint32_t pvfs_gid_t;
+typedef uint32_t pvfs_mode_t;
+typedef uint32_t bitfield_t;
+
+
+#define DAV_MAXNAMELEN 255
+#define DAV_MAXPATHLEN 1024
+#define DAV_HEAD_SIZE 20
+
+#define DAV_SERVER(inode)    ((inode->i_sb->u.generic_sbp))
+#define DAV_INOP(inode)      ((inode->u.generic_ip))
+
+
+/*
+ * Contains all relevant data on a DAV networked file.
+ */
+struct dav_fattr {
+    __u16 attr;
+    
+    char	    f_name[DAV_MAXNAMELEN];
+    int		    f_name_len;	
+    unsigned long   f_ino;
+    umode_t         f_mode;
+    nlink_t         f_nlink;
+    uid_t           f_uid;
+    gid_t           f_gid;
+    kdev_t          f_rdev;
+    off_t           f_size;
+    time_t          f_atime;
+    time_t          f_mtime;
+    time_t          f_ctime;
+    unsigned long   f_blksize;
+    unsigned long   f_blocks;
+};
+
+/*
+** data struct to communicate to davfsd
+** it should keep same size with davfsd 
+*/
+struct dav_finfo {
+    char            f_name[DAV_MAXNAMELEN];
+    int             f_name_len; 
+    int             f_isdir;
+    off_t           f_size;
+    time_t          f_atime;
+    time_t          f_mtime;
+    time_t          f_ctime;
+};
+
+/*
+** data struct to communicate to davfsd for quota
+** it should keep same size with davfsd 
+*/
+struct dav_statfs {
+    long f_blocks;
+    long f_bfree;
+};
+
+
+/*      
+ * This is the time we allow an inode, dentry or dir cache to live. It is bad
+ * for performance to have shorter ttl on an inode than on the cache. It can
+ * cause refresh on each inode for a dir listing ... one-by-one
+ */             
+#define DAV_MAX_AGE(server) (((server)->ttl * HZ) / 1000)
+      
+struct dav_cache_head {
+        time_t          mtime;  /* unused */
+        unsigned long   time;   /* cache age */
+        unsigned long   end;    /* last valid fpos in cache */
+        int             eof;
+};
+
+#define DAV_DIRCACHE_SIZE       ((int)(PAGE_CACHE_SIZE/sizeof(struct dentry *)))
+
+#define DAV_FIRSTCACHE_SIZE     ((int)((DAV_DIRCACHE_SIZE * \
+        sizeof(struct dentry *) - sizeof(struct dav_cache_head)) / \
+        sizeof(struct dentry *)))
+
+#define DAV_DIRCACHE_START      (DAV_DIRCACHE_SIZE - DAV_FIRSTCACHE_SIZE)
+union dav_dir_cache {
+        struct dav_cache_head   head;
+        struct dentry           *dentry[DAV_DIRCACHE_SIZE];
+};
+
+
+struct dav_cache_control {
+        struct  dav_cache_head          head;
+        struct  page                    *page;
+        union   dav_dir_cache           *cache;
+        unsigned long                   fpos, ofs;
+        int                             filled, valid, idx;
+};
+
+/*
+ * Flags for the in-memory inode
+ */
+#define DAV_F_LOCALWRITE        0x02    /* file modified locally */
+
+
+/* From apache source code                                              */
+/* ----------------------- HTTP Status Codes  ------------------------- */
+
+/* The size of the static array in http_protocol.c for storing
+ * all of the potential response status-lines (a sparse table).
+ * A future version should dynamically generate the apr_table_t at startup.
+ */
+
+#define RESPONSE_CODES 55
+
+#define HTTP_CONTINUE                      100
+#define HTTP_SWITCHING_PROTOCOLS           101
+#define HTTP_PROCESSING                    102
+#define HTTP_OK                            200
+#define HTTP_CREATED                       201
+#define HTTP_ACCEPTED                      202
+#define HTTP_NON_AUTHORITATIVE             203
+#define HTTP_NO_CONTENT                    204
+#define HTTP_RESET_CONTENT                 205
+#define HTTP_PARTIAL_CONTENT               206
+#define HTTP_MULTI_STATUS                  207
+#define HTTP_MULTIPLE_CHOICES              300
+#define HTTP_MOVED_PERMANENTLY             301
+#define HTTP_MOVED_TEMPORARILY             302
+#define HTTP_SEE_OTHER                     303
+#define HTTP_NOT_MODIFIED                  304
+#define HTTP_USE_PROXY                     305
+#define HTTP_TEMPORARY_REDIRECT            307
+#define HTTP_BAD_REQUEST                   400
+#define HTTP_UNAUTHORIZED                  401
+#define HTTP_PAYMENT_REQUIRED              402
+#define HTTP_FORBIDDEN                     403
+#define HTTP_NOT_FOUND                     404
+#define HTTP_METHOD_NOT_ALLOWED            405
+#define HTTP_NOT_ACCEPTABLE                406
+#define HTTP_PROXY_AUTHENTICATION_REQUIRED 407
+#define HTTP_REQUEST_TIME_OUT              408
+#define HTTP_CONFLICT                      409
+#define HTTP_GONE                          410
+#define HTTP_LENGTH_REQUIRED               411
+#define HTTP_PRECONDITION_FAILED           412
+#define HTTP_REQUEST_ENTITY_TOO_LARGE      413
+#define HTTP_REQUEST_URI_TOO_LARGE         414
+#define HTTP_UNSUPPORTED_MEDIA_TYPE        415
+#define HTTP_RANGE_NOT_SATISFIABLE         416
+#define HTTP_EXPECTATION_FAILED            417
+#define HTTP_UNPROCESSABLE_ENTITY          422
+#define HTTP_LOCKED                        423
+#define HTTP_FAILED_DEPENDENCY             424
+#define HTTP_INTERNAL_SERVER_ERROR         500
+#define HTTP_NOT_IMPLEMENTED               501
+#define HTTP_BAD_GATEWAY                   502
+#define HTTP_SERVICE_UNAVAILABLE           503
+#define HTTP_GATEWAY_TIME_OUT              504
+#define HTTP_VERSION_NOT_SUPPORTED         505
+#define HTTP_VARIANT_ALSO_VARIES           506
+#define HTTP_INSUFFICIENT_STORAGE          507
+#define HTTP_NOT_EXTENDED                  510
+
+/*
+ * Access modes when opening a file
+ */
+#define DAV_ACCMASK     0x0003
+#define DAV_O_RDONLY    0x0000
+#define DAV_O_WRONLY    0x0001
+#define DAV_O_RDWR      0x0002
+
+/* structure access macros */
+#define dav_server_from_inode(inode) ((inode)->i_sb->u.generic_sbp)
+#define dav_server_from_dentry(dentry) ((dentry)->d_sb->u.generic_sbp)
+#define dav_SB_of(server) (server->sb)
+    
+/* linux/fs/smbfs/file.c */
+extern struct inode_operations dav_file_inode_operations;
+extern struct file_operations dav_file_operations;
+extern struct address_space_operations dav_file_aops;
+
+/* dir.c */
+extern struct inode_operations dav_dir_inode_operations;
+extern struct file_operations dav_dir_operations;
+void dav_new_dentry(struct dentry *dentry);
+void dav_renew_times(struct dentry *);
+
+/* linux/fs/smbfs/ioctl.c */
+int dav_ioctl (struct inode *, struct file *, unsigned int, unsigned long);
+
+/* linux/fs/smbfs/inode.c */
+struct super_block *dav_read_super(struct super_block *, void *, int);
+void dav_get_inode_attr(struct inode *, struct dav_fattr *);
+void dav_set_inode_attr(struct inode *, struct dav_fattr *);
+void dav_invalidate_inodes(struct dav_sb_info *);
+int  dav_revalidate_inode(struct dentry *);
+int  dav_notify_change(struct dentry *, struct iattr *);
+struct inode *dav_iget(struct super_block *, struct dav_fattr *);
+
+
+/* cache.c */
+void dav_invalid_dir_cache(struct inode * dir);
+void dav_invalidate_dircache_entries(struct dentry *parent);
+struct dentry * dav_dget_fpos(struct dentry *dentry, struct dentry *parent, unsigned long fpos);
+int dav_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
+		   struct dav_cache_control *ctrl, struct qstr *qname,
+		   struct dav_fattr *entry);
+
+/* proc */
+int dav_get_rsize(struct dav_sb_info *server);
+int dav_get_wsize(struct dav_sb_info *server);
+int dav_proc_readdir(struct file *filp, void *dirent, filldir_t filldir,
+		     struct dav_cache_control *ctl);
+
+int dav_proc_getattr(struct dentry *dir, struct dav_fattr *fattr);
+int dav_proc_mv(struct dentry *old_dentry, struct dentry *new_dentry);
+int dav_proc_mkdir(struct dentry *dentry);
+int dav_proc_rmdir(struct dentry *dentry);
+int dav_proc_unlink(struct dentry *dentry);
+int dav_proc_trunc(struct dav_sb_info *server, long fid, __u32 length);
+int dav_proc_setattr(struct dentry *dir, struct dav_fattr *fattr);
+int dav_proc_settime(struct dentry *dentry, struct dav_fattr *fattr);
+int dav_proc_open(struct dav_sb_info *server, struct dentry *dentry, int wish);
+int dav_open(struct dentry *dentry, int wish);
+int dav_close(struct inode *ino);
+int dav_close_fileid(struct dentry *dentry, long fileid);
+int dav_proc_create(struct dentry *dentry, __u16 attr, time_t ctime, long *fileid);
+int dav_proc_read(struct inode  *inode, off_t offset, int count, char *data);
+int dav_proc_write(struct inode *inode, off_t offset, int count, const char *data);
+void dav_init_root_dirent(struct dav_sb_info *server, struct dav_fattr *fattr);
+int dav_proc_disconnect(struct dav_sb_info *server);
+int dav_proc_statfs(struct dentry *dentry, struct statfs *buf);
+static inline void
+dav_age_dentry(struct dav_sb_info *server, struct dentry *dentry)
+{
+    dentry->d_time = jiffies - DAV_MAX_AGE(server);
+}
+
+
+/* socket.c */
+int _recvfrom(struct socket *socket, unsigned char *ubuf, int size, unsigned flags);
+int dav_send_raw(struct socket *socket, unsigned char *source, int length);
+int dav_receive_raw(struct socket *socket, unsigned char *target, int length);
+int do_tcp_rcv(struct dav_sb_info *server, void *buffer, size_t len);
+int dav_sendline_raw(struct socket *socket, unsigned char *target);
+int dav_readline_raw(struct dav_sb_info *server, unsigned char *target, int length);
+struct socket *dav_get_sock(struct dav_sb_info *server, unsigned int fd);
+
+
+
+
+
diff -ruN linux/fs.orig/davfs/dir.c linux/fs/davfs/dir.c
--- linux/fs.orig/davfs/dir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/dir.c	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,626 @@
+/*
+ *  dir.c
+ *
+ *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke
+ *  Copyright (C) 1997 by Volker Lendecke
+ *
+ *  Please add a note about your changes to davfs in the ChangeLog file.
+ */
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/ctype.h>
+#include <linux/smp_lock.h>
+
+#include "davfs.h"
+#include "dav_debug.h"
+
+static int dav_readdir(struct file *, void *, filldir_t);
+static int dav_dir_open(struct inode *, struct file *);
+
+static struct dentry *dav_lookup(struct inode *, struct dentry *);
+static int dav_create(struct inode *, struct dentry *, int);
+static int dav_mkdir(struct inode *, struct dentry *, int);
+static int dav_rmdir(struct inode *, struct dentry *);
+static int dav_unlink(struct inode *, struct dentry *);
+static int dav_rename(struct inode *, struct dentry *,
+		      struct inode *, struct dentry *);
+
+struct file_operations dav_dir_operations =
+{
+	read:		generic_read_dir,
+	readdir:	dav_readdir,
+	ioctl:		dav_ioctl,
+	open:		dav_dir_open,
+};
+
+struct inode_operations dav_dir_inode_operations =
+{
+	create:		dav_create,
+	lookup:		dav_lookup,
+	unlink:		dav_unlink,
+	mkdir:		dav_mkdir,
+	rmdir:		dav_rmdir,
+	rename:		dav_rename,
+	revalidate:	dav_revalidate_inode,
+	setattr:	dav_notify_change,
+};
+
+/*
+ * Read a directory, using filldir to fill the dirent memory.
+ * dav_proc_readdir does the actual reading from the dav server.
+ *
+ * The cache code is almost directly taken from ncpfs
+ */
+static int 
+dav_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct dentry *dentry = filp->f_dentry;
+	struct inode *dir = dentry->d_inode;
+	struct dav_sb_info *server = dav_server_from_dentry(dentry);
+	union  dav_dir_cache *cache = NULL;
+	struct dav_cache_control ctl;
+	struct page *page = NULL;
+	int result;
+
+	ctl.page  = NULL;
+	ctl.cache = NULL;
+	
+	TRACE();
+
+	VERBOSE("reading %s/%s, f_pos=%d\n",
+		DENTRY_PATH(dentry),  (int) filp->f_pos);
+
+	result = 0;
+	switch ((unsigned int) filp->f_pos) {
+	case 0:
+	    if (filldir(dirent, ".", 1, 0, dir->i_ino, DT_DIR) < 0)
+		    goto out;
+		filp->f_pos = 1;
+		/* fallthrough */
+	case 1:
+		if (filldir(dirent, "..", 2, 1,
+			    dentry->d_parent->d_inode->i_ino, DT_DIR) < 0)
+			goto out;
+		filp->f_pos = 2;
+	}
+
+	/*
+	 * Make sure our inode is up-to-date.
+	 */
+	result = dav_revalidate_inode(dentry);
+	if (result)
+		goto out;
+
+
+	page = grab_cache_page(&dir->i_data, 0);
+	if (!page)
+		goto read_really;
+
+	ctl.cache = cache = kmap(page);
+	ctl.head  = cache->head;
+
+	if (!Page_Uptodate(page) || !ctl.head.eof) {
+		VERBOSE("%s/%s, page uptodate=%d, eof=%d\n",
+			 DENTRY_PATH(dentry), Page_Uptodate(page),ctl.head.eof);
+		goto init_cache;
+	}
+
+	if (filp->f_pos == 2) {
+		if (jiffies - ctl.head.time >= DAV_MAX_AGE(server))
+			goto init_cache;
+
+		/*
+		 * N.B. ncpfs checks mtime of dentry too here, we don't.
+		 *   1. common dav servers do not update mtime on dir changes
+		 *   2. it requires an extra dav request
+		 *      (revalidate has the same timeout as ctl.head.time)
+		 *
+		 * Instead davfs invalidates its own cache on local changes
+		 * and remote changes are not seen until timeout.
+		 */
+	}
+
+	if (filp->f_pos > ctl.head.end)
+		goto finished;
+
+	ctl.fpos = filp->f_pos + (DAV_DIRCACHE_START - 2);
+	ctl.ofs  = ctl.fpos / DAV_DIRCACHE_SIZE;
+	ctl.idx  = ctl.fpos % DAV_DIRCACHE_SIZE;
+
+	for (;;) {
+		if (ctl.ofs != 0) {
+			ctl.page = find_lock_page(&dir->i_data, ctl.ofs);
+			if (!ctl.page)
+				goto invalid_cache;
+			ctl.cache = kmap(ctl.page);
+			if (!Page_Uptodate(ctl.page))
+				goto invalid_cache;
+		}
+		while (ctl.idx < DAV_DIRCACHE_SIZE) {
+			struct dentry *dent;
+			int res;
+
+			dent = dav_dget_fpos(ctl.cache->dentry[ctl.idx], dentry, filp->f_pos);
+			if (!dent)
+				goto invalid_cache;
+
+			res = filldir(dirent, dent->d_name.name,
+				      dent->d_name.len, filp->f_pos,
+				      dent->d_inode->i_ino, DT_UNKNOWN);
+			dput(dent);
+			if (res)
+				goto finished;
+			filp->f_pos += 1;
+			ctl.idx += 1;
+			if (filp->f_pos > ctl.head.end)
+				goto finished;
+		}
+		if (ctl.page) {
+			kunmap(ctl.page);
+			SetPageUptodate(ctl.page);
+			UnlockPage(ctl.page);
+			page_cache_release(ctl.page);
+			ctl.page = NULL;
+		}
+		ctl.idx  = 0;
+		ctl.ofs += 1;
+	}
+invalid_cache:
+	if (ctl.page) {
+		kunmap(ctl.page);
+		UnlockPage(ctl.page);
+		page_cache_release(ctl.page);
+		ctl.page = NULL;
+	}
+	ctl.cache = cache;
+init_cache:
+	dav_invalidate_dircache_entries(dentry);
+	ctl.head.time = jiffies;
+	ctl.head.eof = 0;
+	ctl.fpos = 2;
+	ctl.ofs = 0;
+	ctl.idx = DAV_DIRCACHE_START;
+	ctl.filled = 0;
+	ctl.valid  = 1;
+read_really:
+	result = dav_proc_readdir(filp, dirent, filldir, &ctl);
+	if (ctl.idx == -1)
+		goto invalid_cache;	/* retry */
+	ctl.head.end = ctl.fpos - 1;
+	ctl.head.eof = ctl.valid;
+finished:
+	if (page) {
+		cache->head = ctl.head;
+		kunmap(page);
+		SetPageUptodate(page);
+		UnlockPage(page);
+		page_cache_release(page);
+	}
+	if (ctl.page) {
+		kunmap(ctl.page);
+		SetPageUptodate(ctl.page);
+		UnlockPage(ctl.page);
+		page_cache_release(ctl.page);
+	}
+out:
+	return result;
+}
+
+/*
+ * Note: in order to allow the davmount process to open the
+ * mount point, we don't revalidate if conn_pid is NULL.
+ *
+ * return 0 for next
+ */
+static int
+dav_dir_open(struct inode *dir, struct file *file)
+{
+	struct dentry *dentry = file->f_dentry;
+	struct dav_sb_info *server;
+	int error = 0;
+
+	TRACE();
+
+	VERBOSE("(%s/%s)\n", dentry->d_parent->d_name.name,
+		file->f_dentry->d_name.name);
+
+	/*
+	 * Directory timestamps in the core protocol aren't updated
+	 * when a file is added, so we give them a very short TTL.
+	 */
+	lock_kernel();
+	server = dav_server_from_dentry(dentry);
+
+	/*
+	if (server->conn_pid)
+		error = dav_revalidate_inode(dentry);
+	*/
+	DEBUG1("conn_pid : %d\n", server->conn_pid);
+	unlock_kernel();
+	return error;
+}
+
+/*
+ * Dentry operations routines
+ */
+static int dav_lookup_validate(struct dentry *, int);
+static int dav_hash_dentry(struct dentry *, struct qstr *);
+static int dav_compare_dentry(struct dentry *, struct qstr *, struct qstr *);
+static int dav_delete_dentry(struct dentry *);
+
+static struct dentry_operations davfs_dentry_operations =
+{
+	d_revalidate:	dav_lookup_validate,
+	d_hash:		dav_hash_dentry,
+	d_compare:	dav_compare_dentry,
+	d_delete:	dav_delete_dentry,
+};
+
+/*
+static struct dentry_operations davfs_dentry_operations_case =
+{
+	d_revalidate:	dav_lookup_validate,
+	d_delete:	dav_delete_dentry,
+};
+*/
+
+/*
+ * This is the callback when the dcache has a lookup hit.
+ */
+static int
+dav_lookup_validate(struct dentry * dentry, int flags)
+{
+	struct dav_sb_info *server = dav_server_from_dentry(dentry);
+	struct inode * inode = dentry->d_inode;
+	unsigned long age = jiffies - dentry->d_time;
+	int valid = 1;
+
+	TRACE();
+
+	/*
+	 * The default validation is based on dentry age:
+	 * we believe in dentries for a few seconds.  (But each
+	 * successful server lookup renews the timestamp.)
+	 */
+	valid = (age <= DAV_MAX_AGE(server));
+#ifdef davFS_DEBUG_VERBOSE
+	if (!valid)
+		VERBOSE("%s/%s not valid, age=%lu\n", 
+			DENTRY_PATH(dentry), age);
+#endif
+
+	if (inode) {
+		lock_kernel();
+		if (is_bad_inode(inode)) {
+			PARANOIA("%s/%s has dud inode\n", DENTRY_PATH(dentry));
+			valid = 0;
+		} else if (!valid)
+			valid = (dav_revalidate_inode(dentry) == 0);
+		unlock_kernel();
+	} else {
+		/*
+		 * What should we do for negative dentries?
+		 */
+	}
+	return valid;
+}
+
+static int 
+dav_hash_dentry(struct dentry *dir, struct qstr *this)
+{
+	unsigned long hash;
+	int i;
+
+	TRACE();
+
+	hash = init_name_hash();
+	for (i=0; i < this->len ; i++)
+		hash = partial_name_hash(tolower(this->name[i]), hash);
+	this->hash = end_name_hash(hash);
+  
+	return 0;
+}
+
+static int
+dav_compare_dentry(struct dentry *dir, struct qstr *a, struct qstr *b)
+{
+	int i, result = 1;
+
+	TRACE();
+
+	if (a->len != b->len)
+		goto out;
+	for (i=0; i < a->len; i++) {
+		if (tolower(a->name[i]) != tolower(b->name[i]))
+			goto out;
+	}
+	result = 0;
+out:
+	return result;
+}
+
+/*
+ * This is the callback from dput() when d_count is going to 0.
+ * We use this to unhash dentries with bad inodes.
+ */
+static int
+dav_delete_dentry(struct dentry * dentry)
+{
+
+	TRACE();
+	if (dentry->d_inode) {
+		if (is_bad_inode(dentry->d_inode)) {
+			PARANOIA("bad inode, unhashing %s/%s\n",
+				 DENTRY_PATH(dentry));
+			return 1;
+		}
+	} else {
+		/* N.B. Unhash negative dentries? */
+	}
+	return 0;
+}
+
+/*
+ * Initialize a new dentry
+ */
+void
+dav_new_dentry(struct dentry *dentry)
+{
+    //	struct dav_sb_info *server = dav_server_from_dentry(dentry);
+
+	TRACE();
+
+	dentry->d_op = &davfs_dentry_operations;
+	
+	dentry->d_time = jiffies;
+}
+
+
+/*
+ * Whenever a lookup succeeds, we know the parent directories
+ * are all valid, so we want to update the dentry timestamps.
+ * N.B. Move this to dcache?
+ */
+void
+dav_renew_times(struct dentry * dentry)
+{
+	TRACE();
+
+	for (;;) {
+		dentry->d_time = jiffies;
+		if (IS_ROOT(dentry))
+			break;
+		dentry = dentry->d_parent;
+	}
+}
+
+static struct dentry *
+dav_lookup(struct inode *dir, struct dentry *dentry)
+{
+	struct dav_fattr finfo;
+	struct inode *inode;
+	int error;
+	struct dav_sb_info *server;
+
+	TRACE();
+
+	error = -ENAMETOOLONG;
+	if (dentry->d_name.len > DAV_MAXNAMELEN)
+		goto out;
+
+	error = dav_proc_getattr(dentry, &finfo);
+#ifdef davFS_PARANOIA
+	if (error && error != -ENOENT)
+		PARANOIA("find %s/%s failed, error=%d\n",
+			 DENTRY_PATH(dentry), error);
+#endif
+	DEBUG1("=== getattr result : %d\n", error);
+
+	inode = NULL;
+	if (error == -ENOENT)
+		goto add_entry;
+	if (!error) {
+		error = -EACCES;
+		finfo.f_ino = iunique(dentry->d_sb, 2);
+		inode = dav_iget(dir->i_sb, &finfo);
+		if (inode) {
+	add_entry:
+			server = dav_server_from_dentry(dentry);
+			dentry->d_op = &davfs_dentry_operations;
+
+			d_add(dentry, inode);
+			dav_renew_times(dentry);
+			error = 0;
+		}
+	}
+out:
+	return ERR_PTR(error);
+}
+
+/*
+ * This code is common to all routines creating a new inode.
+ */
+static int
+dav_instantiate(struct dentry *dentry, long fileid, int have_id)
+{
+    //    struct dav_sb_info *server = dav_server_from_dentry(dentry);
+    struct inode *inode;
+    int error;
+    struct dav_fattr fattr;
+    
+    TRACE();
+    
+    VERBOSE("file %s/%s, fileid=%ld\n", DENTRY_PATH(dentry), fileid);
+    
+    
+    error = dav_proc_getattr(dentry, &fattr);
+    if (error)
+	goto out_close;
+    
+    dav_renew_times(dentry);
+    fattr.f_ino = iunique(dentry->d_sb, 2);
+    inode = dav_iget(dentry->d_sb, &fattr);
+    if (!inode)
+	goto out_no_inode;
+    
+    if (have_id)
+      {
+	  /* we don't have inode before here */
+	  /* bug fix 05/09/01 hunkim         */
+	  struct dav_i_info *dii = DAV_INOP(inode);
+	  dii->fileid = fileid;
+	  DEBUG2("FILEID = %ld\n", dii->fileid);
+	  dii->access = DAV_O_RDWR;
+	  dii->open++;
+      }
+    
+    d_instantiate(dentry, inode);
+ out:
+    return error;
+    
+ out_no_inode:
+    error = -EACCES;
+ out_close:
+    if (have_id)
+      {
+	  PARANOIA("%s/%s failed, error=%d, closing %ld\n",
+		   DENTRY_PATH(dentry), error, fileid);
+	  dav_close_fileid(dentry, fileid);
+      }
+    goto out;
+}
+
+/* N.B. How should the mode argument be used? */
+static int
+dav_create(struct inode *dir, struct dentry *dentry, int mode)
+{
+	/* fake file id */
+	long fileid=0;
+	int error;
+
+	TRACE();
+
+	VERBOSE("creating %s/%s, mode=%d\n", DENTRY_PATH(dentry), mode);
+
+	dav_invalid_dir_cache(dir);
+	error = dav_proc_create(dentry, 0, CURRENT_TIME, &fileid);
+	if (!error) {
+		error = dav_instantiate(dentry, fileid, 1);
+	} else {
+		PARANOIA("%s/%s failed, error=%d\n",
+			 DENTRY_PATH(dentry), error);
+	}
+
+	DEBUG2("FILEID = %ld\n", fileid);
+	return error;
+}
+
+/* N.B. How should the mode argument be used? */
+static int
+dav_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int error;
+
+	TRACE();
+
+	dav_invalid_dir_cache(dir);
+	error = dav_proc_mkdir(dentry);
+	if (!error) {
+		error = dav_instantiate(dentry, 0, 0);
+	}
+	return error;
+}
+
+static int
+dav_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+
+	TRACE();
+
+	/*
+	 * Close the directory if it's open.
+	 */
+	dav_close(inode);
+
+	/*
+	 * Check that nobody else is using the directory..
+	 */
+	error = -EBUSY;
+	if (!d_unhashed(dentry))
+		goto out;
+
+	dav_invalid_dir_cache(dir);
+	error = dav_proc_rmdir(dentry);
+
+out:
+	return error;
+}
+
+static int
+dav_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int error;
+
+	TRACE();
+
+	/*
+	 * Close the file if it's open.
+	 */
+	dav_close(dentry->d_inode);
+
+	dav_invalid_dir_cache(dir);
+	error = dav_proc_unlink(dentry);
+	if (!error)
+		dav_renew_times(dentry);
+	return error;
+}
+
+static int
+dav_rename(struct inode *old_dir, struct dentry *old_dentry,
+	   struct inode *new_dir, struct dentry *new_dentry)
+{
+	int error;
+
+	TRACE();
+
+	/*
+	 * Close any open files, and check whether to delete the
+	 * target before attempting the rename.
+	 */
+	if (old_dentry->d_inode)
+		dav_close(old_dentry->d_inode);
+	if (new_dentry->d_inode)
+	{
+		dav_close(new_dentry->d_inode);
+		error = dav_proc_unlink(new_dentry);
+		if (error)
+		{
+			VERBOSE("unlink %s/%s, error=%d\n",
+				DENTRY_PATH(new_dentry), error);
+			goto out;
+		}
+		/* FIXME */
+		d_delete(new_dentry);
+	}
+
+	dav_invalid_dir_cache(old_dir);
+	dav_invalid_dir_cache(new_dir);
+	error = dav_proc_mv(old_dentry, new_dentry);
+	if (!error)
+	{
+		dav_renew_times(old_dentry);
+		dav_renew_times(new_dentry);
+	}
+out:
+	return error;
+}
+
+
+
+
+
+
diff -ruN linux/fs.orig/davfs/file.c linux/fs/davfs/file.c
--- linux/fs.orig/davfs/file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/file.c	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,397 @@
+/*
+ *  file.c
+ *
+ *  Copyright (C) 1995, 1996, 1997 by Paal-Kr. Engstad and Volker Lendecke
+ *  Copyright (C) 1997 by Volker Lendecke
+ *
+ *  Please add a note about your changes to davfs in the ChangeLog file.
+ */
+
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/stat.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/smp_lock.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include "dav_debug.h"
+#include "davfs.h"
+
+static int
+dav_fsync(struct file *file, struct dentry * dentry, int datasync)
+{
+	VERBOSE("sync file %s/%s\n", DENTRY_PATH(dentry));
+	return 0;
+}
+
+/*
+ * Read a page synchronously.
+ */
+static int
+dav_readpage_sync(struct dentry *dentry, struct page *page)
+{
+	char *buffer = kmap(page);
+	unsigned long offset = page->index << PAGE_CACHE_SHIFT;
+	int rsize = dav_get_rsize(dav_server_from_dentry(dentry));
+	int count = PAGE_SIZE;
+	int result;
+
+	VERBOSE("file %s/%s, count=%d@%ld, rsize=%d\n",
+		DENTRY_PATH(dentry), count, offset, rsize);
+
+	result = dav_open(dentry, DAV_O_RDONLY);
+	if (result < 0) {
+		PARANOIA("%s/%s open failed, error=%d\n",
+			 DENTRY_PATH(dentry), result);
+		goto io_error;
+	}
+
+	do {
+		if (count < rsize)
+			rsize = count;
+
+		result = dav_proc_read(dentry->d_inode, offset, rsize, buffer);
+		if (result < 0)
+			goto io_error;
+
+		count -= result;
+		offset += result;
+		buffer += result;
+		dentry->d_inode->i_atime = CURRENT_TIME;
+		if (result < rsize)
+			break;
+	} while (count);
+
+	memset(buffer, 0, count);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	result = 0;
+
+io_error:
+	kunmap(page);
+	UnlockPage(page);
+	return result;
+}
+
+/*
+ * We are called with the page locked and we unlock it when done.
+ */
+static int
+dav_readpage(struct file *file, struct page *page)
+{
+	int		error;
+	struct dentry  *dentry = file->f_dentry;
+
+	TRACE();
+
+	get_page(page);
+	error = dav_readpage_sync(dentry, page);
+	put_page(page);
+	return error;
+}
+
+/*
+ * Write a page synchronously.
+ * Offset is the data offset within the page.
+ */
+static int
+dav_writepage_sync(struct inode *inode, struct page *page,
+		   unsigned long offset, unsigned int count)
+{
+    char *buffer = kmap(page) + offset;
+    struct dav_i_info *dii = inode->u.generic_ip;
+    
+    int wsize = dav_get_wsize(dav_server_from_inode(inode));
+    int result, written = 0;
+    
+    TRACE();
+    
+    offset += page->index << PAGE_CACHE_SHIFT;
+    VERBOSE("file ino=%ld,  count=%d@%ld, wsize=%d\n",
+	    inode->i_ino,  count, offset, wsize);
+    
+    do {
+	if (count < wsize)
+	    wsize = count;
+	
+	result = dav_proc_write(inode, offset, wsize, buffer);
+	if (result < 0) {
+	    PARANOIA("failed write, wsize=%d, result=%d\n",
+		     wsize, result);
+	    break;
+	}
+	/* N.B. what if result < wsize?? */
+#ifdef davFS_PARANOIA
+	if (result < wsize)
+	    PARANOIA("short write, wsize=%d, result=%d\n",
+		     wsize, result);
+#endif
+	buffer += wsize;
+	offset += wsize;
+	written += wsize;
+	count -= wsize;
+	/*
+	 * Update the inode now rather than waiting for a refresh.
+	 */
+	inode->i_mtime = inode->i_atime = CURRENT_TIME;
+	if (offset > inode->i_size)
+	    inode->i_size = offset;
+	dii->flags |= DAV_F_LOCALWRITE;
+    } while (count);
+    
+    kunmap(page);
+    return written ? written : result;
+}
+
+/*
+ * Write a page to the server. This will be used for NFS swapping only
+ * (for now), and we currently do this synchronously only.
+ *
+ * We are called with the page locked and we unlock it when done.
+ */
+static int
+dav_writepage(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	unsigned long end_index;
+	unsigned offset = PAGE_CACHE_SIZE;
+	int err=0;
+
+	TRACE();
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+
+	end_index = inode->i_size >> PAGE_CACHE_SHIFT;
+
+	/* easy case */
+	if (page->index < end_index)
+		goto do_it;
+	/* things got complicated... */
+	offset = inode->i_size & (PAGE_CACHE_SIZE-1);
+	/* OK, are we completely out? */
+	if (page->index >= end_index+1 || !offset)
+		return -EIO;
+do_it:
+	get_page(page);
+	err = dav_writepage_sync(inode, page, 0, offset);
+	SetPageUptodate(page);
+	UnlockPage(page);
+	put_page(page);
+	return err;
+}
+
+static int
+dav_updatepage(struct file *file, struct page *page, unsigned long offset,
+	       unsigned int count)
+{
+	struct dentry *dentry = file->f_dentry;
+
+	DEBUG1("(%s/%s %d@%ld)\n", DENTRY_PATH(dentry), 
+	       count, (page->index << PAGE_CACHE_SHIFT)+offset);
+
+	return dav_writepage_sync(dentry->d_inode, page, offset, count);
+} 
+
+static ssize_t
+dav_file_read(struct file * file, char * buf, size_t count, loff_t *ppos)
+{
+	struct dentry * dentry = file->f_dentry;
+	ssize_t	status;
+
+	VERBOSE("file %s/%s, count=%lu@%lu\n", DENTRY_PATH(dentry),
+		(unsigned long) count, (unsigned long) *ppos);
+
+	status = dav_revalidate_inode(dentry);
+	if (status)
+	{
+		PARANOIA("%s/%s validation failed, error=%Zd\n",
+			 DENTRY_PATH(dentry), status);
+		goto out;
+	}
+
+	VERBOSE("before read, size=%ld, flags=%x, atime=%ld\n",
+		(long)dentry->d_inode->i_size,
+		dentry->d_inode->i_flags, dentry->d_inode->i_atime);
+
+	status = generic_file_read(file, buf, count, ppos);
+out:
+	return status;
+}
+
+static int
+dav_file_mmap(struct file * file, struct vm_area_struct * vma)
+{
+	struct dentry * dentry = file->f_dentry;
+	int	status;
+
+	VERBOSE("file %s/%s, address %lu - %lu\n",
+		DENTRY_PATH(dentry), vma->vm_start, vma->vm_end);
+
+	status = dav_revalidate_inode(dentry);
+	if (status)
+	{
+		PARANOIA("%s/%s validation failed, error=%d\n",
+			 DENTRY_PATH(dentry), status);
+		goto out;
+	}
+	status = generic_file_mmap(file, vma);
+out:
+	return status;
+}
+
+/*
+ * This does the "real" work of the write. The generic routine has
+ * allocated the page, locked it, done all the page alignment stuff
+ * calculations etc. Now we should just copy the data from user
+ * space and write it back to the real medium..
+ *
+ * If the writer ends up delaying the write, the writer needs to
+ * increment the page use counts until he is done with the page.
+ */
+static int dav_prepare_write(struct file *file, struct page *page, 
+			     unsigned offset, unsigned to)
+{
+	TRACE();
+	kmap(page);
+	return 0;
+}
+
+static int dav_commit_write(struct file *file, struct page *page,
+			    unsigned offset, unsigned to)
+{
+	int status;
+
+	TRACE();
+
+	status = -EFAULT;
+	lock_kernel();
+	status = dav_updatepage(file, page, offset, to-offset);
+	unlock_kernel();
+	kunmap(page);
+	return status;
+}
+
+struct address_space_operations dav_file_aops = {
+	readpage: dav_readpage,
+	writepage: dav_writepage,
+	prepare_write: dav_prepare_write,
+	commit_write: dav_commit_write
+};
+
+/* 
+ * Write to a file (through the page cache).
+ */
+static ssize_t
+dav_file_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	struct dentry * dentry = file->f_dentry;
+	ssize_t	result;
+
+	VERBOSE("file %s/%s, count=%lu@%lu\n",
+		DENTRY_PATH(dentry),
+		(unsigned long) count, (unsigned long) *ppos);
+
+	result = dav_revalidate_inode(dentry);
+	if (result)
+	{
+		PARANOIA("%s/%s validation failed, error=%Zd\n",
+			 DENTRY_PATH(dentry), result);
+		goto out;
+	}
+
+	result = dav_open(dentry, DAV_O_WRONLY);
+	if (result)
+		goto out;
+
+	if (count > 0)
+	{
+		result = generic_file_write(file, buf, count, ppos);
+		VERBOSE("pos=%ld, size=%ld, mtime=%ld, atime=%ld\n",
+			(long) file->f_pos, (long) dentry->d_inode->i_size,
+			dentry->d_inode->i_mtime, dentry->d_inode->i_atime);
+	}
+out:
+	return result;
+}
+
+static int
+dav_file_open(struct inode *inode, struct file * file)
+{
+	int result=0;
+	struct dentry *dentry = file->f_dentry;
+	struct dav_i_info *dii = inode->u.generic_ip;
+	int dav_mode = (file->f_mode & O_ACCMODE) - 1;
+
+	TRACE();
+
+	lock_kernel();
+	result = dav_open(dentry, dav_mode);
+	if (result)
+		goto out;
+	dii->openers++;
+out:
+	unlock_kernel();
+	return result;
+}
+
+static int
+dav_file_release(struct inode *inode, struct file * file)
+{
+    struct dav_i_info *dii = inode->u.generic_ip;
+
+    TRACE();
+    lock_kernel();
+    if (!--dii->openers)
+	dav_close(inode);
+    unlock_kernel();
+    return 0;
+}
+
+/*
+ * Check whether the required access is compatible with
+ * an inode's permission. dav doesn't recognize superuser
+ * privileges, so we need our own check for this.
+ */
+static int
+dav_file_permission(struct inode *inode, int mask)
+{
+	int mode = inode->i_mode;
+	int error = 0;
+
+	VERBOSE("mode=%x, mask=%x\n", mode, mask);
+
+	/* Look at user permissions */
+	mode >>= 6;
+	if ((mode & 7 & mask) != mask)
+		error = -EACCES;
+	return error;
+}
+
+struct file_operations dav_file_operations =
+{
+	read:		dav_file_read,
+	write:		dav_file_write,
+	ioctl:		dav_ioctl,
+	mmap:		dav_file_mmap,
+	open:		dav_file_open,
+	release:	dav_file_release,
+	fsync:		dav_fsync,
+};
+
+struct inode_operations dav_file_inode_operations =
+{
+	permission:	dav_file_permission,
+	revalidate:	dav_revalidate_inode,
+	setattr:	dav_notify_change,
+};
diff -ruN linux/fs.orig/davfs/getopt.c linux/fs/davfs/getopt.c
--- linux/fs.orig/davfs/getopt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/getopt.c	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,7 @@
+/*
+ * getopt.c
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+
diff -ruN linux/fs.orig/davfs/inode.c linux/fs/davfs/inode.c
--- linux/fs.orig/davfs/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/inode.c	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,625 @@
+/*
+ *  inode.c
+ *
+ *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke
+ *  Copyright (C) 1997 by Volker Lendecke
+ *  Copyright (C) 2001 by SungHun Kim, edit and change for dav support
+ *
+ *  Please add a note about your changes to davfs in the ChangeLog file.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/smp_lock.h>
+#include <linux/locks.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/file.h>
+#include <linux/dcache.h>
+
+#include <linux/ncp_no.h>
+/*
+#include <linux/dav_fs.h>
+#include <linux/davno.h>
+#include <linux/dav_mount.h>
+
+*/
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#include "davfs.h"
+#include "dav_debug.h"
+
+static void dav_delete_inode(struct inode *);
+static void dav_put_super(struct super_block *);
+static int  dav_statfs(struct super_block *, struct statfs *);
+
+static struct super_operations dav_sops =
+{
+	put_inode:	force_delete,
+	delete_inode:	dav_delete_inode,
+	put_super:	dav_put_super,
+	statfs:		dav_statfs,
+};
+
+
+/* We are always generating a new inode here */
+struct inode *
+dav_iget(struct super_block *sb, struct dav_fattr *fattr)
+{
+    struct inode *result;
+    struct dav_i_info *dav_i_info;
+    
+    TRACE();
+
+    result = new_inode(sb);
+    if (!result)
+	return result;
+    
+    result->i_ino = fattr->f_ino;
+    
+    /* malloc for dav_i_info */
+    dav_i_info = (struct dav_i_info *) 
+      kmalloc(sizeof(struct dav_i_info), GFP_KERNEL);
+    
+    if(!dav_i_info)
+	return NULL;
+    
+    memset(dav_i_info, 0x00, sizeof(struct dav_i_info));
+    
+    /* we need to use generic pointer */
+    result->u.generic_ip = dav_i_info;
+    
+    dav_set_inode_attr(result, fattr);
+    
+    if (S_ISREG(result->i_mode)) {
+	result->i_op = &dav_file_inode_operations;
+	result->i_fop = &dav_file_operations;
+	result->i_data.a_ops = &dav_file_aops;
+    } else if (S_ISDIR(result->i_mode)) {
+	result->i_op = &dav_dir_inode_operations;
+	result->i_fop = &dav_dir_operations;
+    }
+    insert_inode_hash(result);
+    
+    DEBUG1("dav_iget: %p\n", fattr);
+    
+    return result;
+}
+
+/*
+ * Copy the inode data to a dav_fattr structure.
+ */
+void
+dav_get_inode_attr(struct inode *inode, struct dav_fattr *fattr)
+{
+    struct dav_i_info *dii = inode->u.generic_ip;
+
+    DEBUG1("here\n");
+
+    memset(fattr, 0, sizeof(struct dav_fattr));
+    fattr->f_mode	= inode->i_mode;
+    fattr->f_nlink	= inode->i_nlink;
+    fattr->f_ino	= inode->i_ino;
+    fattr->f_uid	= inode->i_uid;
+    fattr->f_gid	= inode->i_gid;
+    fattr->f_rdev	= inode->i_rdev;
+    fattr->f_size	= inode->i_size;
+    fattr->f_mtime	= inode->i_mtime;
+    fattr->f_ctime	= inode->i_ctime;
+    fattr->f_atime	= inode->i_atime;
+    fattr->f_blksize= inode->i_blksize;
+    fattr->f_blocks	= inode->i_blocks;
+    
+    fattr->attr	= dii->attr;
+    /*
+     * Keep the attributes in sync with the inode permissions.
+     */
+    if (fattr->f_mode & S_IWUSR)
+	fattr->attr &= ~aRONLY;
+    else
+	fattr->attr |= aRONLY;
+}
+
+void
+dav_set_inode_attr(struct inode *inode, struct dav_fattr *fattr)
+{
+    struct dav_i_info *dii = inode->u.generic_ip;
+
+    TRACE();
+    
+    inode->i_mode	= fattr->f_mode;
+    inode->i_nlink	= fattr->f_nlink;
+    inode->i_uid	= fattr->f_uid;
+    inode->i_gid	= fattr->f_gid;
+    inode->i_rdev	= fattr->f_rdev;
+    inode->i_ctime	= fattr->f_ctime;
+    inode->i_blksize    = fattr->f_blksize;
+    inode->i_blocks     = fattr->f_blocks;
+    /*
+     * Don't change the size and mtime/atime fields
+     * if we're writing to the file.
+     */
+    /*
+    if (!(dii->flags & DAV_F_LOCALWRITE)) 
+    */
+    {
+	inode->i_size  = fattr->f_size;
+	inode->i_mtime = fattr->f_mtime;
+	inode->i_atime = fattr->f_atime;
+    }
+
+    if(dii) {
+    
+       dii->attr = fattr->attr;
+      /*
+       * Update the "last time refreshed" field for revalidation.
+       */
+      dii->oldmtime = jiffies;
+    }
+}
+
+/*
+ * This is called if the connection has gone bad ...
+ * try to kill off all the current inodes.
+ */
+void
+dav_invalidate_inodes(struct dav_sb_info *server)
+{
+	VERBOSE("\n");
+	shrink_dcache_sb(dav_SB_of(server));
+	invalidate_inodes(dav_SB_of(server));
+}
+
+/*
+ * This is called to update the inode attributes after
+ * we've made changes to a file or directory.
+ */
+static int
+dav_refresh_inode(struct dentry *dentry)
+{
+    struct inode *inode = dentry->d_inode;
+    int error;
+    struct dav_fattr fattr;
+    
+    DEBUG1("here\n");
+    error = dav_proc_getattr(dentry, &fattr);
+    
+    if (!error) {
+	dav_renew_times(dentry);
+	/*
+	 * Check whether the type part of the mode changed,
+	 * and don't update the attributes if it did.
+	 */
+	if ((inode->i_mode & S_IFMT) == (fattr.f_mode & S_IFMT)) {
+	    dav_set_inode_attr(inode, &fattr);
+	} else {
+	    /*
+	     * Big trouble! The inode has become a new object,
+	     * so any operations attempted on it are invalid.
+	     *
+	     * To limit damage, mark the inode as bad so that
+	     * subsequent lookup validations will fail.
+	     */
+	    PARANOIA("%s/%s changed mode, %07o to %07o\n",
+		     DENTRY_PATH(dentry),
+		     inode->i_mode, fattr.f_mode);
+	    
+	    fattr.f_mode = inode->i_mode; /* save mode */
+	    make_bad_inode(inode);
+	    inode->i_mode = fattr.f_mode; /* restore mode */
+	    /*
+	     * No need to worry about unhashing the dentry: the
+	     * lookup validation will see that the inode is bad.
+	     * But we do want to invalidate the caches ...
+	     */
+	    if (!S_ISDIR(inode->i_mode))
+		invalidate_inode_pages(inode);
+	    else
+		dav_invalid_dir_cache(inode);
+	    error = -EIO;
+	}
+    }
+    return error;
+}
+
+/*
+ * This is called when we want to check whether the inode
+ * has changed on the server.  If it has changed, we must
+ * invalidate our local caches.
+ */
+int
+dav_revalidate_inode(struct dentry *dentry)
+{
+	struct dav_sb_info *s = dav_server_from_dentry(dentry);
+       	struct inode *inode = dentry->d_inode;
+	struct dav_i_info *dii = inode->u.generic_ip;
+	time_t last_time;
+	loff_t last_sz;
+	int error = 0;
+
+	TRACE();
+
+	VERBOSE(" for dentry %s/%s\n",
+               DENTRY_PATH(dentry));
+
+	lock_kernel();
+
+	/*
+	 * Check whether we've recently refreshed the inode.
+	 */
+	if (time_before(jiffies, dii->oldmtime + DAV_MAX_AGE(s))) {
+		VERBOSE("up-to-date, ino=%ld, jiffies=%lu, oldtime=%lu\n",
+			inode->i_ino, jiffies, dii->oldmtime);
+		goto out;
+	}
+
+	/*
+	 * Save the last modified time, then refresh the inode.
+	 * (Note: a size change should have a different mtime,
+	 *  or same mtime but different size.)
+	 */
+	last_time = inode->i_mtime;
+	last_sz   = inode->i_size;
+	error = dav_refresh_inode(dentry);
+	
+	if (error || inode->i_mtime != last_time || inode->i_size != last_sz) {
+		VERBOSE("%s/%s changed, old=%ld, new=%ld\n",
+			DENTRY_PATH(dentry),
+			(long) last_time, (long) inode->i_mtime);
+
+		if (!S_ISDIR(inode->i_mode))
+			invalidate_inode_pages(inode);
+	}
+out:
+	unlock_kernel();
+	return error;
+}
+
+/*
+ * This routine is called when i_nlink == 0 and i_count goes to 0.
+ * All blocking cleanup operations need to go here to avoid races.
+ */
+static void
+dav_delete_inode(struct inode *ino)
+{
+	int ret;
+
+	DEBUG1("ino=%ld\n", ino->i_ino);
+	lock_kernel();
+	
+	
+	if(ino->u.generic_ip) 
+	    kfree(ino->u.generic_ip);
+	
+	if ((ret=dav_close(ino)))
+		PARANOIA("could not close inode %ld(%d)\n", ino->i_ino, ret);
+
+	unlock_kernel();
+
+	clear_inode(ino);
+}
+
+
+static void
+dav_put_super(struct super_block *sb)
+{
+    struct dav_sb_info *server = sb->u.generic_sbp;
+    
+    TRACE();
+	
+    /* disconnect with davfsd */
+    dav_proc_disconnect(server);
+
+    /* free general buf */
+    kfree(server->buf);
+    kfree(server->req);
+
+    /*
+      if (server->sock_file) {
+      dav_proc_disconnect(server);
+      dav_dont_catch_keepalive(server);
+      fput(server->sock_file);
+      }
+      
+      if (server->conn_pid)
+      kill_proc(server->conn_pid, SIGTERM, 1);
+    */
+    
+    /*
+      kfree(sb->u.davfs_sb.temp_buf);
+      
+      if (server->packet)
+      dav_vfree(server->packet);
+    */	
+}
+
+char * dav_strdup(char *str) {
+    char *ret =  kmalloc(strlen(str)+1 ,GFP_KERNEL);
+    if(!ret) 
+	return ret;
+
+    memset(ret, 0, sizeof(strlen(str)+1));
+    strcpy(ret, str);
+
+    return ret;
+}
+
+struct super_block *
+dav_read_super(struct super_block *sb, void *raw_data, int silent)
+{
+    struct dav_mount_data *davmnt;
+    struct inode *root_inode;
+    struct dav_fattr root;
+    struct dav_sb_info *server;
+
+    TRACE();
+
+    if (!raw_data)
+	goto out_no_data;
+    
+    davmnt = (struct dav_mount_data *) raw_data;
+
+    /* malloc for sb */
+    server = (struct dav_sb_info *) 
+      kmalloc(sizeof(struct dav_sb_info) ,GFP_KERNEL);
+    if(!server)
+	goto out_no_mem;
+    
+    memset(server, 0, sizeof(*server));
+    
+    /* copy data from mount information to server data */
+    server->flags = davmnt->flags;
+    server->ttl = 1000;
+    server->uid = davmnt->uid;
+    server->gid = davmnt->gid;
+   
+    server->dir_mode  = S_IRWXU | S_IRWXG | S_IRWXO | S_IFDIR;
+    server->file_mode = S_IRWXU | S_IRWXG | S_IRWXO | S_IFREG;
+    server->sb = sb;
+
+    server->path = dav_strdup(davmnt->path);
+    if(!server->path)
+	goto out_no_mem;
+
+    /* socket handler to communicate davfsd */
+    server->sock = dav_get_sock(server, davmnt->dav_fd);
+    if(!server->sock) 
+	goto out_bad_sock;
+
+    /* init_ MUTEX and waitques */
+    init_MUTEX(&(server->sem));
+    init_waitqueue_head(&server->wait);
+
+    /* memory alloc for general buf */
+    server->buf = kmalloc(DAV_MAXPATHLEN ,GFP_KERNEL);
+    server->req = kmalloc(DAV_MAXPATHLEN ,GFP_KERNEL);
+    if(!server->buf || !server->req)
+	goto out_no_mem;
+
+ 
+#ifdef SERVER_TEST
+    /* test server */
+    dav_server_test(server);
+#endif
+
+    /* assign generic sbp */
+    sb->u.generic_sbp = server;
+	
+    sb->s_blocksize = 1024;	/* Eh...  Is this correct? */
+    sb->s_blocksize_bits = 12;
+    sb->s_magic = DAV_SUPER_MAGIC;
+    sb->s_flags = 0;
+    sb->s_op = &dav_sops;
+    sb->s_maxbytes = MAX_NON_LFS;	/* client support missing */
+	
+    dav_init_root_dirent(server, &root);
+
+    DEBUG1("root_mode : %d\n", root.f_mode);
+    root_inode = dav_iget(sb, &root);
+    if (!root_inode)
+	goto out_no_root;
+    
+    sb->s_root = d_alloc_root(root_inode);
+    if (!sb->s_root)
+	goto out_no_root;
+    dav_new_dentry(sb->s_root);
+	
+    PRINT_INODE(root_inode);
+    PRINT_DENTRY(sb->s_root);
+
+    DEBUG1("org_mode %d\n", server->dir_mode);
+
+    return sb;
+    
+out_no_root:
+	iput(root_inode);
+out_bad_sock:
+	printk(KERN_ERR "dav_get_socket: no socket\n");
+out_no_mem:
+	/*
+	if (!sb->u.davfs_sb.mnt)
+		printk(KERN_ERR "dav_read_super: allocation failure\n");
+	*/
+	goto out_fail;
+out_no_data:
+	printk(KERN_ERR "dav_read_super: missing data argument\n");
+out_fail:
+	return NULL;
+}
+
+static int
+dav_statfs(struct super_block *sb, struct statfs *buf)
+{
+    /*NetWare Server, because free space is distributed over
+      volumes, and the current user might have disk quotas. So
+      free space is not that simple to determine. Our decision
+      here is to err conservatively. */
+    
+    DEBUG1("here\n");
+
+    /* get statfs information from davfsd */
+    dav_proc_statfs(sb->s_root, buf);
+
+    return 0;
+}
+
+int
+dav_notify_change(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	struct dav_sb_info *server = dav_server_from_dentry(dentry);
+	struct dav_i_info *dii = DAV_INOP(inode);
+	unsigned int mask = (S_IFREG | S_IFDIR | S_IRWXU | S_IRWXG | S_IRWXO);
+	int error, changed, refresh = 0;
+	struct dav_fattr fattr;
+
+	TRACE();
+
+	error = dav_revalidate_inode(dentry);
+	if (error)
+		goto out;
+
+	if ((error = inode_change_ok(inode, attr)) < 0)
+		goto out;
+
+	error = -EPERM;
+	if ((attr->ia_valid & ATTR_UID) && (attr->ia_uid != server->uid))
+		goto out;
+
+	if ((attr->ia_valid & ATTR_GID) && (attr->ia_uid != server->gid))
+		goto out;
+
+	if ((attr->ia_valid & ATTR_MODE) && (attr->ia_mode & ~mask))
+		goto out;
+
+	if ((attr->ia_valid & ATTR_SIZE) != 0)
+	{
+		VERBOSE("changing %s/%s, old size=%ld, new size=%ld\n",
+			DENTRY_PATH(dentry),
+			(long) inode->i_size, (long) attr->ia_size);
+		error = dav_open(dentry, O_WRONLY);
+		if (error)
+			goto out;
+		error = dav_proc_trunc(server, dii->fileid,
+					 attr->ia_size);
+		if (error)
+			goto out;
+		vmtruncate(inode, attr->ia_size);
+		refresh = 1;
+	}
+
+	/*
+	 * Initialize the fattr and check for changed fields.
+	 * Note: CTIME under DAV is creation time rather than
+	 * change time, so we don't attempt to change it.
+	 */
+	dav_get_inode_attr(inode, &fattr);
+
+	changed = 0;
+	if ((attr->ia_valid & ATTR_MTIME) != 0)
+	{
+		fattr.f_mtime = attr->ia_mtime;
+		changed = 1;
+	}
+	if ((attr->ia_valid & ATTR_ATIME) != 0)
+	{
+		fattr.f_atime = attr->ia_atime;
+
+	}
+	if (changed)
+	{
+		error = dav_proc_setattr(dentry, &fattr);
+		if (error)
+			goto out;
+		refresh = 1;
+	}
+
+	/*
+	 * Check for mode changes ... we're extremely limited in
+	 * what can be set for DAV servers: just the read-only bit.
+	 */
+	if ((attr->ia_valid & ATTR_MODE) != 0)
+	{
+		VERBOSE("%s/%s mode change, old=%x, new=%x\n",
+			DENTRY_PATH(dentry), fattr.f_mode, attr->ia_mode);
+		changed = 0;
+		if (attr->ia_mode & S_IWUSR)
+		{
+			if (fattr.attr & aRONLY)
+			{
+				fattr.attr &= ~aRONLY;
+				changed = 1;
+			}
+		} else {
+			if (!(fattr.attr & aRONLY))
+			{
+				fattr.attr |= aRONLY;
+				changed = 1;
+			}
+		}
+		if (changed)
+		{
+			error = dav_proc_setattr(dentry, &fattr);
+			if (error)
+				goto out;
+			refresh = 1;
+		}
+	}
+	error = 0;
+
+out:
+	if (refresh)
+		dav_refresh_inode(dentry);
+	return error;
+}
+
+#ifdef DEBUG_DAV_MALLOC
+int dav_malloced;
+int dav_current_kmalloced;
+int dav_current_vmalloced;
+#endif
+
+static DECLARE_FSTYPE( dav_fs_type, "davfs", dav_read_super, 0);
+
+static int __init init_dav_fs(void)
+{
+	DEBUG1("registering ...\n");
+
+#ifdef DEBUG_DAV_MALLOC
+	dav_malloced = 0;
+	dav_current_kmalloced = 0;
+	dav_current_vmalloced = 0;
+#endif
+
+	return register_filesystem(&dav_fs_type);
+}
+
+static void __exit exit_dav_fs(void)
+{
+	DEBUG1("unregistering ...\n");
+	unregister_filesystem(&dav_fs_type);
+#ifdef DEBUG_DAV_MALLOC
+	printk(KERN_DEBUG "dav_malloced: %d\n", dav_malloced);
+	printk(KERN_DEBUG "dav_current_kmalloced: %d\n",dav_current_kmalloced);
+	printk(KERN_DEBUG "dav_current_vmalloced: %d\n",dav_current_vmalloced);
+#endif
+}
+
+EXPORT_NO_SYMBOLS;
+
+/* 
+** Added by Philipp Hahn (pmhahn)
+*/
+MODULE_AUTHOR("Sung Kim <hunkim@cs.ucsc.edu>");
+MODULE_DESCRIPTION("Web Distributed Authoring and Versioning Filesystem");
+MODULE_LICENSE("GPL");
+ 
+module_init(init_dav_fs)
+module_exit(exit_dav_fs)
diff -ruN linux/fs.orig/davfs/ioctl.c linux/fs/davfs/ioctl.c
--- linux/fs.orig/davfs/ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/ioctl.c	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ *  ioctl.c
+ *
+ *  Copyright (C) 1995, 1996 by Volker Lendecke
+ *  Copyright (C) 1997 by Volker Lendecke
+ *
+ *  Please add a note about your changes to davfs in the ChangeLog file.
+ */
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/highuid.h>
+#include <linux/smp_lock.h>
+#include <asm/uaccess.h>
+
+#include "davfs.h"
+
+int
+dav_ioctl(struct inode *inode, struct file *filp,
+	  unsigned int cmd, unsigned long arg)
+{
+    //	struct dav_sb_info *server = DAV_SERVER(inode);
+	//	struct dav_conn_opt opt;
+	int result = -EINVAL;
+	/*
+	switch (cmd) {
+	case DAV_IOC_GETMOUNTUID:
+		result = put_user(NEW_TO_OLD_UID(server->mnt->mounted_uid),
+				  (uid16_t *) arg);
+		break;
+	case DAV_IOC_GETMOUNTUID32:
+		result = put_user(server->mnt->mounted_uid, (uid_t *) arg);
+		break;
+
+	case DAV_IOC_NEWCONN:
+	    
+		if (!arg)
+			break;
+
+		result = -EFAULT;
+		if (!copy_from_user(&opt, (void *)arg, sizeof(opt)))
+			result = dav_newconn(server, &opt);
+		break;
+	default:
+	}
+	*/
+	return result;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -ruN linux/fs.orig/davfs/Makefile linux/fs/davfs/Makefile
--- linux/fs.orig/davfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/Makefile	2002-07-22 16:53:30.000000000 +0200
@@ -0,0 +1,38 @@
+#
+# Makefile for the linux smb-filesystem routines.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile...
+#
+# Modified by Sung Hun Kim <hunkim@kebi.com> for DAVfs
+# 
+
+
+O_TARGET := davfs.o
+
+obj-y   := proc.o dir.o cache.o sock.o inode.o file.o ioctl.o
+obj-m   := $(O_TARGET)
+
+# If you want debugging output, you may add these flags to the EXTRA_CFLAGS
+# SMBFS_PARANOIA should normally be enabled.
+
+EXTRA_CFLAGS += -DSMBFS_PARANOIA
+#EXTRA_CFLAGS += -DSMBFS_DEBUG
+#EXTRA_CFLAGS += -DSMBFS_DEBUG_VERBOSE
+#EXTRA_CFLAGS += -DDEBUG_SMB_MALLOC
+#EXTRA_CFLAGS += -DDEBUG_SMB_TIMESTAMP
+#EXTRA_CFLAGS += -Werror
+
+include $(TOPDIR)/Rules.make
+
+
+
+
+
+
+
+
+
diff -ruN linux/fs.orig/davfs/proc.c linux/fs/davfs/proc.c
--- linux/fs.orig/davfs/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/proc.c	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,980 @@
+ /*
+  *  proc.c
+  *
+  *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke
+  *  Copyright (C) 1997 by Volker Lendecke
+  *
+  *  Please add a note about your changes to davfs in the ChangeLog file.
+  */
+
+ #include <linux/types.h>
+ #include <linux/errno.h>
+ #include <linux/slab.h>
+ #include <linux/fs.h>
+ #include <linux/file.h>
+ #include <linux/stat.h>
+ #include <linux/fcntl.h>
+ #include <linux/dcache.h>
+ #include <linux/dirent.h>
+ #include <linux/ncp_no.h>
+ #include <linux/smp_lock.h>
+
+ #include <asm/string.h>
+
+ #include "davfs.h"
+ #include "dav_debug.h"
+
+ /* Features. Undefine if they cause problems, this should perhaps be a
+    config option. */
+ #define davFS_POSIX_UNLINK 1
+
+ /* Allow dav_retry to be interrupted. Not sure of the benefit ... */
+ /* #define dav_RETRY_INTR */
+
+ #define dav_DIRINFO_SIZE 43
+ #define dav_STATUS_SIZE  21
+
+
+ static inline void
+ dav_lock_server(struct dav_sb_info *server)
+ {
+     down(&(server->sem));
+ }
+
+ static inline void
+ dav_unlock_server(struct dav_sb_info *server)
+ {
+     up(&(server->sem));
+ }
+
+
+ /*
+  * Returns the maximum read or write size for the "payload". Making all of the
+  * packet fit within the negotiated max_xmit size.
+  *
+  * N.B. Since this value is usually computed before locking the server,
+  * the server's packet size must never be decreased!
+  */
+ static inline int
+ dav_get_xmitsize(struct dav_sb_info *server, int overhead)
+ {
+	 TRACE();
+	 return 4096;
+ }
+
+ /*
+  * Calculate the maximum read size
+  */
+ int
+ dav_get_rsize(struct dav_sb_info *server)
+ {
+     int overhead = 0;
+     int size = dav_get_xmitsize(server, overhead);
+
+     TRACE();
+
+     return size;
+ }
+
+/*
+ * Calculate the maximum write size
+ */
+int
+dav_get_wsize(struct dav_sb_info *server)
+{
+    int overhead = 0;
+    int size = dav_get_xmitsize(server, overhead);
+    
+    TRACE();
+    
+    return size;
+}
+
+static int
+dav_errno(int ret_code) 
+{
+    int result;
+    
+    //TRACE();
+    
+    switch(ret_code) {
+    case HTTP_OK:
+     case HTTP_CREATED:
+     case HTTP_ACCEPTED:
+     case HTTP_NO_CONTENT:
+     case HTTP_MULTI_STATUS:
+	 result = 0;
+	 break;
+
+     case HTTP_BAD_REQUEST:
+	 result = -EREMOTEIO;
+	 break;
+
+     case HTTP_NON_AUTHORITATIVE:
+     case HTTP_UNAUTHORIZED:
+     case HTTP_FORBIDDEN:
+     case HTTP_METHOD_NOT_ALLOWED:
+     case HTTP_NOT_ACCEPTABLE:	
+	 result = -EACCES;
+	 break;
+
+     case HTTP_NOT_FOUND:
+	 result =  -ENOENT;
+	 break;
+
+     case HTTP_INTERNAL_SERVER_ERROR:
+	 result =  -EFAULT;
+	 break;
+
+     default :
+	 result = -EIO;
+     }
+
+     DEBUG1("errno : %d\n", result);
+     return result;
+ }
+
+
+/* reverse a string inline. This is used by the dircache walking routines */
+static int reverse_string(char *buf, int len)
+{
+    char c;
+    char *end = buf+len-1;
+    
+    while(buf < end) {
+	c = *buf;
+	*(buf++) = *end;
+	*(end--) = c;
+    }
+    return len;
+}
+
+
+/*
+** atoi
+*/
+int dav_atoi(char *digit) {
+    int ret=0;
+    int i = (strlen(digit)-1);
+    double weight=1;
+    
+    for(;i;i--)
+        weight*=10;
+    
+    for(;*digit;digit++, weight/=10) {
+        if(!weight)
+            weight = 1;
+	
+        if(*digit-'0'>=0 && *digit-'0' <=9)
+            ret+=weight*(*digit-'0');
+    }
+    
+    return ret;
+}
+
+
+/*
+** clear buff 
+*/
+void
+dav_clear_sbuf(struct dav_sb_info *server) {
+    int ret;
+    TRACE();
+    
+    while((ret= _recvfrom(server->sock, 
+			  server->buf, DAV_MAXPATHLEN, MSG_DONTWAIT))>0)
+	;
+}
+
+
+static inline int
+dav_is_open(struct inode *i)
+{
+    struct dav_i_info *dii = DAV_INOP(i);
+    TRACE();
+    DEBUG1("IS OPEN : %d\n", dii->open);
+
+    return dii->open;
+}
+
+/*
+ * general request 
+ * server->req : request body, should fill out
+ * server->length : need to read or something 
+ * return error number, 0 on sucess 
+ */
+int dav_request(struct dav_sb_info *server, int count, const char *data) {
+    int result = -EIO;
+    char *ret_code, *ret_length;
+    
+    /* clear socket like flush */
+    dav_clear_sbuf(server);
+
+    DEBUG1("req: %s\n", server->req);
+    
+    /* 
+    ** send request 
+    ** request should be filled before calling this function
+    */
+    if(dav_sendline_raw(server->sock, server->req)<0)
+	goto out;
+
+    /* send data if have*/
+    if(count)
+	result=dav_send_raw(server->sock, (unsigned char *)data, count);
+    
+    /* read 20bytes head from socket */
+    if(dav_readline_raw(server, server->buf, DAV_HEAD_SIZE)<0) 
+	goto out;
+    
+    /* parse head data */
+    ret_code = strtok(server->buf, " \t\n\r");
+    ret_length = strtok(NULL, " \t\n\r");
+    
+    if(!ret_code || !ret_length)
+	goto out;
+
+    server->length = dav_atoi(ret_length);
+    result =  dav_errno(dav_atoi(ret_code));
+    
+ out:
+    return result;
+}
+
+/*
+ * smb_build_path: build the path to entry and name storing it in buf.
+ * The path returned will have the trailing '\0'.
+ */
+static int dav_build_path(struct dav_sb_info *server, char * buf,
+			   struct dentry * entry, char *base_path)
+{
+    char *path = buf;
+    int ret = strlen(base_path);
+    
+    TRACE();
+    
+    /* memset */
+    memset(buf, 0x00, DAV_MAXPATHLEN);
+
+    if (!entry) 
+	return 0;
+    
+    /*
+      * Build the path string walking the tree backward from end to ROOT
+      * and store it in reversed order [see reverse_string()]
+      */
+#define ALPHA_COM_LEN 50
+    for (;!IS_ROOT(entry);entry = entry->d_parent) {
+	if (strlen(path) + 
+	    entry->d_name.len + ret + ALPHA_COM_LEN > DAV_MAXPATHLEN)
+	    return -ENAMETOOLONG;
+	
+	reverse_string((char*)entry->d_name.name, entry->d_name.len);
+	strncpy(path, entry->d_name.name, entry->d_name.len);
+	reverse_string((char*)entry->d_name.name, entry->d_name.len);
+	
+	path+=entry->d_name.len;
+	*path++='/';
+    }
+    
+    reverse_string(base_path, ret);
+    strncpy(path, base_path, ret);
+    reverse_string(base_path, ret);
+    path+=ret;
+    
+    reverse_string(buf, path-buf);
+    
+    return path-buf;
+}
+
+ /*
+  * We're called with the server locked, and we leave it that way.
+  *
+  * get whole file from http and save it.
+  * return file id.
+  */
+int
+dav_proc_open(struct dav_sb_info *server, struct dentry *dentry, int wish)
+{
+     struct inode *ino = dentry->d_inode;
+     struct dav_i_info *dii = DAV_INOP(ino);
+     int result=-EIO;
+     mm_segment_t fs;
+     
+     TRACE();
+     
+     fs = get_fs();
+     set_fs(get_ds());
+
+     /* make path */
+     dav_build_path(server, server->buf, dentry, server->path);
+
+      /* make open request */
+     sprintf(server->req, "open\t%s\t%d", server->buf, wish);
+     
+     result = dav_request(server, 0, NULL);
+     if(result<0) 
+	 goto out;
+     
+     dii->fileid = server->length;
+     dii->open++;
+     DEBUG2("PROC_FILEID = %ld\n", dii->fileid);
+     
+ out:
+     set_fs(fs);
+     
+     return result;
+}
+
+ /*
+  *
+  */
+int
+dav_proc_read(struct inode  *inode, off_t offset, int count, char *data)
+{
+    int result = -EIO;
+    struct dav_sb_info *server = dav_server_from_inode(inode);
+    struct dav_i_info *dii = DAV_INOP(inode);
+    mm_segment_t fs;
+    
+    TRACE();
+    
+    dav_lock_server(server);
+
+    fs = get_fs();
+    set_fs(get_ds());
+    
+    sprintf(server->req, "read\t%ld\t%ld:%d", 
+	    dii->fileid, offset, count);
+    
+    result = dav_request(server, 0, NULL);
+    if(result<0) 
+	goto out;
+    
+    if(server->length) 
+	result=dav_receive_raw(server->sock, data, server->length);
+ out:
+    set_fs(fs);
+    dav_unlock_server(server);
+    return result;
+}
+
+int
+dav_proc_write(struct inode *inode, off_t offset, int count, const char *data)
+{
+    int result = -EIO;
+    struct dav_i_info *dii = DAV_INOP(inode);
+    struct dav_sb_info *server = dav_server_from_inode(inode);
+    mm_segment_t fs;
+    
+    TRACE();
+
+    dav_lock_server(server);
+    
+    fs = get_fs();
+    set_fs(get_ds());
+        
+    /* make write command */
+    sprintf(server->req, "write\t%ld\t%ld:%d", 
+	    dii->fileid, offset, count);
+    
+    /* do request */
+    result = dav_request(server, count, data);
+    
+    set_fs(fs);
+    dav_unlock_server(server);
+    return result;
+}
+
+/*
+** create file
+** we should not use dav_i_info->fileid, here.
+** just pass to *fileid
+** 
+** dav_inisiate will crate dav_i_info with fileid
+**
+*/
+int
+dav_proc_create(struct dentry *dentry, __u16 attr, time_t ctime, long *fileid)
+{
+    struct dav_sb_info *server = dav_server_from_dentry(dentry);
+    int result=-EIO;
+    mm_segment_t fs;
+    
+    TRACE();
+    
+    dav_lock_server(server);
+
+    fs = get_fs();
+    set_fs(get_ds());
+    
+    /* make path */
+    dav_build_path(server, server->buf, dentry, server->path);
+    
+    sprintf(server->req, "create\t%s", server->buf);
+    
+    result = dav_request(server, 0, NULL);
+    if(result<0) 
+	goto out;
+    
+    *fileid = server->length;
+    DEBUG2("PROC_FILEID = %ld\n", *fileid);
+    
+ out:
+    set_fs(fs);
+    dav_unlock_server(server);
+
+    return result;
+}
+
+int
+dav_proc_mv(struct dentry *old_dentry, struct dentry *new_dentry)
+{
+    struct dav_sb_info *server = dav_server_from_dentry(old_dentry);
+    int result=-EIO;
+    mm_segment_t fs;
+    
+    TRACE();
+  
+    dav_lock_server(server);
+  
+    fs = get_fs();
+    set_fs(get_ds());
+    
+    /* make command with old path */
+    dav_build_path(server, server->buf, old_dentry, server->path);
+    
+    sprintf(server->req, "mv\t%s\t", server->buf);
+    
+    /* meke destination path */
+    dav_build_path(server, server->buf, new_dentry, server->path);
+    
+    strcat(server->req, server->buf);
+    
+    result = dav_request(server, 0, NULL);
+
+    set_fs(fs);
+    dav_unlock_server(server);
+    return result;
+}
+
+int
+dav_proc_mkdir(struct dentry *dentry)
+{
+    struct dav_sb_info *server = dav_server_from_dentry(dentry);
+    int result=-EIO;
+    mm_segment_t fs;
+    
+    TRACE();
+   
+    dav_lock_server(server);
+ 
+    fs = get_fs();
+    set_fs(get_ds());
+    
+    /* make path */
+    result  = dav_build_path(server, server->buf, dentry, server->path);
+    
+    result = -EIO;
+    
+    sprintf(server->req, "mkdir\t%s", server->buf);
+    
+    result = dav_request(server, 0, NULL);
+
+    set_fs(fs);
+    dav_unlock_server(server);
+    return result;
+
+}
+
+int
+dav_proc_rmdir(struct dentry *dentry)
+{
+    struct dav_sb_info *server = dav_server_from_dentry(dentry);
+    int result=-EIO;
+    mm_segment_t fs;
+    
+    TRACE();
+    
+    dav_lock_server(server);
+
+    fs = get_fs();
+    set_fs(get_ds());
+    
+    dav_build_path(server, server->buf, dentry, server->path);
+    
+    sprintf(server->req, "rmdir\t%s", server->buf);
+        
+    result = dav_request(server, 0, NULL);
+    
+    set_fs(fs);
+    dav_unlock_server(server);
+    return result;
+}
+
+
+int
+dav_proc_unlink(struct dentry *dentry)
+{
+    struct dav_sb_info *server = dav_server_from_dentry(dentry);
+    int result=-EIO;
+    mm_segment_t fs;
+    
+    TRACE();
+
+    dav_lock_server(server);
+    
+    fs = get_fs();
+    set_fs(get_ds());
+    
+    /* make path */
+    dav_build_path(server, server->buf, dentry, server->path);
+    sprintf(server->req, "unlink\t%s", server->buf);
+
+    result = dav_request(server, 0, NULL);
+
+    set_fs(fs);
+    dav_unlock_server(server);
+    return result;
+}
+
+
+int
+dav_proc_trunc(struct dav_sb_info *server, long fid, __u32 length)
+{
+    int result=0;
+    mm_segment_t fs;    
+    TRACE();
+
+    dav_lock_server(server);
+
+    fs = get_fs();
+    set_fs(get_ds());
+
+    sprintf(server->req, "trunc\t%ld\t%d", fid, length);
+    result = dav_request(server, 0, NULL);
+    
+    DEBUG1("TRUNC FID : %ld LENGHT: %d\n", fid, length);
+    
+    dav_unlock_server(server);
+    return result;
+}
+
+static void
+dav_init_dirent(struct dav_sb_info *server, struct dav_fattr *fattr)
+{
+	memset(fattr, 0, sizeof(struct dav_fattr));
+	TRACE();
+
+	fattr->f_nlink = 1;
+	fattr->f_uid = server->uid;
+	fattr->f_gid = server->gid;
+	fattr->f_blksize = 4096;
+
+        DEBUG1("UID : %d(%d)\n", server->uid, server->gid);
+}
+
+static void
+dav_finish_dirent(struct dav_sb_info *server, struct dav_fattr *fattr)
+{
+	TRACE();
+	fattr->f_mode = server->file_mode;
+
+	if (fattr->attr & aDIR)
+	{
+	    fattr->f_mode = server->dir_mode;
+	    fattr->f_size = 512;
+	} else {
+	    /* normal file mode */
+	    fattr->f_mode &= ~(S_IXGRP | S_IXOTH);
+        }
+	
+	/* no write permission for user */
+	if(fattr->f_gid) {
+	    fattr->f_mode &= ~S_IWOTH | S_IXGRP;
+	} else {
+	    fattr->f_mode &= ~(S_IWGRP | S_IWOTH);
+	}
+
+	/* Check the read-only flag */
+	if (fattr->attr & aRONLY)
+	    fattr->f_mode &= ~(S_IWUSR | S_IWGRP | S_IWOTH);
+	
+	fattr->f_blocks = 0;
+	if ((fattr->f_blksize != 0) && (fattr->f_size != 0)) {
+	    fattr->f_blocks =
+	      (fattr->f_size - 1) / fattr->f_blksize + 1;
+	}
+	return;
+}
+
+void
+dav_init_root_dirent(struct dav_sb_info *server, struct dav_fattr *fattr)
+{
+	TRACE();
+	dav_init_dirent(server, fattr);
+	fattr->attr = aDIR;
+	fattr->f_ino = 2; /* traditional root inode number */
+	fattr->f_mtime = CURRENT_TIME;
+	dav_finish_dirent(server, fattr);
+}
+
+
+int
+dav_proc_fill_fattr(struct dav_finfo *finfo, struct dav_fattr *fattr) {
+
+    fattr->f_size  = finfo->f_size;    
+    fattr->f_atime = finfo->f_atime;
+    fattr->f_mtime = finfo->f_mtime;
+    fattr->f_ctime = finfo->f_ctime;
+
+    if(finfo->f_isdir) 
+	fattr->attr = aDIR;
+    return 0;
+}
+
+
+int
+dav_proc_fill_finfo( struct dav_fattr *fattr, struct dav_finfo *finfo) {
+
+    finfo->f_size  = fattr->f_size;    
+    finfo->f_atime = fattr->f_atime;
+    finfo->f_mtime = fattr->f_mtime;
+    finfo->f_ctime = fattr->f_ctime;
+
+    if(fattr->attr == aDIR) 
+	finfo->f_isdir = 1; 
+    return 0;
+}
+
+
+/* findfirst/findnext flags */
+#define dav_CLOSE_AFTER_FIRST (1<<0)
+#define dav_CLOSE_IF_END (1<<1)
+#define dav_REQUIRE_RESUME_KEY (1<<2)
+#define dav_CONTINUE_BIT (1<<3)
+
+int
+dav_proc_readdir(struct file *filp, void *dirent, filldir_t filldir,
+		 struct dav_cache_control *ctl)
+{
+    struct dentry *dir = filp->f_dentry;
+    struct dav_sb_info *server = dav_server_from_dentry(dir);
+    struct dav_fattr fattr;
+    struct dav_finfo finfo;
+    int ff_searchcount = 0;
+    int i, result=-EIO;
+    mm_segment_t fs;
+    static struct qstr star = { "*", 1, 0 };
+    
+    TRACE();
+    
+    dav_lock_server(server);
+
+    fs = get_fs();
+    set_fs(get_ds());
+
+    /* make ls command */
+    dav_build_path(server, server->buf, dir, server->path);
+    sprintf(server->req, "ls\t%s", server->buf);
+    result = dav_request(server, 0, NULL);
+    if(result<0) 
+	goto out;
+
+    ff_searchcount = server->length/sizeof(finfo);
+    
+    /* no result , go home */
+    if(!ff_searchcount) 
+	goto out;
+    
+    for(i=0, result=0;i<ff_searchcount;i++) {
+	memset(&finfo, 0x00, sizeof(finfo));
+	
+	/* read finfo */
+	if(dav_receive_raw(server->sock, (unsigned char*)&finfo, sizeof(finfo))<0)
+	    goto out;
+	
+	if(!finfo.f_name_len) {
+	    continue;
+	}
+
+	star.name = finfo.f_name;
+	star.len  = finfo.f_name_len;
+	
+	dav_init_dirent(server, &fattr);
+	
+	/* fill fattr using finfo */
+	dav_proc_fill_fattr(&finfo, &fattr);
+	
+	dav_finish_dirent(server, &fattr);
+	
+	if (!dav_fill_cache(filp, dirent, filldir, ctl, 
+			    &star, &fattr))
+	    result++;
+    }
+ out:
+    dav_unlock_server(server);
+    set_fs(fs);
+    return result;	    
+}
+
+int
+dav_proc_getattr(struct dentry *dir, struct dav_fattr *fattr)
+{
+    struct dav_sb_info *server = dav_server_from_dentry(dir);
+    struct dav_finfo finfo;
+    mm_segment_t fs;
+    int result = -EIO;
+
+    TRACE();
+
+    dav_lock_server(server);
+    
+    fs = get_fs();
+    set_fs(get_ds());
+
+    dav_build_path(server, server->buf, dir, server->path);
+    sprintf(server->req, "attr\t%s", server->buf);
+    
+    result = dav_request(server, 0, NULL);
+    if(result<0) 
+	goto out;
+    
+    /* read finfo */
+    if(dav_receive_raw(server->sock, (unsigned char*)&finfo, server->length)<0)
+	goto out;
+    
+    /* init */
+    dav_init_dirent(server, fattr);
+    
+    /* fill fattr using finfo */
+    dav_proc_fill_fattr(&finfo, fattr);
+
+    /* finish dirent */
+    dav_finish_dirent(server, fattr);
+    
+ out:
+    dav_unlock_server(server);
+    set_fs(fs);
+    return result;
+}
+
+/*
+**
+ */
+int
+dav_proc_setattr(struct dentry *dir, struct dav_fattr *fattr)
+{
+    struct dav_sb_info *server = dav_server_from_dentry(dir);
+    struct dav_finfo finfo;
+    mm_segment_t fs;
+    int result = -EIO;
+    
+    TRACE();
+
+    dav_lock_server(server);
+
+    fs = get_fs();
+    set_fs(get_ds());
+
+    /* fill finfo using fattr */
+    dav_proc_fill_finfo(fattr, &finfo);
+    
+    dav_build_path(server, server->buf, dir, server->path);
+    sprintf(server->req, "setattr\t%s\t%d", server->buf, sizeof(finfo));
+    
+    result = dav_request(server, sizeof(finfo), (char*)&finfo);
+        
+    set_fs(fs);
+    dav_unlock_server(server);
+    return result;
+}
+
+int
+dav_proc_disconnect(struct dav_sb_info *server)
+{
+    mm_segment_t fs;
+    int result = -EIO;
+    
+    TRACE();
+    
+    dav_lock_server(server);
+    
+    fs = get_fs();
+    set_fs(get_ds());
+
+    sprintf(server->req, "quit");
+    result = dav_request(server, 0, NULL);
+        
+    set_fs(fs);
+    dav_unlock_server(server);
+
+    return result;
+}
+
+
+int
+dav_close(struct inode *ino)
+{
+    struct dav_sb_info *server = dav_server_from_inode(ino);
+    struct dav_i_info *dii = DAV_INOP(ino);
+    int result=0;
+    mm_segment_t fs;
+    
+    TRACE();
+
+    dav_lock_server(server);
+
+    /* not open */
+    if (!dav_is_open(ino) || !dii->fileid) 
+	goto ret;
+
+    result=-EIO;
+ 
+    fs = get_fs();
+    set_fs(get_ds());
+    
+    sprintf(server->req, "close\t%ld", dii->fileid);
+    result = dav_request(server, 0, NULL);
+    
+    set_fs(fs);
+    
+    /*  
+    dii->fileid = 0;
+    */
+    dii->open = 0;
+
+ret:
+    dav_unlock_server(server);
+    
+    return result;
+}
+
+/*
+ * This is used to close a file following a failed instantiate.
+ * Since we don't have an inode, we can't use any of the above.
+ */
+int
+dav_close_fileid(struct dentry *dentry, long fileid)
+{
+    int result= 0;
+    struct dav_i_info *dii = DAV_INOP(dentry->d_inode);
+    struct dav_sb_info *server = dav_server_from_dentry(dentry);
+    mm_segment_t fs;
+    
+    TRACE();
+
+    dav_lock_server(server);
+
+    /* not open */
+    if (!dii->open || !fileid) 
+	goto ret;
+
+    result=-EIO;
+ 
+    fs = get_fs();
+    set_fs(get_ds());
+    
+    sprintf(server->req, "close\t%ld", fileid);
+    result = dav_request(server, 0, NULL);
+    
+    set_fs(fs);
+    
+    dii->open = 0;
+
+ret:
+    dav_unlock_server(server);
+    return result;
+}
+
+
+int
+dav_open(struct dentry *dentry, int wish)
+{
+    struct inode *inode = dentry->d_inode;
+    int result;
+    TRACE();
+    
+    result = -ENOENT;
+    if (!inode) {   
+	printk(KERN_ERR "dav_open: no inode for dentry %s/%s\n",
+	       DENTRY_PATH(dentry));
+	goto out;
+    }
+    
+    if (!dav_is_open(inode)) {
+	struct dav_sb_info *server = DAV_SERVER(inode);
+	dav_lock_server(server);
+	result = 0;
+	if (!dav_is_open(inode))
+	    result = dav_proc_open(server, dentry, wish);
+	dav_unlock_server(server);
+	if (result) {
+	    PARANOIA("%s/%s open failed, result=%d\n",
+		     DENTRY_PATH(dentry), result);
+	    goto out;
+	}
+	/*
+	 * A successful open means the path is still valid ...
+	 */
+	 dav_renew_times(dentry);
+    }
+    
+    /*
+     * Check whether the access is compatible with the desired mode.
+     */
+    result = 0;
+ 
+ out:
+    return result;
+}
+
+
+int
+dav_proc_statfs(struct dentry *dentry, struct statfs *buf)
+{
+    struct dav_sb_info *server = dav_server_from_dentry(dentry);
+    struct dav_statfs ds;
+    int result=-EIO;
+    mm_segment_t fs;
+    
+    TRACE();
+
+    /* reset a ds struct */
+    memset(&ds, 0x00, sizeof(ds));
+
+    dav_lock_server(server);
+  
+    fs = get_fs();
+    set_fs(get_ds());
+    
+    /* make command with old path */
+    dav_build_path(server, server->buf, dentry, server->path);
+    
+    sprintf(server->req, "statfs\t%s\t", server->buf);
+    result = dav_request(server, 0, NULL);
+
+    
+    if(result) {
+	/* On error , set default value */
+
+	buf->f_blocks = 0;
+	buf->f_bfree = 0;
+	buf->f_bavail = 0;
+    } else {
+	if(server->length) 
+	    result=dav_receive_raw(server->sock, (void*)&ds, server->length);
+	buf->f_blocks = ds.f_blocks;
+	buf->f_bavail = buf->f_bfree = ds.f_bfree; 
+    }
+
+    buf->f_bsize = 4098;
+    buf->f_namelen = 256;
+    set_fs(fs);
+    dav_unlock_server(server);
+    
+    /* Always return OK */ 
+    return 0;
+}
+
+
diff -ruN linux/fs.orig/davfs/sock.c linux/fs/davfs/sock.c
--- linux/fs.orig/davfs/sock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/fs/davfs/sock.c	2002-07-22 16:34:11.000000000 +0200
@@ -0,0 +1,302 @@
+/*
+ *  sock.c
+ *
+ *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke
+ *  Copyright (C) 1997 by Volker Lendecke
+ *
+ *  Please add a note about your changes to davfs in the ChangeLog file.
+ */
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/socket.h>
+#include <linux/fcntl.h>
+#include <linux/file.h>
+#include <linux/in.h>
+#include <linux/net.h>
+#include <linux/mm.h>
+#include <linux/netdevice.h>
+#include <linux/smp_lock.h>
+#include <net/scm.h>
+#include <net/ip.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+
+#include "davfs.h"
+#include "dav_debug.h"
+
+
+int
+_recvfrom(struct socket *socket, unsigned char *ubuf, int size,
+	  unsigned flags)
+{
+	struct iovec iov;
+	struct msghdr msg;
+	struct scm_cookie scm;
+
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+	iov.iov_base = ubuf;
+	iov.iov_len = size;
+	
+	memset(&scm, 0,sizeof(scm));
+	size=socket->ops->recvmsg(socket, &msg, size, flags, &scm);
+	if(size>=0)
+		scm_recv(socket,&msg,&scm,flags);
+	return size;
+}
+
+static int
+_send(struct socket *socket, const void *buff, int len)
+{
+	struct iovec iov;
+	struct msghdr msg;
+	struct scm_cookie scm;
+	int err;
+
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	
+	iov.iov_base = (void *)buff;
+	iov.iov_len = len;
+
+	msg.msg_flags = 0;
+
+	err = scm_send(socket, &msg, &scm);
+        if (err >= 0)
+	{
+		err = socket->ops->sendmsg(socket, &msg, len, &scm);
+		scm_destroy(&scm);
+	}
+	return err;
+}
+
+struct data_callback {
+	struct tq_struct cb;
+	struct sock *sk;
+};
+
+
+/*
+ * get socket struct 
+ * from mount's fd
+ *
+ * return NULL, if fail
+ */
+struct socket *
+dav_get_sock(struct dav_sb_info *server, unsigned int fd)
+{
+    struct inode *sock_inode;
+    
+    server->sock_file = fget(fd);
+    if(!server->sock_file) 
+	return NULL;
+    
+    sock_inode = server->sock_file->f_dentry->d_inode;
+    if(!S_ISSOCK(sock_inode->i_mode)) {
+	fput(server->sock_file);
+	return NULL;
+    }
+    
+    server->sock = &sock_inode->u.socket_i;
+    if(!server->sock) 
+	fput(server->sock_file);
+
+    return server->sock;
+}
+
+
+/*
+ * Called with the server locked.
+ */
+void
+dav_close_socket(struct dav_sb_info *server)
+{
+    struct file * file = server->sock_file;
+    
+    if (file) {
+	server->sock_file = NULL;
+	fput(file);
+    }
+}
+
+int
+dav_send_raw(struct socket *socket, unsigned char *source, int length)
+{
+	int result;
+	int already_sent = 0;
+
+	while (already_sent < length)
+	{
+		result = _send(socket,
+			       (void *) (source + already_sent),
+			       length - already_sent);
+
+		if (result == 0)
+		{
+			return -EIO;
+		}
+		if (result < 0)
+		{
+			DEBUG1("dav_send_raw: sendto error = %d\n", -result);
+			return result;
+		}
+		already_sent += result;
+	}
+	return already_sent;
+}
+
+int
+dav_receive_raw(struct socket *socket, unsigned char *target, int length)
+{
+	int result;
+	int already_read = 0;
+
+	while (already_read < length)
+	{
+	    result = _recvfrom(socket,
+			       (void *) (target + already_read),
+			       length - already_read, 0);
+	    if (result == 0)
+	      {
+		  return -EIO;
+	      }
+	    if (result < 0)
+	      {
+		  DEBUG1("recvfrom error = %d\n", -result);
+			return result;
+	      }
+	    already_read += result;
+	}
+	return already_read;
+}
+
+
+int do_tcp_rcv(struct dav_sb_info *server, void *buffer, size_t len) {
+    poll_table wait_table;
+    struct socket *sock = server->sock;
+    int init_timeout=10;
+    size_t dataread;
+    int result = 0;
+    
+    dataread = 0;
+    /*
+    init_timeout = server->m.time_out * 20;
+    */
+    /* hard-mounted volumes have no timeout, except connection close... */
+    /*
+    if (!(server->m.flags & NCP_MOUNT_SOFT))
+	init_timeout = 0x7FFF0000;
+    */
+    while (len) {
+	poll_initwait(&wait_table);
+	/* mb() is not necessary because ->poll() will serialize
+	   instructions adding the wait_table waitqueues in the
+	   waitqueue-head before going to calculate the mask-retval. */
+	__set_current_state(TASK_INTERRUPTIBLE);
+	if (!(sock->ops->poll(server->sock_file, sock, &wait_table) & POLLIN)) {
+	    init_timeout = schedule_timeout(init_timeout);
+	    poll_freewait(&wait_table);
+	    current->state = TASK_RUNNING;
+	    if (signal_pending(current)) {
+		return -ERESTARTSYS;
+	    }
+	    if (!init_timeout) {
+		return -EIO;
+	    }
+	    if(wait_table.error) {
+		return wait_table.error;
+	    }
+	} else {
+	    poll_freewait(&wait_table);
+	}
+	current->state = TASK_RUNNING;
+	
+	result = _recvfrom(sock, buffer, len, MSG_DONTWAIT);
+	if (result < 0) {
+	    if (result == -EAGAIN) {
+		DEBUG1("ncpfs: tcp: bad select ready\n");
+		continue;
+	    }
+	    return result;
+	}
+	if (result == 0) {
+	    printk(KERN_ERR "ncpfs: tcp: EOF on socket\n");
+	    return -EIO;
+	}
+	if (result > len) {
+	    printk(KERN_ERR "ncpfs: tcp: bug in recvmsg\n");
+	    return -EIO;			
+	}
+	dataread += result;
+	buffer += result;
+	len -= result;
+    }
+    return 0;
+}	
+
+int
+dav_sendline_raw(struct socket *socket, unsigned char *target) {
+    int ret = 0;
+    ret+=dav_send_raw(socket, target, strlen(target));
+    ret+=dav_send_raw(socket, "\r\n", 2);
+
+    return ret;
+}
+									   
+int
+dav_readline_tcp(struct dav_sb_info *server, unsigned char *target, int length) {
+    int ret = 0;
+    int ch;
+    
+    for(ret=0;ret<length && do_tcp_rcv(server, &ch, 1)>0; ret++) {
+	if(ch=='\r') {
+	    /* read '\n' */
+	    do_tcp_rcv(server, &ch, 1);
+	    break;
+	}
+	*target++=ch;
+    }   
+
+    *target = 0;
+
+    return ret;
+}
+									   
+int
+dav_readline_raw(struct dav_sb_info *server, unsigned char *target, int length) {
+    int ret = 0;
+    unsigned char ch;
+    
+    for(ret=0;ret<length && dav_receive_raw(server->sock, &ch, 1)>0; ret++) {
+	if(ch=='\r' && ch=='\n') {
+	    /* read '\n' */
+	    //dav_receive_raw(server->sock, &ch, 1);
+	    break;
+	}
+	*target++=ch;
+    }   
+
+    *target = 0;
+
+    return ret;
+}
+									   
+
+
+
+
+
+
+
+
+
+
+
diff -ruN linux/fs.orig/Makefile linux/fs/Makefile
--- linux/fs.orig/Makefile	2002-07-22 16:50:53.000000000 +0200
+++ linux/fs/Makefile	2002-07-22 17:23:36.000000000 +0200
@@ -49,6 +49,7 @@
 subdir-$(CONFIG_SYSV_FS)	+= sysv
 subdir-$(CONFIG_SMB_FS)		+= smbfs
 subdir-$(CONFIG_NCP_FS)		+= ncpfs
+subdir-$(CONFIG_DAV_FS)		+= davfs
 subdir-$(CONFIG_HPFS_FS)	+= hpfs
 subdir-$(CONFIG_NTFS_FS)	+= ntfs
 subdir-$(CONFIG_UFS_FS)		+= ufs
