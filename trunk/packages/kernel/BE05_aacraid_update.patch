diff -Nru a/drivers/scsi/aacraid/aachba.c b/drivers/scsi/aacraid/aachba.c
--- a/drivers/scsi/aacraid/aachba.c	Wed Sep  3 23:31:58 2003
+++ b/drivers/scsi/aacraid/aachba.c	Wed Sep  3 23:31:58 2003
@@ -221,9 +221,7 @@
 static unsigned long aac_build_sg(Scsi_Cmnd* scsicmd, struct sgmap* sgmap);
 static unsigned long aac_build_sg64(Scsi_Cmnd* scsicmd, struct sgmap64* psg);
 static int aac_send_srb_fib(Scsi_Cmnd* scsicmd);
-#ifdef AAC_DETAILED_STATUS_INFO
 static char *aac_get_status_string(u32 status);
-#endif
 
 /*
  *	Non dasd selection is handled entirely in aachba now
@@ -231,8 +229,11 @@
  
 MODULE_PARM(nondasd, "i");
 MODULE_PARM_DESC(nondasd, "Control scanning of hba for nondasd devices. 0=off, 1=on");
+MODULE_PARM(paemode, "i");
+MODULE_PARM_DESC(paemode, "Control whether dma addressing is using PAE. 0=off, 1=on");
 
 static int nondasd = -1;
+static int paemode = -1;
 
 /**
  *	aac_get_containers	-	list containers
@@ -298,6 +299,64 @@
 }
 
 /**
+ *	aac_get_container_name	-	get container name
+ */
+static int aac_get_container_name(struct aac_dev *dev, int cid, char * pid)
+{
+	struct fsa_scsi_hba *fsa_dev_ptr;
+	int status = 0;
+	struct aac_get_name *dinfo;
+	struct aac_get_name_resp *dresp;
+	struct fib * fibptr;
+	unsigned instance;
+
+	fsa_dev_ptr = &(dev->fsa_dev);
+	instance = dev->scsi_host_ptr->unique_id;
+
+	if (!(fibptr = fib_alloc(dev)))
+		return -ENOMEM;
+
+	fib_init(fibptr);
+	dinfo = (struct aac_get_name *) fib_data(fibptr);
+
+	dinfo->command = cpu_to_le32(VM_ContainerConfig);
+	dinfo->type = cpu_to_le32(CT_READ_NAME);
+	dinfo->cid = cpu_to_le32(cid);
+	dinfo->count = cpu_to_le32(sizeof(((struct aac_get_name_resp *)NULL)->data));
+
+	status = fib_send(ContainerCommand,
+			    fibptr,
+			    sizeof (struct aac_get_name),
+			    FsaNormal,
+			    1, 1,
+			    NULL, NULL);
+	if (status < 0 ) {
+		printk(KERN_WARNING "aac_get_container_name: SendFIB failed.\n");
+	} else {
+		dresp = (struct aac_get_name_resp *)fib_data(fibptr);
+
+		status = (le32_to_cpu(dresp->status) != CT_OK)
+		      || (dresp->data[0] == '\0');
+		if (status == 0) {
+			char * sp = dresp->data;
+			char * dp = pid;
+			do {
+				if ((*sp == '\0')
+				 || ((dp - pid) >= sizeof(((struct aac_get_name_resp *)NULL)->data))) {
+					*dp = ' ';
+				} else {
+					*dp = *sp++;
+				}
+			} while (++dp < &pid[sizeof(((struct inquiry_data *)NULL)->inqd_pid)]);
+		}
+	}
+	fib_complete(fibptr);
+	fib_free(fibptr);
+	fsa_dev[instance] = fsa_dev_ptr;
+	return status;
+}
+
+/**
  *	probe_container		-	query a logical volume
  *	@dev: device to query
  *	@cid: container identifier
@@ -569,8 +628,10 @@
 	if( (sizeof(dma_addr_t) > 4) && (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64)){
 		dev->pae_support = 1;
 	}
-	/* TODO - dmb temporary until fw can set this bit  */
-	dev->pae_support = (BITS_PER_LONG >= 64);
+
+	if(paemode != -1)
+		dev->pae_support = (paemode != 0);
+
 	if(dev->pae_support != 0) 
 	{
 		printk(KERN_INFO "%s%d: 64 Bit PAE enabled\n", dev->name, dev->id);
@@ -997,7 +1058,6 @@
 		memset(inq_data_ptr, 0, sizeof (struct inquiry_data));
 
 		inq_data_ptr->inqd_ver = 2;	/* claim compliance to SCSI-2 */
-		inq_data_ptr->inqd_dtq = 0x80;	/* set RMB bit to one indicating that the medium is removable */
 		inq_data_ptr->inqd_rdf = 2;	/* A response data format value of two indicates that the data shall be in the format specified in SCSI-2 */
 		inq_data_ptr->inqd_len = 31;
 		/*Format for "pad2" is  RelAdr | WBus32 | WBus16 |  Sync  | Linked |Reserved| CmdQue | SftRe */
@@ -1006,11 +1066,14 @@
 		 *	Set the Vendor, Product, and Revision Level
 		 *	see: <vendor>.c i.e. aac.c
 		 */
-		setinqstr(cardtype, (void *) (inq_data_ptr->inqd_vid), fsa_dev_ptr->type[cid]);
-		if (scsicmd->target == scsicmd->host->this_id)
+		if (scsicmd->target == scsicmd->host->this_id) {
+			setinqstr(cardtype, (void *) (inq_data_ptr->inqd_vid), (sizeof(container_types)/sizeof(char *)));
 			inq_data_ptr->inqd_pdt = INQD_PDT_PROC;	/* Processor device */
-		else
+		} else {
+			setinqstr(cardtype, (void *) (inq_data_ptr->inqd_vid), fsa_dev_ptr->type[cid]);
+			aac_get_container_name(dev, cid, inq_data_ptr->inqd_pid);
 			inq_data_ptr->inqd_pdt = INQD_PDT_DA;	/* Direct/random access device */
+		}
 		scsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | GOOD;
 		__aac_io_done(scsicmd);
 		return 0;
@@ -1123,7 +1186,7 @@
 				SENKEY_ILLEGAL, SENCODE_INVALID_COMMAND,
 			ASENCODE_INVALID_COMMAND, 0, 0, 0, 0);
 			__aac_io_done(scsicmd);
-			return -1;
+			return 0;
 	}
 }
 
@@ -1425,9 +1488,7 @@
 	case SRB_STATUS_FORCE_ABORT:
 	case SRB_STATUS_DOMAIN_VALIDATION_FAIL:
 	default:
-#ifdef AAC_DETAILED_STATUS_INFO
 		printk("aacraid: SRB ERROR(%u) %s scsi cmd 0x%x - scsi status 0x%x\n",le32_to_cpu(srbreply->srb_status&0x3f),aac_get_status_string(le32_to_cpu(srbreply->srb_status)), scsicmd->cmnd[0], le32_to_cpu(srbreply->scsi_status) );
-#endif
 		scsicmd->result = DID_ERROR << 16 | COMMAND_COMPLETE << 8;
 		break;
 	}
@@ -1525,7 +1586,7 @@
 		/*
 		 *	Build Scatter/Gather list
 		 */
-		fibsize = sizeof (struct aac_srb) + (((srbcmd->sg.count & 0xff) - 1) * sizeof (struct sgentry64));
+		fibsize = sizeof (struct aac_srb) - sizeof (struct sgentry) + ((srbcmd->sg.count & 0xff) * sizeof (struct sgentry64));
 
 		/*
 		 *	Now send the Fib to the adapter
@@ -1686,8 +1747,6 @@
 	return byte_count;
 }
 
-#ifdef AAC_DETAILED_STATUS_INFO
-
 struct aac_srb_status_info {
 	u32	status;
 	char	*str;
@@ -1742,4 +1801,3 @@
 	return "Bad Status Code";
 }
 
-#endif
diff -Nru a/drivers/scsi/aacraid/aacraid.h b/drivers/scsi/aacraid/aacraid.h
--- a/drivers/scsi/aacraid/aacraid.h	Wed Sep  3 23:31:58 2003
+++ b/drivers/scsi/aacraid/aacraid.h	Wed Sep  3 23:31:58 2003
@@ -1,3 +1,6 @@
+#define AAC_DRIVER_VERSION		0x01010300
+#define AAC_DRIVER_BUILD_DATE		__DATE__ " " __TIME__
+
 //#define dprintk(x) printk x
 #if (!defined(dprintk))
 # define dprintk(x)
@@ -759,7 +762,7 @@
 	 */	
 	dma_addr_t		hw_fib_pa;
 	struct hw_fib		*hw_fib_va;
-	ulong			fib_base_va;
+	struct hw_fib		*aif_base_va;
 	/*
 	 *	Fib Headers
 	 */
@@ -1176,6 +1179,31 @@
 	u32	   	type;           /* should be same as that requested */
 	u32		count;
 	struct aac_mntent mnt[1];
+};
+
+#define CT_READ_NAME 130
+struct aac_get_name {
+	u32		command;
+	u32		type;	// CT_READ_NAME
+	u32		cid;
+	u32		parm1;
+	u32		parm2;
+	u32		parm3;
+	u32		parm4;
+	u32		count;	// sizeof(((struct aac_get_name_resp *)NULL)->data)
+};
+
+#define CT_OK        218
+struct aac_get_name_resp {
+	u32		dummy0;
+	u32		dummy1;
+	u32		status;	// CT_OK
+	u32		parm1;
+	u32		parm2;
+	u32		parm3;
+	u32		parm4;
+	u32		parm5;
+	u8		data[16];
 };
 
 /*
diff -Nru a/drivers/scsi/aacraid/commctrl.c b/drivers/scsi/aacraid/commctrl.c
--- a/drivers/scsi/aacraid/commctrl.c	Wed Sep  3 23:31:58 2003
+++ b/drivers/scsi/aacraid/commctrl.c	Wed Sep  3 23:31:58 2003
@@ -362,7 +362,7 @@
  *	@dev: adapter
  *	@arg: ioctl arguments
  *
- *	This routine returns the firmware version.
+ *	This routine returns the driver version.
  *      Under Linux, there have been no version incompatibilities, so this is simple!
  */
 
@@ -371,14 +371,223 @@
 	struct revision response;
 
 	response.compat = 1;
-	response.version = dev->adapter_info.kernelrev;
-	response.build = dev->adapter_info.kernelbuild;
+	response.version = AAC_DRIVER_VERSION;
+	response.build = 9999;
 
 	if (copy_to_user(arg, &response, sizeof(response)))
 		return -EFAULT;
 	return 0;
 }
 
+/**
+ *
+ * aac_send_raw_scb
+ *
+ */
+
+int aac_send_raw_srb(struct aac_dev* dev, void* arg)
+{
+	struct fib* srbfib;
+	int status;
+	struct aac_srb *srbcmd;
+	struct aac_srb *user_srb = arg;
+	struct aac_srb_reply* user_reply;
+	struct aac_srb_reply* reply;
+	u32 fibsize = 0;
+	u32 flags = 0;
+	s32 rcode = 0;
+	u32 data_dir;
+	ulong sg_user[32];
+	ulong sg_list[32];
+	u32   sg_indx = 0;
+	u32 byte_count = 0;
+	u32 actual_fibsize = 0;
+	int i;
+
+
+	if (!capable(CAP_SYS_ADMIN)){
+		printk(KERN_DEBUG"aacraid: No permission to send raw srb\n"); 
+		return -EPERM;
+	}
+	/*
+	 *	Allocate and initialize a Fib then setup a BlockWrite command
+	 */
+	if (!(srbfib = fib_alloc(dev))) {
+		return -1;
+	}
+	fib_init(srbfib);
+
+	srbcmd = (struct aac_srb*) fib_data(srbfib);
+
+	if(copy_from_user((void*)&fibsize, (void*)&user_srb->count,sizeof(u32))){
+		printk(KERN_DEBUG"aacraid: Could not copy data size from user\n"); 
+		rcode = -EFAULT;
+		goto cleanup;
+	}
+
+	if(copy_from_user(srbcmd, user_srb,fibsize)){
+		printk(KERN_DEBUG"aacraid: Could not copy srb from user\n"); 
+		rcode = -EFAULT;
+		goto cleanup;
+	}
+
+	user_reply = arg+fibsize;
+
+	flags = srbcmd->flags;
+	// Fix up srb for endian and force some values
+	srbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);	// Force this
+	srbcmd->channel  = cpu_to_le32(srbcmd->channel);
+	srbcmd->target   = cpu_to_le32(srbcmd->target);
+	srbcmd->lun      = cpu_to_le32(srbcmd->lun);
+	srbcmd->flags    = cpu_to_le32(srbcmd->flags);
+	srbcmd->timeout  = cpu_to_le32(srbcmd->timeout);
+	srbcmd->retry_limit =cpu_to_le32(0); // Obsolete parameter
+	srbcmd->cdb_size = cpu_to_le32(srbcmd->cdb_size);
+
+	switch(srbcmd->flags & (SRB_DataIn | SRB_DataOut)){
+	case SRB_DataOut:
+		data_dir = SCSI_DATA_WRITE;
+		break;
+	case (SRB_DataIn | SRB_DataOut):
+		data_dir = SCSI_DATA_UNKNOWN;  
+		break;
+	case SRB_DataIn:
+		data_dir = SCSI_DATA_READ;
+		break;
+	default:
+		data_dir = SCSI_DATA_NONE;
+	}
+	
+	if( dev->pae_support ==1 ) {
+		struct sgmap64* psg = (struct sgmap64*)&srbcmd->sg;
+		byte_count = 0;
+
+		// This should also catch if user used the 32 bit sgmap
+		actual_fibsize = sizeof (struct aac_srb) + (((srbcmd->sg.count & 0xff) - 1) * sizeof (struct sgentry64));
+		if(actual_fibsize != fibsize){ // User made a mistake - should not continue
+			printk(KERN_DEBUG"aacraid: Bad Size specified in Raw SRB command\n");
+			rcode = -EINVAL;
+			goto cleanup;
+		}
+		if ((data_dir == SCSI_DATA_NONE) && psg->count) { // Dogs and cats sleeping with eachother - should not continue
+			printk(KERN_DEBUG"aacraid: SG with no direction specified in Raw SRB command\n");
+			rcode = -EINVAL;
+			goto cleanup;
+		}
+
+		for (i = 0; i < psg->count; i++) {
+			dma_addr_t addr; 
+			u64 le_addr;
+			void* p;
+			p = kmalloc(psg->sg[i].count,GFP_KERNEL|__GFP_DMA);
+			if(p == 0) {
+				printk(KERN_DEBUG"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",
+				psg->sg[i].count,i,psg->count);
+				rcode = -ENOMEM;
+				goto cleanup;
+			}
+			sg_user[i] = (ulong)psg->sg[i].addr;
+			sg_list[i] = (ulong)p; // save so we can clean up later
+			sg_indx = i + 1;
+
+			if( flags & SRB_DataOut ){
+				if(copy_from_user(p,psg->sg[i].addr,psg->sg[i].count)){
+					printk(KERN_DEBUG"aacraid: Could not copy sg data from user\n"); 
+					rcode = -EFAULT;
+					goto cleanup;
+				}
+			}
+			addr = pci_map_single(dev->pdev, p, psg->sg[i].count, scsi_to_pci_dma_dir(data_dir));
+
+			le_addr = cpu_to_le64(addr);
+			psg->sg[i].addr[1] = (u32)(le_addr>>32);
+			psg->sg[i].addr[0] = (u32)(le_addr & 0xffffffff);
+			psg->sg[i].count = cpu_to_le32(psg->sg[i].count);  
+			byte_count += psg->sg[i].count;
+		}
+
+		srbcmd->count = cpu_to_le32(byte_count);
+		status = fib_send(ScsiPortCommand64, srbfib, actual_fibsize, FsaNormal, 1, 1,0,0);
+	} else {
+		struct sgmap* psg = &srbcmd->sg;
+		byte_count = 0;
+
+		actual_fibsize = sizeof (struct aac_srb) + (((srbcmd->sg.count & 0xff) - 1) * sizeof (struct sgentry));
+		if(actual_fibsize != fibsize){ // User made a mistake - should not continue
+			printk(KERN_DEBUG"aacraid: Bad Size specified in Raw SRB command\n");
+			rcode = -EINVAL;
+			goto cleanup;
+		}
+		if ((data_dir == SCSI_DATA_NONE) && psg->count) { // Dogs and cats sleeping with eachother - should not continue
+			printk(KERN_DEBUG"aacraid: SG with no direction specified in Raw SRB command\n");
+			rcode = -EINVAL;
+			goto cleanup;
+		}
+		for (i = 0; i < psg->count; i++) {
+			dma_addr_t addr; 
+			void* p;
+			p = kmalloc(psg->sg[i].count,GFP_KERNEL);
+			if(p == 0) {
+				printk(KERN_DEBUG"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",
+				psg->sg[i].count,i,psg->count);
+				rcode = -ENOMEM;
+				goto cleanup;
+			}
+			sg_user[i] = (ulong)(psg->sg[i].addr);
+			sg_list[i] = (ulong)p; // save so we can clean up later
+			sg_indx = i + 1;
+
+			if( flags & SRB_DataOut ){
+				if(copy_from_user((void*)p,(void*)(ulong)(psg->sg[i].addr),psg->sg[i].count)){
+					printk(KERN_DEBUG"aacraid: Could not copy sg data from user\n"); 
+					rcode = -EFAULT;
+					goto cleanup;
+				}
+			}
+			addr = pci_map_single(dev->pdev, p, psg->sg[i].count, scsi_to_pci_dma_dir(data_dir));
+
+			psg->sg[i].addr = cpu_to_le32(addr);
+			psg->sg[i].count = cpu_to_le32(psg->sg[i].count);  
+			byte_count += psg->sg[i].count;
+		}
+		srbcmd->count = cpu_to_le32(byte_count);
+		status = fib_send(ScsiPortCommand, srbfib, actual_fibsize, FsaNormal, 1, 1, 0, 0);
+	}
+
+	if (status != 0){
+		printk(KERN_DEBUG"aacraid: Could not send raw srb fib to hba\n"); 
+		rcode = -1;
+		goto cleanup;
+	}
+
+	if( flags & SRB_DataIn ) {
+		for(i = 0 ; i < sg_indx; i++){
+			if(copy_to_user((void*)(sg_user[i]),(void*)(sg_list[i]),le32_to_cpu(srbcmd->sg.sg[i].count))){
+				printk(KERN_DEBUG"aacraid: Could not copy sg data to user\n"); 
+				rcode = -EFAULT;
+				goto cleanup;
+
+			}
+		}
+	}
+
+	reply = (struct aac_srb_reply *) fib_data(srbfib);
+	if(copy_to_user(user_reply,reply,sizeof(struct aac_srb_reply))){
+		printk(KERN_DEBUG"aacraid: Could not copy reply to user\n"); 
+		rcode = -EFAULT;
+		goto cleanup;
+	}
+
+cleanup:
+	for(i=0; i < sg_indx; i++){
+		kfree((void*)sg_list[i]);
+	}
+	fib_complete(srbfib);
+	fib_free(srbfib);
+
+	return rcode;
+}
+
 
 struct aac_pci_info {
         u32 bus;
@@ -426,6 +635,9 @@
 		break;
 	case FSACTL_CLOSE_GET_ADAPTER_FIB:
 		status = close_getadapter_fib(dev, arg);
+		break;
+	case FSACTL_SEND_RAW_SRB:
+		status = aac_send_raw_srb(dev,arg);
 		break;
 	case FSACTL_GET_PCI_INFO:
 		status = aac_get_pci_info(dev,arg);
diff -Nru a/drivers/scsi/aacraid/comminit.c b/drivers/scsi/aacraid/comminit.c
--- a/drivers/scsi/aacraid/comminit.c	Wed Sep  3 23:31:58 2003
+++ b/drivers/scsi/aacraid/comminit.c	Wed Sep  3 23:31:58 2003
@@ -84,14 +84,14 @@
 	 *	Adapter Fibs are the first thing allocated so that they
 	 *	start page aligned
 	 */
-	dev->fib_base_va = (ulong)base;
+	dev->aif_base_va = (struct hw_fib *)base;
 
 	/* We submit the physical address for AIF tags to limit to 32 bits */
-	init->AdapterFibsVirtualAddress = cpu_to_le32((u32)phys);
+	init->AdapterFibsVirtualAddress = cpu_to_le32(0);
 	init->AdapterFibsPhysicalAddress = cpu_to_le32((u32)phys);
 	init->AdapterFibsSize = cpu_to_le32(fibsize);
 	init->AdapterFibAlign = cpu_to_le32(sizeof(struct hw_fib));
-	init->HostPhysMemPages = cpu_to_le32(num_physpages);		// number of 4k pages of host physical memory
+	init->HostPhysMemPages = cpu_to_le32((num_physpages << PAGE_SHIFT) / 4096);		// number of 4k pages of host physical memory
 
 	/*
 	 * Increment the base address by the amount already used
diff -Nru a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c
--- a/drivers/scsi/aacraid/commsup.c	Wed Sep  3 23:31:58 2003
+++ b/drivers/scsi/aacraid/commsup.c	Wed Sep  3 23:31:58 2003
@@ -203,7 +203,7 @@
 	hw_fib->header.StructType = FIB_MAGIC;
 	hw_fib->header.Size = cpu_to_le16(sizeof(struct hw_fib));
 	hw_fib->header.XferState = cpu_to_le32(HostOwned | FibInitialized | FibEmpty | FastResponseCapable);
-	hw_fib->header.SenderFibAddress = cpu_to_le32(fibptr->hw_fib_pa);
+	hw_fib->header.SenderFibAddress = 0; /* Filled in later if needed */
 	hw_fib->header.ReceiverFibAddress = cpu_to_le32(fibptr->hw_fib_pa);
 	hw_fib->header.SenderSize = cpu_to_le16(sizeof(struct hw_fib));
 }
@@ -450,8 +450,7 @@
 	 *	Map the fib into 32bits by using the fib number
 	 */
 
-//	hw_fib->header.SenderFibAddress = ((u32)(fibptr-dev->fibs)) << 1;
-	hw_fib->header.SenderFibAddress = cpu_to_le32((u32)(ulong)fibptr->hw_fib_pa);
+	hw_fib->header.SenderFibAddress = cpu_to_le32(((u32)(fibptr - dev->fibs)) << 1);
 	hw_fib->header.SenderData = (u32)(fibptr - dev->fibs);
 	/*
 	 *	Set FIB state to indicate where it came from and if we want a
@@ -792,7 +791,6 @@
 	struct aac_aifcmd * aifcmd = (struct aac_aifcmd *)hw_fib->data;
 	int busy;
 	u32 container;
-	mm_segment_t fs;
 
 	/* Sniff for container changes */
 	dprintk ((KERN_INFO "AifCmdDriverNotify=%x\n", le32_to_cpu(*(u32 *)aifcmd->data)));
@@ -859,18 +857,24 @@
 		 * go away. We need to check the access_count for the
 		 * device since we are not wanting the devices to go away.
 		 */
-		if (busy == 0 && proc_scsi != NULL) {
+		if ((busy == 0)
+		 && (proc_scsi != (struct proc_dir_entry *)NULL)) {
 			struct proc_dir_entry * entry;
 
 			dprintk((KERN_INFO "proc_scsi=%p ", proc_scsi));
-			for (entry = proc_scsi->subdir; entry != (struct proc_dir_entry *)NULL; entry = entry->next) {
+			for (entry = proc_scsi->subdir;
+			  entry != (struct proc_dir_entry *)NULL;
+			  entry = entry->next) {
 				dprintk(("\"%.*s\"[%d]=%x ", entry->namelen,
 				  entry->name, entry->namelen, entry->low_ino));
-				if ((entry->low_ino != 0) && (entry->namelen == 4) && (memcmp ("scsi", entry->name, 4) == 0)) {
+				if ((entry->low_ino != 0)
+				 && (entry->namelen == 4)
+				 && (memcmp ("scsi", entry->name, 4) == 0)) {
 					dprintk(("%p->write_proc=%p ", entry, entry->write_proc));
 					if (entry->write_proc != (int (*)(struct file *, const char *, unsigned long, void *))NULL) {
 						char buffer[80];
 						int length;
+						mm_segment_t fs;
 
 						sprintf (buffer,
 						  "scsi add-single-device %d %d %d %d\n",
@@ -879,12 +883,17 @@
 						  CONTAINER_TO_TARGET(container),
 						  CONTAINER_TO_LUN(container));
 						length = strlen (buffer);
-						dprintk((KERN_INFO "echo %.*s > /proc/scsi/scsi\n", length-1, buffer));
+						dprintk((KERN_INFO
+						  "echo %.*s > /proc/scsi/scsi\n",
+						  length-1,
+						  buffer));
 						fs = get_fs();
 						set_fs(get_ds());
-						length = entry->write_proc(NULL, buffer, length, NULL);
+						length = entry->write_proc(
+						  NULL, buffer, length, NULL);
 						set_fs(fs);
-						dprintk((KERN_INFO "returns %d\n", length));
+						dprintk((KERN_INFO
+						  "returns %d\n", length));
 					}
 					break;
 				}
diff -Nru a/drivers/scsi/aacraid/dpcsup.c b/drivers/scsi/aacraid/dpcsup.c
--- a/drivers/scsi/aacraid/dpcsup.c	Wed Sep  3 23:31:58 2003
+++ b/drivers/scsi/aacraid/dpcsup.c	Wed Sep  3 23:31:58 2003
@@ -74,12 +74,12 @@
 	 */
 	while(aac_consumer_get(dev, q, &entry))
 	{
-		u32 fast ;
-		fast = (entry->addr & cpu_to_le32(0x01));
-//		fib = &dev->fibs[(entry->addr >> 1)];
-//		hwfib = fib->hw_fib;
-		hwfib = bus_to_virt(le32_to_cpu(entry->addr & cpu_to_le32(~0x01)));
-		fib = &dev->fibs[hwfib->header.SenderData];
+		int fast;
+		u32 index;
+		index = le32_to_cpu(entry->addr);
+		fast = index & 0x01;
+		fib = &dev->fibs[index >> 1];
+		hwfib = fib->hw_fib;
 
 		aac_consumer_free(dev, q, HostNormRespQueue);
 		/*
@@ -178,13 +178,12 @@
 	while(aac_consumer_get(dev, q, &entry))
 	{
 		struct fib fibctx;
+		struct hw_fib * hw_fib;
+		u32 index;
 		struct fib *fib = &fibctx;
-		u32 hw_fib_pa = le32_to_cpu(entry->addr & cpu_to_le32(~0x01));
-		struct hw_fib * hw_fib_va = ((dev->comm_phys <= hw_fib_pa)
-		 && (hw_fib_pa < (dev->comm_phys + dev->comm_size)))
-		  ? dev->comm_addr + (hw_fib_pa - dev->comm_phys)
-		  : /* inconceivable */ bus_to_virt(hw_fib_pa);
-		dprintk((KERN_INFO "hw_fib_pa=%x hw_fib_va=%p\n", hw_fib_pa, hw_fib_va));
+
+		index = le32_to_cpu(entry->addr / sizeof(struct hw_fib));
+		hw_fib = &dev->aif_base_va[index];
 
 		/*
 		 *	Allocate a FIB at all costs. For non queued stuff
@@ -199,8 +198,8 @@
 		INIT_LIST_HEAD(&fib->fiblink);
 		fib->type = FSAFS_NTC_FIB_CONTEXT;
 		fib->size = sizeof(struct fib);
-		fib->hw_fib = hw_fib_va;
-		fib->data = hw_fib_va->data;
+		fib->hw_fib = hw_fib;
+		fib->data = hw_fib->data;
 		fib->dev = dev;
 		
 		if (dev->aif_thread && fib != &fibctx)
@@ -214,7 +213,7 @@
 			/*
 			 *	Set the status of this FIB
 			 */
-			*(u32 *)hw_fib_va->data = cpu_to_le32(ST_OK);
+			*(u32 *)hw_fib->data = cpu_to_le32(ST_OK);
 			fib_adapter_complete(fib, sizeof(u32));
 			spin_lock_irqsave(q->lock, flags);
 		}		
diff -Nru a/drivers/scsi/aacraid/linit.c b/drivers/scsi/aacraid/linit.c
--- a/drivers/scsi/aacraid/linit.c	Wed Sep  3 23:31:58 2003
+++ b/drivers/scsi/aacraid/linit.c	Wed Sep  3 23:31:58 2003
@@ -35,9 +35,6 @@
  *	
  */
 
-#define AAC_DRIVER_VERSION		"1.1.2"
-#define AAC_DRIVER_BUILD_DATE		__DATE__ " " __TIME__
-
 #include <linux/module.h>
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -56,15 +53,11 @@
 #include "aacraid.h"
 #include "sd.h"
 
-#define AAC_DRIVERNAME	"aacraid"
+#define AAC_DRIVER_NAME	"aacraid"
 
 MODULE_AUTHOR("Red Hat Inc and Adaptec");
 MODULE_DESCRIPTION("Supports Dell PERC2, 2/Si, 3/Si, 3/Di, Adaptec Advanced Raid Products, and HP NetRAID-4M devices. http://domsch.com/linux/ or http://linux.adaptec.com");
 MODULE_LICENSE("GPL");
-MODULE_PARM(paemode, "i");
-MODULE_PARM_DESC(paemode, "Control whether dma addressing is using PAE. 0=off, 1=on");
-
-static int paemode = -1;
 
 struct aac_dev *aac_devices[MAXIMUM_NUM_ADAPTERS];
 
@@ -107,15 +100,19 @@
 	{ 0x9005, 0x0285, 0x9005, 0x0292, aac_rx_init, "aacraid",  "ADAPTEC ", "AAR-2810SA SATA ", 2 }, 		/* AAR-2810SA PCI SATA 8ch (Corsair-8) */
 	{ 0x9005, 0x0285, 0x9005, 0x0293, aac_rx_init, "aacraid",  "ADAPTEC ", "AAR-21610SA SATA ", 2 },		/* AAR-21610SA PCI SATA 16ch (Corsair-16) */
 	{ 0x9005, 0x0285, 0x9005, 0x0294, aac_rx_init, "aacraid",  "ADAPTEC ", "SO-DIMM SATA ZCR ", 2 },		/* ESD SO-DIMM PCI-X SATA ZCR (Prowler) */
-	/* ServeRAID */
-/*	{ 0x9005, 0x0250, 0x1014, 0x0279, aac_rx_init, "aacraid",  "ADAPTEC ", "Adaptec         ", 2 }, */ /*  (Marco) */
-/*	{ 0x9005, 0x0250, 0x1014, 0x028c, aac_rx_init, "aacraid",  "ADAPTEC ", "Adaptec         ", 2 }, */ /* (Sebring)*/
+	{ 0x9005, 0x0285, 0x0E11, 0x0295, aac_rx_init, "aacraid",  "ADAPTEC ", "SATA 6Channel   ", 1 }, 		/* SATA 6Ch (Bearcat) */
 
 	{ 0x9005, 0x0285, 0x1028, 0x0287, aac_rx_init, "percraid", "DELL    ", "PERC 320/DC     ", 2 },			/* Perc 320/DC*/
 	{ 0x1011, 0x0046, 0x9005, 0x0365, aac_sa_init, "aacraid",  "ADAPTEC ", "Adaptec 5400S   ", 4 }, 		/* Adaptec 5400S (Mustang)*/
 	{ 0x1011, 0x0046, 0x9005, 0x0364, aac_sa_init, "aacraid",  "ADAPTEC ", "AAC-364         ", 4 },			/* Adaptec 5400S (Mustang)*/
 	{ 0x1011, 0x0046, 0x9005, 0x1364, aac_sa_init, "percraid", "DELL    ", "PERCRAID        ", 4 },			/* Dell PERC2 "Quad Channel" */
-	{ 0x1011, 0x0046, 0x103c, 0x10c2, aac_sa_init, "hpnraid",  "HP      ", "NetRAID         ", 4 }			/* HP NetRAID-4M */
+	{ 0x1011, 0x0046, 0x103c, 0x10c2, aac_sa_init, "hpnraid",  "HP      ", "NetRAID         ", 4 },			/* HP NetRAID-4M */
+	{ 0x9005, 0x0285, 0x1028, PCI_ANY_ID,
+					  aac_rx_init, "aacraid",  "DELL    ", "RAID            ", 2, AAC_QUIRK_31BIT },/* Dell Catchall */
+	{ 0x9005, 0x0285, 0x17aa, PCI_ANY_ID,
+					  aac_rx_init, "aacraid",  "Legend  ", "RAID            ", 2, AAC_QUIRK_31BIT },/* Legend Catchall */
+	{ 0x9005, 0x0285, PCI_ANY_ID, PCI_ANY_ID,
+					  aac_rx_init, "aacraid",  "ADAPTEC ", "RAID            ", 2, AAC_QUIRK_31BIT } /* Adaptec Catch All */
 };
 
 #define NUM_AACTYPES	(sizeof(aac_drivers) / sizeof(struct aac_driver_ident))
@@ -175,9 +172,15 @@
 	struct fsa_scsi_hba *fsa_dev_ptr;
 	char *name = NULL;
 	
-	printk(KERN_INFO "Red Hat/Adaptec aacraid driver (%s %s)\n", AAC_DRIVER_VERSION, AAC_DRIVER_BUILD_DATE);
-
+	printk(KERN_INFO "Red Hat/Adaptec %s driver (%d.%d-%d %s)\n",
+		AAC_DRIVER_NAME,
+		AAC_DRIVER_VERSION >> 24,
+		(AAC_DRIVER_VERSION >> 16) & 0xFF,
+		(AAC_DRIVER_VERSION >> 8) & 0xFF,
+		AAC_DRIVER_BUILD_DATE);
+		
 	/* setting up the proc directory structure */
+	
 	template->proc_name = "aacraid";
 	spin_unlock_irq(&io_request_lock);
 
@@ -607,7 +610,7 @@
 
 static int aac_eh_reset(Scsi_Cmnd* cmd)
 {
-	printk(KERN_ERR "aacraid: Host adapter reset request. SCSI hang ?\n");
+	printk(KERN_ERR "%s: Host adapter reset request. SCSI hang ?\n", AAC_DRIVER_NAME);
 	return FAILED;
 }
 
@@ -741,13 +744,41 @@
 static int aac_procinfo(char *proc_buffer, char **start_ptr,off_t offset,
 			int bytes_available, int host_no, int write)
 {
+	struct aac_dev * dev;
+	int index, ret, tmp;
+
 	if(write || offset > 0)
 		return 0;
 	*start_ptr = proc_buffer;
-	return sprintf(proc_buffer,
-	  "Adaptec Raid Controller %s %s, scsi hba number %d\n",
-	  AAC_DRIVER_VERSION, AAC_DRIVER_BUILD_DATE,
-	  host_no);
+	ret = sprintf(proc_buffer,
+		  "Adaptec Raid Controller %d.%d-%d %s, scsi hba number %d\n",
+		  AAC_DRIVER_VERSION >> 24,
+		  (AAC_DRIVER_VERSION >> 16) & 0xFF,
+		  (AAC_DRIVER_VERSION >> 8) & 0xFF,
+		  AAC_DRIVER_BUILD_DATE,
+		  host_no);
+	for (index = 0; index < aac_count; ++index) {
+		if (((dev = aac_devices[index]) != NULL) && dev->scsi_host_ptr->host_no == host_no)
+			break;
+	}
+	if (index >= aac_count || dev == NULL)
+		return ret;
+	tmp = dev->adapter_info.kernelrev;
+	ret += sprintf(proc_buffer + ret, "kernel: %d.%d-%d[%d]\n", 
+		tmp >> 24, (tmp >> 16) & 0xff, (tmp >> 8) & 0xff,
+		dev->adapter_info.kernelbuild);
+	tmp = dev->adapter_info.monitorrev;
+	ret += sprintf(proc_buffer + ret, "monitor: %d.%d-%d[%d]\n", 
+		tmp >> 24, (tmp >> 16) & 0xff, (tmp >> 8) & 0xff,
+		dev->adapter_info.monitorbuild);
+	tmp = dev->adapter_info.biosrev;
+	ret += sprintf(proc_buffer + ret, "bios: %d.%d-%d[%d]\n", 
+		tmp >> 24, (tmp >> 16) & 0xff, (tmp >> 8) & 0xff,
+		dev->adapter_info.biosbuild);
+	ret += sprintf(proc_buffer + ret, "serial: %x%x\n",
+		dev->adapter_info.serial[0],
+		dev->adapter_info.serial[1]);
+	return ret;
 }
 
 EXPORT_NO_SYMBOLS;
