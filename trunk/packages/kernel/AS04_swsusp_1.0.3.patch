diff -ruN swsusp-1.0.2/drivers/char/keyboard.c swsusp-1.0.3/drivers/char/keyboard.c
--- swsusp-1.0.2/drivers/char/keyboard.c	2003-07-19 20:39:35.000000000 +1200
+++ swsusp-1.0.3/drivers/char/keyboard.c	2003-07-19 20:39:38.000000000 +1200
@@ -315,7 +315,7 @@
 				break;
 #endif
 		}
-		if (keycode != 42)
+		if ((keycode != 42) & (keycode != 58))
 			goto out;
 	}
 #endif
diff -ruN swsusp-1.0.2/include/linux/suspend-debug.h swsusp-1.0.3/include/linux/suspend-debug.h
--- swsusp-1.0.2/include/linux/suspend-debug.h	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/include/linux/suspend-debug.h	2003-07-19 20:39:38.000000000 +1200
@@ -6,7 +6,7 @@
 
 #define name_suspend "Suspend Machine:  "
 #define name_resume  "Resume Machine:   "
-#define swsusp_version "1.0.2-2_4_21"
+#define swsusp_version "1.0.3"
 #define name_swsusp  "Swsusp " swsusp_version ": "
 #define console_suspend " S U S P E N D   T O   D I S K " /* Same length to ensure one overwrites the other */
 #define console_resume  "R E S U M E   F R O M   D I S K"
@@ -60,6 +60,7 @@
 #define SUSPEND_CHECKSUMS	8
 #define SUSPEND_SWAP		9
 #define SUSPEND_MEMORY		10
+#define SUSPEND_RANGES		11
 /* debugging levels - if debugging compiled in.
  * These are straight integer values, not bit flags.
  * (Stored as LEVEL << 16 + section_flags).
@@ -73,15 +74,14 @@
 #define NO_OUTPUT_OR_PAUSING ((fg_console != suspend_console) || \
 		(TEST_ACTION_STATE(SUSPEND_NO_OUTPUT)))
 
-void printnolog(int mask, int level, int restartline, const char *fmt, ...);
-void printlog(int mask, int level, const char *fmt, ...);
 #define CHECKMASK(mask) (((!mask) || TEST_DEBUG_STATE(mask)) && (!NO_OUTPUT_OR_PAUSING))
 /* 
  *   #defs that are dependant on CONFIG_SOFTWARE_SUSPEND_DEBUG
  *
  */
 #if defined(CONFIG_SOFTWARE_SUSPEND_DEBUG)
-
+void printnolog(int mask, int level, int restartline, const char *fmt, ...);
+void printlog(int mask, int level, const char *fmt, ...);
 #define MDELAY(a)	if (TEST_ACTION_STATE(SUSPEND_SLOW)) { mdelay(a); } else { do { } while (0); }
 #define beepOK \
 	if (TEST_ACTION_STATE(SUSPEND_BEEP)) { \
@@ -100,6 +100,8 @@
 	} 
 
 #else // #ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+#define printnolog(...) do { } while(0)
+#define printlog(...) do { } while(0)
 #define MDELAY(a) do { } while (0)
 #define beepOK do { } while (0)
 #define beepERR do { } while (0)
diff -ruN swsusp-1.0.2/include/linux/suspend.h swsusp-1.0.3/include/linux/suspend.h
--- swsusp-1.0.2/include/linux/suspend.h	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/include/linux/suspend.h	2003-07-19 20:39:38.000000000 +1200
@@ -34,6 +34,23 @@
 #define PRINTPREEMPTCOUNT(desn) do { } while(0)
 #endif
 
+struct rangechain {
+	struct range * first;
+	int size; /* size of the range ie sum (max-min+1) */
+	int allocs;
+	int frees;
+	int debug;
+	int timesusedoptimisation;
+	char * name;
+	struct range * lastaccessed, *prevtolastaccessed, *prevtoprev;
+};
+
+struct range {
+	unsigned long minimum;
+	unsigned long maximum;
+	struct range * next;
+};
+
 /* page backup entry */
 typedef struct pbe {
 	struct page * origaddress;	/* 4: original address of pageset entry */
@@ -57,6 +74,11 @@
 	struct pbe *data;
 	struct pbe *first_allocated;	/* Shortcut to first pbe in pageset 2 where extra pages
 					   were allocated */
+	struct rangechain origranges;
+	struct rangechain destranges;
+	struct rangechain swapranges;
+	struct rangechain blockranges;
+	struct rangechain allocdranges;
 } suspend_pagedir_t;
 
 struct pbelink {
diff -ruN swsusp-1.0.2/kernel/suspend/common.h swsusp-1.0.3/kernel/suspend/common.h
--- swsusp-1.0.2/kernel/suspend/common.h	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/kernel/suspend/common.h	2003-07-19 20:39:38.000000000 +1200
@@ -138,6 +138,7 @@
 extern int try_to_free_pages_zone_swsusp(zone_t *classzone, unsigned int gfp_mask, int priority, int nr_pages);
 extern int try_to_free_pages_swsusp(unsigned int gfp_mask, int amount_needed);
 extern char log_buf[];
+extern void si_swapinfo_devsonly(struct sysinfo *val);
 
 #ifdef CONFIG_PREEMPT
 #define swsusp_spin_lock_irq(lock) { \
@@ -253,3 +254,36 @@
 #define SWAP_NEEDED (pageset1_size + pageset2_size + pagedir1_size + 1)
 #define RAM_TO_SUSPEND (pagedir1_size + pagedir2_size + 1 + MAX((pageset1_size - pageset2_sizelow), 0) + MIN_FREE_RAM + REAL_MAX_ASYNC)
 #define RAM_TO_RESUME  ((pageset1_size + pagedir1_size) * 2 + 8 + MIN_FREE_RAM + (long) max_mapnr - orig_mem_free + REAL_MAX_ASYNC)
+
+/* --------- Range chains ----------- */
+
+#define RANGES_PER_PAGE (PAGE_SIZE / (sizeof(struct range)))
+#define RANGE_PAGES_NEEDED(x) (((x)+RANGES_PER_PAGE-1)/RANGES_PER_PAGE)
+
+#define range_for_each(rangechain, rangepointer, value) \
+	for (rangepointer = rangechain->first, value = rangepointer->minimum; \
+	     (rangepointer && (rangepointer->next || value <= rangepointer->maximum)); \
+	     ((value == rangepointer->maximum) ? \
+		(rangepointer = rangepointer->next, value = (rangepointer ? rangepointer->minimum : 0)) : \
+	     	value++))
+
+struct range_entry {
+	unsigned long thisvalue;
+	struct range * rangeptr;
+};
+
+extern int max_ranges_used;
+extern int num_range_pages;
+int add_range_pages(int number_requested);
+int add_to_range_chain(struct rangechain * chain, unsigned long value);
+void put_range_chain(struct rangechain * chain);
+void print_chain(int debuglevel, struct rangechain * chain, int printasswap);
+void set_chain_names(struct pagedir * p);
+int free_ranges(void);
+void init_range_entry(struct range_entry * range_entry, struct rangechain rangechain);
+unsigned long get_next_range_entry(struct range_entry * range_entry);
+int append_range_to_range_chain(struct rangechain * chain, unsigned long minimum, unsigned long maximum);
+
+/* We are putting offset in the low bits so consecutive swap entries make consecutive range values */
+#define swap_entry_to_range_val(swp_entry) ((swp_entry.val >> 8) | ((swp_entry.val & 0x3f) << 24))
+#define range_val_to_swap_entry(val) (swp_entry_t) { ((val >> 24) | ((val & 0xffffff) << 8)) }
diff -ruN swsusp-1.0.2/kernel/suspend/freeze_and_free.c swsusp-1.0.3/kernel/suspend/freeze_and_free.c
--- swsusp-1.0.2/kernel/suspend/freeze_and_free.c	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/kernel/suspend/freeze_and_free.c	2003-07-19 20:39:38.000000000 +1200
@@ -293,7 +293,7 @@
 			pagedir2_size,
 			pageset1_size,
 			calcpagedirsize(pageset1_size));
-	si_swapinfo(&swapinfo);	/* FIXME: si_swapinfo(&i) returns all swap devices information.*/ 
+	si_swapinfo_devsonly(&swapinfo);
 }
 
 struct eaten_memory_t
diff -ruN swsusp-1.0.2/kernel/suspend/io.c swsusp-1.0.3/kernel/suspend/io.c
--- swsusp-1.0.2/kernel/suspend/io.c	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/kernel/suspend/io.c	2003-07-19 20:39:38.000000000 +1200
@@ -47,9 +47,7 @@
 
 static int prepare_zlib_deflate_memory(void)
 {
-	trap_page_allocs = 0;
 	compression_workspace = vmalloc(zlib_deflate_workspacesize());
-	trap_page_allocs = 1;
 	if (!compression_workspace) {
 		printk(KERN_WARNING "Failed to allocate %d bytes for deflate workspace\n", zlib_deflate_workspacesize());
 		return -ENOMEM;
@@ -137,9 +135,7 @@
 
 #ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
 	if (!TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION)) {
-		trap_page_allocs = 0;
 		compression_buffer = get_zeroed_page(GFP_ATOMIC);
-		trap_page_allocs = 1;
 
 		if (!compression_buffer) {
 			printk(KERN_ERR name_suspend "Failed to allocate memory for compression buffer.\n");
@@ -504,9 +500,7 @@
 	} while(0)
 	
 	arrayorder = get_bitmask_order(SUSPEND_PD_PAGES(pagedir1.pagedir_size + 1));
-	trap_page_allocs = 0;
 	pbearray = (struct pbe *) __get_free_pages(__GFP_FAST, arrayorder);
-	trap_page_allocs = 1;
 	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_LOW, name_suspend "Writing pagedir (%d pages)\n", pagedir1.pagedir_size);
 
 	for (i=0; i<(pagedir1.pagedir_size); i++) {
@@ -549,9 +543,7 @@
 	if (sizeof(union diskpage) != PAGE_SIZE)
 		abort_and_exit("Size of a disk page is not PAGE_SIZE!\n");
 
-	trap_page_allocs = 0;
 	diskpage.address = get_free_page(GFP_ATOMIC);
-	trap_page_allocs = 1;
 	pbeheader.address = virt_to_page(diskpage.address);
 	pbeheader.swap_address = get_swap_page(1);
 	get_phys_params(&pbeheader);
@@ -604,48 +596,6 @@
 	return -1;
 }
 
-#if 0
-int noresume_fix_signature(union p_diskpage cur)
-{
-	/* 
-	 * We don't do a sanity check here: we want to restore the swap 
-	 * whatever version of kernel made the suspend image
-	 */
-	struct buffer_head *bh;
-	printk(name_resume "%s: Fixing swap signatures...\n", resume_file);
-				/* We need to write swap, but swap is *not* enabled so
-				   we must write the device directly */
-	printlog(SUSPEND_ANY_SECTION, SUSPEND_VERBOSE,"Swap signature will be set to %10s\n",cur.pointer->swh.magic.magic);
-	BREAD_BUFFER_HEAD(resume_device, 0);
-	if (is_read_only(bh->b_dev)) {
-		printk(KERN_ERR name_resume "Can't write to read-only device %s\n",
-		       kdevname(bh->b_dev));
-		BFREE(bh);
-		return -EIO;
-	}
-	
-	flush_dcache_page(virt_to_page(bh->b_data));
-	memcpy(bh->b_data, cur.ptr, PAGE_SIZE);
-	generic_make_request(WRITE, bh);
-	wait_on_buffer(bh);
-	sync_swap_partitions();
-	if (buffer_uptodate(bh)) {
-		brelse(bh);
-		BFREE(bh);
-		free_suspend_cache_page(last_suspend_cache_page);
-		/* As with fix_signature, try to read to ensure its written. */
-		BREAD_BUFFER_HEAD(resume_device, 0);
-		brelse(bh);
-		BFREE(bh);
-		return 0;
-	}
-	printk(name_resume "Warning %s: Fixing swap signatures unsuccessful...\n", resume_file);
-	bforget(bh);
-	BFREE(bh);
-	return -EINVAL;		/* non fatal error */
-}
-#endif
-
 /*
  * Sanity check if this image makes sense with this kernel/swap context
  * I really don't think that it's foolproof but more than nothing..
@@ -757,10 +707,10 @@
 	if (header_block_device != resume_device) {
 		int blksize = 0;
 		if (!blksize_size[MAJOR(header_block_device)]) {
-			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "%x: Blocksize not known?", header_block_device);
+			printk(name_resume "%x: Blocksize not known?", header_block_device);
 		} else blksize = blksize_size[MAJOR(header_block_device)][MINOR(header_block_device)];
 		if (!blksize) {
-			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "%x: Blocksize not set?", header_block_device);
+			printk(name_resume "%x: Blocksize not set?", header_block_device);
 			blksize = PAGE_SIZE;
 		}
 		set_blocksize(header_block_device, PAGE_SIZE);
@@ -836,10 +786,10 @@
 
 		printnolog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, 0, "Resume secondary device %x", thisdevice);
 		if (!blksize_size[MAJOR(thisdevice)]) {
-			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "%x: Blocksize not known?", thisdevice);
+			printk(name_resume "%x: Blocksize not known?", thisdevice);
 		} else blksize = blksize_size[MAJOR(thisdevice)][MINOR(thisdevice)];
 		if (!blksize) {
-			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "%x: Blocksize not set?", thisdevice);
+			printk(name_resume "%x: Blocksize not set?", thisdevice);
 			blksize = PAGE_SIZE;
 		}
 		set_blocksize(thisdevice, PAGE_SIZE);
@@ -935,10 +885,10 @@
 		printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, name_resume "Resuming from device %x\n", resume_device);
 		
 		if (!blksize_size[MAJOR(resume_device)]) {
-			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "Blocksize not known?\n");
+			printk(name_resume "Blocksize not known?\n");
 		} else blksize = blksize_size[MAJOR(resume_device)][MINOR(resume_device)];
 		if (!blksize) {
-			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "Blocksize not set?\n");
+			printk(name_resume "Blocksize not set?\n");
 			blksize = PAGE_SIZE;
 		}
 		set_blocksize(resume_device, PAGE_SIZE);
diff -ruN swsusp-1.0.2/kernel/suspend/low_level_io.c swsusp-1.0.3/kernel/suspend/low_level_io.c
--- swsusp-1.0.2/kernel/suspend/low_level_io.c	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/kernel/suspend/low_level_io.c	2003-07-19 20:39:38.000000000 +1200
@@ -343,7 +343,6 @@
 	struct io_info * this = io_info, * last = NULL, * firstfree = NULL;
 	unsigned long newpage = 0;
 	int iteration = 0;
-	int orig_trap_page_allocs = trap_page_allocs;
 
 try_again:
 	this = io_info;
@@ -387,9 +386,7 @@
 	}
 
 	/* Need to allocate a new page */
-	trap_page_allocs = 0;
 	newpage = get_zeroed_page(GFP_ATOMIC);
-	trap_page_allocs = orig_trap_page_allocs;
 	printlog(SUSPEND_MEMORY, SUSPEND_VERBOSE, "[NewIOPage %lx]", newpage);
 	if (!newpage)
 		goto try_again;
@@ -461,10 +458,11 @@
 void check_io_stats(void)
 {
 	if (outstanding_io)
-		printlog(SUSPEND_MEMORY, SUSPEND_ERROR, "Outstanding_io after writing is %d.\n", outstanding_io);
+		printk("Outstanding_io after writing is %d.\n", outstanding_io);
 	if (infopages)
-		printlog(SUSPEND_MEMORY, SUSPEND_ERROR, "Info pages is %d.\n", infopages);
-	printlog(SUSPEND_MEMORY, SUSPEND_ERROR, "Pages allocated is %d. Freed is %d.\n", pages_allocated, pages_freed);
+		printk("Info pages is %d.\n", infopages);
+	if (pages_allocated != pages_freed)
+		printk("Pages allocated is %d. Freed is %d.\n", pages_allocated, pages_freed);
 }
 
 void sync_swap_partitions(void)
@@ -519,13 +517,8 @@
 		return 1;
 
 	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_HIGH, "Start_write: [%p]", io_info);
-	trap_page_allocs = 0;
-	while (!(buffer_virt = get_zeroed_page(GFP_ATOMIC))) {
-		trap_page_allocs = 1;
+	while (!(buffer_virt = get_zeroed_page(GFP_ATOMIC)))
 		cleanup_finished_swsusp_io();
-		trap_page_allocs = 0;
-	}
-	trap_page_allocs = 1;
 	pages_allocated++;
 	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, "[WRITE BUFFER]->%d", nr_free_pages());
 	buffer_page = virt_to_page(buffer_virt);
@@ -652,7 +645,7 @@
  * Asynchronously reads or writes a page to swap.
  * Used to read/write swap header.
  */
-void swsusp_rw_swap_page(int rw, struct pbe * pbe)
+int swsusp_rw_swap_page(int rw, struct pbe * pbe)
 {
 	struct page * page = pbe->address, * cache_page;
 	swp_entry_t entry = pbe->swap_address;
@@ -668,6 +661,8 @@
 
 	if (rw_swap_page_base(rw, entry, page))
 		lock_page(page);
+	else
+		return 1;	/* Invalid entry */
 	
 	if (!block_flushpage(page, 0))
 		PAGE_BUG(page);
@@ -683,6 +678,8 @@
 	if ((rw == READ) && (cache_page))
 		free_suspend_cache_page(cache_page);
 	atomic_dec(&page->count);
+
+	return 0;
 }
 
 void read_swapfiles(void) /* This is called before saving image */
@@ -728,18 +725,18 @@
 	struct pbe pbe;
 	char * signature;
 	unsigned long pageaddress;
-	int orig_trap_page_allocs = trap_page_allocs;
 
 	PRINTFREEMEM("at start of mark_swapfiles");
 	
-	trap_page_allocs = 0;
 	pageaddress = get_zeroed_page(GFP_ATOMIC);
-	trap_page_allocs = orig_trap_page_allocs;
 	pbe.address = virt_to_page(pageaddress);
 	signature = ((union p_diskpage) pageaddress).pointer->swh.magic.magic;
 
 	pbe.swap_address = SWP_ENTRY(root_swap, 0);
-	swsusp_rw_swap_page(READ, &pbe); 
+	if (swsusp_rw_swap_page(READ, &pbe)) {
+		free_pages(pageaddress, 0);
+		return;
+	}
 
 	switch(mode) {
 	case MARK_SWAP_RESUME:
@@ -820,12 +817,9 @@
 	pte_t * pte;
 	int pageprot = 0;
 	int restore = 0;
-	int orig_trap_page_allocs = trap_page_allocs;
 
-	trap_page_allocs = 0;
 	buffer_address = get_zeroed_page(__GFP_FAST);
 	page = virt_to_page(buffer_address);
-	trap_page_allocs = orig_trap_page_allocs;
 
 	io_info.page = page;
 
diff -ruN swsusp-1.0.2/kernel/suspend/main.c swsusp-1.0.3/kernel/suspend/main.c
--- swsusp-1.0.2/kernel/suspend/main.c	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/kernel/suspend/main.c	2003-07-19 20:39:38.000000000 +1200
@@ -103,7 +103,7 @@
  * pagedir to load pageset2 (if necessary) before freeing that pagedir.
  */
 
-struct pagedir pagedir1 = { 0, 0, 0, 0, NULL}, pagedir2 = {0, 0, 0, 0, NULL};
+struct pagedir pagedir1 = { 0, 0, 0, 0}, pagedir2 = {0, 0, 0, 0};
 
 unsigned long swsusp_debug_state = 0;
 int swsusp_default_console_level = 0;
@@ -258,7 +258,7 @@
 				printk(name_resume "Problem while sending resume event\n");
 			pm_suspend_state=0;
 		} else
-			printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, name_resume "PM suspend state wasn't raised\n");
+			printk(name_resume "PM suspend state wasn't raised\n");
 
 #ifdef DEFAULT_SUSPEND_CONSOLE
 		update_screen(fg_console);
@@ -280,54 +280,97 @@
 {
 	pageset_sizes_t result;
 	int temp_result, alloc_from, i;
+	int orig_num_range_pages, iteration = 0;
 
-	recalculate_stats(0);
-	display_stats(0);
-	
-	expected_size1 = pageset1_size;
-	expected_size2 = pageset2_size;
+	read_swapfiles();
 
-	PRINTPREEMPTCOUNT("At entry to save_image.");
+	/* 
+	 * FIXME.
+	 * We trap anything else that tries to free or allocate memory from now on.
+	 * Processes not in the fridge can still be triggered by timers. We should
+	 * probably stop this happening, but for now we just trap them if they try
+	 * to free or allocate memory on us. This is really only critical when saving
+	 * pageset 2 & copying pageset 1 (which is done with IRQs disabled anyway),
+	 * but we trap also trap them while trying to calculate the image stats so
+	 * that our task isn't further complicated.
+	 */
 
-	if (TEST_RESULT_STATE(SUSPEND_ABORTED)) 
-		goto abort_saving;
+	trap_page_allocs = 1;
 
-	if ((RAM_TO_SUSPEND > max_mapnr) || (RAM_TO_RESUME > max_mapnr)) {
-		printk(KERN_CRIT name_suspend "Couldn't get enough free pages, on %ld pages short\n",
-			 MAX(RAM_TO_RESUME, RAM_TO_SUSPEND) - max_mapnr);
-		prepare_status(1, 1, "Couldn't get enough free pages, on %ld pages short\n",
-			 MAX(RAM_TO_RESUME, RAM_TO_SUSPEND) - max_mapnr);
-		goto abort_saving;
-	}
-	if (swapinfo.freeswap < SWAP_NEEDED)  {
-		printk(KERN_CRIT name_suspend "There's not enough swap space available (%ld pages available, need %d)\n",
-			 swapinfo.freeswap, SWAP_NEEDED);
-		prepare_status(1, 1, "There's not enough swap space available (%ld pages available, need %d)\n",
-			 swapinfo.freeswap, SWAP_NEEDED);
-		SET_RESULT_STATE(SUSPEND_ABORTED);
-		SET_RESULT_STATE(SUSPEND_INSUFFICIENT_SWAP);
-		goto abort_saving;
-	}
+	/* Now that we're using range pages, we need to do this iteratively. We go
+	 * through the original process (get addresses for basic data to be saved,
+	 * swap addresses to store that data in and any extra pages needed to copy
+	 * pageset1 data), then check whether we added new range pages in doing so.
+	 * If we did, we go back to the start and update the ranges for pagesets 1
+	 * & 2, get any extra swap that's needed and any extra pages to be allocated.
+	 * When we stop getting extra range pages, we will have gotten stable values
+	 * for the other variables.
+	 */
+
+	do {
+		iteration++;
+
+		orig_num_range_pages = num_range_pages;
+		printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Iteration %d.\n", 
+				iteration);
+
+		free_pagedir(&pagedir1);
+		free_pagedir(&pagedir2);
 
-	swapforimage = swapinfo.freeswap;
+		recalculate_stats(0);
+		display_stats(0);
 	
-	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Creating pagedir1 and allocating extra pages (if any)\n");
+		expected_size1 = pageset1_size;
+		expected_size2 = pageset2_size;
 
-	alloc_from = (pageset1_size > pageset2_sizelow ? pageset2_sizelow : pageset1_size);
+		PRINTPREEMPTCOUNT("At entry to save_image.");
+
+		if (TEST_RESULT_STATE(SUSPEND_ABORTED)) 
+			goto abort_saving;
+
+		if ((RAM_TO_SUSPEND > max_mapnr) || (RAM_TO_RESUME > max_mapnr)) {
+			printk(KERN_CRIT name_suspend "Couldn't get enough free pages, on %ld pages short\n",
+				 MAX(RAM_TO_RESUME, RAM_TO_SUSPEND) - max_mapnr);
+			prepare_status(1, 1, "Couldn't get enough free pages, on %ld pages short\n",
+				 MAX(RAM_TO_RESUME, RAM_TO_SUSPEND) - max_mapnr);
+			goto abort_saving;
+		}
+		if (swapinfo.freeswap < SWAP_NEEDED)  {
+			printk(KERN_CRIT name_suspend "There's not enough swap space available (%ld pages available, need %d)\n",
+				 swapinfo.freeswap, SWAP_NEEDED);
+			prepare_status(1, 1, "There's not enough swap space available (%ld pages available, need %d)\n",
+				 swapinfo.freeswap, SWAP_NEEDED);
+			SET_RESULT_STATE(SUSPEND_ABORTED);
+			SET_RESULT_STATE(SUSPEND_INSUFFICIENT_SWAP);
+			goto abort_saving;
+		}
+
+		swapforimage = swapinfo.freeswap;
 	
-	read_swapfiles();
+		printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW," - Creating pagedir1 and allocating extra pages (if any)\n");
 
-	ide_unsuspend();
+		alloc_from = (pageset1_size > pageset2_sizelow ? pageset2_sizelow : pageset1_size);
+	
+		ide_unsuspend();
 
-	if (create_pagedir(&pagedir1, pageset1_size, alloc_from))
-		goto abort_saving;
+		if (create_pagedir(&pagedir1, pageset1_size, alloc_from))
+			goto abort_saving;
 
-	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Creating pagedir2\n");
+		printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW," - Creating pagedir2\n");
 
-	if (create_pagedir(&pagedir2, pageset2_size, pageset2_size))
-		goto abort_saving;
+		if (create_pagedir(&pagedir2, pageset2_size, pageset2_size))
+			goto abort_saving;
 	
-	ide_suspend();
+		ide_suspend();
+
+		printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW," - Calling count_data_pages to recalculate ranges.\n");
+
+		result = count_data_pages(0);
+
+		printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW," - Number of range pages is now: %d.\n\n", 
+				num_range_pages);
+
+	} while (orig_num_range_pages < num_range_pages);
 
 	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Calling count_data_pages to set pageset addresses.\n");
 
@@ -336,21 +379,20 @@
 	if (TEST_RESULT_STATE(SUSPEND_ABORTED))
 		goto abort_saving;
 
-	trap_page_allocs = 1;
-
 	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"--  Result of count_data_pages: %d and %d\n", result.size1, result.size2);
 	pageset2_sizelow = result.size2low;
 	pageset2_size = result.size2;
 	pageset1_size = result.size1;
 	
+#if 0
 	{
 		int i, unsetstart = -1;
 		struct pbe * pbe = pagedir1.data;
 		for (i = 0; i < pageset1_size; i++) {
 			if (pbe->origaddress) {
 				if (unsetstart != -1) {
-					abort_suspend("----  Pagedir1 has unset original address entries from %d-%d.\n",
-							unsetstart, i);
+					abort_suspend(" ---  Pagedir1 has unset original address entries from %d-%d.\n",
+						unsetstart, i);
 					unsetstart = -1;
 				}
 			} else {
@@ -361,16 +403,16 @@
 		}
 		
 		if (unsetstart != -1) 
-			abort_suspend("----  Pagedir1 has unset original address entries from %d-%d.\n",
-							unsetstart, i);
+			abort_suspend(" ---  Pagedir1 has unset original address entries from %d-%d.\n",
+						unsetstart, i);
 		unsetstart = -1;
 		
 		pbe = pagedir1.data;
 		for (i = 0; i < pageset1_size; i++) {
 			if (pbe->address) {
 				if (unsetstart != -1) {
-					abort_suspend("----  Pagedir1 has unset destination address entries from %d-%d.\n",
-							unsetstart, i);
+					abort_suspend(" ---  Pagedir1 has unset destination address entries from %d-%d.\n",
+						unsetstart, i);
 					unsetstart = -1;
 				}
 			} else {
@@ -381,16 +423,16 @@
 		}
 		
 		if (unsetstart != -1) 
-			abort_suspend("----  Pagedir1 has unset entries from %d-%d.\n",
-							unsetstart, i);
+			abort_suspend(" ---  Pagedir1 has unset entries from %d-%d.\n",
+						unsetstart, i);
 		unsetstart = -1;
 
 		pbe = pagedir2.data;
 		for (i = 0; i < pageset2_size; i++) {
 			if (pbe->address) {
 				if (unsetstart != -1) {
-					abort_suspend("----  Pagedir2 has unset destination address entries from %d-%d.\n",
-							unsetstart, i);
+					abort_suspend(" ---  Pagedir2 has unset destination address entries from %d-%d.\n",
+						unsetstart, i);
 					unsetstart = -1;
 				}
 			} else {
@@ -401,37 +443,38 @@
 		}
 		
 		if (unsetstart !=-1)
-			abort_suspend("----  Pagedir2 has unset desination addresses entries from %d-%d.\n",
-							unsetstart, i);
+			abort_suspend(" ---  Pagedir2 has unset desination addresses entries from %d-%d.\n",
+						unsetstart, i);
 	}
+#endif
 
-	if (TEST_RESULT_STATE(SUSPEND_ABORTED))
-		goto abort_saving;
-
-	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Copying pageset2 destination addresses from 0 to %d\n", alloc_from - 1);
+		if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+			goto abort_saving;
 
-	{
-		/* 
-		 * We know that we don't need to check that we have enough valid pagedir2
-		 * entries because this was handled above
-		 */
-
-		struct pbe * pbe1 = pagedir1.data;
-		struct pbe * pbe2 = pagedir2.data;
-		for(i=0; i < alloc_from; i++) {
-			while (PageHighMem(pbe2->address))
+		printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Copying pageset2 destination addresses from 0 to %d\n", alloc_from - 1);
+
+		{
+			/* 
+			 * We know that we don't need to check that we have enough valid pagedir2
+			 * entries because this was handled above
+			 */
+
+			struct pbe * pbe1 = pagedir1.data;
+			struct pbe * pbe2 = pagedir2.data;
+			for(i=0; i < alloc_from; i++) {
+				while (PageHighMem(pbe2->address))
+					pbe2 = get_next_pbe(pbe2);
+				pbe1->address = pbe2->address;
+				printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "   Entry %d: %lx", 
+						i, 
+						(unsigned long) pbe1->address);
+				pbe1 = get_next_pbe(pbe1);
 				pbe2 = get_next_pbe(pbe2);
-			pbe1->address = pbe2->address;
-			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "   Entry %d: %lx", 
-					i, 
-					(unsigned long) pbe1->address);
-			pbe1 = get_next_pbe(pbe1);
-			pbe2 = get_next_pbe(pbe2);
+			}
+			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 0, "\n");
 		}
-		printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 0, "\n");
-	}
 
-	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Actual values: %d and %d.\n", 
+		printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW," - Actual values: %d and %d.\n", 
 			pageset1_size, 
 			pageset2_size);
 
@@ -524,7 +567,7 @@
 	if (temp_result || (TEST_RESULT_STATE(SUSPEND_ABORTED)))
 		goto abort_reloading_pagedir_two;
 
-	si_swapinfo(&swapinfo);
+	si_swapinfo_devsonly(&swapinfo);
 	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW, "Finished writing image. %ld pages of swap left.\n", swapinfo.freeswap);
 	ide_suspend();
 	swsusp_spin_lock_irqsave(&suspend_irq_lock, pagedirflags);
@@ -572,7 +615,7 @@
 {
 	C_A_D = 0;
 	/* No delay should be needed - ide_disk_suspend purges cache now */
-	printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, name_suspend "Trying to power down.\n");
+	printk(name_suspend "Trying to power down.\n");
 	beepOK;			/* last beep */
 	prepare_status(1, 1, "Ready to power down.");
 #ifdef CONFIG_VT
@@ -583,7 +626,7 @@
 	{
 		if(!pm_power_off) {
 			pm_power_off=swsusp_power_off;
-			printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, name_suspend "Trying to use an apm bios call (you should enable apm or acpi)\n"); 
+			printk(name_suspend "Trying to use an apm bios call (you should enable apm or acpi)\n"); 
 		}
 		machine_power_off();
 	}
@@ -747,6 +790,27 @@
 }
 
 /*
+ * credit for this code to kdb - but not everyone has it applied.
+ */
+#define MODLIST_SIZE 4096
+
+static void local_print_modules(void)
+{
+	static char modlist[MODLIST_SIZE];
+	struct module *this_mod;
+	int pos = 0;
+
+	this_mod = module_list;
+	while (this_mod) {
+		if (this_mod->name)
+			pos += snprintf(modlist+pos, MODLIST_SIZE-pos-1, 
+					"%s ", this_mod->name);
+		this_mod = this_mod->next;
+	}
+	printk("%s\n",modlist);
+}
+
+/*
  * display_debug_info
  * Functionality   : At the end of resuming, displays information that may be
  *                   helpful in debugging software suspend.
@@ -754,12 +818,16 @@
  */
 static void display_debug_info(void)
 {
-	si_swapinfo(&swapinfo);
+	si_swapinfo_devsonly(&swapinfo);
 	printk("\n\nPlease include the following information in any bug report:\n");
 	printk("- SWSUSP Version : %s\n", swsusp_version);
+	printk("- Kernel Version : %s\n", UTS_RELEASE);
 	printk("- Compiler vers. : %d.%d\n", __GNUC__, __GNUC_MINOR__);
-#ifdef CONFIG_PREEMPT
-	printk("- Preemptive kernel.\n");
+#ifdef CONFIG_MODULES	
+	printk("- Modules loaded : ");
+	local_print_modules();
+#else
+	printk("- No module support.\n");
 #endif
 	printk("- Attempt number : %d\n", nr_suspends);
 	printk("- Swap available : %ld (amount unused when preparing image).\n", swapforimage);
@@ -783,6 +851,10 @@
 #ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
 	printk("- Debugging compiled in.\n");
 #endif
+#ifdef CONFIG_PREEMPT
+	printk("- Preemptive kernel.\n");
+#endif
+	printk("- Max ranges used: %d\n", max_ranges_used);
 }
 	
 #define SUSPEND_C
@@ -820,6 +892,7 @@
 	BUG_ON(in_interrupt());
 	software_suspend_enabled = 0;
 	swsusp_result = 0;
+	max_ranges_used = 0;
 	nr_suspends++;
 	
 	/*
@@ -836,9 +909,9 @@
 		avenrun_save[i] = avenrun[i];
 
 	PRINTFREEMEM("at start of do_software_suspend");
-	si_swapinfo(&swapinfo);	/* FIXME: si_swapinfo(&i) returns all swap devices information.*/ 
+	si_swapinfo_devsonly(&swapinfo); 
 	if (!swapinfo.totalswap) {
-		printk(KERN_ERR "You need some swap space to be able to suspend to disk.\n");
+		printk(KERN_ERR "You need some swap space on a swap partition to be able to suspend to disk.\n");
 		SET_RESULT_STATE(SUSPEND_ABORTED);
 		SET_RESULT_STATE(SUSPEND_NOSWAP_AVAILABLE);
 		goto out;
@@ -873,6 +946,8 @@
 
 	PRINTFREEMEM("after allocating pagedir map");
  
+	set_chain_names(&pagedir1);
+	set_chain_names(&pagedir2);
 	/*
 	printlog(SUSPEND_ANY_SECTION, SUSPEND_MEDIUM, "nr_unused_buffer_heads is %d.\n", nr_unused_buffer_heads);
 	while ((!nr_unused_buffer_heads) && (bh_tries < 50)) {
@@ -948,6 +1023,10 @@
 		freemap(&inusemap);
 	PRINTFREEMEM("after freeing inuse map");
 
+	free_ranges();
+	
+	PRINTFREEMEM("after freeing ranges");
+
 	if (TEST_RESULT_STATE(SUSPEND_UNEXPECTED_ALLOC)) {
 		int orig_console_loglevel = console_loglevel;
 		console_loglevel = 5;
diff -ruN swsusp-1.0.2/kernel/suspend/Makefile swsusp-1.0.3/kernel/suspend/Makefile
--- swsusp-1.0.2/kernel/suspend/Makefile	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/kernel/suspend/Makefile	2003-07-19 20:39:38.000000000 +1200
@@ -6,6 +6,6 @@
 
 export-objs := main.o freeze_and_free.o
 
-obj-$(CONFIG_SOFTWARE_SUSPEND) += main.o io.o ui.o pagedir.o freeze_and_free.o low_level_io.o proc.o
+obj-$(CONFIG_SOFTWARE_SUSPEND) += main.o io.o ui.o pagedir.o freeze_and_free.o low_level_io.o proc.o range.o
 
 include $(TOPDIR)/Rules.make
diff -ruN swsusp-1.0.2/kernel/suspend/pagedir.c swsusp-1.0.3/kernel/suspend/pagedir.c
--- swsusp-1.0.2/kernel/suspend/pagedir.c	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/kernel/suspend/pagedir.c	2003-07-19 20:39:38.000000000 +1200
@@ -111,7 +111,7 @@
 	int i = 0;
 
 	if (!address) { /* Failed to kmap */
-		printlog(SUSPEND_CHECKSUMS, SUSPEND_ERROR, "Failed to kmap page %p.\n", page);
+		printk("Failed to kmap page %p.\n", page);
 		return 0;
 	}
 
@@ -261,11 +261,34 @@
 	return (posn - page);
 }
 
+static int append_to_range_chain(int chain, unsigned long min, unsigned long max)
+{
+	int result = 0;
+
+	switch (chain) {
+		case 0:
+			return 0;
+		case 1:
+			result = append_range_to_range_chain(&pagedir1.origranges, min, max);
+			break;
+		case 2:
+			result = append_range_to_range_chain(&pagedir2.origranges, min, max);
+			if (!result)
+				result = append_range_to_range_chain(&pagedir1.destranges, min, max);
+	}
+
+	check_shift_keys(0, NULL);
+
+	return result;
+}
 pageset_sizes_t count_data_pages(int whichpagedir)
 {
 	int chunk_size, loop, numnosave = 0;
+	int ranges = 0, currentrange = 0;
 	struct pbe * pbe1 = NULL;
 	struct pbe * pbe2 = NULL;
+	int usepagedir2;
+	int rangemin = 0;
 
 	pageset_sizes_t result;
 	result.size1 = 0;
@@ -277,7 +300,18 @@
 		pbe2 = pagedir2.data;
 	}
 
+	put_range_chain(&pagedir1.origranges);
+	put_range_chain(&pagedir1.destranges);
+	put_range_chain(&pagedir2.origranges);
+
 	generate_free_page_map();
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED)) {
+		result.size1 = -1;
+		result.size2 = -1;
+		result.size2low = -1;
+		return result;
+	}
+
 	if (max_mapnr != num_physpages) {
 		abort_suspend("mapnr is not expected");
 		result.size1 = -1;
@@ -289,11 +323,17 @@
 		if (!PageReserved(mem_map+loop)) {
 			if (PageNosave(mem_map+loop)) {
 				numnosave++;
+				append_to_range_chain(currentrange, rangemin, loop - 1);
+				rangemin = loop;
+				currentrange = 0;
 				continue;
 			}
 
 			if ((chunk_size=is_head_of_free_region(mem_map+loop))!=0) {
+				append_to_range_chain(currentrange, rangemin, loop - 1);
+				rangemin = loop;
 				loop += chunk_size - 1;
+				currentrange = 0;
 				continue;
 			}
 		} else {
@@ -311,6 +351,9 @@
 				&__nosave_begin && ADDRESS(loop) < 
 				(unsigned long)&__nosave_end) {
 				numnosave++;
+				append_to_range_chain(currentrange, rangemin, loop - 1);
+				rangemin = loop;
+				currentrange = 0;
 				continue;
 			}
 			/* Hmm, perhaps copying all reserved pages is not too healthy as they may contain 
@@ -318,9 +361,16 @@
 
 		};
 
+		usepagedir2 = (PageHighMem(mem_map+loop) || PagePageset2(mem_map+loop));
+		
+		if (currentrange != (1 + usepagedir2)) {
+			append_to_range_chain(currentrange, rangemin, loop - 1);
+			currentrange = usepagedir2 + 1;
+			rangemin = loop;
+			ranges++;
+		}
+		
 		if (whichpagedir) {
-			int usepagedir2 = (PageHighMem(mem_map+loop) || PagePageset2(mem_map+loop));
-
 			if (usepagedir2) {
 				if (result.size2 <= pagedir2.pageset_size) {
 					pbe2->origaddress = mem_map+loop;
@@ -343,6 +393,8 @@
 			result.size1++;
 	}
 	
+	append_to_range_chain(currentrange, rangemin, loop - 1);
+
 	/*
 	 * printlog(SUSPEND_VERBOSE, "\nResults: %d and %d(%d low). %d marked Nosave\n", 
 	 *		result.size1, result.size2, result.size2low, numnosave);
@@ -360,6 +412,7 @@
 					pagedir2.pagedir_capacity,
 					result.size2);
 	}
+	printnolog(SUSPEND_RANGES, SUSPEND_MEDIUM, 0, "Counted %d ranges.\n", ranges);
 	return result;
 }
 
@@ -394,6 +447,12 @@
 	if (p->pagedir_size == 0)
 		return;
 
+	put_range_chain(&p->origranges);
+	put_range_chain(&p->destranges);
+	put_range_chain(&p->swapranges);
+	put_range_chain(&p->blockranges);
+	put_range_chain(&p->allocdranges);
+
 	/* Entries can validly be NULL. We might be called if creating a pagedir fails to allocate a page */
 	if (p->first_allocated) {
 		pbe = p->first_allocated;
@@ -497,8 +556,11 @@
 			if (!entry.val)
 				abort_and_exit("Not enough swapspace (this shouldn't happen!)\n");
 			pbe->swap_address = entry;
+			add_to_range_chain(&p->swapranges, swap_entry_to_range_val(entry));
 			get_phys_params(pbe);
 			if (TEST_RESULT_STATE(SUSPEND_ABORTED)) {
+				p->pagedir_capacity = pageset_size;
+				p->pagedir_size = pagedir_size;
 				free_pagedir(p);
 				return 0;
 			}
@@ -521,6 +583,8 @@
 			if (!pbe->address)
 				abort_and_exit("Unable to allocate pages for pagedir!\n");
 			SetPageNosave(pbe->address);
+			add_to_range_chain(&p->allocdranges, pbe->address - mem_map);
+			add_to_range_chain(&p->destranges, pbe->address - mem_map);
 			numnosaveallocated++;
 			pbe = get_next_pbe(pbe);
 		}
@@ -529,6 +593,7 @@
 		}
 	}
 
+	print_chain(6, &p->swapranges, 1);
 	p->pagedir_size = calcpagedirsize(pageset_size);
 	p->pageset_size = p->pagedir_capacity = pageset_size;
 	p->alloc_from = alloc_from;
@@ -565,7 +630,7 @@
 
 	if (TEST_ACTION_STATE(SUSPEND_NOPAGESET2)) {
 #ifdef CONFIG_HIGHMEM
-		printlog(SUSPEND_MARK_PAGESET2, SUSPEND_ERROR, "Ignoring request for no pageset2 - HighMem support is configured.\n");
+		printk("Ignoring request for no pageset2 - HighMem support is configured.\n");
 #else
 		return;
 #endif
@@ -769,3 +834,17 @@
 		return 0;
 }
 
+char* origrangesname = "original addresses";
+char* destrangesname = "destination addresses";
+char* swaprangesname = "swap addresses";
+char* blockrangesname = "block addresses";
+char* allocdrangesname = "allocated addresses";
+
+void set_chain_names(struct pagedir * p)
+{
+	p->origranges.name = origrangesname;
+	p->destranges.name = destrangesname;
+	p->swapranges.name = swaprangesname;
+	p->blockranges.name = blockrangesname;
+	p->allocdranges.name = allocdrangesname;
+}
diff -ruN swsusp-1.0.2/kernel/suspend/range.c swsusp-1.0.3/kernel/suspend/range.c
--- swsusp-1.0.2/kernel/suspend/range.c	1970-01-01 12:00:00.000000000 +1200
+++ swsusp-1.0.3/kernel/suspend/range.c	2003-07-19 20:39:38.000000000 +1200
@@ -0,0 +1,500 @@
+
+#include "common.h"
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+#define RPRINTNOLOG(f, a...) \
+	do { if (1 || debuggingchain) \
+		printnolog(f, ##a); \
+	} while (0)
+#else
+#define RPRINTNOLOG(f, a...) do { } while(0)
+#endif
+int debuggingchain = 0;
+
+struct range * unused_ranges = NULL;
+int nr_unused_ranges = 0;
+int max_ranges_used = 0;
+int num_range_pages = 0;
+static unsigned long ranges_allocated = 0;
+
+/* Add_range_page
+ * Allocates new pages for storing ranges.
+ * Returns 1 on failure to get a page.
+ * Otherwise adds the new pages to the unused_ranges pool.
+ */
+
+int add_range_pages(int number_requested)
+{
+	int i, j;
+	struct range * ranges;
+	unsigned long next;
+
+	for (j = 0; j < number_requested; j++) {
+		next = get_zeroed_page(GFP_ATOMIC);
+		RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_LOW, 0, "Add range page %lx.\n", next);
+		if (!next) {
+			if (!nr_unused_ranges)
+				return 1;
+			else
+				return 0;
+		}
+
+		num_range_pages++;
+		ranges = (struct range *) next;
+		for (i = 0; i < (PAGE_SIZE / sizeof(struct range) - 1); i++)
+			(ranges+i)->next = (ranges+i+1);
+		(ranges + i - 1)->next = unused_ranges;
+		unused_ranges = ranges;
+		nr_unused_ranges += i;
+		if (console_loglevel > 5) {
+			for (i = 0; i < (PAGE_SIZE / sizeof(struct range) - 1); i++)
+				RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_VERBOSE, 0, "Ranges %d = %p. Next = %p\n", 
+					i, 
+					(ranges + i),
+					(ranges + i)->next);
+		}
+	}
+	return 0;
+}
+
+
+/* 
+ * Free ranges.
+ *
+ * Frees pages allocated by add_range_pages()
+ *
+ * Checks that all ranges allocated have been freed and aborts
+ * if this is not true.
+ *
+ * Ranges may not be in memory order but we don't
+ * mind. We just look for a range that is on a
+ * page boundary. That gives us the pages to be
+ * freed. As we find them, we link them together
+ * into a new chain (we're not going to use the
+ * other ranges anyway) and then free the chain.
+ */
+
+int free_ranges(void)
+{
+	int numpages = 0, i = 0;
+	struct range * first = NULL, * last = NULL;
+
+	if (ranges_allocated)
+		printk(" *** Warning: %ld ranges still allocated when free_ranges() called.\n", ranges_allocated);
+
+	while (unused_ranges) {
+		if (!(((unsigned long) unused_ranges) & (PAGE_SIZE - 1))) {
+			if (!first) {
+				first = last = unused_ranges;
+				printnolog(SUSPEND_RANGES, SUSPEND_HIGH, 0, "Setting firstpage to %p.\n", first);
+			} else {
+				printnolog(SUSPEND_RANGES, SUSPEND_HIGH, 0, "Linking in page # %d: %p.\n", numpages + 1, unused_ranges);
+				last->next = unused_ranges;
+				last = unused_ranges;
+			}
+			numpages++;
+			unused_ranges= unused_ranges->next;
+			last->next = NULL;
+		} else
+			unused_ranges= unused_ranges->next;
+	}
+	nr_unused_ranges=0;
+
+	while (first) {
+		last = first;
+		first = first->next;
+		i++;
+		printnolog(SUSPEND_RANGES, SUSPEND_LOW, 0, "Freeing page %d (%lx).\n", i, last);
+		free_pages((unsigned long) last, 0);
+		num_range_pages--;
+	}
+	return 0;
+}
+
+/* get_range
+ *
+ * Returns a free range, having removed it from the
+ * unused list and having incremented the usage counter.
+ * May imply allocating a new page and may therefore 
+ * fail, returning NULL instead.
+ *
+ * No locking. This is because we are only called 
+ * from swsusp, which is single threaded
+ */
+
+static struct range * get_range(void)
+{
+	struct range * result;
+	
+	if (!unused_ranges)
+		if (add_range_pages(1))
+			return NULL;
+
+	result = unused_ranges;
+	unused_ranges = unused_ranges->next;
+	nr_unused_ranges--;
+	ranges_allocated++;
+	if (ranges_allocated > max_ranges_used)
+		max_ranges_used++;
+	result->minimum = 0;
+	result->maximum = 0;
+	result->next = NULL;
+	return result;
+}
+
+/*
+ * put_range.
+ *
+ * Returns a range to the pool of unused pages and
+ * decrements the usage counter.
+ */
+static void put_range(struct range * range)
+{
+	if (!range) {
+		printk("Error! put_range called with NULL range.\n");
+		return;
+	}
+	range->next = unused_ranges;
+	unused_ranges = range;
+	ranges_allocated--;
+	nr_unused_ranges++;
+}
+
+/*
+ * put_range_chain.
+ *
+ * Returns a whole chain of ranges to the
+ * unused pool.
+ */
+void put_range_chain(struct rangechain * chain)
+{
+	struct range * this = chain->first, *next = NULL;
+	int count = 0;
+
+	debuggingchain = chain->debug;
+	RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_HIGH, 0, "\n");
+	
+	while (this) {
+		count++;
+		next = this->next;
+		RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_VERBOSE, 0, "%s: Putting range %p.\n", chain->name, this);
+		if (!next) {
+			this->next = unused_ranges;
+			unused_ranges = chain->first;
+			chain->first = NULL;
+			chain->frees+= count;
+			ranges_allocated -= count;
+			nr_unused_ranges += count;
+		}
+		this = next;
+	}
+	
+	RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_MEDIUM, 0, "Emptied %s. For this chain, allocated %d and freed %d. Used optimisation %d times.\n",
+			chain->name,
+			chain->allocs,
+			chain->frees,
+			chain->timesusedoptimisation);
+	chain->allocs = 0;
+	chain->frees = 0;
+	chain->timesusedoptimisation = 0;
+	chain->lastaccessed = NULL;	/* Invalidate optimisation info */
+}
+
+void print_chain(int debuglevel, struct rangechain * chain, int printasswap)
+{
+	struct range * this = chain->first;
+	int count = 0;
+	
+	debuggingchain = chain->debug;
+
+	if (console_loglevel < debuglevel)
+		return;
+	
+	RPRINTNOLOG(SUSPEND_RANGES, debuglevel, 1, "%s:", chain->name);
+	
+	while (this) {
+		if (printasswap)
+			RPRINTNOLOG(SUSPEND_RANGES, debuglevel, 0, "%lx-%lx ", 
+					range_val_to_swap_entry(this->minimum), 
+					range_val_to_swap_entry(this->maximum));
+		else
+			RPRINTNOLOG(SUSPEND_RANGES, debuglevel, 0, "%lu-%lu ", this->minimum, this->maximum);
+		this = this->next;
+		count++;
+	}
+	RPRINTNOLOG(SUSPEND_RANGES, debuglevel, 0, "\n%s: %d entries/%ld allocated. Allocated %d and freed %d.",
+			chain->name,
+			count, 
+			ranges_allocated,
+			chain->allocs,
+			chain->frees);
+	if (count != (chain->allocs - chain->frees)) {
+		chain->debug = 1;
+		check_shift_keys(1, "Discrepancy in chain.");
+	}
+}
+/*
+ * add_to_range_chain.
+ *
+ * Takes a value to be stored and a pointer
+ * to a chain and adds the value to the range
+ * chain, merging with an existing range or 
+ * adding a new entry as necessary. Ranges 
+ * are stored in increasing order.
+ *
+ * Values should be consecutive, and so may
+ * need to be transformed first. (eg for
+ * pages, would want to call with page-mem_map).
+ *
+ * Important optimisation:
+ * We store in the chain info the location of
+ * the last range accessed or added (and its
+ * previous). If the next value is outside this
+ * range by one, we start from the previous
+ * entry instead of the start of the chain.
+ * In cases of heavy fragmentation, this saves
+ * a lot of time searching.
+ * 
+ * Returns:
+ * 0 if successful
+ * 1 if the value is already included.
+ * 2 if unable to allocate memory.
+ * 3 if fall out bottom (shouldn't happen).
+ */
+
+int add_to_range_chain(struct rangechain * chain, unsigned long value)
+{
+	struct range * this, * prev = NULL, * prevtoprev = NULL;
+	int usedoptimisation = 0;
+	
+	debuggingchain = chain->debug;
+	RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_HIGH, 0, "\n");
+	
+	chain->size++;
+
+	//printk("Adding %ld to %s.\n", value, chain->name);
+	//print_chain(0, chain, 0);
+
+	//RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_HIGH, 0, "%s:", chain->name);
+
+	if (!chain->first) {	/* Empty */
+		chain->first = get_range();
+		chain->allocs++;
+		if (!chain->first)
+			return 2;
+		chain->first->maximum = value;
+		chain->first->minimum = value;
+		RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_HIGH, 0, "%s: Added initial entry %p to chain.\n", 
+				chain->name,
+				chain->first);
+		print_chain(6, chain, 0);
+		return 0;
+	}
+	
+	this = chain->first;
+
+	if (chain->lastaccessed && chain->prevtolastaccessed && chain->prevtoprev) {
+		if ((value + 1) == chain->lastaccessed->minimum) {
+			prev = chain->prevtoprev;
+			this = chain->prevtolastaccessed;
+			usedoptimisation = 1;
+		} else if ((chain->lastaccessed) && ((value - 1) == chain->lastaccessed->maximum)) {
+			prev = chain->prevtolastaccessed;
+			this = chain->lastaccessed;
+			usedoptimisation = 1;
+		}
+		
+		/* prev wrong but doesn't matter */
+		if (usedoptimisation)
+			RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_HIGH, 0,
+				"Adding %ld, using last accessed: (%ld-%ld)(%ld-%ld)\n",
+				value,
+				prev->minimum,
+				prev->maximum,
+				this->minimum,
+				this->maximum);
+		chain->timesusedoptimisation++;
+	}
+
+	while (this) {
+		/* Need new entry prior to this? */
+		if ((value + 1) < this->minimum) {
+			struct range * new = get_range();
+			if (!new)
+				return 2;
+			chain->allocs++;
+			new->minimum = value;
+			new->maximum = value;
+			new->next = this;
+			/* Prior to start of chain? */
+			if (!prev)
+				chain->first = new;
+			else
+				prev->next = new;
+			RPRINTNOLOG(SUSPEND_RANGES, SUSPEND_HIGH, 0, 
+					"%s: Adding new range %p prior to existing range.\n",
+					chain->name,
+					new);
+			print_chain(6, chain, 0);
+			if (!usedoptimisation) {
+				chain->prevtoprev = prevtoprev;
+				chain->prevtolastaccessed = prev;
+				chain->lastaccessed = new;
+			}
+			return 0;
+		}
+
+		if ((this->minimum <= value) && (this->maximum >= value)) {
+			printk("%s: Trying to add a value (%ld) already included in chain.\n",
+					chain->name,
+					value);
+			print_chain(0, chain, 0);
+			chain->size--;	/* Undo addition done above */
+			return 1;
+		}
+		if ((value + 1) == this->minimum) {
+			this->minimum = value;
+			print_chain(7, chain, 0);
+			if (!usedoptimisation) {
+				chain->prevtoprev = prevtoprev;
+				chain->prevtolastaccessed = prev;
+				chain->lastaccessed = this;
+			}
+			return 0;
+		}
+		if ((value - 1) == this->maximum) {
+			if ((this->next) && (this->next->minimum == value + 1)) {
+				struct range * oldnext = this->next;
+				this->maximum = this->next->maximum;
+				this->next = this->next->next;
+				put_range(oldnext);
+				chain->lastaccessed = NULL;	/* Invalidate optimisation info */
+				chain->frees++;
+				RPRINTNOLOG(SUSPEND_RANGES,
+						SUSPEND_HIGH,
+						0,
+						"%s: Putting merged range %p.\n", 
+						chain->name,
+						oldnext);
+				print_chain(6, chain, 0);
+				if (!usedoptimisation) {
+					chain->prevtoprev = prevtoprev;
+					chain->prevtolastaccessed = prev;
+					chain->lastaccessed = this;
+				}
+				return 0;
+			} 
+			this->maximum = value;
+			print_chain(7, chain, 0);
+			if (!usedoptimisation) {
+				chain->prevtoprev = prevtoprev;
+				chain->prevtolastaccessed = prev;
+				chain->lastaccessed = this;
+			}
+			return 0;
+		}
+		if (!this->next) {
+			struct range * new = get_range();
+			if (!new)
+				return 2;
+			chain->allocs++;
+			new->minimum = value;
+			new->maximum = value;
+			new->next = NULL;
+			this->next = new;
+			RPRINTNOLOG(SUSPEND_RANGES,
+					SUSPEND_HIGH,
+					0,
+					"%s: Got new range %p for end of chain.\n",
+					chain->name,
+					new);
+			print_chain(6, chain, 0);
+			if (!usedoptimisation) {
+				chain->prevtoprev = prev;
+				chain->prevtolastaccessed = this;
+				chain->lastaccessed = new;
+			}
+			return 0;
+		}
+		prevtoprev = prev;
+		prev = this;
+		this = this->next;
+	}
+	printk("\nFell out the bottom of add_to_range_chain. This shouldn't happen!\n");
+	SET_RESULT_STATE(SUSPEND_ABORTED);
+	return 3;
+}
+
+/* append_range
+ * Used where we know a range is to be added to the end of the list
+ * and does not need merging with the current last range.
+ * (count_data_pages only at the moment)
+ */
+
+int append_range_to_range_chain(struct rangechain * chain, unsigned long minimum, unsigned long maximum)
+{
+	struct range * newrange, * oldlast = NULL;
+
+	if (chain->first) {
+		oldlast = chain->first;
+		while (oldlast->next)
+			oldlast = oldlast->next;
+	}
+
+	newrange = get_range();
+	if (!newrange)
+		return 2;
+
+	chain->allocs++;
+	newrange->minimum = minimum;
+	newrange->maximum = maximum;
+	newrange->next = NULL;
+
+	if (oldlast)
+		oldlast->next = newrange;
+	else
+		chain->first = newrange;
+	RPRINTNOLOG(SUSPEND_RANGES,
+		SUSPEND_HIGH,
+		0,
+		"%s: Got new range %p for end of chain.\n",
+		chain->name,
+		newrange);
+		print_chain(6, chain, 0);
+	/* No need to reset optimisation info since added to end */
+	return 0;
+}
+
+/* get_next_range_entry
+ * Given info on the previous entry in a list, 
+ * update the info & return the next entry
+ */
+unsigned long get_next_range_entry(struct range_entry * range_entry)
+{
+	unsigned long thisvalue;
+
+	/* We are already pointing at the entry to return */
+	if (!range_entry->rangeptr) 
+		return -1;
+	
+	thisvalue = range_entry->thisvalue;
+	
+	if (range_entry->thisvalue == range_entry->rangeptr->maximum) {
+		if (!range_entry->rangeptr->next)
+			range_entry->rangeptr = NULL;
+		else {
+			range_entry->rangeptr = range_entry->rangeptr->next;
+			range_entry->thisvalue = range_entry->rangeptr->minimum;
+		}
+	} else
+		range_entry->thisvalue++;
+	
+	return thisvalue;
+}
+
+/* Initialise range entry */
+void init_range_entry(struct range_entry * range_entry, struct rangechain rangechain)
+{
+	range_entry->rangeptr = rangechain.first;
+	range_entry->thisvalue = range_entry->rangeptr->minimum;
+}
diff -ruN swsusp-1.0.2/kernel/suspend/ui.c swsusp-1.0.3/kernel/suspend/ui.c
--- swsusp-1.0.2/kernel/suspend/ui.c	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/kernel/suspend/ui.c	2003-07-19 20:39:38.000000000 +1200
@@ -26,7 +26,6 @@
 
 extern struct kbd_struct kbd_table[MAX_NR_CONSOLES];
 
-
 /* 
  * Console being used for suspend - may not be default if splash screen 
  * displayed 
@@ -96,6 +95,7 @@
 }
 
 
+#if defined(DEFAULT_SUSPEND_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND_DEBUG)
 /*
  * This function is intended to do the same job as printk, but without actually
  * logging what is printed. The point is to be able to get debugging info on
@@ -106,7 +106,6 @@
 //void printnolog(int restartline, const char *fmt, ...)
 void printnolog(int mask, int level, int restartline, const char *fmt, ...)
 {
-#if defined(DEFAULT_SUSPEND_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND_DEBUG)
 	va_list args;
 	int printed_len = 0;
 
@@ -138,7 +137,6 @@
 		printk(print_buf);
 	else
 		cond_console_print(print_buf, printed_len);
-#endif
 }
 
 /*
@@ -148,7 +146,6 @@
  */
 void printlog(int mask, int level, const char *fmt, ...)
 {
-#if defined(DEFAULT_SUSPEND_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND_DEBUG)
 	va_list args;
 	int printed_len = 0;
 
@@ -170,8 +167,8 @@
 	va_end(args);
 
 	printk(print_buf);
-#endif
 }
+#endif
 
 void prepare_status(int printalways, int clearbar, const char *fmt, ...)
 {
@@ -215,7 +212,7 @@
 	posn[0] = (unsigned char) (0);
 	posn[1] = (unsigned char) (video_num_lines);
 	putconsxy(suspend_console, posn);
-	cond_console_print(name_swsusp, strlen(name_swsusp));
+	cond_console_print(swsusp_version, strlen(swsusp_version));
 
 	/* Print header */
 	posn[0] = (unsigned char) ((video_num_columns - 29) / 2);
@@ -394,6 +391,9 @@
 {
 #ifdef DEFAULT_SUSPEND_CONSOLE 
 	int was_locked = (spin_is_locked(&suspend_irq_lock));
+	static struct kbd_struct * kbd;
+	
+	kbd = kbd_table + fg_console;
 
 	if (was_locked)
 		swsusp_spin_unlock_irqrestore(&suspend_irq_lock, pagedirflags);
@@ -404,18 +404,17 @@
 		goto done_checking;
 
 	/* Don't pause if just toggled */
-	if (((TEST_ACTION_STATE(SUSPEND_PAUSE) && pause) || 
-	     (shift_state & (1 << KG_CTRL))) 
-	    && (console_loglevel > 1)) { 
+	if (((TEST_ACTION_STATE(SUSPEND_PAUSE) && pause) || (vc_kbd_led(kbd, VC_CAPSLOCK))) 
+			&& (console_loglevel > 1)) { 
 		prepare_status(1, 0, "%sPress SHIFT to continue.\n", message ? message : "");
-		while ((shift_state & (1 << KG_SHIFT | 1 << KG_CTRL)) &&
-				(TEST_ACTION_STATE(SUSPEND_PAUSE)) &&
-				(!TEST_RESULT_STATE(SUSPEND_ABORTED)))
-			yield();
-		while ((!(shift_state & (1 << KG_SHIFT | 1 << KG_CTRL))) &&
-				(TEST_ACTION_STATE(SUSPEND_PAUSE)) &&
-				(!TEST_RESULT_STATE(SUSPEND_ABORTED)))
-			yield();
+		while ((shift_state & (1 << KG_SHIFT)) &&
+			(TEST_ACTION_STATE(SUSPEND_PAUSE) || vc_kbd_led(kbd, VC_CAPSLOCK)) &&
+			(!TEST_RESULT_STATE(SUSPEND_ABORTED)))
+		 yield();
+		while ((!shift_state & (1 << KG_SHIFT)) &&
+			(TEST_ACTION_STATE(SUSPEND_PAUSE) || vc_kbd_led(kbd, VC_CAPSLOCK)) &&
+			(!TEST_RESULT_STATE(SUSPEND_ABORTED)))
+		 yield();
 	}
 done_checking:
 	lastshiftstate = shift_state;
@@ -447,7 +446,7 @@
 
 		set_console(DEFAULT_SUSPEND_CONSOLE);
 		if (vt_waitactive(DEFAULT_SUSPEND_CONSOLE)) {
-			printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, "Can't switch virtual consoles.");
+			printk("Can't switch virtual consoles.");
 			return 1;
 		}
 	} else 
@@ -472,7 +471,7 @@
 	if ((orig_fgconsole != suspend_console) && (!SPLASH_IS_ON(suspend_console))) {
 		set_console(orig_fgconsole);
 		if (vt_waitactive(orig_fgconsole)) {
-			printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, "Can't switch virtual consoles.");
+			printk("Can't switch virtual consoles.");
 			return;
 		}
 	}
diff -ruN swsusp-1.0.2/mm/page_alloc.c swsusp-1.0.3/mm/page_alloc.c
--- swsusp-1.0.2/mm/page_alloc.c	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/mm/page_alloc.c	2003-07-19 20:39:38.000000000 +1200
@@ -55,6 +55,40 @@
 	|| ((zone) != page_zone(page))					\
 )
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+#ifdef	CONFIG_KDB
+#include <linux/kdb.h>
+#endif	/* CONFIG_KDB */
+void do_trap_page_alloc(char * action)
+{
+	/* 
+	 * Some tasks get activated using timers even after
+	 * we have suspended. They sometimes try to free or
+	 * allocate memory. (Eg sleep exiting or init forking).
+	 * We stop them here until suspend is done.
+	 *
+	 * Note that it only really matters between the start
+	 * of writing pageset 2 and the end of copying pageset 1,
+	 * so we turn off trapping the processes outside of this
+	 * section of code.
+	 *
+	 * Swsusp allocates and frees memory, but in a very
+	 * controlled way. It works hard to ensure that every
+	 * page allocated is also freed.
+	 */
+	
+	if (current->pid != suspend_task) {
+		printk("Trapped %s(pid %d) trying to %s memory during suspend.\n",
+			current->comm,
+			current->pid,
+			action);
+	
+		while (suspend_task)
+			yield();
+	}
+}
+#endif
+
 /*
  * Freeing function for a buddy system allocator.
  * Contrary to prior comments, this is *NOT* hairy, and there
@@ -88,6 +122,11 @@
 	struct page *base;
 	zone_t *zone;
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	if (unlikely(trap_page_allocs))
+		do_trap_page_alloc("free");
+#endif
+	
 	/*
 	 * Yes, think what happens when other parts of the kernel take 
 	 * a reference to a page in order to pin it for io. -ben
@@ -337,31 +376,10 @@
 #if CONFIG_SOFTWARE_SUSPEND
 	static unsigned int loopcount;
 
-	if (!TASK_NOT_SUSPENDED(current)) {
-		printk("Caught a process in alloc_pages.\n");
-		schedule();	/* Forking comes here */
-	}
-
-	if ((trap_page_allocs) && (!(TEST_RESULT_STATE(SUSPEND_UNEXPECTED_ALLOC)))) {
-		/* 
-		 * Trying to catch a bug that only infrequently appears.
-		 * We want the user to live to tell the story and provide
-		 * useful info, so we set ourselves up to abort swsusp and
-		 * print the stack here. Swsusp will take note, tell
-		 * the user what's going on and ask them to pass the info
-		 * on to Nigel.
-		 */
+	if (unlikely(trap_page_allocs))
+		do_trap_page_alloc("allocate");
+#endif
 
-		show_state();
-		SET_RESULT_STATE(SUSPEND_ABORTED);
-		SET_RESULT_STATE(SUSPEND_UNEXPECTED_ALLOC);
-		/* 
-		 * We will let whatever is calling get the page it wants so
-		 * as to not cause other issues. Swsusp should be able to
-		 * back out okay.
-		 */
-	}
-#endif	
 	zone = zonelist->zones;
 	classzone = *zone;
 	if (classzone == NULL)
diff -ruN swsusp-1.0.2/mm/swapfile.c swsusp-1.0.3/mm/swapfile.c
--- swsusp-1.0.2/mm/swapfile.c	2003-07-19 20:39:36.000000000 +1200
+++ swsusp-1.0.3/mm/swapfile.c	2003-07-19 20:39:38.000000000 +1200
@@ -1155,6 +1155,34 @@
 	swap_list_unlock();
 }
 
+void si_swapinfo_devsonly(struct sysinfo *val)
+{
+	unsigned int i;
+	unsigned long nr_to_be_unused = 0;
+
+	swap_list_lock();
+	for (i = 0; i < nr_swapfiles; i++) {
+		unsigned int j;
+		if (swap_info[i].flags != SWP_USED)
+			continue;
+		if (!swap_info[i].swap_device)
+			continue;
+
+		for (j = 0; j < swap_info[i].max; ++j) {
+			switch (swap_info[i].swap_map[j]) {
+				case 0:
+				case SWAP_MAP_BAD:
+					continue;
+				default:
+					nr_to_be_unused++;
+			}
+		}
+	}
+	val->freeswap = nr_swap_pages + nr_to_be_unused;
+	val->totalswap = total_swap_pages + nr_to_be_unused;
+	swap_list_unlock();
+}
+
 /*
  * Verify that a swap entry is valid and increment its swap map count.
  *
