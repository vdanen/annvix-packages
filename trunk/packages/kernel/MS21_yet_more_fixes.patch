diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff --exclude=ipsec --exclude='defconfig*' w5/include/linux/pnp.h w4/include/linux/pnp.h
--- w5/include/linux/pnp.h	1970-01-01 01:00:00.000000000 +0100
+++ w4/include/linux/pnp.h	2003-08-07 20:54:14.000000000 +0200
@@ -0,0 +1,220 @@
+/*
+ * Linux Plug and Play Support
+ * Copyright by Adam Belay <ambx1@neo.rr.com>
+ *
+ * Reduced and backported for compatibility reasons for 2.2 and
+ * 2.4 kernels by Jaroslav Kysela <perex@suse.cz>
+ *
+ */
+
+#ifndef _LINUX_PNP_H
+#define _LINUX_PNP_H
+
+#ifdef __KERNEL__
+
+#include <linux/isapnp.h>
+#include <linux/list.h>
+
+#define PNP_MAX_PORT		8
+#define PNP_MAX_MEM		4
+#define PNP_MAX_IRQ		2
+#define PNP_MAX_DMA		2
+#define PNP_MAX_DEVICES		8
+#define PNP_ID_LEN		8
+
+#ifndef ISAPNP_ALSA_LOCAL
+#define isapnp_dev pci_dev
+#define isapnp_card pci_bus
+#endif
+
+struct pnp_card {
+	struct isapnp_card p;
+};
+
+struct pnp_dev {
+	struct isapnp_dev p;
+};
+
+/*
+ * Resource Management
+ */
+
+/* Use these instead of directly reading pnp_dev to get resource information */
+#define pnp_port_start(dev,bar)   ((dev)->p.resource[(bar)].start)
+#define pnp_port_end(dev,bar)     ((dev)->p.resource[(bar)].end)
+#define pnp_port_flags(dev,bar)   ((dev)->p.resource[(bar)].flags)
+#define pnp_port_valid(dev,bar)   (pnp_port_flags((dev),(bar)) & IORESOURCE_IO)
+#define pnp_port_len(dev,bar) \
+	((pnp_port_start((dev),(bar)) == 0 &&	\
+	  pnp_port_end((dev),(bar)) ==		\
+	  pnp_port_start((dev),(bar))) ? 0 :	\
+	  					\
+	 (pnp_port_end((dev),(bar)) -		\
+	  pnp_port_start((dev),(bar)) + 1))
+
+#define pnp_mem_start(dev,bar)   ((dev)->p.resource[(bar)+8].start)
+#define pnp_mem_end(dev,bar)     ((dev)->p.resource[(bar)+8].end)
+#define pnp_mem_flags(dev,bar)   ((dev)->p.resource[(bar)+8].flags)
+#define pnp_mem_valid(dev,bar)   (pnp_mem_flags((dev),(bar)) & IORESOURCE_MEM)
+#define pnp_mem_len(dev,bar) \
+	((pnp_mem_start((dev),(bar)) == 0 &&	\
+	  pnp_mem_end((dev),(bar)) ==		\
+	  pnp_mem_start((dev),(bar))) ? 0 :	\
+	  					\
+	 (pnp_mem_end((dev),(bar)) -		\
+	  pnp_mem_start((dev),(bar)) + 1))
+
+#define pnp_irq(dev,bar)	 ((dev)->p.irq_resource[(bar)].start)
+#define pnp_irq_flags(dev,bar)	 ((dev)->p.irq_resource[(bar)].flags)
+#define pnp_irq_valid(dev,bar)   (pnp_irq_flags((dev),(bar)) & IORESOURCE_IRQ)
+
+#define pnp_dma(dev,bar)	 ((dev)->p.dma_resource[(bar)].start)
+#define pnp_dma_flags(dev,bar)	 ((dev)->p.dma_resource[(bar)].flags)
+#define pnp_dma_valid(dev,bar)   (pnp_dma_flags((dev),(bar)) & IORESOURCE_DMA)
+
+#define PNP_PORT_FLAG_16BITADDR	ISAPNP_PORT_FLAG_16BITADDR
+#define PNP_PORT_FLAG_FIXED	ISAPNP_PORT_FLAG_FIXED
+
+#define PNP_RES_PRIORITY_PREFERRED	ISAPNP_RES_PRIORITY_PREFERRED
+#define PNP_RES_PRIORITY_ACCEPTABLE	ISAPNP_RES_PRIORITY_ACCEPTABLE
+#define PNP_RES_PRIORITY_FUNCTIONAL	ISAPNP_RES_PRIORITY_FUNCTIONAL
+#define PNP_RES_PRIORITY_INVALID	ISAPNP_RES_PRIORITY_INVALID
+
+struct pnp_resource_table {
+	struct resource port_resource[PNP_MAX_PORT];
+	struct resource mem_resource[PNP_MAX_MEM];
+	struct resource dma_resource[PNP_MAX_DMA];
+	struct resource irq_resource[PNP_MAX_IRQ];
+};
+
+
+/*
+ * Device Managemnt
+ */
+
+struct pnp_card_link {
+	struct pnp_card * card;
+	struct pnp_card_driver * driver;
+	void * driver_data;
+};
+
+static inline void *pnp_get_card_drvdata (struct pnp_card_link *pcard)
+{
+	return pcard->driver_data;
+}
+
+static inline void pnp_set_card_drvdata (struct pnp_card_link *pcard, void *data)
+{
+	pcard->driver_data = data;
+}
+
+struct pnp_fixup {
+	char id[7];
+	void (*quirk_function)(struct pnp_dev *dev);	/* fixup function */
+};
+
+/* config modes */
+#define PNP_CONFIG_AUTO		0x0001	/* Use the Resource Configuration Engine to determine resource settings */
+#define PNP_CONFIG_MANUAL	0x0002	/* the config has been manually specified */
+#define PNP_CONFIG_FORCE	0x0004	/* disables validity checking */
+#define PNP_CONFIG_INVALID	0x0008	/* If this flag is set, the pnp layer will refuse to activate the device */
+
+/* capabilities */
+#define PNP_READ		0x0001
+#define PNP_WRITE		0x0002
+#define PNP_DISABLE		0x0004
+#define PNP_CONFIGURABLE	0x0008
+#define PNP_REMOVABLE		0x0010
+
+#define pnp_can_read(dev)	1
+#define pnp_can_write(dev)	1
+#define pnp_can_disable(dev)	0
+#define pnp_can_configure(dev)	1
+
+#define pnp_device_is_isapnp(dev) 1
+
+#define isapnp_card_number(dev) (dev->p.bus->number)
+#define isapnp_csn_number(dev)  (dev->p.devfn)
+
+/*
+ * Driver Management
+ */
+
+struct pnp_id {
+	char id[PNP_ID_LEN];
+	struct pnp_id * next;
+};
+
+struct pnp_device_id {
+	char id[PNP_ID_LEN];
+	unsigned long driver_data;	/* data private to the driver */
+};
+
+struct pnp_card_device_id {
+	char id[PNP_ID_LEN];
+	unsigned long driver_data;	/* data private to the driver */
+	struct {
+		char id[PNP_ID_LEN];
+	} devs[PNP_MAX_DEVICES];	/* logical devices */
+};
+
+struct pnp_driver {
+	char * name;
+	const struct pnp_device_id *id_table;
+	unsigned int flags;
+	int  (*probe)  (struct pnp_dev *dev, const struct pnp_device_id *dev_id);
+	void (*remove) (struct pnp_dev *dev);
+};
+
+#define	to_pnp_driver(drv) container_of(drv, struct pnp_driver, driver)
+
+struct pnp_card_driver {
+	struct list_head global_list;
+	char * name;
+	const struct pnp_card_device_id *id_table;
+	unsigned int flags;
+	int  (*probe)  (struct pnp_card_link *card, const struct pnp_card_device_id *card_id);
+	void (*remove) (struct pnp_card_link *card);
+	struct pnp_driver link;
+};
+
+#define	to_pnp_card_driver(drv) container_of(drv, struct pnp_card_driver, link)
+
+/* pnp driver flags */
+#define PNP_DRIVER_RES_DO_NOT_CHANGE	0x0001	/* do not change the state of the device */
+#define PNP_DRIVER_RES_DISABLE		0x0003	/* ensure the device is disabled */
+
+#define pnp_resource_change(resource, start, size) isapnp_resource_change(resource, start, size)
+
+#if defined(CONFIG_PNP)
+
+struct pnp_dev * pnp_request_card_device(struct pnp_card_link *clink, const char * id, struct pnp_dev * from);
+void pnp_release_card_device(struct pnp_dev * dev);
+int pnp_register_card_driver(struct pnp_card_driver * drv);
+void pnp_unregister_card_driver(struct pnp_card_driver * drv);
+int pnp_register_driver(struct pnp_driver *drv);
+void pnp_unregister_driver(struct pnp_driver *drv);
+void pnp_init_resource_table(struct pnp_resource_table *table);
+int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode);
+int pnp_activate_dev(struct pnp_dev *dev);
+static inline int pnp_is_active(struct pnp_dev *dev) { return dev->p.active; }
+
+#else
+
+static inline struct pnp_dev * pnp_request_card_device(struct pnp_card_link *clink, const char * id, struct pnp_dev * from) { return NULL; }
+static inline void pnp_release_card_device(struct pnp_dev * dev) { ; }
+static inline int pnp_register_card_driver(struct pnp_card_driver * drv) { return 0; }
+static inline void pnp_unregister_card_driver(struct pnp_card_driver * drv) { ; }
+static inline int pnp_register_driver(struct pnp_driver *drv) { return 0; }
+static inline void pnp_unregister_driver(struct pnp_driver *drv) { ; }
+static inline void pnp_init_resource_table(struct pnp_resource_table *table) { ; }
+static inline int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode) { return -ENODEV; }
+static inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_is_active(struct pnp_dev * dev) { return -ENODEV; }
+
+#endif
+
+
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_PNP_H */
Files w5/lib/gen_crc32table and w4/lib/gen_crc32table differ
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff --exclude=ipsec --exclude='defconfig*' w5/sound/core/Makefile w4/sound/core/Makefile
--- w5/sound/core/Makefile	2003-08-07 21:17:11.000000000 +0200
+++ w4/sound/core/Makefile	2003-08-07 20:53:14.000000000 +0200
@@ -61,6 +61,8 @@ ifeq ($(CONFIG_SND_BIT32_EMUL),y)
   obj-y += ioctl32/snd-ioctl32.o
 endif
 
+subdir-m += pnp
+
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_DUMMY) += snd-pcm.o snd-timer.o snd-page-alloc.o snd.o
 obj-$(CONFIG_SND_VIRMIDI) += snd-rawmidi.o snd.o snd-timer.o
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff --exclude=ipsec --exclude='defconfig*' w5/sound/core/pnp/Makefile w4/sound/core/pnp/Makefile
--- w5/sound/core/pnp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ w4/sound/core/pnp/Makefile	2003-08-07 20:06:09.000000000 +0200
@@ -0,0 +1,18 @@
+#
+# Makefile for ALSA
+# Copyright (c) 2001 by Jaroslav Kysela <perex@suse.cz>
+#
+
+O_TARGET = _pnp.o
+
+list_multi	:= snd-pnp.o
+export-objs  += pnp.o
+
+snd-pnp-objs := pnp.o
+
+obj-m += snd-pnp.o
+
+include $(TOPDIR)/Rules.make
+
+snd-pnp.o: $(snd-pnp-objs)
+	$(LD) $(LD_RFLAG) -r -o $@ $(snd-pnp-objs)
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff --exclude=ipsec --exclude='defconfig*' w5/sound/core/pnp/pnp.c w4/sound/core/pnp/pnp.c
--- w5/sound/core/pnp/pnp.c	1970-01-01 01:00:00.000000000 +0100
+++ w4/sound/core/pnp/pnp.c	2003-08-07 19:17:42.000000000 +0200
@@ -0,0 +1,392 @@
+/*
+ *  Plug & Play 2.5 layer compatibility
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 0)
+#error "This driver is designed only for Linux 2.2.0 and higher."
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 3, 11)
+#define NEW_RESOURCE
+#endif
+
+#ifdef ALSA_BUILD
+#if defined(CONFIG_MODVERSIONS) && !defined(__GENKSYMS__) && !defined(__DEPEND__)
+#define MODVERSIONS
+#include <linux/modversions.h>
+#include "sndversions.h"
+#endif
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <linux/pci.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#ifndef ALSA_BUILD
+#include <linux/isapnp.h>
+#include <linux/pnp.h>
+#else
+#include <linux/isapnp.h>
+#undef CONFIG_PNP
+#define CONFIG_PNP
+#include "pnp.h"
+#endif
+
+#ifndef __init
+#define __init
+#endif
+
+#ifndef __exit
+#define __exit
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+#define module_init(x)      int init_module(void) { return x(); }
+#define module_exit(x)      void cleanup_module(void) { x(); }
+#endif
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("Plug & Play 2.5 compatible layer");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+
+#ifndef list_for_each_safe
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+#endif
+
+struct pnp_driver_instance {
+	struct pnp_dev * dev;
+	struct pnp_driver * driver;
+	struct list_head list;
+};
+
+struct pnp_card_driver_instance {
+	struct pnp_card_link link;
+	struct pnp_dev * devs[PNP_MAX_DEVICES];
+	struct list_head list;
+};
+
+static LIST_HEAD(pnp_drivers);
+static LIST_HEAD(pnp_card_drivers);
+
+static unsigned int from_hex(unsigned char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'A' && c <= 'F')
+		return (c - 'A') + 10;
+	if (c >= 'a' && c <= 'f')
+		return (c - 'a') + 10;
+	return 0x0f;
+}
+
+static int parse_id(const char * id, unsigned short * vendor, unsigned short * device)
+{
+	if (memcmp(id, "ANYDEVS", 7) == 0) {
+		*vendor = ISAPNP_ANY_ID;
+		*device = ISAPNP_ANY_ID;
+	} else {
+		*vendor = ISAPNP_VENDOR(id[0], id[1], id[2]);
+		if (memcmp(id + 3, "XXXX", 4) == 0) {
+			*device = ISAPNP_ANY_ID;
+		} else if (strchr(id + 3, 'X') != NULL) {
+			printk(KERN_ERR "cannot detect incomplete PnP ID definition '%s'\n", id);
+			return -EINVAL;
+		} else {
+			*device = ISAPNP_DEVICE((from_hex(id[3]) << 12) |
+						(from_hex(id[4]) << 8) |
+						(from_hex(id[5]) << 4) |
+						from_hex(id[6]));
+		}
+	}
+	return 0;
+}
+
+struct pnp_dev * pnp_request_card_device(struct pnp_card_link *clink, const char * id, struct pnp_dev * from)
+{
+	unsigned short vendor, function;
+	struct pnp_dev *dev;
+
+	if (parse_id(id, &vendor, &function) < 0)
+		return NULL;
+	dev = (struct pnp_dev *)isapnp_find_dev((struct isapnp_card *)clink->card, vendor, function, (struct isapnp_dev *)from);
+	if (dev != NULL && dev->p.active &&
+	    (clink->driver->flags & PNP_DRIVER_RES_DO_NOT_CHANGE) == 0)
+		return NULL;
+	return dev;
+}
+
+void pnp_release_card_device(struct pnp_dev * dev)
+{
+	if (!dev->p.active)
+		return;
+	dev->p.deactivate((struct isapnp_dev *)dev);
+}
+
+int pnp_register_card_driver(struct pnp_card_driver * drv)
+{
+	unsigned short vendor, device;
+	unsigned int i, res = 0;
+	const struct pnp_card_device_id *cid;
+	struct pnp_card *card;
+	struct pnp_dev *dev;
+	struct pnp_card_driver_instance *ninst = NULL;
+	
+	for (cid = drv->id_table; cid->id[0] != '\0'; cid++) {
+	      __next_card:
+		card = NULL;
+		do {
+		      __next:
+			if (parse_id(cid->id, &vendor, &device) < 0)
+				break;
+			card = (struct pnp_card *)isapnp_find_card(vendor, device, (struct isapnp_card *)card);
+			if (card) {
+				if (ninst == NULL) {
+					ninst = kmalloc(sizeof(*ninst), GFP_KERNEL);
+					if (ninst == NULL)
+						return res > 0 ? (int)res : -ENOMEM;
+					memset(ninst, 0, sizeof(*ninst));
+					INIT_LIST_HEAD(&ninst->list);
+				}
+				for (i = 0; i < PNP_MAX_DEVICES; i++)
+					ninst->devs[i] = NULL;
+				for (i = 0; i < PNP_MAX_DEVICES && cid->devs[i].id[0] != '\0'; i++) {
+					if (parse_id(cid->devs[i].id, &vendor, &device) < 0) {
+						cid++;
+						goto __next_card;
+					}
+					dev = ninst->devs[i] = (struct pnp_dev *)isapnp_find_dev((struct isapnp_card *)card, vendor, device, NULL);
+					if (dev == NULL)
+						goto __next;
+				}
+				ninst->link.card = card;
+				ninst->link.driver = drv;
+				ninst->link.driver_data = NULL;
+				if (drv->probe(&ninst->link, cid) >= 0) {
+					list_add_tail(&ninst->list, &pnp_card_drivers);
+					ninst = NULL;
+					res++;
+				}
+			}
+		} while (card != NULL);
+	}
+
+	if (ninst != NULL)
+		kfree(ninst);
+ 
+	return res;
+}
+
+void pnp_unregister_card_driver(struct pnp_card_driver * drv)
+{
+	struct pnp_card_driver_instance *inst;
+	struct list_head *p, *n;
+	unsigned int i;
+	
+	list_for_each_safe(p, n, &pnp_card_drivers) {
+		inst = list_entry(p, struct pnp_card_driver_instance, list);
+		if (inst->link.driver == drv) {
+			list_del(p);
+			drv->remove(&inst->link);
+			if ((drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE) == 0)
+				for (i = 0; i < PNP_MAX_DEVICES && inst->devs[i]; i++)
+					pnp_release_card_device(inst->devs[i]);
+			kfree(inst);
+		}
+	}
+}
+
+int pnp_register_driver(struct pnp_driver *drv)
+{
+	unsigned short vendor, function;
+	unsigned int res = 0;
+	const struct pnp_device_id *did;
+	struct pnp_dev *dev;
+	struct pnp_driver_instance *ninst = NULL;
+	
+	for (did = drv->id_table; did->id[0] != '\0'; did++) {
+		dev = NULL;
+		if (ninst == NULL) {
+			ninst = kmalloc(sizeof(*ninst), GFP_KERNEL);
+			if (ninst == NULL)
+				return res > 0 ? (int)res : -ENOMEM;
+			memset(ninst, 0, sizeof(*ninst));
+			INIT_LIST_HEAD(&ninst->list);
+		}
+		if (parse_id(did->id, &vendor, &function) < 0)
+			continue;
+		dev = ninst->dev = (struct pnp_dev *)isapnp_find_dev(NULL, vendor, function, (struct isapnp_dev *)dev);
+		if (dev == NULL)
+			continue;
+		ninst->driver = drv;
+		if (drv->probe(ninst->dev, did) >= 0) {
+			list_add_tail(&ninst->list, &pnp_drivers);
+			ninst = NULL;
+			res++;
+		}
+	}
+	return res;
+}
+
+void pnp_unregister_driver(struct pnp_driver *drv)
+{
+	struct pnp_driver_instance *inst;
+	struct list_head *p, *n;
+	
+	list_for_each_safe(p, n, &pnp_drivers) {
+		inst = list_entry(p, struct pnp_driver_instance, list);
+		if (inst->driver == drv) {
+			list_del(p);
+			drv->remove(inst->dev);
+			if (inst->dev->p.active)
+				inst->dev->p.deactivate((struct isapnp_dev *)inst->dev);
+			kfree(inst);
+		}
+	}
+}
+
+static void copy_resource(struct resource *dst, const struct resource *src)
+{
+	dst->name = src->name;
+	dst->start = src->start;
+	dst->end = src->end;
+	dst->flags = (dst->flags & ~IORESOURCE_AUTO) |
+		(dst->flags & src->flags & IORESOURCE_AUTO);
+}
+
+void pnp_init_resource_table(struct pnp_resource_table *table)
+{
+	unsigned int idx;
+
+	for (idx = 0; idx < PNP_MAX_IRQ; idx++) {
+		table->irq_resource[idx].name = NULL;
+		table->irq_resource[idx].start = 0;
+		table->irq_resource[idx].end = 0;
+		table->irq_resource[idx].flags = IORESOURCE_AUTO;
+	}
+	for (idx = 0; idx < PNP_MAX_DMA; idx++) {
+		table->dma_resource[idx].name = NULL;
+		table->dma_resource[idx].start = 0;
+		table->dma_resource[idx].end = 0;
+		table->dma_resource[idx].flags = IORESOURCE_AUTO;
+	}
+	for (idx = 0; idx < PNP_MAX_PORT; idx++) {
+		table->port_resource[idx].name = NULL;
+		table->port_resource[idx].start = 0;
+		table->port_resource[idx].end = 0;
+		table->port_resource[idx].flags = IORESOURCE_AUTO;
+	}
+	for (idx = 0; idx < PNP_MAX_MEM; idx++) {
+		table->mem_resource[idx].name = NULL;
+		table->mem_resource[idx].start = 0;
+		table->mem_resource[idx].end = 0;
+		table->mem_resource[idx].flags = IORESOURCE_AUTO;
+	}
+}
+
+/* FIXME: this function cannot be called many times.  the setting is cleared at each time */
+int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode)
+{
+	unsigned int idx;
+	int err;
+
+	/* prepare the isapnp */
+	err = dev->p.prepare((struct isapnp_dev *)dev);
+
+	for (idx = 0; idx < PNP_MAX_IRQ; idx++)
+		copy_resource(&dev->p.irq_resource[idx], &res->irq_resource[idx]);
+	for (idx = 0; idx < PNP_MAX_DMA; idx++)
+		copy_resource(&dev->p.dma_resource[idx], &res->dma_resource[idx]);
+	for (idx = 0; idx < PNP_MAX_PORT; idx++)
+		copy_resource(&dev->p.resource[idx], &res->port_resource[idx]);
+	for (idx = 0; idx < PNP_MAX_MEM; idx++)
+		copy_resource(&dev->p.resource[idx+8], &res->mem_resource[idx]);
+
+	return 0;
+}
+
+int pnp_activate_dev(struct pnp_dev *dev)
+{
+	struct pnp_resource_table *tmp;
+	unsigned int idx;
+
+	if (dev->p.active)
+		return -EBUSY;
+
+	/* reserve the manual configuration */
+	tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);
+	if (! tmp)
+		return -ENOMEM;
+	pnp_init_resource_table(tmp);
+	for (idx = 0; idx < PNP_MAX_IRQ; idx++)
+		copy_resource(&tmp->irq_resource[idx], &dev->p.irq_resource[idx]);
+	for (idx = 0; idx < PNP_MAX_DMA; idx++)
+		copy_resource(&tmp->dma_resource[idx], &dev->p.dma_resource[idx]);
+	for (idx = 0; idx < PNP_MAX_PORT; idx++)
+		copy_resource(&tmp->port_resource[idx], &dev->p.resource[idx]);
+	for (idx = 0; idx < PNP_MAX_MEM; idx++)
+		copy_resource(&tmp->mem_resource[idx], &dev->p.resource[idx+8]);
+
+	/* restore the manual configuration again */
+	pnp_manual_config_dev(dev, tmp, 0);
+	kfree(tmp);
+
+	return dev->p.activate((struct isapnp_dev *)dev);
+}
+
+static int __init pnp_init(void)
+{
+	return 0;
+}
+
+static void __exit pnp_exit(void)
+{
+}
+
+module_init(pnp_init)
+module_exit(pnp_exit)
+
+EXPORT_SYMBOL(pnp_request_card_device);
+EXPORT_SYMBOL(pnp_release_card_device);
+EXPORT_SYMBOL(pnp_register_card_driver);
+EXPORT_SYMBOL(pnp_unregister_card_driver);
+EXPORT_SYMBOL(pnp_register_driver);
+EXPORT_SYMBOL(pnp_unregister_driver);
+EXPORT_SYMBOL(pnp_init_resource_table);
+EXPORT_SYMBOL(pnp_manual_config_dev);
+EXPORT_SYMBOL(pnp_activate_dev);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff --exclude=ipsec --exclude='defconfig*' w5/sound/core/seq/seq_clientmgr.c w4/sound/core/seq/seq_clientmgr.c
--- w5/sound/core/seq/seq_clientmgr.c	2003-07-25 19:22:26.000000000 +0200
+++ w4/sound/core/seq/seq_clientmgr.c	2003-08-07 21:15:34.000000000 +0200
@@ -143,7 +143,9 @@ client_t *snd_seq_client_use_ptr(int cli
 					if (seq_client_load[idx] < 0)
 						break;
 					if (seq_client_load[idx] == clientid) {
-						request_module("snd-seq-client-%i", clientid);
+						char str[32];
+						sprintf(str, "snd-seq-client-%i", clientid);
+						request_module(str);
 						break;
 					}
 				}
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff --exclude=ipsec --exclude='defconfig*' w5/sound/core/sound.c w4/sound/core/sound.c
--- w5/sound/core/sound.c	2003-08-07 21:17:11.000000000 +0200
+++ w4/sound/core/sound.c	2003-08-07 20:08:29.000000000 +0200
@@ -511,3 +511,13 @@ EXPORT_SYMBOL(snd_wrapper_kfree);
 EXPORT_SYMBOL(snd_wrapper_vmalloc);
 EXPORT_SYMBOL(snd_wrapper_vfree);
 #endif
+
+#ifndef CONFIG_HAVE_STRLCPY
+EXPORT_SYMBOL(snd_compat_strlcpy);
+EXPORT_SYMBOL(snd_compat_strlcat);
+#endif
+
+#if defined(CONFIG_DEVFS_FS) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 67)
+EXPORT_SYMBOL(snd_compat_devfs_mk_dir);
+EXPORT_SYMBOL(snd_compat_devfs_mk_cdev);
+#endif
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff --exclude=ipsec --exclude='defconfig*' w5/sound/core/wrappers.c w4/sound/core/wrappers.c
--- w5/sound/core/wrappers.c	2003-04-08 17:33:59.000000000 +0200
+++ w4/sound/core/wrappers.c	2003-08-07 19:43:53.000000000 +0200
@@ -25,6 +25,7 @@
 #include <linux/ioport.h>
 #include <linux/vmalloc.h>
 #include <linux/fs.h>
+#include <linux/devfs_fs_kernel.h>
 
 #ifdef CONFIG_SND_DEBUG_MEMORY
 void *snd_wrapper_kmalloc(size_t size, int flags)
@@ -48,3 +49,65 @@ void snd_wrapper_vfree(void *obj)
 }
 #endif
 
+size_t snd_compat_strlcpy(char *dest, const char *src, size_t size)
+{
+	size_t ret = strlen(src);
+
+	if (size) {
+		size_t len = (ret >= size) ? size-1 : ret;
+		memcpy(dest, src, len);
+		dest[len] = '\0';
+	}
+	return ret;
+}
+
+size_t snd_compat_strlcat(char *dest, const char *src, size_t count)
+{
+	size_t dsize = strlen(dest);
+	size_t len = strlen(src);
+	size_t res = dsize + len;
+
+	/* This would be a bug */
+	BUG_ON(dsize >= count);
+
+	dest += dsize;
+	count -= dsize;
+	if (len >= count)
+		len = count-1;
+	memcpy(dest, src, len);
+	dest[len] = 0;
+	return res;
+}
+
+int snd_compat_devfs_mk_dir(const char *dir, ...)
+{
+	char buf[64];
+	va_list args;
+	int n;
+
+	va_start(args, dir);
+	n = vsnprintf(buf, 64, dir, args);
+	va_end(args);
+	if (n < 64 && buf[0]) {
+		return devfs_mk_dir(NULL, buf, NULL) ? -EIO : 0;
+	}
+	return 0;
+}
+
+extern struct file_operations snd_fops;
+int snd_compat_devfs_mk_cdev(dev_t dev, umode_t mode, const char *fmt, ...)
+{
+	char buf[64];
+	va_list args;
+	int n;
+
+	va_start(args, fmt);
+	n = vsnprintf(buf, 64, fmt, args);
+	va_end(args);
+	if (n < 64 && buf[0]) {
+		devfs_register(NULL, buf, DEVFS_FL_DEFAULT,
+			       major(dev), minor(dev), mode,
+			       &snd_fops, NULL);
+	}
+	return 0;
+}
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff --exclude=ipsec --exclude='defconfig*' w5/sound/usb/usbaudio.c w4/sound/usb/usbaudio.c
--- w5/sound/usb/usbaudio.c	2003-08-07 21:17:11.000000000 +0200
+++ w4/sound/usb/usbaudio.c	2003-08-07 17:32:23.000000000 +0200
@@ -1721,10 +1721,6 @@ void *snd_usb_find_csint_desc(void *buff
  * entry point for linux usb interface
  */
 
-static int usb_audio_probe(struct usb_interface *intf,
-			   const struct usb_device_id *id);
-static void usb_audio_disconnect(struct usb_interface *intf);
-
 static struct usb_device_id usb_audio_ids [] = {
 #include "usbquirks.h"
     { .match_flags = (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS),
@@ -2868,28 +2864,6 @@ static void snd_usb_audio_disconnect(str
 	}
 }
 
-/*
- * new 2.5 USB kernel API
- */
-static int usb_audio_probe(struct usb_interface *intf,
-			   const struct usb_device_id *id)
-{
-	void *chip;
-	chip = snd_usb_audio_probe(interface_to_usbdev(intf), intf, id);
-	if (chip) {
-		dev_set_drvdata(&intf->dev, chip);
-		return 0;
-	} else
-		return -EIO;
-}
-
-static void usb_audio_disconnect(struct usb_interface *intf)
-{
-	snd_usb_audio_disconnect(interface_to_usbdev(intf),
-				 dev_get_drvdata(&intf->dev));
-}
-
-
 static int __init snd_usb_audio_init(void)
 {
 	if (nrpacks < 2 || nrpacks > MAX_PACKS) {
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff --exclude=ipsec --exclude='defconfig*' w5/sound/usb/usbmidi.c w4/sound/usb/usbmidi.c
--- w5/sound/usb/usbmidi.c	2003-08-07 21:17:11.000000000 +0200
+++ w4/sound/usb/usbmidi.c	2003-08-07 17:34:27.000000000 +0200
@@ -137,7 +137,7 @@ static const uint8_t snd_usbmidi_cin_len
  */
 static int snd_usbmidi_submit_urb(struct urb* urb, int flags)
 {
-	int err = usb_submit_urb(urb, flags);
+	int err = usb_submit_urb(urb);
 	if (err < 0 && err != -ENODEV)
 		snd_printk(KERN_ERR "usb_submit_urb: %d\n", err);
 	return err;
@@ -581,7 +581,7 @@ static int snd_usbmidi_in_endpoint_creat
 	else
 		int_epd = snd_usbmidi_get_int_epd(umidi);
 
-	ep->urb = usb_alloc_urb(0, GFP_KERNEL);
+	ep->urb = usb_alloc_urb(0);
 	if (!ep->urb) {
 		snd_usbmidi_in_endpoint_delete(ep);
 		return -ENOMEM;
@@ -652,7 +652,7 @@ static int snd_usbmidi_out_endpoint_crea
 		return -ENOMEM;
 	ep->umidi = umidi;
 
-	ep->urb = usb_alloc_urb(0, GFP_KERNEL);
+	ep->urb = usb_alloc_urb(0);
 	if (!ep->urb) {
 		snd_usbmidi_out_endpoint_delete(ep);
 		return -ENOMEM;
