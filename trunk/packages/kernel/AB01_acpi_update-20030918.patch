# This is a BitKeeper generated patch for the following project:
# Project Name: Linux kernel tree
# This patch format is intended for GNU patch command version 2.5 or higher.
# This patch includes the following deltas:
#	           ChangeSet	1.1100  -> 1.1120 
#	include/linux/acpi.h	1.19    -> 1.20   
#	drivers/acpi/asus_acpi.c	1.1     -> 1.4    
#	include/asm-i386/acpi.h	1.7     -> 1.8    
#	drivers/acpi/dispatcher/dswload.c	1.18    -> 1.19   
#	include/acpi/acstruct.h	1.12    -> 1.13   
#	drivers/acpi/events/evregion.c	1.17    -> 1.18   
#	drivers/acpi/dispatcher/dsfield.c	1.18    -> 1.19   
#	drivers/acpi/tables.c	1.10    -> 1.11   
#	drivers/acpi/parser/psparse.c	1.17    -> 1.18   
#	arch/i386/kernel/Makefile	1.7     -> 1.8    
#	arch/x86_64/kernel/setup.c	1.5     -> 1.6    
#	include/acpi/acconfig.h	1.36    -> 1.38   
#	   drivers/acpi/ec.c	1.12    -> 1.13   
#	arch/i386/mm/ioremap.c	1.4     -> 1.5    
#	drivers/acpi/dispatcher/dsopcode.c	1.17    -> 1.18   
#	arch/i386/kernel/mpparse.c	1.31    -> 1.35   
#	arch/i386/kernel/dmi_scan.c	1.35    -> 1.36   
#	drivers/acpi/dispatcher/dsutils.c	1.15    -> 1.16   
#	arch/i386/kernel/setup.c	1.71    -> 1.72   
#	drivers/acpi/namespace/nsutils.c	1.21    -> 1.22   
#	drivers/acpi/pci_link.c	1.7     -> 1.11   
#	drivers/acpi/dispatcher/dsinit.c	1.9     -> 1.10   
#	  drivers/acpi/bus.c	1.16    -> 1.17   
#	         MAINTAINERS	1.106   -> 1.107  
#	include/acpi/acdisasm.h	1.1     -> 1.2    
#	arch/i386/kernel/acpi.c	1.12    -> 1.13   
#	drivers/acpi/Config.in	1.12    -> 1.14   
#	drivers/acpi/dispatcher/dswstate.c	1.16    -> 1.17   
#	drivers/acpi/namespace/nsdump.c	1.16    -> 1.17   
#	Documentation/Configure.help	1.178   -> 1.179  
#	drivers/acpi/executer/excreate.c	1.14    -> 1.15   
#	drivers/acpi/namespace/nssearch.c	1.16    -> 1.17   
#	drivers/acpi/pci_irq.c	1.11    -> 1.12   
#	drivers/acpi/dispatcher/dswscope.c	1.13    -> 1.14   
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 03/09/08	len.brown@intel.com	1.1101
# Extended IRQ resource type for nForce (Andrew de Quincey)
# Handle BIOS with _CRS that fails (Jun Nakajima)
# --------------------------------------------
# 03/09/08	len.brown@intel.com	1.1102
# Fix ACPI oops on ThinkPad T32/T40 (Shaohua David Li)
# --------------------------------------------
# 03/09/08	len.brown@intel.com	1.1103
# support non ACPI compliant SCI over-ride specs (Jun Nakajima)
# --------------------------------------------
# 03/09/08	len.brown@intel.com	1.1104
# remove ASUS A7V BIOS version 1011 from blacklist (Eric Valette)
# --------------------------------------------
# 03/09/12	len.brown@intel.com	1.1105
# fix off-by-one error in ioremap()
# fixes kernel crash in acpi mode: http://bugzilla.kernel.org/show_bug.cgi?id=1085
# --------------------------------------------
# 03/09/16	len.brown@intel.com	1.1106
# ACPI_CA_VERSION                 0x20030916
# --------------------------------------------
# 03/09/17	len.brown@intel.com	1.1107
# tables.c.diff
# --------------------------------------------
# 03/09/17	len.brown@intel.com	1.1108
# from 2.6
# acpi_pci_link_get_irq() returns 0 on error, not -ENODEV. (Christophe Saout)
# --------------------------------------------
# 03/09/17	len.brown@intel.com	1.1109
# exclude acpitable.[ch] from the CONFIG_ACPI_HT_ONLY build
# --------------------------------------------
# 03/09/18	len.brown@intel.com	1.1110
# [ACPI] Fix SCI storm on out of spec boards like Tyan
# http://bugzilla.kernel.org/show_bug.cgi?id=774
# --------------------------------------------
# 03/09/18	len.brown@intel.com	1.1111
# [ACPI] acpi_disabled is used after __initdata is freed.
# fixes random battery module loading problem -- SuSE bug #30477 (Andi Kleen)
# --------------------------------------------
# 03/09/19	len.brown@intel.com	1.1112
# [ACPI] fix IO-APIC mode SCI storm due to sharing with PCI device (David Shaohua Li)
# http://bugzilla.kernel.org/show_bug.cgi?id=1165
# --------------------------------------------
# 03/09/25	len.brown@intel.com	1.1113
# [ACPI] For ThinkPad -- carry on in face of ECDT probe failure (Andi Kleen)
# --------------------------------------------
# 03/09/29	len.brown@intel.com	1.1114
# [ACPI] ACPI Component Architecture 20030918 (Bob Moore)
# 
# Found and fixed a longstanding problem with the late execution of
# the various deferred AML opcodes (such as Operation Regions,
# Buffer Fields, Buffers, and Packages)...
# This fixes the "region size computed incorrectly" problem.
# 
# Fixed several 64-bit issues with prototypes, casting and data types.
# 
# Removed duplicate prototype from acdisasm.h
# --------------------------------------------
# 03/09/29	len.brown@intel.com	1.1115
# [ACPI] CONFIG_ACPI is no longer necessary to enable HT
# if (CONFIG_ACPI || CONFIG_SMP) CONFIG_ACPI_BOOT=y
# --------------------------------------------
# 03/09/30	len.brown@intel.com	1.1116
# [ACPI] acpi_pci_link_allocate() should stick with irq.active if set.  (Andrew de Quincey)
# Fixes OSDL #1186 "broken USB" and others
# --------------------------------------------
# 03/09/30	len.brown@intel.com	1.1117
# [ACPI] acpi4asus-0.24a-0.25-2.4 (Karol Kozimor)
# --------------------------------------------
# 03/09/30	len.brown@intel.com	1.1118
# [ACPI] acpi4asus-0.25-0.26 (Karol Kozimor)
# --------------------------------------------
# 03/09/30	len.brown@intel.com	1.1119
# [ACPI] build fix: remove 2nd __exit from asus_acpi.c
# --------------------------------------------
# 03/09/30	len.brown@intel.com	1.1120
# [ACPI] deal with lack of acpi prt entries gracefully (Jesse Barnes)
# --------------------------------------------
#
diff -Nru a/Documentation/Configure.help b/Documentation/Configure.help
--- a/Documentation/Configure.help	Wed Oct  1 01:10:29 2003
+++ b/Documentation/Configure.help	Wed Oct  1 01:10:29 2003
@@ -19084,6 +19084,9 @@
   display brightness and output, switching the LCD backlight on and off,
   and most importantly, allows you to blink those fancy LEDs intended
   for reporting mail and wireless status.
+
+  Note: the display switching code is currently considered EXPERIMENTAL,
+  toying with these values may even lock your machine.
   
   All settings are changed via /proc/acpi/asus directory entries. Owner
   and group for these entries can be set with asus_uid and asus_gid
diff -Nru a/MAINTAINERS b/MAINTAINERS
--- a/MAINTAINERS	Wed Oct  1 01:10:29 2003
+++ b/MAINTAINERS	Wed Oct  1 01:10:29 2003
@@ -266,6 +266,16 @@
 L:	linux-net@vger.kernel.org
 S:	Maintained
 
+ASUS ACPI EXTRAS DRIVER
+P:	Karol Kozimor
+M:	sziwan@users.sourceforge.net
+P:	Julien Lerouge
+M:	julien.lerouge@free.fr
+L:	acpi4asus-user@lists.sourceforge.net
+W:	http://sourceforge.net/projects/acpi4asus
+W:	http://julien.lerouge.free.fr
+S:	Maintained
+
 ATM
 P:	Chas Williams
 M:	chas@cmf.nrl.navy.mil
diff -Nru a/arch/i386/kernel/Makefile b/arch/i386/kernel/Makefile
--- a/arch/i386/kernel/Makefile	Wed Oct  1 01:10:29 2003
+++ b/arch/i386/kernel/Makefile	Wed Oct  1 01:10:29 2003
@@ -38,7 +38,6 @@
 obj-$(CONFIG_APM)		+= apm.o
 obj-$(CONFIG_ACPI_BOOT)		+= acpi.o
 obj-$(CONFIG_ACPI_SLEEP)	+= acpi_wakeup.o
-obj-$(CONFIG_ACPI_HT_ONLY)	+= acpitable.o
 obj-$(CONFIG_SMP)		+= smp.o smpboot.o trampoline.o
 obj-$(CONFIG_X86_LOCAL_APIC)	+= mpparse.o apic.o nmi.o
 obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o
diff -Nru a/arch/i386/kernel/acpi.c b/arch/i386/kernel/acpi.c
--- a/arch/i386/kernel/acpi.c	Wed Oct  1 01:10:29 2003
+++ b/arch/i386/kernel/acpi.c	Wed Oct  1 01:10:29 2003
@@ -355,7 +355,6 @@
 
 	result = acpi_table_parse(ACPI_APIC, acpi_parse_madt);
 	if (!result) {
-		printk(KERN_WARNING PREFIX "MADT not present\n");
 		return 0;
 	}
 	else if (result < 0) {
diff -Nru a/arch/i386/kernel/dmi_scan.c b/arch/i386/kernel/dmi_scan.c
--- a/arch/i386/kernel/dmi_scan.c	Wed Oct  1 01:10:29 2003
+++ b/arch/i386/kernel/dmi_scan.c	Wed Oct  1 01:10:29 2003
@@ -1033,11 +1033,6 @@
 			MATCH(DMI_BOARD_NAME, "CUR-DLS"),
 			NO_MATCH, NO_MATCH }},
 
-	{ force_acpi_ht, "ASUS A7V", {
-			MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC"),
-			MATCH(DMI_BOARD_NAME, "<A7V>"),
-			MATCH(DMI_BIOS_VERSION, "ASUS A7V ACPI BIOS Revision 1011"), NO_MATCH }},
-
 	{ force_acpi_ht, "ABIT i440BX-W83977", {
 			MATCH(DMI_BOARD_VENDOR, "ABIT <http://www.abit.com>"),
 			MATCH(DMI_BOARD_NAME, "i440BX-W83977 (BP6)"),
@@ -1070,7 +1065,9 @@
 	{ disable_acpi_pci, "ASUS A7V", {
 			MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC"),
 			MATCH(DMI_BOARD_NAME, "<A7V>"),
-			MATCH(DMI_BIOS_VERSION, "ASUS A7V ACPI BIOS Revision 1007"), NO_MATCH }},
+			/* newer BIOS, Revision 1011, does work */
+			MATCH(DMI_BIOS_VERSION, "ASUS A7V ACPI BIOS Revision 1007"),
+			NO_MATCH }},
 #endif	// CONFIG_ACPI_BOOT
 
 	{ NULL, }
diff -Nru a/arch/i386/kernel/mpparse.c b/arch/i386/kernel/mpparse.c
--- a/arch/i386/kernel/mpparse.c	Wed Oct  1 01:10:29 2003
+++ b/arch/i386/kernel/mpparse.c	Wed Oct  1 01:10:29 2003
@@ -1199,8 +1199,6 @@
 	}
 }
 
-/* Ensure the ACPI SCI interrupt level is active low, edge-triggered */
-
 extern FADT_DESCRIPTOR acpi_fadt;
 
 void __init mp_config_ioapic_for_sci(int irq)
@@ -1209,6 +1207,7 @@
 	int ioapic_pin;
 	struct acpi_table_madt* madt;
 	struct acpi_table_int_src_ovr *entry = NULL;
+	acpi_interrupt_flags flags;
 	void *madt_end;
 	acpi_status status;
 
@@ -1227,30 +1226,36 @@
 
 		while ((void *) entry < madt_end) {
                 	if (entry->header.type == ACPI_MADT_INT_SRC_OVR &&
-			    acpi_fadt.sci_int == entry->bus_irq) {
-				/*
-				 * See the note at the end of ACPI 2.0b section
-				 * 5.2.10.8 for what this is about.
-				 */
-				if (entry->bus_irq != entry->global_irq) {
-					acpi_fadt.sci_int = entry->global_irq;
-					irq = entry->global_irq;
-					break;
-				}
-				else
-                			return;
-			}
-
+			    acpi_fadt.sci_int == entry->bus_irq)
+				goto found;
+			
                 	entry = (struct acpi_table_int_src_ovr *)
                 	        ((unsigned long) entry + entry->header.length);
         	}
 	}
+	/*
+	 * Although the ACPI spec says that the SCI should be level/low
+	 * don't reprogram it unless there is an explicit MADT OVR entry
+	 * instructing us to do so -- otherwise we break Tyan boards which
+	 * have the SCI wired edge/high but no MADT OVR.
+	 */
+	return;
 
+found:
+	/*
+	 * See the note at the end of ACPI 2.0b section
+	 * 5.2.10.8 for what this is about.
+	 */
+	flags = entry->flags;
+	acpi_fadt.sci_int = entry->global_irq;
+	irq = entry->global_irq;
+	
 	ioapic = mp_find_ioapic(irq);
 
 	ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
 
-	io_apic_set_pci_routing(ioapic, ioapic_pin, irq, 1, 1); // Active low, level triggered
+	io_apic_set_pci_routing(ioapic, ioapic_pin, irq, 
+				(flags.trigger >> 1) , (flags.polarity >> 1));
 }
 
 
@@ -1288,8 +1293,10 @@
 		}
 
 		/* Don't set up the ACPI SCI because it's already set up */
-		if (acpi_fadt.sci_int == irq)
+                if (acpi_fadt.sci_int == irq) {
+                        entry->irq = irq; /*we still need to set entry's irq*/
 			continue;
+                }
 	
 		ioapic = mp_find_ioapic(irq);
 		if (ioapic < 0)
diff -Nru a/arch/i386/kernel/setup.c b/arch/i386/kernel/setup.c
--- a/arch/i386/kernel/setup.c	Wed Oct  1 01:10:29 2003
+++ b/arch/i386/kernel/setup.c	Wed Oct  1 01:10:29 2003
@@ -176,9 +176,9 @@
 static u32 disabled_x86_caps[NCAPINTS] __initdata = { 0 };
 
 #ifdef	CONFIG_ACPI_INTERPRETER
-	int acpi_disabled __initdata = 0;
+	int acpi_disabled = 0;
 #else
-	int acpi_disabled __initdata = 1;
+	int acpi_disabled = 1;
 #endif
 EXPORT_SYMBOL(acpi_disabled);
 
diff -Nru a/arch/i386/mm/ioremap.c b/arch/i386/mm/ioremap.c
--- a/arch/i386/mm/ioremap.c	Wed Oct  1 01:10:29 2003
+++ b/arch/i386/mm/ioremap.c	Wed Oct  1 01:10:29 2003
@@ -140,7 +140,7 @@
 	 */
 	offset = phys_addr & ~PAGE_MASK;
 	phys_addr &= PAGE_MASK;
-	size = PAGE_ALIGN(last_addr) - phys_addr;
+	size = PAGE_ALIGN(last_addr+1) - phys_addr;
 
 	/*
 	 * Ok, go for it..
diff -Nru a/arch/x86_64/kernel/setup.c b/arch/x86_64/kernel/setup.c
--- a/arch/x86_64/kernel/setup.c	Wed Oct  1 01:10:29 2003
+++ b/arch/x86_64/kernel/setup.c	Wed Oct  1 01:10:29 2003
@@ -48,7 +48,7 @@
 #include <asm/bootsetup.h>
 #include <asm/proto.h>
 
-int acpi_disabled __initdata = 0;
+int acpi_disabled = 0;
 
 /*
  * Machine setup..
diff -Nru a/drivers/acpi/Config.in b/drivers/acpi/Config.in
--- a/drivers/acpi/Config.in	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/Config.in	Wed Oct  1 01:10:29 2003
@@ -8,36 +8,32 @@
   comment 'ACPI Support'
   bool         'ACPI Support' CONFIG_ACPI
   if [ "$CONFIG_ACPI" = "y" ]; then
-    if [ "$CONFIG_SMP" = "y" ]; then
-      bool         'CPU Enumeration Only' CONFIG_ACPI_HT_ONLY
-    else
-      define_bool CONFIG_ACPI_HT_ONLY n
-    fi
 
-    if [ "$CONFIG_ACPI_HT_ONLY" = "n" ]; then
+    define_bool CONFIG_ACPI_BOOT		y
+    define_bool CONFIG_ACPI_BUS			y
+    define_bool CONFIG_ACPI_INTERPRETER		y
+    define_bool CONFIG_ACPI_EC			y
+    define_bool CONFIG_ACPI_POWER		y
+    if [ "$CONFIG_PCI" = "y" ]; then
+      define_bool CONFIG_ACPI_PCI		y
+    fi
+    define_bool CONFIG_ACPI_SLEEP		y
+    define_bool CONFIG_ACPI_SYSTEM		y
+    tristate     '  AC Adapter'	CONFIG_ACPI_AC
+    tristate     '  Battery'		CONFIG_ACPI_BATTERY
+    tristate     '  Button'		CONFIG_ACPI_BUTTON
+    tristate     '  Fan'		CONFIG_ACPI_FAN
+    tristate     '  Processor'	CONFIG_ACPI_PROCESSOR
+    dep_tristate '  Thermal Zone' 	CONFIG_ACPI_THERMAL $CONFIG_ACPI_PROCESSOR
+    if [ "$CONFIG_NUMA" = "y" -a "$CONFIG_X86_64" != "y" ]; then
+      dep_bool       '  NUMA support'     CONFIG_ACPI_NUMA $CONFIG_NUMA
+    fi
+    tristate     '  ASUS Laptop Extras'  CONFIG_ACPI_ASUS
+    tristate     '  Toshiba Laptop Extras'	CONFIG_ACPI_TOSHIBA
+    bool         '  Debug Statements'	CONFIG_ACPI_DEBUG
+    bool         '  Relaxed AML Checking'	CONFIG_ACPI_RELAXED_AML
+  else if [ "$CONFIG_SMP" = "y" ]; then
       define_bool CONFIG_ACPI_BOOT		y
-      define_bool CONFIG_ACPI_BUS		y
-      define_bool CONFIG_ACPI_INTERPRETER	y
-      define_bool CONFIG_ACPI_EC		y
-      define_bool CONFIG_ACPI_POWER		y
-      if [ "$CONFIG_PCI" = "y" ]; then
-        define_bool CONFIG_ACPI_PCI		y
-      fi
-      define_bool CONFIG_ACPI_SLEEP		y
-      define_bool CONFIG_ACPI_SYSTEM		y
-      tristate     '  AC Adapter'	CONFIG_ACPI_AC
-      tristate     '  Battery'		CONFIG_ACPI_BATTERY
-      tristate     '  Button'		CONFIG_ACPI_BUTTON
-      tristate     '  Fan'		CONFIG_ACPI_FAN
-      tristate     '  Processor'	CONFIG_ACPI_PROCESSOR
-      dep_tristate '  Thermal Zone' 	CONFIG_ACPI_THERMAL $CONFIG_ACPI_PROCESSOR
-      if [ "$CONFIG_NUMA" = "y" -a "$CONFIG_X86_64" != "y" ]; then
-        dep_bool       '  NUMA support'     CONFIG_ACPI_NUMA $CONFIG_NUMA
-      fi
-      tristate     '  ASUS Laptop Extras'  CONFIG_ACPI_ASUS
-      tristate     '  Toshiba Laptop Extras'	CONFIG_ACPI_TOSHIBA
-      bool         '  Debug Statements'	CONFIG_ACPI_DEBUG
-      bool         '  Relaxed AML Checking'	CONFIG_ACPI_RELAXED_AML
     fi
   fi
 
diff -Nru a/drivers/acpi/asus_acpi.c b/drivers/acpi/asus_acpi.c
--- a/drivers/acpi/asus_acpi.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/asus_acpi.c	Wed Oct  1 01:10:29 2003
@@ -26,13 +26,17 @@
  *  Johann Wiesner - Small compile fixes
  *  John Belmonte  - ACPI code for Toshiba laptop was a good starting point.
  *
- *  TODO
+ *  TODO:
  *  add Fn key status
- *  Add mode selection on module loading (parameter) -> still necessary ?
+ *  Add mode selection on module loading (parameter) -> still necessary?
  *  Complete display switching -- may require dirty hacks?
- *
  */
 
+#include <linux/config.h>
+#if defined (CONFIG_MODVERSIONS) && !defined (MODVERSIONS) && defined (MODULE)
+#include <linux/modversions.h>
+#endif
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -41,7 +45,7 @@
 #include <acpi/acpi_drivers.h>
 #include <acpi/acpi_bus.h>
 
-#define ASUS_ACPI_VERSION "0.24a"
+#define ASUS_ACPI_VERSION "0.26"
 
 #define PROC_ASUS       "asus"	//the directory
 #define PROC_MLED       "mled"
@@ -73,7 +77,6 @@
 MODULE_LICENSE("GPL");
 EXPORT_NO_SYMBOLS;
 
-
 static uid_t asus_uid = 0;
 static gid_t asus_gid = 0;
 MODULE_PARM(asus_uid, "i");
@@ -111,20 +114,24 @@
 	struct model_data *methods;	//methods available on the laptop
 	u8 brightness;			//brighness level
 	enum {
-		L2X = 0,	//L200D -> TODO check Q11 (Fn+F8)
-				//	   Calling this method simply hang the
+		A1X=0,  	//A1340D, A1300F
+		A2X,		//A2500H
+		D1X,		//D1
+		L1X,		//L1400B
+		L2X,		//L2000D -> TODO check Q11 (Fn+F8)
+				//	   Calling this method simply hangs the
 				//	   computer, ISMI method hangs the laptop.
-		L3X,		//L3C
 		L3D,		//L3400D
+		L3X,		//L3C
+		L5X,		//L5C TODO this model seems to have one more
+		                //         LED, add support
 		M2X,		//M2400E
+		M3N,		//M3700N, but also S1300N -> TODO WLED
 		S1X,		//S1300A -> TODO special keys do not work ?
-		D1X,		//D1
-		L1X,		//L1400B
-		A1X, 		//A1340D, A1300F
-		J1X,		//S200 (J1)
-				//TODO  A1370D does not seems to have a ATK device 
+		S2X,		//S200 (J1 reported), Victor MP-XP7210
+				//TODO  A1370D does not seem to have an ATK device 
 				//	L8400 model doesn't have ATK
-		END_MODEL,
+		END_MODEL
 	} model;		//Models currently supported
 	u16 event_count[128];	//count for each event TODO make this better
 };
@@ -134,7 +141,8 @@
 #define S1X_PREFIX "\\_SB.PCI0.PX40."
 #define L1X_PREFIX S1X_PREFIX
 #define A1X_PREFIX "\\_SB.PCI0.ISA.EC0."
-#define J1X_PREFIX A1X_PREFIX
+#define S2X_PREFIX A1X_PREFIX
+#define M3N_PREFIX "\\_SB.PCI0.SBRG.EC0."
 
 static struct model_data model_conf[END_MODEL] = {
         /*
@@ -148,33 +156,43 @@
 	 * it seems to be a kind of switch, but what for ?
 	 *
 	 */
+	{"A1X", "MLED", "\\MAIL", NULL, NULL, A1X_PREFIX "_Q10", "\\BKLI",
+	 A1X_PREFIX "_Q0E", A1X_PREFIX "_Q0F", NULL, NULL, NULL, NULL, NULL},
+
+	{"A2X", "MLED", NULL, "WLED", "\\SG66", "\\Q10", "\\BAOF",
+	 "\\Q0E", "\\Q0F", "SPLV", "GPLV", "\\CMOD", "SDSP", "\\INFB"},
+
+	{"D1X", "MLED", NULL, NULL, NULL, "\\Q0D", "\\GP11", 
+	 "\\Q0C", "\\Q0B", NULL, NULL, "\\BLVL", "SDSP","\\INFB"},
+
+	{"L1X", "MLED", NULL, "WLED", NULL, L1X_PREFIX "Q10", "\\PNOF", 
+	 L1X_PREFIX "Q0F", L1X_PREFIX "Q0E", "SPLV", "GPLV", "\\BRIT", NULL, NULL},
+	 
 	{"L2X", "MLED", "\\SGP6", "WLED", "\\RCP3", "\\Q10", "\\SGP0", 
 	 "\\Q0E", "\\Q0F", NULL, NULL, NULL, "SDSP", "\\INFB"},
 
+	{"L3D", "MLED", "\\MALD", "WLED", NULL, "\\Q10", "\\BKLG",
+	 "\\Q0E", "\\Q0F", "SPLV", "GPLV", "\\BLVL", "SDSP", "\\INFB"},
+
 	{"L3X", "MLED", NULL, "WLED", NULL, L3X_PREFIX "_Q10", "\\GL32", 
 	 L3X_PREFIX "_Q0F", L3X_PREFIX "_Q0E", "SPLV", "GPLV", "\\BLVL", "SDSP", 
 	 "\\_SB.PCI0.PCI1.VGAC.NMAP"},
 
-	{"L3D", "MLED", "\\MALD", "WLED", NULL, "\\Q10", "\\BKLG",
-	 "\\Q0E", "\\Q0F", "SPLV", "GPLV", "\\BLVL", "SDSP", "\\INFB"},
-
+	{"L5X", "MLED", NULL, "WLED", "WRED", "\\Q0D", "\\BAOF", 
+	 "\\Q0C","\\Q0B", "SPLV", "GPLV", NULL, "SDSP", "\\INFB"},
+	 
 	{"M2X", "MLED", NULL, "WLED", NULL, "\\Q10", "\\GP06", 
 	 "\\Q0E","\\Q0F", "SPLV", "GPLV", NULL, "SDSP", "\\INFB"},
+
+	{"M3N", "MLED", NULL, "WLED", "\\PO33", M3N_PREFIX "_Q10", "\\BKLT", 
+	 M3N_PREFIX "_Q0F", M3N_PREFIX "_Q0E", "SPLV", "GPLV", "\\LBTN", "SDSP", 
+	 "\\ADVG"},
 	
 	{"S1X", "MLED", "\\EMLE", "WLED", NULL, S1X_PREFIX "Q10", "\\PNOF", 
 	 S1X_PREFIX "Q0F", S1X_PREFIX "Q0E", "SPLV", "GPLV", "\\BRIT", NULL, NULL},
 	
-	{"D1X", "MLED", NULL, NULL, NULL, "\\Q0D", "\\GP11", 
-	 "\\Q0C", "\\Q0B", NULL, NULL, "\\BLVL", "SDSP","\\INFB"},
-
-	{"L1X", "MLED", NULL, "WLED", NULL, L1X_PREFIX "Q10", "\\PNOF", 
-	 L1X_PREFIX "Q0F", L1X_PREFIX "Q0E", "SPLV", "GPLV", "\\BRIT", NULL, NULL},
-
-	{"A1X", "MLED", "\\MAIL", NULL, NULL, A1X_PREFIX "_Q10", "\\BKLI",
-	 A1X_PREFIX "_Q0E", A1X_PREFIX "_Q0F", NULL, NULL, NULL, NULL, NULL},
-
-	{"J1X", "MLED", "\\MAIL", NULL, NULL, J1X_PREFIX "_Q10", "\\BKLI",
-	 J1X_PREFIX "_Q0B", J1X_PREFIX "_Q0A", NULL, NULL, NULL, NULL, NULL}
+	{"S2X", "MLED", "\\MAIL", NULL, NULL, S2X_PREFIX "_Q10", "\\BKLI",
+	 S2X_PREFIX "_Q0B", S2X_PREFIX "_Q0A", NULL, NULL, NULL, NULL, NULL}
 };
 
 /* procdir we use */
@@ -235,7 +253,7 @@
 	output.length = sizeof(out_obj);
 	output.pointer = &out_obj;
 
-	status = acpi_evaluate_object(handle, (char*) method, NULL, &output);
+	status = acpi_evaluate_object(handle, (char *) method, NULL, &output);
 	*val = out_obj.integer.value;
 	return (status == AE_OK) && (out_obj.type == ACPI_TYPE_INTEGER);
 }
@@ -250,6 +268,7 @@
 		void *data)
 {
 	int len = 0;
+	int sfun;
 	struct asus_hotk *hotk = (struct asus_hotk *) data;
 	char buf[16];		//enough for all info
 	/*
@@ -258,28 +277,27 @@
 	 */
 
 	len += sprintf(page, ACPI_HOTK_NAME " " ASUS_ACPI_VERSION "\n");
-	len +=
-	    sprintf(page + len, "Model reference    : %s\n",
-		    hotk->methods->name);
+	len += sprintf(page + len, "Model reference    : %s\n", 
+		       hotk->methods->name);
+	if(read_acpi_int(hotk->handle, "SFUN", &sfun))
+		len += sprintf(page + len, "SFUN value         : 0x%04x\n", sfun);
 	if (asus_info) {
-		snprintf(buf, 5, "%s", asus_info->signature);
-		len += sprintf(page + len, "ACPI signature     : %s\n", buf);
 		snprintf(buf, 16, "%d", asus_info->length);
-		len += sprintf(page + len, "Table length       : %s\n", buf);
-		snprintf(buf, 16, "%d", asus_info->revision);
-		len += sprintf(page + len, "ACPI minor version : %s\n", buf);
+		len += sprintf(page + len, "DSDT length        : %s\n", buf);
 		snprintf(buf, 16, "%d", asus_info->checksum);
-		len += sprintf(page + len, "Checksum           : %s\n", buf);
+		len += sprintf(page + len, "DSDT checksum      : %s\n", buf);
+		snprintf(buf, 16, "%d", asus_info->revision);
+		len += sprintf(page + len, "DSDT revision      : %s\n", buf);
 		snprintf(buf, 7, "%s", asus_info->oem_id);
-		len += sprintf(page + len, "OEM identification : %s\n", buf);
+		len += sprintf(page + len, "OEM id             : %s\n", buf);
 		snprintf(buf, 9, "%s", asus_info->oem_table_id);
 		len += sprintf(page + len, "OEM table id       : %s\n", buf);
 		snprintf(buf, 16, "%x", asus_info->oem_revision);
-		len += sprintf(page + len, "OEM rev number     : 0x%s\n", buf);
+		len += sprintf(page + len, "OEM revision       : 0x%s\n", buf);
 		snprintf(buf, 5, "%s", asus_info->asl_compiler_id);
-		len += sprintf(page + len, "ASL comp vendor ID : %s\n", buf);
+		len += sprintf(page + len, "ASL comp vendor id : %s\n", buf);
 		snprintf(buf, 16, "%x", asus_info->asl_compiler_revision);
-		len += sprintf(page + len, "ASL comp rev number: 0x%s\n", buf);
+		len += sprintf(page + len, "ASL comp revision  : 0x%s\n", buf);
 	}
 
 	return len;
@@ -305,7 +323,7 @@
 				  &led_status))
 			len =  sprintf(page, "%d\n", led_status);
 		else
-			printk(KERN_NOTICE "Asus ACPI: Error reading MLED "
+			printk(KERN_WARNING "Asus ACPI: Error reading MLED "
 			       "status\n");
 	} else {
 		len = sprintf(page, "%d\n", (hotk->status & MLED_ON) ? 1 : 0);
@@ -335,7 +353,7 @@
 	/* We don't have to check mt_mled exists if we are here :) */
 	if (!write_acpi_int(hotk->handle, hotk->methods->mt_mled, led_out,
 			    NULL))
-		printk(KERN_NOTICE "Asus ACPI: MLED write failed\n");
+		printk(KERN_WARNING "Asus ACPI: MLED write failed\n");
 
 
 
@@ -356,11 +374,11 @@
 	int led_status;
 
 	if (hotk->methods->wled_status) {
-		if (read_acpi_int(NULL, hotk->methods->mled_status, 
+		if (read_acpi_int(NULL, hotk->methods->wled_status, 
 				  &led_status))
 			len = sprintf(page, "%d\n", led_status);
 		else
-			printk(KERN_NOTICE "Asus ACPI: Error reading WLED "
+			printk(KERN_WARNING "Asus ACPI: Error reading WLED "
 			       "status\n");
 	} else {
 		len = sprintf(page, "%d\n", (hotk->status & WLED_ON) ? 1 : 0);
@@ -387,7 +405,7 @@
 	/* We don't have to check if mt_wled exists if we are here :) */
 	if (!write_acpi_int(hotk->handle, hotk->methods->mt_wled, led_out,
 			    NULL))
-		printk(KERN_NOTICE "Asus ACPI: WLED write failed\n");
+		printk(KERN_WARNING "Asus ACPI: WLED write failed\n");
 
 
 	return count;
@@ -400,7 +418,7 @@
 
 	/* We don't have to check anything, if we are here */
 	if (!read_acpi_int(NULL, hotk->methods->lcd_status, &lcd))
-		printk(KERN_NOTICE "Asus ACPI: Error reading LCD status\n");
+		printk(KERN_WARNING "Asus ACPI: Error reading LCD status\n");
 	
 	if (hotk->model == L2X)
 		lcd = ~lcd;
@@ -439,7 +457,7 @@
 		    acpi_evaluate_object(NULL, hotk->methods->mt_lcd_switch,
 					 NULL, NULL);
 		if (ACPI_FAILURE(status))
-			printk(KERN_NOTICE "Asus ACPI: Error switching LCD\n");
+			printk(KERN_WARNING "Asus ACPI: Error switching LCD\n");
 	}
 
 	return count;
@@ -453,15 +471,15 @@
 {
 	acpi_status status = 0;
 
-	/* ATKD laptop */
+	/* SPLV laptop */
 	if(hotk->methods->brightness_set) {
 		if (!write_acpi_int(hotk->handle, hotk->methods->brightness_set, 
 				    value, NULL))
-			printk(KERN_NOTICE "Asus ACPI: Error changing brightness\n");
+			printk(KERN_WARNING "Asus ACPI: Error changing brightness\n");
 		return;
 	}
 
-	/* HOTK laptop if we are here, act as appropriate */
+	/* No SPLV method if we are here, act as appropriate */
 	value -= hotk->brightness;
 	while (value != 0) {
 		status = acpi_evaluate_object(NULL, (value > 0) ? 
@@ -470,7 +488,7 @@
 					      NULL, NULL);
 		(value > 0) ? value-- : value++;
 		if (ACPI_FAILURE(status))
-			printk(KERN_NOTICE "Asus ACPI: Error changing brightness\n");
+			printk(KERN_WARNING "Asus ACPI: Error changing brightness\n");
 	}
 	return;
 }
@@ -479,15 +497,15 @@
 {
 	int value;
 	
-	if(hotk->methods->brightness_get) { /* ATKD laptop */
+	if(hotk->methods->brightness_get) { /* SPLV/GPLV laptop */
 		if (!read_acpi_int(hotk->handle, hotk->methods->brightness_get, 
 				   &value))
-			printk(KERN_NOTICE "Asus ACPI: Error reading brightness\n");
+			printk(KERN_WARNING "Asus ACPI: Error reading brightness\n");
 	} else if (hotk->methods->brightness_status) { /* For D1 for example */
 		if (!read_acpi_int(NULL, hotk->methods->brightness_status, 
 				   &value))
-			printk(KERN_NOTICE "Asus ACPI: Error reading brightness\n");
-	} else /* HOTK laptop */
+			printk(KERN_WARNING "Asus ACPI: Error reading brightness\n");
+	} else /* No GPLV method */
 		value = hotk->brightness;
 	return value;
 }
@@ -513,7 +531,7 @@
 			/* 0 <= value <= 15 */
 		set_brightness(value, hotk);
 	} else {
-		printk(KERN_NOTICE "Asus ACPI: Error reading user input\n");
+		printk(KERN_WARNING "Asus ACPI: Error reading user input\n");
 	}
 
 	return count;
@@ -524,7 +542,7 @@
 	/* no sanity check needed for now */
 	if (!write_acpi_int(hotk->handle, hotk->methods->display_set, 
 			    value, NULL))
-		printk(KERN_NOTICE "Asus ACPI: Error setting display\n");
+		printk(KERN_WARNING "Asus ACPI: Error setting display\n");
 	return;
 }
 
@@ -541,12 +559,12 @@
 	struct asus_hotk *hotk = (struct asus_hotk *) data;
 	
 	if (!read_acpi_int(hotk->handle, hotk->methods->display_get, &value))
-		printk(KERN_NOTICE "Asus ACPI: Error reading display status\n");
+		printk(KERN_WARNING "Asus ACPI: Error reading display status\n");
 	return sprintf(page, "%d\n", value);
 }
 
 /*
- * Preliminary support for display switching. As of now: 0x01 should activate 
+ * Experimental support for display switching. As of now: 0x01 should activate 
  * the LCD output, 0x02 should do for CRT, and 0x04 for TV-Out. Any combination 
  * (bitwise) of these will suffice. I never actually tested 3 displays hooked up 
  * simultaneously, so be warned.
@@ -563,13 +581,13 @@
 	if (sscanf(buffer, "%d", &value) == 1)
 		set_display(value, hotk);
 	else {
-		printk(KERN_NOTICE "Asus ACPI: Error reading user input\n");
+		printk(KERN_WARNING "Asus ACPI: Error reading user input\n");
 	}
 
 	return count;
 }
 
-static int asus_hotk_add_fs(struct acpi_device *device)
+static int __init asus_hotk_add_fs(struct acpi_device *device)
 {
 	struct proc_dir_entry *proc;
 	struct asus_hotk *hotk = acpi_driver_data(device);
@@ -583,7 +601,7 @@
 
 	if ((asus_uid == 0) && (asus_gid == 0)){
 		mode = S_IFREG | S_IRUGO | S_IWUGO;
-	}else{
+	} else {
 		mode = S_IFREG | S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP;
 	}
 
@@ -599,7 +617,7 @@
 		proc->uid = asus_uid;
 		proc->gid = asus_gid;;
 	} else {
-		printk(KERN_NOTICE "  Unable to create " PROC_INFOS
+		printk(KERN_WARNING "  Unable to create " PROC_INFOS
 		       " fs entry\n");
 	}
 
@@ -613,7 +631,7 @@
 			proc->uid = asus_uid;
 			proc->gid = asus_gid;;
 		} else {
-			printk(KERN_NOTICE "  Unable to create " PROC_WLED
+			printk(KERN_WARNING "  Unable to create " PROC_WLED
 			       " fs entry\n");
 		}
 	}
@@ -628,7 +646,7 @@
 			proc->uid = asus_uid;
 			proc->gid = asus_gid;;
 		} else {
-			printk(KERN_NOTICE "  Unable to create " PROC_MLED
+			printk(KERN_WARNING "  Unable to create " PROC_MLED
 			       " fs entry\n");
 		}
 	}
@@ -647,7 +665,7 @@
 			proc->uid = asus_uid;
 			proc->gid = asus_gid;;
 		} else {
-			printk(KERN_NOTICE "  Unable to create " PROC_LCD
+			printk(KERN_WARNING "  Unable to create " PROC_LCD
 			       " fs entry\n");
 		}
 	}
@@ -663,7 +681,7 @@
 			proc->uid = asus_uid;
 			proc->gid = asus_gid;;
 		} else {
-			printk(KERN_NOTICE "  Unable to create " PROC_BRN
+			printk(KERN_WARNING "  Unable to create " PROC_BRN
 			       " fs entry\n");
 		}
 	}
@@ -678,19 +696,19 @@
 			proc->uid = asus_uid;
 			proc->gid = asus_gid;;
 		} else {
-			printk(KERN_NOTICE "  Unable to create " PROC_DISP
+			printk(KERN_WARNING "  Unable to create " PROC_DISP
 			       " fs entry\n");
 		}
 	}
 
-	return (AE_OK);
+	return 0;
 }
 
 
 static void asus_hotk_notify(acpi_handle handle, u32 event, void *data)
 {
 	/* TODO Find a better way to handle events count. Here, in data, we receive
-	 * the hotk, so we can make anything !!
+	 * the hotk, so we can do anything!
 	 */
 	struct asus_hotk *hotk = (struct asus_hotk *) data;
 
@@ -713,19 +731,40 @@
  * This function is used to initialize the hotk with right values. In this
  * method, we can make all the detection we want, and modify the hotk struct
  */
-static int asus_hotk_get_info(struct asus_hotk *hotk)
+static int __init asus_hotk_get_info(struct asus_hotk *hotk)
 {
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_buffer dsdt = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *model = NULL;
+	int bsts_result;
+	acpi_status status;
 
-	/* 
-	 * We have to write 0 on init this far for all ASUS models
+	/*
+	 * Get DSDT headers early enough to allow for differentiating between 
+	 * models, but late enough to allow acpi_bus_register_driver() to fail 
+	 * before doing anything ACPI-specific. Should we encounter a machine,
+	 * which needs special handling (i.e. its hotkey device has a different
+	 * HID), this bit will be moved. A global variable asus_info contains
+	 * the DSDT header.
 	 */
+	status = acpi_get_table(ACPI_TABLE_DSDT, 1, &dsdt);
+	if (ACPI_FAILURE(status))
+		printk(KERN_WARNING "  Couldn't get the DSDT table header\n");
+	else
+		asus_info = (struct acpi_table_header *) dsdt.pointer;
+
+	/* We have to write 0 on init this far for all ASUS models */
 	if (!write_acpi_int(hotk->handle, "INIT", 0, &buffer)) {
-		printk(KERN_NOTICE "  Hotkey initialization failed\n");
+		printk(KERN_ERR "  Hotkey initialization failed\n");
 		return -ENODEV;
 	}
 
+	/* For testing purposes */
+	if (!read_acpi_int(hotk->handle, "BSTS", &bsts_result))
+		printk(KERN_WARNING "  Error calling BSTS\n");
+	else if (bsts_result)
+		printk(KERN_NOTICE "  BSTS called, 0x%02x returned\n", bsts_result);
+
 	/*
 	 * Here, we also use asus_info to make decision. For example, on INIT
 	 * method, S1X and L1X models both reports to be L84F, but they don't
@@ -750,26 +789,34 @@
 		hotk->model = L3X;
 	else if (strncmp(model->string.pointer, "M2", 2) == 0)
 		hotk->model = M2X;
+	else if (strncmp(model->string.pointer, "M3N", 3) == 0 ||
+		 strncmp(model->string.pointer, "S1N", 3) == 0)
+		hotk->model = M3N; /* S1300N is similar enough */
 	else if (strncmp(model->string.pointer, "L2", 2) == 0)
 		hotk->model = L2X;
-	else if (strncmp(model->string.pointer, "L8", 2) == 0)
+	else if (strncmp(model->string.pointer, "L8", 2) == 0) {
 		/* S1300A reports L84F, but L1400B too */
-		if (strncmp(asus_info->oem_table_id, "L1", 2) == 0)
-			hotk->model = L1X;
-		else
+		if (asus_info) {
+			if (strncmp(asus_info->oem_table_id, "L1", 2) == 0)
+				hotk->model = L1X;
+		} else
 			hotk->model = S1X;
+	}
 	else if (strncmp(model->string.pointer, "D1", 2) == 0)
 		hotk->model = D1X;
 	else if (strncmp(model->string.pointer, "A1", 2) == 0)
 		hotk->model = A1X;
+	else if (strncmp(model->string.pointer, "A2", 2) == 0)
+		hotk->model = A2X;
 	else if (strncmp(model->string.pointer, "J1", 2) == 0)
-		hotk->model = J1X;
-
+		hotk->model = S2X;
+	else if (strncmp(model->string.pointer, "L5", 2) == 0)
+		hotk->model = L5X;
 
 	if (hotk->model == END_MODEL) {
 		/* By default use the same values, as I don't know others */
-		printk("unsupported, trying default values, contact the "
-		       "developers\n");
+		printk("unsupported, trying default values, supply the "
+		       "developers with your DSDT\n");
 		hotk->model = L2X;
 	} else {
 		printk("supported\n");
@@ -784,7 +831,7 @@
 
 
 
-static int asus_hotk_check(struct asus_hotk *hotk)
+static int __init asus_hotk_check(struct asus_hotk *hotk)
 {
 	int result = 0;
 
@@ -798,7 +845,7 @@
 	if (hotk->device->status.present) {
 		result = asus_hotk_get_info(hotk);
 	} else {
-		printk(KERN_NOTICE "  Hotkey device not present, aborting\n");
+		printk(KERN_ERR "  Hotkey device not present, aborting\n");
 		return(-EINVAL);
 	}
 
@@ -807,7 +854,7 @@
 
 
 
-static int asus_hotk_add(struct acpi_device *device)
+static int __init asus_hotk_add(struct acpi_device *device)
 {
 	struct asus_hotk *hotk = NULL;
 	acpi_status status = AE_OK;
@@ -816,6 +863,9 @@
 	if (!device)
 		return(-EINVAL);
 
+	printk(KERN_NOTICE "Asus Laptop ACPI Extras version %s\n",
+	       ASUS_ACPI_VERSION);
+
 	hotk =
 	    (struct asus_hotk *) kmalloc(sizeof(struct asus_hotk), GFP_KERNEL);
 	if (!hotk)
@@ -843,25 +893,23 @@
 	 */
 	status = acpi_install_notify_handler(hotk->handle, ACPI_SYSTEM_NOTIFY,
 					     asus_hotk_notify, hotk);
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_NOTICE
-		       "  Error installing notify handler\n");
-	} else {
-		printk(KERN_DEBUG
-		       "  Notify Handler installed successfully\n");
-	}
+	if (ACPI_FAILURE(status))
+		printk(KERN_ERR "  Error installing notify handler\n");
 
-	/* For HOTK laptops: init the hotk->brightness value */
+	/* For laptops without GPLV: init the hotk->brightness value */
 	if ((!hotk->methods->brightness_get) && (!hotk->methods->brightness_status) &&
 	    (hotk->methods->brightness_up && hotk->methods->brightness_down)) {
 		status = acpi_evaluate_object(NULL, hotk->methods->brightness_down,
 					      NULL, NULL);
 		if (ACPI_FAILURE(status))
-			printk(KERN_NOTICE "  Error changing brightness\n");
-		status = acpi_evaluate_object(NULL, hotk->methods->brightness_up,
-					      NULL, NULL);
-		if (ACPI_FAILURE(status))
-			printk(KERN_NOTICE "  Error changing brightness\n");
+			printk(KERN_WARNING "  Error changing brightness\n");
+		else {
+			status = acpi_evaluate_object(NULL, hotk->methods->brightness_up,
+						      NULL, NULL);
+			if (ACPI_FAILURE(status))
+				printk(KERN_WARNING "  Strange, error changing" 
+				       " brightness\n");
+		}
 	}
 
       end:
@@ -888,7 +936,7 @@
 	status = acpi_remove_notify_handler(hotk->handle, ACPI_SYSTEM_NOTIFY,
 					    asus_hotk_notify);
 	if (ACPI_FAILURE(status))
-		printk(KERN_NOTICE "Error removing notify handler\n");
+		printk(KERN_ERR "Asus ACPI: Error removing notify handler\n");
 
 	kfree(hotk);
 
@@ -900,35 +948,17 @@
 
 static int __init asus_acpi_init(void)
 {
-	int result = 0;
-	acpi_status status = 0;
-	struct acpi_buffer dsdt = { ACPI_ALLOCATE_BUFFER, NULL };
-
-	printk(KERN_NOTICE "Asus Laptop ACPI Extras version %s\n",
-	       ASUS_ACPI_VERSION);
-	/*
-	 * Here is the code to know the model we are running on. We need to
-	 * know this before calling the acpi_bus_register_driver function, in
-	 * case the HID for the laptop we are running on is different from
-	 * ACPI_HOTK_HID, which I have never seen yet :)
-	 * 
-	 * This information is then available in the global var asus_info
-	 */
-	status = acpi_get_table(ACPI_TABLE_DSDT, 1, &dsdt);
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_NOTICE "  Couldn't get the DSDT table header\n");
-	} else {
-		asus_info = (struct acpi_table_header *) dsdt.pointer;
-	}
+	int result;
 
 	asus_proc_dir = proc_mkdir(PROC_ASUS, acpi_root_dir);
-	if (!asus_proc_dir)
+	if (!asus_proc_dir) {
+		printk(KERN_ERR "Asus ACPI: Unable to create /proc entry");
 		return(-ENODEV);
+	}
 	asus_proc_dir->owner = THIS_MODULE;
 
 	result = acpi_bus_register_driver(&asus_hotk_driver);
 	if (result < 0) {
-		printk(KERN_NOTICE "  Error registering " ACPI_HOTK_NAME " \n");
 		remove_proc_entry(PROC_ASUS, acpi_root_dir);
 		return(-ENODEV);
 	}
diff -Nru a/drivers/acpi/bus.c b/drivers/acpi/bus.c
--- a/drivers/acpi/bus.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/bus.c	Wed Oct  1 01:10:29 2003
@@ -1898,9 +1898,7 @@
 	 * of that.
 	 */
 	result = acpi_ec_ecdt_probe();
-	if (result) {
-		goto error1;
-	}
+	/* Ignore result. Not having an ECDT is not fatal. */
 #endif
 
 	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
diff -Nru a/drivers/acpi/dispatcher/dsfield.c b/drivers/acpi/dispatcher/dsfield.c
--- a/drivers/acpi/dispatcher/dsfield.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/dispatcher/dsfield.c	Wed Oct  1 01:10:29 2003
@@ -105,27 +105,33 @@
 		return_ACPI_STATUS (AE_AML_NO_OPERAND);
 	}
 
-	/*
-	 * During the load phase, we want to enter the name of the field into
-	 * the namespace.  During the execute phase (when we evaluate the size
-	 * operand), we want to lookup the name
-	 */
-	if (walk_state->parse_flags & ACPI_PARSE_EXECUTE) {
-		flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE;
+	if (walk_state->deferred_node) {
+		node = walk_state->deferred_node;
+		status = AE_OK;
 	}
 	else {
-		flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND;
-	}
+		/*
+		 * During the load phase, we want to enter the name of the field into
+		 * the namespace.  During the execute phase (when we evaluate the size
+		 * operand), we want to lookup the name
+		 */
+		if (walk_state->parse_flags & ACPI_PARSE_EXECUTE) {
+			flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE;
+		}
+		else {
+			flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND;
+		}
 
-	/*
-	 * Enter the name_string into the namespace
-	 */
-	status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
-			 ACPI_TYPE_ANY, ACPI_IMODE_LOAD_PASS1,
-			 flags, walk_state, &(node));
-	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_NSERROR (arg->common.value.string, status);
-		return_ACPI_STATUS (status);
+		/*
+		 * Enter the name_string into the namespace
+		 */
+		status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
+				 ACPI_TYPE_ANY, ACPI_IMODE_LOAD_PASS1,
+				 flags, walk_state, &(node));
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_NSERROR (arg->common.value.string, status);
+			return_ACPI_STATUS (status);
+		}
 	}
 
 	/* We could put the returned object (Node) on the object stack for later, but
diff -Nru a/drivers/acpi/dispatcher/dsinit.c b/drivers/acpi/dispatcher/dsinit.c
--- a/drivers/acpi/dispatcher/dsinit.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/dispatcher/dsinit.c	Wed Oct  1 01:10:29 2003
@@ -135,7 +135,7 @@
 		}
 
 		/*
-		 * Always parse methods to detect errors, we may delete
+		 * Always parse methods to detect errors, we will delete
 		 * the parse tree below
 		 */
 		status = acpi_ds_parse_method (obj_handle);
@@ -150,7 +150,7 @@
 		}
 
 		/*
-		 * Delete the parse tree.  We simple re-parse the method
+		 * Delete the parse tree.  We simply re-parse the method
 		 * for every execution since there isn't much overhead
 		 */
 		acpi_ns_delete_namespace_subtree (obj_handle);
diff -Nru a/drivers/acpi/dispatcher/dsopcode.c b/drivers/acpi/dispatcher/dsopcode.c
--- a/drivers/acpi/dispatcher/dsopcode.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/dispatcher/dsopcode.c	Wed Oct  1 01:10:29 2003
@@ -65,7 +65,7 @@
  *
  * RETURN:      Status.
  *
- * DESCRIPTION: Late execution of region or field arguments
+ * DESCRIPTION: Late (deferred) execution of region or field arguments
  *
  ****************************************************************************/
 
@@ -111,7 +111,10 @@
 		return_ACPI_STATUS (status);
 	}
 
+	/* Mark this parse as a deferred opcode */
+
 	walk_state->parse_flags = ACPI_PARSE_DEFERRED_OP;
+	walk_state->deferred_node = node;
 
 	/* Pass1: Parse the entire declaration */
 
@@ -128,7 +131,7 @@
 	arg->common.node = node;
 	acpi_ps_delete_parse_tree (op);
 
-	/* Evaluate the address and length arguments for the Buffer Field */
+	/* Evaluate the deferred arguments */
 
 	op = acpi_ps_alloc_op (AML_INT_EVAL_SUBTREE_OP);
 	if (!op) {
@@ -144,6 +147,8 @@
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
+	/* Execute the opcode and arguments */
+
 	status = acpi_ds_init_aml_walk (walk_state, op, NULL, aml_start,
 			  aml_length, NULL, NULL, 3);
 	if (ACPI_FAILURE (status)) {
@@ -151,6 +156,9 @@
 		return_ACPI_STATUS (status);
 	}
 
+	/* Mark this execution as a deferred opcode */
+
+	walk_state->deferred_node = node;
 	status = acpi_ps_parse_aml (walk_state);
 	acpi_ps_delete_parse_tree (op);
 	return_ACPI_STATUS (status);
@@ -192,7 +200,7 @@
 	node = obj_desc->buffer_field.node;
 
 	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname (ACPI_TYPE_BUFFER_FIELD, node, NULL));
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] buffer_field JIT Init\n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] buffer_field Arg Init\n",
 		node->name.ascii));
 
 	/* Execute the AML code for the term_arg arguments */
@@ -207,7 +215,7 @@
  *
  * FUNCTION:    acpi_ds_get_buffer_arguments
  *
- * PARAMETERS:  obj_desc        - A valid Bufferobject
+ * PARAMETERS:  obj_desc        - A valid Buffer object
  *
  * RETURN:      Status.
  *
@@ -240,7 +248,7 @@
 		return_ACPI_STATUS (AE_AML_INTERNAL);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Buffer JIT Init\n"));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Buffer Arg Init\n"));
 
 	/* Execute the AML code for the term_arg arguments */
 
@@ -254,7 +262,7 @@
  *
  * FUNCTION:    acpi_ds_get_package_arguments
  *
- * PARAMETERS:  obj_desc        - A valid Packageobject
+ * PARAMETERS:  obj_desc        - A valid Package object
  *
  * RETURN:      Status.
  *
@@ -287,7 +295,7 @@
 		return_ACPI_STATUS (AE_AML_INTERNAL);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Package JIT Init\n"));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Package Arg Init\n"));
 
 	/* Execute the AML code for the term_arg arguments */
 
@@ -335,11 +343,12 @@
 
 	node = obj_desc->region.node;
 
-	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname (ACPI_TYPE_REGION, node, NULL));
+	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (ACPI_TYPE_REGION, node, NULL));
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] op_region Init at AML %p\n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] op_region Arg Init at AML %p\n",
 		node->name.ascii, extra_desc->extra.aml_start));
 
+	/* Execute the argument AML */
 
 	status = acpi_ds_execute_arguments (node, acpi_ns_get_parent_node (node),
 			 extra_desc->extra.aml_length, extra_desc->extra.aml_start);
@@ -505,14 +514,16 @@
 		goto cleanup;
 	}
 
-
 	/* Entire field must fit within the current length of the buffer */
 
 	if ((bit_offset + bit_count) >
 		(8 * (u32) buffer_desc->buffer.length)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Field size %d exceeds Buffer size %d (bits)\n",
-			 bit_offset + bit_count, 8 * (u32) buffer_desc->buffer.length));
+			"Field [%4.4s] size %d exceeds Buffer [%4.4s] size %d (bits)\n",
+			((struct acpi_namespace_node *) result_desc)->name.ascii,
+			 bit_offset + bit_count,
+			 buffer_desc->buffer.node->name.ascii,
+			 8 * (u32) buffer_desc->buffer.length));
 		status = AE_AML_BUFFER_LIMIT;
 		goto cleanup;
 	}
diff -Nru a/drivers/acpi/dispatcher/dsutils.c b/drivers/acpi/dispatcher/dsutils.c
--- a/drivers/acpi/dispatcher/dsutils.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/dispatcher/dsutils.c	Wed Oct  1 01:10:29 2003
@@ -53,6 +53,7 @@
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsutils")
 
+
 #ifndef ACPI_NO_METHOD_EXECUTION
 
 /*******************************************************************************
@@ -196,7 +197,6 @@
 			acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
 
 	return_VALUE (FALSE);
-
 }
 
 
@@ -239,7 +239,6 @@
 		return_VOID;
 	}
 
-
 	if (!acpi_ds_is_result_used (op, walk_state)) {
 		/*
 		 * Must pop the result stack (obj_desc should be equal to result_obj)
@@ -389,61 +388,77 @@
 		 * in name_string
 		 */
 
+
 		/*
-		 * Differentiate between a namespace "create" operation
-		 * versus a "lookup" operation (IMODE_LOAD_PASS2 vs.
-		 * IMODE_EXECUTE) in order to support the creation of
-		 * namespace objects during the execution of control methods.
+		 * Special handling for buffer_field declarations. This is a deferred
+		 * opcode that unfortunately defines the field name as the last
+		 * parameter instead of the first.  We get here when we are performing
+		 * the deferred execution, so the actual name of the field is already
+		 * in the namespace.  We don't want to attempt to look it up again
+		 * because we may be executing in a different scope than where the
+		 * actual opcode exists.
 		 */
-		parent_op = arg->common.parent;
-		op_info = acpi_ps_get_opcode_info (parent_op->common.aml_opcode);
-		if ((op_info->flags & AML_NSNODE) &&
-			(parent_op->common.aml_opcode != AML_INT_METHODCALL_OP) &&
-			(parent_op->common.aml_opcode != AML_REGION_OP) &&
-			(parent_op->common.aml_opcode != AML_INT_NAMEPATH_OP)) {
-			/* Enter name into namespace if not found */
-
-			interpreter_mode = ACPI_IMODE_LOAD_PASS2;
+		if ((walk_state->deferred_node) &&
+			(walk_state->deferred_node->type == ACPI_TYPE_BUFFER_FIELD) &&
+			(arg_index != 0)) {
+			obj_desc = ACPI_CAST_PTR (union acpi_operand_object, walk_state->deferred_node);
+			status = AE_OK;
 		}
+		else    /* All other opcodes */ {
+			/*
+			 * Differentiate between a namespace "create" operation
+			 * versus a "lookup" operation (IMODE_LOAD_PASS2 vs.
+			 * IMODE_EXECUTE) in order to support the creation of
+			 * namespace objects during the execution of control methods.
+			 */
+			parent_op = arg->common.parent;
+			op_info = acpi_ps_get_opcode_info (parent_op->common.aml_opcode);
+			if ((op_info->flags & AML_NSNODE) &&
+				(parent_op->common.aml_opcode != AML_INT_METHODCALL_OP) &&
+				(parent_op->common.aml_opcode != AML_REGION_OP) &&
+				(parent_op->common.aml_opcode != AML_INT_NAMEPATH_OP)) {
+				/* Enter name into namespace if not found */
 
-		else {
-			/* Return a failure if name not found */
-
-			interpreter_mode = ACPI_IMODE_EXECUTE;
-		}
+				interpreter_mode = ACPI_IMODE_LOAD_PASS2;
+			}
+			else {
+				/* Return a failure if name not found */
 
-		status = acpi_ns_lookup (walk_state->scope_info, name_string,
-				 ACPI_TYPE_ANY, interpreter_mode,
-				 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
-				 walk_state,
-				 ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, &obj_desc));
-		/*
-		 * The only case where we pass through (ignore) a NOT_FOUND
-		 * error is for the cond_ref_of opcode.
-		 */
-		if (status == AE_NOT_FOUND) {
-			if (parent_op->common.aml_opcode == AML_COND_REF_OF_OP) {
-				/*
-				 * For the Conditional Reference op, it's OK if
-				 * the name is not found;  We just need a way to
-				 * indicate this to the interpreter, set the
-				 * object to the root
-				 */
-				obj_desc = ACPI_CAST_PTR (union acpi_operand_object, acpi_gbl_root_node);
-				status = AE_OK;
+				interpreter_mode = ACPI_IMODE_EXECUTE;
 			}
 
-			else {
-				/*
-				 * We just plain didn't find it -- which is a
-				 * very serious error at this point
-				 */
-				status = AE_AML_NAME_NOT_FOUND;
+			status = acpi_ns_lookup (walk_state->scope_info, name_string,
+					 ACPI_TYPE_ANY, interpreter_mode,
+					 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+					 walk_state,
+					 ACPI_CAST_INDIRECT_PTR (struct acpi_namespace_node, &obj_desc));
+			/*
+			 * The only case where we pass through (ignore) a NOT_FOUND
+			 * error is for the cond_ref_of opcode.
+			 */
+			if (status == AE_NOT_FOUND) {
+				if (parent_op->common.aml_opcode == AML_COND_REF_OF_OP) {
+					/*
+					 * For the Conditional Reference op, it's OK if
+					 * the name is not found;  We just need a way to
+					 * indicate this to the interpreter, set the
+					 * object to the root
+					 */
+					obj_desc = ACPI_CAST_PTR (union acpi_operand_object, acpi_gbl_root_node);
+					status = AE_OK;
+				}
+				else {
+					/*
+					 * We just plain didn't find it -- which is a
+					 * very serious error at this point
+					 */
+					status = AE_AML_NAME_NOT_FOUND;
+				}
 			}
-		}
 
-		if (ACPI_FAILURE (status)) {
-			ACPI_REPORT_NSERROR (name_string, status);
+			if (ACPI_FAILURE (status)) {
+				ACPI_REPORT_NSERROR (name_string, status);
+			}
 		}
 
 		/* Free the namestring created above */
@@ -464,8 +479,6 @@
 		}
 		ACPI_DEBUGGER_EXEC (acpi_db_display_argument_object (obj_desc, walk_state));
 	}
-
-
 	else {
 		/* Check for null name case */
 
@@ -480,7 +493,6 @@
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Null namepath: Arg=%p\n", arg));
 		}
-
 		else {
 			opcode = arg->common.aml_opcode;
 		}
diff -Nru a/drivers/acpi/dispatcher/dswload.c b/drivers/acpi/dispatcher/dswload.c
--- a/drivers/acpi/dispatcher/dswload.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/dispatcher/dswload.c	Wed Oct  1 01:10:29 2003
@@ -248,6 +248,14 @@
 		 *       buffer_field, or Package), the name of the object is already
 		 *       in the namespace.
 		 */
+		if (walk_state->deferred_node) {
+			/* This name is already in the namespace, get the node */
+
+			node = walk_state->deferred_node;
+			status = AE_OK;
+			break;
+		}
+
 		flags = ACPI_NS_NO_UPSEARCH;
 		if ((walk_state->opcode != AML_SCOPE_OP) &&
 			(!(walk_state->parse_flags & ACPI_PARSE_DEFERRED_OP))) {
@@ -589,7 +597,17 @@
 		 * Enter the named type into the internal namespace.  We enter the name
 		 * as we go downward in the parse tree.  Any necessary subobjects that involve
 		 * arguments to the opcode must be created as we go back up the parse tree later.
+		 *
+		 * Note: Name may already exist if we are executing a deferred opcode.
 		 */
+		if (walk_state->deferred_node) {
+			/* This name is already in the namespace, get the node */
+
+			node = walk_state->deferred_node;
+			status = AE_OK;
+			break;
+		}
+
 		status = acpi_ns_lookup (walk_state->scope_info, buffer_ptr, object_type,
 				  ACPI_IMODE_EXECUTE, ACPI_NS_NO_UPSEARCH, walk_state, &(node));
 		break;
diff -Nru a/drivers/acpi/dispatcher/dswscope.c b/drivers/acpi/dispatcher/dswscope.c
--- a/drivers/acpi/dispatcher/dswscope.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/dispatcher/dswscope.c	Wed Oct  1 01:10:29 2003
@@ -121,10 +121,9 @@
 	/* Make sure object type is valid */
 
 	if (!acpi_ut_valid_object_type (type)) {
-		ACPI_REPORT_WARNING (("ds_scope_stack_push: type code out of range\n"));
+		ACPI_REPORT_WARNING (("ds_scope_stack_push: Invalid object type: 0x%X\n", type));
 	}
 
-
 	/* Allocate a new scope object */
 
 	scope_info = acpi_ut_create_generic_state ();
@@ -146,13 +145,13 @@
 	old_scope_info = walk_state->scope_info;
 	if (old_scope_info) {
 		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC,
-			"[%4.4s] (%10s)",
+			"[%4.4s] (%s)",
 			old_scope_info->scope.node->name.ascii,
 			acpi_ut_get_type_name (old_scope_info->common.value)));
 	}
 	else {
 		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC,
-			"[\\___] (%10s)", "ROOT"));
+			"[\\___] (%s)", "ROOT"));
 	}
 
 	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_EXEC,
@@ -163,7 +162,6 @@
 	/* Push new scope object onto stack */
 
 	acpi_ut_push_generic_state (&walk_state->scope_info, scope_info);
-
 	return_ACPI_STATUS (AE_OK);
 }
 
@@ -207,7 +205,7 @@
 	walk_state->scope_depth--;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-		"[%.2d] Popped scope [%4.4s] (%10s), New scope -> ",
+		"[%.2d] Popped scope [%4.4s] (%s), New scope -> ",
 		(u32) walk_state->scope_depth,
 		scope_info->scope.node->name.ascii,
 		acpi_ut_get_type_name (scope_info->common.value)));
@@ -225,7 +223,6 @@
 	}
 
 	acpi_ut_delete_generic_state (scope_info);
-
 	return_ACPI_STATUS (AE_OK);
 }
 
diff -Nru a/drivers/acpi/dispatcher/dswstate.c b/drivers/acpi/dispatcher/dswstate.c
--- a/drivers/acpi/dispatcher/dswstate.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/dispatcher/dswstate.c	Wed Oct  1 01:10:29 2003
@@ -56,11 +56,12 @@
  * FUNCTION:    acpi_ds_result_insert
  *
  * PARAMETERS:  Object              - Object to push
+ *              Index               - Where to insert the object
  *              walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Push an object onto this walk's result stack
+ * DESCRIPTION: Insert an object onto this walk's result stack
  *
  ******************************************************************************/
 
@@ -114,6 +115,7 @@
  * FUNCTION:    acpi_ds_result_remove
  *
  * PARAMETERS:  Object              - Where to return the popped object
+ *              Index               - Where to extract the object
  *              walk_state          - Current Walk state
  *
  * RETURN:      Status
@@ -233,6 +235,7 @@
 	return (AE_AML_NO_RETURN_VALUE);
 }
 
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_result_pop_from_bottom
@@ -295,7 +298,6 @@
 		*object, (*object) ? acpi_ut_get_object_type_name (*object) : "NULL",
 		state, walk_state));
 
-
 	return (AE_OK);
 }
 
@@ -358,8 +360,7 @@
  *
  * FUNCTION:    acpi_ds_result_stack_push
  *
- * PARAMETERS:  Object              - Object to push
- *              walk_state          - Current Walk state
+ * PARAMETERS:  walk_state          - Current Walk state
  *
  * RETURN:      Status
  *
@@ -420,7 +421,6 @@
 		return (AE_AML_NO_OPERAND);
 	}
 
-
 	state = acpi_ut_pop_generic_state (&walk_state->results);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
@@ -572,6 +572,7 @@
 }
 #endif
 
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ds_obj_stack_pop
@@ -641,6 +642,7 @@
 	u32                             i;
 	union acpi_operand_object       *obj_desc;
 
+
 	ACPI_FUNCTION_NAME ("ds_obj_stack_pop_and_delete");
 
 
@@ -883,8 +885,15 @@
  * FUNCTION:    acpi_ds_init_aml_walk
  *
  * PARAMETERS:  walk_state      - New state to be initialized
+ *              Op              - Current parse op
+ *              method_node     - Control method NS node, if any
+ *              aml_start       - Start of AML
+ *              aml_length      - Length of AML
+ *              Params          - Method args, if any
+ *              return_obj_desc - Where to store a return object, if any
+ *              pass_number     - 1, 2, or 3
  *
- * RETURN:      None
+ * RETURN:      Status
  *
  * DESCRIPTION: Initialize a walk state for a pass 1 or 2 parse tree walk
  *
@@ -927,9 +936,9 @@
 
 	if (method_node) {
 		walk_state->parser_state.start_node = method_node;
-		walk_state->walk_type               = ACPI_WALK_METHOD;
-		walk_state->method_node             = method_node;
-		walk_state->method_desc             = acpi_ns_get_attached_object (method_node);
+		walk_state->walk_type            = ACPI_WALK_METHOD;
+		walk_state->method_node          = method_node;
+		walk_state->method_desc          = acpi_ns_get_attached_object (method_node);
 
 		/* Push start scope on scope stack and make it current  */
 
@@ -956,6 +965,7 @@
 		while (extra_op && !extra_op->common.node) {
 			extra_op = extra_op->common.parent;
 		}
+
 		if (!extra_op) {
 			parser_state->start_node = NULL;
 		}
@@ -1014,7 +1024,7 @@
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p walk still has a scope list\n", walk_state));
 	}
 
-   /* Always must free any linked control states */
+	/* Always must free any linked control states */
 
 	while (walk_state->control_state) {
 		state = walk_state->control_state;
diff -Nru a/drivers/acpi/ec.c b/drivers/acpi/ec.c
--- a/drivers/acpi/ec.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/ec.c	Wed Oct  1 01:10:29 2003
@@ -33,7 +33,7 @@
 #include <asm/io.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
-
+#include <acpi/actypes.h>
 
 #define _COMPONENT		ACPI_EC_COMPONENT
 ACPI_MODULE_NAME		("acpi_ec")
@@ -408,7 +408,10 @@
 	 * The EC object is in the handler context and is needed
 	 * when calling the acpi_ec_space_handler.
 	 */
-	*return_context = handler_context;
+	if(function == ACPI_REGION_DEACTIVATE) 
+		*return_context = NULL;
+	else 
+		*return_context = handler_context;
 
 	return AE_OK;
 }
diff -Nru a/drivers/acpi/events/evregion.c b/drivers/acpi/events/evregion.c
--- a/drivers/acpi/events/evregion.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/events/evregion.c	Wed Oct  1 01:10:29 2003
@@ -382,7 +382,7 @@
 	union acpi_operand_object       *obj_desc;
 	union acpi_operand_object       **last_obj_ptr;
 	acpi_adr_space_setup            region_setup;
-	void                            *region_context;
+	void                            **region_context;
 	union acpi_operand_object       *region_obj2;
 	acpi_status                     status;
 
@@ -394,7 +394,7 @@
 	if (!region_obj2) {
 		return_VOID;
 	}
-	region_context = region_obj2->extra.region_context;
+	region_context = &region_obj2->extra.region_context;
 
 	/* Get the address handler from the region object */
 
@@ -450,7 +450,7 @@
 
 			region_setup = handler_obj->address_space.setup;
 			status = region_setup (region_obj, ACPI_REGION_DEACTIVATE,
-					  handler_obj->address_space.context, &region_context);
+					  handler_obj->address_space.context, region_context);
 
 			/* Init routine may fail, Just ignore errors */
 
diff -Nru a/drivers/acpi/executer/excreate.c b/drivers/acpi/executer/excreate.c
--- a/drivers/acpi/executer/excreate.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/executer/excreate.c	Wed Oct  1 01:10:29 2003
@@ -286,7 +286,7 @@
 	ACPI_FUNCTION_TRACE ("ex_create_region");
 
 
-	/* Get the Node from the object stack  */
+	/* Get the Namespace Node */
 
 	node = walk_state->op->common.node;
 
@@ -311,7 +311,6 @@
 	ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Region Type - %s (%X)\n",
 			  acpi_ut_get_region_name (region_space), region_space));
 
-
 	/* Create the region descriptor */
 
 	obj_desc = acpi_ut_create_internal_object (ACPI_TYPE_REGION);
@@ -375,6 +374,7 @@
 
 	ACPI_FUNCTION_TRACE ("ex_create_table_region");
 
+
 	/* Get the Node from the object stack  */
 
 	node = walk_state->op->common.node;
@@ -392,7 +392,6 @@
 	status = acpi_tb_find_table (operand[1]->string.pointer,
 			   operand[2]->string.pointer,
 			   operand[3]->string.pointer, &table);
-
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -489,7 +488,6 @@
 	status = acpi_ns_attach_object ((struct acpi_namespace_node *) operand[0],
 			  obj_desc, ACPI_TYPE_PROCESSOR);
 
-
 	/* Remove local reference to the object */
 
 	acpi_ut_remove_reference (obj_desc);
@@ -540,7 +538,6 @@
 	status = acpi_ns_attach_object ((struct acpi_namespace_node *) operand[0],
 			  obj_desc, ACPI_TYPE_POWER);
 
-
 	/* Remove local reference to the object */
 
 	acpi_ut_remove_reference (obj_desc);
@@ -609,7 +606,6 @@
 		obj_desc->method.concurrency = (u8)
 				  (((method_flags & METHOD_FLAGS_SYNCH_LEVEL) >> 4) + 1);
 	}
-
 	else {
 		obj_desc->method.concurrency = INFINITE_CONCURRENCY;
 	}
diff -Nru a/drivers/acpi/namespace/nsdump.c b/drivers/acpi/namespace/nsdump.c
--- a/drivers/acpi/namespace/nsdump.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/namespace/nsdump.c	Wed Oct  1 01:10:29 2003
@@ -234,7 +234,7 @@
 
 		case ACPI_TYPE_DEVICE:
 
-			acpi_os_printf ("Notify object: %p", obj_desc);
+			acpi_os_printf ("Notify Object: %p\n", obj_desc);
 			break;
 
 
@@ -371,7 +371,7 @@
 		case ACPI_TYPE_LOCAL_BANK_FIELD:
 		case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-			acpi_os_printf (" Off %.2X Len %.2X Acc %.2hd\n",
+			acpi_os_printf ("Off %.2X Len %.2X Acc %.2hd\n",
 					(obj_desc->common_field.base_byte_offset * 8)
 						+ obj_desc->common_field.start_field_bit_offset,
 					obj_desc->common_field.bit_length,
diff -Nru a/drivers/acpi/namespace/nssearch.c b/drivers/acpi/namespace/nssearch.c
--- a/drivers/acpi/namespace/nssearch.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/namespace/nssearch.c	Wed Oct  1 01:10:29 2003
@@ -96,7 +96,7 @@
 
 		scope_name = acpi_ns_get_external_pathname (node);
 		if (scope_name) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Searching %s [%p] For %4.4s (%s)\n",
+			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Searching %s (%p) For [%4.4s] (%s)\n",
 				scope_name, node, (char *) &target_name, acpi_ut_get_type_name (type)));
 
 			ACPI_MEM_FREE (scope_name);
@@ -117,9 +117,9 @@
 			 * Found matching entry.
 			 */
 			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-				"Name %4.4s Type [%s] found in scope [%4.4s] %p\n",
+				"Name [%4.4s] (%s) %p found in scope [%4.4s] %p\n",
 				(char *) &target_name, acpi_ut_get_type_name (next_node->type),
-				next_node->name.ascii, next_node));
+				next_node, node->name.ascii, node));
 
 			*return_node = next_node;
 			return_ACPI_STATUS (AE_OK);
@@ -143,7 +143,7 @@
 	/* Searched entire namespace level, not found */
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-		"Name %4.4s Type [%s] not found in search in scope [%4.4s] %p first child %p\n",
+		"Name [%4.4s] (%s) not found in search in scope [%4.4s] %p first child %p\n",
 		(char *) &target_name, acpi_ut_get_type_name (type),
 		node->name.ascii, node, node->child));
 
diff -Nru a/drivers/acpi/namespace/nsutils.c b/drivers/acpi/namespace/nsutils.c
--- a/drivers/acpi/namespace/nsutils.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/namespace/nsutils.c	Wed Oct  1 01:10:29 2003
@@ -175,6 +175,11 @@
 	acpi_status                     status;
 
 
+	if (!node) {
+		acpi_os_printf ("[NULL NAME]");
+		return;
+	}
+
 	/* Convert handle to a full pathname and print it (with supplied message) */
 
 	buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
@@ -470,11 +475,11 @@
 	*result = 0;
 
 	if (info->fully_qualified) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "returning [%p] (abs) \"\\%s\"\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Returning [%p] (abs) \"\\%s\"\n",
 			internal_name, internal_name));
 	}
 	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "returning [%p] (rel) \"%s\"\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Returning [%p] (rel) \"%s\"\n",
 			internal_name, internal_name));
 	}
 
diff -Nru a/drivers/acpi/parser/psparse.c b/drivers/acpi/parser/psparse.c
--- a/drivers/acpi/parser/psparse.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/parser/psparse.c	Wed Oct  1 01:10:29 2003
@@ -437,7 +437,6 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-
 	parser_state = &walk_state->parser_state;
 	walk_state->arg_types = 0;
 
@@ -705,10 +704,9 @@
 				walk_state->arg_types = 0;
 				break;
 
-
 			default:
 
-				/* Op is not a constant or string, append each argument */
+				/* Op is not a constant or string, append each argument to the Op */
 
 				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) &&
 						!walk_state->arg_count) {
@@ -727,23 +725,23 @@
 					INCREMENT_ARG_LIST (walk_state->arg_types);
 				}
 
+				/* Special processing for certain opcodes */
+
 				switch (op->common.aml_opcode) {
 				case AML_METHOD_OP:
 
-					/* For a method, save the length and address of the body */
-
 					/*
-					 * Skip parsing of control method or opregion body,
+					 * Skip parsing of control method
 					 * because we don't have enough info in the first pass
-					 * to parse them correctly.
+					 * to parse it correctly.
+					 *
+					 * Save the length and address of the body
 					 */
 					op->named.data   = parser_state->aml;
 					op->named.length = (u32) (parser_state->pkg_end - parser_state->aml);
-					/*
-					 * Skip body of method.  For op_regions, we must continue
-					 * parsing because the opregion is not a standalone
-					 * package (We don't know where the end is).
-					 */
+
+					/* Skip body of method */
+
 					parser_state->aml   = parser_state->pkg_end;
 					walk_state->arg_count = 0;
 					break;
@@ -756,15 +754,15 @@
 						(op->common.parent->common.aml_opcode == AML_NAME_OP) &&
 						(walk_state->descending_callback != acpi_ds_exec_begin_op)) {
 						/*
-						 * Skip parsing of
+						 * Skip parsing of Buffers and Packages
 						 * because we don't have enough info in the first pass
 						 * to parse them correctly.
 						 */
 						op->named.data   = aml_op_start;
 						op->named.length = (u32) (parser_state->pkg_end - aml_op_start);
-						/*
-						 * Skip body
-						 */
+
+						/* Skip body */
+
 						parser_state->aml   = parser_state->pkg_end;
 						walk_state->arg_count = 0;
 					}
@@ -778,6 +776,7 @@
 					break;
 
 				default:
+
 					/* No action for all other opcodes */
 					break;
 				}
diff -Nru a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
--- a/drivers/acpi/pci_irq.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/pci_irq.c	Wed Oct  1 01:10:29 2003
@@ -73,6 +73,9 @@
 
 	ACPI_FUNCTION_TRACE("acpi_pci_irq_find_prt_entry");
 
+	if (!acpi_prt.count)
+		return_PTR(NULL);
+
 	/*
 	 * Parse through all PRT entries looking for a match on the specified
 	 * PCI device's segment, bus, device, and pin (don't care about func).
diff -Nru a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
--- a/drivers/acpi/pci_link.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/pci_link.c	Wed Oct  1 01:10:29 2003
@@ -216,7 +216,6 @@
 	return AE_CTRL_TERMINATE;
 }
 
-
 static int
 acpi_pci_link_get_current (
 	struct acpi_pci_link	*link)
@@ -275,6 +274,28 @@
 	return_VALUE(result);
 }
 
+static int
+acpi_pci_link_try_get_current (
+	struct acpi_pci_link *link,
+	int irq)
+{
+	int result;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_try_get_current");
+
+	result = acpi_pci_link_get_current(link);
+	if (result && link->irq.active) {
+ 		return_VALUE(result);
+ 	}
+
+	if (!link->irq.active) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "No active IRQ resource found\n"));
+		printk(KERN_WARNING "_CRS returns NULL! Using IRQ %d for device (%s [%s]).\n", irq, acpi_device_name(link->device), acpi_device_bid(link->device));
+		link->irq.active = irq;
+	}
+	
+	return 0;
+}
 
 static int
 acpi_pci_link_set (
@@ -290,7 +311,8 @@
 	struct acpi_buffer	buffer = {sizeof(resource)+1, &resource};
 	int			i = 0;
 	int			valid = 0;
-
+	int			resource_type = 0;
+   
 	ACPI_FUNCTION_TRACE("acpi_pci_link_set");
 
 	if (!link || !irq)
@@ -313,12 +335,23 @@
 		}
 	}
 
+	/* If IRQ<=15, first try with a "normal" IRQ descriptor. If that fails, try with
+	 * an extended one */
+	if (irq <= 15) {
+		resource_type = ACPI_RSTYPE_IRQ;
+	} else {
+		resource_type = ACPI_RSTYPE_EXT_IRQ;
+	}
+
+retry_programming:
+   
 	memset(&resource, 0, sizeof(resource));
 
 	/* NOTE: PCI interrupts are always level / active_low / shared. But not all
 	   interrupts > 15 are PCI interrupts. Rely on the ACPI IRQ definition for 
 	   parameters */
-	if (irq <= 15) {
+	switch(resource_type) {
+	case ACPI_RSTYPE_IRQ:
 		resource.res.id = ACPI_RSTYPE_IRQ;
 		resource.res.length = sizeof(struct acpi_resource);
 		resource.res.data.irq.edge_level = link->irq.edge_level;
@@ -326,8 +359,9 @@
 		resource.res.data.irq.shared_exclusive = ACPI_SHARED;
 		resource.res.data.irq.number_of_interrupts = 1;
 		resource.res.data.irq.interrupts[0] = irq;
-	}
-	else {
+		break;
+	   
+	case ACPI_RSTYPE_EXT_IRQ:
 		resource.res.id = ACPI_RSTYPE_EXT_IRQ;
 		resource.res.length = sizeof(struct acpi_resource);
 		resource.res.data.extended_irq.producer_consumer = ACPI_CONSUMER;
@@ -337,11 +371,22 @@
 		resource.res.data.extended_irq.number_of_interrupts = 1;
 		resource.res.data.extended_irq.interrupts[0] = irq;
 		/* ignore resource_source, it's optional */
+		break;
 	}
 	resource.end.id = ACPI_RSTYPE_END_TAG;
 
 	/* Attempt to set the resource */
 	status = acpi_set_current_resources(link->handle, &buffer);
+   
+
+	/* if we failed and IRQ <= 15, try again with an extended descriptor */
+	if (ACPI_FAILURE(status) && (resource_type == ACPI_RSTYPE_IRQ)) {
+                resource_type = ACPI_RSTYPE_EXT_IRQ;
+                printk(PREFIX "Retrying with extended IRQ descriptor\n");
+                goto retry_programming;
+	}
+  
+	/* check for total failure */
 	if (ACPI_FAILURE(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SRS\n"));
 		return_VALUE(-ENODEV);
@@ -359,7 +404,7 @@
 	}
 
 	/* Make sure the active IRQ is the one we requested. */
-	result = acpi_pci_link_get_current(link);
+	result = acpi_pci_link_try_get_current(link, irq);
 	if (result) {
 		return_VALUE(result);
 	}
@@ -454,16 +499,16 @@
 		irq = link->irq.active;
 	} else {
 		irq = link->irq.possible[0];
-	}
 
-		/* 
-		 * Select the best IRQ.  This is done in reverse to promote 
+		/*
+		 * Select the best IRQ.  This is done in reverse to promote
 		 * the use of IRQs 9, 10, 11, and >15.
 		 */
 		for (i=(link->irq.possible_count-1); i>0; i--) {
 			if (acpi_irq_penalty[irq] > acpi_irq_penalty[link->irq.possible[i]])
 				irq = link->irq.possible[i];
 		}
+	}
 
 	/* Attempt to enable the link device at this IRQ. */
 	if (acpi_pci_link_set(link, irq)) {
@@ -514,10 +559,9 @@
 		return_VALUE(0);
 	}
 
-	if (acpi_pci_link_allocate(link)) {
-		return -ENODEV;
-	}
-	   
+	if (acpi_pci_link_allocate(link))
+		return_VALUE(0);
+
 	if (!link->irq.active) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link disabled\n"));
 		return_VALUE(0);
@@ -573,10 +617,6 @@
 		else
 			printk(" %d", link->irq.possible[i]);
 	}
-	if (!link->irq.active)
-		printk(", disabled");
-	else if (!found)
-		printk(", enabled at IRQ %d", link->irq.active);
 	printk(")\n");
 
 	/* TBD: Acquire/release lock */
diff -Nru a/drivers/acpi/tables.c b/drivers/acpi/tables.c
--- a/drivers/acpi/tables.c	Wed Oct  1 01:10:29 2003
+++ b/drivers/acpi/tables.c	Wed Oct  1 01:10:29 2003
@@ -69,7 +69,8 @@
 
 static unsigned long		sdt_pa;		/* Physical Address */
 static unsigned long		sdt_count;	/* Table count */
-static struct acpi_table_sdt	*sdt_entry;
+
+static struct acpi_table_sdt	sdt_entry[ACPI_MAX_TABLES];
 
 void
 acpi_table_print (
@@ -418,12 +419,6 @@
 			sdt_count = ACPI_MAX_TABLES;
 		}
 
-		sdt_entry = alloc_bootmem(sdt_count * sizeof(struct acpi_table_sdt));
-		if (!sdt_entry) {
-			printk(KERN_ERR "ACPI: Could not allocate mem for SDT entries!\n");
-			return -ENOMEM;
-		}
-
 		for (i = 0; i < sdt_count; i++)
 			sdt_entry[i].pa = (unsigned long) mapped_xsdt->entry[i];
 	}
@@ -468,12 +463,6 @@
 			printk(KERN_WARNING PREFIX "Truncated %lu RSDT entries\n",
 				(sdt_count - ACPI_MAX_TABLES));
 			sdt_count = ACPI_MAX_TABLES;
-		}
-
-		sdt_entry = alloc_bootmem(sdt_count * sizeof(struct acpi_table_sdt));
-		if (!sdt_entry) {
-			printk(KERN_ERR "ACPI: Could not allocate mem for SDT entries!\n");
-			return -ENOMEM;
 		}
 
 		for (i = 0; i < sdt_count; i++)
diff -Nru a/include/acpi/acconfig.h b/include/acpi/acconfig.h
--- a/include/acpi/acconfig.h	Wed Oct  1 01:10:29 2003
+++ b/include/acpi/acconfig.h	Wed Oct  1 01:10:29 2003
@@ -64,7 +64,7 @@
 
 /* Version string */
 
-#define ACPI_CA_VERSION                 0x20030813
+#define ACPI_CA_VERSION                 0x20030918
 
 /* Maximum objects in the various object caches */
 
diff -Nru a/include/acpi/acdisasm.h b/include/acpi/acdisasm.h
--- a/include/acpi/acdisasm.h	Wed Oct  1 01:10:29 2003
+++ b/include/acpi/acdisasm.h	Wed Oct  1 01:10:29 2003
@@ -152,10 +152,6 @@
 acpi_dm_decode_internal_object (
 	union acpi_operand_object       *obj_desc);
 
-void
-acpi_dm_decode_node (
-	struct acpi_namespace_node      *node);
-
 u32
 acpi_dm_block_type (
 	union acpi_parse_object         *op);
diff -Nru a/include/acpi/acstruct.h b/include/acpi/acstruct.h
--- a/include/acpi/acstruct.h	Wed Oct  1 01:10:29 2003
+++ b/include/acpi/acstruct.h	Wed Oct  1 01:10:29 2003
@@ -91,11 +91,12 @@
 	struct acpi_namespace_node          arguments[ACPI_METHOD_NUM_ARGS];    /* Control method arguments */
 	union acpi_operand_object           **caller_return_desc;
 	union acpi_generic_state            *control_state;                     /* List of control states (nested IFs) */
+	struct acpi_namespace_node          *deferred_node;                      /* Used when executing deferred opcodes */
 	struct acpi_namespace_node          local_variables[ACPI_METHOD_NUM_LOCALS];    /* Control method locals */
 	struct acpi_namespace_node          *method_call_node;                  /* Called method Node*/
 	union acpi_parse_object             *method_call_op;                    /* method_call Op if running a method */
 	union acpi_operand_object           *method_desc;                       /* Method descriptor if running a method */
-	struct acpi_namespace_node          *method_node;                       /* Method Node if running a method */
+	struct acpi_namespace_node          *method_node;                       /* Method node if running a method. */
 	union acpi_parse_object             *op;                                /* Current parser op */
 	union acpi_operand_object           *operands[ACPI_OBJ_NUM_OPERANDS+1]; /* Operands passed to the interpreter (+1 for NULL terminator) */
 	const struct acpi_opcode_info       *op_info;                           /* Info on current opcode */
diff -Nru a/include/asm-i386/acpi.h b/include/asm-i386/acpi.h
--- a/include/asm-i386/acpi.h	Wed Oct  1 01:10:29 2003
+++ b/include/asm-i386/acpi.h	Wed Oct  1 01:10:29 2003
@@ -106,12 +106,6 @@
         :"0"(n_hi), "1"(n_lo))
 
 
-#ifdef CONFIG_ACPI_HT_ONLY
-extern int acpi_lapic;
-#define acpi_ioapic 0
-
-#else /* CONFIG_ACPI_HT_ONLY */
-
 #ifdef CONFIG_ACPI_BOOT 
 extern int acpi_lapic;
 extern int acpi_ioapic;
@@ -144,7 +138,6 @@
 #  define acpi_ioapic 0
 
 #endif
-#endif /* !CONFIG_ACPI_HT_ONLY */
 
 #ifdef CONFIG_ACPI_SLEEP
 
diff -Nru a/include/linux/acpi.h b/include/linux/acpi.h
--- a/include/linux/acpi.h	Wed Oct  1 01:10:29 2003
+++ b/include/linux/acpi.h	Wed Oct  1 01:10:29 2003
@@ -369,16 +369,10 @@
 
 #else /*!CONFIG_ACPI_BOOT*/
 
-#ifdef	CONFIG_ACPI_HT_ONLY
-int acpi_boot_init (void);
-
-#else /* !CONFIG_ACPI_HT_ONLY */
-
 static inline int acpi_boot_init(void)
 {
 	return 0;
 }
-#endif	/* !CONFIG_ACPI_HT_ONLY */
 
 #endif /*!CONFIG_ACPI_BOOT*/
 
