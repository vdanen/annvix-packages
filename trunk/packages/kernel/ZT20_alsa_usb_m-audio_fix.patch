diff -Nurp -X /Data/dontdiff 7mdk/sound/usb/usbaudio.c 7mdk.alsa/sound/usb/usbaudio.c
--- 7mdk/sound/usb/usbaudio.c	2003-09-13 17:20:14.000000000 +0300
+++ 7mdk.alsa/sound/usb/usbaudio.c	2003-09-15 21:47:50.000000000 +0300
@@ -48,6 +48,7 @@ static void __old_snd_complete_sync_urb(
 static void * usb_audio_probe(struct usb_device *dev, unsigned int ifnum,
                               const struct usb_device_id *id);
 static void usb_audio_disconnect(struct usb_device *dev, void *ptr);
+static int usb_reset_configuration(struct usb_device *dev);
 #endif
 
 #include "usbaudio.h"
@@ -224,10 +225,6 @@ struct snd_usb_stream {
 static DECLARE_MUTEX(register_mutex);
 static snd_usb_audio_t *usb_chip[SNDRV_CARDS];
 
-inline int snd_hack_usb_set_interface(struct usb_device *dev, int interface, int alternate) {
-        return usb_set_interface(dev,interface,alternate);
-}
-
 /*
  * convert a sampling rate into USB format (fs/1000 in Q10.14)
  * this will overflow at approx 2MSPS
@@ -2888,24 +2885,32 @@ module_exit(snd_usb_audio_cleanup);
  * 2.4 USB kernel API
  */
 static void *usb_audio_probe(struct usb_device *dev, unsigned int ifnum,
-			     const struct usb_device_id *id)
+                            const struct usb_device_id *id)
 {
-	return snd_usb_audio_probe(dev, usb_ifnum_to_if(dev, ifnum), id);
+       return snd_usb_audio_probe(dev, usb_ifnum_to_if(dev, ifnum), id);
 }
-                                       
+
 static void usb_audio_disconnect(struct usb_device *dev, void *ptr)
 {
-	snd_usb_audio_disconnect(dev, ptr);
+       snd_usb_audio_disconnect(dev, ptr);
 }
 
 static void __old_snd_complete_urb(struct urb *urb)
 {
-	snd_complete_urb(urb, NULL);
+       snd_complete_urb(urb, NULL);
 }
 
 static void __old_snd_complete_sync_urb(struct urb *urb)
 {
-	snd_complete_sync_urb(urb, NULL);
+       snd_complete_sync_urb(urb, NULL);
+}
+
+static int usb_reset_configuration(struct usb_device *dev)
+{
+       struct usb_host_config *config = dev->actconfig;
+
+       /* FIXME: replace with something more useful like in 2.6 code? */
+       return usb_set_configuration(dev, get_cfg_desc(config)->bConfigurationValue);
 }
 #endif
 
@@ -2913,6 +2918,74 @@ static void __old_snd_complete_sync_urb(
  * workarounds / hacks for the older kernels follow below
  */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 24)
+/* M-Audio Quattro has weird alternate settings.  the altsetting jumps
+ * from 0 to 4 or 3 insuccessively, and this screws up
+ * usb_set_interface() (at least on 2.4.18/19 and 2.4.21).
+ */
+
+/*
+ * the following is a stripped version of usb_set_interface() with the fix
+ * for insuccessive altsetting numbers.
+ */
+
+/* stripped version for isochronos only */
+static void hack_usb_set_maxpacket(struct usb_device *dev)
+{
+       int i, b;
+
+       for (i=0; i<dev->actconfig->bNumInterfaces; i++) {
+               struct usb_interface *ifp = dev->actconfig->interface + i;
+               struct usb_interface_descriptor *as = ifp->altsetting + ifp->act_altsetting;
+               struct usb_endpoint_descriptor *ep = as->endpoint;
+               int e;
+
+               for (e=0; e<as->bNumEndpoints; e++) {
+                       b = ep[e].bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+                       if (usb_endpoint_out(ep[e].bEndpointAddress)) {
+                               if (ep[e].wMaxPacketSize > dev->epmaxpacketout[b])
+                                       dev->epmaxpacketout[b] = ep[e].wMaxPacketSize;
+                       }
+                       else {
+                               if (ep[e].wMaxPacketSize > dev->epmaxpacketin [b])
+                                       dev->epmaxpacketin [b] = ep[e].wMaxPacketSize;
+                       }
+               }
+       }
+}
+
+/* stripped version */
+int snd_hack_usb_set_interface(struct usb_device *dev, int interface, int alternate)
+{
+       struct usb_interface *iface;
+       struct usb_interface_descriptor *iface_as;
+       int i, ret;
+
+       iface = usb_ifnum_to_if(dev, interface);
+       if (!iface)
+               return -EINVAL;
+       if (iface->num_altsetting == 1)
+               return 0;
+       if (alternate < 0 || alternate >= iface->num_altsetting)
+               return -EINVAL;
+
+       if ((ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+                                  USB_REQ_SET_INTERFACE, USB_RECIP_INTERFACE,
+                                  iface->altsetting[alternate].bAlternateSetting,
+                                  interface, NULL, 0, HZ * 5)) < 0)
+               return ret;
+
+       iface->act_altsetting = alternate;
+       iface_as = &iface->altsetting[alternate];
+       for (i = 0; i < iface_as->bNumEndpoints; i++) {
+               u8 ep = iface_as->endpoint[i].bEndpointAddress;
+               usb_settoggle(dev, ep&USB_ENDPOINT_NUMBER_MASK, usb_endpoint_out(ep), 0);
+       }
+       hack_usb_set_maxpacket(dev);
+       return 0;
+}
+
+#endif /* LINUX_VERSION < 2.5.24 */
 
 #ifndef MODULE
 /*
diff -Nurp -X /Data/dontdiff 7mdk/sound/usb/usbquirks.h 7mdk.alsa/sound/usb/usbquirks.h
--- 7mdk/sound/usb/usbquirks.h	2003-06-18 15:55:34.000000000 +0300
+++ 7mdk.alsa/sound/usb/usbquirks.h	2003-09-15 20:29:38.000000000 +0300
@@ -755,6 +755,19 @@
 		}
 	}
 },
+{
+	USB_DEVICE_VENDOR_SPEC(0x0763, 0x2008),
+	.driver_info = (unsigned long) & (const snd_usb_audio_quirk_t) {
+		.vendor_name = "M-Audio",
+		.product_name = "Ozone",
+		.ifnum = 3,
+		.type = QUIRK_MIDI_MIDIMAN,
+		.data = & (const snd_usb_midi_endpoint_info_t) {
+			.out_cables = 0x0001,
+			.in_cables  = 0x0001
+		}
+	}
+},
 
 /* Mark of the Unicorn devices */
 {
