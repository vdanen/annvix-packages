--- ./src/utils.h.lfs	2003-10-11 15:57:11.000000000 +0200
+++ ./src/utils.h	2004-12-15 17:31:53.284577004 +0100
@@ -45,7 +45,7 @@
 
 struct file_memory {
   char *content;
-  long length;
+  off_t length;
   int mmap_p;
 };
 
@@ -71,7 +71,7 @@
 int remove_link PARAMS ((const char *));
 int file_exists_p PARAMS ((const char *));
 int file_non_directory_p PARAMS ((const char *));
-long file_size PARAMS ((const char *));
+off_t file_size PARAMS ((const char *));
 int make_directory PARAMS ((const char *));
 char *unique_name PARAMS ((const char *, int));
 char *file_merge PARAMS ((const char *, const char *));
@@ -101,10 +101,21 @@
 void string_set_free PARAMS ((struct hash_table *));
 void free_keys_and_values PARAMS ((struct hash_table *));
 
-char *legible PARAMS ((long));
+char *legible PARAMS ((unsigned long int));
 char *legible_large_int PARAMS ((LARGE_INT));
-int numdigit PARAMS ((long));
-char *number_to_string PARAMS ((char *, long));
+int numdigit PARAMS ((unsigned long int));
+char *number_to_string PARAMS ((char *, unsigned long int));
+
+#ifdef LFS
+char *legible_off_t PARAMS ((off_t));
+char *number_to_string_off_t PARAMS ((char *, off_t ));
+char *number_to_string_64 PARAMS ((char *, unsigned long long int));
+int numdigit_64 PARAMS ((unsigned long long int));
+unsigned long long int wget_strtoull ( const char *ptr, char **endptr, int base );
+#else
+#define number_to_string_off_t number_to_string
+#define legible_off_t          legible
+#endif
 
 struct wget_timer *wtimer_allocate PARAMS ((void));
 struct wget_timer *wtimer_new PARAMS ((void));
--- ./src/utils.c.lfs	2003-10-23 14:16:21.000000000 +0200
+++ ./src/utils.c	2004-12-15 17:31:53.286577039 +0100
@@ -569,10 +569,10 @@
 
 /* Return the size of file named by FILENAME, or -1 if it cannot be
    opened or seeked into. */
-long
+off_t
 file_size (const char *filename)
 {
-  long size;
+  off_t size;
   /* We use fseek rather than stat to determine the file size because
      that way we can also verify whether the file is readable.
      Inspired by the POST patch by Arnaud Wylie.  */
@@ -985,7 +985,7 @@
 {
   int fd;
   struct file_memory *fm;
-  long size;
+  off_t size;
   int inhibit_close = 0;
 
   /* Some magic in the finest tradition of Perl and its kin: if FILE
@@ -1037,7 +1037,7 @@
   fm->content = xmalloc (size);
   while (1)
     {
-      long nread;
+      off_t nread;
       if (fm->length > size / 2)
 	{
 	  /* #### I'm not sure whether the whole exponential-growth
@@ -1337,7 +1337,7 @@
 /* Legible -- return a static pointer to the legibly printed long.  */
 
 char *
-legible (long l)
+legible (unsigned long int l)
 {
   char inbuf[24];
   /* Print the number into the buffer.  */
@@ -1373,7 +1373,7 @@
 
 /* Count the digits in a (long) integer.  */
 int
-numdigit (long number)
+numdigit (unsigned long int number)
 {
   int cnt = 1;
   if (number < 0)
@@ -1386,6 +1386,25 @@
   return cnt;
 }
 
+#ifdef LFS
+int
+numdigit_64 (unsigned long long int number)
+{
+  int cnt = 1;
+  if (number < 0)
+    {
+      number = -number;
+      ++cnt;
+    }
+  while ((number /= 10ULL) > 0)
+    ++cnt;
+  return cnt;
+}
+
+#endif
+
+
+
 /* A half-assed implementation of INT_MAX on machines that don't
    bother to define one. */
 #ifndef INT_MAX
@@ -1437,10 +1456,10 @@
    terminating '\0'.  */
 
 char *
-number_to_string (char *buffer, long number)
+number_to_string (char *buffer, unsigned long int number)
 {
   char *p = buffer;
-  long n = number;
+  unsigned long int n = number;
 
 #if (SIZEOF_LONG != 4) && (SIZEOF_LONG != 8)
   /* We are running in a strange or misconfigured environment.  Let
@@ -2084,4 +2103,91 @@
   return 0;
 }
 #endif /* not WINDOWS */
+
 #endif /* not USE_SIGNAL_TIMEOUT */
+
+#ifdef LFS
+char *
+number_to_string_off_t  (char *buffer, off_t number)
+{
+  if ( sizeof(number) == 8 )
+       return number_to_string_64 (buffer, number);
+    else
+       return number_to_string (buffer, number);
+    return number_to_string (buffer, number);
+}
+
+
+/* Legible_off_t -- return a static pointer to the legibly printed long.      */
+/*                  the same as legible, but it interprete the argument       */
+/*                  either as 32-bits unsigned long or as 64-bits unsigned    */
+/*                  long according to the size of off_t                       */
+
+char *
+legible_off_t ( off_t l)
+{
+  char inbuf[28];
+  /* Print the number into the buffer.  */
+
+  number_to_string_off_t (inbuf, l);
+  return legible_1 (inbuf);
+}
+
+/*  number_to_string_64 -- is the same as number_to_string, but it it      */
+/*                         assumes that its argukent is a 64-bits unsigned */
+/*                         long                                            */
+
+char *
+number_to_string_64 (char *buffer, unsigned long long int number)
+{
+  char *p = buffer;
+  unsigned long long int n = number;
+
+#define ONE_DIGIT(figure) *p++ = n / (figure) + '0'
+#define ONE_DIGIT_ADVANCE(figure) (ONE_DIGIT (figure), n %= (figure))
+
+#define DIGITS_1(figure) ONE_DIGIT (figure)
+#define DIGITS_2(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_1 ((figure) / 10)
+#define DIGITS_3(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_2 ((figure) / 10)
+#define DIGITS_4(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_3 ((figure) / 10)
+#define DIGITS_5(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_4 ((figure) / 10)
+#define DIGITS_6(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_5 ((figure) / 10)
+#define DIGITS_7(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_6 ((figure) / 10)
+#define DIGITS_8(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_7 ((figure) / 10)
+#define DIGITS_9(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_8 ((figure) / 10)
+#define DIGITS_10(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_9 ((figure) / 10)
+#define DIGITS_11(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_10 ((figure) / 10)
+#define DIGITS_12(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_11 ((figure) / 10)
+#define DIGITS_13(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_12 ((figure) / 10)
+#define DIGITS_14(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_13 ((figure) / 10)
+#define DIGITS_15(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_14 ((figure) / 10)
+#define DIGITS_16(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_15 ((figure) / 10)
+#define DIGITS_17(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_16 ((figure) / 10)
+#define DIGITS_18(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_17 ((figure) / 10)
+#define DIGITS_19(figure) ONE_DIGIT_ADVANCE (figure); DIGITS_18 ((figure) / 10)
+
+  if      (n < 10ULL)                  { DIGITS_1 (1ULL); }
+  else if (n < 100ULL)                 { DIGITS_2 (10ULL); }
+  else if (n < 1000ULL)                { DIGITS_3 (100ULL); }
+  else if (n < 10000ULL)               { DIGITS_4 (1000ULL); }
+  else if (n < 100000ULL)              { DIGITS_5 (10000ULL); }
+  else if (n < 1000000ULL)             { DIGITS_6 (100000ULL); }
+  else if (n < 10000000ULL)            { DIGITS_7 (1000000ULL); }
+  else if (n < 100000000ULL)           { DIGITS_8 (10000000ULL); }
+  else if (n < 1000000000ULL)          { DIGITS_9 (100000000ULL); }
+  else if (n < 10000000000ULL)         { DIGITS_10 (1000000000ULL); }
+  else if (n < 100000000000ULL)        { DIGITS_11 (10000000000ULL); }
+  else if (n < 1000000000000ULL)       { DIGITS_12 (100000000000ULL); }
+  else if (n < 10000000000000ULL)      { DIGITS_13 (1000000000000ULL); }
+  else if (n < 100000000000000ULL)     { DIGITS_14 (10000000000000ULL); }
+  else if (n < 1000000000000000ULL)    { DIGITS_15 (100000000000000ULL); }
+  else if (n < 10000000000000000ULL)   { DIGITS_16 (1000000000000000ULL); }
+  else if (n < 100000000000000000ULL)  { DIGITS_17 (10000000000000000ULL); }
+  else if (n < 1000000000000000000ULL) { DIGITS_18 (100000000000000000ULL); }
+  else                                 { DIGITS_19 (1000000000000000000ULL); }
+
+  *p = '\0';
+  return p;
+}
+#endif
+
--- ./src/ftp.h.lfs	2003-09-18 15:46:17.000000000 +0200
+++ ./src/ftp.h	2004-12-15 17:31:53.286577039 +0100
@@ -57,11 +57,11 @@
 uerr_t ftp_type PARAMS ((struct rbuf *, int));
 uerr_t ftp_cwd PARAMS ((struct rbuf *, const char *));
 uerr_t ftp_retr PARAMS ((struct rbuf *, const char *));
-uerr_t ftp_rest PARAMS ((struct rbuf *, long));
+uerr_t ftp_rest PARAMS ((struct rbuf *, off_t));
 uerr_t ftp_list PARAMS ((struct rbuf *, const char *));
 uerr_t ftp_syst PARAMS ((struct rbuf *, enum stype *));
 uerr_t ftp_pwd PARAMS ((struct rbuf *, char **));
-uerr_t ftp_size PARAMS ((struct rbuf *, const char *, long int *));
+uerr_t ftp_size PARAMS ((struct rbuf *, const char *, off_t *));
 
 struct url;
 
@@ -86,7 +86,7 @@
 {
   enum ftype type;		/* file type */
   char *name;			/* file name */
-  long size;			/* file size */
+  off_t size;			/* file size */
   long tstamp;			/* time-stamp */
   int perms;			/* file permissions */
   char *linkto;			/* link to which file points */
--- ./src/html-url.c.lfs	2003-10-13 16:32:25.000000000 +0200
+++ ./src/html-url.c	2004-12-15 17:31:53.287577056 +0100
@@ -598,7 +598,7 @@
       logprintf (LOG_NOTQUIET, "%s: %s\n", file, strerror (errno));
       return NULL;
     }
-  DEBUGP (("Loaded %s (size %ld).\n", file, fm->length));
+  DEBUGP (("Loaded %s (size %s).\n", file, legible_off_t(fm->length)));
 
   ctx.text = fm->content;
   ctx.head = ctx.tail = NULL;
@@ -647,7 +647,7 @@
       logprintf (LOG_NOTQUIET, "%s: %s\n", file, strerror (errno));
       return NULL;
     }
-  DEBUGP (("Loaded %s (size %ld).\n", file, fm->length));
+  DEBUGP (("Loaded %s (size %s).\n", file, legible_off_t(fm->length)));
 
   head = tail = NULL;
   text = fm->content;
--- ./src/connect.h.lfs	2003-09-21 01:12:18.000000000 +0200
+++ ./src/connect.h	2004-12-15 17:31:53.287577056 +0100
@@ -45,7 +45,7 @@
 void closeport PARAMS ((int));
 int conaddr PARAMS ((int, ip_address *));
 
-int iread PARAMS ((int, char *, int));
-int iwrite PARAMS ((int, char *, int));
+int iread PARAMS ((int, char *, off_t));
+int iwrite PARAMS ((int, char *, off_t));
 
 #endif /* CONNECT_H */
--- ./src/http.c.lfs	2003-10-15 01:32:15.000000000 +0200
+++ ./src/http.c	2004-12-15 17:31:53.289577091 +0100
@@ -192,10 +192,10 @@
    longer, read only that much; if the file is shorter, report an error.  */
 
 static int
-post_file (int sock, void *ssl, const char *file_name, long promised_size)
+post_file (int sock, void *ssl, const char *file_name, off_t promised_size)
 {
   static char chunk[8192];
-  long written = 0;
+  off_t written = 0;
   int write_error;
   FILE *fp;
 
@@ -246,9 +246,9 @@
 /* Functions to be used as arguments to header_process(): */
 
 struct http_process_range_closure {
-  long first_byte_pos;
-  long last_byte_pos;
-  long entity_length;
+  off_t first_byte_pos;
+  off_t last_byte_pos;
+  off_t entity_length;
 };
 
 /* Parse the `Content-Range' header and extract the information it
@@ -258,7 +258,7 @@
 {
   struct http_process_range_closure *closure
     = (struct http_process_range_closure *)arg;
-  long num;
+  off_t num;
 
   /* Certain versions of Nutscape proxy server send out
      `Content-Length' without "bytes" specifier, which is a breach of
@@ -564,9 +564,9 @@
 
 struct http_stat
 {
-  long len;			/* received length */
-  long contlen;			/* expected length */
-  long restval;			/* the restart value */
+  off_t len;			/* received length */
+  off_t contlen;		/* expected length */
+  off_t restval;		/* the restart value */
   int res;			/* the result of last read */
   char *newloc;			/* new location (redirection) */
   char *remote_time;		/* remote time-stamp string */
@@ -631,7 +631,7 @@
   char *request_keep_alive;
   int sock, hcount, all_length, statcode;
   int write_error;
-  long contlen, contrange;
+  off_t contlen, contrange;
   struct url *conn;
   FILE *fp;
   int auth_tried_already;
@@ -660,7 +660,7 @@
 
   /* Headers sent when using POST. */
   char *post_content_type, *post_content_length;
-  long post_data_size = 0;
+  off_t post_data_size = 0;
 
 #ifdef HAVE_SSL
   /* initialize ssl_ctx on first run */
@@ -809,7 +809,11 @@
          HTTP/1.1 specifies a multipart/byte-ranges MIME type, but
          only if multiple non-overlapping ranges are requested --
          which Wget never does.  */
+#ifdef LFS
+      sprintf (range, "Range: bytes=%llu-\r\n", hs->restval);
+#else
       sprintf (range, "Range: bytes=%ld-\r\n", hs->restval);
+#endif
     }
   else
     range = NULL;
@@ -931,8 +935,13 @@
 	    }
 	}
       post_content_length = xmalloc (16 + numdigit (post_data_size) + 2 + 1);
+#ifdef LFS
+      sprintf (post_content_length,
+	       "Content-Length: %llu\r\n", post_data_size);
+#else
       sprintf (post_content_length,
 	       "Content-Length: %ld\r\n", post_data_size);
+#endif
     }
 
   if (proxy)
@@ -1166,7 +1175,7 @@
 
       /* Try getting content-length.  */
       if (contlen == -1 && !opt.ignore_length)
-	if (header_process (hdr, "Content-Length", header_extract_number,
+	if (header_process (hdr, "Content-Length", header_extract_number_off_t,
 			    &contlen))
 	  goto done_header;
       /* Try getting content-type.  */
@@ -1446,10 +1455,10 @@
 	  logputs (LOG_VERBOSE, _("Length: "));
 	  if (contlen != -1)
 	    {
-	      logputs (LOG_VERBOSE, legible (contlen));
+	      logputs (LOG_VERBOSE, legible_off_t (contlen));
 	      if (contrange != -1)
 		logprintf (LOG_VERBOSE, _(" (%s to go)"),
-			   legible (contlen - contrange));
+			   legible_off_t (contlen - contrange));
 	    }
 	  else
 	    logputs (LOG_VERBOSE,
@@ -1571,7 +1580,7 @@
   char *tms, *locf, *tmrate;
   uerr_t err;
   time_t tml = -1, tmr = -1;	/* local and remote time-stamps */
-  long local_size = 0;		/* the size of the local file */
+  off_t local_size = 0;		/* the size of the local file */
   size_t filename_len;
   struct http_stat hstat;	/* HTTP status */
   struct stat st;
@@ -1903,7 +1912,7 @@
 		}
 	      else if (tml >= tmr)
 		logprintf (LOG_VERBOSE, _("\
-The sizes do not match (local %ld) -- retrieving.\n"), local_size);
+The sizes do not match (local %s) -- retrieving.\n"), legible_off_t(local_size));
 	      else
 		logputs (LOG_VERBOSE,
 			 _("Remote file is newer, retrieving.\n"));
@@ -1947,11 +1956,11 @@
 	  if (*dt & RETROKF)
 	    {
 	      logprintf (LOG_VERBOSE,
-			 _("%s (%s) - `%s' saved [%ld/%ld]\n\n"),
-			 tms, tmrate, locf, hstat.len, hstat.contlen);
+			 _("%s (%s) - `%s' saved [%s/%s]\n\n"),
+			 tms, tmrate, locf, legible_off_t(hstat.len), legible_off_t(hstat.contlen));
 	      logprintf (LOG_NONVERBOSE,
-			 "%s URL:%s [%ld/%ld] -> \"%s\" [%d]\n",
-			 tms, u->url, hstat.len, hstat.contlen, locf, count);
+			 "%s URL:%s [%s/%s] -> \"%s\" [%d]\n",
+			 tms, u->url, legible_off_t(hstat.len), legible_off_t(hstat.contlen), locf, count);
 	    }
 	  ++opt.numurls;
 	  total_downloaded_bytes += hstat.len;
@@ -1974,11 +1983,11 @@
 	      if (*dt & RETROKF)
 		{
 		  logprintf (LOG_VERBOSE,
-			     _("%s (%s) - `%s' saved [%ld]\n\n"),
-			     tms, tmrate, locf, hstat.len);
+			     _("%s (%s) - `%s' saved [%s]\n\n"),
+			     tms, tmrate, locf, legible_off_t(hstat.len));
 		  logprintf (LOG_NONVERBOSE,
-			     "%s URL:%s [%ld] -> \"%s\" [%d]\n",
-			     tms, u->url, hstat.len, locf, count);
+			     "%s URL:%s [%s] -> \"%s\" [%d]\n",
+			     tms, u->url, legible_off_t(hstat.len), locf, count);
 		}
 	      ++opt.numurls;
 	      total_downloaded_bytes += hstat.len;
@@ -1997,8 +2006,8 @@
 						 connection too soon */
 	    {
 	      logprintf (LOG_VERBOSE,
-			 _("%s (%s) - Connection closed at byte %ld. "),
-			 tms, tmrate, hstat.len);
+			 _("%s (%s) - Connection closed at byte %s. "),
+			 tms, tmrate, legible_off_t(hstat.len));
 	      printwhat (count, opt.ntry);
 	      free_hstat (&hstat);
 	      continue;
@@ -2006,11 +2015,11 @@
 	  else if (!opt.kill_longer) /* meaning we got more than expected */
 	    {
 	      logprintf (LOG_VERBOSE,
-			 _("%s (%s) - `%s' saved [%ld/%ld])\n\n"),
-			 tms, tmrate, locf, hstat.len, hstat.contlen);
+			 _("%s (%s) - `%s' saved [%s/%s])\n\n"),
+			 tms, tmrate, locf, legible_off_t(hstat.len), legible_off_t(hstat.contlen));
 	      logprintf (LOG_NONVERBOSE,
-			 "%s URL:%s [%ld/%ld] -> \"%s\" [%d]\n",
-			 tms, u->url, hstat.len, hstat.contlen, locf, count);
+			 "%s URL:%s [%s/%s] -> \"%s\" [%d]\n",
+			 tms, u->url, legible_off_t(hstat.len), legible_off_t(hstat.contlen), locf, count);
 	      ++opt.numurls;
 	      total_downloaded_bytes += hstat.len;
 
@@ -2027,8 +2036,8 @@
 	  else			/* the same, but not accepted */
 	    {
 	      logprintf (LOG_VERBOSE,
-			 _("%s (%s) - Connection closed at byte %ld/%ld. "),
-			 tms, tmrate, hstat.len, hstat.contlen);
+			 _("%s (%s) - Connection closed at byte %s/%s. "),
+			 tms, tmrate, legible_off_t(hstat.len), legible_off_t(hstat.contlen));
 	      printwhat (count, opt.ntry);
 	      free_hstat (&hstat);
 	      continue;
@@ -2039,8 +2048,8 @@
 	  if (hstat.contlen == -1)
 	    {
 	      logprintf (LOG_VERBOSE,
-			 _("%s (%s) - Read error at byte %ld (%s)."),
-			 tms, tmrate, hstat.len, strerror (errno));
+			 _("%s (%s) - Read error at byte %s (%s)."),
+			 tms, tmrate, legible_off_t(hstat.len), strerror (errno));
 	      printwhat (count, opt.ntry);
 	      free_hstat (&hstat);
 	      continue;
@@ -2048,8 +2057,8 @@
 	  else			/* hstat.res == -1 and contlen is given */
 	    {
 	      logprintf (LOG_VERBOSE,
-			 _("%s (%s) - Read error at byte %ld/%ld (%s). "),
-			 tms, tmrate, hstat.len, hstat.contlen,
+			 _("%s (%s) - Read error at byte %s/%s (%s). "),
+			 tms, tmrate, legible_off_t(hstat.len), legible_off_t(hstat.contlen),
 			 strerror (errno));
 	      printwhat (count, opt.ntry);
 	      free_hstat (&hstat);
--- ./src/gen_sslfunc.h.lfs	2002-05-18 04:16:22.000000000 +0200
+++ ./src/gen_sslfunc.h	2004-12-15 17:31:53.290577108 +0100
@@ -42,8 +42,8 @@
 void shutdown_ssl PARAMS ((SSL*));
 void free_ssl_ctx PARAMS ((SSL_CTX *));
 int verify_callback PARAMS ((int, X509_STORE_CTX *));
-int ssl_iread PARAMS ((SSL *, char *, int));
-int ssl_iwrite PARAMS ((SSL *, char *, int));
+int ssl_iread PARAMS ((SSL *, char *, off_t));
+int ssl_iwrite PARAMS ((SSL *, char *, off_t));
 int ssl_printerrors PARAMS ((void)); 
 
 #endif /* GEN_SSLFUNC_H */
--- ./src/gen_sslfunc.c.lfs	2003-09-21 06:41:55.000000000 +0200
+++ ./src/gen_sslfunc.c	2004-12-15 17:31:53.291577125 +0100
@@ -312,7 +312,7 @@
    most LEN bytes from FD, storing them to BUF. */
 
 int
-ssl_iread (SSL *con, char *buf, int len)
+ssl_iread (SSL *con, char *buf, off_t len)
 {
   int res, fd;
   BIO_get_fd (con->rbio, &fd);
@@ -332,7 +332,7 @@
    LEN bytes from BUF to FD.  */
 
 int
-ssl_iwrite (SSL *con, char *buf, int len)
+ssl_iwrite (SSL *con, char *buf, off_t len)
 {
   int res = 0, fd;
   BIO_get_fd (con->rbio, &fd);
--- ./src/headers.c.lfs	2002-05-18 04:16:22.000000000 +0200
+++ ./src/headers.c	2004-12-15 17:31:53.291577125 +0100
@@ -177,6 +177,33 @@
   return 1;
 }
 
+/* Extract a long integer from HEADER and store it to CLOSURE.  If an
+   error is encountered, return 0, else 1.  */
+int
+header_extract_number_off_t (const char *header, void *closure)
+{
+  const char *p = header;
+  off_t result;
+
+  for (result = 0; ISDIGIT (*p); p++)
+    result = 10 * result + (*p - '0');
+
+  /* Failure if no number present. */
+  if (p == header)
+    return 0;
+
+  /* Skip trailing whitespace. */
+  p += skip_lws (p);
+
+  /* Indicate failure if trailing garbage is present. */
+  if (*p)
+    return 0;
+
+  *(off_t *)closure = result;
+  return 1;
+}
+
+
 /* Strdup HEADER, and place the pointer to CLOSURE.  */
 int
 header_strdup (const char *header, void *closure)
--- ./src/ftp-basic.c.lfs	2003-11-08 20:17:55.000000000 +0100
+++ ./src/ftp-basic.c	2004-12-15 17:31:53.292577142 +0100
@@ -610,14 +610,14 @@
 
 /* Sends REST command to the FTP server.  */
 uerr_t
-ftp_rest (struct rbuf *rbuf, long offset)
+ftp_rest (struct rbuf *rbuf, off_t offset)
 {
   char *request, *respline;
   int nwritten;
   uerr_t err;
   static char numbuf[24]; /* Buffer for the number */
 
-  number_to_string (numbuf, offset);
+  number_to_string_off_t (numbuf, offset);
   request = ftp_request ("REST", numbuf);
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
@@ -824,10 +824,140 @@
   return FTPOK;
 }
 
+
+#ifdef LFS
+unsigned long long int wget_strtoull ( const char * str, 
+                                       char ** endptr, 
+                                       int base )
+/* *********************************************************************** */
+/*                                                                         */
+/* These functions shall convert the initial portion of the string         */
+/* pointed to by nptr to double, float, and long double representation,    */
+/* respectively. First, they decompose the input string into three parts:  */
+/*                                                                         */
+/* An initial, possibly empty, sequence of white-space characters          */
+/* (as specified by isspace())                                             */
+/* A subject sequence interpreted as a floating-point constant or          */
+/* representing infinity or NaN                                            */
+/* A final string of one or more unrecognized characters, including the    */
+/* terminating null byte of the input string                               */
+/*                                                                         */
+/* Then they shall attempt to convert the subject sequence                 */
+/* to a floating-point number, and return the result.                      */
+/*                                                                         */
+/* The expected form of the subject sequence is an optional plus or        */
+/* minus sign, then one of the following:                                  */
+/*                                                                         */
+/* A non-empty sequence of decimal digits optionally containing            */
+/* a radix character, then an optional exponent part                       */
+/*                                                                         */
+/* A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally  */
+/* containing a radix character, then an optional binary exponent part     */
+/*                                                                         */
+/* One of INF or INFINITY, ignoring case                                   */
+/*                                                                         */
+/* One of NAN or NAN(n-char-sequenceopt), ignoring case                    */
+/* in the NAN part, where:                                                 */
+/* n-char-sequence: -- digit -- nondigit -- n-char-sequence digit          */
+/* -- n-char-sequence nondigit                                             */
+/*                                                                         */
+/* Borrowed from http://www.greatsnakes.com/Sepal/d8/d4/strtoull_8c.html   */
+/* on 2004.09.09                                                           */
+/*                                                                         */
+/* 2003, greatsnakes.com.  "Verbatim copying and distribution of this      */
+/*       entire article is permitted in any medium, provided this notice   */
+/*       is preserved." -- unless otherwise specified.                     */
+/*                                                                         */
+/* *********************************************************************** */
+#define WGET__ULLONG_MAX ( 18446744073709551615ULL )
+
+{
+   unsigned long long result;
+   unsigned long long stop;
+
+   const char *cursor = str;
+   int   i_char, sign = 0, track, threshold;
+
+   do 
+   {
+      i_char = *cursor++;
+   } while ( isspace( i_char & 0xff ) );
+
+   if ( i_char == '-' ) 
+   {
+      sign   = 1;
+      i_char = *cursor++;
+   } else if ( i_char == '+' ) 
+   {
+      i_char = *cursor++;
+   }/* end of if else */
+
+   if (( base == 0 || base == 16 ) &&
+	 ( i_char == '0' ) && ( ( ( *cursor == 'x' ) || ( *cursor == 'X' )))) 
+   {
+      i_char = cursor[1];
+      cursor += 2;
+      base = 16;
+   }/* end of if base */
+
+   if ( base == 0 )
+      base = ( ( i_char == '0' ) ? 8 : 10 );
+
+   stop      = ((( unsigned long long ) WGET__ULLONG_MAX) / base);
+   threshold = ((( unsigned long long ) WGET__ULLONG_MAX) % base);
+   result = 0; track = 0;
+
+   for ( ;; ( i_char = *cursor++ ), ( i_char &= 0xff ) ) 
+   {
+      if ( isdigit(i_char) ) 
+      {
+	 i_char -= '0';
+      } else if (isalpha(i_char)) 
+      {
+	 i_char -= ( isupper(i_char) ? ('A' - 10) : ('a' - 10) );
+      } else 
+      {
+	 break;
+      }/* if elseif else */
+
+      if ( i_char >= base )
+	 break;
+      if ( ( track < 0 ) || ( result > stop ) ||
+	    ( result == stop && ( i_char > threshold ) ) ) 
+      {
+	 track = -1;
+      } else 
+      {
+	 track   = 1;
+	 result *= base;
+	 result += i_char;
+      }/* end if else */
+   }/* for ( ;; ( i_char = *cursor++ ), ( i_char &= 0xff ) ) */
+
+   if ( track < 0 ) 
+   {
+      result = (( unsigned long long ) WGET__ULLONG_MAX);
+      errno  = ERANGE;
+   } else if ( sign ) 
+   {
+      result = -result;
+   }/* end of if else */
+
+   if ( endptr != 0 ) 
+   {
+      //    *endptr = ( track ? ( fixit( str, char * ) - 1 )
+      //            : fixit( str, char * ) );
+   }
+
+   return result;
+}/* unsigned long long int wget_strtoull ( const char *str, char **endptr, int base ) */
+
+#endif /* ifdef LFS */
+
 /* Sends the SIZE command to the server, and returns the value in 'size'.
  * If an error occurs, size is set to zero. */
 uerr_t
-ftp_size (struct rbuf *rbuf, const char *file, long int *size)
+ftp_size (struct rbuf *rbuf, const char *file, off_t *size)
 {
   char *request, *respline;
   int nwritten;
@@ -863,7 +993,11 @@
     }
 
   errno = 0;
-  *size = strtol (respline + 4, NULL, 0);
+#ifdef LFS
+  *size = wget_strtoull (respline + 4, NULL, 10);
+#else
+  *size = strtol (respline + 4, NULL, 10);
+#endif
   if (errno) 
     {
       /* 
--- ./src/progress.h.lfs	2003-09-15 23:14:15.000000000 +0200
+++ ./src/progress.h	2004-12-15 17:31:53.292577142 +0100
@@ -34,8 +34,8 @@
 void set_progress_implementation PARAMS ((const char *));
 void progress_schedule_redirect PARAMS ((void));
 
-void *progress_create PARAMS ((long, long));
-void progress_update PARAMS ((void *, long, double));
+void *progress_create PARAMS ((off_t, off_t));
+void progress_update PARAMS ((void *, off_t, double));
 void progress_finish PARAMS ((void *, double));
 
 RETSIGTYPE progress_handle_sigwinch PARAMS ((int));
--- ./src/connect.c.lfs	2003-11-01 15:08:22.000000000 +0100
+++ ./src/connect.c	2004-12-15 17:31:53.293577159 +0100
@@ -448,7 +448,7 @@
    read()).  */
 
 int
-iread (int fd, char *buf, int len)
+iread (int fd, char *buf, off_t len)
 {
   int res;
 
@@ -470,7 +470,7 @@
    value equals to LEN.  Instead, you should simply check for -1.  */
 
 int
-iwrite (int fd, char *buf, int len)
+iwrite (int fd, char *buf, off_t len)
 {
   int res = 0;
 
--- ./src/ftp-ls.c.lfs	2003-09-15 00:04:12.000000000 +0200
+++ ./src/ftp-ls.c	2004-12-15 17:31:53.294577177 +0100
@@ -211,7 +211,7 @@
 	      if (i != 12)
 		{
 		  char *t = tok - 2;
-		  long mul = 1;
+		  off_t mul = 1;
 
 		  for (cur.size = 0; t > line && ISDIGIT (*t); mul *= 10, t--)
 		    cur.size += mul * (*t - '0');
@@ -510,7 +510,7 @@
 	  cur.type  = FT_PLAINFILE;
 	  cur.size  = atoi(tok);
 	  cur.perms = 0644;
-	  DEBUGP(("File, size %ld bytes\n", cur.size));
+	  DEBUGP(("File, size %s bytes\n", legible_off_t(cur.size)));
 	}
 
       cur.linkto = NULL;
@@ -910,7 +910,7 @@
 	putc ('/', fp);
       fprintf (fp, "</a> ");
       if (f->type == FT_PLAINFILE)
-	fprintf (fp, _(" (%s bytes)"), legible (f->size));
+	fprintf (fp, _(" (%s bytes)"), legible_off_t (f->size));
       else if (f->type == FT_SYMLINK)
 	fprintf (fp, "-> %s", f->linkto ? f->linkto : "(nil)");
       putc ('\n', fp);
--- ./src/progress.c.lfs	2004-12-15 17:31:53.226576007 +0100
+++ ./src/progress.c	2004-12-15 17:37:42.760587568 +0100
@@ -51,21 +51,21 @@
 
 struct progress_implementation {
   char *name;
-  void *(*create) PARAMS ((long, long));
-  void (*update) PARAMS ((void *, long, double));
+  void *(*create) PARAMS ((off_t, off_t));
+  void (*update) PARAMS ((void *, off_t, double));
   void (*finish) PARAMS ((void *, double));
   void (*set_params) PARAMS ((const char *));
 };
 
 /* Necessary forward declarations. */
 
-static void *dot_create PARAMS ((long, long));
-static void dot_update PARAMS ((void *, long, double));
+static void *dot_create PARAMS ((off_t, off_t));
+static void dot_update PARAMS ((void *, off_t, double));
 static void dot_finish PARAMS ((void *, double));
 static void dot_set_params PARAMS ((const char *));
 
-static void *bar_create PARAMS ((long, long));
-static void bar_update PARAMS ((void *, long, double));
+static void *bar_create PARAMS ((off_t, off_t));
+static void bar_update PARAMS ((void *, off_t, double));
 static void bar_finish PARAMS ((void *, double));
 static void bar_set_params PARAMS ((const char *));
 
@@ -155,7 +155,7 @@
    advance.  */
 
 void *
-progress_create (long initial, long total)
+progress_create (off_t initial, off_t total)
 {
   /* Check if the log status has changed under our feet. */
   if (output_redirected)
@@ -172,7 +172,7 @@
    time in milliseconds since the beginning of the download.  */
 
 void
-progress_update (void *progress, long howmuch, double dltime)
+progress_update (void *progress, off_t howmuch, double dltime)
 {
   current_impl->update (progress, howmuch, dltime);
 }
@@ -189,12 +189,12 @@
 /* Dot-printing. */
 
 struct dot_progress {
-  long initial_length;		/* how many bytes have been downloaded
+  off_t initial_length;		/* how many bytes have been downloaded
 				   previously. */
-  long total_length;		/* expected total byte count when the
+  off_t total_length;		/* expected total byte count when the
 				   download finishes */
 
-  int accumulated;
+  off_t accumulated;
 
   int rows;			/* number of rows printed so far */
   int dots;			/* number of dots printed in this row */
@@ -204,7 +204,7 @@
 /* Dot-progress backend for progress_create. */
 
 static void *
-dot_create (long initial, long total)
+dot_create (off_t initial, off_t total)
 {
   struct dot_progress *dp = xmalloc (sizeof (struct dot_progress));
 
@@ -215,11 +215,35 @@
 
   if (dp->initial_length)
     {
+#ifdef LFS   /* 64-bit off_t  */
+      long long int dot_bytes = opt.dot_bytes;
+      long row_bytes = opt.dot_bytes * opt.dots_in_line;
+
+      long long int remainder = (long long int) (dp->initial_length % row_bytes);
+      off_t skipped = dp->initial_length - remainder;
+
+      if (skipped)
+       {
+         long long int skipped_k = (skipped / 1024ULL); /* skipped amount in K */
+         int skipped_k_len = numdigit_64 (skipped_k);
+         if (skipped_k_len < 5)
+           skipped_k_len = 5;
+
+         /* Align the [ skipping ... ] line with the dots.  To do
+            that, insert the number of spaces equal to the number of
+            digits in the skipped amount in K.  */
+          DEBUGP ( ("Skipped bytes: %llu", skipped ));
+         logprintf (LOG_VERBOSE, _("\n%*s[ skipping %lluK ]"),
+                    2 + skipped_k_len, "", skipped_k);
+       }
+
+      logprintf (LOG_VERBOSE, "\n%5lluK", (skipped / 1024ULL) );
+#else
       int dot_bytes = opt.dot_bytes;
       long row_bytes = opt.dot_bytes * opt.dots_in_line;
 
       int remainder = (int) (dp->initial_length % row_bytes);
-      long skipped = dp->initial_length - remainder;
+      off_t skipped = dp->initial_length - remainder;
 
       if (skipped)
 	{
@@ -231,11 +255,13 @@
 	  /* Align the [ skipping ... ] line with the dots.  To do
 	     that, insert the number of spaces equal to the number of
 	     digits in the skipped amount in K.  */
+          DEBUGP ( ("Skipped bytes: %ld", skipped ));
 	  logprintf (LOG_VERBOSE, _("\n%*s[ skipping %dK ]"),
 		     2 + skipped_k_len, "", skipped_k);
 	}
 
-      logprintf (LOG_VERBOSE, "\n%5ldK", skipped / 1024);
+      logprintf (LOG_VERBOSE, "\n%5luK", skipped / 1024);
+#endif
       for (; remainder >= dot_bytes; remainder -= dot_bytes)
 	{
 	  if (dp->dots % opt.dot_spacing == 0)
@@ -253,7 +279,7 @@
 }
 
 static void
-print_percentage (long bytes, long expected,
+print_percentage (off_t bytes, off_t expected,
                   long row_size,
                   long dltime, struct dot_progress *dp )
 {
@@ -308,7 +334,7 @@
 }
 
 static void
-print_download_speed (struct dot_progress *dp, long bytes, double dltime)
+print_download_speed (struct dot_progress *dp, off_t bytes, double dltime)
 {
   logprintf (LOG_VERBOSE, " %s",
 	     retr_rate (bytes, dltime - dp->last_timer_value, 1));
@@ -318,7 +344,7 @@
 /* Dot-progress backend for progress_update. */
 
 static void
-dot_update (void *progress, long howmuch, double dltime)
+dot_update (void *progress, off_t howmuch, double dltime)
 {
   struct dot_progress *dp = progress;
   int dot_bytes = opt.dot_bytes;
@@ -330,7 +356,12 @@
   for (; dp->accumulated >= dot_bytes; dp->accumulated -= dot_bytes)
     {
       if (dp->dots == 0)
+#ifdef LFS
+       logprintf (LOG_VERBOSE, "\n%5lluK",
+           (long long)dp->rows * (long long)row_bytes / 1024ULL );
+#else
 	logprintf (LOG_VERBOSE, "\n%5ldK", dp->rows * row_bytes / 1024);
+#endif
 
       if (dp->dots % opt.dot_spacing == 0)
 	logputs (LOG_VERBOSE, " ");
@@ -346,7 +377,8 @@
 	  ++dp->rows;
 	  dp->dots = 0;
 
-    print_percentage (dp->rows * row_bytes, dp->total_length,
+  	  print_download_speed (dp, row_qty, dltime);
+    print_percentage ((long long)dp->rows * (long long)row_bytes, dp->total_length,
                       row_qty, dltime, dp );
 	}
     }
@@ -367,7 +399,12 @@
   log_set_flush (0);
 
   if (dp->dots == 0)
+#ifdef LFS
+       logprintf (LOG_VERBOSE, "\n%5lluK",
+           (long long)dp->rows * (long long)(row_bytes) / 1024ULL );
+#else
     logprintf (LOG_VERBOSE, "\n%5ldK", dp->rows * row_bytes / 1024);
+#endif
   for (i = dp->dots; i < opt.dots_in_line; i++)
     {
       if (i % opt.dot_spacing == 0)
@@ -375,10 +412,15 @@
       logputs (LOG_VERBOSE, " ");
     }
   {
+#ifdef LFS
+    long long row_qty =   (long long)dp->dots * (long long)dot_bytes
+                        + dp->accumulated;
+#else
     long row_qty = dp->dots * dot_bytes + dp->accumulated;
+#endif
     if (dp->rows == dp->initial_length / row_bytes)
       row_qty -= dp->initial_length % row_bytes;
-    print_percentage (dp->rows * row_bytes
+    print_percentage ((long long)dp->rows * (long long)row_bytes
 			+ dp->dots * dot_bytes
 			+ dp->accumulated,
 			dp->total_length, row_qty, dltime, dp );
@@ -465,11 +507,11 @@
 #define DLSPEED_SAMPLE_MIN 150
 
 struct bar_progress {
-  long initial_length;		/* how many bytes have been downloaded
+  off_t initial_length;		/* how many bytes have been downloaded
 				   previously. */
-  long total_length;		/* expected total byte count when the
+  off_t total_length;		/* expected total byte count when the
 				   download finishes */
-  long count;			/* bytes downloaded so far */
+  off_t count;			/* bytes downloaded so far */
 
   double last_screen_update;	/* time of the last screen update,
 				   measured since the beginning of
@@ -492,18 +534,18 @@
      details.  */
   struct bar_progress_hist {
     int pos;
-    long times[DLSPEED_HISTORY_SIZE];
-    long bytes[DLSPEED_HISTORY_SIZE];
+    off_t times[DLSPEED_HISTORY_SIZE];
+    off_t bytes[DLSPEED_HISTORY_SIZE];
 
     /* The sum of times and bytes respectively, maintained for
        efficiency. */
-    long total_time;
-    long total_bytes;
+    off_t total_time;
+    off_t total_bytes;
   } hist;
 
   double recent_start;		/* timestamp of beginning of current
 				   position. */
-  long recent_bytes;		/* bytes downloaded so far. */
+  off_t recent_bytes;		/* bytes downloaded so far. */
 
   /* create_image() uses these to make sure that ETA information
      doesn't flash. */
@@ -517,7 +559,7 @@
 static void display_image PARAMS ((char *));
 
 static void *
-bar_create (long initial, long total)
+bar_create (off_t initial, off_t total)
 {
   struct bar_progress *bp = xmalloc (sizeof (struct bar_progress));
 
@@ -544,10 +586,10 @@
   return bp;
 }
 
-static void update_speed_ring PARAMS ((struct bar_progress *, long, double));
+static void update_speed_ring PARAMS ((struct bar_progress *, off_t, double));
 
 static void
-bar_update (void *progress, long howmuch, double dltime)
+bar_update (void *progress, off_t howmuch, double dltime)
 {
   struct bar_progress *bp = progress;
   int force_screen_update = 0;
@@ -618,7 +660,7 @@
    3-second average would be too erratic.  */
 
 static void
-update_speed_ring (struct bar_progress *bp, long howmuch, double dltime)
+update_speed_ring (struct bar_progress *bp, off_t howmuch, double dltime)
 {
   struct bar_progress_hist *hist = &bp->hist;
   double recent_age = dltime - bp->recent_start;
@@ -683,9 +725,9 @@
 create_image (struct bar_progress *bp, double dl_total_time)
 {
   char *p = bp->buffer;
-  long size = bp->initial_length + bp->count;
+  off_t size = bp->initial_length + bp->count;
 
-  char *size_legible = legible (size);
+  char *size_legible = legible_off_t (size);
   int size_legible_len = strlen (size_legible);
 
   struct bar_progress_hist *hist = &bp->hist;
@@ -792,7 +834,7 @@
     }
 
   /* " 234,567,890" */
-  sprintf (p, " %-11s", legible (size));
+  sprintf (p, " %-11s", legible_off_t (size));
   p += strlen (p);
 
   /* " 1012.45K/s" */
@@ -802,7 +844,7 @@
       int units = 0;
       /* Calculate the download speed using the history ring and
 	 recent data that hasn't made it to the ring yet.  */
-      long dlquant = hist->total_bytes + bp->recent_bytes;
+      off_t dlquant = hist->total_bytes + bp->recent_bytes;
       double dltime = hist->total_time + (dl_total_time - bp->recent_start);
       double dlspeed = calc_rate (dlquant, dltime, &units);
       sprintf (p, " %7.2f%s", dlspeed, short_units[units]);
@@ -835,7 +877,7 @@
 	     I found that doing that results in a very jerky and
 	     ultimately unreliable ETA.  */
 	  double time_sofar = (double)dl_total_time / 1000;
-	  long bytes_remaining = bp->total_length - size;
+	  off_t bytes_remaining = bp->total_length - size;
 	  eta = (long) (time_sofar * bytes_remaining / bp->count);
 	  bp->last_eta_value = eta;
 	  bp->last_eta_time = dl_total_time;
--- ./src/ftp.c.lfs	2003-10-15 00:52:12.000000000 +0200
+++ ./src/ftp.c	2004-12-15 17:31:53.297577228 +0100
@@ -82,10 +82,10 @@
 /* Look for regexp "( *[0-9]+ *byte" (literal parenthesis) anywhere in
    the string S, and return the number converted to long, if found, 0
    otherwise.  */
-static long
+static off_t
 ftp_expected_bytes (const char *s)
 {
-  long res;
+  off_t res;
 
   while (1)
     {
@@ -125,16 +125,16 @@
    connection to the server.  It always closes the data connection,
    and closes the control connection in case of error.  */
 static uerr_t
-getftp (struct url *u, long *len, long restval, ccon *con)
+getftp (struct url *u, off_t *len, off_t restval, ccon *con)
 {
   int csock, dtsock, res;
-  uerr_t err;
+  uerr_t err = 0;
   FILE *fp;
   char *user, *passwd, *respline;
   char *tms, *tmrate;
   int cmd = con->cmd;
   int pasv_mode_open = 0;
-  long expected_bytes = 0L;
+  off_t expected_bytes = 0;
 
   assert (con != NULL);
   assert (con->target != NULL);
@@ -664,7 +664,7 @@
   if (restval && (cmd & DO_RETR))
     {
       if (!opt.server_response)
-	logprintf (LOG_VERBOSE, "==> REST %ld ... ", restval);
+	logprintf (LOG_VERBOSE, "==> REST %s ... ", legible_off_t(restval));
       err = ftp_rest (&con->rbuf, restval);
 
       /* FTPRERR, WRITEFAILED, FTPRESTFAIL */
@@ -895,21 +895,33 @@
 
   if (*len)
     {
-      logprintf (LOG_VERBOSE, _("Length: %s"), legible (*len));
+      logprintf (LOG_VERBOSE, _("Length: %s"), legible_off_t (*len));
       if (restval)
-	logprintf (LOG_VERBOSE, _(" [%s to go]"), legible (*len - restval));
+	logprintf (LOG_VERBOSE, _(" [%s to go]"), legible_off_t (*len - restval));
       logputs (LOG_VERBOSE, "\n");
       expected_bytes = *len;	/* for get_contents/show_progress */
     }
   else if (expected_bytes)
     {
-      logprintf (LOG_VERBOSE, _("Length: %s"), legible (expected_bytes));
+      logprintf (LOG_VERBOSE, _("Length: %s"), legible_off_t (expected_bytes));
       if (restval)
 	logprintf (LOG_VERBOSE, _(" [%s to go]"),
-		   legible (expected_bytes - restval));
+		   legible_off_t (expected_bytes - restval));
       logputs (LOG_VERBOSE, _(" (unauthoritative)\n"));
     }
-
+  if (*len > 2147483647 && (*len - restval) <= 0 )
+     {
+       logputs (LOG_VERBOSE, _("File has already been downloaded. Nothing to do.\n"));
+       /* Close data connection socket.  */
+       closeport (dtsock);
+      /* Close the local file.  */
+       int flush_res;
+       if (con->cmd & DO_LIST)
+           flush_res = fclose (fp);
+        else
+         flush_res = fflush (fp);
+       return RETRFINISHED;
+     }
   /* Get the contents of the document.  */
   res = get_contents (dtsock, fp, len, restval, expected_bytes, &con->rbuf,
 		      0, &con->dltime);
@@ -1029,7 +1041,7 @@
 ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con)
 {
   int count, orig_lp;
-  long restval, len;
+  off_t restval, len;
   char *tms, *locf;
   char *tmrate = NULL;
   uerr_t err;
@@ -1177,16 +1189,16 @@
 	  rbuf_uninitialize (&con->rbuf);
 	}
       if (!opt.spider)
-        logprintf (LOG_VERBOSE, _("%s (%s) - `%s' saved [%ld]\n\n"),
-		   tms, tmrate, locf, len);
+        logprintf (LOG_VERBOSE, _("%s (%s) - `%s' saved [%s]\n\n"),
+		   tms, tmrate, locf, legible_off_t(len));
       if (!opt.verbose && !opt.quiet)
 	{
 	  /* Need to hide the password from the URL.  The `if' is here
              so that we don't do the needless allocation every
              time. */
 	  char *hurl = url_string (u, 1);
-	  logprintf (LOG_NONVERBOSE, "%s URL: %s [%ld] -> \"%s\" [%d]\n",
-		     tms, hurl, len, locf, count);
+	  logprintf (LOG_NONVERBOSE, "%s URL: %s [%s] -> \"%s\" [%d]\n",
+		     tms, hurl, legible_off_t(len), locf, count);
 	  xfree (hurl);
 	}
 
@@ -1303,7 +1315,7 @@
   static int depth = 0;
   uerr_t err;
   struct fileinfo *orig;
-  long local_size;
+  off_t local_size;
   time_t tml;
   int dlthis;
 
@@ -1396,7 +1408,7 @@
                 {
                   /* Sizes do not match */
                   logprintf (LOG_VERBOSE, _("\
-The sizes do not match (local %ld) -- retrieving.\n\n"), local_size);
+The sizes do not match (local %s) -- retrieving.\n\n"), legible_off_t(local_size));
                 }
             }
 	}	/* opt.timestamping && f->type == FT_PLAINFILE */
@@ -1760,8 +1772,8 @@
 		      else
 			sz = -1;
 		      logprintf (LOG_NOTQUIET,
-				 _("Wrote HTML-ized index to `%s' [%ld].\n"),
-				 filename, sz);
+				 _("Wrote HTML-ized index to `%s' [%s].\n"),
+				 filename, legible_off_t(sz));
 		    }
 		  else
 		    logprintf (LOG_NOTQUIET,
--- ./src/headers.h.lfs	2002-05-18 04:16:22.000000000 +0200
+++ ./src/headers.h	2004-12-15 17:31:53.297577228 +0100
@@ -43,6 +43,7 @@
 			    void *));
 
 int header_extract_number PARAMS ((const char *, void *));
+int header_extract_number_off_t PARAMS ((const char *, void *));
 int header_strdup PARAMS ((const char *, void *));
 int header_exists PARAMS ((const char *, void *));
 
--- ./src/retr.h.lfs	2003-10-11 15:57:11.000000000 +0200
+++ ./src/retr.h	2004-12-15 17:31:53.297577228 +0100
@@ -32,15 +32,15 @@
 
 #include "rbuf.h"
 
-int get_contents PARAMS ((int, FILE *, long *, long, long, struct rbuf *,
+int get_contents PARAMS ((int, FILE *, off_t *, off_t, off_t, struct rbuf *,
 			  int, double *));
 
 uerr_t retrieve_url PARAMS ((const char *, char **, char **,
 			     const char *, int *));
 uerr_t retrieve_from_file PARAMS ((const char *, int, int *));
 
-char *retr_rate PARAMS ((long, double, int));
-double calc_rate PARAMS ((long, double, int *));
+char *retr_rate PARAMS ((off_t, double, int));
+double calc_rate PARAMS ((off_t, double, int *));
 void printwhat PARAMS ((int, int));
 
 void sleep_between_retrievals PARAMS ((int));
--- ./src/retr.c.lfs	2003-10-11 15:57:11.000000000 +0200
+++ ./src/retr.c	2004-12-15 17:31:53.298577245 +0100
@@ -71,7 +71,7 @@
 
 
 static struct {
-  long chunk_bytes;
+  off_t chunk_bytes;
   double chunk_start;
   double sleep_adjust;
 } limit_data;
@@ -88,7 +88,7 @@
    is the number of milliseconds it took to receive them.  */
 
 static void
-limit_bandwidth (long bytes, double *dltime, struct wget_timer *timer)
+limit_bandwidth (off_t bytes, double *dltime, struct wget_timer *timer)
 {
   double delta_t = *dltime - limit_data.chunk_start;
   double expected;
@@ -106,12 +106,12 @@
       double t0, t1;
       if (slp < 200)
 	{
-	  DEBUGP (("deferring a %.2f ms sleep (%ld/%.2f).\n",
-		   slp, limit_data.chunk_bytes, delta_t));
+	  DEBUGP (("deferring a %.2f ms sleep (%s/%.2f).\n",
+		   slp, legible_off_t(limit_data.chunk_bytes), delta_t));
 	  return;
 	}
-      DEBUGP (("\nsleeping %.2f ms for %ld bytes, adjust %.2f ms\n",
-	       slp, limit_data.chunk_bytes, limit_data.sleep_adjust));
+      DEBUGP (("\nsleeping %.2f ms for %s bytes, adjust %.2f ms\n",
+	       slp, legible_off_t(limit_data.chunk_bytes), limit_data.sleep_adjust));
 
       t0 = *dltime;
       usleep ((unsigned long) (1000 * slp));
@@ -156,7 +156,7 @@
    rbuf_flush() before actually reading from fd.  If you wish to read
    from fd immediately, flush or discard the buffer.  */
 int
-get_contents (int fd, FILE *fp, long *len, long restval, long expected,
+get_contents (int fd, FILE *fp, off_t *len, off_t restval, off_t expected,
 	      struct rbuf *rbuf, int use_expected, double *elapsed)
 {
   int res = 0;
@@ -211,7 +211,7 @@
      then expected being zero means exactly that.  */
   while (!use_expected || (*len < expected))
     {
-      int amount_to_read = (use_expected
+      off_t amount_to_read = (use_expected
 			    ? MIN (expected - *len, dlbufsize) : dlbufsize);
 #ifdef HAVE_SSL
       if (rbuf->ssl!=NULL)
@@ -264,7 +264,7 @@
    appropriate for the speed.  If PAD is non-zero, strings will be
    padded to the width of 7 characters (xxxx.xx).  */
 char *
-retr_rate (long bytes, double msecs, int pad)
+retr_rate (off_t bytes, double msecs, int pad)
 {
   static char res[20];
   static char *rate_names[] = {"B/s", "KB/s", "MB/s", "GB/s" };
@@ -284,7 +284,7 @@
    UNITS is zero for B/s, one for KB/s, two for MB/s, and three for
    GB/s.  */
 double
-calc_rate (long bytes, double msecs, int *units)
+calc_rate (off_t bytes, double msecs, int *units)
 {
   double dlrate;
 
--- ./configure.in.lfs	2004-12-15 17:31:53.231576093 +0100
+++ ./configure.in	2004-12-15 17:31:53.284577004 +0100
@@ -106,6 +106,16 @@
 AC_PROG_CC
 
 dnl
+dnl Define Large File support
+dnl
+
+AC_ARG_ENABLE(LFS, [  --disable-LFS           disable Large File Support],
+ENABLE_LFS=$enableval, ENABLE_LFS=yes)
+test x"${ENABLE_LFS}" = xyes && AC_DEFINE([ENABLE_LFS], 1,
+   [Define if you want the Large File Support compiled in.])
+
+
+dnl
 dnl if the user hasn't specified CFLAGS, then
 dnl   if compiler is gcc, then use -O2 and some warning flags
 dnl   else use os-specific flags or -O
@@ -123,6 +133,14 @@
 fi
 
 dnl
+dnl if we're compiling with largefile support, append appropriate 
+dnl parameters to CFLAGS, don't care if they are already in CFLAGS
+dnl
+if test x"$ENABLE_LFS" = xyes; then
+   CFLAGS="$CFLAGS -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -DLFS"
+fi
+
+dnl
 dnl Handle AIX
 dnl
 AC_AIX
@@ -195,7 +213,7 @@
 AC_CHECK_FUNCS(strdup strstr strcasecmp strncasecmp strpbrk memmove)
 AC_CHECK_FUNCS(gettimeofday mktime strptime strerror snprintf vsnprintf)
 AC_CHECK_FUNCS(select sigblock sigsetjmp signal symlink access isatty)
-AC_CHECK_FUNCS(uname gethostname usleep)
+AC_CHECK_FUNCS(uname gethostname usleep strtol strtoll)
 
 dnl
 dnl Check if we need to compile in getopt.c.
