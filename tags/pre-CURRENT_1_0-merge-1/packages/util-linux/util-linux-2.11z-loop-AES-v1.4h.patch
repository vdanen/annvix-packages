--- util-linux-2.11z/mount/Makefile.loopAES	2003-04-14 01:34:31.000000000 -0400
+++ util-linux-2.11z/mount/Makefile	2003-04-14 01:34:31.000000000 -0400
@@ -24,7 +24,7 @@ PROGS = $(SUID_PROGS) $(NOSUID_PROGS)
 
 MAYBE = pivot_root swapoff
 
-LO_OBJS = lomount.o $(LIB)/xstrncpy.o
+LO_OBJS = lomount.o sha512.o $(LIB)/xstrncpy.o
 NFS_OBJS = nfsmount.o nfsmount_xdr.o nfsmount_clnt.o
 GEN_FILES = nfsmount.h nfsmount_xdr.c nfsmount_clnt.c
 
@@ -57,9 +57,11 @@ swapon:	swapon.o version.o
 main_losetup.o: lomount.c
 	$(COMPILE) -DMAIN lomount.c -o $@
 
-losetup: main_losetup.o $(LIB)/xstrncpy.o
+losetup: main_losetup.o sha512.o $(LIB)/xstrncpy.o
 	$(LINK) $^ -o $@
 
+sha512.o lomount.o main_losetup.o: sha512.h
+
 mount.o umount.o nfsmount.o losetup.o fstab.o realpath.o sundries.o: sundries.h
 
 mount.o umount.o fstab.o sundries.o: fstab.h
--- util-linux-2.11z/mount/lomount.c.loopAES	2003-04-14 01:34:31.000000000 -0400
+++ util-linux-2.11z/mount/lomount.c	2003-04-14 01:34:31.000000000 -0400
@@ -30,42 +30,72 @@
 #include "lomount.h"
 #include "xstrncpy.h"
 #include "nls.h"
+#include "sha512.h"
 
 extern int verbose;
 extern char *xstrdup (const char *s);	/* not: #include "sundries.h" */
 extern void error (const char *fmt, ...);	/* idem */
 
+#if !defined(LOOP_PASSWORD_MIN_LENGTH)
+# define  LOOP_PASSWORD_MIN_LENGTH   20
+#endif
+
+int	passFD_number = -1;	/* -1 = read password from terminal */
+char    *passSeedString = (char *)0;
+
 #ifdef LOOP_SET_FD
 struct crypt_type_struct {
 	int id;
 	char *name;
+	int keyBytes;
 } crypt_type_tbl[] = {
-	{ LO_CRYPT_NONE, "no" },
-	{ LO_CRYPT_NONE, "none" },
-	{ LO_CRYPT_XOR, "xor" },
-	{ LO_CRYPT_DES, "DES" },
-	{ -1, NULL   }
+	{ LO_CRYPT_NONE, "no", 0 },
+	{ LO_CRYPT_NONE, "none", 0 },
+	{ LO_CRYPT_XOR, "xor", 0 },
+	{ 3, "twofish128", 16 },
+	{ 3, "twofish192", 24 },
+	{ 3, "twofish256", 32 },
+	{ 4, "blowfish128", 16 },
+	{ 4, "blowfish192", 24 },
+	{ 4, "blowfish256", 32 },
+	{ 7, "serpent128", 16 },
+	{ 7, "serpent192", 24 },
+	{ 7, "serpent256", 32 },
+	{ 8, "mars128", 16 },
+	{ 8, "mars192", 24 },
+	{ 8, "mars256", 32 },
+	{ 11, "rc6_128", 16 },
+	{ 11, "rc6_192", 24 },
+	{ 11, "rc6_256", 32 },
+	{ 12, "tripleDES", 21 },
+	{ 16, "AES128", 16 },
+	{ 16, "AES192", 24 },
+	{ 16, "AES256", 32 },
+	{ 16, "AES", 0 },
+	{ -1, NULL, 0 }
 };
 
 static int 
-crypt_type (const char *name) {
+crypt_type (const char *name, int *kbyp) {
 	int i;
 
 	if (name) {
 		for (i = 0; crypt_type_tbl[i].id != -1; i++)
-			if (!strcasecmp (name, crypt_type_tbl[i].name))
+			if (!strcasecmp (name, crypt_type_tbl[i].name)) {
+				*kbyp = crypt_type_tbl[i].keyBytes;
 				return crypt_type_tbl[i].id;
+			}
 	}
 	return -1;
 }
 
 #ifdef MAIN
 static char *
-crypt_name (int id) {
+crypt_name (int id, int kby) {
 	int i;
 
 	for (i = 0; crypt_type_tbl[i].id != -1; i++)
-		if (id == crypt_type_tbl[i].id)
+		if((id == crypt_type_tbl[i].id) && crypt_type_tbl[i].keyBytes && (crypt_type_tbl[i].keyBytes == kby))
 			return crypt_type_tbl[i].name;
 	return "undefined";
 }
@@ -91,7 +121,7 @@ show_loop (char *device) {
 	printf (_("%s: [%04x]:%ld (%s) offset %d, %s encryption\n"),
 		device, loopinfo.lo_device, loopinfo.lo_inode,
 		loopinfo.lo_name, loopinfo.lo_offset,
-		crypt_name (loopinfo.lo_encrypt_type));
+		crypt_name (loopinfo.lo_encrypt_type, loopinfo.lo_encrypt_key_size));
 	close (fd);
 
 	return 0;
@@ -196,6 +226,93 @@ find_unused_loop_device (void) {
 	return 0;
 }
 
+/* A function to read the passphrase either from the terminal or from
+ * an open file descriptor -- copied from internat. crypto patch */
+static char *
+xgetpass(const char *prompt)
+{
+	if (passFD_number < 0) /* terminal */
+		return (getpass(prompt));
+	else {	     /* file descriptor */
+		char *pass = NULL;
+		int buflen, i;
+
+		buflen=0;
+		for (i=0; ; i++) {
+			if (i >= buflen-1) {
+				/* we're running out of space in the buffer. 
+				 * Make it bigger: */
+				char *tmppass = pass;
+				buflen += 128;
+				pass = realloc(tmppass,buflen);
+				if (pass == NULL) {
+					/* realloc failed. Stop reading _now_. */
+					error("not enough memory while reading passphrase");
+					pass = tmppass; /* the old buffer hasn't changed */
+					break;
+				}
+			}
+			if (read(passFD_number, pass+i, 1) != 1 || pass[i] == '\n' )
+				break;
+		}
+		if (pass == NULL)
+			return "";
+		else {
+			pass[i] = 0;
+			return pass;
+		}
+	}
+}
+
+static char *sgetpass(const char *prompt)
+{
+	char *p, *s;
+	int i;
+
+	p = xgetpass(prompt);
+	if(!passSeedString) return(p);
+	i = strlen(p);
+	if(i < LOOP_PASSWORD_MIN_LENGTH) return("");
+	s = malloc(i + strlen(passSeedString) + 1);
+	if(!s) return("");
+	strcpy(s, p);
+	strcat(s, passSeedString);
+	if(i > 0) memset(p, 0, i);
+	return(s);
+}
+
+static int keysetup_u(char *keyStr, unsigned char *keyBuf, int bufSize)
+{
+	register int    x, y, z;
+	char            *kp;
+
+	/*
+	 *  Preprocess the key. Uses only 6 bits of each character.
+	 */
+	for(x = 0; x < bufSize; x++) {
+		keyBuf[x] = 0;
+	}
+	kp = keyStr;
+	for(x = 0; x < (bufSize * 8); x += 6) {
+		if(!(*kp)) kp = keyStr;
+		y = *kp++;
+		if((y >= '0') && (y <= '9')) y -= '0';
+		else if((y >= 'A') && (y <= 'Z')) y -= ('A' - 10);
+		else if((y >= 'a') && (y <= 'z')) y -= ('a' - 36);
+		else if((y == '.') || (y == '/')) y += (62 - '.');
+		else return(0);   /* invalid character */
+		z = x >> 3;
+		if(z < bufSize) {
+			keyBuf[z] |= y << (x & 7);
+		}
+		z++;
+		if(z < bufSize) {
+			keyBuf[z] |= y >> (8 - (x & 7));
+		}
+	}
+	return(1);   /* ok */
+}
+
 int
 set_loop (const char *device, const char *file, int offset,
 	  const char *encryption, int *loopro) {
@@ -221,7 +338,7 @@ set_loop (const char *device, const char
 
 	memset (&loopinfo, 0, sizeof (loopinfo));
 	xstrncpy (loopinfo.lo_name, file, LO_NAME_SIZE);
-	if (encryption && (loopinfo.lo_encrypt_type = crypt_type (encryption))
+	if (encryption && (loopinfo.lo_encrypt_type = crypt_type (encryption, &loopinfo.lo_encrypt_key_size))
 	    < 0) {
 		fprintf (stderr, _("Unsupported encryption type %s\n"),
 			 encryption);
@@ -247,26 +364,44 @@ set_loop (const char *device, const char
 		loopinfo.lo_encrypt_key_size = 0;
 		break;
 	case LO_CRYPT_XOR:
-		pass = getpass (_("Password: "));
+		pass = xgetpass (_("Password: "));
 		xstrncpy (loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE);
 		loopinfo.lo_encrypt_key_size = strlen(loopinfo.lo_encrypt_key);
 		break;
-	case LO_CRYPT_DES:
-		pass = getpass (_("Password: "));
-		strncpy (loopinfo.lo_encrypt_key, pass, 8);
-		loopinfo.lo_encrypt_key[8] = 0;
-		loopinfo.lo_encrypt_key_size = 8;
-		pass = getpass (_("Init (up to 16 hex digits): "));
-		for (i = 0; i < 16 && pass[i]; i++)
-			if (isxdigit (pass[i])) {
-				loopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?
-				  (islower (pass[i]) ? toupper (pass[i]) :
-				   pass[i])-'A'+10 : pass[i]-'0') << (i&7) * 4;
-			} else {
-				fprintf (stderr, _("Non-hex digit '%c'.\n"),
-					 pass[i]);
-				return 1;
+	case 3:   /* LO_CRYPT_FISH2 */
+	case 4:   /* LO_CRYPT_BLOW */
+	case 7:   /* LO_CRYPT_SERPENT */
+	case 8:   /* LO_CRYPT_MARS */
+	case 11:  /* LO_CRYPT_RC6 */
+	case 12:  /* LO_CRYPT_DES_EDE3 */
+	case 16:  /* LO_CRYPT_AES */
+		pass = sgetpass (_("Password: "));
+		if((i = strlen(pass)) < LOOP_PASSWORD_MIN_LENGTH) {
+			fprintf(stderr, "Error: Password string must be at least %d characters.\n", LOOP_PASSWORD_MIN_LENGTH);
+			return(1);
+		}
+		switch(loopinfo.lo_encrypt_key_size) {
+		default:
+		case 16:
+			sha256_hash_buffer(pass, i, &loopinfo.lo_encrypt_key[0], sizeof(loopinfo.lo_encrypt_key));
+			break;
+		case 24:
+			sha384_hash_buffer(pass, i, &loopinfo.lo_encrypt_key[0], sizeof(loopinfo.lo_encrypt_key));
+			break;
+		case 32:
+			sha512_hash_buffer(pass, i, &loopinfo.lo_encrypt_key[0], sizeof(loopinfo.lo_encrypt_key));
+			break;
+		case 0:
+			if(!keysetup_u(pass, &loopinfo.lo_encrypt_key[0], sizeof(loopinfo.lo_encrypt_key))) {
+				fprintf(stderr, "Error: Password string can contain characters only from the set: a-zA-Z0-9./\n");
+				return(1);
 			}
+			loopinfo.lo_encrypt_key_size = 16;             /* 128 bits */
+			if(i >= 32) loopinfo.lo_encrypt_key_size = 24; /* 192 bits */
+			if(i >= 43) loopinfo.lo_encrypt_key_size = 32; /* 256 bits */
+			break;
+		}
+		memset(pass, 0, i);   /* erase original password */
 		break;
 	default:
 		fprintf (stderr,
@@ -283,6 +418,7 @@ set_loop (const char *device, const char
 		perror ("ioctl: LOOP_SET_STATUS");
 		return 1;
 	}
+	memset(loopinfo.lo_encrypt_key, 0, sizeof(loopinfo.lo_encrypt_key));
 	close (fd);
 	close (ffd);
 	if (verbose > 1)
@@ -355,7 +491,8 @@ usage(void) {
 	fprintf(stderr, _("usage:\n\
   %s loop_device                                      # give info\n\
   %s -d loop_device                                   # delete\n\
-  %s [ -e encryption ] [ -o offset ] loop_device file # setup\n"),
+  %s [ -e encryption ] [ options ] loop_device file   # setup\n\
+options:  -o offset  -p num  -S pseed\n"),
 		progname, progname, progname);
 	exit(1);
 }
@@ -401,7 +538,7 @@ main(int argc, char **argv) {
 	delete = off = 0;
 	offset = encryption = NULL;
 	progname = argv[0];
-	while ((c = getopt(argc,argv,"de:o:v")) != -1) {
+	while ((c = getopt(argc,argv,"de:o:p:S:v")) != -1) {
 		switch (c) {
 		case 'd':
 			delete = 1;
@@ -412,6 +549,12 @@ main(int argc, char **argv) {
 		case 'o':
 			offset = optarg;
 			break;
+		case 'p':               /* read passphrase from given fd */
+			sscanf(optarg, "%d", &passFD_number);
+			break;
+		case 'S':               /* optional seed for password */
+			passSeedString = optarg;
+			break;
 		case 'v':
 			verbose = 1;
 			break;
--- util-linux-2.11z/mount/losetup.8.loopAES	2000-08-11 07:11:30.000000000 -0400
+++ util-linux-2.11z/mount/losetup.8	2003-04-14 01:34:31.000000000 -0400
@@ -1,4 +1,4 @@
-.TH LOSETUP 8 "Nov 24 1993" "Linux" "MAINTENANCE COMMANDS"
+.TH LOSETUP 8 "May 23 2001" "Linux" "MAINTENANCE COMMANDS"
 .SH NAME
 losetup \- set up and control loop devices
 .SH SYNOPSIS
@@ -7,10 +7,7 @@ losetup \- set up and control loop devic
 [
 .B \-e
 .I encryption
-] [
-.B \-o
-.I offset
-]
+] [options]
 .I loop_device file
 .br
 .B losetup
@@ -36,16 +33,28 @@ use no encryption (default).
 .PD 0
 .IP \fBXOR\fP
 use a simple XOR encryption.
-.IP \fBDES\fP
-use DES encryption. DES encryption is only available if the optional
-DES package has been added to the kernel. DES encryption uses an additional
-start value that is used to protect passwords against dictionary
-attacks.
+.IP \fBAES128\fP
+use 128 bit AES encryption. Password is hashed with SHA-256.
+.IP \fBAES192\fP
+use 192 bit AES encryption. Password is hashed with SHA-384.
+.IP \fBAES256\fP
+use 256 bit AES encryption. Password is hashed with SHA-512.
+.IP \fBAES\fP
+use AES encryption. Password is fed directly to AES cipher.
+Length of the password determines encryption key length.
 .PD
 .RE
 .IP "\fB\-o \fIoffset\fP"
 the data start is moved \fIoffset\fP bytes into the specified file or
 device.
+.IP "\fB\-p \fInum\fP"
+read the passphrase from file descriptor \fInum\fP instead of the
+terminal.
+.IP "\fB\-S \fIpseed\fP"
+sets encryption password seed \fIpseed\fP which is appended to user
+supplied password before hashing. Using different seeds for different
+partitions makes dictionary attacks slower but does not prevent them
+if user supplied password is guessable.
 .SH RETURN VALUE
 .B losetup
 returns 0 on success, nonzero on failure. When
@@ -69,9 +78,8 @@ The following commands can be used as an
 .nf
 .IP
 dd if=/dev/zero of=/file bs=1k count=100
-losetup -e des /dev/loop0 /file
+losetup -e AES128 /dev/loop0 /file
 Password:
-Init (up to 16 hex digits):
 mkfs -t ext2 /dev/loop0 100
 mount -t ext2 /dev/loop0 /mnt
  ...
@@ -86,9 +94,9 @@ the command
 .LP
 .fi
 .SH RESTRICTION
-DES encryption is painfully slow. On the other hand, XOR is terribly weak.
+XOR encryption is terribly weak.
 .SH AUTHORS
 .nf
 Original version: Theodore Ts'o <tytso@athena.mit.edu>
-Original DES by: Eric Young <eay@psych.psy.uq.oz.au>
+AES support: Jari Ruusu <jari.ruusu@pp.inet.fi>
 .fi
--- util-linux-2.11z/mount/mount.8.loopAES	2003-01-21 08:45:54.000000000 -0500
+++ util-linux-2.11z/mount/mount.8	2003-04-14 01:34:31.000000000 -0400
@@ -39,7 +39,7 @@
 .\" 010725, Nikita Danilov <NikitaDanilov@Yahoo.COM>: reiserfs options
 .\" 011124, Karl Eichwalder <ke@gnu.franken.de>: tmpfs options
 .\"
-.TH MOUNT 8 "14 September 1997" "Linux 2.0" "Linux Programmer's Manual"
+.TH MOUNT 8 "May 23 2001" "Linux 2.0" "Linux Programmer's Manual"
 .SH NAME
 mount \- mount a file system
 .SH SYNOPSIS
@@ -270,6 +270,12 @@ Print a help message.
 .B \-v
 Verbose mode.
 .TP
+.B \-p "\fInum\fP"
+If the mount requires a passphrase to be entered, read it from file
+descriptor
+.IR num\fP
+instead of from the terminal.
+.TP
 .B \-a
 Mount all filesystems (of the given types) mentioned in
 .IR fstab .
@@ -1684,10 +1690,14 @@ to correspond to the file
 .IR /tmp/fdimage ,
 and then mount this device on
 .IR /mnt .
-This type of mount knows about three options, namely
-.BR loop ", " offset " and " encryption ,
+This type of mount knows about four options, namely
+.BR loop ", " offset ",  " encryption " and " pseed
 that are really options to
 .BR losetup (8).
+If the mount requires a passphrase, you will be prompted for one unless you
+specify a file descriptor to read from instead with the
+.BR \-p
+option.
 If no explicit loop device is mentioned
 (but just an option `\fB\-o loop\fP' is given), then
 .B mount
--- util-linux-2.11z/mount/mount.c.loopAES	2003-04-14 01:34:31.000000000 -0400
+++ util-linux-2.11z/mount/mount.c	2003-04-14 01:35:23.000000000 -0400
@@ -195,6 +195,8 @@ static const struct opt_map opt_map[] = 
 static char *opt_loopdev, *opt_vfstype, *opt_offset, *opt_encryption,
   *opt_speed;
 
+extern char *passSeedString;
+
 static struct string_opt_map {
   char *tag;
   int skip;
@@ -202,6 +204,7 @@ static struct string_opt_map {
 } string_opt_map[] = {
   { "loop=",	0, &opt_loopdev },
   { "vfs=",	1, &opt_vfstype },
+  { "pseed=",	1, &passSeedString },
   { "offset=",	0, &opt_offset },
   { "encryption=", 0, &opt_encryption },
   { "speed=", 0, &opt_speed },
@@ -1390,7 +1393,7 @@ usage (FILE *fp, int n) {
 	  "       mount --move olddir newdir\n"
 	  "A device can be given by name, say /dev/hda1 or /dev/cdrom,\n"
 	  "or by label, using  -L label  or by uuid, using  -U uuid .\n"
-	  "Other options: [-nfFrsvw] [-o options].\n"
+	  "Other options: [-nfFrsvw] [-o options] [-p num].\n"
 	  "For many more details, say  man 8 mount .\n"
 	));
 /*
@@ -1429,7 +1432,7 @@ main (int argc, char *argv[]) {
 	initproctitle(argc, argv);
 #endif
 
-	while ((c = getopt_long (argc, argv, "afFhilL:no:O:rsU:vVwt:",
+	while ((c = getopt_long (argc, argv, "afFhilL:no:O:p:rsU:vVwt:",
 				 longopts, NULL)) != -1) {
 		switch (c) {
 		case 'a':	       /* mount everything in fstab */
@@ -1462,6 +1465,9 @@ main (int argc, char *argv[]) {
 			else
 				options = xstrdup(optarg);
 			break;
+		case 'p':               /* read passphrase from given fd */
+			{ extern int passFD_number; sscanf(optarg, "%d", &passFD_number); }
+			break;
 		case 'O':		/* with -t: mount only if (not) opt */
 			if (test_opts)
 				test_opts = xstrconcat3(test_opts, ",", optarg);
--- util-linux-2.11z/mount/sha512.c.loopAES	2003-04-14 01:34:31.000000000 -0400
+++ util-linux-2.11z/mount/sha512.c	2003-04-14 01:34:31.000000000 -0400
@@ -0,0 +1,432 @@
+/*
+ *  sha512.c
+ *
+ *  Written by Jari Ruusu, April 16 2001
+ *
+ *  Copyright 2001 by Jari Ruusu.
+ *  Redistribution of this file is permitted under the GNU Public License.
+ */
+
+#include <string.h>
+#include <sys/types.h>
+#include "sha512.h"
+
+/* Define one or more of these. If none is defined, you get all of them */
+#if !defined(SHA256_NEEDED)&&!defined(SHA512_NEEDED)&&!defined(SHA384_NEEDED)
+# define SHA256_NEEDED  1
+# define SHA512_NEEDED  1
+# define SHA384_NEEDED  1
+#endif
+
+#if defined(SHA256_NEEDED)
+static const u_int32_t sha256_hashInit[8] = {
+    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c,
+    0x1f83d9ab, 0x5be0cd19
+};
+static const u_int32_t sha256_K[64] = {
+    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
+    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
+    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
+    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
+    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
+    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+#endif
+
+#if defined(SHA512_NEEDED)
+static const u_int64_t sha512_hashInit[8] = {
+    0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL, 0x3c6ef372fe94f82bULL,
+    0xa54ff53a5f1d36f1ULL, 0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,
+    0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL
+};
+#endif
+
+#if defined(SHA384_NEEDED)
+static const u_int64_t sha384_hashInit[8] = {
+    0xcbbb9d5dc1059ed8ULL, 0x629a292a367cd507ULL, 0x9159015a3070dd17ULL,
+    0x152fecd8f70e5939ULL, 0x67332667ffc00b31ULL, 0x8eb44a8768581511ULL,
+    0xdb0c2e0d64f98fa7ULL, 0x47b5481dbefa4fa4ULL
+};
+#endif
+
+#if defined(SHA512_NEEDED) || defined(SHA384_NEEDED)
+static const u_int64_t sha512_K[80] = {
+    0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL, 0xb5c0fbcfec4d3b2fULL,
+    0xe9b5dba58189dbbcULL, 0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
+    0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL, 0xd807aa98a3030242ULL,
+    0x12835b0145706fbeULL, 0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
+    0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL, 0x9bdc06a725c71235ULL,
+    0xc19bf174cf692694ULL, 0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
+    0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL, 0x2de92c6f592b0275ULL,
+    0x4a7484aa6ea6e483ULL, 0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
+    0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL, 0xb00327c898fb213fULL,
+    0xbf597fc7beef0ee4ULL, 0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
+    0x06ca6351e003826fULL, 0x142929670a0e6e70ULL, 0x27b70a8546d22ffcULL,
+    0x2e1b21385c26c926ULL, 0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
+    0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL, 0x81c2c92e47edaee6ULL,
+    0x92722c851482353bULL, 0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
+    0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL, 0xd192e819d6ef5218ULL,
+    0xd69906245565a910ULL, 0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
+    0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL, 0x2748774cdf8eeb99ULL,
+    0x34b0bcb5e19b48a8ULL, 0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
+    0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL, 0x748f82ee5defb2fcULL,
+    0x78a5636f43172f60ULL, 0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
+    0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL, 0xbef9a3f7b2c67915ULL,
+    0xc67178f2e372532bULL, 0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
+    0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL, 0x06f067aa72176fbaULL,
+    0x0a637dc5a2c898a6ULL, 0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
+    0x28db77f523047d84ULL, 0x32caab7b40c72493ULL, 0x3c9ebe0a15c9bebcULL,
+    0x431d67c49c100d4cULL, 0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
+    0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
+};
+#endif
+
+#define Ch(x,y,z)   (((x) & (y)) ^ ((~(x)) & (z)))
+#define Maj(x,y,z)  (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
+#define R(x,y)      ((y) >> (x))
+
+#if defined(SHA256_NEEDED)
+void sha256_init(sha256_context *ctx)
+{
+    memcpy(&ctx->sha_H[0], &sha256_hashInit[0], sizeof(ctx->sha_H));
+    ctx->sha_blocks = 0;
+    ctx->sha_bufCnt = 0;
+}
+
+#define S(x,y)      (((y) >> (x)) | ((y) << (32 - (x))))
+#define uSig0(x)    ((S(2,(x))) ^ (S(13,(x))) ^ (S(22,(x))))
+#define uSig1(x)    ((S(6,(x))) ^ (S(11,(x))) ^ (S(25,(x))))
+#define lSig0(x)    ((S(7,(x))) ^ (S(18,(x))) ^ (R(3,(x))))
+#define lSig1(x)    ((S(17,(x))) ^ (S(19,(x))) ^ (R(10,(x))))
+
+static void sha256_transform(sha256_context *ctx, unsigned char *datap)
+{
+    register int    j;
+    u_int32_t       a, b, c, d, e, f, g, h;
+    u_int32_t       T1, T2, W[64], Wm2, Wm15;
+
+    /* read the data, big endian byte order */
+    j = 0;
+    do {
+        W[j] = (((u_int32_t)(datap[0]))<<24) | (((u_int32_t)(datap[1]))<<16) |
+               (((u_int32_t)(datap[2]))<<8 ) | ((u_int32_t)(datap[3]));
+        datap += 4;
+    } while(++j < 16);
+    
+    /* initialize variables a...h */
+    a = ctx->sha_H[0];
+    b = ctx->sha_H[1];
+    c = ctx->sha_H[2];
+    d = ctx->sha_H[3];
+    e = ctx->sha_H[4];
+    f = ctx->sha_H[5];
+    g = ctx->sha_H[6];
+    h = ctx->sha_H[7];
+
+    /* apply compression function */
+    j = 0;
+    do {
+        if(j >= 16) {
+            Wm2 = W[j - 2];
+            Wm15 = W[j - 15];
+            W[j] = lSig1(Wm2) + W[j - 7] + lSig0(Wm15) + W[j - 16];
+        }
+        T1 = h + uSig1(e) + Ch(e,f,g) + sha256_K[j] + W[j];
+        T2 = uSig0(a) + Maj(a,b,c);
+        h = g; g = f; f = e;
+        e = d + T1;
+        d = c; c = b; b = a;
+        a = T1 + T2;
+    } while(++j < 64);
+
+    /* compute intermediate hash value */
+    ctx->sha_H[0] += a;
+    ctx->sha_H[1] += b;
+    ctx->sha_H[2] += c;
+    ctx->sha_H[3] += d;
+    ctx->sha_H[4] += e;
+    ctx->sha_H[5] += f;
+    ctx->sha_H[6] += g;
+    ctx->sha_H[7] += h;
+
+    ctx->sha_blocks++;
+}
+
+void sha256_write(sha256_context *ctx, unsigned char *datap, int length)
+{
+    while(length > 0) {
+        if(!ctx->sha_bufCnt) {
+            while(length >= sizeof(ctx->sha_out)) {
+                sha256_transform(ctx, datap);
+                datap += sizeof(ctx->sha_out);
+                length -= sizeof(ctx->sha_out);
+            }
+            if(!length) return;
+        }
+        ctx->sha_out[ctx->sha_bufCnt] = *datap++;
+        length--;
+        if(++ctx->sha_bufCnt == sizeof(ctx->sha_out)) {
+            sha256_transform(ctx, &ctx->sha_out[0]);
+            ctx->sha_bufCnt = 0;
+        }
+    }
+}
+
+void sha256_final(sha256_context *ctx)
+{
+    register int    j;
+    u_int64_t       bitLength;
+    u_int32_t       i;
+    unsigned char   padByte, *datap;
+
+    bitLength = (ctx->sha_blocks << 9) | (ctx->sha_bufCnt << 3);
+    padByte = 0x80;
+    sha256_write(ctx, &padByte, 1);
+
+    /* pad extra space with zeroes */
+    padByte = 0;
+    while(ctx->sha_bufCnt != 56) {
+        sha256_write(ctx, &padByte, 1);
+    }
+
+    /* write bit length, big endian byte order */
+    ctx->sha_out[56] = bitLength >> 56;
+    ctx->sha_out[57] = bitLength >> 48;
+    ctx->sha_out[58] = bitLength >> 40;
+    ctx->sha_out[59] = bitLength >> 32;
+    ctx->sha_out[60] = bitLength >> 24;
+    ctx->sha_out[61] = bitLength >> 16;
+    ctx->sha_out[62] = bitLength >> 8;
+    ctx->sha_out[63] = bitLength;
+    sha256_transform(ctx, &ctx->sha_out[0]);
+    
+    /* return results in ctx->sha_out[0...31] */
+    datap = &ctx->sha_out[0];
+    j = 0;
+    do {
+        i = ctx->sha_H[j];
+        datap[0] = i >> 24;
+        datap[1] = i >> 16;
+        datap[2] = i >> 8;
+        datap[3] = i;
+        datap += 4;
+    } while(++j < 8);
+
+    /* clear sensitive information */
+    memset(&ctx->sha_out[32], 0, sizeof(sha256_context) - 32);
+}
+
+void sha256_hash_buffer(unsigned char *ib, int ile, unsigned char *ob, int ole)
+{
+    sha256_context ctx;
+
+    if(ole < 1) return;
+    memset(ob, 0, ole);
+    if(ole > 32) ole = 32;
+    sha256_init(&ctx);
+    sha256_write(&ctx, ib, ile);
+    sha256_final(&ctx);
+    memcpy(ob, &ctx.sha_out[0], ole);
+    memset(&ctx, 0, sizeof(ctx));
+}
+
+#endif
+
+#if defined(SHA512_NEEDED)
+void sha512_init(sha512_context *ctx)
+{
+    memcpy(&ctx->sha_H[0], &sha512_hashInit[0], sizeof(ctx->sha_H));
+    ctx->sha_blocks = 0;
+    ctx->sha_blocksMSB = 0;
+    ctx->sha_bufCnt = 0;
+}
+#endif
+
+#if defined(SHA512_NEEDED) || defined(SHA384_NEEDED)
+#undef S
+#undef uSig0
+#undef uSig1
+#undef lSig0
+#undef lSig1
+#define S(x,y)      (((y) >> (x)) | ((y) << (64 - (x))))
+#define uSig0(x)    ((S(28,(x))) ^ (S(34,(x))) ^ (S(39,(x))))
+#define uSig1(x)    ((S(14,(x))) ^ (S(18,(x))) ^ (S(41,(x))))
+#define lSig0(x)    ((S(1,(x))) ^ (S(8,(x))) ^ (R(7,(x))))
+#define lSig1(x)    ((S(19,(x))) ^ (S(61,(x))) ^ (R(6,(x))))
+
+static void sha512_transform(sha512_context *ctx, unsigned char *datap)
+{
+    register int    j;
+    u_int64_t       a, b, c, d, e, f, g, h;
+    u_int64_t       T1, T2, W[80], Wm2, Wm15;
+
+    /* read the data, big endian byte order */
+    j = 0;
+    do {
+        W[j] = (((u_int64_t)(datap[0]))<<56) | (((u_int64_t)(datap[1]))<<48) |
+               (((u_int64_t)(datap[2]))<<40) | (((u_int64_t)(datap[3]))<<32) |
+               (((u_int64_t)(datap[4]))<<24) | (((u_int64_t)(datap[5]))<<16) |
+               (((u_int64_t)(datap[6]))<<8 ) | ((u_int64_t)(datap[7]));
+        datap += 8;
+    } while(++j < 16);
+    
+    /* initialize variables a...h */
+    a = ctx->sha_H[0];
+    b = ctx->sha_H[1];
+    c = ctx->sha_H[2];
+    d = ctx->sha_H[3];
+    e = ctx->sha_H[4];
+    f = ctx->sha_H[5];
+    g = ctx->sha_H[6];
+    h = ctx->sha_H[7];
+
+    /* apply compression function */
+    j = 0;
+    do {
+        if(j >= 16) {
+            Wm2 = W[j - 2];
+            Wm15 = W[j - 15];
+            W[j] = lSig1(Wm2) + W[j - 7] + lSig0(Wm15) + W[j - 16];
+        }
+        T1 = h + uSig1(e) + Ch(e,f,g) + sha512_K[j] + W[j];
+        T2 = uSig0(a) + Maj(a,b,c);
+        h = g; g = f; f = e;
+        e = d + T1;
+        d = c; c = b; b = a;
+        a = T1 + T2;
+    } while(++j < 80);
+
+    /* compute intermediate hash value */
+    ctx->sha_H[0] += a;
+    ctx->sha_H[1] += b;
+    ctx->sha_H[2] += c;
+    ctx->sha_H[3] += d;
+    ctx->sha_H[4] += e;
+    ctx->sha_H[5] += f;
+    ctx->sha_H[6] += g;
+    ctx->sha_H[7] += h;
+
+    ctx->sha_blocks++;
+    if(!ctx->sha_blocks) ctx->sha_blocksMSB++;
+}
+
+void sha512_write(sha512_context *ctx, unsigned char *datap, int length)
+{
+    while(length > 0) {
+        if(!ctx->sha_bufCnt) {
+            while(length >= sizeof(ctx->sha_out)) {
+                sha512_transform(ctx, datap);
+                datap += sizeof(ctx->sha_out);
+                length -= sizeof(ctx->sha_out);
+            }
+            if(!length) return;
+        }
+        ctx->sha_out[ctx->sha_bufCnt] = *datap++;
+        length--;
+        if(++ctx->sha_bufCnt == sizeof(ctx->sha_out)) {
+            sha512_transform(ctx, &ctx->sha_out[0]);
+            ctx->sha_bufCnt = 0;
+        }
+    }
+}
+
+void sha512_final(sha512_context *ctx)
+{
+    register int    j;
+    u_int64_t       bitLength, bitLengthMSB;
+    u_int64_t       i;
+    unsigned char   padByte, *datap;
+
+    bitLength = (ctx->sha_blocks << 10) | (ctx->sha_bufCnt << 3);
+    bitLengthMSB = (ctx->sha_blocksMSB << 10) | (ctx->sha_blocks >> 54);
+    padByte = 0x80;
+    sha512_write(ctx, &padByte, 1);
+
+    /* pad extra space with zeroes */
+    padByte = 0;
+    while(ctx->sha_bufCnt != 112) {
+        sha512_write(ctx, &padByte, 1);
+    }
+
+    /* write bit length, big endian byte order */
+    ctx->sha_out[112] = bitLengthMSB >> 56;
+    ctx->sha_out[113] = bitLengthMSB >> 48;
+    ctx->sha_out[114] = bitLengthMSB >> 40;
+    ctx->sha_out[115] = bitLengthMSB >> 32;
+    ctx->sha_out[116] = bitLengthMSB >> 24;
+    ctx->sha_out[117] = bitLengthMSB >> 16;
+    ctx->sha_out[118] = bitLengthMSB >> 8;
+    ctx->sha_out[119] = bitLengthMSB;
+    ctx->sha_out[120] = bitLength >> 56;
+    ctx->sha_out[121] = bitLength >> 48;
+    ctx->sha_out[122] = bitLength >> 40;
+    ctx->sha_out[123] = bitLength >> 32;
+    ctx->sha_out[124] = bitLength >> 24;
+    ctx->sha_out[125] = bitLength >> 16;
+    ctx->sha_out[126] = bitLength >> 8;
+    ctx->sha_out[127] = bitLength;
+    sha512_transform(ctx, &ctx->sha_out[0]);
+    
+    /* return results in ctx->sha_out[0...63] */
+    datap = &ctx->sha_out[0];
+    j = 0;
+    do {
+        i = ctx->sha_H[j];
+        datap[0] = i >> 56;
+        datap[1] = i >> 48;
+        datap[2] = i >> 40;
+        datap[3] = i >> 32;
+        datap[4] = i >> 24;
+        datap[5] = i >> 16;
+        datap[6] = i >> 8;
+        datap[7] = i;
+        datap += 8;
+    } while(++j < 8);
+
+    /* clear sensitive information */
+    memset(&ctx->sha_out[64], 0, sizeof(sha512_context) - 64);
+}
+
+void sha512_hash_buffer(unsigned char *ib, int ile, unsigned char *ob, int ole)
+{
+    sha512_context ctx;
+
+    if(ole < 1) return;
+    memset(ob, 0, ole);
+    if(ole > 64) ole = 64;
+    sha512_init(&ctx);
+    sha512_write(&ctx, ib, ile);
+    sha512_final(&ctx);
+    memcpy(ob, &ctx.sha_out[0], ole);
+    memset(&ctx, 0, sizeof(ctx));
+}
+#endif
+
+#if defined(SHA384_NEEDED)
+void sha384_init(sha512_context *ctx)
+{
+    memcpy(&ctx->sha_H[0], &sha384_hashInit[0], sizeof(ctx->sha_H));
+    ctx->sha_blocks = 0;
+    ctx->sha_blocksMSB = 0;
+    ctx->sha_bufCnt = 0;
+}
+
+void sha384_hash_buffer(unsigned char *ib, int ile, unsigned char *ob, int ole)
+{
+    sha512_context ctx;
+
+    if(ole < 1) return;
+    memset(ob, 0, ole);
+    if(ole > 48) ole = 48;
+    sha384_init(&ctx);
+    sha512_write(&ctx, ib, ile);
+    sha512_final(&ctx);
+    memcpy(ob, &ctx.sha_out[0], ole);
+    memset(&ctx, 0, sizeof(ctx));
+}
+#endif
--- util-linux-2.11z/mount/sha512.h.loopAES	2003-04-14 01:34:31.000000000 -0400
+++ util-linux-2.11z/mount/sha512.h	2003-04-14 01:34:31.000000000 -0400
@@ -0,0 +1,45 @@
+/*
+ *  sha512.h
+ *
+ *  Written by Jari Ruusu, April 16 2001
+ *
+ *  Copyright 2001 by Jari Ruusu.
+ *  Redistribution of this file is permitted under the GNU Public License.
+ */
+
+#include <sys/types.h>
+
+typedef struct {
+    unsigned char   sha_out[64];    /* results are here, bytes 0...31 */
+    u_int32_t       sha_H[8];
+    u_int64_t       sha_blocks;
+    int             sha_bufCnt;
+} sha256_context;
+
+typedef struct {
+    unsigned char   sha_out[128];   /* results are here, bytes 0...63 */
+    u_int64_t       sha_H[8];
+    u_int64_t       sha_blocks;
+    u_int64_t       sha_blocksMSB;
+    int             sha_bufCnt;
+} sha512_context;
+
+/* no sha384_context, use sha512_context */
+
+/* 256 bit hash, provides 128 bits of security against collision attacks */
+extern void sha256_init(sha256_context *);
+extern void sha256_write(sha256_context *, unsigned char *, int);
+extern void sha256_final(sha256_context *);
+extern void sha256_hash_buffer(unsigned char *, int, unsigned char *, int);
+
+/* 512 bit hash, provides 256 bits of security against collision attacks */
+extern void sha512_init(sha512_context *);
+extern void sha512_write(sha512_context *, unsigned char *, int);
+extern void sha512_final(sha512_context *);
+extern void sha512_hash_buffer(unsigned char *, int, unsigned char *, int);
+
+/* 384 bit hash, provides 192 bits of security against collision attacks */
+extern void sha384_init(sha512_context *);
+/* no sha384_write(), use sha512_write() */
+/* no sha384_final(), use sha512_final(), result in ctx->sha_out[0...47]  */
+extern void sha384_hash_buffer(unsigned char *, int, unsigned char *, int);
