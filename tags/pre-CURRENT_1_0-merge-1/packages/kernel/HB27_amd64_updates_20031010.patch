--- linux-2.4.22/include/asm-x86_64/acpi.h.amd64-updates	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/acpi.h	2003-10-10 11:17:46.000000000 +0200
@@ -115,7 +115,22 @@ extern int acpi_lapic;
 #endif
 #ifdef CONFIG_X86_IO_APIC
 extern int acpi_ioapic;
+extern int skip_ioapic_setup;
+
+static inline void disable_ioapic_setup(void)
+{
+	
+	skip_ioapic_setup = 1;
+}
+
+static inline int ioapic_setup_disabled(void)
+{
+	return skip_ioapic_setup;
+}
 #else
+static inline void disable_ioapic_setup(void)
+{ }
+
 #define acpi_ioapic 0
 #endif
 
@@ -142,6 +157,8 @@ extern void acpi_reserve_bootmem(void);
 
 extern void mp_config_ioapic_for_sci(int irq);
 
+extern int use_acpi_pci;
+
 #endif /*__KERNEL__*/
 
 #endif /*_ASM_ACPI_H*/
--- linux-2.4.22/include/asm-x86_64/calling.h.amd64-updates	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/asm-x86_64/calling.h	2003-10-10 11:17:46.000000000 +0200
@@ -8,7 +8,7 @@
 #define R14 8
 #define R13 16
 #define R12 24
-#define RBP 36
+#define RBP 32
 #define RBX 40
 /* arguments: interrupts/non tracing syscalls only save upto here*/
 #define R11 48
--- linux-2.4.22/include/asm-x86_64/cpufeature.h.amd64-updates	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/asm-x86_64/cpufeature.h	2003-10-10 11:17:46.000000000 +0200
@@ -63,6 +63,26 @@
 #define X86_FEATURE_CYRIX_ARR	(3*32+ 2) /* Cyrix ARRs (= MTRRs) */
 #define X86_FEATURE_CENTAUR_MCR	(3*32+ 3) /* Centaur MCRs (= MTRRs) */
 
+#define cpu_has(c, bit)                test_bit(bit, (c)->x86_capability)
+#define boot_cpu_has(bit)      test_bit(bit, boot_cpu_data.x86_capability)
+
+#define cpu_has_pge 1
+#define cpu_has_pse 1
+#define cpu_has_pae 1
+#define cpu_has_tsc 1
+#define cpu_has_de 1
+#define cpu_has_vme 1
+#define cpu_has_fxsr 1
+#define cpu_has_xmm 1
+#define cpu_has_apic 		boot_cpu_has(X86_FEATURE_APIC)
+#define cpu_has_ht 0 
+#define cpu_has_mp             boot_cpu_has(X86_FEATURE_MP)
+#define cpu_has_k6_mtrr 0
+#define cpu_has_cyrix_arr 0
+#define cpu_has_centaur_mcr 0
+#define cpu_has_mmx 0
+#define cpu_has_fpu 1
+
 #endif /* __ASM_X8664_CPUFEATURE_H */
 
 /* 
--- linux-2.4.22/include/asm-x86_64/hardirq.h.amd64-updates	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/asm-x86_64/hardirq.h	2003-10-10 11:17:46.000000000 +0200
@@ -67,6 +67,8 @@ static inline void irq_enter(int cpu, in
 {
 	++local_irq_count(cpu);
 
+	smp_mb();
+	
 	while (test_bit(0,&global_irq_lock)) {
 		cpu_relax();
 	}
--- linux-2.4.22/include/asm-x86_64/ia32.h.amd64-updates	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/ia32.h	2003-10-10 11:17:46.000000000 +0200
@@ -234,6 +234,11 @@ struct iovec32 { 
 	int iov_len; 
 };
 
+struct timespec32 {
+	int 	tv_sec;
+	int	tv_nsec;
+};
+
 #endif /* !CONFIG_IA32_SUPPORT */
  
 #endif 
--- linux-2.4.22/include/asm-x86_64/kdebug.h.amd64-updates	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/kdebug.h	2003-10-10 11:17:52.000000000 +0200
@@ -39,11 +39,13 @@ static inline int notify_die(enum die_va
 	return notifier_call_chain(&die_chain, val, &args); 
 } 
 
-
 extern int printk_address(unsigned long address);
 extern void die(const char *,struct pt_regs *,long);
+extern void __die(const char *,struct pt_regs *,long);
 extern void show_stack(unsigned long* esp);
 extern void show_registers(struct pt_regs *regs);
 extern void dump_pagetable(unsigned long);
+extern void prepare_die(unsigned long *flags);
+extern void exit_die(unsigned long flags);
 
 #endif
--- linux-2.4.22/include/asm-x86_64/msr.h.amd64-updates	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/asm-x86_64/msr.h	2003-10-10 11:17:53.000000000 +0200
@@ -173,6 +173,9 @@
 
 /* VIA Cyrix defined MSRs*/
 #define MSR_VIA_FCR			0x1107
+#define MSR_VIA_LONGHAUL		0x110a
+#define MSR_VIA_RNG			0x110b
+#define MSR_VIA_BCR2			0x1147
 
 /* Intel defined MSRs. */
 #define MSR_IA32_P5_MC_ADDR		0
--- linux-2.4.22/include/asm-x86_64/pgalloc.h.amd64-updates	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/asm-x86_64/pgalloc.h	2003-10-10 11:17:53.000000000 +0200
@@ -204,7 +204,7 @@ struct tlb_state
 {
 	struct mm_struct *active_mm;
 	int state;
-};
+} ____cacheline_aligned;
 extern struct tlb_state cpu_tlbstate[NR_CPUS];
 
 
--- linux-2.4.22/include/asm-x86_64/pgtable.h.amd64-updates	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/pgtable.h	2003-10-10 11:17:53.000000000 +0200
@@ -254,7 +254,7 @@ extern inline void pgd_clear (pgd_t * pg
 	(_PAGE_PRESENT | _PAGE_USER | _PAGE_DIRTY | _PAGE_ACCESSED) 
 
 extern unsigned long __supported_pte_mask; 
-#define __PTE_SUPP(x) __pgprot((x) & __supported_pte_mask)
+#define __PTE_SUPP(x) __pgprot((x)  & __supported_pte_mask)
 
 /* _NX is masked away in mk_pmd/pte */
 
--- linux-2.4.22/include/asm-x86_64/processor.h.amd64-updates	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/processor.h	2003-10-10 11:17:53.000000000 +0200
@@ -17,6 +17,7 @@
 #include <asm/msr.h>
 #include <asm/current.h>
 #include <asm/system.h>
+#include <asm/cpufeature.h>
 
 #define TF_MASK		0x00000100
 #define IF_MASK		0x00000200
@@ -77,16 +78,6 @@ extern struct cpuinfo_x86 cpu_data[];
 #define current_cpu_data boot_cpu_data
 #endif
 
-#define cpu_has_pge 1
-#define cpu_has_pse 1
-#define cpu_has_pae 1
-#define cpu_has_tsc 1
-#define cpu_has_de 1
-#define cpu_has_vme 1
-#define cpu_has_fxsr 1
-#define cpu_has_xmm 1
-#define cpu_has_apic (test_bit(X86_FEATURE_APIC, boot_cpu_data.x86_capability))
-
 extern char ignore_irq13;
 
 extern void identify_cpu(struct cpuinfo_x86 *);
@@ -258,7 +249,9 @@ static inline void clear_in_cr4 (unsigne
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_32 0xa0000000
+
+#define IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
+#define TASK_UNMAPPED_32 (IA32_PAGE_OFFSET / 3) 
 #define TASK_UNMAPPED_64 (TASK_SIZE/3) 
 #define TASK_UNMAPPED_BASE	\
 	((current->thread.flags & THREAD_IA32) ? TASK_UNMAPPED_32 : TASK_UNMAPPED_64)  
@@ -396,7 +389,7 @@ extern unsigned long get_wchan(struct ta
 /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
 extern inline void rep_nop(void)
 {
-	__asm__ __volatile__("rep;nop");
+	__asm__ __volatile__("rep;nop":::"memory");
 }
 
 /* Avoid speculative execution by the CPU */
@@ -406,8 +399,6 @@ extern inline void sync_core(void)
 	asm volatile("cpuid" : "=a" (tmp) : "0" (1) : "ebx","ecx","edx","memory");
 } 
 
-#define cpu_has_fpu 1
-
 #define ARCH_HAS_PREFETCH
 #define ARCH_HAS_PREFETCHW
 #define ARCH_HAS_SPINLOCK_PREFETCH
--- linux-2.4.22/include/asm-x86_64/proto.h.amd64-updates	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/proto.h	2003-10-10 11:17:53.000000000 +0200
@@ -43,6 +43,8 @@ extern void show_trace(unsigned long *st
 extern void __show_regs(struct pt_regs * regs);
 extern void show_regs(struct pt_regs * regs);
 
+extern int apic_disabled;
+extern int acpi_disabled;
 
 #define round_up(x,y) (((x) + (y) - 1) & ~((y)-1))
 #define round_down(x,y) ((x) & ~((y)-1))
--- linux-2.4.22/include/asm-x86_64/ptrace.h.amd64-updates	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.22/include/asm-x86_64/ptrace.h	2003-10-10 11:17:53.000000000 +0200
@@ -6,7 +6,7 @@
 #define R14 8
 #define R13 16
 #define R12 24
-#define RBP 36
+#define RBP 32
 #define RBX 40
 /* arguments: interrupts/non tracing syscalls only save upto here*/
 #define R11 48
@@ -37,10 +37,6 @@
 /* options set using PTRACE_SETOPTIONS */
 #define PTRACE_O_TRACESYSGOOD     0x00000001
 
-/* Dummy values for ptrace */ 
-#define FS 1000 
-#define GS 1008
-
 #ifndef __ASSEMBLY__ 
 
 struct pt_regs {
--- linux-2.4.22/include/asm-x86_64/softirq.h.amd64-updates	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/softirq.h	2003-10-10 11:17:53.000000000 +0200
@@ -33,9 +33,9 @@ do {									\
 			"jnz 2f;"					\
 			"1:;"						\
 			LOCK_SECTION_START("") 		\
-			"2:"	\
+			"2:"						\
 			"call do_softirq_thunk;"		\
-			""		\
+			""							\
 			"jmp 1b;"					\
 			LOCK_SECTION_END			\
 		: /* no output */					\
--- linux-2.4.22/include/asm-x86_64/system.h.amd64-updates	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/system.h	2003-10-10 11:17:53.000000000 +0200
@@ -284,8 +284,8 @@ extern void __global_restore_flags(unsig
 #define sti() __global_sti()
 #define save_flags(x) ((x)=__global_save_flags())
 #define restore_flags(x) __global_restore_flags(x)
-#define save_and_cli(x) do { save_flags(x); cli(); } while(0);
-#define save_and_sti(x) do { save_flags(x); sti(); } while(0);
+#define save_and_cli(x) do { save_flags(x); cli(); } while(0)
+#define save_and_sti(x) do { save_flags(x); sti(); } while(0)
 
 #else
 
--- linux-2.4.22/include/asm-x86_64/uaccess.h.amd64-updates	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/uaccess.h	2003-10-10 11:17:53.000000000 +0200
@@ -173,18 +173,18 @@ struct __large_struct { unsigned long bu
  * aliasing issues.
  */
 #define __put_user_asm(x, addr, err, itype, rtype, ltype, errno)	\
-	__asm__ __volatile__(				\
-		"1:	mov"itype" %"rtype"1,%2\n"	\
-		"2:\n"							\
-		".section .fixup,\"ax\"\n"		\
+	__asm__ __volatile__(					\
+		"1:	mov"itype" %"rtype"1,%2\n"		\
+		"2:\n"						\
+		".section .fixup,\"ax\"\n"			\
 		"3:	mov %3,%0\n"				\
-		"	jmp 2b\n"					\
+		"	jmp 2b\n"				\
 		".previous\n"					\
-		".section __ex_table,\"a\"\n"	\
-		"	.align 8\n"					\
+		".section __ex_table,\"a\"\n"			\
+		"	.align 8\n"				\
 		"	.quad 1b,3b\n"				\
-		".previous"						\
-		: "=r"(err)						\
+		".previous"					\
+		: "=r"(err)					\
 		: ltype (x), "m"(__m(addr)), "i"(errno), "0"(err))
 
 
@@ -254,12 +254,12 @@ static inline int __copy_from_user(void 
 	case 10:
 	       	__get_user_asm(*(u64*)dst,(u64*)src,ret,"q","","=r",16);
 		if (ret) return ret;
-		__get_user_asm(*(u16*)(8+dst),(u16*)(8+src),ret,"w","w","=r",2);
+		__get_user_asm(*(u16*)(8+(char*)dst),(u16*)(8+(char*)src),ret,"w","w","=r",2);
 		return ret; 
 	case 16:
 		__get_user_asm(*(u64*)dst,(u64*)src,ret,"q","","=r",16);
 		if (ret) return ret;
-		__get_user_asm(*(u64*)(8+dst),(u64*)(8+src),ret,"q","","=r",8);
+		__get_user_asm(*(u64*)(8+(char*)dst),(u64*)(8+(char*)src),ret,"q","","=r",8);
 		return ret; 
 	default:
 		return copy_user_generic(dst,src,size); 
--- linux-2.4.22/include/asm-x86_64/unistd.h.amd64-updates	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/unistd.h	2003-10-10 11:17:53.000000000 +0200
@@ -462,7 +462,7 @@ __SYSCALL(__NR_fremovexattr, sys_ni_sysc
 #define __NR_tkill	200	/* 2.5 only */
 __SYSCALL(__NR_tkill, sys_ni_syscall) 
 #define __NR_time		201
-__SYSCALL(__NR_time, sys_time)
+__SYSCALL(__NR_time, sys_time64)
 #define __NR_futex		202 /* 2.5 only */
 __SYSCALL(__NR_futex, sys_ni_syscall)
 #define __NR_sched_setaffinity    203
@@ -495,8 +495,12 @@ __SYSCALL(__NR_epoll_wait, sys_ni_syscal
 __SYSCALL(__NR_remap_file_pages, sys_ni_syscall)
 #define __NR_getdents64 217
 __SYSCALL(__NR_getdents64, sys_getdents64)
+#define __NR_restart_syscall	219
+__SYSCALL(__NR_restart_syscall, sys_ni_syscall)
+#define __NR_semtimedop		220
+__SYSCALL(__NR_semtimedop, sys_semtimedop)
 
-#define __NR_syscall_max __NR_getdents64
+#define __NR_syscall_max __NR_semtimedop
 
 #ifndef __NO_STUBS
 
--- linux-2.4.22/include/asm-x86_64/xor.h.amd64-updates	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/asm-x86_64/xor.h	2003-10-10 11:17:53.000000000 +0200
@@ -547,7 +547,7 @@ static struct xor_block_template xor_blo
 #undef XOR_TRY_TEMPLATES
 #define XOR_TRY_TEMPLATES				\
 	do {						\
-		xor_speed(&xor_block_sse);	\
+		xor_speed(&xor_block_sse); 		\
 		xor_speed(&xor_block_64regs_stream);	\
 	} while (0)
 
--- linux-2.4.22/arch/x86_64/mm/fault.c.amd64-updates	2003-10-10 10:32:23.000000000 +0200
+++ linux-2.4.22/arch/x86_64/mm/fault.c	2003-10-10 11:17:45.000000000 +0200
@@ -92,6 +92,85 @@ ret:
 	return;
 bad:
 	printk("BAD\n");
+}		
+
+/* Sometimes the CPU reports invalid exceptions on prefetch.
+   Check that here and ignore.
+   Opcode checker based on code by Richard Brunner */
+static int is_prefetch(struct pt_regs *regs, unsigned long addr)
+{ 
+	unsigned char *instr = (unsigned char *)(regs->rip);
+	int scan_more = 1;
+	int prefetch = 0; 
+	unsigned char *max_instr = instr + 15;
+
+	/* Avoid recursive faults for this common case */
+	if (regs->rip == addr)
+		return 0; 
+
+	if (regs->cs & (1<<2))
+		return 0;
+
+	while (scan_more && instr < max_instr) { 
+		unsigned char opcode;
+		unsigned char instr_hi;
+		unsigned char instr_lo;
+
+		if (__get_user(opcode, instr))
+			break; 
+
+		instr_hi = opcode & 0xf0; 
+		instr_lo = opcode & 0x0f; 
+		instr++;
+
+		switch (instr_hi) { 
+		case 0x20:
+		case 0x30:
+			/* Values 0x26,0x2E,0x36,0x3E are valid x86
+			   prefixes.  In long mode, the CPU will signal
+			   invalid opcode if some of these prefixes are
+			   present so we will never get here anyway */
+			scan_more = ((instr_lo & 7) == 0x6);
+			break;
+			
+		case 0x40:
+			/* In AMD64 long mode, 0x40 to 0x4F are valid REX prefixes
+			   Need to figure out under what instruction mode the
+			   instruction was issued ... */
+			/* Could check the LDT for lm, but for now it's good
+			   enough to assume that long mode only uses well known
+			   segments or kernel. */
+			scan_more = ((regs->cs & 3) == 0) || (regs->cs == __USER_CS);
+			break;
+			
+		case 0x60:
+			/* 0x64 thru 0x67 are valid prefixes in all modes. */
+			scan_more = (instr_lo & 0xC) == 0x4;
+			break;		
+		case 0xF0:
+			/* 0xF0, 0xF2, and 0xF3 are valid prefixes in all modes. */
+			scan_more = !instr_lo || (instr_lo>>1) == 1;
+			break;			
+		case 0x00:
+			/* Prefetch instruction is 0x0F0D or 0x0F18 */
+			scan_more = 0;
+			if (__get_user(opcode, instr)) 
+				break;
+			prefetch = (instr_lo == 0xF) &&
+				(opcode == 0x0D || opcode == 0x18);
+			break;			
+		default:
+			scan_more = 0;
+			break;
+		} 
+	}
+
+#if 0
+	if (prefetch)
+		printk("%s: prefetch caused page fault at %lx/%lx\n", current->comm,
+		       regs->rip, addr);
+#endif
+	return prefetch;
 }
 
 int page_fault_trace; 
@@ -134,7 +213,7 @@ asmlinkage void do_page_fault(struct pt_
 		unsigned long gs; 
 		struct x8664_pda *pda = cpu_pda + safe_smp_processor_id(); 
 		rdmsrl(MSR_GS_BASE, gs); 
-		if (gs != (unsigned long)pda) { 
+		if (gs != (unsigned long)pda) {
 			wrmsrl(MSR_GS_BASE, pda); 
 			printk("page_fault: wrong gs %lx expected %p\n", gs, pda);
 		}
@@ -156,7 +235,7 @@ asmlinkage void do_page_fault(struct pt_
 	 * context, we must not take the fault..
 	 */
 	if (in_interrupt() || !mm)
-		goto no_context;
+		goto bad_area_nosemaphore;
 
 again:
 	down_read(&mm->mmap_sem);
@@ -227,9 +306,11 @@ bad_area:
 	up_read(&mm->mmap_sem);
 
 bad_area_nosemaphore:
-
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & 4) {
+		if (is_prefetch(regs, address))
+			return;
+
 		if (exception_trace && !(tsk->ptrace & PT_PTRACED) && 
 		    (tsk->sig->action[SIGSEGV-1].sa.sa_handler == SIG_IGN ||
 		    (tsk->sig->action[SIGSEGV-1].sa.sa_handler == SIG_DFL)))
@@ -261,40 +342,27 @@ no_context:
 		return;
 	}
 
+	if (is_prefetch(regs, address))
+		return;
+
 /*
  * Oops. The kernel tried to access some bad page. We'll have to
  * terminate things with extreme prejudice.
  */
 
-	console_verbose();
-	bust_spinlocks(1); 
-
-	int cpu = safe_smp_processor_id(); 
-	unsigned long flags; 
-	extern int die_owner; 
-	extern spinlock_t die_lock;
-	
-	__save_flags(flags); 
-	__cli(); 
-	if (!spin_trylock(&die_lock)) { 
-		if (cpu == die_owner) 
-			/* nested oops. should stop eventually */;
-		else
-			spin_lock(&die_lock); 
-	}
-	die_owner = cpu; 
-
+	unsigned long flags;
+	prepare_die(&flags);
 	if (address < PAGE_SIZE)
 		printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference");
 	else
 		printk(KERN_ALERT "Unable to handle kernel paging request");
-	printk(" at virtual address %016lx\n",address);
-	printk(" printing rip:\n");
-	printk("%016lx\n", regs->rip);
+	printk(KERN_ALERT " at %016lx RIP: ", address); 
+	printk_address(regs->rip);
 	dump_pagetable(address);
-	die("Oops", regs, error_code);
-	bust_spinlocks(0); 
-	spin_unlock_irqrestore(&die_lock, flags);
+	__die("Oops", regs, error_code);
+	/* Executive summary in case the oops scrolled away */
+	printk(KERN_EMERG "CR2: %016lx\n", address);
+	exit_die(flags);
 	do_exit(SIGKILL);
 
 /*
@@ -316,10 +384,13 @@ out_of_memory:
 do_sigbus:
 	up_read(&mm->mmap_sem);
 
-	/*
-	 * Send a sigbus, regardless of whether we were in kernel
-	 * or user mode.
-	 */
+	/* Kernel mode? Handle exceptions or die */
+	if (!(error_code & 4))
+		goto no_context;
+		
+	if (is_prefetch(regs, address))
+		return;
+
 	tsk->thread.cr2 = address;
 	tsk->thread.error_code = error_code;
 	tsk->thread.trap_no = 14;
@@ -328,10 +399,6 @@ do_sigbus:
 	info.si_code = BUS_ADRERR;
 	info.si_addr = (void *)address;
 	force_sig_info(SIGBUS, &info, tsk);
-
-	/* Kernel mode? Handle exceptions or die */
-	if (!(error_code & 4))
-		goto no_context;
 	return;
 
 
--- linux-2.4.22/arch/x86_64/mm/init.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/mm/init.c	2003-10-10 11:17:45.000000000 +0200
@@ -290,7 +290,7 @@ void __init init_memory_mapping(void) 
 	table_end = table_start;
        
 	end += __PAGE_OFFSET; /* turn virtual */  
-
+	
 	for (adr = PAGE_OFFSET; adr < end; adr = next) { 
 		int map;
 		unsigned long pgd_phys; 
@@ -423,7 +423,7 @@ void __init mem_init(void)
    must be aligned to 2MB boundaries. 
    Does nothing when the mapping doesn't exist. */
 void __init clear_kernel_mapping(unsigned long address, unsigned long size) 
-{ 
+{
 	unsigned long end = address + size;
 
 	BUG_ON(address & ~LARGE_PAGE_MASK);
@@ -441,10 +441,10 @@ void __init clear_kernel_mapping(unsigne
 			printk(KERN_ERR 
 		"clear_kernel_mapping: mapping has been split. will leak memory\n"); 
 			pmd_ERROR(*pmd); 
-		} 
+		}
 		set_pmd(pmd, __pmd(0)); 		
-	} 
-	__flush_tlb_all(); 
+	}
+	__flush_tlb_all();
 } 
 
 void free_initmem(void)
--- linux-2.4.22/arch/x86_64/mm/ioremap.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/mm/ioremap.c	2003-10-10 11:17:46.000000000 +0200
@@ -125,12 +125,12 @@ void * __ioremap(unsigned long phys_addr
 	 */
 	if (phys_addr < virt_to_phys(high_memory)) {
 		char *t_addr, *t_end;
-		struct page *page;
 
 		t_addr = __va(phys_addr);
 		t_end = t_addr + (size - 1);
-	   
+	
 #ifndef CONFIG_DISCONTIGMEM
+		struct page *page;
 		for(page = virt_to_page(t_addr); page <= virt_to_page(t_end); page++)
 			if(!PageReserved(page))
 				return NULL;
--- linux-2.4.22/arch/x86_64/mm/k8topology.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/mm/k8topology.c	2003-10-10 11:17:46.000000000 +0200
@@ -6,7 +6,7 @@
  * Instead the northbridge registers are read directly. 
  * 
  * Copyright 2002 Andi Kleen, SuSE Labs.
- * $Id: k8topology.c,v 1.7 2003/04/02 21:36:22 ak Exp $
+ * $Id: k8topology.c,v 1.11 2003/09/12 01:55:37 ak Exp $
  */
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -20,6 +20,8 @@
 #include <asm/e820.h>
 #include <asm/pci-direct.h>
 
+#define Dprintk(x...)
+
 int memnode_shift;
 u8  memnodemap[NODEMAPSIZE];
 
@@ -110,6 +112,9 @@ int __init k8_scan_nodes(unsigned long s
 		limit = read_pci_config(0, nb, 1, 0x44 + i*8);
 
 		nodeid = limit & 3; 
+		if ((base & 3) == 0) { 
+			continue;
+		} 
 		if (!limit) { 
 			printk(KERN_INFO "Skipping node entry %d (base %lx)\n", i,			       base);
 			continue;
@@ -145,7 +150,7 @@ int __init k8_scan_nodes(unsigned long s
 		if (limit == base) 
 			continue; 
 		if (limit < base) { 
-			printk(KERN_INFO"Node %d bogus settings %lx-%lx. Ignored.\n",
+			Dprintk(KERN_INFO"Node %d bogus settings %lx-%lx. Ignored.\n",
 			       nodeid, base, limit); 			       
 			continue; 
 		} 
@@ -178,7 +183,7 @@ int __init k8_scan_nodes(unsigned long s
 
 	for (i = 0; i < MAXNODE; i++) { 
 		if (nodes[i].start != nodes[i].end)
-		setup_node_bootmem(i, nodes[i].start, nodes[i].end); 
+			setup_node_bootmem(i, nodes[i].start, nodes[i].end); 
 	} 
 
 	/* There are unfortunately some poorly designed mainboards around
--- linux-2.4.22/arch/x86_64/mm/modutil.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/mm/modutil.c	2003-10-10 11:17:46.000000000 +0200
@@ -58,7 +58,7 @@ void * module_map (unsigned long size)
 
 	size = PAGE_ALIGN(size);
 	if (!size || size > MODULES_LEN) return NULL;
-		
+	
 	area = (struct vm_struct *) kmalloc(sizeof(*area), GFP_KERNEL);
 	if (!area) return NULL; 
 
@@ -80,7 +80,7 @@ void * module_map (unsigned long size)
 		write_unlock(&vmlist_lock); 
 		kfree(area);
 		return NULL;
-	}
+	} 
 	
 	area->size = size;
 	area->addr = addr;
--- linux-2.4.22/arch/x86_64/lib/copy_page.S.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/lib/copy_page.S	2003-10-10 11:17:45.000000000 +0200
@@ -1,8 +1,8 @@
 /* Written 2003 by Andi Kleen, based on a kernel by Evandro Menezes */
-	
+
 /* Don't use streaming store because it's better when the target
    ends up in cache. */
-	    
+
 /* Could vary the prefetch distance based on SMP/UP */
 
 	.globl copy_page
@@ -10,14 +10,8 @@
 copy_page:
 	prefetch (%rsi) 
 	prefetch 1*64(%rsi)
-	prefetch 2*64(%rsi)
-	prefetch 3*64(%rsi)
-	prefetch 4*64(%rsi)
 	prefetchw (%rdi) 
 	prefetchw 1*64(%rdi) 
-	prefetchw 2*64(%rdi) 
-	prefetchw 3*64(%rdi)
-	prefetchw 4*64(%rdi)
 
 	subq	$3*8,%rsp
 	movq	%rbx,(%rsp)
@@ -59,7 +53,7 @@ copy_page:
 	movl	$5,%ecx
 	.p2align 4
 .Loop2:	
-	decl   %ecx
+	decl	%ecx
 
 	movq        (%rsi), %rax
 	movq      8 (%rsi), %rbx
--- linux-2.4.22/arch/x86_64/lib/copy_user.S.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/lib/copy_user.S	2003-10-10 11:17:45.000000000 +0200
@@ -4,7 +4,7 @@
  * Functions to copy from and to user space.		
  */		 
 
-#define FIX_ALIGNMENT 1
+/* #define FIX_ALIGNMENT 1 */
 
 	#include <asm/current.h>
 	#include <asm/offset.h>
@@ -59,9 +59,8 @@ bad_to_user:
 	.globl copy_user_generic	
 	.p2align 4
 copy_user_generic:	
-	/* Put the first cacheline into cache. This should handle
-	   the small movements in ioctls etc., but not penalize the bigger
-	   filesystem data copies too much. */
+	prefetch (%rsi)
+	prefetchw (%rdi)
 	pushq %rbx
 	xorl %eax,%eax		/*zero for the exception handler */
 
--- linux-2.4.22/arch/x86_64/lib/csum-copy.S.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/lib/csum-copy.S	2003-10-10 11:17:45.000000000 +0200
@@ -24,7 +24,7 @@
  * Output
  * eax  64bit sum. undefined in case of exception.
  * 
- * Wrappers need to take care of valid exception sum and zeroing.		 
+ * Wrappers need to take care of valid exception sum and zeroing.	
  * They also should align source or destination to 8 bytes.
  */
 
@@ -43,7 +43,7 @@
 	.quad 20b,.Lbad_dest
 	.previous
 	.endm
-			
+
 	.macro ignore L=.Lignore
 30:
 	.section __ex_table,"a"
@@ -56,29 +56,18 @@
 	.globl csum_partial_copy_generic
 	.p2align 4
 csum_partial_copy_generic:
-	cmpl	 $3*64,%edx
+	cmpl	 $2*64,%edx
 	jle	 .Lignore
 
 	ignore
-	prefetch (%rdi)
-	ignore
 	prefetch 1*64(%rdi)
 	ignore
 	prefetch 2*64(%rdi)
 	ignore
-	prefetch 3*64(%rdi)
-	ignore
-	prefetch 4*64(%rdi)
-	ignore
 	prefetchw (%rsi)
 	ignore
 	prefetchw 1*64(%rsi)
 	ignore
-	prefetchw 2*64(%rsi)
-	ignore
-	prefetchw 3*64(%rsi)
-	ignore
-	prefetchw 4*64(%rsi)
 
 .Lignore:		
 	subq  $7*8,%rsp
@@ -116,7 +105,7 @@ csum_partial_copy_generic:
 	movq  16(%rdi),%r11
 	source
 	movq  24(%rdi),%rdx
-
+	
 	source
 	movq  32(%rdi),%r10
 	source
@@ -125,10 +114,7 @@ csum_partial_copy_generic:
 	movq  48(%rdi),%r14
 	source
 	movq  56(%rdi),%r13
-		
-	ignore 2f
-	prefetch 5*64(%rdi)
-2:							
+
 	adcq  %rbx,%rax
 	adcq  %r8,%rax
 	adcq  %r11,%rax
@@ -148,7 +134,7 @@ csum_partial_copy_generic:
 	movq %r11,16(%rsi)
 	dest
 	movq %rdx,24(%rsi)
-
+	
 	dest
 	movq %r10,32(%rsi)
 	dest
@@ -157,11 +143,7 @@ csum_partial_copy_generic:
 	movq %r14,48(%rsi)
 	dest
 	movq %r13,56(%rsi)
-	
-	ignore 3f
-	prefetchw 5*64(%rsi)
-3:
-	
+
 	leaq 64(%rdi),%rdi
 	leaq 64(%rsi),%rsi
 
@@ -212,7 +194,7 @@ csum_partial_copy_generic:
 	movw (%rdi),%bx
 	adcl %ebx,%eax
 	dest
-	decl %ecx
+	decl %ecx	
 	movw %bx,(%rsi)
 	leaq 2(%rdi),%rdi
 	leaq 2(%rsi),%rsi
--- linux-2.4.22/arch/x86_64/lib/csum-partial.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/lib/csum-partial.c	2003-10-10 11:17:45.000000000 +0200
@@ -12,19 +12,19 @@
 #define __force_inline inline __attribute__((always_inline))
 
 static inline unsigned short from32to16(unsigned a) 
-{
+{ 
 	unsigned short b = a >> 16; 
 	asm("addw %w2,%w0\n\t"
 	    "adcw $0,%w0\n" 
 	    : "=r" (b)
 	    : "0" (b), "r" (a));
 	return b;
-}
+} 
 
 /*
  * Do a 64-bit checksum on an arbitrary memory area.
  * Returns a 32bit checksum.
- *
+ * 
  * This isn't as time critical as it used to be because many NICs
  * do hardware checksumming these days.
  * 
@@ -65,7 +65,7 @@ static __force_inline unsigned do_csum(c
 			count >>= 1;	/* nr of 64-bit words.. */
 
 			/* main loop using 64byte blocks */
-				unsigned long zero = 0; 
+			unsigned long zero = 0; 
 			unsigned count64 = count >> 3; 
 			while (count64) { 
 				asm("addq 0*8(%[src]),%[res]\n\t"
@@ -89,12 +89,12 @@ static __force_inline unsigned do_csum(c
 			while (count) { 
 				asm("addq %1,%0\n\t"
 				    "adcq %2,%0\n" 
-					    : "=r" (result)
+				    : "=r" (result)
 				    : "m" (*(unsigned long *)buff), 
 				    "r" (zero),  "0" (result));
 				--count; 
-					buff += 8;
-			}
+				buff += 8; 
+			} 
 			result = add32_with_carry(result>>32,
 						  result&0xffffffff); 
 
--- linux-2.4.22/arch/x86_64/lib/csum-wrappers.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/lib/csum-wrappers.c	2003-10-10 11:17:45.000000000 +0200
@@ -44,7 +44,7 @@ csum_partial_copy_from_user(const char *
 			}
 		}
 		isum = csum_partial_copy_generic(src,dst,len,isum,errp,NULL);
-		if (likely(*errp == 0)) 
+		if (likely(*errp == 0))
 			return isum;
 	} 
 	*errp = -EFAULT;
--- linux-2.4.22/arch/x86_64/lib/memset.S.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/lib/memset.S	2003-10-10 11:17:45.000000000 +0200
@@ -67,7 +67,7 @@ __memset:
 	jz      .Lende
 	.p2align 4
 .Lloop_1:
-	decl    %ecx
+	decl    %ecx	
 	movb 	%al,(%rdi)
 	leaq	1(%rdi),%rdi
 	jnz     .Lloop_1
--- linux-2.4.22/arch/x86_64/lib/usercopy.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/lib/usercopy.c	2003-10-10 11:17:45.000000000 +0200
@@ -68,7 +68,7 @@ unsigned long __clear_user(void *addr, u
 	asm volatile(
 		"	testq  %[size8],%[size8]\n"
 		"	jz     4f\n"
-		"0:	movnti %[zero],(%[dst])\n"
+		"0:	movq %[zero],(%[dst])\n"
 		"	addq   %[eight],%[dst]\n"
 		"	decl %%ecx ; jnz   0b\n"
 		"4:	movq  %[size1],%%rcx\n"
@@ -77,7 +77,7 @@ unsigned long __clear_user(void *addr, u
 		"1:	movb   %b[zero],(%[dst])\n"
 		"	incq   %[dst]\n"
 		"	decl %%ecx ; jnz  1b\n"
-		"2:	sfence\n"
+		"2:\n"
 		".section .fixup,\"ax\"\n"
 		"3:	lea 0(%[size1],%[size8],8),%[size8]\n"
 		"	jmp 2b\n"
--- linux-2.4.22/arch/x86_64/kernel/acpi.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/acpi.c	2003-10-10 11:17:45.000000000 +0200
@@ -44,6 +44,7 @@
 #include <asm/io_apic.h>
 #include <asm/proto.h>
 
+extern int acpi_disabled;
 
 #define PREFIX			"ACPI: "
 
@@ -351,6 +352,28 @@ acpi_boot_init (void)
 
 #ifdef CONFIG_X86_LOCAL_APIC
 
+	/*
+	 * ACPI interpreter is required to complete interrupt setup,
+	 * so if it is off, don't enumerate the io-apics with ACPI.
+	 * If MPS is present, it will handle them,
+	 * otherwise the system will stay in PIC mode
+	 */
+	if (acpi_disabled) {
+		return 1;
+	}
+
+	if (!use_acpi_pci)
+		return 0; 
+
+	/* If "nolocalapic" is specified don't look further */
+	extern int apic_disabled;
+	if (apic_disabled) {
+		printk(KERN_INFO PREFIX "Skipping Local/IO-APIC probe due to \"nolocalapic\"\n");
+		return 0;	
+	}	
+	printk(KERN_INFO PREFIX "Parsing Local APIC info in MADT\n"); 
+	
+
 	/* 
 	 * MADT
 	 * ----
@@ -411,6 +434,15 @@ acpi_boot_init (void)
 
 #ifdef CONFIG_X86_IO_APIC
 
+	/*
+	 * if "noapic" boot option, don't look for IO-APICs
+	 */
+	if (ioapic_setup_disabled()) {
+		printk(KERN_INFO PREFIX "Skipping IOAPIC probe "
+			"due to 'noapic' option.\n");
+		return 1;
+        }
+
 	/* 
 	 * I/O APIC 
 	 * --------
--- linux-2.4.22/arch/x86_64/kernel/acpi_wakeup.S.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/acpi_wakeup.S	2003-10-10 11:17:45.000000000 +0200
@@ -209,7 +209,7 @@ wakeup_long64:
 
 	movw	$0x0e00 + '!', %ds:(0xb801a)
 	movq	saved_eip, %rax
-	jmp	%rax
+	jmp	*%rax
 
 .code32
 
--- linux-2.4.22/arch/x86_64/kernel/aperture.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/aperture.c	2003-10-10 11:17:45.000000000 +0200
@@ -205,14 +205,14 @@ void __init iommu_hole_init(void) 
 
 		printk("CPU %d: aperture @ %Lx size %u MB\n", num-24, 
 		       aper_base, aper_size>>20);
-		
+
 		char name[30];
 		sprintf(name, "northbridge cpu %d", num-24); 
 
 		if (!aperture_valid(name, aper_base, aper_size)) { 
-			fix = 1; 
+			fix = 1;
 			break; 
-		} 
+		}
 	} 
 
 	if (!fix && !fallback_aper_force) 
@@ -233,12 +233,12 @@ void __init iommu_hole_init(void) 
 		   aperture) should only happen with a more broken than
 		   usual BIOS, because it would even break Windows. */
 
-	printk("Your BIOS doesn't leave a aperture memory hole\n");
-	printk("Please enable the IOMMU option in the BIOS setup\n"); 
+		printk("Your BIOS doesn't leave a aperture memory hole\n");
+		printk("Please enable the IOMMU option in the BIOS setup\n");
 		printk("This costs you %d MB of RAM\n", 32 << fallback_aper_order); 
  
 		aper_order = fallback_aper_order;
-	aper_alloc = allocate_aperture(); 
+		aper_alloc = allocate_aperture(); 
 		if (!aper_alloc) { 
 			/* Could disable AGP and IOMMU here, but it's probably
 			   not worth it. But the later users cannot deal with
@@ -248,7 +248,7 @@ void __init iommu_hole_init(void) 
 			panic("Not enough memory for aperture");
 		}
 	} else { 
-		return; 
+		return;
 	} 
 
 	/* Fix up the north bridges */
--- linux-2.4.22/arch/x86_64/kernel/apic.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/apic.c	2003-10-10 11:17:45.000000000 +0200
@@ -600,7 +600,7 @@ static int __init detect_init_APIC (void
 	if (!cpu_has_apic) {
 		printk(KERN_INFO "APIC disabled by BIOS.\n");
 		return -1;
-	}
+	}		
 	set_bit(X86_FEATURE_APIC, &boot_cpu_data.x86_capability);
 	mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
 	boot_cpu_id = 0;
@@ -1057,7 +1057,7 @@ int __init APIC_init_uniprocessor (void)
 		check_nmi_watchdog();
 #ifdef CONFIG_X86_IO_APIC
 	if (smp_found_config && !skip_ioapic_setup && nr_ioapics)
-			setup_IO_APIC();
+		setup_IO_APIC();
 	else
 		nr_ioapics = 0;
 #endif
--- linux-2.4.22/arch/x86_64/kernel/bluesmoke.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/bluesmoke.c	2003-10-10 11:17:45.000000000 +0200
@@ -186,7 +186,7 @@ static char *highbits[32] = { 
 	[0] = "err cpu1",
 };
 
-static void check_k8_nb(void)
+static void check_k8_nb(int header)
 {
 	struct pci_dev *nb;
 	nb = find_k8_nb(); 
@@ -198,8 +198,11 @@ static void check_k8_nb(void)
 	pci_read_config_dword(nb, 0x4c, &statushigh);
 	if (!(statushigh & (1<<31)))
 		return;
+	if (header) 
+		printk(KERN_ERR "CPU %d: Silent Northbridge MCE\n", smp_processor_id());
+
 	printk(KERN_ERR "Northbridge status %08x%08x\n",
-	       statushigh,statuslow); 
+	       statushigh,statuslow);
 
 	unsigned short errcode = statuslow & 0xffff;	
 	switch (errcode >> 8) { 
@@ -257,9 +260,11 @@ static void k8_machine_check(struct pt_r
 	rdmsrl(MSR_IA32_MCG_STATUS, status); 
 	if ((status & (1<<2)) == 0) { 
 		if (!regs) 
-			check_k8_nb();
+			check_k8_nb(1);
 		return; 
 	}
+	printk(KERN_EMERG "CPU %d: Machine Check Exception: %016Lx\n", smp_processor_id(), status);
+
 	if (status & 1)
 		printk(KERN_EMERG "MCG_STATUS: unrecoverable\n"); 
 
@@ -277,7 +282,7 @@ static void k8_machine_check(struct pt_r
 	if (nbstatus & (1UL<57))
 		printk(KERN_EMERG "Unrecoverable condition\n"); 
 		
-	check_k8_nb();
+	check_k8_nb(0);
 
 	if (nbstatus & (1UL<<58)) { 
 		u64 adr;
@@ -316,7 +321,7 @@ static void mcheck_timer_other(void *dat
 } 
 
 static void mcheck_timer_dist(void *data)
-{ 
+{ 	
 	smp_call_function(mcheck_timer_other,0,0,0);
 	k8_machine_check(NULL, 0); 
 	mcheck_timer.expires = jiffies + mcheck_interval;
@@ -338,7 +343,6 @@ static void __init k8_mcheck_init(struct
 {
 	u64 cap;
 	int i;
-	struct pci_dev *nb; 
 
 	if (!test_bit(X86_FEATURE_MCE, &c->x86_capability) || 
 	    !test_bit(X86_FEATURE_MCA, &c->x86_capability))
--- linux-2.4.22/arch/x86_64/kernel/e820.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/e820.c	2003-10-10 11:17:45.000000000 +0200
@@ -1,7 +1,7 @@
 /* 
  * Handle the memory map.
  * The functions here do the job until bootmem takes over.
- * $Id: e820.c,v 1.6 2002/10/15 09:35:16 ak Exp $
+ * $Id: e820.c,v 1.10 2003/09/25 03:22:05 ak Exp $
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -12,6 +12,7 @@
 #include <asm/page.h>
 #include <asm/e820.h>
 #include <asm/proto.h>
+#include <asm/acpi.h>
 #include <asm/bootsetup.h>
 
 extern unsigned long table_start, table_end;
@@ -121,7 +122,7 @@ void __init e820_bootmem_free(pg_data_t 
 	}
 }
 
-/*
+/* 
  * end_pfn only includes RAM, while end_pfn_map includes all e820 entries.
  * The direct mapping extends to end_pfn_map, so that we can directly access
  * ACPI and other tables without having to play with fixmaps.
@@ -151,8 +152,8 @@ void __init e820_end_of_ram(void)
 		if (start >= end)
 			continue;
 		if (ei->type == E820_RAM) { 
-		if (end > end_pfn<<PAGE_SHIFT)
-			end_pfn = end>>PAGE_SHIFT;
+			if (end > end_pfn<<PAGE_SHIFT)
+				end_pfn = end>>PAGE_SHIFT;
 		} else { 
 			if (end > end_pfn_map<<PAGE_SHIFT) 
 				end_pfn_map = end>>PAGE_SHIFT;
@@ -488,7 +489,6 @@ void __init setup_memory_region(void)
 			mem_size = ALT_MEM_K;
 			who = "BIOS-e801";
 		}
-
 		e820.nr_map = 0;
 		add_memory_region(0, LOWMEMSIZE(), E820_RAM);
 		add_memory_region(HIGH_MEMORY, mem_size << 10, E820_RAM);
@@ -500,7 +500,6 @@ void __init setup_memory_region(void)
 extern char command_line[], saved_command_line[];
 extern int fallback_aper_order;
 extern int iommu_setup(char *opt);
-extern int acpi_disabled;
 
 void __init parse_mem_cmdline (char ** cmdline_p)
 {
@@ -530,10 +529,10 @@ void __init parse_mem_cmdline (char ** c
 			 * Also on x86-64 there should be always a good e820
 			 * map. This is only an upper limit, you cannot force
 			 * usage of memory not in e820.
-					 */
+			 */
 			end_user_pfn = memparse(from+4, &from) + HIGH_MEMORY;
 			end_user_pfn >>= PAGE_SHIFT;
-		}
+		} 
 #ifdef CONFIG_GART_IOMMU 
 		else if (!memcmp(from,"iommu=",6)) { 
 			iommu_setup(from+6); 
@@ -541,7 +540,23 @@ void __init parse_mem_cmdline (char ** c
 #endif
  		else if (!memcmp(from, "acpi=off", 8))
   			acpi_disabled = 1;
+		else if (!memcmp(from,"maxcpus=0",9)) {
+			disable_ioapic_setup();
+			apic_disabled = 1;
+		}
 		
+		else if (!memcmp(from, "noapic", 6)) 
+			disable_ioapic_setup();
+		else if (!memcmp(from, "nolocalapic", 11) || !memcmp(from,"nolapic",7))
+			apic_disabled = 1;
+		else if (!memcmp(from, "pci=noacpi", 10))
+			use_acpi_pci = 0;
+		else if (!memcmp(from,"apic",4)) {
+			extern int ioapic_force;
+			ioapic_force = 1;
+			skip_ioapic_setup = 0;
+		}
+
 	next:
 		c = *(from++);
 		if (!c)
--- linux-2.4.22/arch/x86_64/kernel/entry.S.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/entry.S	2003-10-10 11:17:45.000000000 +0200
@@ -341,7 +341,7 @@ retint_with_reschedule:
 retint_restore_args_swapgs:		
 	swapgs
 retint_restore_args:				
-	RESTORE_ARGS 0,8						
+	RESTORE_ARGS 0,8
 iret_label:	
 	iretq
 	.section __ex_table,"a"
@@ -354,7 +354,7 @@ bad_iret:
 	movq $-9999,%rdi	/* better code? */
 	jmp do_exit			
 	.previous	
-
+				
 retint_signal:	
 	sti
 	SAVE_REST
@@ -457,8 +457,8 @@ error_entry:
 	xorl %r15d,%r15d	
 	testl $3,CS(%rsp)
 	je error_kernelspace
-	swapgs	
-error_action:
+	swapgs
+error_action:		
 	movq  %rdi,RDI(%rsp) 	
 	movq %rsp,%rdi
 	movq ORIG_RAX(%rsp),%rsi	/* get error code */ 
@@ -475,12 +475,12 @@ error_test:		
 	jne  error_reschedule
 	cmpl $0,tsk_sigpending(%rcx)
 	jne  error_signal
-error_restore_swapgs:					
+error_restore_swapgs:	
 	swapgs
-error_restore:	
+error_restore:
 	RESTORE_REST
 	jmp retint_restore_args
-	
+		
 error_reschedule:
 	sti
 	call schedule
@@ -500,14 +500,14 @@ error_signal_test:
 	call schedule
 	jmp  error_signal_test
 	
-error_kernelspace:	
+error_kernelspace:
 	incl %r15d
 	/* There are two places in the kernel that can potentially fault with
 	   usergs. Handle them here. */	   
 	cmpq $iret_label,RIP(%rsp)
 	je   1f
 	cmpq $gs_change,RIP(%rsp)
-	jne  error_action
+	jne  error_action	
 	/* iret_label and gs_change are handled by exception handlers
 	   and the exit points run with kernelgs again */
 1:	swapgs
@@ -520,7 +520,7 @@ ENTRY(load_gs_index)
 	cli
 	swapgs
 gs_change:	
-	movl %edi,%gs	
+	movl %edi,%gs
 2:	mfence		/* workaround for opteron errata #88 */
 	swapgs
 	popf
@@ -637,7 +637,7 @@ ENTRY(device_not_available)
 	jmp  error_exit
 1:	incl %r15d
 	jmp  2b
-
+	
 ENTRY(debug)
 	zeroentry do_debug
 
--- linux-2.4.22/arch/x86_64/kernel/head.S.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/head.S	2003-10-10 11:17:45.000000000 +0200
@@ -6,7 +6,7 @@
  *  Copyright (C) 2000 Karsten Keil <kkeil@suse.de>
  *  Copyright (C) 2001,2002 Andi Kleen <ak@suse.de>
  *
- *  $Id: head.S,v 1.56 2003/05/12 14:38:43 ak Exp $
+ *  $Id: head.S,v 1.57 2003/07/11 15:58:46 ak Exp $
  */
 
 
@@ -312,7 +312,8 @@ ENTRY(empty_bad_pmd_table)
 ENTRY(level3_physmem_pgt)
 	.quad	0x0000000000105007		/* -> level2_kernel_pgt (so that __va works even before pagetable_init) */
 
-.org 0xb000
+	.org 0xb000
+#ifdef CONFIG_ACPI_SLEEP
 ENTRY(wakeup_level4_pgt)
         .quad   0x0000000000102007              /* -> level3_ident_pgt */
         .fill   255,8,0
@@ -320,6 +321,7 @@ ENTRY(wakeup_level4_pgt)
         .fill   254,8,0
         /* (2^48-(2*1024*1024*1024))/(2^39) = 511 */
         .quad   0x0000000000103007              /* -> level3_kernel_pgt */
+#endif
 
 .data
 
--- linux-2.4.22/arch/x86_64/kernel/io_apic.c.amd64-updates	2003-10-10 10:31:52.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/io_apic.c	2003-10-10 11:17:45.000000000 +0200
@@ -165,6 +165,14 @@ void clear_IO_APIC_pin(unsigned int apic
 	struct IO_APIC_route_entry entry;
 	unsigned long flags;
 
+        /* Check delivery_mode to be sure we're not clearing an SMI pin */
+        spin_lock_irqsave(&ioapic_lock, flags);
+        *(((int*)&entry) + 0) = io_apic_read(apic, 0x10 + 2 * pin);
+        *(((int*)&entry) + 1) = io_apic_read(apic, 0x11 + 2 * pin);
+        spin_unlock_irqrestore(&ioapic_lock, flags);
+        if (entry.delivery_mode == dest_SMI)
+                return;
+
 	/*
 	 * Disable it in the IO-APIC irq-routing table:
 	 */
@@ -193,10 +201,12 @@ static void clear_IO_APIC (void)
 #define MAX_PIRQS 8
 int pirq_entries [MAX_PIRQS];
 int pirqs_enabled;
-int skip_ioapic_setup;
+int skip_ioapic_setup; 
+int ioapic_force; 
 
 static int __init noioapic_setup(char *str)
 {
+	ioapic_force = 1;
 	skip_ioapic_setup = 1;
 	return 1;
 }
@@ -205,12 +215,66 @@ __setup("noapic", noioapic_setup);
 
 static int __init ioapic_setup(char *str)
 {
+	ioapic_force = 1;
 	skip_ioapic_setup = 0;
 	return 1;
 }
 
 __setup("apic", ioapic_setup);
 
+#ifndef CONFIG_SMP
+#include <asm/pci-direct.h>
+#include <linux/pci_ids.h>
+#include <linux/pci.h>
+
+/* Temporary Hack. Nvidia and VIA boards currently only work with IO-APIC
+   off. Check for an Nvidia or VIA PCI bridge and turn it off.
+   Use pci direct infrastructure because this runs before the PCI subsystem. 
+
+   Can be overwritten with "apic" */
+void __init check_ioapic(void) 
+{ 
+	int num,slot,func; 
+	if (ioapic_force) 
+		return; 
+
+	/* Poor man's PCI discovery */
+	for (num = 0; num < 32; num++) { 
+		for (slot = 0; slot < 32; slot++) { 
+			for (func = 0; func < 8; func++) { 
+				u32 class;
+				u32 vendor;
+				class = read_pci_config(num,slot,func,
+							PCI_CLASS_REVISION);
+				if (class == 0xffffffff)
+					break; 
+
+		       		if ((class >> 16) != PCI_CLASS_BRIDGE_PCI)
+					continue; 
+
+				vendor = read_pci_config(num, slot, func, 
+							 PCI_VENDOR_ID);
+				vendor &= 0xffff;
+				switch (vendor) { 
+				case PCI_VENDOR_ID_NVIDIA: 
+				case PCI_VENDOR_ID_VIA:
+					printk(KERN_INFO 
+     "PCI bridge %02x:%02x from %x found. Setting \"noapic\". Overwrite with \"apic\"\n",
+					       num,slot,vendor); 
+					skip_ioapic_setup = 1;
+					return;
+				} 
+
+				/* No multi-function device? */
+				u8 type = read_pci_config_byte(num,slot,func,
+							       PCI_HEADER_TYPE);
+				if (!(type & 0x80))
+					break;
+			} 
+		}
+	}
+} 
+#endif
 
 static int __init ioapic_pirq_setup(char *str)
 {
@@ -1640,7 +1704,7 @@ static inline void check_timer(void)
 #define PIC_IRQS	(1<<2)
 
 void __init setup_IO_APIC(void)
-{
+{   
 	enable_IO_APIC();
 
 	io_apic_irqs = ~PIC_IRQS;
--- linux-2.4.22/arch/x86_64/kernel/ioport.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/ioport.c	2003-10-10 11:17:45.000000000 +0200
@@ -19,35 +19,13 @@
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, short base, short extent, int new_value)
 {
-	unsigned long mask;
-	unsigned long *bitmap_base = bitmap + base / sizeof(long);
-	unsigned low_index = base & (BITS_PER_LONG - 1);
-	int length = low_index + extent;
-
-	if (low_index != 0) {
-		mask = (~0UL << low_index);
-		if (length < 64)
-			mask &= ~(~0UL << length);
-		if (new_value)
-			*bitmap_base++ |= mask;
-		else
-			*bitmap_base++ &= ~mask;
-		length -= 64;
-	}
-
-	mask = (new_value ? ~0UL : 0UL);
-	while (length >= 64) {
-		*bitmap_base++ = mask;
-		length -= 64;
-	}
-
-	if (length > 0) {
-		mask = ~(~0UL << length);
-		if (new_value)
-			*bitmap_base++ |= mask;
-		else
-			*bitmap_base++ &= ~mask;
-	}
+	int i;
+	if (new_value) 
+		for (i = base; i < base + extent; i++) 
+			__set_bit(i, bitmap); 
+	else
+		for (i = base; i < base + extent; i++) 
+			clear_bit(i, bitmap); 
 }
 
 /*
@@ -86,7 +64,7 @@ asmlinkage long sys_ioperm(unsigned long
 		memcpy(tss->io_bitmap, t->io_bitmap_ptr, sizeof(tss->io_bitmap));
 		tss->io_map_base = IO_BITMAP_OFFSET;
 	} else { 
-	set_bitmap((unsigned long *) tss->io_bitmap, from, num, !turn_on);
+		set_bitmap((unsigned long *) tss->io_bitmap, from, num, !turn_on);
 	}
 
 	return 0;
--- linux-2.4.22/arch/x86_64/kernel/mpparse.c.amd64-updates	2003-10-10 10:32:01.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/mpparse.c	2003-10-10 11:24:38.000000000 +0200
@@ -139,9 +139,12 @@ static void __init MP_bus_info (struct m
 	str[6] = 0;
 	Dprintk("Bus #%d is %s\n", m->mpc_busid, str);
 
-	if (m->mpc_busid >= MAX_MP_BUSSES) {
+#if MAX_MP_BUSSES < 256
+	if ((long)m->mpc_busid >= MAX_MP_BUSSES) {
 		printk(KERN_ERR "MAX_MP_BUSSES ERROR mpc_busid %d, max %d\n", m->mpc_busid, MAX_MP_BUSSES);
-	} else if (strncmp(str, "ISA", 3) == 0) {
+	} else 
+#endif	
+	if (strncmp(str, "ISA", 3) == 0) {
 		mp_bus_id_to_type[m->mpc_busid] = MP_BUS_ISA;
 	} else if (strncmp(str, "EISA", 4) == 0) {
 		mp_bus_id_to_type[m->mpc_busid] = MP_BUS_EISA;
@@ -756,7 +759,7 @@ void __init mp_register_ioapic (
 	mp_ioapic_routing[idx].irq_end = irq_base + 
 		io_apic_get_redir_entries(idx);
 
-	printk("IOAPIC[%d]: apic_id %d, version %d, address 0x%lx, "
+	printk("IOAPIC[%d]: apic_id %d, version %d, address 0x%x, "
 		"IRQ %d-%d\n", idx, mp_ioapics[idx].mpc_apicid, 
 		mp_ioapics[idx].mpc_apicver, mp_ioapics[idx].mpc_apicaddr,
 		mp_ioapic_routing[idx].irq_start,
@@ -883,8 +886,6 @@ void __init mp_config_acpi_legacy_irqs (
 
 #ifndef CONFIG_ACPI_HT_ONLY
 
-/* Ensure the ACPI SCI interrupt level is active low, edge-triggered */
-
 extern FADT_DESCRIPTOR acpi_fadt;
 
 void __init mp_config_ioapic_for_sci(int irq)
@@ -893,6 +894,7 @@ void __init mp_config_ioapic_for_sci(int
 	int ioapic_pin;
 	struct acpi_table_madt* madt;
 	struct acpi_table_int_src_ovr *entry = NULL;
+	acpi_interrupt_flags flags;
 	void *madt_end;
 	acpi_status status;
 
@@ -911,23 +913,42 @@ void __init mp_config_ioapic_for_sci(int
 
 		while ((void *) entry < madt_end) {
                 	if (entry->header.type == ACPI_MADT_INT_SRC_OVR &&
-			    acpi_fadt.sci_int == entry->global_irq)
-                		return;
+ 			    acpi_fadt.sci_int == entry->bus_irq)
+ 				goto found;
 
-                	entry = (struct acpi_table_int_src_ovr *)
-                	        ((unsigned long) entry + entry->header.length);
-        	}
+                  	entry = (struct acpi_table_int_src_ovr *)
+                  	        ((unsigned long) entry + entry->header.length);
+		}
 	}
+ 	/*
+ 	 * Although the ACPI spec says that the SCI should be level/low
+ 	 * don't reprogram it unless there is an explicit MADT OVR entry
+ 	 * instructing us to do so -- otherwise we break Tyan boards which
+ 	 * have the SCI wired edge/high but no MADT OVR.
+ 	 */
+ 	return;
 
+found:
+ 	/*
+ 	 * See the note at the end of ACPI 2.0b section
+ 	 * 5.2.10.8 for what this is about.
+ 	 */
+ 	flags = entry->flags;
+ 	acpi_fadt.sci_int = entry->global_irq;
+ 	irq = entry->global_irq;
+ 	
 	ioapic = mp_find_ioapic(irq);
 
 	ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
 
-	io_apic_set_pci_routing(ioapic, ioapic_pin, irq, 1, 1);
+ 	io_apic_set_pci_routing(ioapic, ioapic_pin, irq, 
+ 				(flags.trigger >> 1) , (flags.polarity >> 1));
 }
 
 #endif /*CONFIG_ACPI_HT_ONLY*/
 
+int acpi_tolerant;
+
 #ifdef CONFIG_ACPI_PCI
 
 void __init mp_parse_prt (void)
@@ -961,6 +982,13 @@ void __init mp_parse_prt (void)
 		}
 
 		irq = entry->link.index;
+
+  		/* Don't set up the ACPI SCI because it's already set up */
+                if (acpi_fadt.sci_int == irq) {
+                         entry->irq = irq; /*we still need to set entry's irq*/
+ 			continue;
+                }
+
 		ioapic = mp_find_ioapic(irq);
 		if (ioapic < 0)
 			continue;
--- linux-2.4.22/arch/x86_64/kernel/nmi.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/nmi.c	2003-10-10 11:17:45.000000000 +0200
@@ -30,6 +30,7 @@
 unsigned int nmi_watchdog = NMI_LOCAL_APIC;
 static unsigned int nmi_hz = HZ;
 unsigned int nmi_perfctr_msr;	/* the MSR to reset in NMI handler */
+int panic_on_timeout;
 
 int nmi_watchdog_disabled; 
 
@@ -121,6 +122,13 @@ static int __init setup_nmi_watchdog(cha
 {
 	int nmi;
 
+	if (!strncmp(str,"panic",5)) {
+		panic_on_timeout = 1;
+		str = strchr(str, ',');
+		if (!str) 
+			return 1; 
+		++str;	
+	}			
 	get_option(&str, &nmi);
 
 	if (nmi >= NMI_INVALID)
@@ -379,7 +387,9 @@ void nmi_watchdog_tick (struct pt_regs *
 			 */
 			bust_spinlocks(1);
 			printk("NMI Watchdog detected LOCKUP on CPU%d, eip %16lx, registers:\n", cpu, regs->rip);
-			show_registers(regs);
+			show_registers(regs);			
+			if (panic_on_timeout)
+				panic("NMI lockup");
 			printk("console shuts up ...\n");
 			console_silent();
 			spin_unlock(&nmi_print_lock);
--- linux-2.4.22/arch/x86_64/kernel/pci-gart.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/pci-gart.c	2003-10-10 11:17:45.000000000 +0200
@@ -8,7 +8,7 @@
  * See Documentation/DMA-mapping.txt for the interface specification.
  * 
  * Copyright 2002 Andi Kleen, SuSE Labs.
- * $Id: pci-gart.c,v 1.27 2003/08/05 18:25:31 ak Exp $
+ * $Id: pci-gart.c,v 1.28 2003/09/19 07:01:58 ak Exp $
  */
 
 #include <linux/config.h>
@@ -87,7 +87,7 @@ static unsigned long alloc_iommu(int siz
 	offset = find_next_zero_string(iommu_gart_bitmap,next_bit,iommu_pages,size);
 	if (offset == -1) {
 		need_flush = 1;
-	       	offset = find_next_zero_string(iommu_gart_bitmap,0,next_bit,size);
+		offset = find_next_zero_string(iommu_gart_bitmap,0,next_bit,size);
 	}
 	if (offset != -1) { 
 		set_bit_string(iommu_gart_bitmap, offset, size); 
@@ -95,7 +95,7 @@ static unsigned long alloc_iommu(int siz
 		if (next_bit >= iommu_pages) { 
 			need_flush = 1;
 			next_bit = 0;
-	} 
+		}
 	} 
 	spin_unlock_irqrestore(&iommu_bitmap_lock, flags);      
 	return offset;
@@ -130,7 +130,7 @@ static void __flush_gart(void)
 		if (!flushed) 
 			printk("nothing to flush?\n");
 		need_flush = 0;
-	} 
+	}
 	spin_unlock_irqrestore(&iommu_bitmap_lock, flags);
 } 
 
@@ -220,9 +220,9 @@ void pci_free_consistent(struct pci_dev 
 		int i;
 		for (i = 0; i < pages; i++) {
 			u64 pte = iommu_gatt_base[iommu_page + i];
-		BUG_ON((pte & GPTE_VALID) == 0); 
-		iommu_gatt_base[iommu_page + i] = 0; 		
-	} 
+			BUG_ON((pte & GPTE_VALID) == 0); 
+			iommu_gatt_base[iommu_page + i] = 0;	
+		}
 		free_iommu(iommu_page, pages);
 	}
 	free_pages((unsigned long)vaddr, get_order(size)); 		
@@ -315,7 +315,7 @@ dma_addr_t pci_map_single(struct pci_dev
 		return iommu_bus_base; 
 	} 
 
-	phys_mem &= PAGE_MASK;
+	phys_mem &= PAGE_MASK; 
 	for (i = 0; i < npages; i++, phys_mem += PAGE_SIZE) {
 		BUG_ON(phys_mem & ~PHYSICAL_PAGE_MASK); 
 		
@@ -414,20 +414,20 @@ static __init int init_k8_gatt(agp_kern_
 	void *gatt;
 	unsigned aper_base, new_aper_base;
 	unsigned aper_size, gatt_size, new_aper_size;
-
+	
 	aper_size = aper_base = info->aper_size = 0;
 	for_all_nb(dev) { 
 		new_aper_base = read_aperture(dev, &new_aper_size); 
 		if (!new_aper_base) 
-	goto nommu; 
-
+			goto nommu; 
+		
 		if (!aper_base) { 
 			aper_size = new_aper_size;
 			aper_base = new_aper_base;
-	}
+		} 
 		if (aper_size != new_aper_size || aper_base != new_aper_base) 
-		goto nommu;
-	} 
+			goto nommu;
+	}
 	if (!aper_base)
 		goto nommu; 
 	info->aper_base = aper_base;
@@ -440,7 +440,7 @@ static __init int init_k8_gatt(agp_kern_
 	memset(gatt, 0, gatt_size); 
 	change_page_attr(virt_to_page(gatt), gatt_size/PAGE_SIZE, PAGE_KERNEL_NOCACHE);
 	agp_gatt_table = gatt;
-
+	
 	for_all_nb(dev) { 
 		u32 ctl; 
 		u32 gatt_reg; 
@@ -459,11 +459,11 @@ static __init int init_k8_gatt(agp_kern_
 	
 		
 	printk("PCI-DMA: aperture base @ %x size %u KB\n", aper_base, aper_size>>10); 
-		return 0;
+	return 0;
 
  nommu:
 	/* XXX: reject 0xffffffff mask now in pci mapping functions */
-		printk(KERN_ERR "PCI-DMA: More than 4GB of RAM and no IOMMU\n"
+	printk(KERN_ERR "PCI-DMA: More than 4GB of RAM and no IOMMU\n"
 	       KERN_ERR "PCI-DMA: 32bit PCI IO may malfunction."); 
 	return -1; 
 } 
@@ -473,7 +473,7 @@ void __init pci_iommu_init(void)
 	agp_kern_info info;
 	unsigned long aper_size;
 	unsigned long iommu_start;
-
+		
 #ifndef CONFIG_AGP
 	no_agp = 1; 
 #else
@@ -495,11 +495,11 @@ void __init pci_iommu_init(void)
 		if (err < 0) { 
 			printk(KERN_INFO "PCI-DMA: Disabling IOMMU.\n"); 
 			no_iommu = 1;
-			return; 
+			return;
 		}
 	} 
 	
-	aper_size = info.aper_size * 1024 * 1024;
+	aper_size = info.aper_size * 1024 * 1024;	
 	iommu_size = check_iommu_size(info.aper_base, aper_size); 
 	iommu_pages = iommu_size >> PAGE_SHIFT; 
 
@@ -578,7 +578,7 @@ __init int iommu_setup(char *opt) 
     
     for (;;) { 
 	    if (!memcmp(p,"noagp", 5))
-		    no_agp = 1; 
+		    no_agp = 1;
 	    if (!memcmp(p,"off", 3))
 		    no_iommu = 1;
 	    if (!memcmp(p,"force", 5))
@@ -588,8 +588,11 @@ __init int iommu_setup(char *opt) 
 	    if (!memcmp(p, "memaper", 7)) { 
 		    fallback_aper_force = 1; 
 		    p += 7; 
-		    if (*p == '=' && get_option(&p, &arg))
-			    fallback_aper_order = arg;
+		    if (*p == '=') { 
+			    ++p;
+			    if (get_option(&p, &arg))
+				    fallback_aper_order = arg;
+		    }
 	    } 
 #ifdef CONFIG_IOMMU_LEAK
 	    if (!memcmp(p,"leak", 4)) { 
@@ -606,7 +609,7 @@ __init int iommu_setup(char *opt) 
 		    if (*p == ' ' || *p == 0) 
 			    return 0; 
 	    } while (*p++ != ','); 
-    }	
+    }
     return 1;
 } 
 
--- linux-2.4.22/arch/x86_64/kernel/pci-irq.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/pci-irq.c	2003-10-10 11:17:45.000000000 +0200
@@ -741,24 +741,24 @@ void pcibios_penalize_isa_irq(int irq)
 
 void pcibios_enable_irq(struct pci_dev *dev)
 {
-		u8 pin;
+	u8 pin;
 	extern int interrupt_line_quirk;
 
-		pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
 	if (pin && !pcibios_lookup_irq(dev, 1) && !dev->irq) {
-			char *msg;
+		char *msg;
 		/* With IDE legacy devices the IRQ lookup failure is not a problem.. */
 		if (dev->class >> 8 == PCI_CLASS_STORAGE_IDE && !(dev->class & 0x5))
 			return;
 
-			if (io_apic_assign_pci_irqs)
-				msg = " Probably buggy MP table.";
-			else if (pci_probe & PCI_BIOS_IRQ_SCAN)
-				msg = "";
-			else
-				msg = " Please try using pci=biosirq.";
-			printk(KERN_WARNING "PCI: No IRQ known for interrupt pin %c of device %s.%s\n",
-			       'A' + pin - 1, dev->slot_name, msg);
+		if (io_apic_assign_pci_irqs)
+			msg = " Probably buggy MP table.";
+		else if (pci_probe & PCI_BIOS_IRQ_SCAN)
+			msg = "";
+		else
+			msg = " Please try using pci=biosirq.";
+		printk(KERN_WARNING "PCI: No IRQ known for interrupt pin %c of device %s.%s\n",
+		       'A' + pin - 1, dev->slot_name, msg);
 	}
 	/* VIA bridges use interrupt line for apic/pci steering across
 	   the V-Link */
--- linux-2.4.22/arch/x86_64/kernel/pci-pc.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/pci-pc.c	2003-10-10 11:17:45.000000000 +0200
@@ -23,9 +23,11 @@
 #include <asm/segment.h>
 #include <asm/io.h>
 #include <asm/mpspec.h>
+#include <asm/proto.h>
 
 #include "pci-x86_64.h"
 
+int use_acpi_pci = 1;
 unsigned int pci_probe = PCI_PROBE_CONF1 | PCI_PROBE_CONF2;
 
 int pcibios_last_bus = -1;
@@ -588,15 +590,15 @@ void __devinit pcibios_init(void)
 
 	printk(KERN_INFO "PCI: Probing PCI hardware\n");
 #ifdef CONFIG_ACPI_PCI
- 	if (!acpi_pci_irq_init())
+ 	if (!acpi_disabled && use_acpi_pci && !acpi_pci_irq_init())
  		pci_using_acpi_prt = 1;
 #endif
  	if (!pci_using_acpi_prt) {
  		pci_root_bus = pcibios_scan_root(0);
-	pcibios_irq_init();
-	pci_scan_mptable(); 
-	pcibios_fixup_peer_bridges();
-	pcibios_fixup_irqs();
+		pcibios_irq_init();
+		pci_scan_mptable(); 
+		pcibios_fixup_peer_bridges();
+		pcibios_fixup_irqs();
  	}
 
 	pcibios_resource_survey();
@@ -661,7 +663,7 @@ int pcibios_enable_device(struct pci_dev
 		return err;
 
 #ifdef CONFIG_ACPI_PCI
-	if (pci_using_acpi_prt) {
+	if (use_acpi_pci && pci_using_acpi_prt) {
 		acpi_pci_irq_enable(dev);
 		return 0;
 	}
--- linux-2.4.22/arch/x86_64/kernel/process.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/process.c	2003-10-10 11:17:45.000000000 +0200
@@ -9,7 +9,7 @@
  *  X86-64 port
  *	Andi Kleen.
  * 
- *  $Id: process.c,v 1.70 2003/06/09 05:18:21 ak Exp $
+ *  $Id: process.c,v 1.74 2003/08/13 13:43:16 ak Exp $
  */
 
 /*
@@ -168,7 +168,7 @@ static enum { 
 static int reboot_mode = 0; 
 
 /* reboot=b[ios] | t[riple] | k[bd] [, [w]arm | [c]old]
-   bios	  Use the CPU reboto vector for warm reset
+   bios	  Use the CPU reboot vector for warm reset
    warm   Don't set the cold reboot flag
    cold   Set the cold reboto flag
    triple Force a triple fault (init)
@@ -179,7 +179,7 @@ static int __init reboot_setup(char *str
 	for (;;) {
 		switch (*str) {
 		case 'w': 
-			reboot_mode = 0x1234;
+			reboot_mode = 0x1234; 
 			break;
 
 		case 'c':
@@ -191,7 +191,7 @@ static int __init reboot_setup(char *str
 		case 'k':
 			reboot_type = *str;
 			break;
-		}
+		} 
 		if((str = strchr(str,',')) != NULL)
 			str++;
 		else
@@ -227,7 +227,7 @@ static void reboot_warm(void)
 		      [target] "b" (WARMBOOT_TRAMP));
 }
 
-static inline void kb_wait(void)
+static void kb_wait(void)
 {
 	int i;
 
@@ -242,7 +242,7 @@ static void smp_halt(void)
 {
 	int cpuid = safe_smp_processor_id(); 
 	static int first_entry = 1;
-	
+
 	if (first_entry) { 
 		first_entry = 0;
 		smp_call_function((void *)machine_restart, NULL, 1, 0);		
@@ -252,9 +252,10 @@ static void smp_halt(void)
 
 	/* AP calling this. Just halt */
 	if (cpuid != boot_cpu_id) { 
-		for (;;)
+		printk("CPU %d SMP halt\n", cpuid); 
+		for (;;) 
 			asm("hlt");
-	}
+	} 
 
 	/* Wait for all other CPUs to have run smp_stop_cpu */
 	while (cpu_online_map) 
@@ -281,7 +282,7 @@ void machine_restart(char * __unused)
 	/* Tell the BIOS if we want cold or warm reboot */
 	*((unsigned short *)__va(0x472)) = reboot_mode;
 
-	for (;;) {
+	for (;;) { 
 		/* Could also try the reset bit in the Hammer NB */
 		switch (reboot_type) { 
 		case BOOT_BIOS:
@@ -289,19 +290,19 @@ void machine_restart(char * __unused)
 
 		case BOOT_KBD:
 			/* force cold reboot to reinit all hardware*/
-		for (i=0; i<100; i++) {
-			kb_wait();
-			udelay(50);
-			outb(0xfe,0x64);         /* pulse reset low */
-			udelay(50);
-		}
+			for (i=0; i<100; i++) {
+				kb_wait();
+				udelay(50);
+				outb(0xfe,0x64);         /* pulse reset low */
+				udelay(50);
+			}
 			
 		case BOOT_TRIPLE: 
 			/* force cold reboot to reinit all hardware*/
 			*((unsigned short *)__va(0x472)) = 0;
 
-		__asm__ __volatile__("lidt %0": :"m" (no_idt));
-		__asm__ __volatile__("int3");
+			__asm__ __volatile__("lidt %0": :"m" (no_idt));
+			__asm__ __volatile__("int3");
 
 			reboot_type = BOOT_KBD;
 			break;
@@ -553,20 +554,20 @@ struct task_struct *__switch_to(struct t
 			 * is allways mapped to the Null selector
 			 */
 			if (fsindex)
-			prev->fs = 0; 
+				prev->fs = 0;
 		}
 		/* when next process has a 64bit base use it */
 		if (next->fs) 
 			wrmsrl(MSR_FS_BASE, next->fs); 
 		prev->fsindex = fsindex;
 	}
-	{
+	{ 
 		unsigned gsindex;
 		asm volatile("movl %%gs,%0" : "=g" (gsindex)); 
 		if (unlikely((gsindex | next->gsindex) || prev->gs)) {
 			load_gs_index(next->gsindex);
 			if (gsindex)
-			prev->gs = 0;				
+				prev->gs = 0;
 		}
 		if (next->gs)
 			wrmsrl(MSR_KERNEL_GS_BASE, next->gs); 
@@ -721,17 +722,17 @@ asmlinkage long sys_arch_prctl(int code,
 	case ARCH_SET_GS:
 		if (addr >= TASK_SIZE) 
 			return -EPERM; 
-		asm volatile("movl %0,%%gs" :: "r" (0)); 
+		asm volatile("movl %0,%%gs" :: "r" (0));
 		current->thread.gsindex = 0;
 		current->thread.gs = addr;
-		ret = checking_wrmsrl(MSR_KERNEL_GS_BASE, addr); 
+		ret = checking_wrmsrl(MSR_KERNEL_GS_BASE, addr);
 		break;
 	case ARCH_SET_FS:
 		/* Not strictly needed for fs, but do it for symmetry
 		   with gs. */
 		if (addr >= TASK_SIZE)
-			return -EPERM; 
-		asm volatile("movl %0,%%fs" :: "r" (0)); 
+			return -EPERM;
+		asm volatile("movl %0,%%fs" :: "r" (0));
 		current->thread.fsindex = 0;
 		current->thread.fs = addr;
 		ret = checking_wrmsrl(MSR_FS_BASE, addr); 
--- linux-2.4.22/arch/x86_64/kernel/setup.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/setup.c	2003-10-10 11:17:45.000000000 +0200
@@ -295,6 +295,11 @@ void __init setup_arch(char **cmdline_p)
 #endif
 
 	paging_init();
+#if !defined(CONFIG_SMP) && defined(CONFIG_X86_IO_APIC)
+	extern void check_ioapic(void);
+	check_ioapic();
+#endif
+
 #ifdef CONFIG_ACPI_BOOT
 	/*
 	 * Parse the ACPI tables for possible boot-time SMP configuration.
@@ -377,11 +382,14 @@ static void __init display_cacheinfo(stro
 		c->x86_cache_size=(ecx>>24)+(edx>>24);	
 		if (n >= 0x80000006) {
 			printk(KERN_INFO "CPU: L2 Cache: %dK (%d bytes/line/%d way)\n",
-			       ecx_2>>16, ecx_2&0xFF, (ecx_2>>12)&0xf);
+			       ecx_2>>16, ecx_2&0xFF, 
+			       /*  use bits[15:13] as power of 2 for # of ways */
+			       1 << ((ecx>>13) & 0x7) 
+			       /* Direct and Full associative L2 are very unlikely */);
 			c->x86_cache_size = ecx_2 >> 16;
-		c->x86_tlbsize = ((ebx>>16)&0xff) + ((ebx_2>>16)&0xfff) + 
-			(ebx&0xff) + ((ebx_2)&0xfff);
-	}
+			c->x86_tlbsize = ((ebx>>16)&0xff) + ((ebx_2>>16)&0xfff) + 
+				(ebx&0xff) + ((ebx_2)&0xfff);
+		}
 		if (n >= 0x80000007)
 			cpuid(0x80000007, &dummy, &dummy, &dummy, &c->x86_power); 
 		if (n >= 0x80000008) {
@@ -466,7 +474,7 @@ void __init identify_cpu(struct cpuinfo_
 		c->x86_model = (tfms >> 4) & 15;
 		if (c->x86 == 0xf) { /* extended */
 			c->x86 += (tfms >> 20) & 0xff;
-			c->x86_model += ((tfms >> 16) & 0xF) << 4; 
+			c->x86_model += ((tfms >> 16) & 0xF) << 4;
 		}
 		c->x86_mask = tfms & 15;
 		if (c->x86_capability[0] & (1<<19)) 
--- linux-2.4.22/arch/x86_64/kernel/setup64.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/setup64.c	2003-10-10 11:17:45.000000000 +0200
@@ -3,7 +3,7 @@
  * Copyright (C) 1995  Linus Torvalds
  * Copyright 2001, 2002 SuSE Labs / Andi Kleen.
  * See setup.c for older changelog.
- * $Id: setup64.c,v 1.23 2003/05/16 14:22:27 ak Exp $
+ * $Id: setup64.c,v 1.25 2003/07/11 15:58:47 ak Exp $
  */ 
 #include <linux/config.h>
 #include <linux/init.h>
--- linux-2.4.22/arch/x86_64/kernel/signal.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/signal.c	2003-10-10 11:17:45.000000000 +0200
@@ -8,7 +8,7 @@
  *  2000-06-20  Pentium III FXSR, SSE support by Gareth Hughes
  *  2000-2001   x86-64 support by Andi Kleen
  * 
- *  $Id: signal.c,v 1.42 2003/02/24 21:06:02 ak Exp $
+ *  $Id: signal.c,v 1.43 2003/09/06 18:10:44 ak Exp $
  */
 
 #include <linux/sched.h>
@@ -70,6 +70,10 @@ int copy_siginfo_to_user(siginfo_t *to, 
 			err |= __put_user(from->si_status, &to->si_status);
 		default:
 			err |= __put_user(from->si_uid, &to->si_uid);
+			break;			
+		case __SI_POLL >> 16:
+			err |= __put_user(from->si_band, &to->si_band); 
+			err |= __put_user(from->si_fd, &to->si_fd); 
 			break;
 		/* case __SI_RT: This is not generated by the kernel as of now.  */
 		}
--- linux-2.4.22/arch/x86_64/kernel/smp.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/smp.c	2003-10-10 11:17:45.000000000 +0200
@@ -504,7 +504,7 @@ static void smp_really_stop_cpu(void *du
 	smp_stop_cpu(); 
 	for (;;) 
 		asm("hlt"); 
-}
+} 
 
 /*
  * this function calls the 'stop' function on all other CPUs in the system.
--- linux-2.4.22/arch/x86_64/kernel/smpboot.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/smpboot.c	2003-10-10 11:17:45.000000000 +0200
@@ -50,6 +50,7 @@
 #include <asm/kdebug.h>
 #include <asm/timex.h>
 #include <asm/proto.h>
+#include <asm/acpi.h>
 
 /* Setup configured maximum number of CPUs to activate */
 static int max_cpus = -1;
@@ -384,12 +385,12 @@ void __init smp_callin(void)
 
 	Dprintk("CALLIN, before setup_local_APIC().\n");
 	setup_local_APIC();
-
+	
 	if (nmi_watchdog == NMI_IO_APIC) {
 		disable_8259A_irq(0);
 		enable_NMI_through_LVT0(NULL);
 		enable_8259A_irq(0);
-	}
+	} 
 
 	sti();
 
@@ -863,7 +864,7 @@ void __init smp_boot_cpus(void)
 	 * If we couldnt find an SMP configuration at boot time,
 	 * get out of here now!
 	 */
-	if (!smp_found_config) {
+	if (!smp_found_config && !acpi_lapic) {
 		printk(KERN_NOTICE "SMP motherboard not detected.\n");
 		io_apic_irqs = 0;
 		cpu_online_map = phys_cpu_present_map = 1;
@@ -907,10 +908,8 @@ void __init smp_boot_cpus(void)
 	if (!max_cpus) {
 		smp_found_config = 0;
 		printk(KERN_INFO "SMP mode deactivated, forcing use of dummy APIC emulation.\n");
-		io_apic_irqs = 0;
 		cpu_online_map = phys_cpu_present_map = 1;
 		smp_num_cpus = 1;
-		apic_disabled = 1;
 		goto smp_done;
 	}
 
@@ -946,7 +945,7 @@ void __init smp_boot_cpus(void)
 		 * Make sure we unmap all failed CPUs
 		 */
 		if ((x86_apicid_to_cpu[apicid] == -1) &&
-				(phys_cpu_present_map & (1 << apicid)))
+		    (phys_cpu_present_map & (1 << apicid)))
 			printk("phys CPU #%d not responding - cannot use it.\n",apicid);
 		else if (cpu > maxcpu) 
 			maxcpu = cpu; 
@@ -1012,6 +1011,9 @@ void __init smp_boot_cpus(void)
 	if (cpu_has_tsc && cpucount)
 		synchronize_tsc_bp();
 
+	if (nmi_watchdog != 0) 
+		check_nmi_watchdog(); 
+
 smp_done:
 	zap_low_mappings();
 	time_init_smp();
--- linux-2.4.22/arch/x86_64/kernel/suspend.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/suspend.c	2003-10-10 11:17:45.000000000 +0200
@@ -5,6 +5,9 @@
  *
  * Copyright (c) 2002 Pavel Machek <pavel@suse.cz>
  * Copyright (c) 2001 Patrick Mochel <mochel@osdl.org>
+ * 
+ * AK currently useless for 24 because the core ACPI code doesn't support S3.
+ *    and most of the infrastructure is missing.
  */
 
 #include <linux/config.h>
--- linux-2.4.22/arch/x86_64/kernel/sys_x86_64.c.amd64-updates	2003-10-10 10:32:23.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/sys_x86_64.c	2003-10-10 11:17:45.000000000 +0200
@@ -101,7 +101,7 @@ unsigned long arch_get_unmapped_area(str
 		if (!addr) 
 			addr = TASK_UNMAPPED_64; 
 		end = TASK_SIZE; 
-		}
+	} 
 
 	if (len > end)
 		return -ENOMEM;
@@ -140,3 +140,17 @@ asmlinkage long wrap_sys_shmat(int shmid
 	unsigned long raddr;
 	return sys_shmat(shmid,shmaddr,shmflg,&raddr) ?: raddr;
 } 
+
+asmlinkage long sys_time64(long * tloc)
+{
+	struct timeval now; 
+	int i; 
+
+	do_gettimeofday(&now);
+	i = now.tv_sec;
+	if (tloc) {
+		if (put_user(i,tloc))
+			i = -EFAULT;
+	}
+	return i;
+}
--- linux-2.4.22/arch/x86_64/kernel/time.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/time.c	2003-10-10 11:17:45.000000000 +0200
@@ -41,10 +41,10 @@ struct timeval __xtime __section_xtime;
 struct timezone __sys_tz __section_sys_tz;
 
 static inline void rdtscll_sync(unsigned long *tsc)
-{
+{ 
 	sync_core();
 	rdtscll(*tsc);
-}
+} 
 
 /*
  * do_gettimeoffset() returns microseconds since last timer interrupt was
@@ -85,11 +85,11 @@ void do_gettimeofday(struct timeval *tv)
 		sequence = __vxtime_sequence[1];
 		rmb();
 
-	sec = xtime.tv_sec;
-	usec = xtime.tv_usec
-		+ (jiffies - wall_jiffies) * tick
+		sec = xtime.tv_sec;
+		usec = xtime.tv_usec
+			+ (jiffies - wall_jiffies) * tick
 			+ do_gettimeoffset();
-
+		
 		rmb(); 
 	} while (sequence != __vxtime_sequence[0]);
 
@@ -531,7 +531,7 @@ void __init time_init(void)
         printk(KERN_INFO "time.c: Detected %ld.%06ld MHz %s timer.\n",
 		vxtime_hz / 1000000, vxtime_hz % 1000000, timename);
 	printk(KERN_INFO "time.c: Detected %d.%03d MHz TSC timer.\n",
-			cpu_khz / 1000, cpu_khz % 1000);
+		cpu_khz / 1000, cpu_khz % 1000);
 }
 
 void __init time_init_smp(void)
@@ -556,7 +556,7 @@ void __init time_init_smp(void)
 		} else { 
 			timetype = "PIT/TSC";
 			vxtime.mode = VXTIME_TSC;
-	}
+		} 
 	}
 	printk(KERN_INFO "time.c: Using %s based timekeeping.\n", timetype);
 }
--- linux-2.4.22/arch/x86_64/kernel/traps.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/traps.c	2003-10-10 11:17:45.000000000 +0200
@@ -7,7 +7,7 @@
  *  Pentium III FXSR, SSE support
  *	Gareth Hughes <gareth@valinux.com>, May 2000
  *
- *  $Id: traps.c,v 1.66 2003/06/09 05:18:21 ak Exp $
+ *  $Id: traps.c,v 1.69 2003/09/21 04:54:09 ak Exp $
  */
 
 /*
@@ -81,7 +81,7 @@ extern char iret_address[];
 
 struct notifier_block *die_chain;
 
-int kstack_depth_to_print = 40;
+int kstack_depth_to_print = 12;
 
 #ifdef CONFIG_KALLSYMS
 #include <linux/kallsyms.h> 
@@ -342,18 +342,25 @@ void handle_BUG(struct pt_regs *regs)
 spinlock_t die_lock = SPIN_LOCK_UNLOCKED;
 int die_owner = -1;
 
-void die(const char * str, struct pt_regs * regs, long err)
+void __die(const char * str, struct pt_regs * regs, long err)
 {
-	unsigned long flags;
-	int cpu;
-	console_verbose();
-	bust_spinlocks(1);
-	handle_BUG(regs);		
 	printk(KERN_EMERG "%s: %04lx\n", str, err & 0xffff);
  	notify_die(DIE_OOPS, (char *)str, regs, err, 255, SIGSEGV);
+	show_registers(regs);
+	/* Execute summary in case the oops scrolled away */
+	printk(KERN_EMERG "RIP "); 
+	printk_address(regs->rip); 
+	printk(" RSP <%016lx>\n", regs->rsp); 
+}
+
+void prepare_die(unsigned long *flags)
+{ 
+	int cpu;
+	console_verbose();
+	bust_spinlocks(1); 
 	cpu = safe_smp_processor_id(); 
 	/* racy, but better than risking deadlock. */ 
-	__save_flags(flags); 
+	__save_flags(*flags); 
 	__cli();
 	if (!spin_trylock(&die_lock)) { 
 		if (cpu == die_owner) 
@@ -362,9 +369,23 @@ void die(const char * str, struct pt_reg
 			spin_lock(&die_lock); 
 	}
 	die_owner = cpu; 
-	show_registers(regs);
+} 
+
+void exit_die(unsigned long flags)
+{
+	die_owner = -1;
+	spin_unlock_irqrestore(&die_lock, flags); 		
+	__sti();	/* back scroll should work */
 	bust_spinlocks(0);
-	spin_unlock_irqrestore(&die_lock, flags);
+}
+
+void die(const char * str, struct pt_regs * regs, long err)
+{
+	unsigned long flags;
+	prepare_die(&flags);
+	handle_BUG(regs);		
+	__die(str, regs, err);
+	exit_die(flags);
 	do_exit(SIGSEGV);
 }
 
--- linux-2.4.22/arch/x86_64/kernel/vsyscall.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/vsyscall.c	2003-10-10 11:17:45.000000000 +0200
@@ -104,7 +104,7 @@ static force_inline void do_get_tz(struc
 static long __vsyscall(0) vgettimeofday(struct timeval * tv, struct timezone * tz)
 {
 	if (tv)
-			do_vgettimeofday(tv);
+		do_vgettimeofday(tv);
 
 	if (tz)
 		do_get_tz(tz);
--- linux-2.4.22/arch/x86_64/kernel/x8664_ksyms.c.amd64-updates	2003-10-10 10:32:23.000000000 +0200
+++ linux-2.4.22/arch/x86_64/kernel/x8664_ksyms.c	2003-10-10 11:17:45.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/string.h>
 #include <linux/tty.h>
 #include <linux/string.h>
+#include <linux/nmi.h>
 
 #include <asm/semaphore.h>
 #include <asm/processor.h>
@@ -224,4 +225,6 @@ EXPORT_SYMBOL(fake_node);
 #endif
 
 extern void int_ret_from_sys_call(void);
-EXPORT_SYMBOL(int_ret_from_sys_call); 
+EXPORT_SYMBOL_NOVERS(int_ret_from_sys_call); 
+
+EXPORT_SYMBOL(touch_nmi_watchdog);
--- linux-2.4.22/arch/x86_64/ia32/fpu32.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/ia32/fpu32.c	2003-10-10 11:17:45.000000000 +0200
@@ -155,7 +155,7 @@ int restore_i387_ia32(struct task_struct
 				     &buf->_fxsr_env[0],
 				     sizeof(struct i387_fxsave_struct)))
 			return -1;
-	tsk->thread.i387.fxsave.mxcsr &= 0xffbf;
+		tsk->thread.i387.fxsave.mxcsr &= 0xffbf;
 	}
 	tsk->used_math = 1;
 	return convert_fxsr_from_user(&tsk->thread.i387.fxsave, buf);
--- linux-2.4.22/arch/x86_64/ia32/ia32_binfmt.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/ia32/ia32_binfmt.c	2003-10-10 11:17:45.000000000 +0200
@@ -28,7 +28,6 @@ struct elf_phdr; 
 
 #define ELF_NAME "elf/i386"
 
-#define IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
 #define IA32_STACK_TOP IA32_PAGE_OFFSET
 #define ELF_ET_DYN_BASE		(IA32_PAGE_OFFSET/3 + 0x1000000)
 
@@ -243,7 +242,7 @@ int ia32_setup_arg_pages(struct linux_bi
 	{
 		mpnt->vm_mm = current->mm;
 		mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;
-		mpnt->vm_end = IA32_STACK_TOP;
+		mpnt->vm_end = IA32_STACK_TOP;		
 		mpnt->vm_flags = vm_stack_flags32; 
 		mpnt->vm_page_prot = (mpnt->vm_flags & VM_EXEC) ? 
 			PAGE_COPY_EXEC : PAGE_COPY;
--- linux-2.4.22/arch/x86_64/ia32/ia32_ioctl.c.amd64-updates	2003-10-10 10:32:36.000000000 +0200
+++ linux-2.4.22/arch/x86_64/ia32/ia32_ioctl.c	2003-10-10 11:17:45.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Id: ia32_ioctl.c,v 1.34 2003/05/08 06:34:01 ak Exp $
+/* $Id: ia32_ioctl.c,v 1.37 2003/08/20 11:00:23 ak Exp $
  * ioctl32.c: Conversion between 32bit and 64bit native ioctls.
  *
  * Copyright (C) 1997-2000  Jakub Jelinek  (jakub@redhat.com)
@@ -482,7 +482,7 @@ static int dev_ifname32(unsigned int fd,
 	strncpy(ifr32.ifr_name, dev->name, sizeof(ifr32.ifr_name)-1);
 	ifr32.ifr_name[sizeof(ifr32.ifr_name)-1] = 0; 
 	dev_put(dev);
-	
+
 	err = copy_to_user((struct ifreq32 *)arg, &ifr32, sizeof(struct ifreq32));
 	return (err ? -EFAULT : 0);
 }
@@ -901,12 +901,12 @@ struct fb_fix_screeninfo32 {
 };
 
 struct fb_cmap32 {
-	__u32			start;
-	__u32			len;
-	__kernel_caddr_t32	red;
-	__kernel_caddr_t32	green;
-	__kernel_caddr_t32	blue;
-	__kernel_caddr_t32	transp;
+       __u32                   start;
+       __u32                   len;
+       __kernel_caddr_t32      red;
+       __kernel_caddr_t32      green;
+       __kernel_caddr_t32      blue;
+       __kernel_caddr_t32      transp;
 };
 
 static int fb_ioctl_trans(unsigned int fd, unsigned int cmd, unsigned long arg)
@@ -1520,7 +1520,7 @@ out:
 	if (sg_io64.sbp)
 		kfree(sg_io64.sbp);
 	if (sg_io64.dxferp && sg_io64.iovec_count)
-			free_sg_iovec(&sg_io64);
+		free_sg_iovec(&sg_io64);
 	return err;
 }
 
@@ -2147,7 +2147,7 @@ static int do_atm_iobuf(unsigned int fd,
 	err = sys_ioctl (fd, cmd, (unsigned long)&iobuf);      
 	set_fs (old_fs);
         if(!err)
-	err = __put_user(iobuf.length, &(((struct atm_iobuf32*)arg)->length));
+		err = __put_user(iobuf.length, &(((struct atm_iobuf32*)arg)->length));
 
 	return err;
 }
@@ -2180,7 +2180,7 @@ static int do_atmif_sioc(unsigned int fd
         err = sys_ioctl (fd, cmd, (unsigned long)&sioc);	
         set_fs (old_fs);
 	if (!err)
-        err = __put_user(sioc.length, &(((struct atmif_sioc32*)arg)->length));
+		err = __put_user(sioc.length, &(((struct atmif_sioc32*)arg)->length));
 	return err;
 }
 
@@ -2476,6 +2476,9 @@ static int do_lvm_ioctl(unsigned int fd,
 	mm_segment_t old_fs;
 	void *karg = &u;
 
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
 	switch (cmd) {
 	case VG_STATUS:
 		v = kmalloc(sizeof(vg_t), GFP_KERNEL);
@@ -2704,14 +2707,14 @@ struct blkpg_ioctl_arg32 {
 	int datalen;
 	u32 data;
 };
-
+                                
 static int blkpg_ioctl_trans(unsigned int fd, unsigned int cmd, struct blkpg_ioctl_arg32 *arg)
 {
 	struct blkpg_ioctl_arg a;
 	struct blkpg_partition p;
 	int err;
 	mm_segment_t old_fs = get_fs();
-
+	
 	err = get_user(a.op, &arg->op);
 	err |= __get_user(a.flags, &arg->flags);
 	err |= __get_user(a.datalen, &arg->datalen);
@@ -2828,7 +2831,7 @@ static int serial_struct_ioctl(unsigned 
 		ss.iomem_base = (void *)((unsigned long)ss.iomem_base & 0xffffffff);
 	}
 	set_fs(KERNEL_DS);
-		err = sys_ioctl(fd,cmd,(unsigned long)(&ss)); 
+	err = sys_ioctl(fd,cmd,(unsigned long)(&ss)); 
 	set_fs(oldseg);
 	if (cmd == TIOCGSERIAL && err >= 0) { 
 		if (__copy_to_user(ss32,&ss,offsetof(SS,iomem_base)) ||
@@ -2838,7 +2841,7 @@ static int serial_struct_ioctl(unsigned 
 		    __put_user(ss.iomem_reg_shift, &ss32->iomem_reg_shift) || 
 		    __put_user(ss.port_high, &ss32->port_high))
 			return -EFAULT;
-	} 
+	}
 	return err;	
 }
 
@@ -2903,19 +2906,19 @@ static int vfat_ioctl32(unsigned fd, uns
 #define RTC_EPOCH_SET32		_IOW('p', 0x0e, unsigned)	 /* Set epoch       */
 
 static int rtc32_ioctl(unsigned fd, unsigned cmd, unsigned long arg) 
-{
+{ 
 	unsigned long val;
 	mm_segment_t oldfs = get_fs(); 
 	int ret; 
 	
 	switch (cmd) { 
 	case RTC_IRQP_READ32: 
-	set_fs(KERNEL_DS);
+		set_fs(KERNEL_DS); 
 		ret = sys_ioctl(fd, RTC_IRQP_READ, (unsigned long)&val); 
 		set_fs(oldfs); 
 		if (!ret)
 			ret = put_user(val, (unsigned int*) arg); 
-	return ret; 
+		return ret; 
 
 	case RTC_IRQP_SET32: 
 		cmd = RTC_EPOCH_SET; 
@@ -3292,7 +3295,7 @@ static int do_usbdevfs_urb(unsigned int 
 		/* XXX Shit, this doesn't work for async URBs :-( XXX */
 		if (put_urb32(kurb, uurb)) {
 			err = -EFAULT;
-		}
+		} 
 	}
 
 out:
@@ -3541,6 +3544,7 @@ COMPATIBLE_IOCTL(TIOCSCTTY)
 COMPATIBLE_IOCTL(TIOCGPTN)
 COMPATIBLE_IOCTL(TIOCSPTLCK)
 COMPATIBLE_IOCTL(TIOCSERGETLSR)
+COMPATIBLE_IOCTL(FIOQSIZE)
 /* Big F */
 COMPATIBLE_IOCTL(FBIOGET_VSCREENINFO)
 COMPATIBLE_IOCTL(FBIOPUT_VSCREENINFO)
@@ -4422,6 +4426,9 @@ int register_ioctl32_conversion(unsigned
 	struct ioctl_trans *t;
 	unsigned long hash = ioctl32_hash(cmd);
 
+	if (handler == NULL)
+		handler = (void *)sys_ioctl; 
+
 	lock_kernel(); 
 	for (t = (struct ioctl_trans *)ioctl32_hash_table[hash];
 	     t;
@@ -4429,9 +4436,9 @@ int register_ioctl32_conversion(unsigned
 		if (t->cmd == cmd) {
 			printk("Trying to register duplicated ioctl32 handler %x\n", cmd);
 			unlock_kernel();
-			return -EINVAL;
-		}
-	}
+			return -EINVAL; 
+		} 			
+	} 
 
 	if (ioctl_free_list) { 
 		t = ioctl_free_list; 
@@ -4440,8 +4447,8 @@ int register_ioctl32_conversion(unsigned
 		t = kmalloc(sizeof(struct ioctl_trans), GFP_KERNEL); 
 		if (!t) { 
 			unlock_kernel();
-		return -ENOMEM;
-	}
+			return -ENOMEM;
+		}
 	}
 	
 	t->next = NULL;
@@ -4484,10 +4491,10 @@ int unregister_ioctl32_conversion(unsign
 			printk("%p tried to unregister builtin ioctl %x\n",
 			       __builtin_return_address(0), cmd);
 		} else { 
-		ioctl32_hash_table[hash] = t->next;
+			ioctl32_hash_table[hash] = t->next;
 			free_ioctl(t); 
 			unlock_kernel();
-		return 0;
+			return 0;
 		}
 	} 
 	while (t->next) {
@@ -4498,11 +4505,11 @@ int unregister_ioctl32_conversion(unsign
 				       __builtin_return_address(0), cmd);
 				goto out;
 			} else { 
-			t->next = t1->next;
+				t->next = t1->next;
 				free_ioctl(t1); 
 				unlock_kernel();
-			return 0;
-		}
+				return 0;
+			}
 		}
 		t = t1;
 	}
@@ -4563,7 +4570,7 @@ asmlinkage long sys32_ioctl(unsigned int
 			       "cmd(%08x){%s} arg(%08x) on %s\n",
 			       current->comm, current->pid,
 			       (int)fd, (unsigned int)cmd, buf, (unsigned int)arg,
-			       IS_ERR(fn) ? "???" : fn);
+			       fn);
 			if (path) 
 				free_page((unsigned long)path); 
 		}
--- linux-2.4.22/arch/x86_64/ia32/ia32_signal.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/ia32/ia32_signal.c	2003-10-10 11:17:45.000000000 +0200
@@ -7,7 +7,7 @@
  *  2000-06-20  Pentium III FXSR, SSE support by Gareth Hughes
  *  2000-12-*   x86-64 compatibility mode signal handling by Andi Kleen
  * 
- *  $Id: ia32_signal.c,v 1.31 2003/03/12 08:22:12 ak Exp $
+ *  $Id: ia32_signal.c,v 1.32 2003/09/06 18:10:44 ak Exp $
  */
 
 #include <linux/sched.h>
@@ -78,6 +78,10 @@ static int ia32_copy_siginfo_to_user(sig
 		default:
 			err |= __put_user(from->si_uid, &to->si_uid);
 			break;
+		case __SI_POLL >> 16:
+			err |= __put_user(from->si_band, &to->si_band); 
+			err |= __put_user(from->si_fd, &to->si_fd); 
+			break;
 		/* case __SI_RT: This is not generated by the kernel as of now.  */
 		}
 		return err;
@@ -115,11 +119,11 @@ sys32_sigaltstack(const stack_ia32_t *us
 	if (uss_ptr) {
 		u32 val32;
 		memset(&uss, 0, sizeof(stack_t));
-	if (!access_ok(VERIFY_READ,uss_ptr,sizeof(stack_ia32_t)) ||
+		if (!access_ok(VERIFY_READ,uss_ptr,sizeof(stack_ia32_t)) ||
 		    __get_user(val32, &uss_ptr->ss_sp) ||
 		    __get_user(uss.ss_flags, &uss_ptr->ss_flags) ||
 		    __get_user(uss.ss_size, &uss_ptr->ss_size))
-		return -EFAULT;
+			return -EFAULT;
 		uss.ss_sp = u32_to_ptr(val32);	
 	}
 	seg = get_fs(); 
@@ -343,14 +347,14 @@ ia32_setup_sigcontext(struct sigcontext_
 
 	tmp = save_i387_ia32(current, fpstate, regs, 0);
 	if (tmp < 0)
-	  err = -EFAULT;
+		err = -EFAULT;
 	else { 
 		/* trigger finit in signal handler */
 		current->used_math = 0;
 		stts();
-	  err |= __put_user((u32)(u64)(tmp ? fpstate : NULL), &sc->fpstate);
+		err |= __put_user((u32)(u64)(tmp ? fpstate : NULL), &sc->fpstate);
 	} 
-
+	  
 	/* non-iBCS2 extensions.. */
 	err |= __put_user(mask, &sc->oldmask);
 	err |= __put_user(current->thread.cr2, &sc->cr2);
--- linux-2.4.22/arch/x86_64/ia32/ia32entry.S.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/ia32/ia32entry.S	2003-10-10 11:17:45.000000000 +0200
@@ -3,7 +3,7 @@
  * 		
  * Copyright 2000,2001 Andi Kleen, SuSE Labs.
  * 
- * $Id: ia32entry.S,v 1.40 2003/04/03 09:46:54 ak Exp $ 		
+ * $Id: ia32entry.S,v 1.41 2003/09/22 04:25:53 ak Exp $ 		
  */		 
 
 #include <asm/calling.h>
@@ -256,10 +256,10 @@ ia32_sys_call_table:
 	.quad sys32_adjtimex
 	.quad sys32_mprotect		/* 125 */
 	.quad sys32_sigprocmask
-	.quad sys32_module_warning	/* create_module */
-	.quad sys32_module_warning	/* init_module */
-	.quad sys32_module_warning	/* delete module */
-	.quad sys32_module_warning	/* 130  get_kernel_syms */
+	.quad sys32_create_module
+	.quad sys32_init_module
+	.quad sys32_delete_module
+	.quad sys32_get_kernel_syms 	/* 130 */
 	.quad ni_syscall	/* quotactl */ 
 	.quad sys_getpgid
 	.quad sys_fchdir
@@ -296,7 +296,7 @@ ia32_sys_call_table:
 	.quad sys_setresuid16
 	.quad sys_getresuid16	/* 165 */
 	.quad sys32_vm86_warning	/* vm86 */ 
-	.quad quiet_ni_syscall	/* query_module */
+	.quad sys32_query_module
 	.quad sys_poll
 	.quad sys32_nfsservctl
 	.quad sys_setresgid16	/* 170 */
@@ -354,7 +354,7 @@ ia32_sys_call_table:
 	.quad sys_ni_syscall	/* tux */
 	.quad sys_ni_syscall    /* security */
 	.quad sys_gettid	
-	.quad sys_readahead	/* 225 */ 
+	.quad sys_readahead	/* 225 */
 	.quad quiet_ni_syscall  /* xattr syscalls 226-237 */
 	.quad quiet_ni_syscall
 	.quad quiet_ni_syscall
--- linux-2.4.22/arch/x86_64/ia32/ipc32.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/ia32/ipc32.c	2003-10-10 11:17:45.000000000 +0200
@@ -16,6 +16,8 @@
 
 #include <asm/ia32.h>
 
+extern int sem_ctls[];
+
 /*
  * sys32_ipc() is the de-multiplexer for the SysV IPC calls in 32bit emulation..
  *
@@ -163,6 +165,7 @@ struct ipc_kludge {
 #define SEMOP		 1
 #define SEMGET		 2
 #define SEMCTL		 3
+#define SEMTIMEDOP       4
 #define MSGSND		11
 #define MSGRCV		12
 #define MSGGET		13
@@ -638,7 +641,27 @@ sys32_ipc (u32 call, int first, int seco
 	switch (call) {
 	      case SEMOP:
 		/* struct sembuf is the same on 32 and 64bit :)) */
-		return sys_semop(first, (struct sembuf *)AA(ptr), second);
+		return sys_semtimedop(first, (struct sembuf *)AA(ptr), second, NULL);
+	      case SEMTIMEDOP: { 
+		int err;
+		mm_segment_t oldfs = get_fs();
+		struct timespec32 *ts32 = (struct timespec32 *)AA(fifth);
+		struct timespec ts;
+		if ((unsigned)second > sem_ctls[2])
+			return -EINVAL;		
+		if (ts32) { 
+			if (get_user(ts.tv_sec, &ts32->tv_sec) ||
+				__get_user(ts.tv_nsec, &ts32->tv_nsec) ||
+				verify_area(VERIFY_READ, (void *)AA(ptr), 
+								second*sizeof(struct sembuf)))
+					return -EFAULT; 
+		} 			
+		set_fs(KERNEL_DS); 
+	 	err = sys_semtimedop(first, (struct sembuf *)AA(ptr), second,
+					ts32 ? &ts : NULL); 
+		set_fs(oldfs);
+		return err; 			
+	      }	
 	      case SEMGET:
 		return sys_semget(first, second, third);
 	      case SEMCTL:
@@ -663,9 +686,7 @@ sys32_ipc (u32 call, int first, int seco
 	      case SHMCTL:
 		return shmctl32(first, second, (void *)AA(ptr));
 
-	      default:
-		return -EINVAL;
 	}
-	return -EINVAL;
+	return -ENOSYS;
 }
 
--- linux-2.4.22/arch/x86_64/ia32/ptrace32.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/ia32/ptrace32.c	2003-10-10 11:17:45.000000000 +0200
@@ -35,11 +35,11 @@ static int putreg32(struct task_struct *
 
 	switch (regno) {
 	case offsetof(struct user32, regs.fs):
-        if (val && (val & 3) != 3) return -EIO;
-        child->thread.fs = val & 0xffff; 
+		if (val && (val & 3) != 3) return -EIO;
+		child->thread.fs = val & 0xffff; 
 		break;
 	case offsetof(struct user32, regs.gs):
-	    if (val && (val & 3) != 3) return -EIO;
+		if (val && (val & 3) != 3) return -EIO;
 		child->thread.gs = val & 0xffff;
 		break;
 	case offsetof(struct user32, regs.ds):
@@ -49,10 +49,10 @@ static int putreg32(struct task_struct *
 	case offsetof(struct user32, regs.es):
 		child->thread.es = val & 0xffff;
 		break;
-    case offsetof(struct user32, regs.ss):
+	case offsetof(struct user32, regs.ss):
 		if ((val & 3) != 3) return -EIO; 
-        stack[offsetof(struct pt_regs, ss)/8] = val & 0xffff;
-        break;
+        	stack[offsetof(struct pt_regs, ss)/8] = val & 0xffff;
+        	break;
 	case offsetof(struct user32, regs.cs):
 		if ((val & 3) != 3) return -EIO;
 		stack[offsetof(struct pt_regs, cs)/8] = val & 0xffff;
@@ -72,7 +72,7 @@ static int putreg32(struct task_struct *
 	case offsetof(struct user32, regs.eflags): 
 		stack[offsetof(struct pt_regs, eflags)/8] = val & 0x44dd5; 
 		break;
-
+		
 	case offsetof(struct user32, u_debugreg[4]): 
 	case offsetof(struct user32, u_debugreg[5]):
 		return -EIO;
@@ -178,7 +178,7 @@ static struct task_struct *find_target(i
 			goto out;
 		*err = ptrace_check_attach(child, request == PTRACE_KILL); 
 		if (*err < 0) 
-				goto out;
+			goto out;
 		return child; 
 	} 
 
@@ -316,7 +316,7 @@ asmlinkage long sys32_ptrace(long reques
 		ret = -EIO;
 		if (!access_ok(VERIFY_WRITE, u, sizeof(*u)))
 			break;
-			ret = -EFAULT;
+		ret = -EFAULT;
 		if (__copy_to_user(u, &child->thread.i387.fxsave, sizeof(*u)))
 			break;
 		ret = __put_user(childregs->cs, &u->fcs);
--- linux-2.4.22/arch/x86_64/ia32/socket32.c.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/ia32/socket32.c	2003-10-10 11:17:45.000000000 +0200
@@ -503,7 +503,6 @@ static int do_set_attach_filter(int fd, 
 		__u32 filter;
 	} *fprog32 = (struct sock_fprog32 *)optval;
 	struct sock_fprog kfprog;
-	unsigned int fsize;
 	mm_segment_t old_fs;
 	__u32 uptr;
 	int ret;
@@ -513,7 +512,7 @@ static int do_set_attach_filter(int fd, 
 		return -EFAULT;
 
 	kfprog.filter = (struct sock_filter *)A(uptr);
-
+	
 	if (verify_area(VERIFY_WRITE, kfprog.filter, kfprog.len*sizeof(struct sock_filter)))
 		return -EFAULT;
 
--- linux-2.4.22/arch/x86_64/ia32/sys_ia32.c.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/ia32/sys_ia32.c	2003-10-10 11:17:45.000000000 +0200
@@ -16,7 +16,7 @@
  *
  * This file assumes that there is a hole at the end of user address space.
  *
- * $Id: sys_ia32.c,v 1.58 2003/05/09 17:21:17 ak Exp $
+ * $Id: sys_ia32.c,v 1.64 2003/09/26 19:26:27 ak Exp $
  */
 
 #include <linux/config.h>
@@ -56,6 +56,7 @@
 #include <linux/rwsem.h>
 #include <linux/binfmts.h>
 #include <linux/init.h>
+#include <linux/highuid.h>
 #include <asm/mman.h>
 #include <asm/types.h>
 #include <asm/uaccess.h>
@@ -84,17 +85,23 @@
 #define low2highgid(gid) ((gid) == (u16)-1) ? (gid_t)-1 : (gid_t)(gid)
 extern int overflowuid,overflowgid; 
 
+typedef u16 old_uid_t;
+typedef u16 old_gid_t;
+
+#include "../../../kernel/uid16.c" 
 
 static int
 putstat(struct stat32 *ubuf, struct stat *kbuf)
 {
+	if (kbuf->st_size > 0x7fffffff)
+		return -EOVERFLOW;
 	if (verify_area(VERIFY_WRITE, ubuf, sizeof(struct stat32)) ||
 	    __put_user (kbuf->st_dev, &ubuf->st_dev) ||
 	    __put_user (kbuf->st_ino, &ubuf->st_ino) ||
 	    __put_user (kbuf->st_mode, &ubuf->st_mode) ||
 	    __put_user (kbuf->st_nlink, &ubuf->st_nlink) ||
-	    __put_user (kbuf->st_uid, &ubuf->st_uid) ||
-	    __put_user (kbuf->st_gid, &ubuf->st_gid) ||
+	    __put_user (high2lowuid(kbuf->st_uid), &ubuf->st_uid) ||
+	    __put_user (high2lowgid(kbuf->st_gid), &ubuf->st_gid) ||
 	    __put_user (kbuf->st_rdev, &ubuf->st_rdev) ||
 	    __put_user (kbuf->st_size, &ubuf->st_size) ||
 	    __put_user (kbuf->st_atime, &ubuf->st_atime) ||
@@ -118,9 +125,9 @@ sys32_newstat(char * filename, struct st
 	set_fs (KERNEL_DS);
 	ret = sys_newstat(filename, &s);
 	set_fs (old_fs);
-	if (putstat (statbuf, &s))
-		return -EFAULT;
-	return ret;
+	if (ret)
+		return ret;
+	return putstat(statbuf, &s);
 }
 
 extern asmlinkage long sys_newlstat(char * filename, struct stat * statbuf);
@@ -135,9 +142,9 @@ sys32_newlstat(char * filename, struct s
 	set_fs (KERNEL_DS);
 	ret = sys_newlstat(filename, &s);
 	set_fs (old_fs);
-	if (putstat (statbuf, &s))
-		return -EFAULT;
-	return ret;
+	if (ret) 
+		return ret;
+	return putstat(statbuf, &s);
 }
 
 extern asmlinkage long sys_newfstat(unsigned int fd, struct stat * statbuf);
@@ -152,9 +159,9 @@ sys32_newfstat(unsigned int fd, struct s
 	set_fs (KERNEL_DS);
 	ret = sys_newfstat(fd, &s);
 	set_fs (old_fs);
-	if (putstat (statbuf, &s))
-		return -EFAULT;
-	return ret;
+	if (ret)
+		return ret;
+	return putstat(statbuf, &s);
 }
 
 /* Another set for IA32/LFS -- x86_64 struct stat is different due to 
@@ -192,9 +199,9 @@ sys32_stat64(char * filename, struct sta
 	set_fs (KERNEL_DS);
 	ret = sys_newstat(filename, &s);
 	set_fs (old_fs);
-	if (putstat64 (statbuf, &s))
-		return -EFAULT;
-	return ret;
+	if (ret)
+		return ret;
+	return putstat64(statbuf, &s);
 }
 
 asmlinkage long
@@ -207,9 +214,9 @@ sys32_lstat64(char * filename, struct st
 	set_fs (KERNEL_DS);
 	ret = sys_newlstat(filename, &s);
 	set_fs (old_fs);
-	if (putstat64 (statbuf, &s))
-		return -EFAULT;
-	return ret;
+	if (ret)
+		return ret;
+	return putstat64(statbuf, &s);
 }
 
 asmlinkage long
@@ -222,9 +229,9 @@ sys32_fstat64(unsigned int fd, struct st
 	set_fs (KERNEL_DS);
 	ret = sys_newfstat(fd, &s);
 	set_fs (old_fs);
-	if (putstat64 (statbuf, &s))
-		return -EFAULT;
-	return ret;
+	if (ret)
+		return ret;
+	return putstat64(statbuf, &s);
 }
 
 /* Don't set O_LARGEFILE implicitely. */
@@ -474,8 +481,14 @@ put_statfs (struct statfs32 *ubuf, struc
 	    __put_user (kbuf->f_files, &ubuf->f_files) ||
 	    __put_user (kbuf->f_ffree, &ubuf->f_ffree) ||
 	    __put_user (kbuf->f_namelen, &ubuf->f_namelen) ||
-	    __put_user (kbuf->f_fsid.val[0], &ubuf->f_fsid.val[0]) ||
-	    __put_user (kbuf->f_fsid.val[1], &ubuf->f_fsid.val[1]))
+	    __put_user (kbuf->f_fsid.val[0], &ubuf->f_fsid.val[0]) || 
+	    __put_user (kbuf->f_fsid.val[1], &ubuf->f_fsid.val[1]) ||
+	    __put_user (0, &ubuf->f_spare[0]) ||
+	    __put_user (0, &ubuf->f_spare[1]) ||
+	    __put_user (0, &ubuf->f_spare[2]) ||
+	    __put_user (0, &ubuf->f_spare[3]) ||
+	    __put_user (0, &ubuf->f_spare[4]) ||
+	    __put_user (0, &ubuf->f_spare[5]))
 		return -EFAULT;
 	return 0;
 }
@@ -925,11 +938,6 @@ sys32_old_select(struct sel_arg_struct *
 			    (struct timeval32 *)A(a.tvp));
 }
 
-struct timespec32 {
-	int 	tv_sec;
-	int	tv_nsec;
-};
-
 extern asmlinkage long sys_nanosleep(struct timespec *rqtp, struct timespec *rmtp); 
 
 asmlinkage long
@@ -940,10 +948,10 @@ sys32_nanosleep(struct timespec32 *rqtp,
 	mm_segment_t old_fs = get_fs ();
 	
 	if (rqtp) { 
-	if (verify_area(VERIFY_READ, rqtp, sizeof(struct timespec32)) ||
-	    __get_user (t.tv_sec, &rqtp->tv_sec) ||
-	    __get_user (t.tv_nsec, &rqtp->tv_nsec))
-		return -EFAULT;
+		if (verify_area(VERIFY_READ, rqtp, sizeof(struct timespec32)) ||
+		    __get_user (t.tv_sec, &rqtp->tv_sec) ||
+		    __get_user (t.tv_nsec, &rqtp->tv_nsec))
+			return -EFAULT;
 	}
 	set_fs (KERNEL_DS);
 	ret = sys_nanosleep(rqtp ? &t : NULL, rmtp ? &tout : NULL);
@@ -1029,7 +1037,7 @@ sys32_readv(int fd, struct iovec32 *vect
 	struct iovec *iov;
 	int ret;
 	mm_segment_t old_fs = get_fs();
-
+	
 	if ((iov = get_iovec32(vector, iovstack, &count, VERIFY_WRITE, &ret)) == NULL)
 		return ret;
 	set_fs(KERNEL_DS);
@@ -1378,7 +1386,7 @@ asmlinkage long sys32_fcntl64(unsigned i
 	int ret = 0; 
 	int oldcmd = cmd;
 	unsigned long oldarg = arg;
-
+	
 	switch (cmd) {
 	case F_GETLK64: 
 		cmd = F_GETLK; 
@@ -1517,10 +1525,30 @@ sys32_sysinfo(struct sysinfo32 *info)
 	struct sysinfo s;
 	int ret;
 	mm_segment_t old_fs = get_fs ();
-	
+	int bitcount = 0;
+
 	set_fs (KERNEL_DS);
 	ret = sys_sysinfo(&s);
 	set_fs (old_fs);
+
+        /* Check to see if any memory value is too large for 32-bit and scale
+	 *  down if needed
+	 */
+	if ((s.totalram >> 32) || (s.totalswap >> 32)) {
+		while (s.mem_unit < PAGE_SIZE) {
+			s.mem_unit <<= 1;
+			bitcount++;
+		}
+		s.totalram >>= bitcount;
+		s.freeram >>= bitcount;
+		s.sharedram >>= bitcount;
+		s.bufferram >>= bitcount;
+		s.totalswap >>= bitcount;
+		s.freeswap >>= bitcount;
+		s.totalhigh >>= bitcount;
+		s.freehigh >>= bitcount;
+	}
+
 	if (verify_area(VERIFY_WRITE, info, sizeof(struct sysinfo32)) ||
 	    __put_user (s.uptime, &info->uptime) ||
 	    __put_user (s.loads[0], &info->loads[0]) ||
@@ -2150,38 +2178,38 @@ asmlinkage long sys32_execve(char *name,
 	int na = 0,ne = 0;
 	int ret;
 	unsigned sz = 0; 
-	
+
 	if (argv) {
-	na = nargs(argv, NULL); 
-	if (na < 0) 
-		return -EFAULT; 
+		na = nargs(argv, NULL); 
+		if (na < 0) 
+			return -EFAULT; 
 	} 	
 	if (envp) { 
-	ne = nargs(envp, NULL); 
-	if (ne < 0) 
-		return -EFAULT; 
+		ne = nargs(envp, NULL); 
+		if (ne < 0) 
+			return -EFAULT;
 	}
 
 	if (argv || envp) { 
-	sz = (na+ne)*sizeof(void *); 
-	if (sz > PAGE_SIZE) 
-		buf = vmalloc(sz); 
-	else
-		buf = kmalloc(sz, GFP_KERNEL); 
-	if (!buf)
-		return -ENOMEM; 
+		sz = (na+ne)*sizeof(void *); 
+		if (sz > PAGE_SIZE) 
+			buf = vmalloc(sz); 
+		else
+			buf = kmalloc(sz, GFP_KERNEL); 
+		if (!buf)
+			return -ENOMEM; 
 	} 
 	
 	if (argv) { 
-	ret = nargs(argv, buf);
-	if (ret < 0)
-		goto free;
+		ret = nargs(argv, buf);
+		if (ret < 0)
+			goto free;
 	}
 
 	if (envp) { 
-	ret = nargs(envp, buf + na); 
-	if (ret < 0)
-		goto free; 
+		ret = nargs(envp, buf + na); 
+		if (ret < 0)
+			goto free; 
 	}
 
 	name = getname(name); 
@@ -2201,10 +2229,10 @@ asmlinkage long sys32_execve(char *name,
  
 free:
 	if (argv || envp) { 
-	if (sz > PAGE_SIZE)
-		vfree(buf); 
-	else
-		kfree(buf);
+		if (sz > PAGE_SIZE)
+			vfree(buf); 
+		else
+			kfree(buf);
 	}
 	return ret; 
 } 
@@ -2534,16 +2562,421 @@ long asmlinkage sys32_nfsservctl(int cmd
 }
 #endif
 
-long sys32_module_warning(void)
-{ 
-	static long warn_time = -(60*HZ); 
-	if (time_before(warn_time + 60*HZ,jiffies) && strcmp(current->comm,"klogd")) { 
-		printk(KERN_INFO "%s: 32bit modutils not supported on 64bit kernel\n",
-		       current->comm);
-		warn_time = jiffies;
-	} 
-	return -ENOSYS ;
-} 
+#ifdef CONFIG_MODULES
+
+extern asmlinkage unsigned long sys_create_module(const char *name_user, size_t size);
+
+asmlinkage unsigned long sys32_create_module(const char *name_user, __kernel_size_t32 size)
+{
+	return sys_create_module(name_user, (size_t)size);
+}
+
+extern asmlinkage int sys_init_module(const char *name_user, struct module *mod_user);
+
+/* Hey, when you're trying to init module, take time and prepare us a nice 64bit
+ * module structure, even if from 32bit modutils... Why to pollute kernel... :))
+ */
+asmlinkage int sys32_init_module(const char *name_user, struct module *mod_user)
+{
+	return sys_init_module(name_user, mod_user);
+}
+
+extern asmlinkage int sys_delete_module(const char *name_user);
+
+asmlinkage int sys32_delete_module(const char *name_user)
+{
+	return sys_delete_module(name_user);
+}
+
+struct module_info32 {
+	u32 addr;
+	u32 size;
+	u32 flags;
+	s32 usecount;
+};
+
+/* Query various bits about modules.  */
+
+static inline long
+get_mod_name(const char *user_name, char **buf)
+{
+	unsigned long page;
+	long retval;
+
+	if ((unsigned long)user_name >= TASK_SIZE
+	    && !segment_eq(get_fs (), KERNEL_DS))
+		return -EFAULT;
+
+	page = __get_free_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	retval = strncpy_from_user((char *)page, user_name, PAGE_SIZE);
+	if (retval > 0) {
+		if (retval < PAGE_SIZE) {
+			*buf = (char *)page;
+			return retval;
+		}
+		retval = -ENAMETOOLONG;
+	} else if (!retval)
+		retval = -EINVAL;
+
+	free_page(page);
+	return retval;
+}
+
+static inline void
+put_mod_name(char *buf)
+{
+	free_page((unsigned long)buf);
+}
+
+static __inline__ struct module *find_module(const char *name)
+{
+	struct module *mod;
+
+	for (mod = module_list; mod ; mod = mod->next) {
+		if (mod->flags & MOD_DELETED)
+			continue;
+		if (!strcmp(mod->name, name))
+			break;
+	}
+
+	return mod;
+}
+
+static int
+qm_modules(char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	struct module *mod;
+	size_t nmod, space, len;
+
+	nmod = space = 0;
+
+	for (mod = module_list; mod->next != NULL; mod = mod->next, ++nmod) {
+		len = strlen(mod->name)+1;
+		if (len > bufsize)
+			goto calc_space_needed;
+		if (copy_to_user(buf, mod->name, len))
+			return -EFAULT;
+		buf += len;
+		bufsize -= len;
+		space += len;
+	}
+
+	if (put_user(nmod, ret))
+		return -EFAULT;
+	else
+		return 0;
+
+calc_space_needed:
+	space += len;
+	while ((mod = mod->next)->next != NULL)
+		space += strlen(mod->name)+1;
+
+	if (put_user(space, ret))
+		return -EFAULT;
+	else
+		return -ENOSPC;
+}
+
+static int
+qm_deps(struct module *mod, char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	size_t i, space, len;
+
+	if (mod->next == NULL)
+		return -EINVAL;
+	if (!MOD_CAN_QUERY(mod))
+		return put_user(0, ret);
+
+	space = 0;
+	for (i = 0; i < mod->ndeps; ++i) {
+		const char *dep_name = mod->deps[i].dep->name;
+
+		len = strlen(dep_name)+1;
+		if (len > bufsize)
+			goto calc_space_needed;
+		if (copy_to_user(buf, dep_name, len))
+			return -EFAULT;
+		buf += len;
+		bufsize -= len;
+		space += len;
+	}
+
+	return put_user(i, ret);
+
+calc_space_needed:
+	space += len;
+	while (++i < mod->ndeps)
+		space += strlen(mod->deps[i].dep->name)+1;
+
+	if (put_user(space, ret))
+		return -EFAULT;
+	else
+		return -ENOSPC;
+}
+
+static int
+qm_refs(struct module *mod, char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	size_t nrefs, space, len;
+	struct module_ref *ref;
+
+	if (mod->next == NULL)
+		return -EINVAL;
+	if (!MOD_CAN_QUERY(mod))
+		if (put_user(0, ret))
+			return -EFAULT;
+		else
+			return 0;
+
+	space = 0;
+	for (nrefs = 0, ref = mod->refs; ref ; ++nrefs, ref = ref->next_ref) {
+		const char *ref_name = ref->ref->name;
+
+		len = strlen(ref_name)+1;
+		if (len > bufsize)
+			goto calc_space_needed;
+		if (copy_to_user(buf, ref_name, len))
+			return -EFAULT;
+		buf += len;
+		bufsize -= len;
+		space += len;
+	}
+
+	if (put_user(nrefs, ret))
+		return -EFAULT;
+	else
+		return 0;
+
+calc_space_needed:
+	space += len;
+	while ((ref = ref->next_ref) != NULL)
+		space += strlen(ref->ref->name)+1;
+
+	if (put_user(space, ret))
+		return -EFAULT;
+	else
+		return -ENOSPC;
+}
+
+static inline int
+qm_symbols(struct module *mod, char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	size_t i, space, len;
+	struct module_symbol *s;
+	char *strings;
+	unsigned *vals;
+
+	if (!MOD_CAN_QUERY(mod))
+		if (put_user(0, ret))
+			return -EFAULT;
+		else
+			return 0;
+
+	space = mod->nsyms * 2*sizeof(u32);
+
+	i = len = 0;
+	s = mod->syms;
+
+	if (space > bufsize)
+		goto calc_space_needed;
+
+	if (!access_ok(VERIFY_WRITE, buf, space))
+		return -EFAULT;
+
+	bufsize -= space;
+	vals = (unsigned *)buf;
+	strings = buf+space;
+
+	for (; i < mod->nsyms ; ++i, ++s, vals += 2) {
+		len = strlen(s->name)+1;
+		if (len > bufsize)
+			goto calc_space_needed;
+
+		if (copy_to_user(strings, s->name, len)
+		    || __put_user(s->value, vals+0)
+		    || __put_user(space, vals+1))
+			return -EFAULT;
+
+		strings += len;
+		bufsize -= len;
+		space += len;
+	}
+
+	if (put_user(i, ret))
+		return -EFAULT;
+	else
+		return 0;
+
+calc_space_needed:
+	for (; i < mod->nsyms; ++i, ++s)
+		space += strlen(s->name)+1;
+
+	if (put_user(space, ret))
+		return -EFAULT;
+	else
+		return -ENOSPC;
+}
+
+static inline int
+qm_info(struct module *mod, char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	int error = 0;
+
+	if (mod->next == NULL)
+		return -EINVAL;
+
+	if (sizeof(struct module_info32) <= bufsize) {
+		struct module_info32 info;
+		info.addr = (unsigned long)mod;
+		info.size = mod->size;
+		info.flags = mod->flags;
+		info.usecount =
+			((mod_member_present(mod, can_unload)
+			  && mod->can_unload)
+			 ? -1 : atomic_read(&mod->uc.usecount));
+
+		if (copy_to_user(buf, &info, sizeof(struct module_info32)))
+			return -EFAULT;
+	} else
+		error = -ENOSPC;
+
+	if (put_user(sizeof(struct module_info32), ret))
+		return -EFAULT;
+
+	return error;
+}
+
+asmlinkage int sys32_query_module(char *name_user, int which, char *buf, __kernel_size_t32 bufsize, u32 ret)
+{
+	struct module *mod;
+	int err;
+
+	lock_kernel();
+	if (name_user == 0) {
+		/* This finds "kernel_module" which is not exported. */
+		for(mod = module_list; mod->next != NULL; mod = mod->next)
+			;
+	} else {
+		long namelen;
+		char *name;
+
+		if ((namelen = get_mod_name(name_user, &name)) < 0) {
+			err = namelen;
+			goto out;
+		}
+		err = -ENOENT;
+		if (namelen == 0) {
+			/* This finds "kernel_module" which is not exported. */
+			for(mod = module_list; mod->next != NULL; mod = mod->next)
+				;
+		} else if ((mod = find_module(name)) == NULL) {
+			put_mod_name(name);
+			goto out;
+		}
+		put_mod_name(name);
+	}
+
+	switch (which)
+	{
+	case 0:
+		err = 0;
+		break;
+	case QM_MODULES:
+		err = qm_modules(buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	case QM_DEPS:
+		err = qm_deps(mod, buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	case QM_REFS:
+		err = qm_refs(mod, buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	case QM_SYMBOLS:
+		err = qm_symbols(mod, buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	case QM_INFO:
+		err = qm_info(mod, buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+out:
+	unlock_kernel();
+	return err;
+}
+
+struct kernel_sym32 {
+	u32 value;
+	char name[60];
+};
+		 
+extern asmlinkage int sys_get_kernel_syms(struct kernel_sym *table);
+
+asmlinkage int sys32_get_kernel_syms(struct kernel_sym32 *table)
+{
+	int len, i;
+	struct kernel_sym *tbl;
+	mm_segment_t old_fs;
+	
+	len = sys_get_kernel_syms(NULL);
+	if (!table) return len;
+	tbl = kmalloc (len * sizeof (struct kernel_sym), GFP_KERNEL);
+	if (!tbl) return -ENOMEM;
+	old_fs = get_fs();
+	set_fs (KERNEL_DS);
+	sys_get_kernel_syms(tbl);
+	set_fs (old_fs);
+	for (i = 0; i < len; i++, table++) {
+		if (put_user (tbl[i].value, &table->value) ||
+		    copy_to_user (table->name, tbl[i].name, 60))
+			break;
+	}
+	kfree (tbl);
+	return i;
+}
+
+#else /* CONFIG_MODULES */
+
+asmlinkage unsigned long
+sys32_create_module(const char *name_user, size_t size)
+{
+	return -ENOSYS;
+}
+
+asmlinkage int
+sys32_init_module(const char *name_user, struct module *mod_user)
+{
+	return -ENOSYS;
+}
+
+asmlinkage int
+sys32_delete_module(const char *name_user)
+{
+	return -ENOSYS;
+}
+
+asmlinkage int
+sys32_query_module(const char *name_user, int which, char *buf, size_t bufsize,
+		 size_t *ret)
+{
+	/* Let the program know about the new interface.  Not that
+	   it'll do them much good.  */
+	if (which == 0)
+		return 0;
+
+	return -ENOSYS;
+}
+
+asmlinkage int
+sys32_get_kernel_syms(struct kernel_sym *table)
+{
+	return -ENOSYS;
+}
+
+#endif  /* CONFIG_MODULES */
 
 long sys32_vm86_warning(void)
 { 
@@ -2565,7 +2998,7 @@ struct exec_domain ia32_exec_domain = { 
 
 static int __init ia32_init (void)
 {
-	printk("IA32 emulation $Id: sys_ia32.c,v 1.58 2003/05/09 17:21:17 ak Exp $\n");  
+	printk("IA32 emulation $Id: sys_ia32.c,v 1.64 2003/09/26 19:26:27 ak Exp $\n");  
 	ia32_exec_domain.signal_map = default_exec_domain.signal_map;
 	ia32_exec_domain.signal_invmap = default_exec_domain.signal_invmap;
 	register_exec_domain(&ia32_exec_domain);
--- linux-2.4.22/arch/x86_64/boot/bootsect.S.amd64-updates	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.22/arch/x86_64/boot/bootsect.S	2003-10-10 11:17:45.000000000 +0200
@@ -395,9 +395,9 @@ print_digit:
 # NOTE: Doesn't save %ax or %dx; do it yourself if you need to.
 
 kill_motor:
-	xorw	%ax, %ax		# reset FDC
-	xorb	%dl, %dl
-	int	$0x13
+	xorw    %ax, %ax                # reset FDC
+        xorb    %dl, %dl
+        int     $0x13
 	ret
 
 sectors:	.word 0
--- linux-2.4.22/arch/x86_64/boot/setup.S.amd64-updates	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.22/arch/x86_64/boot/setup.S	2003-10-10 11:17:45.000000000 +0200
@@ -193,7 +193,7 @@ prtstr:
 	jmp	prtstr
 
 fin:	ret
-
+			
 # Space printing
 prtsp2:	call	prtspc		# Print double space
 prtspc:	movb	$0x20, %al	# Print single space (note: fall-thru)
@@ -346,7 +346,7 @@ long_mode_panic:
 	
 sse_ok:
 	popw	%ds
-	
+
 # tell BIOS we want to go to long mode
 	movl  $0xec00,%eax	# declare target operating mode
 	movl  $2,%ebx		# long mode
@@ -524,7 +524,7 @@ no_psmouse:
 	cmpw	$0, %cs:realmode_swtch
 	jz	rmodeswtch_normal
 
-	lcall	%cs:realmode_swtch
+	lcall	*%cs:realmode_swtch
 
 	jmp	rmodeswtch_end
 
--- linux-2.4.22/arch/x86_64/Makefile.amd64-updates	2003-10-10 10:32:23.000000000 +0200
+++ linux-2.4.22/arch/x86_64/Makefile	2003-10-10 11:17:45.000000000 +0200
@@ -19,7 +19,7 @@
 # 20010105  Andi Kleen, add IA32 compiler.
 #           ....and later removed it again....
 #
-# $Id: Makefile,v 1.33 2003/05/12 14:36:34 ak Exp $
+# $Id: Makefile,v 1.34 2003/09/25 02:50:05 ak Exp $
 
 #
 # early bootup linking needs 32bit. You can either use real 32bit tools
@@ -38,6 +38,8 @@ OBJCOPY=$(CROSS_COMPILE)objcopy -O binar
 LDFLAGS=-e stext
 LINKFLAGS =-T $(TOPDIR)/arch/x86_64/vmlinux.lds $(LDFLAGS)
 
+check_gcc = $(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1 ; then echo "$(1)"; else echo "$(2)"; fi)
+
 CFLAGS += -mno-red-zone
 CFLAGS += -mcmodel=kernel
 CFLAGS += -pipe
@@ -51,9 +53,7 @@ CFLAGS += -Wno-sign-compare
 ifneq ($(CONFIG_X86_REMOTE_DEBUG),y)
 CFLAGS += -fno-asynchronous-unwind-tables
 endif
-
-# prevent gcc from keeping the stack 16 byte aligned (FIXME)
-#CFLAGS += -mpreferred-stack-boundary=2
+CFLAGS += $(call check_gcc,-fno-unit-at-a-time,)
 
 HEAD := arch/x86_64/kernel/head.o arch/x86_64/kernel/head64.o arch/x86_64/kernel/init_task.o
 
--- linux-2.4.22/arch/x86_64/config.in.amd64-updates	2003-10-10 10:32:37.000000000 +0200
+++ linux-2.4.22/arch/x86_64/config.in	2003-10-10 11:17:45.000000000 +0200
@@ -10,7 +10,7 @@ define_bool CONFIG_X86 y
 define_bool CONFIG_ISA n
 define_bool CONFIG_SBUS n
 
-define_bool CONFIG_UID16 y
+define_bool CONFIG_UID16 n
 define_bool CONFIG_RWSEM_GENERIC_SPINLOCK y
 define_bool CONFIG_RWSEM_XCHGADD_ALGORITHM n
 define_bool CONFIG_X86_CMPXCHG y
--- linux-2.4.22/Documentation/x86_64/boot-options.txt.amd64-updates	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.22/Documentation/x86_64/boot-options.txt	2003-10-10 11:17:45.000000000 +0200
@@ -65,13 +65,14 @@ Timing
   0 don't use an NMI watchdog
   1 use the IO-APIC timer for the NMI watchdog
   2 use the local APIC for the NMI watchdog using a performance counter. Note
-  This will use one performance counter.
+  This will use one performance counter and the local APIC's performance
+  counter vector.
 
 Idle loop
 
   idle=poll
   Don't do power saving in the idle loop using HLT, but poll for rescheduling 
-  event. This will make the CPUs eat a lot more power, but may be useful 
+  events. This will make the CPUs burn a lot more power, but may be useful 
   to get slightly better performance in multiprocessor benchmarks. It also
   makes some profiling using performance counters more accurate.
 
@@ -145,7 +146,7 @@ IOMMU
    off   don't use the IOMMU
    leak  turn on simple iommu leak tracing (only when CONFIG_IOMMU_LEAK is on)
    memaper[=order] allocate an own aperture over RAM with size 32MB^order.
-   noforce don't force IOMMU usage. Should be fastest.
-   force  Force IOMMU and turn on unmap debugging.  
+   noforce don't force IOMMU usage. Default.
+   force  Force IOMMU for all devices.
 
 
