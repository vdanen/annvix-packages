diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/arch/i386/config.in m1/arch/i386/config.in
--- m2/arch/i386/config.in	2003-07-30 18:13:26.000000000 +0200
+++ m1/arch/i386/config.in	2003-07-31 17:27:37.000000000 +0200
@@ -326,6 +326,8 @@ tristate 'Kernel support for MISC binari
 
 bool 'Power Management support' CONFIG_PM
 
+source kernel/suspend/Config.in
+
 dep_tristate '  Advanced Power Management BIOS support' CONFIG_APM $CONFIG_PM
 if [ "$CONFIG_APM" != "n" ]; then
    bool '    Ignore USER SUSPEND' CONFIG_APM_IGNORE_USER_SUSPEND
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/arch/i386/defconfig m1/arch/i386/defconfig
--- m2/arch/i386/defconfig	2002-11-29 00:53:09.000000000 +0100
+++ m1/arch/i386/defconfig	2003-07-31 17:27:37.000000000 +0200
@@ -109,6 +109,7 @@ CONFIG_BINFMT_ELF=y
 CONFIG_BINFMT_MISC=y
 CONFIG_PM=y
 # CONFIG_APM is not set
+# CONFIG_SOFTWARE_SUSPEND is not set
 
 #
 # Memory Technology Devices (MTD)
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/arch/i386/kernel/apm.c m1/arch/i386/kernel/apm.c
--- m2/arch/i386/kernel/apm.c	2003-07-30 18:13:26.000000000 +0200
+++ m1/arch/i386/kernel/apm.c	2003-07-31 17:27:37.000000000 +0200
@@ -1710,6 +1710,7 @@ static int apm(void *unused)
 	daemonize();
 
 	strcpy(current->comm, "kapmd");
+	current->flags |= PF_IOTHREAD;
 	sigfillset(&current->blocked);
 
 #ifdef CONFIG_SMP
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/arch/i386/kernel/mtrr.c m1/arch/i386/kernel/mtrr.c
--- m2/arch/i386/kernel/mtrr.c	2003-06-13 16:51:29.000000000 +0200
+++ m1/arch/i386/kernel/mtrr.c	2003-07-31 17:27:37.000000000 +0200
@@ -270,6 +270,7 @@
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -2305,6 +2306,68 @@ int __init mtrr_init(void)
     return 0;
 }   /*  End Function mtrr_init  */
 
+#ifdef SOFTWARE_SUSPEND_MTRR
+struct mtrr_suspend_state
+{
+     mtrr_type ltype;
+     unsigned long lbase, lsize;
+};
+/* We return a pointer ptr on an area of *ptr bytes
+   beginning at ptr+sizeof(int)
+   This buffer has to be saved in some way during suspension */
+int *mtrr_suspend(void)
+{
+     int i, max, len;
+     int *ptr;
+     static struct mtrr_suspend_state *mtrr_suspend_buffer=NULL;
+     
+     max = get_num_var_ranges ();
+     if(!mtrr_suspend_buffer)
+     {
+	  len = max * sizeof (struct mtrr_suspend_state) + sizeof(int);
+	  ptr = kmalloc (len, GFP_KERNEL);
+	  if (ptr == NULL)
+	       return(NULL);
+	  *ptr = len;
+	  ptr++;
+	  mtrr_suspend_buffer = (struct mtrr_suspend_state *)ptr;
+	  ptr--;
+     }
+     for (i = 0; i < max; ++i,mtrr_suspend_buffer++)
+	  (*get_mtrr) (i,
+		       &(mtrr_suspend_buffer->lbase),
+		       &(mtrr_suspend_buffer->lsize),
+		       &(mtrr_suspend_buffer->ltype));
+     return(ptr);
+}
+
+/* We restore mtrrs from buffer ptr */
+int mtrr_resume(int *ptr)
+{
+     int i, max, len;
+     struct mtrr_suspend_state *mtrr_suspend_buffer;
+     
+     max = get_num_var_ranges ();
+     len = max * sizeof (struct mtrr_suspend_state) + sizeof(int);
+     if(*ptr != len)
+     {
+	  printk ("mtrr: Resuming failed due to different number of MTRRs\n");
+	  return (-1);
+     }
+     ptr++;
+     mtrr_suspend_buffer=(struct mtrr_suspend_state *)ptr;
+     for (i = 0; i < max; ++i,mtrr_suspend_buffer++)     
+	  if (mtrr_suspend_buffer->lsize)	  
+	       set_mtrr(i,
+			mtrr_suspend_buffer->lbase,
+			mtrr_suspend_buffer->lsize,
+			mtrr_suspend_buffer->ltype);
+     return(0);
+}
+EXPORT_SYMBOL(mtrr_suspend);
+EXPORT_SYMBOL(mtrr_resume);
+#endif
+
 /*
  * Local Variables:
  * mode:c
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/arch/i386/kernel/process.c m1/arch/i386/kernel/process.c
--- m2/arch/i386/kernel/process.c	2003-07-30 18:13:27.000000000 +0200
+++ m1/arch/i386/kernel/process.c	2003-07-31 17:27:37.000000000 +0200
@@ -740,6 +740,36 @@ void __switch_to(struct task_struct *pre
 	}
 }
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+/**
+ *	swsusp_power_off	-	ask the BIOS to power off
+ *
+ *	Handle the power off sequence. This is the one piece of code we
+ *	will execute even on SMP machines. In order to deal with BIOS
+ *	bugs we support real mode APM BIOS power off calls. We also make
+ *	the SMP call on CPU0 as some systems will only honour this call
+ *	on their first cpu.
+ *
+ *	This piece of code is extracted from apm.c. We want to be able
+ *	to do this even if apm isn't activated.
+ */
+ 
+void swsusp_power_off(void)
+{
+	unsigned char	po_bios_call[] = {
+		0xb8, 0x00, 0x10,	/* movw  $0x1000,ax  */
+		0x8e, 0xd0,		/* movw  ax,ss       */
+		0xbc, 0x00, 0xf0,	/* movw  $0xf000,sp  */
+		0xb8, 0x07, 0x53,	/* movw  $0x5307,ax  */
+		0xbb, 0x01, 0x00,	/* movw  $0x0001,bx  */
+		0xb9, 0x03, 0x00,	/* movw  $0x0003,cx  */
+		0xcd, 0x15		/* int   $0x15       */
+	};
+
+	machine_real_restart(po_bios_call, sizeof(po_bios_call));
+}
+#endif
+
 asmlinkage int sys_fork(struct pt_regs regs)
 {
 	return do_fork(SIGCHLD, regs.esp, &regs, 0);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/arch/i386/kernel/signal.c m1/arch/i386/kernel/signal.c
--- m2/arch/i386/kernel/signal.c	2002-08-03 02:39:42.000000000 +0200
+++ m1/arch/i386/kernel/signal.c	2003-07-31 17:27:37.000000000 +0200
@@ -20,6 +20,7 @@
 #include <linux/stddef.h>
 #include <linux/tty.h>
 #include <linux/personality.h>
+#include <linux/suspend.h>
 #include <asm/ucontext.h>
 #include <asm/uaccess.h>
 #include <asm/i387.h>
@@ -595,6 +596,11 @@ int do_signal(struct pt_regs *regs, sigs
 	if ((regs->xcs & 3) != 3)
 		return 1;
 
+	if (current->flags & PF_FREEZE) {
+		refrigerator(0);
+		goto no_signal;
+	}
+
 	if (!oldset)
 		oldset = &current->blocked;
 
@@ -702,6 +708,7 @@ int do_signal(struct pt_regs *regs, sigs
 		return 1;
 	}
 
+ no_signal:
 	/* Did we come from a system call? */
 	if (regs->orig_eax >= 0) {
 		/* Restart the system call - no handlers present */
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/arch/i386/mm/fault.c m1/arch/i386/mm/fault.c
--- m2/arch/i386/mm/fault.c	2002-11-29 00:53:09.000000000 +0100
+++ m1/arch/i386/mm/fault.c	2003-07-31 17:27:37.000000000 +0200
@@ -325,6 +325,7 @@ no_context:
 		printk(KERN_ALERT "*pte = %08lx\n", page);
 	}
 	die("Oops", regs, error_code);
+	printk("\n");
 	bust_spinlocks(0);
 	do_exit(SIGKILL);
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/arch/i386/mm/pageattr.c m1/arch/i386/mm/pageattr.c
--- m2/arch/i386/mm/pageattr.c	2002-11-29 00:53:09.000000000 +0100
+++ m1/arch/i386/mm/pageattr.c	2003-07-31 17:27:37.000000000 +0200
@@ -15,7 +15,8 @@
 #define LARGE_PAGE_MASK (~(LARGE_PAGE_SIZE-1))
 #define LARGE_PAGE_SIZE (1UL << PMD_SHIFT)
 
-static inline pte_t *lookup_address(unsigned long address) 
+// Also used in kernel/suspend/low_level_io.c
+inline pte_t *lookup_address(unsigned long address) 
 { 
 	pmd_t *pmd;	
 	pgd_t *pgd = pgd_offset(&init_mm, address); 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/CREDITS m1/CREDITS
--- m2/CREDITS	2003-07-30 18:13:25.000000000 +0200
+++ m1/CREDITS	2003-07-31 17:27:37.000000000 +0200
@@ -499,6 +499,14 @@ S: 48287 Sawleaf
 S: Fremont, California 94539
 S: USA
 
+N: Florent Chabaud
+E: florent.chabaud@polytechnique.org
+D: software suspend
+S: SGDN/DCSSI/SDS/LTI
+S: 58, Bd Latour-Maubourg
+S: 75700 Paris 07 SP
+S: France
+
 N: Gordon Chaffee
 E: chaffee@cs.berkeley.edu
 W: http://bmrc.berkeley.edu/people/chaffee/
@@ -633,6 +641,11 @@ S: Northampton
 S: NN1 3QT
 S: United Kingdom
 
+N: Nigel Cunningham
+E: ncunningham@clear.net.nz
+D: Major Software Suspend enchancements
+S: Hastings, New Zealand
+
 N: Stephane Dalton
 E: sdalton@videotron.ca
 D: Tieman Voyager USB Braille display driver.
@@ -990,6 +1003,13 @@ S: 1150 Ringwood Court
 S: San Jose, California 95131
 S: USA
 
+N: Nathan Friess
+E: natmanz@shaw.ca
+D: software suspend
+S: 25 Tararidge Close NE
+S: Calgary, Alberta  T3J 2P4
+S: Canada
+
 N: Fernando Fuganti
 E: fuganti@conectiva.com.br
 E: fuganti@netbank.com.br
@@ -1741,6 +1761,11 @@ S: Schlehenweg 9
 S: D-91080 Uttenreuth
 S: Germany
 
+N: Gabor Kuti
+E: seasons@falcon.sch.bme.hu
+E: seasons@makosteszta.sote.hu
+D: software suspend
+
 N: Jaroslav Kysela
 E: perex@suse.cz
 W: http://www.perex.cz
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/Documentation/Configure.help m1/Documentation/Configure.help
--- m2/Documentation/Configure.help	2003-07-30 18:13:25.000000000 +0200
+++ m1/Documentation/Configure.help	2003-07-31 17:27:37.000000000 +0200
@@ -109,6 +109,52 @@ CONFIG_OBSOLETE
   like MGA monitors that you are very unlikely to see on today's
   systems.
 
+Software Suspend
+CONFIG_SOFTWARE_SUSPEND
+  Enable the possibilty of suspending your machine to disk. No special
+  hardware support (BIOS, APM or ACPI) is required, but your milage may
+  vary because support for hardware is currently limited. This is partly
+  due to the lack of a driver model in 2.4 and partly due to the fact
+  that it has been developed for x86+ide in the first instance.
+
+  Please read Documentation/swsusp.txt for more information.
+  
+Debugging info for Software Suspend
+CONFIG_SOFTWARE_SUSPEND_DEBUG
+  This option enables the inclusion of debugging info in the software
+  suspend code. Turning it off will reduce the kernel size but make
+  debugging suspend & resume issues harder to do.
+
+  For normal usage, this option can be turned off.
+
+Checksum pages stored during Software Suspend
+CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+  This option enables code that calculates a simple checksum for each
+  page prior to writing the image and compares the checksum with the
+  value after restoring the image. There will always be some differences
+  between the saved image and the point where checksums are checked, but
+  knowing what the differences are may help in debugging the code.
+
+  This option should normally be off.
+
+Compress the Software Suspend image
+CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+  This option enables compression of pages stored during Software Suspend
+  process. Pages are compressed using the zlib library, with a default
+  setting (in code) of fastest compression. If your swap device is
+  significantly slower than your CPU, you may improve the speed of a
+  suspend/resume cycle by enabling this option.
+  
+  You may also benefit from it if your swap space is small. Note, however,
+  that since we can't know how big the image will be until we actually
+  compress it, the algorithm assumes no compression will be achieved and
+  ensures that your data will fit on disk even if that happens. This means
+  that more memory will be eaten than probably needs to be. The best
+  solution to this issue is to increase your swapspace size. We may
+  implement support for a swap file in future.
+
+  This option should be off for most people.
+
 Symmetric Multi-Processing support
 CONFIG_SMP
   This enables support for systems with more than one CPU. If you have
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/Documentation/kernel-parameters.txt m1/Documentation/kernel-parameters.txt
--- m2/Documentation/kernel-parameters.txt	2003-07-30 18:13:26.000000000 +0200
+++ m1/Documentation/kernel-parameters.txt	2003-07-31 17:27:37.000000000 +0200
@@ -46,6 +46,7 @@ restrictions referred to are that the re
 	SERIAL	Serial support is enabled.
 	SMP 	The kernel is an SMP kernel.
 	SOUND	Appropriate sound system support is enabled.
+	SWSUSP  Software suspension is enabled.
 	V4L	Video For Linux support is enabled.
 	VGA 	The VGA console has been enabled.
 	VT	Virtual terminal support is enabled.
@@ -413,6 +414,8 @@ running once the system is up.
 			initial RAM disk.
 
 	nointroute	[IA-64]
+
+	noresume	[SWSUSP] Disables resume and restore original swap space.
  
 	no-scroll	[VGA]
 
@@ -532,6 +535,8 @@ running once the system is up.
 
 	reserve=	[KNL,BUGS] force the kernel to ignore some iomem area.
 
+	resume=		[SWSUSP] specify the partition device for software suspension.
+
 	riscom8=	[HW,SERIAL]
 
 	ro		[KNL] Mount root device read-only on boot.
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/Documentation/swsusp.txt m1/Documentation/swsusp.txt
--- m2/Documentation/swsusp.txt	1970-01-01 01:00:00.000000000 +0100
+++ m1/Documentation/swsusp.txt	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,153 @@
+   --- Software Suspend ('swsusp') for Linux, version 1.0 ---
+
+
+
+   BIG FAT WARNING.
+
+   Although swsusp is quite highly developed, has undergone a lot of testing
+   and is relied upon to do its job, it is still considered to be in 
+   development. As such, no guarantees are given about the safety of your
+   data while using swsusp.
+
+   PLEASE ENSURE YOU HAVE BACKUPS OF IMPORTANT DATA WHEN TRYING SWSUSP,
+   ESPECIALLY WHEN TRYING IT FOR THE FIRST TIME.
+
+
+
+1. What is it?
+2. Why would you want it?
+3. What do you need to use it?
+4. How do you use it?
+5. How do you get support?
+6. What about 2.5 kernels?
+7. When will XXX be supported?
+
+1. What is it?
+
+   Imagine you're sitting at your computer, working away. For some reason, you
+   need to turn off your computer for a while - perhaps it's time to go home
+   for the day. When you come back to your computer next, you're going to want
+   to carry on where you left off. Now image that you could push a button and
+   have your computer store the contents of its memory to disk and power down.
+   Then, when you next start up your computer, it loads that image back into
+   memory and you can carry on from where you were, just as if you'd never
+   turned the compputer off. That's what Software Suspend does.
+
+2. Why would you want it?
+
+   Why wouldn't you want it?
+   
+   Being able to save the state of your system and quickly restore it improves
+   your productivity - you get a useful system in far less time than through
+   the normal boot process.
+   
+3. What do you need to use it?
+
+   Software Suspend is part of the Linux Kernel. It is not part of Marcelo's
+   2.4 tree at the moment, so you will need to download the kernel source and
+   apply the latest patch. Having done that, enable the appropriate options in
+   make [menu|x]config (under General Setup), compile and install your kernel.
+
+   Software Suspend is available from www.sourceforge.net/projects/swsusp.
+
+   Software Suspend stores the image of your memory in your swap partition,
+   so you'll need a large enough swap partition to contain the largest image
+   you'd want to store, plus the space you'd normally use for swap. A good
+   rule of thumb would be to calculate the amount of swap you'd want without
+   using Software Suspend, and then add the amount of memory you have. This
+   swap space can be arranged in any way you'd like. It can be in one partition
+   or spread over a number. The only requirement is that the partitions be
+   activated when you start to suspend. If you want to ensure you have enough
+   memory to suspend, you might want to make one swap partition for 'normal'
+   use, and another to activate just before suspending and deactivate 
+   afterwards.
+
+   Using Software Suspend requires that you add an extra parameter to your
+   lilo.conf or equivalent. Here's an example:
+
+   append="resume=/dev/hda1"
+
+   This would tell Software Suspend that /dev/hda1 is a swap partition you 
+   have. It will use the swap signature of this partition as a pointer to
+   your data when you suspend. This doesn't need to be _the_ swap partition
+   where all your data is actually stored. It just needs to be a swap
+   partition. In the example of two swap partitions given above, /dev/hda1
+   could be your swap partition for normal usage.
+
+   Once you've compiled and installed the kernel, adjusted your lilo.conf
+   and rerun lilo, you should only need to reboot for the most basic part
+   of Software Suspend to be ready.
+
+   Since 2.4 kernels don't have the driver model that's being developed for
+   2.5, you may need to do more, however. Users of Software Suspend usually
+   start the process via a script which prepares for the suspend, tells the 
+   kernel to do its stuff and then restore things afterwards. This script might
+   involve:
+
+   - Switching to a text console and back if X doesn't like the video card
+     status on resume.
+   - Running /sbin/hwclock [--directisa] to update the clock on resume
+   - Un/reloading PCMCIA support since it doesn't play well with swsusp.
+  
+   Note that you might not be able to unload some drivers if there are 
+   processes using them. You might have to kill off processes that hold
+   devices open. Hint: if your X server accesses an USB mouse, doing a
+   'chvt' to a text console releases the device and you can unload the
+   module.
+
+   Check out the latest script (available on Sourceforge).
+   
+4. How do you use it?
+
+   Once your script is properly set up, you should just be able to start it
+   and everything should go like clockwork. Of course things aren't always
+   that easy out of the box.
+
+   Check out (in the kernel source tree) include/linux/suspend-debug for
+   settings you can use to get detailed information about what swsusp is doing.
+   /proc/sys/kernel/swsusp and the kernel parameters swsusp_act, swsusp_dbg
+   and swsusp_lvl allow you to set the action and debugging parameters prior
+   to starting a suspend and/or at the lilo prompt before resuming. There is
+   also a nice little program that should be available from Sourceforge which
+   makes it easier to turn these debugging settings on and off. Note that to
+   get any debugging output, you need to enable it when compiling the kernel.
+   If cat /proc/sys/kernel/swsusp only shows 4 numbers, you didn't do that.
+
+   A neat feature of Software Suspend is that you can press Shift and Alt
+   together at any time during suspending, and the process will be aborted.
+   Due to the way swsusp works, this means you'll have your system back and
+   perfectly usable almost instantly. The only exception is when it's at
+   the very end of writing the image. Then it will need to reload a small
+   (usually 4-50MBs) portion first.
+
+   If you run into problems with resuming, adding the "noresume" option to
+   the kernel command line will let you skip the resume step and
+   (hopefully) recover your system.
+
+5. How do you get support?
+
+   Glad you asked. Software Suspend is being actively maintained and supported,
+   both by Nigel (the guy doing most of the coding at the moment) and its
+   users. You can find the mailing list via the Sourceforge project page.
+
+6. What about 2.5 kernels?
+
+   There is a version of Software Suspend already included in the 2.5 kernel
+   tree. Unfortunately, it lacks a large proportion of the features in 2.4.
+   The hope and plan is to get the 1.0 release of the 2.4 version done, and
+   then complete the port to 2.5 (which shouldn't take long). The struggle
+   will then be to get it integrated into Linus' tree (don't expect this to
+   be quick).
+   
+7. When will XXX be supported?
+
+   Software Suspend currently lacks support for SMP, non x86, SCSI and swap 
+   files.
+
+   The last item is probably the easiest to fix. Patches for the other items
+   (and anything that's been missed) are welcome. Please send to the list.
+
+   Because Nigel's main task is definitely not Software Suspend and he doesn;t
+   have the hardware, he will be unlikely to develop support for any of these
+   in the near future. His development work to date has been driven by the
+   desire to be a user of a more feature complete Software Suspend.
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/Documentation/sysctl/kernel.txt m1/Documentation/sysctl/kernel.txt
--- m2/Documentation/sysctl/kernel.txt	2001-09-30 21:26:08.000000000 +0200
+++ m1/Documentation/sysctl/kernel.txt	2003-07-31 17:27:37.000000000 +0200
@@ -39,6 +39,7 @@ show up in /proc/sys/kernel:
 - rtsig-max
 - sg-big-buff                 [ generic SCSI device (sg) ]
 - shmmax                      [ sysv ipc ]
+- swsusp		      ==> Documentation/swsusp.txt
 - tainted
 - version
 - zero-paged                  [ PPC only ]
@@ -221,6 +222,12 @@ kernel.  This value defaults to SHMMAX.
 
 ==============================================================
 
+swsusp:
+
+Please see kernel/suspend.c for up-to-date documentation.
+
+==============================================================
+
 tainted: 
 
 Non-zero if the kernel has been tainted.  Numeric values, which
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/block/ll_rw_blk.c m1/drivers/block/ll_rw_blk.c
--- m2/drivers/block/ll_rw_blk.c	2003-07-30 18:13:34.000000000 +0200
+++ m1/drivers/block/ll_rw_blk.c	2003-07-31 17:28:39.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/smp_lock.h>
 #include <linux/completion.h>
 #include <linux/bootmem.h>
+#include <linux/suspend.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
@@ -647,7 +648,10 @@ static struct request *__get_request_wai
 	} while (rq == NULL);
 	remove_wait_queue(&q->wait_for_requests, &wait);
 	current->state = TASK_RUNNING;
-
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	if (unlikely(current->flags & PF_FREEZE))
+		refrigerator(PF_IOTHREAD);
+#endif
 	return rq;
 }
 
@@ -1207,6 +1211,10 @@ void generic_make_request (int rw, struc
 	if (!bh->b_end_io)
 		BUG();
 
+#if 0
+	if (suspend_device && (bh->b_rdev != suspend_device))
+		panic("Attempted to corrupt disk.");
+#endif
 	/* Test device size, when known. */
 	if (blk_size[major])
 		minorsize = blk_size[major][MINOR(bh->b_rdev)];
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/block/loop.c m1/drivers/block/loop.c
--- m2/drivers/block/loop.c	2003-07-30 18:13:34.000000000 +0200
+++ m1/drivers/block/loop.c	2003-07-31 17:27:37.000000000 +0200
@@ -71,6 +71,7 @@
 #include <linux/smp_lock.h>
 #include <linux/swap.h>
 #include <linux/slab.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 
@@ -581,7 +582,9 @@ static int loop_thread(void *data)
 	atomic_inc(&lo->lo_pending);
 	spin_unlock_irq(&lo->lo_lock);
 
-	current->flags |= PF_NOIO;
+	current->flags |= PF_NOIO | PF_IOTHREAD; /* loop can be used in an encrypted device
+						    hence, it mustn't be stopped at all because it could
+						    be indirectly used during suspension */
 
 	/*
 	 * up sem, we are running
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/char/agp/agpgart_be.c m1/drivers/char/agp/agpgart_be.c
--- m2/drivers/char/agp/agpgart_be.c	2003-07-30 18:13:35.000000000 +0200
+++ m1/drivers/char/agp/agpgart_be.c	2003-07-31 17:27:37.000000000 +0200
@@ -588,7 +588,7 @@ static int agp_generic_create_gatt_table
 
 	agp_bridge.gatt_table_real = (u32 *) table;
 	agp_gatt_table = (void *)table;
-#ifdef CONFIG_X86
+#if defined(CONFIG_X86) && !defined(CONFIG_SOFTWARE_SUSPEND)
 	err = change_page_attr(virt_to_page(table), 1<<page_order, PAGE_KERNEL_NOCACHE);
 #endif
 	if (!err) 
@@ -621,6 +621,7 @@ static int agp_generic_suspend(void)
 
 static void agp_generic_resume(void)
 {
+  	agp_bridge.configure();
 	return;
 }
 
@@ -660,7 +661,7 @@ static int agp_generic_free_gatt_table(v
 	 * from the table.
 	 */
 
-#ifdef CONFIG_X86
+#if defined(CONFIG_X86) && !defined(CONFIG_SOFTWARE_SUSPEND)
 	change_page_attr(virt_to_page(agp_bridge.gatt_table_real), 1<<page_order, 
 			 PAGE_KERNEL);
 #endif
@@ -786,7 +787,7 @@ static unsigned long agp_generic_alloc_p
 	if (page == NULL) {
 		return 0;
 	}
-#ifdef CONFIG_X86
+#if defined(CONFIG_X86) && !defined(CONFIG_SOFTWARE_SUSPEND)
 	if (change_page_attr(page, 1, PAGE_KERNEL_NOCACHE) < 0) {
 		__free_page(page); 
 		return 0;
@@ -808,7 +809,7 @@ static void agp_generic_destroy_page(uns
 	}
 	
 	page = virt_to_page(pt);
-#ifdef CONFIG_X86
+#if defined(CONFIG_X86) && !defined(CONFIG_SOFTWARE_SUSPEND)
 	change_page_attr(page, 1, PAGE_KERNEL); 
 #endif	
 	put_page(page);
@@ -1824,11 +1825,6 @@ static unsigned long intel_mask_memory(u
 	return addr | agp_bridge.masks[0].mask;
 }
 
-static void intel_resume(void)
-{
-	intel_configure();
-}
-
 /* Setup function */
 static gatt_mask intel_generic_masks[] =
 {
@@ -1895,7 +1891,7 @@ static int __init intel_generic_setup (s
 	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
 	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
 	agp_bridge.suspend = agp_generic_suspend;
-	agp_bridge.resume = intel_resume;
+	agp_bridge.resume = agp_generic_resume;
 	agp_bridge.cant_use_aperture = 0;
 
 	return 0;
@@ -2382,7 +2378,7 @@ static int amd_create_page_map(amd_page_
 	}
 	SetPageReserved(virt_to_page(page_map->real));
 	CACHE_FLUSH();
-#ifdef CONFIG_X86
+#if defined(CONFIG_X86) && !defined(CONFIG_SOFTWARE_SUSPEND)
 	err = change_page_attr(virt_to_page(page_map->real), 1, PAGE_KERNEL_NOCACHE);
 #endif
 	if (!err) 
@@ -2406,7 +2402,7 @@ static int amd_create_page_map(amd_page_
 static void amd_free_page_map(amd_page_map *page_map)
 {
 	iounmap(page_map->remapped);
-#ifdef CONFIG_X86
+#if defined(CONFIG_X86) && !defined(CONFIG_SOFTWARE_SUSPEND)
 	change_page_attr(virt_to_page(page_map->real), 1, PAGE_KERNEL);
 #endif
 	ClearPageReserved(virt_to_page(page_map->real));
@@ -3473,7 +3469,7 @@ static int serverworks_create_page_map(s
 		return -ENOMEM;
 	}
 	SetPageReserved(virt_to_page(page_map->real));
-#ifdef CONFIG_X86
+#if defined(CONFIG_X86) && !defined(CONFIG_SOFTWARE_SUSPEND)
 	err = change_page_attr(virt_to_page(page_map->real), 1, PAGE_KERNEL_NOCACHE);
 #endif
 	CACHE_FLUSH();
@@ -3497,7 +3493,7 @@ static int serverworks_create_page_map(s
 
 static void serverworks_free_page_map(serverworks_page_map *page_map)
 {
-#ifdef CONFIG_X86
+#if defined(CONFIG_X86) && !defined(CONFIG_SOFTWARE_SUSPEND)
 	change_page_attr(virt_to_page(page_map->real),1,PAGE_KERNEL); 
 #endif
 	iounmap(page_map->remapped);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/char/console.c m1/drivers/char/console.c
--- m2/drivers/char/console.c	2002-11-29 00:53:12.000000000 +0100
+++ m1/drivers/char/console.c	2003-07-31 17:27:37.000000000 +0200
@@ -147,11 +147,11 @@ static void vc_init(unsigned int console
 static void blank_screen(unsigned long dummy);
 static void gotoxy(int currcons, int new_x, int new_y);
 static void save_cur(int currcons);
-static void reset_terminal(int currcons, int do_clear);
+void reset_terminal(int currcons, int do_clear);
 static void con_flush_chars(struct tty_struct *tty);
 static void set_vesa_blanking(unsigned long arg);
 static void set_cursor(int currcons);
-static void hide_cursor(int currcons);
+void hide_cursor(int currcons);
 static void unblank_screen_t(unsigned long dummy);
 static void console_callback(void *ignored);
 
@@ -522,7 +522,7 @@ static void add_softcursor(int currcons)
 		sw->con_putc(vc_cons[currcons].d, i, y, x);
 }
 
-static void hide_cursor(int currcons)
+void hide_cursor(int currcons)
 {
 	if (currcons == sel_cons)
 		clear_selection();
@@ -1389,7 +1389,7 @@ enum { ESnormal, ESesc, ESsquare, ESgetp
 	ESpalette };
 
 /* console_sem is held (except via vc_init()) */
-static void reset_terminal(int currcons, int do_clear)
+void reset_terminal(int currcons, int do_clear)
 {
 	top		= 0;
 	bottom		= video_num_lines;
@@ -3020,6 +3020,8 @@ EXPORT_SYMBOL(video_scan_lines);
 EXPORT_SYMBOL(vc_resize);
 EXPORT_SYMBOL(fg_console);
 EXPORT_SYMBOL(console_blank_hook);
+EXPORT_SYMBOL(hide_cursor);
+EXPORT_SYMBOL(reset_terminal);
 #ifdef CONFIG_VT
 EXPORT_SYMBOL(vt_cons);
 #endif
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/char/keyboard.c m1/drivers/char/keyboard.c
--- m2/drivers/char/keyboard.c	2003-06-13 16:51:33.000000000 +0200
+++ m1/drivers/char/keyboard.c	2003-07-31 17:27:37.000000000 +0200
@@ -32,6 +32,10 @@
 #include <linux/string.h>
 #include <linux/random.h>
 #include <linux/init.h>
+#ifdef CONFIG_SOFTWARE_SUSPEND
+#include <linux/suspend.h>
+#include <linux/suspend-debug.h>
+#endif
 
 #include <asm/keyboard.h>
 #include <asm/bitops.h>
@@ -152,7 +156,7 @@ static unsigned char handle_diacr(unsign
 struct pt_regs * kbd_pt_regs;
 
 #ifdef CONFIG_MAGIC_SYSRQ
-static int sysrq_pressed;
+int sysrq_pressed;  /* Made non static so swsusp can reset on resume */
 #endif
 
 static struct pm_dev *pm_kbd;
@@ -263,6 +267,59 @@ void handle_scancode(unsigned char scanc
 	}
 #endif
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	if (!up_flag && (suspend_task)) {
+		extern void prepare_status(int printalways, int clearbar, const char *fmt, ...);
+		extern unsigned long swsusp_action;
+		extern void request_abort_suspend(void);
+		switch (keycode) {
+			case 60:
+			case 1:
+				/* Abort suspend */
+				if (TEST_ACTION_STATE(SUSPEND_CAN_CANCEL))
+					request_abort_suspend();
+				break;
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+			case 101:
+			case 119:
+				/* During suspend, toggle pausing with Pause or Break if kdb active */
+				swsusp_action ^= (1 << SUSPEND_PAUSE);
+				prepare_status(1, 0, "Pausing %s.\n", 
+					TEST_ACTION_STATE(SUSPEND_PAUSE) ? "enabled" : "disabled");
+				break;
+			case 19:
+				/* Otherwise, if R pressed, toggle rebooting */
+				swsusp_action ^= (1 << SUSPEND_REBOOT);
+				prepare_status(1, 0, "Rebooting %s.\n", 
+					TEST_ACTION_STATE(SUSPEND_REBOOT) ? "enabled" : "disabled");
+				break;
+			case 38:
+				/* Otherwise, if L pressed, toggle logging everything */
+				swsusp_action ^= (1 << SUSPEND_LOGALL);
+				prepare_status(1, 0, "Logging all output %s.\n", 
+					TEST_ACTION_STATE(SUSPEND_LOGALL) ? "enabled" : "disabled");
+				break;
+			case 2:
+			case 3:
+			case 4:
+			case 5:
+			case 6:
+			case 7:
+			case 8:
+			case 9:
+			case 10:
+				console_loglevel = ((keycode - 1));
+				break;
+			case 11:
+				console_loglevel = 0;
+				break;
+#endif
+		}
+		if (keycode != 42)
+			goto out;
+	}
+#endif
+
 	if (kbd->kbdmode == VC_MEDIUMRAW) {
 		/* soon keycodes will require more than one byte */
 		put_queue(keycode + up_flag);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/char/sysrq.c m1/drivers/char/sysrq.c
--- m2/drivers/char/sysrq.c	2003-07-30 18:13:35.000000000 +0200
+++ m1/drivers/char/sysrq.c	2003-07-31 17:27:37.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/quotaops.h>
 #include <linux/smp_lock.h>
 #include <linux/module.h>
+#include <linux/suspend.h>
 
 #include <linux/spinlock.h>
 
@@ -47,7 +48,8 @@ static void sysrq_handle_loglevel(int ke
 	int i;
 	i = key - '0';
 	console_loglevel = 7;
-	printk("Loglevel set to %d\n", i);
+	if (!suspend_task)
+		printk("Loglevel set to %d\n", i);
 	console_loglevel = i;
 }	
 static struct sysrq_key_op sysrq_loglevel_op = {
@@ -442,7 +444,8 @@ void __handle_sysrq_nolock(int key, stru
 		return;
 
 	orig_log_level = console_loglevel;
-	console_loglevel = 7;
+	if (!suspend_task) /* Not if nice display on */
+		console_loglevel = 7;
 	printk(KERN_INFO "SysRq : ");
 
         op_p = __sysrq_get_key_op(key);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/ide/ide-disk.c m1/drivers/ide/ide-disk.c
--- m2/drivers/ide/ide-disk.c	2003-06-13 16:51:33.000000000 +0200
+++ m1/drivers/ide/ide-disk.c	2003-07-31 17:27:37.000000000 +0200
@@ -60,6 +60,7 @@
 #include <linux/genhd.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
+#include <linux/suspend-debug.h>
 
 #define _IDE_DISK
 
@@ -1866,64 +1867,87 @@ ide_startstop_t panic_box(ide_drive_t *d
 	return ide_stopped;
 }
 
-int ide_disks_busy(void)
+int ide_disks_busy(int no_warning)
 {
 	int i;
-	for (i=0; i<MAX_HWIFS; i++) {
-		struct hwgroup_s *hwgroup = ide_hwifs[i].hwgroup;
-		if (!hwgroup) continue;
-		if ((hwgroup->handler) && (hwgroup->handler != panic_box))
-			return 1;
-	}
+	
+	for (i=0; i<MAX_HWIFS; i++)
+		if(ide_hwifs[i].present) { /* when using pcmcia ide-disk hwgroup is non NULL but the
+					      disk can be absent */
+			struct hwgroup_s *hwgroup = ide_hwifs[i].hwgroup;
+			if (!hwgroup) continue;
+			if ((hwgroup->handler) && (hwgroup->handler != panic_box)) {
+				if(!no_warning) /* busy ide disks is not an error */
+					printk("ide_disks_busy: %6s: handler not null: %p\n",
+					       ide_hwifs[i].name,hwgroup->handler);
+				return 1;
+			}
+		}
 	return 0;
 }
 
 void ide_disk_suspend(void)
 {
-	int i;
-	while (ide_disks_busy()) {
-		printk("*");
+	int i, drivenum = 0;
+	ide_drive_t *drive;
+
+	if (driver_blocked)
+		return;
+
+	i=1;
+	while (ide_disks_busy(i++)) {
 		schedule();
+		i &= (unsigned int)((1<<21)-1);	/* CBD: we print a warning only after a great number of errors, no need to frighten the newbie ;-) */
 	}
-	for (i=0; i<MAX_HWIFS; i++) {
-		struct hwgroup_s *hwgroup = ide_hwifs[i].hwgroup;
-
-		if (!hwgroup) continue;
-		hwgroup->handler_save = hwgroup->handler;
-		hwgroup->handler = panic_box;
+	/* Ensure caches are purged too (derived from module unload) - Nigel Cunningham */
+	while ((drive = ide_scan_devices(ide_disk, idedisk_driver.name,
+			&idedisk_driver, drivenum)) != NULL) {
+		if ((drive->id->command_set_1 & 0x20) && drive->id->cfs_enable_1 & 0x20) {
+			if (do_idedisk_flushcache(drive))
+				printk(KERN_ERR "Failed!");
+		}
+		drivenum++;
 	}
+	
+	for (i=0; i<MAX_HWIFS; i++)
+		if(ide_hwifs[i].present) { /* when using pcmcia ide-disk hwgroup is non NULL but the
+					      disk can be absent */		
+			struct hwgroup_s *hwgroup = ide_hwifs[i].hwgroup;
+
+			if (!hwgroup) continue;
+			hwgroup->handler = panic_box;
+		}
 	driver_blocked = 1;
-	if (ide_disks_busy())
+	if (ide_disks_busy(0))
 		panic("How did you get that request through?!");
 }
 
-/* unsuspend and resume should be equal in the ideal world */
-
-void ide_disk_unsuspend(void)
+void ide_disk_unsuspend(int resume)
 {
 	int i;
-	for (i=0; i<MAX_HWIFS; i++) {
-		struct hwgroup_s *hwgroup = ide_hwifs[i].hwgroup;
-
-		if (!hwgroup) continue;
-		hwgroup->handler = NULL; /* hwgroup->handler_save; */
-		hwgroup->handler_save = NULL;
-	}
-	driver_blocked = 0;
-}
 
-void ide_disk_resume(void)
-{
-	int i;
-	for (i=0; i<MAX_HWIFS; i++) {
-		struct hwgroup_s *hwgroup = ide_hwifs[i].hwgroup;
+	if (!driver_blocked)
+		return;
 
-		if (!hwgroup) continue;
-		if (hwgroup->handler != panic_box)
-			panic("Handler was not set to panic?");
-		hwgroup->handler_save = NULL;
-		hwgroup->handler = NULL;
-	}
+	for (i=0; i<MAX_HWIFS; i++)
+		if(ide_hwifs[i].present) { /* when using pcmcia ide-disk hwgroup is non NULL but the
+					      disk can be absent */
+
+			struct hwgroup_s *hwgroup = ide_hwifs[i].hwgroup;
+
+			if (!hwgroup) continue;
+			if (hwgroup->handler != panic_box)
+				printk(KERN_ERR "ide_disk_unsuspend: %6s: Handler was not set to panic? %p",
+				       ide_hwifs[i].name,hwgroup->handler);
+			hwgroup->handler = NULL;
+#if 0				/* CBD: not working on my configs. Necessary for others? */
+			if(resume) {
+			  	printk("ide_disk_unsuspend: %6s: reinit drive %p",
+				       ide_hwifs[i].name,hwgroup->drive);
+				ide_reinit_drive(hwgroup->drive);
+			}
+#endif
+		}
 	driver_blocked = 0;
 }
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/md/md.c m1/drivers/md/md.c
--- m2/drivers/md/md.c	2003-07-30 18:13:35.000000000 +0200
+++ m1/drivers/md/md.c	2003-07-31 17:27:37.000000000 +0200
@@ -3425,7 +3425,6 @@ int md_do_sync(mddev_t *mddev, mdp_disk_
 	struct md_list_head *tmp;
 	unsigned long last_check;
 
-
 	err = down_interruptible(&mddev->resync_sem);
 	if (err)
 		goto out_nolock;
@@ -3588,6 +3587,8 @@ void md_do_recovery(void *data)
 	mdp_disk_t *spare;
 	struct md_list_head *tmp;
 
+	current->flags |= PF_IOTHREAD;
+
 	printk(KERN_INFO "md: recovery thread got woken up ...\n");
 restart:
 	ITERATE_MDDEV(mddev,tmp) {
@@ -3797,6 +3798,15 @@ void md_autodetect_dev(kdev_t dev)
 		detected_devices[dev_cnt++] = dev;
 }
 
+void md_autostart_arrays(void)
+{
+  	struct md_list_head *tmp;
+	mddev_t *mddev;
+	
+	autostart_arrays();
+	ITERATE_MDDEV(mddev, tmp)
+  		restart_array(mddev);
+}
 
 static void autostart_arrays(void)
 {
@@ -4127,4 +4137,5 @@ MD_EXPORT_SYMBOL(md_interrupt_thread);
 MD_EXPORT_SYMBOL(mddev_map);
 MD_EXPORT_SYMBOL(md_check_ordering);
 MD_EXPORT_SYMBOL(get_spare);
+MD_EXPORT_SYMBOL(md_autostart_arrays);
 MODULE_LICENSE("GPL");
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/md/raid1.c m1/drivers/md/raid1.c
--- m2/drivers/md/raid1.c	2003-06-13 16:51:34.000000000 +0200
+++ m1/drivers/md/raid1.c	2003-07-31 17:27:37.000000000 +0200
@@ -1162,6 +1162,7 @@ static void raid1d (void *data)
 
 	if (mddev->sb_dirty)
 		md_update_sb(mddev);
+	current->flags |= PF_IOTHREAD;
 
 	for (;;) {
 		md_spin_lock_irqsave(&retry_list_lock, flags);
@@ -1286,6 +1287,8 @@ static void raid1syncd (void *data)
 	raid1_conf_t *conf = data;
 	mddev_t *mddev = conf->mddev;
 
+	current->flags |= PF_IOTHREAD;
+
 	if (!conf->resync_mirrors)
 		return;
 	if (conf->resync_mirrors == 2)
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/md/raid5.c m1/drivers/md/raid5.c
--- m2/drivers/md/raid5.c	2003-07-30 18:13:35.000000000 +0200
+++ m1/drivers/md/raid5.c	2003-07-31 17:27:37.000000000 +0200
@@ -1299,6 +1299,8 @@ static void raid5d (void *data)
 
 	PRINTK("+++ raid5d active\n");
 
+	current->flags |= PF_IOTHREAD;
+
 	handled = 0;
 
 	if (mddev->sb_dirty)
@@ -1348,6 +1350,8 @@ static void raid5syncd (void *data)
 	raid5_conf_t *conf = data;
 	mddev_t *mddev = conf->mddev;
 
+	current->flags |= PF_IOTHREAD;
+
 	if (!conf->resync_parity)
 		return;
 	if (conf->resync_parity == 2)
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/net/8139too.c m1/drivers/net/8139too.c
--- m2/drivers/net/8139too.c	2003-07-30 18:13:36.000000000 +0200
+++ m1/drivers/net/8139too.c	2003-07-31 17:27:37.000000000 +0200
@@ -110,6 +110,7 @@
 #include <linux/mii.h>
 #include <linux/completion.h>
 #include <linux/crc32.h>
+#include <linux/suspend.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
 
@@ -1597,10 +1598,13 @@ static int rtl8139_thread (void *data)
 
 	strncpy (current->comm, dev->name, sizeof(current->comm) - 1);
 	current->comm[sizeof(current->comm) - 1] = '\0';
+	current->flags |= PF_REFRIGERATE;
 
 	while (1) {
 		timeout = next_tick;
 		do {
+			if (current->flags & PF_FREEZE)
+				refrigerator(PF_IOTHREAD);
 			timeout = interruptible_sleep_on_timeout (&tp->thr_wait, timeout);
 		} while (!signal_pending (current) && (timeout > 0));
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/net/eepro100.c m1/drivers/net/eepro100.c
--- m2/drivers/net/eepro100.c	2003-07-30 18:13:37.000000000 +0200
+++ m1/drivers/net/eepro100.c	2003-07-31 17:27:37.000000000 +0200
@@ -529,6 +529,8 @@ static const char is_mii[] = { 0, 1, 1, 
 static int eepro100_init_one(struct pci_dev *pdev,
 		const struct pci_device_id *ent);
 static void eepro100_remove_one (struct pci_dev *pdev);
+static int eepro100_suspend (struct pci_dev *pdev, u32 state);
+static int eepro100_resume (struct pci_dev *pdev);
 
 static int do_eeprom_cmd(long ioaddr, int cmd, int cmd_len);
 static int mdio_read(struct net_device *dev, int phy_id, int location);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/net/via-rhine.c m1/drivers/net/via-rhine.c
--- m2/drivers/net/via-rhine.c	2003-07-30 18:13:37.000000000 +0200
+++ m1/drivers/net/via-rhine.c	2003-07-31 17:27:37.000000000 +0200
@@ -1893,12 +1893,40 @@ static void __devexit via_rhine_remove_o
 	pci_set_drvdata(pdev, NULL);
 }
 
+#ifdef CONFIG_PM
+static int via_rhine_suspend(struct pci_dev *pdev, u32 state)
+{
+	printk("Suspending via_rhine...\n");
+#if 0
+	via_rhine_remove_one(pdev);
+#endif
+	return 0;
+}
+
+static int via_rhine_resume(struct pci_dev *pdev)
+{
+	long ioaddr;
+	
+	printk("Resuming via_rhine...\n");
+#if 1
+	ioaddr = pci_resource_start (pdev, 0);
+	/* Reset the chip. */
+	writew(CmdReset, ioaddr + ChipCmd);
+#endif
+	return 0;
+}
+#endif
+					    
 
 static struct pci_driver via_rhine_driver = {
 	.name		= "via-rhine",
 	.id_table	= via_rhine_pci_tbl,
 	.probe		= via_rhine_init_one,
 	.remove		= __devexit_p(via_rhine_remove_one),
+#ifdef CONFIG_PM
+	.suspend	= via_rhine_suspend,
+	.resume		= via_rhine_resume
+#endif
 };
 
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/usb/host/usb-ohci.c m1/drivers/usb/host/usb-ohci.c
--- m2/drivers/usb/host/usb-ohci.c	2003-07-30 18:13:39.000000000 +0200
+++ m1/drivers/usb/host/usb-ohci.c	2003-07-31 17:27:37.000000000 +0200
@@ -65,6 +65,7 @@
 #include <linux/init.h>
 #include <linux/timer.h>
 #include <linux/list.h>
+#include <linux/suspend.h>
 #include <linux/interrupt.h>  /* for in_interrupt() */
 #undef DEBUG
 #include <linux/usb.h>
@@ -107,6 +108,9 @@
 static LIST_HEAD (ohci_hcd_list);
 static spinlock_t usb_ed_lock = SPIN_LOCK_UNLOCKED;
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+static ohci_t *ohci_save = NULL;
+#endif /* CONFIG_SOFTWARE_SUSPEND */
 
 /*-------------------------------------------------------------------------*/
 
@@ -2580,6 +2584,14 @@ static void hc_restart (ohci_t *ohci)
 	int temp;
 	int i;
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	/* dont do anything till we're out of a software suspend */
+	if (suspend_task) {
+		ohci_save = ohci;
+		return;
+	}
+#endif /* CONFIG_SOFTWARE_SUSPEND */
+
 	if (ohci->pci_latency)
 		pci_write_config_byte (ohci->ohci_dev, PCI_LATENCY_TIMER, ohci->pci_latency);
 
@@ -2938,23 +2950,49 @@ static struct pci_driver ohci_pci_driver
 };
 
  
+#ifdef CONFIG_SOFTWARE_SUSPEND
+static struct notifier_block ohci_resume_notifier;
+#endif /* CONFIG_SOFTWARE_SUSPEND */
+
 /*-------------------------------------------------------------------------*/
 
 static int __init ohci_hcd_init (void) 
 {
-	return pci_module_init (&ohci_pci_driver);
+	int retval = pci_module_init (&ohci_pci_driver);
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	if (!retval)
+		register_resume_notifier(&ohci_resume_notifier);
+#endif /* CONFIG_SOFTWARE_SUSPEND */
+	return retval;
 }
 
 /*-------------------------------------------------------------------------*/
 
 static void __exit ohci_hcd_cleanup (void) 
 {	
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	unregister_resume_notifier(&ohci_resume_notifier);
+#endif /* CONFIG_SOFTWARE_SUSPEND */
 	pci_unregister_driver (&ohci_pci_driver);
 }
 
 module_init (ohci_hcd_init);
 module_exit (ohci_hcd_cleanup);
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+static int ohci_swsusp_resume(struct notifier_block *self, unsigned long v, void *vp)
+{
+	if (ohci_save) {
+		hc_restart(ohci_save);
+		ohci_save = NULL;
+	}
+	return 0;
+}
+
+static struct notifier_block ohci_resume_notifier = {
+	.notifier_call = ohci_swsusp_resume,
+};
+#endif /* CONFIG_SOFTWARE_SUSPEND */
 
 MODULE_AUTHOR( DRIVER_AUTHOR );
 MODULE_DESCRIPTION( DRIVER_DESC );
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/usb/hub.c m1/drivers/usb/hub.c
--- m2/drivers/usb/hub.c	2003-07-30 18:13:39.000000000 +0200
+++ m1/drivers/usb/hub.c	2003-07-31 17:27:37.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/list.h>
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 #ifdef CONFIG_USB_DEBUG
 	#define DEBUG
 #else
@@ -914,11 +915,14 @@ static int usb_hub_thread(void *__hub)
 
 	/* Setup a nice name */
 	strcpy(current->comm, "khubd");
+	current->flags |= PF_REFRIGERATE;
 
 	/* Send me a signal to get me die (for debugging) */
 	do {
 		usb_hub_events();
 		wait_event_interruptible(khubd_wait, !list_empty(&hub_event_list)); 
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_IOTHREAD);
 	} while (!signal_pending(current));
 
 	dbg("usb_hub_thread exiting");
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/drivers/usb/storage/usb.c m1/drivers/usb/storage/usb.c
--- m2/drivers/usb/storage/usb.c	2003-07-30 18:13:39.000000000 +0200
+++ m1/drivers/usb/storage/usb.c	2003-07-31 17:27:37.000000000 +0200
@@ -319,6 +319,7 @@ static int usb_stor_control_thread(void 
 	 */
 	exit_files(current);
 	current->files = init_task.files;
+	current->flags |= PF_IOTHREAD;
 	atomic_inc(&current->files->count);
 	daemonize();
 	reparent_to_init();
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/fs/buffer.c m1/fs/buffer.c
--- m2/fs/buffer.c	2003-07-30 18:13:39.000000000 +0200
+++ m1/fs/buffer.c	2003-07-31 17:27:37.000000000 +0200
@@ -47,6 +47,8 @@
 #include <linux/highmem.h>
 #include <linux/module.h>
 #include <linux/completion.h>
+#include <linux/suspend.h>
+#include <linux/suspend-debug.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -71,16 +73,16 @@ static unsigned int bh_hash_shift;
 static struct buffer_head **hash_table;
 static rwlock_t hash_table_lock = RW_LOCK_UNLOCKED;
 
-static struct buffer_head *lru_list[NR_LIST];
+struct buffer_head *lru_list[NR_LIST];
 
 static spinlock_cacheline_t lru_list_lock_cacheline = {SPIN_LOCK_UNLOCKED};
 #define lru_list_lock  lru_list_lock_cacheline.lock
 
-static int nr_buffers_type[NR_LIST];
+int nr_buffers_type[NR_LIST];
 static unsigned long size_buffers_type[NR_LIST];
 
 static struct buffer_head * unused_list;
-static int nr_unused_buffer_heads;
+int nr_unused_buffer_heads;
 static spinlock_t unused_list_lock = SPIN_LOCK_UNLOCKED;
 static DECLARE_WAIT_QUEUE_HEAD(buffer_wait);
 
@@ -208,7 +210,7 @@ static void write_locked_buffers(struct 
  * return without it!
  */
 #define NRSYNC (32)
-static int write_some_buffers(kdev_t dev)
+int write_some_buffers(kdev_t dev)
 {
 	struct buffer_head *next;
 	struct buffer_head *array[NRSYNC];
@@ -222,6 +224,8 @@ static int write_some_buffers(kdev_t dev
 		struct buffer_head * bh = next;
 		next = bh->b_next_free;
 
+		if (current->flags & PF_FREEZE)
+			return 0;
 		if (dev != NODEV && bh->b_dev != dev)
 			continue;
 		if (test_and_set_bit(BH_Lock, &bh->b_state))
@@ -247,14 +251,11 @@ static int write_some_buffers(kdev_t dev
 	return 0;
 }
 
-/*
- * Write out all buffers on the dirty list.
- */
 static void write_unlocked_buffers(kdev_t dev)
 {
 	do
 		spin_lock(&lru_list_lock);
-	while (write_some_buffers(dev));
+	while ((!(current->flags & PF_FREEZE)) && write_some_buffers(dev));
 }
 
 /*
@@ -274,6 +275,9 @@ static int wait_for_buffers(kdev_t dev, 
 		struct buffer_head *bh = next;
 		next = bh->b_next_free;
 
+		if (current->flags & PF_FREEZE)
+			return 0;
+
 		if (!buffer_locked(bh)) {
 			if (refile)
 				__refile_buffer(bh);
@@ -284,7 +288,7 @@ static int wait_for_buffers(kdev_t dev, 
 
 		get_bh(bh);
 		spin_unlock(&lru_list_lock);
-		wait_on_buffer (bh);
+		wait_on_buffer(bh);
 		put_bh(bh);
 		return -EAGAIN;
 	}
@@ -296,7 +300,7 @@ static int wait_for_locked_buffers(kdev_
 {
 	do {
 		spin_lock(&lru_list_lock);
-	} while (wait_for_buffers(dev, index, refile));
+	} while ((!(current->flags & PF_FREEZE)) && wait_for_buffers(dev, index, refile));
 	return 0;
 }
 
@@ -310,6 +314,11 @@ static int wait_for_locked_buffers(kdev_
  * We will ultimately want to put these in a separate list, but for
  * now we search all of the lists for dirty buffers.
  */
+
+/* If the current process (esp kupdated) is being put in the fridge, we
+ * drop out of this early. (This means we can suspend without waiting
+ * for fsync to finish!)
+ */
 int sync_buffers(kdev_t dev, int wait)
 {
 	int err = 0;
@@ -746,7 +755,8 @@ static void free_more_memory(void)
 {
 	balance_dirty();
 	wakeup_bdflush();
-	try_to_free_pages(GFP_NOIO);
+	if (likely(suspend_task != current->pid))
+		try_to_free_pages(GFP_NOIO);
 	run_task_queue(&tq_disk);
 	yield();
 }
@@ -758,7 +768,7 @@ void init_buffer(struct buffer_head *bh,
 	bh->b_private = private;
 }
 
-static void end_buffer_io_async(struct buffer_head * bh, int uptodate)
+void end_buffer_io_async(struct buffer_head * bh, int uptodate)
 {
 	static spinlock_t page_uptodate_lock = SPIN_LOCK_UNLOCKED;
 	unsigned long flags;
@@ -1047,6 +1057,7 @@ void balance_dirty(void)
 		write_some_buffers(NODEV);
 	}
 }
+
 EXPORT_SYMBOL(balance_dirty);
 
 inline void __mark_dirty(struct buffer_head *bh)
@@ -1081,7 +1092,7 @@ EXPORT_SYMBOL(set_buffer_flushtime);
  * A buffer may need to be moved from one buffer list to another
  * (e.g. in case it is not shared any more). Handle this.
  */
-static void __refile_buffer(struct buffer_head *bh)
+void __refile_buffer(struct buffer_head *bh)
 {
 	int dispose = BUF_CLEAN;
 	if (buffer_locked(bh))
@@ -1138,6 +1149,8 @@ struct buffer_head * bread(kdev_t dev, i
 {
 	struct buffer_head * bh;
 
+	if (unlikely(current->flags & PF_FREEZE))
+		refrigerator(PF_IOTHREAD);
 	bh = getblk(dev, block, size);
 	if (buffer_uptodate(bh))
 		return bh;
@@ -1201,7 +1214,7 @@ struct buffer_head * get_unused_buffer_h
 	 * to get more buffer heads, because the FS may need
 	 * more buffer-heads itself.  Thus SLAB_NOFS.
 	 */
-	if((bh = kmem_cache_alloc(bh_cachep, SLAB_NOFS)) != NULL) {
+	if((suspend_task != current->pid) && (bh = kmem_cache_alloc(bh_cachep, SLAB_NOFS)) != NULL) {
 		bh->b_blocknr = -1;
 		bh->b_this_page = NULL;
 		return bh;
@@ -1248,6 +1261,12 @@ EXPORT_SYMBOL(set_bh_page);
  * from ordinary buffer allocations, and only async requests are allowed
  * to sleep waiting for buffer heads. 
  */
+
+#ifdef CONFIG_SOFTWARE_SUSPEND
+extern void cleanup_finished_swsusp_io(void);
+extern void sync_swap_partitions(void);
+#endif
+
 static struct buffer_head * create_buffers(struct page * page, unsigned long size, int async)
 {
 	struct buffer_head *bh, *head;
@@ -1303,15 +1322,22 @@ no_grow:
 	if (!async)
 		return NULL;
 
-	/* We're _really_ low on memory. Now we just
-	 * wait for old buffer heads to become free due to
-	 * finishing IO.  Since this is an async request and
-	 * the reserve list is empty, we're sure there are 
-	 * async buffer heads in use.
+	/* We're _really_ low on memory or in swsusp and not
+	 * wanting to make our image inconsistent by allocating
+	 * extra pages. Now we just wait for old buffer heads 
+	 * to become free due to finishing IO.  Since this is
+	 * an async request and the reserve list is empty, 
+	 * we're sure there are async buffer heads in use.
 	 */
 	run_task_queue(&tq_disk);
 
 	free_more_memory();
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	if (suspend_task == current->pid) {
+		cleanup_finished_swsusp_io();
+		//sync_swap_partitions();
+	}
+#endif
 	goto try_again;
 }
 
@@ -1413,6 +1439,11 @@ void create_empty_buffers(struct page *p
 
 	/* FIXME: create_buffers should fail if there's no enough memory */
 	head = create_buffers(page, blocksize, 1);
+
+	/* Head only NULL if swsusp is running - shouldn't happen on this path */
+	if (!head)
+		BUG();
+	
 	if (page->buffers)
 		BUG();
 
@@ -2401,7 +2432,8 @@ int brw_page(int rw, struct page *page, 
 		panic("brw_page: page not locked for I/O");
 
 	if (!page->buffers)
-		create_empty_buffers(page, dev, size);
+ 		create_empty_buffers(page, dev, size);
+
 	head = bh = page->buffers;
 
 	/* Stage 1: lock all the buffers */
@@ -2496,7 +2528,12 @@ static struct page * grow_dev_page(struc
 			goto failed;
 	}
 
-	bh = create_buffers(page, size, 0);
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	if (suspend_task == current->pid)
+		bh = create_buffers(page, size, 1);
+	else
+#endif
+		bh = create_buffers(page, size, 0);
 	if (!bh)
 		goto failed;
 	link_dev_buffers(page, bh);
@@ -2880,6 +2917,8 @@ static int sync_old_buffers(void)
 		bh = lru_list[BUF_DIRTY];
 		if (!bh || time_before(jiffies, bh->b_flushtime))
 			break;
+		if (current->flags & PF_FREEZE)
+			break;
 		if (write_some_buffers(NODEV))
 			continue;
 		return 0;
@@ -2965,6 +3004,7 @@ int bdflush(void *startup)
 	tsk->session = 1;
 	tsk->pgrp = 1;
 	strcpy(tsk->comm, "bdflush");
+	tsk->flags |= PF_REFRIGERATE;
 
 	/* avoid getting signals */
 	spin_lock_irq(&tsk->sigmask_lock);
@@ -2996,6 +3036,8 @@ int bdflush(void *startup)
 				break;
 			ndirty -= NRSYNC;
 		}
+		if (unlikely(current->flags & PF_FREEZE))
+			refrigerator(PF_IOTHREAD);
 		if (ndirty > 0 || bdflush_stop())
 			interruptible_sleep_on(&bdflush_wait);
 	}
@@ -3015,6 +3057,7 @@ int kupdate(void *startup)
 	tsk->session = 1;
 	tsk->pgrp = 1;
 	strcpy(tsk->comm, "kupdated");
+	tsk->flags |= PF_REFRIGERATE;
 
 	/* sigstop and sigcont will stop and wakeup kupdate */
 	spin_lock_irq(&tsk->sigmask_lock);
@@ -3028,6 +3071,8 @@ int kupdate(void *startup)
 	for (;;) {
 		/* update interval */
 		interval = bdf_prm.b_un.interval;
+		if (unlikely(current->flags & PF_FREEZE))
+			refrigerator(PF_IOTHREAD);
 		if (interval) {
 			tsk->state = TASK_INTERRUPTIBLE;
 			schedule_timeout(interval);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/fs/inode.c m1/fs/inode.c
--- m2/fs/inode.c	2003-07-30 18:13:40.000000000 +0200
+++ m1/fs/inode.c	2003-07-31 17:27:37.000000000 +0200
@@ -356,7 +356,7 @@ static inline int try_to_sync_unused_lis
 void sync_inodes_sb(struct super_block *sb)
 {
 	spin_lock(&inode_lock);
-	while (!list_empty(&sb->s_dirty)||!list_empty(&sb->s_locked_inodes)) {
+	while ((!list_empty(&sb->s_dirty)||!list_empty(&sb->s_locked_inodes)) && (!(current->flags & PF_FREEZE))) {
 		sync_list(&sb->s_dirty);
 		wait_on_locked(&sb->s_locked_inodes);
 	}
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/fs/jbd/commit.c m1/fs/jbd/commit.c
--- m2/fs/jbd/commit.c	2003-06-13 16:51:37.000000000 +0200
+++ m1/fs/jbd/commit.c	2003-07-31 17:27:37.000000000 +0200
@@ -20,6 +20,7 @@
 #include <linux/slab.h>
 #include <linux/locks.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 
 extern spinlock_t journal_datalist_lock;
 
@@ -756,4 +757,6 @@ skip_commit: /* The journal should be un
 
 	unlock_journal(journal);
 	wake_up(&journal->j_wait_done_commit);
+	if (current->flags & PF_FREEZE)
+		refrigerator(PF_IOTHREAD);
 }
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/fs/jbd/journal.c m1/fs/jbd/journal.c
--- m2/fs/jbd/journal.c	2003-07-30 18:13:40.000000000 +0200
+++ m1/fs/jbd/journal.c	2003-07-31 17:27:37.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/jbd.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
+#include <linux/suspend.h>
 #include <linux/locks.h>
 #include <linux/smp_lock.h>
 #include <linux/sched.h>
@@ -211,6 +212,7 @@ int kjournald(void *arg)
 	spin_unlock_irq(&current->sigmask_lock);
 
 	sprintf(current->comm, "kjournald");
+	current->flags |= PF_REFRIGERATE;
 
 	/* Set up an interval timer which can be used to trigger a
            commit wakeup after the commit interval expires */
@@ -243,12 +245,25 @@ int kjournald(void *arg)
 			}
 
 			journal_commit_transaction(journal);
+			if (current->flags & PF_FREEZE) {
+				jbd_debug(1, "Now suspending kjournald\n");
+				refrigerator(PF_IOTHREAD);
+				jbd_debug(1, "Resuming kjournald\n");						
+			}
 			continue;
 		}
 
 		wake_up(&journal->j_wait_done_commit);
 		interruptible_sleep_on(&journal->j_wait_commit);
 
+		/* kjournald gets refrigerated before other kernel threads. freeze_processes 
+		 * will wait until it enters the fridge before freezing other threads */
+		if (current->flags & PF_FREEZE) {
+			jbd_debug(1, "Now suspending kjournald\n");
+			refrigerator(PF_IOTHREAD);
+			jbd_debug(1, "Resuming kjournald\n");						
+		}
+
 		jbd_debug(1, "kjournald wakes\n");
 
 		/* Were we woken up by a commit wakeup event? */
@@ -599,6 +614,8 @@ void log_wait_commit (journal_t *journal
 		sleep_on(&journal->j_wait_done_commit);
 	}
 	unlock_kernel();
+	if (current->flags & PF_FREEZE)
+		refrigerator(PF_IOTHREAD);
 }
 
 /*
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/fs/lockd/svc.c m1/fs/lockd/svc.c
--- m2/fs/lockd/svc.c	2003-06-13 16:51:37.000000000 +0200
+++ m1/fs/lockd/svc.c	2003-07-31 17:27:37.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/slab.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 
 #include <linux/sunrpc/types.h>
 #include <linux/sunrpc/stats.h>
@@ -95,6 +96,7 @@ lockd(struct svc_rqst *rqstp)
 	daemonize();
 	reparent_to_init();
 	sprintf(current->comm, "lockd");
+	current->flags |= PF_REFRIGERATE;
 
 	/* Process request with signals blocked.  */
 	spin_lock_irq(&current->sigmask_lock);
@@ -121,7 +123,11 @@ lockd(struct svc_rqst *rqstp)
 	while ((nlmsvc_users || !signalled()) && nlmsvc_pid == current->pid)
 	{
 		long timeout = MAX_SCHEDULE_TIMEOUT;
-		if (signalled()) {
+		if (current->flags & PF_FREEZE) { 
+			dprintk("Now suspending lockd\n");
+			refrigerator(PF_IOTHREAD);
+			dprintk("Now resuming lockd\n");
+		} else if (signalled()) {
 			spin_lock_irq(&current->sigmask_lock);
 			flush_signals(current);
 			spin_unlock_irq(&current->sigmask_lock);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/fs/reiserfs/journal.c m1/fs/reiserfs/journal.c
--- m2/fs/reiserfs/journal.c	2003-07-30 18:13:40.000000000 +0200
+++ m1/fs/reiserfs/journal.c	2003-07-31 17:27:37.000000000 +0200
@@ -58,6 +58,7 @@
 #include <linux/stat.h>
 #include <linux/string.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 
 /* the number of mounted filesystems.  This is used to decide when to
 ** start and kill the commit thread
@@ -1894,6 +1895,7 @@ static int reiserfs_journal_commit_threa
   spin_unlock_irq(&current->sigmask_lock);
 
   sprintf(current->comm, "kreiserfsd") ;
+  current->flags |= PF_REFRIGERATE;
   lock_kernel() ;
   while(1) {
 
@@ -1907,6 +1909,8 @@ static int reiserfs_journal_commit_threa
       break ;
     }
     wake_up(&reiserfs_commit_thread_done) ;
+    if (current->flags & PF_FREEZE)
+      refrigerator(PF_IOTHREAD);
     interruptible_sleep_on_timeout(&reiserfs_commit_thread_wait, 5 * HZ) ;
   }
   unlock_kernel() ;
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/asm-generic/bitops.h m1/include/asm-generic/bitops.h
--- m2/include/asm-generic/bitops.h	2000-11-28 02:47:38.000000000 +0100
+++ m1/include/asm-generic/bitops.h	2003-07-31 17:27:37.000000000 +0200
@@ -51,6 +51,12 @@ extern __inline__ int test_bit(int nr, l
 	return ((mask & *addr) != 0);
 }
 
+/*
+ * fls: find last bit set.
+ */
+
+#define fls(x) generic_fls(x)
+
 #ifdef __KERNEL__
 
 /*
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/asm-i386/bitops.h m1/include/asm-i386/bitops.h
--- m2/include/asm-i386/bitops.h	2003-07-30 18:13:41.000000000 +0200
+++ m1/include/asm-i386/bitops.h	2003-07-31 17:27:37.000000000 +0200
@@ -330,6 +330,12 @@ static __inline__ unsigned long ffz(unsi
 	return word;
 }
 
+/*
+ * fls: find last bit set.
+ */
+
+#define fls(x) generic_fls(x)
+
 #ifdef __KERNEL__
 
 /**
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/asm-i386/cpufeature.h m1/include/asm-i386/cpufeature.h
--- m2/include/asm-i386/cpufeature.h	2003-07-30 18:13:41.000000000 +0200
+++ m1/include/asm-i386/cpufeature.h	2003-07-31 17:31:06.000000000 +0200
@@ -74,6 +74,7 @@
 #define cpu_has_vme		boot_cpu_has(X86_FEATURE_VME)
 #define cpu_has_de		boot_cpu_has(X86_FEATURE_DE)
 #define cpu_has_pse		boot_cpu_has(X86_FEATURE_PSE)
+#define cpu_has_pse36		boot_cpu_has(X86_FEATURE_PSE36)
 #define cpu_has_tsc		boot_cpu_has(X86_FEATURE_TSC)
 #define cpu_has_pae		boot_cpu_has(X86_FEATURE_PAE)
 #define cpu_has_pge		boot_cpu_has(X86_FEATURE_PGE)
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/asm-i386/mtrr.h m1/include/asm-i386/mtrr.h
--- m2/include/asm-i386/mtrr.h	2001-11-22 20:46:37.000000000 +0100
+++ m1/include/asm-i386/mtrr.h	2003-07-31 17:27:37.000000000 +0200
@@ -89,6 +89,10 @@ extern int mtrr_add_page (unsigned long 
 extern int mtrr_del (int reg, unsigned long base, unsigned long size);
 extern int mtrr_del_page (int reg, unsigned long base, unsigned long size);
 extern void mtrr_centaur_report_mcr(int mcr, u32 lo, u32 hi);
+#  ifdef CONFIG_SOFTWARE_SUSPEND
+extern int *mtrr_suspend(void);
+extern int mtrr_resume(int *ptr);
+#  endif
 #  else
 static __inline__ int mtrr_add (unsigned long base, unsigned long size,
 				unsigned int type, char increment)
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/asm-i386/suspend.h m1/include/asm-i386/suspend.h
--- m2/include/asm-i386/suspend.h	1970-01-01 01:00:00.000000000 +0100
+++ m1/include/asm-i386/suspend.h	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,321 @@
+ /*
+  * Copyright 2001-2002 Pavel Machek <pavel@suse.cz>
+  * Based on code
+  * Copyright 2001 Patrick Mochel <mochel@osdl.org>
+  */
+#include <asm/desc.h>
+#include <asm/i387.h>
+#ifdef SUSPEND_C
+#include <asm/processor.h>
+#endif
+#ifdef	CONFIG_KDB
+#include <linux/kdb.h>
+#endif	/* CONFIG_KDB */
+
+/* image of the saved processor state */
+struct saved_context {
+	u32 eax, ebx, ecx, edx;
+	u32 esp, ebp, esi, edi;
+	u16 es, fs, gs, ss;
+	u32 cr0, cr2, cr3, cr4;
+	u16 gdt_pad;
+	u16 gdt_limit;
+	u32 gdt_base;
+	u16 idt_pad;
+	u16 idt_limit;
+	u32 idt_base;
+	u16 ldt;
+	u16 tss;
+	u32 tr;
+	u32 safety;
+	u32 return_address;
+	u32 eflags;
+} __attribute__((packed));
+
+struct saved_context saved_context;
+
+#define loaddebug(thread,register) \
+               __asm__("movl %0,%%db" #register  \
+                       : /* no output */ \
+                       :"r" ((thread)->debugreg[register]))
+
+ 
+/*
+ * save_processor_context
+ * 
+ * Save the state of the processor before we go to sleep.
+ *
+ * return_stack is the value of the stack pointer (%esp) as the caller sees it.
+ * A good way could not be found to obtain it from here (don't want to make _too_
+ * many assumptions about the layout of the stack this far down.) Also, the 
+ * handy little __builtin_frame_pointer(level) where level > 0, is blatantly 
+ * buggy - it returns the value of the stack at the proper location, not the 
+ * location, like it should (as of gcc 2.91.66)
+ * 
+ * Note that the context and timing of this function is pretty critical.
+ * With a minimal amount of things going on in the caller and in here, gcc
+ * does a good job of being just a dumb compiler.  Watch the assembly output
+ * if anything changes, though, and make sure everything is going in the right
+ * place. 
+ */
+static inline void save_processor_context (void)
+{
+	kernel_fpu_begin();
+
+	/*
+	 * descriptor tables
+	 */
+	asm volatile ("sgdt (%0)" : "=m" (saved_context.gdt_limit));
+	asm volatile ("sidt (%0)" : "=m" (saved_context.idt_limit));
+	asm volatile ("sldt (%0)" : "=m" (saved_context.ldt));
+	asm volatile ("str (%0)"  : "=m" (saved_context.tr));
+
+	/*
+	 * save the general registers.
+	 * note that gcc has constructs to specify output of certain registers,
+	 * but they're not used here, because it assumes that you want to modify
+	 * those registers, so it tries to be smart and save them beforehand.
+	 * It's really not necessary, and kinda fishy (check the assembly output),
+	 * so it's avoided. 
+	 */
+	asm volatile ("movl %%esp, (%0)" : "=m" (saved_context.esp));
+	asm volatile ("movl %%eax, (%0)" : "=m" (saved_context.eax));
+	asm volatile ("movl %%ebx, (%0)" : "=m" (saved_context.ebx));
+	asm volatile ("movl %%ecx, (%0)" : "=m" (saved_context.ecx));
+	asm volatile ("movl %%edx, (%0)" : "=m" (saved_context.edx));
+	asm volatile ("movl %%ebp, (%0)" : "=m" (saved_context.ebp));
+	asm volatile ("movl %%esi, (%0)" : "=m" (saved_context.esi));
+	asm volatile ("movl %%edi, (%0)" : "=m" (saved_context.edi));
+
+	/*
+	 * segment registers
+	 */
+	asm volatile ("movw %%es, %0" : "=r" (saved_context.es));
+	asm volatile ("movw %%fs, %0" : "=r" (saved_context.fs));
+	asm volatile ("movw %%gs, %0" : "=r" (saved_context.gs));
+	asm volatile ("movw %%ss, %0" : "=r" (saved_context.ss));
+
+	/*
+	 * control registers 
+	 */
+	asm volatile ("movl %%cr0, %0" : "=r" (saved_context.cr0));
+	asm volatile ("movl %%cr2, %0" : "=r" (saved_context.cr2));
+	asm volatile ("movl %%cr3, %0" : "=r" (saved_context.cr3));
+	asm volatile ("movl %%cr4, %0" : "=r" (saved_context.cr4));
+
+	/*
+	 * eflags
+	 */
+	asm volatile ("pushfl ; popl (%0)" : "=m" (saved_context.eflags));
+}
+
+void fix_processor_context(void)
+{
+	int nr = smp_processor_id();
+	struct tss_struct * t = &init_tss[nr];
+
+	set_tss_desc(nr,t);	/* This just modifies memory; should not be neccessary. But... This is neccessary, because 386 hardware has concept of busy tsc or some similar stupidity. */
+        gdt_table[__TSS(nr)].b &= 0xfffffdff;
+
+	load_TR(nr);		/* This does ltr */
+
+	load_LDT(current->active_mm);	/* This does lldt */
+
+	/*
+	 * Now maybe reload the debug registers
+	 */
+	if (current->thread.debugreg[7]){
+                loaddebug(&current->thread, 0);
+                loaddebug(&current->thread, 1);
+                loaddebug(&current->thread, 2);
+                loaddebug(&current->thread, 3);
+                /* no 4 and 5 */
+                loaddebug(&current->thread, 6);
+                loaddebug(&current->thread, 7);
+	}
+
+}
+
+void
+do_fpu_end(void)
+{
+        /* restore FPU regs if necessary */
+	/* Do it out of line so that gcc does not move cr0 load to some stupid place */
+        kernel_fpu_end();
+}
+
+/*
+ * restore_processor_context
+ * 
+ * Restore the processor context as it was before we went to sleep
+ * - descriptor tables
+ * - control registers
+ * - segment registers
+ * - flags
+ * 
+ * Note that it is critical that this function is declared inline.  
+ * It was separated out from restore_state to make that function
+ * a little clearer, but it needs to be inlined because we won't have a
+ * stack when we get here (so we can't push a return address).
+ */
+inline void restore_processor_context (void)
+{
+	/*
+	 * first restore %ds, so we can access our data properly
+	 */
+	asm volatile (".align 4");
+	asm volatile ("movw %0, %%ds" :: "r" ((u16)__KERNEL_DS));
+
+
+	/*
+	 * control registers
+	 */
+	asm volatile ("movl %0, %%cr4" :: "r" (saved_context.cr4));
+	asm volatile ("movl %0, %%cr3" :: "r" (saved_context.cr3));
+	asm volatile ("movl %0, %%cr2" :: "r" (saved_context.cr2));
+	asm volatile ("movl %0, %%cr0" :: "r" (saved_context.cr0));
+	
+	/*
+	 * segment registers
+	 */
+	asm volatile ("movw %0, %%es" :: "r" (saved_context.es));
+	asm volatile ("movw %0, %%fs" :: "r" (saved_context.fs));
+	asm volatile ("movw %0, %%gs" :: "r" (saved_context.gs));
+	asm volatile ("movw %0, %%ss" :: "r" (saved_context.ss));
+
+	/*
+	 * the other general registers
+	 *
+	 * note that even though gcc has constructs to specify memory 
+	 * input into certain registers, it will try to be too smart
+	 * and save them at the beginning of the function.  This is esp.
+	 * bad since we don't have a stack set up when we enter, and we 
+	 * want to preserve the values on exit. So, we set them manually.
+	 */
+	asm volatile ("movl %0, %%esp" :: "m" (saved_context.esp));
+	asm volatile ("movl %0, %%ebp" :: "m" (saved_context.ebp));
+	asm volatile ("movl %0, %%eax" :: "m" (saved_context.eax));
+	asm volatile ("movl %0, %%ebx" :: "m" (saved_context.ebx));
+	asm volatile ("movl %0, %%ecx" :: "m" (saved_context.ecx));
+	asm volatile ("movl %0, %%edx" :: "m" (saved_context.edx));
+	asm volatile ("movl %0, %%esi" :: "m" (saved_context.esi));
+	asm volatile ("movl %0, %%edi" :: "m" (saved_context.edi));
+
+	/*
+	 * now restore the descriptor tables to their proper values
+	 * ltr is done i fix_processor_context().
+	 */
+	asm volatile ("lgdt (%0)" :: "m" (saved_context.gdt_limit));
+	asm volatile ("lidt (%0)" :: "m" (saved_context.idt_limit));
+	asm volatile ("lldt (%0)" :: "m" (saved_context.ldt));
+
+	fix_processor_context();
+
+	/*
+	 * the flags
+	 */
+	asm volatile ("pushl %0 ; popfl" :: "m" (saved_context.eflags));
+
+	do_fpu_end();
+}
+
+#ifdef SUSPEND_C
+/* Local variables for do_magic */
+static int loop __nosavedata = 0;
+static int loop2 __nosavedata = 0;
+static int state1 __nosavedata = 0;
+static int state2 __nosavedata = 0;
+static int state3 __nosavedata = 0;
+static struct pbe * pbe __nosavedata;
+#ifdef CONFIG_SMP
+static unsigned long c_loops_per_jiffy_ref __nosavedata = 0;
+static unsigned long cpu_khz_ref __nosavedata = 0;
+#endif
+
+/*
+ * FIXME: This function should really be written in assembly. Actually
+ * requirement is that it does not touch stack, because %esp will be
+ * wrong during resume before restore_processor_context(). Check
+ * assembly if you modify this.
+ */
+static void do_suspend_lowlevel(int resume)
+{
+	if (!resume) {
+		do_magic_suspend_1();
+		save_processor_context();	/* We need to capture registers and memory at "same time" */
+		do_magic_suspend_2();		/* If everything goes okay, this function does not return */
+		return;
+	}
+
+	/* We want to run from swapper_pg_dir, since swapper_pg_dir is stored in constant
+	 * place in memory 
+	 */
+
+        __asm__( "movl %%ecx,%%cr3\n" ::"c"(__pa(swapper_pg_dir)));
+
+/*
+ * Final function for resuming: after copying the pages to their original
+ * position, it restores the register state.
+ *
+ * What about page tables? Writing data pages may toggle
+ * accessed/dirty bits in our page tables. That should be no problems
+ * with 4MB page tables. That's why we require have_pse.  
+ *
+ * This loops destroys stack from under itself, so it better should
+ * not use any stack space, itself. When this function is entered at
+ * resume time, we move stack to _old_ place.  This is means that this
+ * function must use no stack and no local variables in registers,
+ * until calling restore_processor_context();
+ *
+ * Critical section here: noone should touch saved memory after
+ * do_magic_resume_1; copying works, because nr_copy_pages,
+ * pagedir_nosave, loop and loop2 are nosavedata.
+ */
+
+	do_magic_resume_1();
+
+#ifdef CONFIG_PREEMPT
+	preempt_disable();
+#endif
+
+	state1 = swsusp_action;
+	state2 = swsusp_debug_state;
+	state3 = console_loglevel;
+	pbe = pagedir_nosave.data;
+#ifdef CONFIG_SMP
+	c_loops_per_jiffy_ref = cpu_data->loops_per_jiffy;
+	cpu_khz_ref = cpu_khz;
+#endif
+	
+	for (loop=0; loop < pagedir_nosave.pageset_size; loop++) {
+		/* You may not call something (like copy_page) here: see above */
+		for (loop2=0; loop2 < (PAGE_SIZE / sizeof(unsigned long)); loop2++) {
+			*(((unsigned long *)(page_address(pbe->origaddress)))+loop2) =
+				*(((unsigned long *)(page_address(pbe->address)))+loop2);
+			__flush_tlb();
+		}
+		if ((loop + 1)%PBES_PER_PAGE) {
+			pbe++;
+		} else
+			pbe = ((struct pbelink *) ((unsigned long) pbe & PAGE_MASK))->next;
+	}
+	restore_processor_context();
+
+/* Ahah, we now run with our old stack, and with registers copied from
+   suspend time */
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	check_pagedir_checksums(&pagedir1, 1);
+#endif
+
+#ifdef CONFIG_SMP
+	cpu_data->loops_per_jiffy = c_loops_per_jiffy_ref;
+	loops_per_jiffy = c_loops_per_jiffy_ref;
+	cpu_khz = cpu_khz_ref;
+#endif
+	swsusp_action = state1;
+	swsusp_debug_state = state2;
+	console_loglevel = state3;
+
+	do_magic_resume_2();
+}
+#endif 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/bitops.h m1/include/linux/bitops.h
--- m2/include/linux/bitops.h	2001-11-22 20:46:18.000000000 +0100
+++ m1/include/linux/bitops.h	2003-07-31 17:27:37.000000000 +0200
@@ -1,6 +1,6 @@
 #ifndef _LINUX_BITOPS_H
 #define _LINUX_BITOPS_H
-
+#include <asm/bitops.h>
 
 /*
  * ffs: find first bit set. This is defined the same way as
@@ -38,6 +38,47 @@ static inline int generic_ffs(int x)
 }
 
 /*
+ * fls: find last bit set.
+ */
+
+extern __inline__ int generic_fls(int x)
+{
+	int r = 32;
+
+	if (!x)
+		return 0;
+	if (!(x & 0xffff0000)) {
+		x <<= 16;
+		r -= 16;
+	}
+	if (!(x & 0xff000000)) {
+		x <<= 8;
+		r -= 8;
+	}
+	if (!(x & 0xf0000000)) {
+		x <<= 4;
+		r -= 4;
+	}
+	if (!(x & 0xc0000000)) {
+		x <<= 2;
+		r -= 2;
+	}
+	if (!(x & 0x80000000)) {
+		x <<= 1;
+		r -= 1;
+	}
+	return r;
+}
+
+extern __inline__ int get_bitmask_order(unsigned int count)
+{
+	int order;
+	
+	order = fls(count);
+	return order;	/* We could be slightly more clever with -1 here... */
+}
+
+/*
  * hweightN: returns the hamming weight (i.e. the number
  * of bits set) of a N-bit word
  */
@@ -66,7 +107,5 @@ static inline unsigned int generic_hweig
         return (res & 0x0F) + ((res >> 4) & 0x0F);
 }
 
-#include <asm/bitops.h>
-
 
 #endif
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/init.h m1/include/linux/init.h
--- m2/include/linux/init.h	2001-12-21 18:42:03.000000000 +0100
+++ m1/include/linux/init.h	2003-07-31 17:27:37.000000000 +0200
@@ -111,6 +111,9 @@ extern struct kernel_param __setup_start
  */
 #define module_exit(x)	__exitcall(x);
 
+/* Data marked not to be saved by software_suspend() */
+#define __nosavedata __attribute__ ((__section__ (".data.nosave")))
+
 #else	/* MODULE */
 
 #define __init
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/mm.h m1/include/linux/mm.h
--- m2/include/linux/mm.h	2003-07-30 18:13:43.000000000 +0200
+++ m1/include/linux/mm.h	2003-07-31 17:27:37.000000000 +0200
@@ -300,6 +300,7 @@ typedef struct page {
 #define PG_reserved		14
 #define PG_launder		15	/* written out by VM pressure.. */
 #define PG_fs_1			16	/* Filesystem specific */
+#define PG_nosave		17      /* swsusp - used to be 16!! */
 
 #ifndef arch_set_page_uptodate
 #define arch_set_page_uptodate(page)
@@ -325,6 +326,9 @@ typedef struct page {
 #define PageLaunder(page)	test_bit(PG_launder, &(page)->flags)
 #define SetPageLaunder(page)	set_bit(PG_launder, &(page)->flags)
 #define ClearPageLaunder(page)	clear_bit(PG_launder, &(page)->flags)
+#define PageNosave(page)	test_bit(PG_nosave, &(page)->flags)
+#define SetPageNosave(page)	set_bit(PG_nosave, &(page)->flags)
+#define ClearPageNosave(page)	clear_bit(PG_nosave, &(page)->flags)
 
 /*
  * The zone field is never updated after free_area_init_core()
@@ -417,6 +421,12 @@ extern void FASTCALL(set_page_dirty(stru
 #define SetPageReserved(page)		set_bit(PG_reserved, &(page)->flags)
 #define ClearPageReserved(page)		clear_bit(PG_reserved, &(page)->flags)
 
+#define PageNosave(page)	test_bit(PG_nosave, &(page)->flags)
+#define PageSetNosave(page)	set_bit(PG_nosave, &(page)->flags)
+#define PageTestandSetNosave(page)	test_and_set_bit(PG_nosave, &(page)->flags)
+#define PageClearNosave(page)		clear_bit(PG_nosave, &(page)->flags)
+#define PageTestandClearNosave(page)	test_and_clear_bit(PG_nosave, &(page)->flags)
+
 /*
  * Error return values for the *_nopage functions
  */
@@ -610,6 +620,8 @@ extern struct page *filemap_nopage(struc
 #define __GFP_IO	0x40	/* Can start low memory physical IO? */
 #define __GFP_HIGHIO	0x80	/* Can start high mem physical IO? */
 #define __GFP_FS	0x100	/* Can call down to low-level FS? */
+#define __GFP_FAST	0x200	/* fast return in reschedule if out
+				   of page (used in swsusp) */
 
 #define GFP_NOHIGHIO	(__GFP_HIGH | __GFP_WAIT | __GFP_IO)
 #define GFP_NOIO	(__GFP_HIGH | __GFP_WAIT)
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/raid/md.h m1/include/linux/raid/md.h
--- m2/include/linux/raid/md.h	2003-06-13 16:51:39.000000000 +0200
+++ m1/include/linux/raid/md.h	2003-07-31 17:27:37.000000000 +0200
@@ -86,6 +86,8 @@ extern int md_run_setup(void);
 
 extern void md_print_devices (void);
 
+extern void md_autostart_arrays(void);
+
 #define MD_BUG(x...) { printk("md: bug in file %s, line %d\n", __FILE__, __LINE__); md_print_devices(); }
 
 #endif 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/reboot.h m1/include/linux/reboot.h
--- m2/include/linux/reboot.h	2001-02-09 23:46:13.000000000 +0100
+++ m1/include/linux/reboot.h	2003-07-31 17:27:37.000000000 +0200
@@ -20,6 +20,7 @@
  * CAD_OFF     Ctrl-Alt-Del sequence sends SIGINT to init task.
  * POWER_OFF   Stop OS and remove all power from system, if possible.
  * RESTART2    Restart system using given command string.
+ * SW_SUSPEND  Suspend system using Software Suspend if compiled in
  */
 
 #define	LINUX_REBOOT_CMD_RESTART	0x01234567
@@ -28,6 +29,7 @@
 #define	LINUX_REBOOT_CMD_CAD_OFF	0x00000000
 #define	LINUX_REBOOT_CMD_POWER_OFF	0x4321FEDC
 #define	LINUX_REBOOT_CMD_RESTART2	0xA1B2C3D4
+#define	LINUX_REBOOT_CMD_SW_SUSPEND	0xD000FCE2
 
 
 #ifdef __KERNEL__
@@ -46,6 +48,13 @@ extern void machine_restart(char *cmd);
 extern void machine_halt(void);
 extern void machine_power_off(void);
 
+/*
+ * Architecture-independent suspend facility
+ */
+
+extern void software_suspend_pending(void);
+extern unsigned char software_suspend_enabled;
+
 #endif
 
 #endif /* _LINUX_REBOOT_H */
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/sched.h m1/include/linux/sched.h
--- m2/include/linux/sched.h	2003-06-13 16:51:39.000000000 +0200
+++ m1/include/linux/sched.h	2003-07-31 17:27:37.000000000 +0200
@@ -432,6 +432,10 @@ struct task_struct {
 #define PF_MEMDIE	0x00001000	/* Killed for out-of-memory */
 #define PF_FREE_PAGES	0x00002000	/* per process page freeing */
 #define PF_NOIO		0x00004000	/* avoid generating further I/O */
+#define PF_FROZEN	0x00008000	/* frozen for system suspend */
+#define PF_FREEZE	0x00010000	/* trying to freeze this task for suspend */
+#define PF_IOTHREAD	0x00020000	/* this thread is needed for doing I/O to swap */
+#define PF_REFRIGERATE  0x00040000	/* this task should be frozen when a suspend occurs */
 
 #define PF_USEDFPU	0x00100000	/* task used FPU this quantum (SMP) */
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/suspend-debug.h m1/include/linux/suspend-debug.h
--- m2/include/linux/suspend-debug.h	1970-01-01 01:00:00.000000000 +0100
+++ m1/include/linux/suspend-debug.h	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,107 @@
+
+#ifndef _LINUX_SWSUSP_DEBUG_H
+#define _LINUX_SWSUSP_DEBUG_H
+
+#include <linux/suspend.h>
+
+#define name_suspend "Suspend Machine:  "
+#define name_resume  "Resume Machine:   "
+#define swsusp_version "1.0-2_4_21"
+#define name_swsusp  "Swsusp " swsusp_version ": "
+#define console_suspend " S U S P E N D   T O   D I S K " /* Same length to ensure one overwrites the other */
+#define console_resume  "R E S U M E   F R O M   D I S K"
+
+#define TEST_RESULT_STATE(bit) (test_bit(bit, &swsusp_result))
+#define SET_RESULT_STATE(bit) (test_and_set_bit(bit, &swsusp_result))
+#define CLEAR_RESULT_STATE(bit) (test_and_clear_bit(bit, &swsusp_result))
+
+#define TEST_ACTION_STATE(bit) (test_bit(bit, &swsusp_action))
+#define SET_ACTION_STATE(bit) (test_and_set_bit(bit, &swsusp_action))
+#define CLEAR_ACTION_STATE(bit) (test_and_clear_bit(bit, &swsusp_action))
+
+#define TEST_DEBUG_STATE(bit) (test_bit(bit, &swsusp_debug_state))
+#define SET_DEBUG_STATE(bit) (test_and_set_bit(bit, &swsusp_debug_state))
+#define CLEAR_DEBUG_STATE(bit) (test_and_clear_bit(bit, &swsusp_debug_state))
+
+extern int suspend_console;
+
+/* first status register - this is swsusp's return code. */
+#define SUSPEND_ABORTED			0
+#define SUSPEND_ABORT_REQUESTED		1
+#define SUSPEND_NOSWAP_AVAILABLE	2
+#define SUSPEND_INSUFFICIENT_SWAP	3
+#define SUSPEND_FREEZING_FAILED		4
+
+/* second status register */
+#define SUSPEND_REBOOT		0
+#define SUSPEND_NO_OUTPUT	1
+#define SUSPEND_PAUSE		2
+#define SUSPEND_SLOW		3
+#define SUSPEND_BEEP		4
+#define SUSPEND_NO_ASYNC_READS	5
+#define SUSPEND_NO_ASYNC_WRITES	6
+#define SUSPEND_NOPAGESET2	7
+#define SUSPEND_LOGALL		8
+/* Set to disable compression when compiled in */
+#define SUSPEND_NO_COMPRESSION	9
+//#define SUSPEND_ENABLE_KDB	10
+#define SUSPEND_CAN_CANCEL	11
+
+/* debug sections  - if debugging compiled in */
+#define SUSPEND_ANY_SECTION	0
+#define SUSPEND_FREEZER		1
+#define SUSPEND_EAT_MEMORY 	2
+#define SUSPEND_PAGESETS	3
+#define SUSPEND_MARK_PAGESET2 	4
+#define SUSPEND_COPY_PAGESET	5
+#define SUSPEND_WRITE_PAGESETS 	6
+#define SUSPEND_READ_PAGESETS 	7
+#define SUSPEND_CHECKSUMS	8
+#define SUSPEND_SWAP		9
+#define SUSPEND_MEMORY		10
+/* debugging levels - if debugging compiled in.
+ * These are straight integer values, not bit flags.
+ * (Stored as LEVEL << 16 + section_flags).
+ */
+#define SUSPEND_ERROR		3
+#define SUSPEND_LOW	 	4
+#define SUSPEND_MEDIUM	 	5
+#define SUSPEND_HIGH	  	6
+#define SUSPEND_VERBOSE		7
+
+#define NO_OUTPUT_OR_PAUSING ((fg_console != suspend_console) || \
+		(TEST_ACTION_STATE(SUSPEND_NO_OUTPUT)))
+
+void printnolog(int mask, int level, int restartline, const char *fmt, ...);
+void printlog(int mask, int level, const char *fmt, ...);
+#define CHECKMASK(mask) (((!mask) || TEST_DEBUG_STATE(mask)) && (!NO_OUTPUT_OR_PAUSING))
+/* 
+ *   #defs that are dependant on CONFIG_SOFTWARE_SUSPEND_DEBUG
+ *
+ */
+#if defined(CONFIG_SOFTWARE_SUSPEND_DEBUG)
+
+#define MDELAY(a)	if (TEST_ACTION_STATE(SUSPEND_SLOW)) { mdelay(a); } else { do { } while (0); }
+#define beepOK \
+	if (TEST_ACTION_STATE(SUSPEND_BEEP)) { \
+		currentbeep += 200; \
+		kd_mksound(currentbeep,HZ/8); \
+		mdelay(150); \
+	} else { \
+		do { } while (0); \
+	}
+#define beepERR \
+	if (TEST_ACTION_STATE(SUSPEND_BEEP)) { \
+		kd_mksound(300,HZ/4); \
+		mdelay(300); \
+	} else { \
+		do { } while (0); \
+	} 
+
+#else // #ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+#define MDELAY(a) do { } while (0)
+#define beepOK do { } while (0)
+#define beepERR do { } while (0)
+#endif // #ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+
+#endif
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/suspend.h m1/include/linux/suspend.h
--- m2/include/linux/suspend.h	1970-01-01 01:00:00.000000000 +0100
+++ m1/include/linux/suspend.h	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,137 @@
+#ifndef _LINUX_SWSUSP_H
+#define _LINUX_SWSUSP_H
+
+#if defined(SUSPEND_C) || defined(ACPI_C)
+#include <asm/suspend.h>
+#endif
+#include <linux/swap.h>
+#include <linux/notifier.h>
+#include <linux/config.h>
+#include <linux/kdev_t.h>
+
+#define NORESUME	 1
+#define RESUME_SPECIFIED 2
+#define COMMANDLINE_ERROR 4
+
+#ifdef CONFIG_SOFTWARE_SUSPEND
+extern unsigned long swsusp_action;
+extern unsigned long swsusp_result;
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+extern unsigned long swsusp_debug_state;
+#if 0
+#define PRINTFREEMEM(desn) printlog(SUSPEND_MEMORY, SUSPEND_MEDIUM, \
+		"Free memory %s: %d.\n", desn, nr_free_pages())
+#else
+#define PRINTFREEMEM(desn) printk("Free memory %s: %d.\n", desn, nr_free_pages())
+#endif
+#else /* CONFIG_SOFTWARE_SUSPEND_DEBUG */
+#define PRINTFREEMEM(desn) do { } while(0)
+#endif /* CONFIG_SOFTWARE_SUSPEND_DEBUG */
+
+/* page backup entry */
+typedef struct pbe {
+	struct page * origaddress;	/* 4: original address of pageset entry */
+	struct page * address;		/* 4: address of copy of pageset entry (pageset1 only) */
+	swp_entry_t swap_address;	/* 4: */
+	unsigned long checksum;
+	unsigned long checksum_error;
+	kdev_t swap_bdev;		/* Physical location of swap entry */
+	unsigned long block;
+	swp_entry_t dummy;		/* we need at least one sizeof(long) scratch space at 
+					 * end of page (see link, diskpage) and
+					 * sizeof(struct pbe) must be multiple of 4*sizeof(long)
+					 */
+} suspend_pbe_t;
+
+typedef struct pagedir {
+	int pageset_size;
+	int pagedir_size;
+	int pagedir_capacity;
+	int alloc_from;
+	struct pbe *data;
+	struct pbe *first_allocated;	/* Shortcut to first pbe in pageset 2 where extra pages
+					   were allocated */
+} suspend_pagedir_t;
+
+struct pbelink {
+	char dummy[sizeof(struct pbe) - sizeof(struct pbe *)];
+	struct pbe * next;
+};
+
+#define SWAP_FILENAME_MAXLENGTH	32
+
+struct suspend_header {
+	__u32 version_code;
+	unsigned long num_physpages;
+	char machine[65];
+	char version[65];
+	int num_cpus;
+	int page_size;
+	unsigned long base_mem_free;
+	unsigned long swapforimage;
+	unsigned int expected_size1;
+	unsigned int expected_size2;
+	struct pagedir pagedir;
+	int param0;
+	int param1;
+	int param2;
+	int param3;
+	int param4;
+	int progress0;
+	int progress1;
+	int progress2;
+	int progress3;
+	int progress4;
+	kdev_t kdevs[MAX_SWAPFILES];
+	struct swap_location {
+		char filename[SWAP_FILENAME_MAXLENGTH];
+	} swap_location[MAX_SWAPFILES];
+};
+
+#define PBES_PER_PAGE	(PAGE_SIZE/sizeof(struct pbe))
+#define SUSPEND_PD_PAGES(x)	(((x)+PBES_PER_PAGE-1)/PBES_PER_PAGE)
+#define PAGEDIR_CAPACITY(x)     (((x)*PBES_PER_PAGE))
+//#define PAGEDIR_ENTRY(pagedir, i) ((pagedir)->data[((i)/PBES_PER_PAGE)] + ((i)%PBES_PER_PAGE))
+   
+extern struct tq_struct suspend_tq;
+
+/* mm/vmscan.c */
+extern int shrink_mem(void);
+
+/* kernel/suspend.c */
+extern void software_suspend_pending(void);
+extern void software_resume(void);
+
+extern int register_suspend_notifier(struct notifier_block *);
+extern int unregister_suspend_notifier(struct notifier_block *);
+extern int register_resume_notifier(struct notifier_block *);
+extern int unregister_resume_notifier(struct notifier_block * nb);
+extern void refrigerator(unsigned long);
+extern struct buffer_head * suspend_swap_bh;
+
+extern struct page * last_suspend_cache_page;
+extern unsigned int suspend_task;
+
+#ifdef CONFIG_MTRR
+#define SOFTWARE_SUSPEND_MTRR 1
+#else
+#undef SOFTWARE_SUSPEND_MTRR
+#endif
+
+#define TASK_NOT_SUSPENDED(p)	((!suspend_task) || \
+				 (p->flags & PF_IOTHREAD) || \
+				 (!p->pid) || \
+				 (suspend_task == p->pid) || \
+				 ((p->flags & PF_REFRIGERATE) && (!(p->flags & PF_FROZEN))))
+#else
+#define software_suspend_pending()	do { } while(0)
+#define software_resume()		do { } while(0)
+#define register_suspend_notifier(a)	do { } while(0)
+#define unregister_suspend_notifier(a)	do { } while(0)
+#define refrigerator(a)			do { BUG(); } while(0)
+#define TASK_NOT_SUSPENDED(p) (1)
+#define suspend_task (0)
+#endif
+
+#endif /* _LINUX_SWSUSP_H */
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/swap.h m1/include/linux/swap.h
--- m2/include/linux/swap.h	2003-07-30 18:13:43.000000000 +0200
+++ m1/include/linux/swap.h	2003-07-31 17:27:37.000000000 +0200
@@ -118,7 +118,9 @@ extern int FASTCALL(try_to_free_pages(un
 
 /* linux/mm/page_io.c */
 extern void rw_swap_page(int, struct page *);
-extern void rw_swap_page_nolock(int, swp_entry_t, char *);
+extern void __rw_swap_page_nolock(int, swp_entry_t, char *, int);
+#define rw_swap_page_nolock(rw, entry, buf) __rw_swap_page_nolock(rw, entry, buf, 1)
+#define rw_swap_page_nolock_norfree(rw, entry, buf) __rw_swap_page_nolock(rw, entry, buf, 0)
 
 /* linux/mm/page_alloc.c */
 
@@ -143,7 +145,7 @@ extern unsigned int nr_swapfiles;
 extern struct swap_info_struct swap_info[];
 extern int is_swap_partition(kdev_t);
 extern void si_swapinfo(struct sysinfo *);
-extern swp_entry_t get_swap_page(void);
+extern swp_entry_t get_swap_page(int must_be_partition);
 extern void get_swaphandle_info(swp_entry_t, unsigned long *, kdev_t *, 
 					struct inode **);
 extern int swap_duplicate(swp_entry_t);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/include/linux/sysctl.h m1/include/linux/sysctl.h
--- m2/include/linux/sysctl.h	2003-07-30 18:13:43.000000000 +0200
+++ m1/include/linux/sysctl.h	2003-07-31 17:27:37.000000000 +0200
@@ -124,6 +124,7 @@ enum
 	KERN_CORE_USES_PID=52,		/* int: use core or core.%pid */
 	KERN_TAINTED=53,	/* int: various kernel tainted flags */
 	KERN_CADPID=54,		/* int: PID of the process to notify on CAD */
+	KERN_SWSUSP=55,		/* struct: interface to activate software suspension */
  	KERN_CORE_PATTERN=56,	/* string: pattern for core-files */
 	KERN_PPC_L3CR=57,       /* l3cr register on PPC */
 	KERN_EXCEPTION_TRACE=58, /* boolean: exception trace */
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/init/main.c m1/init/main.c
--- m2/init/main.c	2003-07-30 18:13:43.000000000 +0200
+++ m1/init/main.c	2003-07-31 17:27:37.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/iobuf.h>
 #include <linux/bootmem.h>
 #include <linux/tty.h>
+#include <linux/suspend.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
@@ -535,6 +536,10 @@ static void __init do_basic_setup(void)
 	start_context_thread();
 	do_initcalls();
 
+	/* This has to be before mounting root, because even readonly mount of reiserfs would replay
+	   log corrupting stuff */
+	software_resume();
+
 #ifdef CONFIG_IRDA
 	irda_proto_init();
 	irda_device_init(); /* Must be done after protocol initialization */
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/context.c m1/kernel/context.c
--- m2/kernel/context.c	2001-10-11 20:17:22.000000000 +0200
+++ m1/kernel/context.c	2003-07-31 17:27:37.000000000 +0200
@@ -72,6 +72,7 @@ static int context_thread(void *startup)
 
 	daemonize();
 	strcpy(curtask->comm, "keventd");
+	current->flags |= PF_IOTHREAD;
 	keventd_running = 1;
 	keventd_task = curtask;
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/ksyms.c m1/kernel/ksyms.c
--- m2/kernel/ksyms.c	2003-07-30 18:13:43.000000000 +0200
+++ m1/kernel/ksyms.c	2003-07-31 17:27:37.000000000 +0200
@@ -51,6 +51,9 @@
 #include <linux/crc32.h>
 #include <asm/checksum.h>
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+#include <linux/suspend.h>
+#endif
 #if defined(CONFIG_PROC_FS)
 #include <linux/proc_fs.h>
 #endif
@@ -594,6 +597,11 @@ EXPORT_SYMBOL(tasklist_lock);
 EXPORT_SYMBOL(pidhash);
 EXPORT_SYMBOL(unshare_files);
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+EXPORT_SYMBOL(register_resume_notifier);
+EXPORT_SYMBOL(unregister_resume_notifier);
+#endif
+
 /* debug */
 EXPORT_SYMBOL(dump_stack);
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/Makefile m1/kernel/Makefile
--- m2/kernel/Makefile	2001-09-17 06:22:40.000000000 +0200
+++ m1/kernel/Makefile	2003-07-31 17:27:37.000000000 +0200
@@ -16,7 +16,10 @@ obj-y     = sched.o dma.o fork.o exec_do
 	    sysctl.o acct.o capability.o ptrace.o timer.o user.o \
 	    signal.o sys.o kmod.o context.o
 
+subdir-$(CONFIG_SOFTWARE_SUSPEND) += suspend
+
 obj-$(CONFIG_UID16) += uid16.o
+obj-$(CONFIG_SOFTWARE_SUSPEND) += suspend/swsusp.o
 obj-$(CONFIG_MODULES) += ksyms.o
 obj-$(CONFIG_PM) += pm.o
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/panic.c m1/kernel/panic.c
--- m2/kernel/panic.c	2002-11-29 00:53:15.000000000 +0100
+++ m1/kernel/panic.c	2003-07-31 17:27:37.000000000 +0200
@@ -114,9 +114,10 @@ const char *print_tainted()
 {
 	static char buf[20];
 	if (tainted) {
-		snprintf(buf, sizeof(buf), "Tainted: %c%c",
+		snprintf(buf, sizeof(buf), "Tainted: %c%c%c",
 			tainted & 1 ? 'P' : 'G',
-			tainted & 2 ? 'F' : ' ');
+			tainted & 2 ? 'F' : ' ',
+			tainted & 4 ? 'Z' : ' ');
 	}
 	else
 		snprintf(buf, sizeof(buf), "Not tainted");
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/printk.c m1/kernel/printk.c
--- m2/kernel/printk.c	2003-07-30 18:13:43.000000000 +0200
+++ m1/kernel/printk.c	2003-07-31 17:27:37.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/config.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 
@@ -78,7 +79,7 @@ struct console *console_drivers;
  */
 static spinlock_t logbuf_lock = SPIN_LOCK_UNLOCKED;
 
-static char log_buf[LOG_BUF_LEN];
+char log_buf[LOG_BUF_LEN]; /* Not static so swsusp can print its location */
 #define LOG_BUF(idx) (log_buf[(idx) & LOG_BUF_MASK])
 
 /*
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/sched.c m1/kernel/sched.c
--- m2/kernel/sched.c	2003-07-30 18:13:43.000000000 +0200
+++ m1/kernel/sched.c	2003-07-31 17:27:37.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/completion.h>
 #include <linux/prefetch.h>
 #include <linux/compiler.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -116,12 +117,12 @@ extern struct task_struct *child_reaper;
 
 #define idle_task(cpu) (init_tasks[cpu_number_map(cpu)])
 #define can_schedule(p,cpu) \
-	((p)->cpus_runnable & (p)->cpus_allowed & (1UL << cpu))
+	((TASK_NOT_SUSPENDED(p)) && ((p)->cpus_runnable & (p)->cpus_allowed & (1UL << cpu)))
 
 #else
 
 #define idle_task(cpu) (&init_task)
-#define can_schedule(p,cpu) (1)
+#define can_schedule(p,cpu) (TASK_NOT_SUSPENDED(p))
 
 #endif
 
@@ -634,6 +635,9 @@ repeat_schedule:
 	task_set_cpu(next, this_cpu);
 	spin_unlock_irq(&runqueue_lock);
 
+	if (unlikely(!TASK_NOT_SUSPENDED(next)))
+		printk(KERN_EMERG "Scheduling suspended task %s!\n", next->comm);
+
 	if (unlikely(prev == next)) {
 		/* We won't go through the normal tail, so do this by hand */
 		prev->policy &= ~SCHED_YIELD;
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/signal.c m1/kernel/signal.c
--- m2/kernel/signal.c	2003-06-13 16:51:39.000000000 +0200
+++ m1/kernel/signal.c	2003-07-31 17:27:37.000000000 +0200
@@ -492,7 +492,7 @@ static int send_signal(int sig, struct s
  * No need to set need_resched since signal event passing
  * goes through ->blocked
  */
-static inline void signal_wake_up(struct task_struct *t)
+inline void signal_wake_up(struct task_struct *t)
 {
 	t->sigpending = 1;
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/softirq.c m1/kernel/softirq.c
--- m2/kernel/softirq.c	2002-11-29 00:53:15.000000000 +0100
+++ m1/kernel/softirq.c	2003-07-31 17:27:37.000000000 +0200
@@ -16,6 +16,9 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/tqueue.h>
+#ifdef CONFIG_SOFTWARE_SUSPEND
+#include <linux/suspend.h>
+#endif
 
 /*
    - No shared variables, all the data are CPU local.
@@ -365,6 +368,7 @@ static int ksoftirqd(void * __bind_cpu)
 
 	daemonize();
 	current->nice = 19;
+	current->flags |= PF_REFRIGERATE;
 	sigfillset(&current->blocked);
 
 	/* Migrate to the right CPU */
@@ -392,6 +396,11 @@ static int ksoftirqd(void * __bind_cpu)
 		}
 
 		__set_current_state(TASK_INTERRUPTIBLE);
+
+#ifdef CONFIG_SOFTWARE_SUSPEND
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_IOTHREAD);
+#endif
 	}
 }
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/common.h m1/kernel/suspend/common.h
--- m2/kernel/suspend/common.h	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/common.h	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,229 @@
+/*
+ * Software Suspend.
+ *
+ * Module level definitions.
+ *
+ */
+
+#ifndef SWSUSP_COMMON_H
+#define SWSUSP_COMMON_H
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/locks.h>
+#include <linux/swapctl.h>
+#if defined(CONFIG_FBCON_SPLASHSCREEN)
+#include <linux/fb.h>
+#include <video/fbcon.h>
+#else
+#include <linux/console_struct.h>
+#endif
+#include <linux/suspend.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/file.h>
+#include <linux/utsname.h>
+#include <linux/init.h>
+#include <linux/compile.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+#include <linux/vt_kern.h>
+#include <linux/bitops.h>
+#include <linux/interrupt.h>
+#include <linux/kbd_kern.h>
+#include <linux/keyboard.h>
+#include <linux/spinlock.h>
+#include <linux/genhd.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/blk.h>
+#include <linux/swap.h>
+#include <linux/pm.h>
+#include <linux/raid/md.h>
+#include <linux/selection.h>
+#include <linux/console.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/suspend-debug.h>
+#include <linux/zlib.h>
+
+#include <asm/uaccess.h>
+#include <asm/mmu_context.h>
+#include <asm/pgtable.h>
+#include <asm/io.h>
+#include <asm/mtrr.h>
+
+#define MAX(a,b)	((signed long)(a)>(signed long)(b)?(a):(b))
+#define MIN(a,b)	((signed long)(a)<(signed long)(b)?(a):(b))
+
+#ifndef SWSUSP_MAIN_C
+extern unsigned char software_suspend_enabled;
+extern unsigned int suspend_task;
+extern unsigned long swsusp_debug_state;
+extern struct sysinfo swapinfo;
+extern spinlock_t suspend_pagedir_lock __nosavedata;
+extern unsigned long pagedirflags __nosavedata;
+
+extern int max_async_ios;
+extern int image_size_limit;
+
+extern int currentbeep;
+extern int orig_loglevel;
+extern int now_resuming;
+extern struct pagedir pagedir1, pagedir2;
+#endif
+
+struct swaplink {
+	char dummy[PAGE_SIZE - sizeof(swp_entry_t)];
+	swp_entry_t next;
+};
+
+union diskpage {
+	union swap_header swh;	/* swh.magic is the only member used */
+	struct swaplink link;
+	struct suspend_header sh;
+};
+
+union p_diskpage {
+	union diskpage *pointer;
+	char *ptr;
+        unsigned long address;
+};
+
+typedef struct pageset_sizes_result {
+	int size1; /* Can't be unsigned - breaks MAX function */
+	int size2;
+	int size2low;
+} pageset_sizes_t;
+
+/* */
+extern int C_A_D;
+
+/*
+ * Poll the swsusp state every second
+ */
+#define SWSUSP_CHECK_TIMEOUT	(HZ)
+#define SWSUSP_COMMIT_TIMEOUT	(HZ)
+
+#if defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+#define DEFAULT_SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
+#endif
+
+#define TIMEOUT	(6 * HZ)	/* Timeout for stopping processes */
+#define __ADDRESS(x)  ((unsigned long) phys_to_virt(x))
+#define ADDRESS(x) __ADDRESS((x) << PAGE_SHIFT)
+
+#define MB(x) ((x) >> (20 - PAGE_SHIFT))
+
+#define MARK_SWAP_SUSPEND 0
+#define MARK_SWAP_RECOVER 1
+#define MARK_SWAP_RESUME 2
+
+/* References to section boundaries */
+extern char _text, _etext, _edata, __bss_start, _end;
+extern char __nosave_begin, __nosave_end;
+
+extern int console_loglevel;
+extern inline void signal_wake_up(struct task_struct *t);
+asmlinkage long sys_sched_yield(void);
+asmlinkage void sys_sync(void);	/* it's really int */
+extern void ide_disk_unsuspend(int);
+extern void ide_disk_suspend(void);
+extern kdev_t name_to_kdev_t(char *line) __init;
+extern void vt_console_print(struct console *co, const char * b, unsigned count);
+extern void free_suspend_cache_page(struct page * page);
+extern inline pte_t *lookup_address(unsigned long address);
+extern int rw_swap_page_base(int rw, swp_entry_t entry, struct page *page);
+extern int try_to_free_pages_zone_swsusp(zone_t *classzone, unsigned int gfp_mask, int priority, int nr_pages);
+extern int try_to_free_pages_swsusp(unsigned int gfp_mask, int amount_needed);
+extern char log_buf[];
+
+#define swsusp_spin_lock_irq(lock) { \
+	printlog(SUSPEND_FREEZER, SUSPEND_VERBOSE, "Spinlock %p.\n", lock); \
+	spin_lock_irq(lock); \
+}
+
+#define swsusp_spin_lock_irqsave(lock, flags) { \
+	printlog(SUSPEND_FREEZER, SUSPEND_VERBOSE, "Spinlock IRQSave %p.\n", lock); \
+	spin_lock_irqsave(lock, flags); \
+}
+
+#define swsusp_spin_unlock_irq(lock) { \
+	printlog(SUSPEND_FREEZER, SUSPEND_VERBOSE, "Spinunlock %p.\n", lock); \
+	spin_unlock_irq(lock); \
+}
+
+#define swsusp_spin_unlock_irqrestore(lock, flags) { \
+	printlog(SUSPEND_FREEZER, SUSPEND_VERBOSE, "Spinunlock IRQRestore %p.\n", lock); \
+	spin_unlock_irqrestore(lock, flags); \
+}
+
+/* Variables to be preserved over suspend */
+extern char resume_file[256];	/* For resume= kernel option */
+/* Local variables that should not be affected by save */
+#define pageset1_size (pagedir1.pageset_size)
+#define pageset2_size (pagedir2.pageset_size)
+
+#define BITS_PER_PAGE (PAGE_SIZE * 8)
+#define PAGES_PER_BITMAP ((max_mapnr + BITS_PER_PAGE - 1) / BITS_PER_PAGE)
+#define BITMAP_ORDER (get_bitmask_order(PAGES_PER_BITMAP))
+
+/*
+ * XXX: We try to keep some more pages free so that I/O operations succeed
+ * without paging. Might this be more?
+ */
+#define MIN_FREE_RAM 1024
+
+void prepare_status(int printalways, int clearbar, const char *fmt, ...);
+void abort_suspend(const char *fmt, ...);
+
+/* Exported variables */
+
+int read_secondary_pagedir(int);
+int read_primary_suspend_image(char * specialfile, int noresume);
+void thaw_processes(void);
+
+extern int nr_unused_buffer_heads;
+
+/* ------ io.c ------ */
+int write_pageset(struct pagedir * pagedir, int whichtowrite);
+int read_pageset(struct pagedir * pagedir, int whichtoread, int overwrittenpagesonly);
+int write_pagedir_and_suspend_header(void);
+void mark_swapfiles(swp_entry_t prev, int mode);
+void sync_swap_partitions(void); 
+int noresume_fix_signature(union p_diskpage cur);
+void do_suspend_sync(void);
+void read_swapfiles(void);
+void finish_all_io(void);
+int bdev_read_page(kdev_t bdev, long pos, struct page * page);
+extern kdev_t resume_device;
+int bdev_read_swap(struct pbe * pbe, int asyncio);
+__inline__ int fill_suspend_header(struct suspend_header *sh);
+
+/* ------ ui.c ------ */
+void check_shift_keys(int pause, char * message);
+int update_status(unsigned long value, unsigned long maximum, const char *fmt, ...);
+#if defined(CONFIG_FBCON_SPLASHSCREEN)
+extern int fb_splash_set_progress(int consolenr, int value, int maximum, int reset);
+extern int fb_splash_progress[5]; /* Needed while progress bar posn/size set via proc interface */
+int splash_is_on(int consolenr);
+#define SPLASH_IS_ON(consolenr) (splash_is_on(consolenr))
+#else
+#define SPLASH_IS_ON(consolenr) (0)
+#define fb_splash_set_progress(a, b, c, d) do { } while (0)
+#endif
+int prepare_suspend_console(void);
+void restore_console(void);
+
+#define PBEPAGE_START(pbe) (((unsigned long) (pbe)) & PAGE_MASK)
+inline void set_next_pagedir_page(struct pbe * pbe, struct pbe * next);
+inline struct pbe * get_next_pagedir_page(struct pbe * pbe);
+inline struct pbe * get_next_pbe(struct pbe * pbe);
+#endif
+
+#define REAL_MAX_ASYNC (MIN(10 * (MAX_BUF_PER_PAGE + 2), (max_async_ios ? 100 : max_async_ios)))
+
+#define SWAP_NEEDED (pageset1_size + pageset2_size + pagedir1_size + 1)
+#define RAM_TO_SUSPEND (pagedir1_size + pagedir2_size + 1 + MAX((pageset1_size - pageset2_sizelow), 0) + MIN_FREE_RAM + REAL_MAX_ASYNC)
+#define RAM_TO_RESUME  ((pageset1_size + pagedir1_size) * 2 + 8 + MIN_FREE_RAM + (long) max_mapnr - orig_mem_free + REAL_MAX_ASYNC)
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/Config.in m1/kernel/suspend/Config.in
--- m2/kernel/suspend/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/Config.in	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,10 @@
+
+if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+   dep_bool 'Software Suspend' CONFIG_SOFTWARE_SUSPEND $CONFIG_PM
+   if [ "$CONFIG_SOFTWARE_SUSPEND" = "y" ]; then
+      bool '    Compile in debugging output' CONFIG_SOFTWARE_SUSPEND_DEBUG
+      bool '    Checksum pages and report differences' CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+      bool '    Compress image' CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+   fi
+fi
+
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/freeze_and_free.c m1/kernel/suspend/freeze_and_free.c
--- m2/kernel/suspend/freeze_and_free.c	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/freeze_and_free.c	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,499 @@
+/*
+ * Freeze_and_free.c
+ *
+ * Freeze_and_free contains the routines software suspend uses to freeze other
+ * processes during the suspend cycle and to (if necessary) free up memory in
+ * accordance with limitations on the image size.
+ *
+ * Ideally, the image saved to disk would be an atomic copy of the entire 
+ * contents of all RAM and related hardware state. One of the first 
+ * prerequisites for getting our approximation of this is stopping the activity
+ * of other processes. We can't stop all other processes, however, since some 
+ * are needed in doing the I/O to save the image. Freeze_and_free.c contains 
+ * the routines that control suspension and resuming of these processes.
+ * 
+ * Under high I/O load, we need to be careful about the order in which we
+ * freeze processes. If we freeze processes in the wrong order, we could
+ * deadlock others. The freeze_order array this specifies the order in which
+ * critical processes are frozen. All others are suspended after these have
+ * entered the refrigerator.
+ *
+ * Another complicating factor is that freeing memory requires the processes
+ * to not be frozen, but at the end of freeing memory, they need to be frozen
+ * so that we can be sure we actually have eaten enough memory. This is why
+ * freezing and freeing are in the one file. The freezer is not called from
+ * the main logic, but indirectly, via the code for eating memory. The eat
+ * memory logic is iterative, first freezing processes and checking the stats,
+ * then (if necessary) unfreezing them and eating more memory until it looks 
+ * like the criteria are met (at which point processes are frozen & stats
+ * checked again).
+ */
+
+#define SWSUSP_FREEZER_C
+
+#include "common.h"
+#include <linux/notifier.h>
+
+extern int pagedir1_size, pagedir2_size;
+extern int pageset2_sizelow;
+extern unsigned long orig_mem_free;
+extern void markpagesforpageset2(void);
+extern int expected_size1, expected_size2; 
+
+/* Pagedir.c */
+extern pageset_sizes_t count_data_pages(int whichpagedir);
+extern int calcpagedirsize(int size);
+
+/* ------------------------------------------------------------------------ */
+
+/* Processes which are never put in the freezer */
+#define IS_IGNORED(p) \
+ ((p->flags & PF_IOTHREAD) || (p == current) || (p->state == TASK_ZOMBIE))
+
+/* Processes which need to be frozen before others in this particular order */
+static char * freeze_order[] = { "kupdated", "kjournald", "kswapd" };
+static const int freeze_order_num = 3;
+
+static int processestofreeze = 0;
+static int processesfrozen = 0;
+static int freezing = 0;
+
+/**
+ * refrigerator - idle routine for frozen processes
+ * @flag: unsigned long, non zero if signals to be flushed.
+ *
+ * A routine for kernel threads which should not do work during suspend
+ * to enter and spin in until the process is finished.
+ *
+ */
+
+void refrigerator(unsigned long flag)
+{
+	long save;
+	/* You need correct to work with real-time processes.
+	   OTOH, this way one process may see (via /proc/) some other
+	   process in stopped state (and thereby discovered we were
+	   suspended. We probably do not care). 
+	 */
+	processesfrozen++;
+	printnolog(SUSPEND_FREEZER, SUSPEND_VERBOSE, 0, "%s refrigerated.\n", current->comm);
+	
+	if (flag)
+		flush_signals(current); /* We have signaled a kernel thread, which isn't normal behaviour
+					   and that may lead to 100%CPU sucking because those threads
+					   just don't manage signals. */
+
+	/* 
+	 * We don't look at suspend_task here anymore, because
+	 * it isn't set when first threads are signalled.
+	 */
+
+	if (freezing) {
+		save = current->state;
+		current->state = TASK_STOPPED;
+		current->flags |= PF_FROZEN;
+		while (current->flags & PF_FROZEN)
+			schedule();
+		current->state = save;
+	} else
+		printk(KERN_DEBUG "%s entered refrigerator when suspend not in progress!\n", current->comm);
+	current->flags &= ~PF_FREEZE;
+	processesfrozen--;
+}
+
+/*
+ * freeze_processes - Freeze processes prior to saving an image of memory to disk
+ * 
+ * Return value: 0 = success, else # of processes that we failed to stop 
+ */
+static int freeze_processes(void)
+{
+	int todo, threadcount;
+	unsigned long start_time, iorequestflags;
+	struct task_struct *p;
+	int index = 0;
+	
+	/* 
+	 * Only use our count of processes yet to be frozen
+	 * when no processes have been frozen yet (first pass).
+	 */
+
+	freezing = 1;
+
+	if (!processesfrozen)
+		processestofreeze = 0;
+
+	start_time = jiffies;
+	printnolog(SUSPEND_FREEZER, SUSPEND_VERBOSE, 0, "%s:\n",
+		freeze_order[0]);
+
+	swsusp_spin_lock_irqsave(&io_request_lock, iorequestflags);
+
+	do {
+		todo = 0;
+		threadcount = 0;
+		read_lock(&tasklist_lock);
+		for_each_task(p) {
+			unsigned long flags;
+			int getsattention = ((index == freeze_order_num) || 
+					(!strcmp(p->comm, freeze_order[index])));
+			if (IS_IGNORED(p) || (p->flags & PF_FROZEN) ||
+					(!(p->flags & PF_REFRIGERATE)))
+				continue;
+			if (getsattention)
+				threadcount++;
+			todo++;
+			if (!getsattention)
+				continue;
+			if (!(p->flags & PF_FREEZE))
+				printnolog(SUSPEND_FREEZER, SUSPEND_VERBOSE, 0, "  pid %d\n", p->pid);
+			/* FIXME: smp problem here: we may not access other process' flags
+			   without locking */
+			p->flags |= PF_FREEZE;
+			swsusp_spin_lock_irqsave(&p->sigmask_lock, flags);
+			signal_wake_up(p);
+			swsusp_spin_unlock_irqrestore(&p->sigmask_lock, flags);
+		}
+		read_unlock(&tasklist_lock);
+		if (!threadcount && index < freeze_order_num) {
+			printnolog(SUSPEND_FREEZER, SUSPEND_VERBOSE, 0, "done.\n");
+			index++;
+			if (index < freeze_order_num) {
+				printnolog(SUSPEND_FREEZER, SUSPEND_VERBOSE, 0, "%s:\n",
+					freeze_order[index]);
+			} else {
+				printnolog(SUSPEND_FREEZER, SUSPEND_VERBOSE, 0, "Remaining threads:");
+			}
+		}
+		if (processestofreeze == 0)
+			processestofreeze = todo;
+		yield();
+		if (time_after(jiffies, start_time + TIMEOUT)) {
+			SET_RESULT_STATE(SUSPEND_ABORTED);
+			SET_RESULT_STATE(SUSPEND_FREEZING_FAILED);
+			printk(KERN_ERR name_suspend "\nStopping tasks failed.\n");
+			show_state();
+			printk(KERN_ERR "Tasks that refused to be refrigerated were:\n");
+			for_each_task(p) {
+				if (IS_IGNORED(p) || (p->flags & PF_FROZEN) ||
+					(!(p->flags & PF_FREEZE)))
+					continue;
+				/* 
+				 * We still let the process enter the refrigerator when it's 
+				 * ready. It will just flush signals and exit immediately 
+				 * because suspend_task isn't set.
+				 */
+				printk(" - %s\n", p->comm);
+			}
+			freezing = 0;
+			swsusp_spin_unlock_irqrestore(&io_request_lock, iorequestflags);
+			return todo;
+		}
+		if (processestofreeze)
+			update_status(processestofreeze - processesfrozen , processestofreeze, NULL);
+	} while(processestofreeze > processesfrozen);
+
+	suspend_task = current->pid;
+	freezing = 0;
+
+	swsusp_spin_unlock_irqrestore(&io_request_lock, iorequestflags);
+
+	check_shift_keys(1, "Freezing processes completed. ");
+	
+	return 0;
+}
+
+void thaw_processes(void)
+{
+	struct task_struct *p;
+	printnolog(SUSPEND_FREEZER, SUSPEND_LOW, 1, name_resume "Thawing tasks\n");
+	
+	suspend_task = 0;
+	
+	for_each_task(p) {
+		if (IS_IGNORED(p))
+			continue;
+		if (p->flags & PF_FROZEN) {
+			p->flags &= ~PF_FROZEN;
+			wake_up_process(p);
+		}
+	}
+}
+
+/*
+ * We need to eat memory until we can:
+ * 1. Perform the save without changing anything (RAM_NEEDED < max_mapnr)
+ * 2. Fit it all in available swap (swapinfo.freeswap >= SWAP_NEEDED)
+ * 3. Reload the pagedir and pageset1 to places that don't collide with their
+ *    final destinations, not knowing to what extent the resumed kernel will
+ *    overlap with the one loaded at boot time. I think the resumed kernel should overlap
+ *    completely, but I don't want to rely on this as it is an unproven assumption. We
+ *    therefore assume there will be no overlap at all (worse case).
+ * 4. Meet the user's requested limit (if any) on the size of the image.
+ *    The limit is in MB, so pages/256 (assuming 4K pages).
+ *
+ *    I have seen simply waiting for the user to press SHIFT increase the
+ *    number of pages to save by one (logs?), so tests are <, not <= to allow
+ *    one extra page. (Final test in save_image doesn't use EATEN_ENOUGH_MEMORY)
+ *
+ *    RAM_TO_RESUME includes +8 to allow for extra pages allocated during read_primary_suspend_image.
+ *    pageset1_size includes space for both pagedirs.
+ */
+
+static int amount_needed(int eaten)
+{
+	return (MAX(MAX(MAX(RAM_TO_SUSPEND - nr_free_pages() - eaten, RAM_TO_RESUME - max_mapnr), 
+			       SWAP_NEEDED -  swapinfo.freeswap), 
+			   ((image_size_limit) ? (SWAP_NEEDED - (image_size_limit << 8)) : 0)));
+}
+
+#define EATEN_ENOUGH_MEMORY() (amount_needed(amount_eaten) < 1)
+
+/* 
+ * We are assuming here that pageset1_size always excludes pagedir size.
+ */
+void display_stats(unsigned int eaten)
+{ 
+	printnolog(SUSPEND_EAT_MEMORY, SUSPEND_VERBOSE, 0, "Free:%d(%d). Sets:%d,%d (%d). PD:(%d,%d). Swap:%d/%lu. RAM s:%d; r:%lu. Limits:%lu,%d\n", 
+			nr_free_pages() + eaten, 
+			nr_free_pages(),
+			pageset1_size, 
+			pageset2_size,
+			pageset2_sizelow,
+			pagedir1_size,
+			pagedir2_size,
+			SWAP_NEEDED,
+			swapinfo.freeswap,
+			RAM_TO_SUSPEND,
+			RAM_TO_RESUME,
+			max_mapnr,
+			image_size_limit << 8); 
+}
+
+/*
+ * Eaten is the number of pages which have been eaten.
+ * Pagedirincluded is the number of pages which have been allocated for the pagedir.
+ */
+void recalculate_stats(int amount_eaten) 
+{ 
+	pageset_sizes_t result;
+	markpagesforpageset2();  /* Need to call this before getting pageset1_size! */
+	result = count_data_pages(0);	/* Only counts because of zero parameter */
+	printlog(SUSPEND_PAGESETS, SUSPEND_VERBOSE, "Recalculate stats: PD2: %d->%d ", result.size2, calcpagedirsize(result.size2));
+	pageset2_sizelow = result.size2low;
+	pageset2_size = result.size2;
+	pagedir2_size = calcpagedirsize(pageset2_size);
+	printlog(SUSPEND_PAGESETS, SUSPEND_VERBOSE, "PD1: %d->%d ", result.size1, calcpagedirsize(result.size1));
+	pageset1_size = result.size1 + pagedir2_size;
+	pagedir1_size = calcpagedirsize(pageset1_size + calcpagedirsize(pageset1_size));
+	pageset1_size += pagedir1_size;
+	printlog(SUSPEND_PAGESETS, SUSPEND_VERBOSE, "Pageset1 Total %d + %d + %d = %d. Check: %d.\n",
+			result.size1,
+			pagedir1_size,
+			pagedir2_size,
+			pageset1_size,
+			calcpagedirsize(pageset1_size));
+	si_swapinfo(&swapinfo);	/* FIXME: si_swapinfo(&i) returns all swap devices information.*/ 
+}
+
+struct eaten_memory_t
+{
+	void * prev;
+	int order; /* Order of _this_ allocation */
+};
+
+struct eaten_memory_t *eaten_memory = NULL;
+
+static int grab_free_memory(void)
+{
+	int order, k, amount_eaten = 0;
+	struct eaten_memory_t *prev = eaten_memory;
+
+	/*
+	 * First, quickly eat all memory that's already free.
+	 */
+	
+	for (order = MAX_ORDER - 1; order > -1; order--) {
+		eaten_memory = (struct eaten_memory_t *) __get_free_pages(__GFP_FAST, order);
+		while (eaten_memory) {
+			struct page * page = virt_to_page(eaten_memory);
+			eaten_memory->prev = prev;
+			eaten_memory->order = order;
+			prev = eaten_memory;
+			amount_eaten += (1 << order);
+			for (k=0; k < (1 << order); k++)
+				SetPageNosave(page + k);
+			eaten_memory = (struct eaten_memory_t *) __get_free_pages(__GFP_FAST, order);
+		}
+	}
+
+	eaten_memory = prev;
+	return amount_eaten;
+}
+
+void free_grabbed_memory(void)
+{
+	struct eaten_memory_t *prev = NULL;
+	int j, num_freed = 0;
+
+	/* Free all eaten pages immediately */
+	while(eaten_memory) {
+		struct page * page = virt_to_page(eaten_memory);
+		prev = eaten_memory->prev;
+		for (j=0; j < (1 << (eaten_memory->order)); j++) {
+			ClearPageNosave(page + j);
+			num_freed++;
+		}
+		free_pages((unsigned long) eaten_memory, eaten_memory->order);
+		eaten_memory = prev;
+	}
+	printlog(SUSPEND_EAT_MEMORY, SUSPEND_VERBOSE,"Freed %d pages.\n", num_freed);
+}
+
+int attempt_to_freeze(void)
+{
+	int lastfreezeresult, freezeattemptsleft = 3;
+
+	/* Stop processes before checking again */
+	do {
+		prepare_status(1, 1, "Freezing processes: Attempt %d", 4 - freezeattemptsleft);
+		lastfreezeresult = freeze_processes();
+		freezeattemptsleft--;
+	} while (freezeattemptsleft && lastfreezeresult);
+
+	return lastfreezeresult;
+}
+
+int eat_memory_and_freeze_processes(void)
+{
+	int orig_memory_still_to_eat, last_amount_needed = 0, times_criteria_met = 0;
+	int amount_eaten = 0, arefrozen = 0;
+
+	printlog(SUSPEND_EAT_MEMORY, SUSPEND_LOW, name_suspend "Eating pages\n");
+
+	recalculate_stats(0);
+	display_stats(0);
+
+	prepare_status(0, 1, "Freeing memory...");
+
+	orig_memory_still_to_eat = amount_needed(0);
+	last_amount_needed = orig_memory_still_to_eat;
+
+	/*
+	 * Note that if we have enough swap and enough free memory, we may exit 
+	 * without eating anything. We give up when the last 10 iterations ate
+	 * no extra pages because we're not going to get much more anyway, but
+	 * the few pages we get will take a lot of time.
+	 *
+	 * We freeze processes before beginning, and then unfreeze them if we
+	 * need to eat memory until we think we have enough. If our attempts
+	 * to freeze fail, we give up and abort.
+	 */
+
+	if (attempt_to_freeze())
+		return 1;
+	arefrozen = 1;
+	
+	printlog(SUSPEND_EAT_MEMORY, SUSPEND_VERBOSE, "Frozen processes at entry to eating memory.\n");
+
+	while ((!EATEN_ENOUGH_MEMORY()) && (!SUSPEND_ABORTED) && (times_criteria_met < 10) && (swapinfo.freeswap)) {
+		if (orig_memory_still_to_eat)
+			update_status(orig_memory_still_to_eat - amount_needed(amount_eaten), orig_memory_still_to_eat, "Image size %d ", MB(SWAP_NEEDED));
+		//printk("Amount needed:%d, Orig:%d, Percent: %d\n", amount_needed(), orig_memory_still_to_eat, (orig_memory_still_to_eat - amount_needed()) * 100 / orig_memory_still_to_eat);
+		
+		if (arefrozen) {
+			printlog(SUSPEND_EAT_MEMORY, SUSPEND_VERBOSE, "Waking for memory grab...\n");
+			thaw_processes();
+			arefrozen = 0;
+		}
+
+		if (((last_amount_needed - amount_needed(amount_eaten)) == 0) && (amount_eaten > 0))
+			times_criteria_met++;
+		else
+			times_criteria_met = 0;
+		last_amount_needed = amount_needed(amount_eaten);
+		try_to_free_pages_swsusp(GFP_KSWAPD, amount_needed(amount_eaten));
+		amount_eaten += grab_free_memory();
+		recalculate_stats(amount_eaten);
+		display_stats(amount_eaten);
+
+		check_shift_keys(0, NULL);
+
+		if (EATEN_ENOUGH_MEMORY())  { /* Make sure we really have eaten enough before we leave the loop */
+			do_suspend_sync();
+			
+			if (times_criteria_met == 10) 
+				if (attempt_to_freeze())
+					return 1;
+
+			recalculate_stats(amount_eaten);
+		}
+	}
+
+	printlog(SUSPEND_EAT_MEMORY, SUSPEND_VERBOSE, "\n");
+	
+	if (!arefrozen)
+		if (attempt_to_freeze())
+			return 1;
+	
+	update_status(100, 100, NULL);
+	if ((amount_needed(amount_eaten) > 0))
+		printlog(SUSPEND_EAT_MEMORY, SUSPEND_LOW, "\n--- UNABLE TO GET ANY MORE PAGES ---\n");
+	
+	check_shift_keys(1, "Memory eating completed. ");
+
+	return 0;
+}
+
+/*
+ * The following code is based on the reboot notifier code in kernel/sys.c.
+ * It is used to notify drivers when a suspend cycle finishes, so that
+ * timers which have been stopped can be restarted.
+ */
+
+
+/*
+ *	Notifier list for kernel code which wants to be called
+ *	at resume. This is used to restart timers which were
+ *	stopped during suspend.
+ */
+
+static struct notifier_block *resume_notifier_list;
+rwlock_t swsusp_notifier_lock = RW_LOCK_UNLOCKED;
+
+/**
+ *	register_resume_notifier - Register function to be called at resume time
+ *	@nb: Info about notifier function to be called
+ *
+ *	Registers a function with the list of functions
+ *	to be called at resume time.
+ *
+ *	Currently always returns zero, as notifier_chain_register
+ *	always returns zero.
+ */
+ 
+int register_resume_notifier(struct notifier_block * nb)
+{
+	return notifier_chain_register(&resume_notifier_list, nb);
+}
+
+/**
+ *	unregister_resume_notifier - Unregister previously registered resume notifier
+ *	@nb: Hook to be unregistered
+ *
+ *	Unregisters a previously registered resume
+ *	notifier function.
+ *
+ *	Returns zero on success, or %-ENOENT on failure.
+ */
+ 
+int unregister_resume_notifier(struct notifier_block * nb)
+{
+	return notifier_chain_unregister(&resume_notifier_list, nb);
+}
+
+inline int notify_resume(void)
+{
+	return notifier_call_chain(&resume_notifier_list, 0, NULL);
+}
+
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/io.c m1/kernel/suspend/io.c
--- m2/kernel/suspend/io.c	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/io.c	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,986 @@
+/*
+ * linux/drivers/swsusp/io.c
+ *
+ * This file contains IO routines for swsusp.
+ *
+ */
+
+#define SWSUSP_IO_C
+
+#include "common.h"
+extern void reset_io_stats(void);
+extern void check_io_stats(void);
+extern int write_swap_page(swp_entry_t posn, struct page * page, int asyncio);
+extern int get_phys_params(struct pbe * pbe);
+extern void swsusp_rw_swap_page(int rw, struct pbe * pbe);
+extern unsigned long swapforimage;
+extern unsigned long base_mem_free;
+extern int expected_size1, expected_size2; 
+extern int swsusp_act_used;
+extern int swsusp_lvl_used;
+extern int swsusp_dbg_used;
+extern void warmup_collision_cache(void);
+extern int relocate_pagedir(void);
+extern int check_pagedir(void);
+extern struct pagedir __nosavedata pagedir_nosave;
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+extern unsigned long pagechecksum(struct page * page);
+unsigned long checkpagecopy = 0;
+unsigned long checkpage = 0;
+#endif
+extern int allocatemap(unsigned long ** pagemap, int setnosave);
+extern unsigned long * pagedirmap;
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+
+extern int zlib_compress(unsigned char *data_in, unsigned char *cpage_out, __u32 *sourcelen, __u32 *dstlen);
+extern void zlib_decompress(unsigned char *data_in, unsigned char *cpage_out, __u32 srclen, __u32 destlen);
+static void *compression_workspace;
+
+/*
+ * prepare_zlib_deflate_memory()
+ *
+ * Description: Allocate space for zlib's deflate code.
+ * Returns: -ENOMEM on failure, 0 on success.
+ *
+ */
+
+static int prepare_zlib_deflate_memory(void)
+{
+	compression_workspace = vmalloc(zlib_deflate_workspacesize());
+	if (!compression_workspace) {
+		printk(KERN_WARNING "Failed to allocate %d bytes for deflate workspace\n", zlib_deflate_workspacesize());
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+/*
+ * prepare_zlib_inflate_memory()
+ *
+ * Description: Allocate space for zlib inflate code.
+ * Returns: -ENOMEM on failure, 0 on success.
+ *
+ */
+
+static int prepare_zlib_inflate_memory(void)
+{
+	compression_workspace = vmalloc(zlib_inflate_workspacesize());
+	if (!compression_workspace) {
+		printk(KERN_WARNING "Failed to allocate %d bytes for inflate workspace\n", zlib_inflate_workspacesize());
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+/*
+ * release_zlib_memory()
+ *
+ * Description: Release space for zlib [de|in]flate code.
+ * Returns: Nothing
+ *
+ */
+
+static void release_zlib_memory(void)
+{
+	if (compression_workspace)
+		vfree(compression_workspace);
+}
+#endif // CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+
+/*
+ * write_pageset()
+ *
+ * Description: Write a pageset to disk.
+ * @pagedir: Pointer to the pagedir to be saved.
+ * @whichtowrite: Controls what debugging output is printed.
+ * Returns: Zero on success or -1 on failure.
+ *
+ */
+
+int write_pageset(struct pagedir * pagedir, int whichtowrite)
+{
+	int nextupdate = 0, size, ret = 0, i;
+	int start_time, end_time;
+	long result = 0;
+	struct pbe * pbe;
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	z_stream strm;
+	int ret2 = 0;
+	struct pbe * swap_pbe = NULL;
+	unsigned long compression_buffer = 0;
+#endif
+
+#define abort_and_exit(f, a...) do { \
+			abort_suspend(f, ## a); \
+			result = -1; \
+			goto write_pageset_free_buffers; \
+	} while(0)
+
+	reset_io_stats();
+	PRINTFREEMEM("at start of write pageset");
+
+	size = pagedir->pageset_size;
+	if (!size)
+		return 0;
+
+	if (whichtowrite == 1) {
+		prepare_status(1, 1, "Writing suspend image (1)...");
+	} else {
+		prepare_status(1, 1, "Writing suspend image (2)...");
+	}	
+	
+	start_time = jiffies;
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	if (!TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION)) {
+		compression_buffer = get_zeroed_page(GFP_ATOMIC);
+
+		if (!compression_buffer) {
+			printk(KERN_ERR name_suspend "Failed to allocate memory for compression buffer.\n");
+			return -1;
+		}
+	
+		if (prepare_zlib_deflate_memory()) {
+			printk(KERN_ERR name_suspend "Failed to allocate memory for zlib to work in.\n");
+			free_pages(compression_buffer, 0);
+			return -1;
+		}
+	
+		strm.total_in = 0;
+		strm.total_out = 0;
+		strm.workspace = compression_workspace;
+		strm.next_out = (char *) compression_buffer;
+		strm.avail_out = PAGE_SIZE;
+
+		if (Z_OK != zlib_deflateInit(&strm, Z_BEST_SPEED)) {
+			printk(KERN_ERR name_suspend "Failed to initialise zlib.\n");
+			release_zlib_memory();
+			free_pages(compression_buffer, 0);
+			return -1;
+		}
+		swap_pbe = pagedir->data;
+	}
+#endif
+
+	pbe = pagedir->data;
+
+	for (i=0; i<size; i++) {
+		if (!(i&0x1FF)) 
+			printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_LOW, ".");
+		if ((i >= nextupdate) || (!(i%(1 << (20 - PAGE_SHIFT)))))
+			nextupdate = update_status(i, size, " %d/%d MB ", MB(i+1), MB(size));
+		printnolog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, 1, name_suspend "Writing pageset: %d/%d ", i + 1, size);
+	
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+		if ((unsigned long) page_address(pbe->origaddress) == checkpage) {
+			checkpagecopy = (unsigned long) page_address(pbe->address);
+			printk(KERN_ERR "Page checksum for page %lx is %lx. Writing to %lx.\n",
+				checkpage,
+				pagechecksum(pbe->origaddress),
+				pbe->swap_address.val);
+		}
+#endif
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+		if (!TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION)) {
+			strm.next_in = kmap_nonblock(pbe->address);
+			if (!strm.next_in) {
+				zlib_deflateEnd(&strm);
+				abort_and_exit("Failed to kmap a page.\n");
+			}
+			strm.avail_in = PAGE_SIZE;
+
+			while ((strm.avail_in) || (((i+1) == size) && (ret != Z_STREAM_END))) {
+				if ((i+1) == size) {
+					ret = zlib_deflate(&strm, Z_FINISH);
+					if (ret == Z_STREAM_END)
+						zlib_deflateEnd(&strm);
+				} else
+					ret = zlib_deflate(&strm, Z_PARTIAL_FLUSH);
+				if ((ret != Z_OK) && (ret != Z_STREAM_END)) {
+					zlib_deflateEnd(&strm);
+					abort_and_exit("Failed to finish compressing data. Result %d received.\n", ret);
+				}
+				if ((!strm.avail_out) || (ret == Z_STREAM_END)) {
+					/* Submit previous buffer for writing */
+					ret2 = write_swap_page(swap_pbe->swap_address, virt_to_page(compression_buffer), 1);
+					if (ret2) {
+						zlib_deflateEnd(&strm);
+						abort_and_exit("Failed writing page to swap. Error number was %d.\n", ret);
+					}
+
+					/* Get next buffer */
+					swap_pbe = get_next_pbe(swap_pbe);
+					/* 
+					 * Since it is a copy of the compression buffer that is written 
+					 * asynchronously, we can immediately reuse our buffer.
+					 */
+					strm.next_out = (char *) compression_buffer;
+					strm.avail_out = PAGE_SIZE;
+				}
+			}
+		
+			kunmap(pbe->address);
+		} else {
+#endif
+			if (whichtowrite == 1) {
+				printnolog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, 0, "!%d! [1]%lx -> [2]%lx -> [sw]%lx.", 
+					i,
+					(unsigned long) pbe->origaddress, 
+					(unsigned long) pbe->address, 
+					pbe->swap_address.val);
+			} else {
+				printnolog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, 0, "!%d! %s[2]%lx -> [sw]%lx",
+					i,
+					PageHighMem(pbe->origaddress) ? "[HighMem]" : "",
+					(unsigned long) pbe->address,
+					pbe->swap_address.val);
+			}
+
+			ret = write_swap_page(pbe->swap_address, pbe->address, 1);
+			if (ret)
+				abort_and_exit("Failed writing page to swap. Error number was %d.\n", ret);
+		
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+		}
+#endif
+		check_shift_keys(0, NULL);
+		if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+			abort_and_exit("Aborting as requested.\n");
+
+		pbe = get_next_pbe(pbe);
+	}
+
+	update_status(1, 1, NULL);
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	if (!TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION)) {
+		if (ret != Z_STREAM_END)
+			printk(KERN_ERR "Final zlib return value wasn't stream_end!\n");
+	}
+#endif
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, "|\n");
+write_pageset_free_buffers:
+	finish_all_io();
+	
+	end_time = jiffies;
+	if ((end_time - start_time) && (!TEST_RESULT_STATE(SUSPEND_ABORTED)))
+		printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_MEDIUM, "Time to write data: %d jiffies. Pages written per jiffy: %d.\n", end_time - start_time, size / (end_time - start_time));
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	if (!TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION)) {
+		release_zlib_memory();
+		free_pages(compression_buffer, 0);
+	}
+#endif
+	PRINTFREEMEM("at end of write pageset");
+	check_io_stats();
+	return result;
+}
+
+/*
+ * read_pageset()
+ *
+ * Description: Read a pageset from disk.
+ * @pagedir: Pointer to the pagedir to be saved.
+ * @whichtowrite: Controls what debugging output is printed.
+ * @overwrittenpagesonly: Whether to read the whole pageset or only part.
+ * Returns: Zero on success or -1 on failure.
+ *
+ */
+
+int read_pageset(struct pagedir * pagedir, int whichtoread, int overwrittenpagesonly)
+{
+	int nextupdate = 0, size, result = 0;
+	int start_time, end_time, finish_at = 0;
+	long i;
+	char * dest_address = NULL;
+	struct pbe * pbe;
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	struct pbe * checkpagepbe = NULL;
+#endif
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	int ret = 0, ret2 = 0;
+	z_stream strm;
+	struct pbe * swap_pbe = NULL;
+	unsigned long compression_buffer = 0;
+	struct pbe readpbe;
+#endif
+
+#undef abort_and_exit
+#define abort_and_exit(f, a...) do { \
+			abort_suspend(f, ## a); \
+			result = -1; \
+			goto read_pageset_free_buffers; \
+	} while(0)
+
+	reset_io_stats();
+	PRINTFREEMEM("at start of read pageset");
+
+	size = pagedir->pageset_size;
+
+	if (whichtoread == 1) {
+		prepare_status(1, 1, "Reading suspend image (1)...");
+	} else {
+		prepare_status(1, 1, "Reading suspend image (2)...");
+	}	
+	beepOK;
+	
+	start_time=jiffies;
+
+	if (overwrittenpagesonly && (whichtoread == 2))
+		finish_at = MIN(pageset1_size, pageset2_size);
+	else
+		finish_at = pagedir->pageset_size;
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	if (!TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION)) {
+		compression_buffer = get_zeroed_page(GFP_ATOMIC);
+
+		if (!compression_buffer) {
+			printk(KERN_ERR name_suspend "Failed to allocate memory for compression buffer.\n");
+			return -1;
+		}
+	
+		if (prepare_zlib_inflate_memory()) {
+			printk(KERN_ERR name_suspend "Failed to allocate memory to write the pageset.\n");
+			free_pages(compression_buffer, 0);
+			return -1;
+		}
+	
+		strm.total_in = 0;
+		strm.total_out = 0;
+		strm.workspace = compression_workspace;
+		strm.avail_in = 0;
+
+		if (Z_OK != zlib_inflateInit(&strm)) {
+			printk(KERN_ERR name_suspend "Failed to initialise zlib.\n");
+			free_pages(compression_buffer, 0);
+			goto read_pageset_free_buffers;
+		}
+
+		swap_pbe = pagedir->data;
+	}
+#endif
+	pbe = pagedir->data;
+
+	for (i=0; i< finish_at; i++) {
+		if (!(i&0x1FF)) 
+			printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_LOW, ".");
+		if ((i >= nextupdate) || (!(i%(1 << (20 - PAGE_SHIFT)))))
+			nextupdate = update_status(i, finish_at, " %d/%d MB ", MB(i+1), MB(finish_at));
+		printnolog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, 1, name_suspend "Reading pageset: %d/%d ", i + 1, finish_at);
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+		if (!TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION)) {
+			dest_address = kmap_nonblock(pbe->address);
+			if (!dest_address)
+				abort_and_exit("Failed to kmap a page!");
+
+			strm.next_out = dest_address;
+			strm.avail_out = PAGE_SIZE;
+
+			while ((strm.avail_out) && (ret != Z_STREAM_END) && (ret != Z_BUF_ERROR)) {
+				if (!strm.avail_in) {
+					/* Get next page of the compressed image */
+					readpbe.swap_address = swap_pbe->swap_address;
+					readpbe.swap_bdev = swap_pbe->swap_bdev;
+					readpbe.block = swap_pbe->block;
+					readpbe.address = virt_to_page(compression_buffer);
+					ret2 = bdev_read_swap(&readpbe, 0);
+					if (ret2)
+						abort_and_exit("Failed reading page to swap. Error number was %d.\n", ret);
+					strm.next_in = (char *) compression_buffer;
+					strm.avail_in = PAGE_SIZE;
+					swap_pbe = get_next_pbe(swap_pbe);
+				}
+				ret = zlib_inflate(&strm, Z_PARTIAL_FLUSH);
+				if ( ret == Z_BUF_ERROR && strm.avail_in == 0 )
+					continue;
+				if (ret == Z_STREAM_END)
+					zlib_inflateEnd(&strm);
+				check_shift_keys(0, NULL);
+				if ((ret != Z_OK) && (ret != Z_STREAM_END)) {
+					zlib_inflateEnd(&strm);
+					abort_and_exit("Failed to decompress data. Result %d received. Message is %s\n", ret, strm.msg);
+				}
+			}
+			kunmap(pbe->address);
+		} else {
+#endif
+			if (bdev_read_swap(pbe, 1)) {
+				result = -EIO;
+				abort_and_exit("Failed to read page %lx from swap to %lx!", pbe->swap_address.val, dest_address);
+			}
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+		}
+#endif
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+		if ((unsigned long) page_address(pbe->origaddress) == checkpage)
+			checkpagepbe = pbe;
+#endif
+
+		pbe = get_next_pbe(pbe);
+
+		check_shift_keys(0, NULL);
+	}
+
+	update_status(1, 1, NULL);
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	if (!TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION)) {
+		/* If only reading part, still need to clean up */
+		if ((i > finish_at) && (ret != Z_STREAM_END))
+			zlib_inflateEnd(&strm);
+	
+		if (ret != Z_STREAM_END)
+			printk(KERN_ERR "Final zlib return value wasn't stream_end!\n");
+	}
+#endif
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_LOW, "|\n");
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	if (checkpagepbe)
+		printk(KERN_ERR "Page checksum for page %lx is %lx. For data loaded from %lx (to %p) is %lx.\n",
+			checkpage,
+			pagechecksum(checkpagepbe->origaddress),
+			checkpagepbe->swap_address.val,
+			checkpagepbe->address,
+			pagechecksum(checkpagepbe->address));
+#endif
+
+read_pageset_free_buffers:
+	finish_all_io();
+	
+	end_time=jiffies;
+	if ((end_time - start_time) && (!TEST_RESULT_STATE(SUSPEND_ABORTED)))
+		printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_MEDIUM, "Time to read data: %d jiffies. Pages read per jiffy: %d.\n", end_time - start_time, finish_at / (end_time - start_time));
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	if (!TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION)) {
+		release_zlib_memory();
+		free_pages(compression_buffer, 0);
+	}
+#endif
+	PRINTFREEMEM("at end of read pageset");
+	check_io_stats();
+	return result;
+}
+
+/*
+ * write_pagedir_and_suspend_header()
+ *
+ * Description: Write the pagedir and suspend header to disk.
+ * Returns: Zero on success or -1 on failure.
+ *
+ */
+
+int  write_pagedir_and_suspend_header(void)
+{
+	int i, j, len, *ptr, nextupdate = 0, ret, arrayorder;
+	swp_entry_t entry, prev = { 0 };
+	int total = pagedir1.pageset_size+pagedir2.pageset_size+pagedir1.pagedir_size+2;
+	int progress = total-1;
+	//struct pbe pbearray[pagedir1.pagedir_size+1];
+	struct pbe * pbearray;
+	struct pbe pbeheader;
+	struct pbe * thispagedirpage = pagedir1.data;
+	union p_diskpage diskpage;
+
+#undef abort_and_exit
+#define abort_and_exit(f, a...) do { \
+			abort_suspend(f, ## a); \
+			goto write_pagedir_abort; \
+	} while(0)
+	
+	arrayorder = get_bitmask_order(SUSPEND_PD_PAGES(pagedir1.pagedir_size + 1));
+	pbearray = (struct pbe *) __get_free_pages(__GFP_FAST, arrayorder);
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_LOW, name_suspend "Writing pagedir (%d pages)\n", pagedir1.pagedir_size);
+
+	for (i=0; i<(pagedir1.pagedir_size); i++) {
+		printnolog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, 1, "%d/%d = %p", i+1, pagedir1.pagedir_size, thispagedirpage);
+		pbearray[i].address = virt_to_page(thispagedirpage);
+		printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_LOW, "."); 
+		if (i >= nextupdate)
+			nextupdate = update_status(progress + i, total, NULL);
+		pbearray[i].swap_address = entry = get_swap_page(1);
+		if (!entry.val)
+			abort_and_exit("Not enough swapspace when writing pgdir\n");		
+		get_phys_params(&pbearray[i]);
+		check_shift_keys(0, NULL);
+		if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+			abort_and_exit("Aborting as requested.\n");
+		diskpage.address = (unsigned long) thispagedirpage;
+		diskpage.pointer->link.next = prev;
+		
+		ret = write_swap_page(pbearray[i].swap_address, pbearray[i].address, 1);
+		if (ret)
+			abort_and_exit("Failed writing page to swap. Error number was %d.\n", ret);
+		
+		prev = entry;
+		thispagedirpage = get_next_pagedir_page(thispagedirpage);
+	}
+
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, "H");
+#ifdef SOFTWARE_SUSPEND_MTRR
+	ptr = mtrr_suspend();
+	if(ptr)
+		len = *ptr;
+	else
+#endif
+	{
+		len = 4;	/* we need to put a zero */
+		ptr = NULL;
+	}
+	if (len + sizeof(struct suspend_header) > PAGE_SIZE-sizeof(swp_entry_t))
+		abort_and_exit("Size of suspend header too big!\n");
+	if (sizeof(union diskpage) != PAGE_SIZE)
+		abort_and_exit("Size of a disk page is not PAGE_SIZE!\n");
+
+	diskpage.address = get_free_page(GFP_ATOMIC);
+	pbeheader.address = virt_to_page(diskpage.address);
+	pbeheader.swap_address = get_swap_page(1);
+	get_phys_params(&pbeheader);
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+		goto write_pagedir_abort;
+	
+	if (fill_suspend_header(&(diskpage.pointer->sh)))
+		abort_and_exit("Out of memory while writing header!\n");
+	if(ptr)
+		memcpy(diskpage.ptr+sizeof(struct suspend_header), ptr, len);
+	else {
+		len = 0;
+		ptr = &len;
+		memcpy(diskpage.ptr+sizeof(struct suspend_header), ptr, sizeof(int));
+	}	  
+	flush_dcache_page(virt_to_page(pbeheader.address));
+	diskpage.pointer->link.next = prev;
+
+	swsusp_rw_swap_page(WRITE, &pbeheader);
+	prev = pbeheader.swap_address;
+
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, "S");
+	update_status(total - 1, total, NULL);
+	mark_swapfiles(prev, MARK_SWAP_SUSPEND);
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+		goto write_pagedir_abort;
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, "|\n");
+	update_status(total, total, NULL);
+
+	MDELAY(1000);
+	finish_all_io();
+	free_pages((unsigned long) diskpage.address, 0);
+	free_pages((unsigned long) pbearray, arrayorder);
+	return 0;
+
+write_pagedir_abort:
+	swap_free(entry);
+	swap_free(prev);
+	printk(KERN_ERR "Attempting to free %d pagedir entries in swap.\n", i);
+	thispagedirpage = pagedir1.data;
+	for (j=i-1; j >= 0; j--) {
+		swap_free(((union diskpage *) thispagedirpage)->link.next);
+		thispagedirpage = get_next_pagedir_page(thispagedirpage);
+	}
+	if (pbeheader.swap_address.val)
+		swap_free(pbeheader.swap_address);
+	finish_all_io();
+	free_pages((unsigned long) diskpage.address, 0);
+	free_pages((unsigned long) pbearray, arrayorder);
+	return -1;
+}
+
+#if 0
+int noresume_fix_signature(union p_diskpage cur)
+{
+	/* 
+	 * We don't do a sanity check here: we want to restore the swap 
+	 * whatever version of kernel made the suspend image
+	 */
+	struct buffer_head *bh;
+	printk(name_resume "%s: Fixing swap signatures...\n", resume_file);
+				/* We need to write swap, but swap is *not* enabled so
+				   we must write the device directly */
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_VERBOSE,"Swap signature will be set to %10s\n",cur.pointer->swh.magic.magic);
+	BREAD_BUFFER_HEAD(resume_device, 0);
+	if (is_read_only(bh->b_dev)) {
+		printk(KERN_ERR name_resume "Can't write to read-only device %s\n",
+		       kdevname(bh->b_dev));
+		BFREE(bh);
+		return -EIO;
+	}
+	
+	flush_dcache_page(virt_to_page(bh->b_data));
+	memcpy(bh->b_data, cur.ptr, PAGE_SIZE);
+	generic_make_request(WRITE, bh);
+	wait_on_buffer(bh);
+	sync_swap_partitions();
+	if (buffer_uptodate(bh)) {
+		brelse(bh);
+		BFREE(bh);
+		free_suspend_cache_page(last_suspend_cache_page);
+		/* As with fix_signature, try to read to ensure its written. */
+		BREAD_BUFFER_HEAD(resume_device, 0);
+		brelse(bh);
+		BFREE(bh);
+		return 0;
+	}
+	printk(name_resume "Warning %s: Fixing swap signatures unsuccessful...\n", resume_file);
+	bforget(bh);
+	BFREE(bh);
+	return -EINVAL;		/* non fatal error */
+}
+#endif
+
+/*
+ * Sanity check if this image makes sense with this kernel/swap context
+ * I really don't think that it's foolproof but more than nothing..
+ */
+
+/*
+ * write_pagedir_and_suspend_header()
+ *
+ * Description: Write the pagedir and suspend header to disk.
+ * Returns: Zero on success or -1 on failure.
+ *
+ */
+
+
+static int sanity_check_failed(char *reason)
+{
+	beepERR;
+	printk(KERN_EMERG name_swsusp "%s\n",reason);
+	printk(KERN_EMERG "BIG FAT WARNING!!\n");
+	printk(KERN_EMERG "If you continue booting with this kernel, be sure to mkswap your swap\n");
+	printk(KERN_EMERG "partition. Otherwise, you may severely damage your filesystem on next\n");
+	printk(KERN_EMERG "reboot with the kernel that wrote the resume image.\n");
+	printk(KERN_EMERG "Press SHIFT to reboot or CONTROL to continue booting with this kernel\n");
+	while (!(shift_state & ((1 << KG_SHIFT) | (1 << KG_CTRL)))) 
+		yield(); 
+	if (shift_state & (1 << KG_SHIFT))
+		machine_restart(NULL);
+	/* Wait for release */
+	while (shift_state) 
+		yield(); 
+	printk(KERN_EMERG "ARE YOU SURE: Unless you really know what you're doing just reboot on the correct kernel or use the noresume boot option.");
+	printk(KERN_EMERG "Press SHIFT to reboot or CONTROL to continue booting with this kernel\n");
+	while (!(shift_state & ((1 << KG_SHIFT) | (1 << KG_CTRL)))) 
+		yield(); 
+	if (shift_state & (1 << KG_SHIFT))
+		machine_restart(NULL);
+	/* Wait for release */
+	while (shift_state) 
+		yield(); 
+	return -EPERM;
+}
+
+static int sanity_check(struct suspend_header *sh)
+{
+	if (sh->version_code != LINUX_VERSION_CODE)
+		return sanity_check_failed("Incorrect kernel version");
+	if (sh->num_physpages != num_physpages)
+		return sanity_check_failed("Incorrect memory size");
+	if (strncmp(sh->machine, system_utsname.machine, 65))
+		return sanity_check_failed("Incorrect machine type");
+	if (strncmp(sh->version, system_utsname.version, 65))
+		return sanity_check_failed("Incorrect version");
+	if (sh->num_cpus != smp_num_cpus)
+		return sanity_check_failed("Incorrect number of cpus");
+	if (sh->page_size != PAGE_SIZE)
+		return sanity_check_failed("Incorrect PAGE_SIZE");
+	return 0;
+}
+
+static int __read_primary_suspend_image(union p_diskpage diskpage, int noresume)
+{				/* returned values:
+				   -EINVAL in case of swapspace or if noresume is set and swap signature
+				   wasn't correctly fixed (non fatal error),
+				   0 if suspended image was correctly read or if noresume is set
+				   and swap signature was correctly fixed,
+				   other non zero values are errors. */
+	swp_entry_t next;
+	int i, len, *ptr;
+	kdev_t header_block_device = 0;
+	struct pbe * thispbepage;
+	struct pbe * nextpbepage = NULL;
+
+	if (bdev_read_page(resume_device, 0, virt_to_page(diskpage.ptr))) return -EIO;
+
+	if ((!memcmp("SWAP-SPACE",diskpage.pointer->swh.magic.magic,10)) ||
+	    (!memcmp("SWAPSPACE2",diskpage.pointer->swh.magic.magic,10))) {
+		printk(KERN_ERR name_resume "This is normal swap space\n" );
+		return -EINVAL;	/* non fatal error */
+	}
+	/* Put bdev of suspend header in last byte of swap header (unsigned short) */
+	{
+		kdev_t * header_ptr = (kdev_t *) (&(diskpage.pointer->swh.magic.magic[2]));
+		header_block_device = *header_ptr;
+	}
+
+	next = diskpage.pointer->link.next;
+
+	if (!memcmp("1R",diskpage.pointer->swh.magic.magic,2))
+		memcpy(diskpage.pointer->swh.magic.magic,"SWAP-SPACE",10);
+	else if (!memcmp("2R",diskpage.pointer->swh.magic.magic,2))
+		memcpy(diskpage.pointer->swh.magic.magic,"SWAPSPACE2",10);
+	else {
+		printk("%sUnable to find suspended-data signature (%.10s - misspelled?\n", 
+			name_resume, diskpage.pointer->swh.magic.magic);
+		return -EINVAL;
+		/* We want to abort_suspend even with noresume -- we certainly don't want to add
+		   our signature into your ext2 filesystem ;-) */
+	}
+	flush_dcache_page(virt_to_page(diskpage.pointer));
+	if (noresume)
+		return(noresume_fix_signature(diskpage));
+	
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_VERBOSE, name_resume "Signature found, resuming\n");
+	MDELAY(1000);
+	
+	/* 
+	 * If the header is not on the resume_device, get the resume device first.
+	 */
+	if (header_block_device != resume_device) {
+		int blksize = 0;
+		if (!blksize_size[MAJOR(header_block_device)]) {
+			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "%x: Blocksize not known?", header_block_device);
+		} else blksize = blksize_size[MAJOR(header_block_device)][MINOR(header_block_device)];
+		if (!blksize) {
+			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "%x: Blocksize not set?", header_block_device);
+			blksize = PAGE_SIZE;
+		}
+		set_blocksize(header_block_device, PAGE_SIZE);
+	}
+
+	if (bdev_read_page(header_block_device, SWP_OFFSET(next), virt_to_page(diskpage.ptr))) return -EIO;
+	if (sanity_check(&(diskpage.pointer->sh))) /* Is this the same machine? */
+		return -EPERM;
+#ifdef SOFTWARE_SUSPEND_MTRR
+	ptr = ((int *)(diskpage.ptr+sizeof(struct suspend_header)));
+	len = *ptr;
+	if(len)
+		mtrr_resume(ptr);
+#endif
+	next = diskpage.pointer->link.next;
+
+	base_mem_free = diskpage.pointer->sh.base_mem_free;
+	swapforimage = diskpage.pointer->sh.swapforimage;
+	pagedir_nosave.pageset_size = diskpage.pointer->sh.pagedir.pageset_size;
+	pagedir_nosave.pagedir_size = diskpage.pointer->sh.pagedir.pagedir_size;
+	expected_size1 = diskpage.pointer->sh.expected_size1;
+	expected_size2 = diskpage.pointer->sh.expected_size2;
+	swsusp_result = diskpage.pointer->sh.param0;
+	if (!swsusp_act_used)
+		swsusp_action = diskpage.pointer->sh.param1;
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+	if (!swsusp_dbg_used)
+		swsusp_debug_state = diskpage.pointer->sh.param2;
+#endif
+	if (!swsusp_lvl_used)
+		console_loglevel = diskpage.pointer->sh.param3;
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	checkpage = diskpage.pointer->sh.param4;
+#endif
+#if defined(CONFIG_FBCON_SPLASHSCREEN)
+	fb_splash_progress[0] = diskpage.pointer->sh.progress0;
+	fb_splash_progress[1] = diskpage.pointer->sh.progress1;
+	fb_splash_progress[2] = diskpage.pointer->sh.progress2;
+	fb_splash_progress[3] = diskpage.pointer->sh.progress3;
+	fb_splash_progress[4] = diskpage.pointer->sh.progress4;
+#endif
+	suspend_task = current->pid;
+
+	/*
+	 * We don't need to save swsusp_state[4] because it's not used during resume
+	 * and will be restored with the image anyway
+	 */
+	
+	now_resuming = 1;
+	if (prepare_suspend_console())
+		printk(name_resume "Can't allocate a console... proceeding\n");
+
+	/* 
+	 * Swap hasn't been turned on yet, so we can safely store our kdevs in the original array.
+	 * We're going to be reloading the same values anyway, so nothing will be broken by this.
+	 */
+
+	for (i = 0; i < MAX_SWAPFILES; i++) {
+		kdev_t thisdevice = diskpage.pointer->sh.kdevs[i];
+		int blksize = 0;
+
+		printnolog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, 1, "Swap device %d is %x.", i, diskpage.pointer->sh.kdevs[i]);
+
+		swap_info[i].swap_device = thisdevice;
+		
+		if (!thisdevice)
+			continue;
+
+		if (thisdevice == resume_device) {
+			printnolog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, 0, "Resume root device %x", thisdevice);
+			continue;
+		}
+
+		printnolog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, 0, "Resume secondary device %x", thisdevice);
+		if (!blksize_size[MAJOR(thisdevice)]) {
+			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "%x: Blocksize not known?", thisdevice);
+		} else blksize = blksize_size[MAJOR(thisdevice)][MINOR(thisdevice)];
+		if (!blksize) {
+			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "%x: Blocksize not set?", thisdevice);
+			blksize = PAGE_SIZE;
+		}
+		set_blocksize(thisdevice, PAGE_SIZE);
+	}
+
+	printnolog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, 1, "");
+
+	check_shift_keys(1, "About to read pagedir. ");
+
+	/* We get pages in reverse order of saving. Since this is the only place
+	 * we would _really_ need the reverse part doubly linked, we just
+	 * allocate the pages as we go. */
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,name_resume "Reading pagedir of %d pages, %lx", pagedir_nosave.pagedir_size, next.val);
+
+	for (i=pagedir_nosave.pagedir_size-1; i>=0; i--) {
+		thispbepage = (struct pbe *)get_zeroed_page(GFP_ATOMIC);
+		if ((!thispbepage) || (!next.val)) {
+			int j;
+			thispbepage = nextpbepage;
+			for (j = i; j < pagedir_nosave.pagedir_size - 1; j++) {
+				nextpbepage = get_next_pagedir_page(thispbepage);
+				free_page((unsigned long) thispbepage);
+				thispbepage = nextpbepage;
+			}
+			if (!thispbepage)
+				abort_suspend("Unable to allocate a pagedir.\n");
+			else
+				abort_suspend("next.val NULL in __read_primary_suspend_image!\n");
+			//swsusp_spin_unlock_irq_restore(&suspend_pagedir_lock, pagedirflags);
+			return -ENOMEM;
+		}
+		printnolog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, 0, "[sw]%lx -> [pd%d]%p.\n", next.val, i, thispbepage);
+		diskpage.pointer = (union diskpage *) thispbepage;
+		{
+			kdev_t bdev = swap_info[SWP_TYPE(next)].swap_device;
+			int pos = SWP_OFFSET(next); 
+			if (bdev_read_page(bdev, pos, virt_to_page(diskpage.ptr))) return -EIO;
+		}
+		next = diskpage.pointer->link.next;
+		if (!i)
+			pagedir_nosave.data = thispbepage;
+		set_next_pagedir_page(thispbepage, nextpbepage);
+		nextpbepage = thispbepage;
+	}
+	if (next.val) {
+		abort_suspend("next.val not NULL in __read_primary_suspend_image!\n");
+		return -EPERM;
+	}
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "Pagedir_nosave.data is %p\n", pagedir_nosave.data);
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "Pagedir_nosave.pageset_size is %d\n", pagedir_nosave.pageset_size);
+
+ 	warmup_collision_cache();
+ 
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "Attempting to relocate pagedir with %d pages free.\n", nr_free_pages());
+	if (allocatemap(&pagedirmap, 1))
+		return -ENOMEM;
+	
+	if (relocate_pagedir())
+		return -ENOMEM;
+	if (check_pagedir())
+		return -ENOMEM;
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,name_resume "Reading primary pageset data (%d pages). Pagedir at %lx\n", pagedir_nosave.pageset_size, (unsigned long) pagedir_nosave.data);
+	
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,"\n");
+
+	check_shift_keys(1, "About to read pageset 1. ");
+
+	if (read_pageset(&pagedir_nosave, 1, 0))
+		return -EPERM;
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,"\n|\n");
+	
+	update_status(100, 100, NULL);
+	
+	check_shift_keys(1, "About to restore original kernel. ");
+
+	return 0;
+}
+
+int read_primary_suspend_image(char * specialfile, int noresume)
+{
+	union p_diskpage cur;
+	unsigned long scratch_page = 0;
+	int error, blksize = 0;
+
+	beepOK;
+	resume_device = name_to_kdev_t(specialfile);
+	scratch_page = get_zeroed_page(GFP_ATOMIC);
+	if (scratch_page) {
+		cur.address = scratch_page;
+		printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, name_resume "Resuming from device %x\n", resume_device);
+		
+		if (!blksize_size[MAJOR(resume_device)]) {
+			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "Blocksize not known?\n");
+		} else blksize = blksize_size[MAJOR(resume_device)][MINOR(resume_device)];
+		if (!blksize) {
+			printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, name_resume "Blocksize not set?\n");
+			blksize = PAGE_SIZE;
+		}
+		set_blocksize(resume_device, PAGE_SIZE);
+		error = __read_primary_suspend_image(cur, noresume);
+		free_page(scratch_page);
+	} else error = -ENOMEM;
+
+	switch (error) {
+		case 0:
+			beepOK;
+		case -EINVAL:	/* non fatal error */
+			set_blocksize(resume_device, blksize);
+			software_suspend_enabled = 1;
+			MDELAY(1000);
+			return(error);
+			break;
+		case -EIO:
+			printk(KERN_CRIT name_resume "I/O error\n");
+			beepERR;
+			break;
+		case -ENOENT:
+			printk(KERN_CRIT name_resume "%s: No such file or directory\n", specialfile);
+			break;
+		case -EPERM:
+			printk(KERN_CRIT name_resume "Sanity check error\n");
+			beepERR;
+			break;
+		default:
+			printk(KERN_CRIT name_resume "Error %d resuming\n", error);
+			beepERR;
+			break;
+	}
+	__read_primary_suspend_image(cur, 1); /* Try to fix the swap signature */
+	abort_suspend("Error %d in read_primary_suspend_image",error);
+	return(error);
+}
+
+int read_secondary_pagedir(int overwrittenpagesonly)
+{
+	int result = 0;
+
+	if (!pageset2_size)
+		return 0;
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "Beginning of read_secondary_pagedir: "); 
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,name_resume "Reading secondary pageset data (%d pages). Pagedir at %lx.\n", pageset2_size, (unsigned long) pagedir2.data);
+
+	result = read_pageset(&pagedir2, 2, overwrittenpagesonly);
+
+	update_status(100, 100, NULL);
+	check_shift_keys(1, "Pagedir 2 read. ");
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,"\n");
+	return result;
+}
+
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/low_level_io.c m1/kernel/suspend/low_level_io.c
--- m2/kernel/suspend/low_level_io.c	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/low_level_io.c	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,930 @@
+/*
+ * linux/drivers/swsusp/io.c
+ *
+ * This file contains IO routines for swsusp.
+ *
+ */
+
+#define SWSUSP_LOWLEVEL_IO_C
+
+#include "common.h"
+
+extern int max_async_ios;
+
+/* Exported variables */
+struct page * last_suspend_cache_page;	/* Pointer to the last cache page */
+
+#define BUFFER_BUSY_BITS ((1<<BH_Dirty) | (1<<BH_Lock))
+#define buffer_busy(bh)	(atomic_read(&(bh)->b_count) | \
+			((bh)->b_state & BUFFER_BUSY_BITS))
+
+#define BREAD_BUFFER_HEAD(dev, pos) \
+	bh = bread(dev, pos, PAGE_SIZE); \
+	if (!bh || (!bh->b_data)) { \
+		return -EIO; \
+	}
+
+#define BFREE(bh) \
+	if (!buffer_busy(bh)) \
+		try_to_free_buffers(bh->b_page, __GFP_FAST); \
+	free_suspend_cache_page(last_suspend_cache_page); \
+	last_suspend_cache_page = NULL;
+
+#define PANIC(f, a...) 	panic(f, ## a) 
+
+struct io_info {
+	struct buffer_head * bh;
+	struct page * cache_page;
+	struct page * page;
+	char flags;
+	pte_t * pte;
+	int pageprot;
+	struct page * data_page;
+	swp_entry_t swap_address;
+	kdev_t dev;
+	int zones[PAGE_SIZE/512];
+	int zones_used;
+	int block_size;
+	struct io_info * next;
+};
+static struct io_info * io_info = NULL;
+static int infopages = 0;
+static int outstanding_io = 0;
+
+#define IO_IN_USE 0
+#define IO_WRITING 1
+#define IO_RESTORE_PAGE_PROT 2
+#define IO_AWAITING_READ 3
+#define IO_AWAITING_WRITE 4
+#define IO_CLEANUP_IN_PROGRESS 5
+#define IO_HANDLE_PAGE_PROT 6
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+extern unsigned long pagechecksum(struct page * page);
+extern unsigned long checkpagecopy;
+extern unsigned long checkpage;
+#endif
+
+/*
+ * This is our sync function. With this solution we probably won't sleep
+ * but that should not be a problem since tasks are stopped..
+ */
+
+void do_suspend_sync(void)
+{
+	while (1) {
+		run_task_queue(&tq_disk);
+		if (!TQ_ACTIVE(tq_disk))
+			break;
+		printk(KERN_ERR "Hm, tq_disk is not empty after run_task_queue\n");
+	}
+}
+
+/* We memorize in swapfile_used what swap devices are used for suspension */
+#define SWAPFILE_UNUSED    0
+#define SWAPFILE_SUSPEND   1	/* This is the suspending device */
+#define SWAPFILE_IGNORED   2	/* Those are other swap devices ignored for suspension */
+
+static unsigned short swapfile_used[MAX_SWAPFILES];
+static unsigned short root_swap;
+
+static int swsusp_writepage(struct page *page);
+
+static inline int sync_page(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+
+	if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
+		return mapping->a_ops->sync_page(page);
+	return 0;
+}
+
+static struct address_space_operations swsusp_aops = {
+	writepage: swsusp_writepage,
+	sync_page: block_sync_page,
+};
+
+struct address_space swsusp_space = {
+	LIST_HEAD_INIT(swsusp_space.clean_pages),
+	LIST_HEAD_INIT(swsusp_space.dirty_pages),
+	LIST_HEAD_INIT(swsusp_space.locked_pages),
+	0,				/* nrpages	*/
+	&swsusp_aops,
+};
+
+int get_phys_params(struct pbe * pbe)
+{
+	unsigned long offset;
+	struct inode *swapf = 0;
+
+	get_swaphandle_info(pbe->swap_address, &offset, &pbe->swap_bdev, &swapf);
+	if (pbe->swap_bdev) {
+		pbe->block = offset;
+		/* We are assuming this.
+		io_info->zones_used = 1;
+		io_info->block_size = PAGE_SIZE;
+		*/
+	} else if (swapf) {
+#if 0
+		int i, j;
+		unsigned int block = offset
+			<< (PAGE_SHIFT - swapf->i_sb->s_blocksize_bits);
+#endif
+		if (swapf->i_sb->s_blocksize != PAGE_SIZE) {
+			abort_suspend("Get_phys_params: Error! Blocksize (%d) is not pagesize!", swapf->i_sb->s_blocksize);
+			return 0;
+		}
+		if (!(pbe->block = bmap(swapf,0))) {
+			abort_suspend("Get_phys_params: bad swap file!");
+			return 0;
+		}
+#if 0
+		io_info->block_size = swapf->i_sb->s_blocksize;
+		for (i=0, j=0; j< PAGE_SIZE ; i++, j += io_info->block_size)
+			if (!(io_info->zones[i] = bmap(swapf,block++))) {
+				abort_suspend("get_phys_params: bad swap file");
+				return 0;
+			}
+		io_info->zones_used = i;
+		io_info->dev = swapf->i_dev;
+		check_shift_keys(1, "Using swapfile entry %lx -> %lx + %lx\n",
+				pbe->swap_address,
+				pbe->swap_bdev,
+				pbe->block);
+		block_dump = 1;
+#endif
+	} else {
+		return 0;
+	}
+
+	return 1;
+}
+
+int get_brw_params(struct io_info * io_info)
+{
+	unsigned long offset;
+	struct inode *swapf = 0;
+
+	get_swaphandle_info(io_info->swap_address, &offset, &io_info->dev, &swapf);
+	if (io_info->dev) {
+		io_info->zones[0] = offset;
+		io_info->zones_used = 1;
+		io_info->block_size = PAGE_SIZE;
+	} else if (swapf) {
+		int i, j;
+		unsigned int block = offset
+			<< (PAGE_SHIFT - swapf->i_sb->s_blocksize_bits);
+
+		io_info->block_size = swapf->i_sb->s_blocksize;
+		for (i=0, j=0; j< PAGE_SIZE ; i++, j += io_info->block_size)
+			if (!(io_info->zones[i] = bmap(swapf,block++))) {
+				abort_suspend("get_brw_params: bad swap file");
+				return 0;
+			}
+		io_info->zones_used = i;
+		io_info->dev = swapf->i_dev;
+	} else {
+		return 0;
+	}
+
+	return 1;
+}
+
+extern void end_buffer_io_sync(struct buffer_head * bh, int uptodate);
+
+void cleanup_write_swsusp_page_async(struct io_info * io_info)
+{
+	struct buffer_head *bh = io_info->bh;
+	struct page * page = bh->b_page;
+
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_HIGH, "Cleanup_write: [%p]\n", io_info);
+	if (test_and_set_bit(IO_CLEANUP_IN_PROGRESS, &io_info->flags))
+		return;
+
+	TryLockPage(page); /* Ensure it's locked */
+
+	if (!block_flushpage(page, 0))
+		PAGE_BUG(page);
+	
+	page->mapping = NULL;
+	page->index = 0;
+	UnlockPage(page);
+
+	atomic_dec(&page->count);
+	__free_pages(page, 0);
+
+	outstanding_io--;
+	io_info->bh = NULL;
+	io_info->flags = 0;
+}
+
+void cleanup_read_swsusp_page_async(struct io_info * io_info)
+{
+	struct page *data_page = io_info->data_page, * bpage;
+	struct buffer_head * bh = io_info->bh;
+	pte_t * pte = NULL;
+	int pageprot = 0;
+	char * destaddress;
+	
+	if (test_and_set_bit(IO_CLEANUP_IN_PROGRESS, &io_info->flags))
+		return;
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_HIGH, "Cleanup_read: [%p:%p %p]", io_info, data_page, bh);
+	clear_bit(IO_RESTORE_PAGE_PROT, &io_info->flags);
+	
+	// Remove any page protection while we restore contents
+	if (test_bit(IO_HANDLE_PAGE_PROT, &io_info->flags)) {
+		pte = lookup_address((unsigned long) page_address(io_info->data_page));
+		printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "pte %p", pte);
+		if (pte) {
+			pageprot = pte->pte_low & ~_PAGE_CHG_MASK;
+			if (pageprot != pgprot_val(PAGE_KERNEL_NOCACHE)) {
+				set_pte(pte, pte_modify(*pte, PAGE_KERNEL_NOCACHE));	
+				set_bit(IO_RESTORE_PAGE_PROT, &io_info->flags);
+			}
+		}
+	}
+	io_info->pte = pte;
+	io_info->pageprot = pageprot;
+	
+	destaddress=kmap(data_page);
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "destaddr: %p", destaddress);
+	memcpy(destaddress, bh->b_data, PAGE_SIZE);
+	flush_dcache_page(data_page);
+	kunmap(data_page);
+
+	if (test_bit(IO_RESTORE_PAGE_PROT, &io_info->flags))
+		set_pte(io_info->pte, pte_modify(*(io_info->pte), __pgprot(io_info->pageprot)));
+
+	put_bh(bh);
+	brelse(bh);
+	bpage = bh->b_page;
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "bpage: %p", bpage);
+
+	if (!buffer_busy(bh))
+		try_to_free_buffers(bpage, __GFP_FAST);
+	free_suspend_cache_page(io_info->cache_page);
+	io_info->cache_page = NULL;
+
+	io_info->bh = NULL;
+	io_info->flags = 0;
+	outstanding_io--;
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_HIGH, "\n");
+}
+
+int swsusp_brw_page(int rw, struct page *page, kdev_t dev, int b[], int size)
+{
+	struct buffer_head *head, *bh;
+
+	if (!PageLocked(page))
+		panic("swsusp_brw_page: page not locked for I/O");
+
+	if (!page->buffers)
+ 		create_empty_buffers(page, dev, size);
+
+	head = bh = page->buffers;
+
+	do {
+		lock_buffer(bh);
+		bh->b_blocknr = *(b++);
+		if (rw == WRITE)
+			__mark_buffer_dirty(bh);
+		set_bit(BH_Mapped, &bh->b_state);
+		set_bit(BH_Uptodate, &bh->b_state) ;
+		set_buffer_async_io(bh);
+		bh = bh->b_this_page;
+	} while (bh != head);
+
+	do {
+		struct buffer_head *next = bh->b_this_page;
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUMS
+		if ((unsigned long) page_address(page) == checkpagecopy)
+			printk(KERN_ERR "Page checksum in swsusp_brw_page is %lx.\n",
+				pagechecksum(page));
+#endif
+		submit_bh(rw, bh);
+		bh = next;
+	} while (bh != head);
+
+	return 0;
+}
+
+void cleanup_finished_swsusp_io(void)
+{
+	struct io_info * this = io_info, * firstfree = NULL;
+
+	this = io_info;
+	firstfree = NULL;
+	
+	/* We clean up all we can at once so we don't only batch the first lot */
+	while (this) {
+		if ((this->bh) && (this->bh->b_page) && (!buffer_locked(this->bh)) && (!PageLocked(this->bh->b_page))) {
+			if (test_bit(IO_AWAITING_READ, &this->flags)) 
+				cleanup_read_swsusp_page_async(this);
+			else if (test_bit(IO_AWAITING_WRITE, &this->flags))
+				cleanup_write_swsusp_page_async(this);
+		}
+		if ((!test_bit(IO_IN_USE, &this->flags)) && (!firstfree))
+				firstfree = this;
+		this = this->next;
+	}
+}
+
+static struct io_info * get_io_info_struct(void)
+{
+	struct io_info * this = io_info, * last = NULL, * firstfree = NULL;
+	unsigned long newpage = 0;
+	int iteration = 0;
+
+try_again:
+	this = io_info;
+	last = NULL;
+	firstfree = NULL;
+	if (!(iteration%8))
+		run_task_queue(&tq_disk);
+	iteration++;
+	
+	/* We clean up all we can at once so we don't only batch the first lot */
+	while (this) {
+		if ((this->bh) && (this->bh->b_page) && (!buffer_locked(this->bh)) && (!PageLocked(this->bh->b_page))) {
+			if (test_bit(IO_AWAITING_READ, &this->flags)) 
+				cleanup_read_swsusp_page_async(this);
+			else if (test_bit(IO_AWAITING_WRITE, &this->flags))
+				cleanup_write_swsusp_page_async(this);
+		}
+		if ((!test_bit(IO_IN_USE, &this->flags)) && (!firstfree)) 
+			firstfree = this;
+		last = this;
+		this = this->next;
+	}
+
+	if ((max_async_ios) && (outstanding_io >= max_async_ios))
+		goto try_again;
+
+	if (firstfree) {
+		this = firstfree;
+		goto finish;
+	}
+
+	/* If not, is there more space in the page already allocated? */
+	if (last) {
+		int remaining = PAGE_SIZE - ((unsigned long) last & ~PAGE_MASK) - sizeof(struct io_info);
+		if (remaining >= (sizeof(struct io_info))) {
+			this = (struct io_info *) ((unsigned long) last + sizeof(struct io_info));
+			last->next = this;
+			this->next=NULL;
+			goto finish;
+		}
+	}
+
+	/* Need to allocate a new page */
+	newpage = get_zeroed_page(GFP_ATOMIC);
+	printlog(SUSPEND_MEMORY, SUSPEND_VERBOSE, "[NewIOPage %lx]", newpage);
+	if (!newpage)
+		goto try_again;
+	infopages++;
+	this = (struct io_info *) newpage;
+	this->next = NULL;
+	SetPageNosave(virt_to_page(newpage));
+	if (last)
+		last->next = this;
+	else
+		io_info = this;
+finish:
+	if (test_and_set_bit(IO_IN_USE, &this->flags))
+		goto try_again;
+	return this;
+}
+
+/*
+ * Returns zero when no io_info structs left.
+ */
+static int free_io_info_structs(void)
+{
+	struct io_info * this = io_info, * last = NULL, * pageprev = NULL;
+	unsigned long pageaddress = 0;
+	int pageused = 0, numleft = 0;
+
+	pageaddress = (unsigned long) this;
+	while (this) {
+		do { /* Forward at least one */
+			if ((this->bh) && (this->bh->b_page) && (!buffer_locked(this->bh)) && (!PageLocked(this->bh->b_page))) {
+				if (test_bit(IO_AWAITING_READ, &this->flags)) 
+					cleanup_read_swsusp_page_async(this);
+				else if (test_bit(IO_AWAITING_WRITE, &this->flags))
+					cleanup_write_swsusp_page_async(this);
+			}
+			if (test_bit(IO_IN_USE, &this->flags)) {
+				pageused = 1;
+				numleft++;
+			}
+			last = this;
+			this = this->next;
+		} while ((this) && (pageused) && ((((unsigned long) this) & PAGE_MASK) == pageaddress)); 
+		if ((((unsigned long) this) & PAGE_MASK) != pageaddress) { /* At start of new page? */
+			if (!pageused && (!in_interrupt())) {
+				if (!pageprev) {
+					io_info = this;
+				}
+				else
+					pageprev->next = this;
+				ClearPageNosave(virt_to_page(pageaddress));
+				free_pages(pageaddress, 0);
+				infopages--;
+			} else
+				pageprev = last;
+			pageaddress = (unsigned long) this;
+		}
+	}
+	return numleft;
+}
+
+void __inline reset_io_stats(void)
+{
+	outstanding_io = 0;
+	infopages = 0;
+}
+
+void check_io_stats(void)
+{
+	if (outstanding_io)
+		printlog(SUSPEND_MEMORY, SUSPEND_ERROR, "Outstanding_io after writing is %d.\n", outstanding_io);
+	if (infopages)
+		printlog(SUSPEND_MEMORY, SUSPEND_ERROR, "Info pages is %d.\n", infopages);
+}
+
+void sync_swap_partitions(void)
+{
+	int i;
+	
+	swap_list_lock();
+	for(i=0; i<MAX_SWAPFILES; i++) {
+		if (swapfile_used[i] == SWAPFILE_SUSPEND) {
+			sync_buffers(swap_info[i].swap_device, 2);
+		}
+	}
+	swap_list_unlock();
+}
+
+void finish_all_io(void)
+{
+	int numleft;
+
+	check_shift_keys(0, NULL);
+	while ((numleft = free_io_info_structs())) {
+		sync_swap_partitions();
+		do_suspend_sync();
+	}
+}
+
+static int swsusp_writepage(struct page *page)
+{
+	struct io_info * io_info = (struct io_info *) page->index;
+	
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, "Writepage %p.", page);
+#if 1
+	if (remove_exclusive_swap_page(page)) {
+		printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, "Unlocking page %p. (1)", page);
+		UnlockPage(page);
+		return 0;
+	}
+#endif
+	get_brw_params(io_info);
+ 	swsusp_brw_page(WRITE, page, io_info->dev, io_info->zones, io_info->block_size);
+	return 0;
+}
+
+static int start_write_swsusp_page_async(swp_entry_t swap_address, struct page * data_page)
+{
+	struct io_info * io_info = get_io_info_struct();
+	unsigned long buffer_virt;
+	char * to, * from;
+	struct page * buffer_page;
+
+	if (!io_info)
+		return 1;
+
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_HIGH, "Start_write: [%p]", io_info);
+	while (!(buffer_virt = get_zeroed_page(GFP_ATOMIC)))
+		cleanup_finished_swsusp_io();
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, "[WRITE BUFFER]->%d", nr_free_pages());
+	buffer_page = virt_to_page(buffer_virt);
+	
+	io_info->swap_address = swap_address;
+	io_info->data_page = data_page;
+	io_info->page = buffer_page;
+
+	set_bit(IO_WRITING, &io_info->flags);
+
+	to = (char *) buffer_virt;
+	from = kmap(data_page);
+	memcpy(to, from, PAGE_SIZE);
+	flush_dcache_page(data_page);
+	flush_dcache_page(buffer_page);
+	kunmap(data_page);
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	if (from == (char *) checkpagecopy)
+		printk(KERN_ERR "Page checksum for copy of page %lx (%p) is %lx. For buffer (%p) it is %lx.\n",
+			checkpage,
+			data_page,
+			pagechecksum(data_page),
+			buffer_page,
+			pagechecksum(buffer_page));
+#endif
+
+	atomic_inc(&buffer_page->count);
+	lock_page(buffer_page);
+
+	BUG_ON(buffer_page->mapping);
+	buffer_page->mapping = &swsusp_space;
+	buffer_page->index = (unsigned long) io_info;
+
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_VERBOSE, "-> (PRE BRW) %d\n", nr_free_pages());
+	get_brw_params(io_info);
+ 	swsusp_brw_page(WRITE, buffer_page, io_info->dev, io_info->zones, io_info->block_size);
+	
+	io_info->bh = buffer_page->buffers;
+	io_info->cache_page = last_suspend_cache_page;
+	last_suspend_cache_page = NULL;
+	
+	set_bit(IO_AWAITING_WRITE, &io_info->flags);
+	outstanding_io++;
+
+	return 0;
+}
+	
+static int start_read_async(kdev_t bdev, long pos, struct page * data_page)
+{
+	struct io_info * io_info = get_io_info_struct();
+	struct buffer_head *bh = NULL;
+	unsigned int major;
+	int correct_size;
+	unsigned long flags;
+
+	if (!io_info)
+		return 1;
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_HIGH, "Start_read: [%p]", io_info);
+
+	io_info->data_page = data_page;
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, " {%x %lx <-> %p ", bdev, pos, data_page);
+ 	bh = getblk(bdev, pos, PAGE_SIZE);
+	
+	io_info->bh = bh;
+	
+	flags = bh->b_page->flags & ~(1 << BH_Uptodate | 1 << BH_Dirty);
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "via %p/%p ", io_info, bh->b_page);
+	bh->b_page->index = (unsigned long) io_info;
+	
+	major = MAJOR(bdev);
+
+	/* Determine correct block size for this device. */
+	correct_size = get_hardsect_size(bdev);
+
+	/* Verify requested block sizes. */
+	if (bh->b_size % correct_size) {
+		printk(KERN_EMERG "start_read_swsusp_page: device %s: "
+		       "only %d-char blocks implemented (%u)\n",
+		       kdevname(bdev),
+		       correct_size, bh->b_size);
+		goto sorry;
+	}
+
+	lock_buffer(bh);
+	atomic_inc(&bh->b_count);
+	set_buffer_async_io(bh);
+	atomic_set_buffer_clean(bh);
+	__mark_buffer_clean(bh);
+	
+	lock_page(bh->b_page);
+
+	submit_bh(READ, bh);
+
+	if (last_suspend_cache_page)
+		io_info->cache_page = last_suspend_cache_page;
+	else
+		io_info->cache_page = 0;
+	last_suspend_cache_page = NULL;
+
+	set_bit(IO_AWAITING_READ, &io_info->flags);
+	outstanding_io++;
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_HIGH, "\n");
+
+	return 0;
+
+sorry:
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR, "Start_read: Sorry!\n");
+	/* Make sure we don't get infinite dirty retries.. */
+	mark_buffer_clean(bh);
+
+	clear_bit(IO_AWAITING_READ, &io_info->flags);
+
+	return -EIO;
+}
+
+/*
+ * swsusp_rw_swap_page:
+ * Based on __rw_swap_page_nolock.
+ * Asynchronously reads or writes a page to swap.
+ * Used to read/write swap header.
+ */
+void swsusp_rw_swap_page(int rw, struct pbe * pbe)
+{
+	struct page * page = pbe->address, * cache_page;
+	swp_entry_t entry = pbe->swap_address;
+
+	atomic_inc(&page->count);
+	lock_page(page);
+	if (page->mapping)
+		PAGE_BUG(page);
+
+	/* needs sync_page to wait I/O completation */
+	page->mapping = &swapper_space;
+	last_suspend_cache_page = NULL;
+
+	if (rw_swap_page_base(rw, entry, page))
+		lock_page(page);
+	
+	if (!block_flushpage(page, 0))
+		PAGE_BUG(page);
+	page->mapping = NULL;
+	UnlockPage(page);
+
+	if (last_suspend_cache_page)
+		cache_page = last_suspend_cache_page;
+	else
+		cache_page = 0;
+
+	sync_page(page);
+	if ((rw == READ) && (cache_page))
+		free_suspend_cache_page(cache_page);
+	atomic_dec(&page->count);
+}
+
+void read_swapfiles(void) /* This is called before saving image */
+{
+	int i, len;
+	
+	len=strlen(resume_file);
+	root_swap = 0xFFFF;
+	
+	swap_list_lock();
+	for(i=0; i<MAX_SWAPFILES; i++) {
+		if (swap_info[i].flags == 0) {
+			swapfile_used[i]=SWAPFILE_UNUSED;
+		} else {
+			if (!len) {
+	    			printk(KERN_ERR "resume= option should be used to set suspend device" );
+				if (root_swap == 0xFFFF) {
+					swapfile_used[i] = SWAPFILE_SUSPEND;
+					root_swap = i;
+				} else
+					swapfile_used[i] = SWAPFILE_IGNORED;				  
+			} else {
+	  			/* we ignore all swap devices that are not the resume_file */
+				if (resume_device == swap_info[i].swap_device) {
+					swapfile_used[i] = SWAPFILE_SUSPEND;
+					root_swap = i;
+				} else {
+				  	swapfile_used[i] = SWAPFILE_IGNORED;
+				}
+			}
+		}
+	}
+	swap_list_unlock();
+}
+
+/*
+ * mark_swapfiles:
+ * Change the swapfile signature as appropriate.
+ */
+
+void mark_swapfiles(swp_entry_t prev, int mode)
+{
+	struct pbe pbe;
+	char * signature;
+	unsigned long pageaddress;
+
+	PRINTFREEMEM("at start of mark_swapfiles");
+	
+	pageaddress = get_zeroed_page(GFP_ATOMIC);
+	pbe.address = virt_to_page(pageaddress);
+	signature = ((union p_diskpage) pageaddress).pointer->swh.magic.magic;
+
+	pbe.swap_address = SWP_ENTRY(root_swap, 0);
+	swsusp_rw_swap_page(READ, &pbe); 
+
+	switch(mode) {
+	case MARK_SWAP_RESUME:
+		if (!memcmp("1R",signature,2))
+			memcpy(signature,"SWAP-SPACE",10);
+		else if (!memcmp("2R",signature,2))
+			memcpy(signature,"SWAPSPACE2",10);
+		else printk(KERN_ERR name_resume "Unable to find suspended-data signature (%.10s - misspelled?\n", signature);
+		break;
+	case MARK_SWAP_RECOVER:
+		if (!memcmp("1R",signature,2))
+			memcpy(signature,"SWAP-SPACE",10);
+		else if (!memcmp("2R",signature,2))
+			memcpy(signature,"SWAPSPACE2",10);
+	  	else if ((!memcmp("SWAP-SPACE",signature,10))
+			 &&(!memcmp("SWAPSPACE2",signature,10))) {
+			abort_suspend("\nSwapspace is altered (%.10s)\n", signature);
+			free_pages(pageaddress, 0);
+			return;
+		}
+		break;
+	case MARK_SWAP_SUSPEND:
+		printk(KERN_ERR "Signature is %.10s\n", signature);
+	  	if ((!memcmp("SWAP-SPACE",signature,10)))
+		  	memcpy(signature,"1R",2);
+		else if ((!memcmp("SWAPSPACE2",signature,10)))
+			memcpy(signature,"2R",2);
+		else {
+			abort_suspend("\nSwapspace is not swapspace (%.10s)\n", signature);
+			free_pages(pageaddress, 0);
+			return;
+		}
+
+		/* Put bdev of suspend header in swap header (unsigned short) */
+		{
+			kdev_t * header_ptr = (kdev_t *) (&(signature[2]));
+			*header_ptr = swap_info[SWP_TYPE(prev)].swap_device;
+		}
+		((union p_diskpage) pageaddress).pointer->link.next = prev; /* prev is the first/last swap page of the resume area */
+		/* link.next lies in last 4 bytes of magic */
+		break;
+	}
+	flush_dcache_page(virt_to_page(pageaddress)) ;
+	swsusp_rw_swap_page(WRITE, &pbe);
+	PRINTFREEMEM("before freeing pbe page in mark_swapfiles");
+	free_pages(pageaddress, 0);
+	PRINTFREEMEM("after freeing pbe page in mark_swapfiles");
+	sync_swap_partitions();
+	do_suspend_sync();
+}
+
+int bdev_read_page(kdev_t bdev, long pos, struct page * page)
+{
+	struct buffer_head *bh;
+	char * destaddress;
+	BREAD_BUFFER_HEAD(bdev, pos);
+	destaddress = kmap(page);
+	memcpy(destaddress, bh->b_data, PAGE_SIZE);
+	flush_dcache_page(page) ;
+	kunmap(page);
+	if (!buffer_uptodate(bh)) {
+		abort_suspend("buffer_uptodate false in bdev_read_page!\n");
+		brelse(bh);
+		BFREE(bh);
+		return -1;
+	}
+	brelse(bh);
+	BFREE(bh);
+	return 0;
+} 
+
+static int rw_swap_page_sync(int rw, swp_entry_t swap_address, struct page * data_page)
+{
+	struct io_info io_info;
+	unsigned long buffer_address = get_zeroed_page(__GFP_FAST);
+	struct page *page = virt_to_page(buffer_address);
+	void * pageaddress;
+	pte_t * pte;
+	int pageprot = 0;
+	int restore = 0;
+
+	io_info.page = page;
+
+	atomic_inc(&page->count);
+	atomic_inc(&page->count);
+	lock_page(page);
+
+	BUG_ON(page->mapping);
+	page->mapping = &swapper_space;
+
+	if (rw == WRITE) {
+		pageaddress = kmap(data_page);
+		memcpy((char *) buffer_address, (char *) pageaddress, PAGE_SIZE);
+		flush_dcache_page(data_page) ;
+		kunmap(data_page);
+	}
+
+	if (rw_swap_page_base(rw, swap_address, page))
+		lock_page(page);
+
+	if (last_suspend_cache_page)
+		io_info.cache_page = last_suspend_cache_page;
+	else
+		io_info.cache_page = 0;
+	last_suspend_cache_page = NULL;
+
+	if (rw == WRITE) {
+		if (!block_flushpage(page, 0))
+			PAGE_BUG(page);
+	}
+	sync_page(page);
+
+	page->mapping = NULL;
+	UnlockPage(page);
+
+	if (rw == READ) {
+		pageaddress = kmap(data_page);
+
+		// Remove any page protection while we restore contents
+		pte = lookup_address((unsigned long) pageaddress);
+		if (pte) {
+			pageprot = pte->pte_low & ~_PAGE_CHG_MASK;
+			if (pageprot != pgprot_val(PAGE_KERNEL_NOCACHE)) {
+				set_pte(pte, pte_modify(*pte, PAGE_KERNEL_NOCACHE));	
+				restore = 1;
+			}
+		}
+		
+		memcpy((char *) pageaddress, (char *) buffer_address, PAGE_SIZE);
+		flush_dcache_page(virt_to_page(data_page));
+
+		if (restore)
+			set_pte(pte, pte_modify(*(pte), __pgprot(pageprot)));
+
+		kunmap(data_page);
+	}
+
+	if ((rw == READ) && (io_info.cache_page))
+		free_suspend_cache_page(io_info.cache_page);
+	atomic_dec(&page->count);
+	atomic_dec(&page->count);
+	free_pages(buffer_address, 0);
+
+	return 0;
+}
+
+int bdev_read_swap(struct pbe * pbe, int asyncio)
+{
+#if 0
+	kdev_t bdev = swap_info[SWP_TYPE(pbe->swap_address)].swap_device;
+	int pos = SWP_OFFSET(pbe->swap_address); 
+#endif
+	if ((TEST_ACTION_STATE(SUSPEND_NO_ASYNC_READS)) || (!asyncio))
+		return bdev_read_page(pbe->swap_bdev, pbe->block, pbe->address);
+	else
+		return start_read_async(pbe->swap_bdev, pbe->block, pbe->address);
+} 
+
+int write_swap_page(swp_entry_t posn, struct page * page, int asyncio)
+{
+	if ((TEST_ACTION_STATE(SUSPEND_NO_ASYNC_WRITES)) || (!asyncio))
+		return rw_swap_page_sync(WRITE, posn, page);
+	else
+		return start_write_swsusp_page_async(posn, page);
+} 
+
+int noresume_fix_signature(union p_diskpage cur)
+{
+	/* 
+	 * We don't do a sanity check here: we want to restore the swap 
+	 * whatever version of kernel made the suspend image
+	 */
+	struct buffer_head *bh;
+	printk(name_resume "%s: Fixing swap signatures...\n", resume_file);
+				/* We need to write swap, but swap is *not* enabled so
+				   we must write the device directly */
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_VERBOSE,"Swap signature will be set to %10s\n",cur.pointer->swh.magic.magic);
+	BREAD_BUFFER_HEAD(resume_device, 0);
+	if (is_read_only(bh->b_dev)) {
+		printk(KERN_ERR name_resume "Can't write to read-only device %s\n",
+		       kdevname(bh->b_dev));
+		BFREE(bh);
+		return -EIO;
+	}
+	
+	//flush_dcache_page(virt_to_page(bh->b_data));
+	memcpy(bh->b_data, cur.ptr, PAGE_SIZE);
+	//generic_make_request(WRITE, bh);
+	mark_buffer_dirty(bh);
+	ll_rw_block(WRITE, 1, &bh);
+	wait_on_buffer(bh);
+	sync_swap_partitions();
+	do_suspend_sync();
+	if (buffer_uptodate(bh)) {
+		brelse(bh);
+		BFREE(bh);
+#if 0
+		//free_suspend_cache_page(last_suspend_cache_page);
+		/* As with fix_signature, try to read to ensure its written. */
+		BREAD_BUFFER_HEAD(resume_device, 0);
+		brelse(bh);
+		BFREE(bh);
+#endif
+		return 0;
+	}
+	printk(name_resume "Warning %s: Fixing swap signatures unsuccessful...\n", resume_file);
+	bforget(bh);
+	BFREE(bh);
+	return -EINVAL;		/* non fatal error */
+}
+
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/main.c m1/kernel/suspend/main.c
--- m2/kernel/suspend/main.c	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/main.c	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,1162 @@
+/*
+ * linux/kernel/suspend.c
+ *
+ * This file is to realize architecture-independent
+ * machine suspend feature using pretty near only high-level routines
+ *
+ * Copyright (C) 1998-2001 Gabor Kuti <seasons@fornax.hu>
+ * Copyright (C) 1998,2001,2002 Pavel Machek <pavel@suse.cz>
+ * Copyright (C) 2002-2003 Florent Chabaud <fchabaud@free.fr>
+ * Copyright (C) 2002-2003 Nigel Cunningham <ncunningham@clear.net.nz>
+ *
+ * We'd like to thank the following people for their work:
+ * 
+ * Pavel Machek <pavel@ucw.cz>:
+ * Modifications, defectiveness pointing, being with me at the very beginning,
+ * suspend to swap space, stop all tasks. Port to 2.4.18-ac and 2.5.17.
+ *
+ * Steve Doddi <dirk@loth.demon.co.uk>: 
+ * Support the possibility of hardware state restoring.
+ *
+ * Raph <grey.havens@earthling.net>:
+ * Support for preserving states of network devices and virtual console
+ * (including X and svgatextmode)
+ *
+ * Kurt Garloff <garloff@suse.de>:
+ * Straightened the critical function in order to prevent compilers from
+ * playing tricks with local variables.
+ *
+ * Andreas Mohr <a.mohr@mailto.de>
+ *
+ * Alex Badea <vampire@go.ro>:
+ * Fixed runaway init
+ *
+ * Jeff Snyder <je4d@pobox.com>
+ * ACPI patch
+ *
+ * Nathan Friess <natmanz@shaw.ca>
+ * Some patches.
+ *
+ * More state savers are welcome. Especially for the scsi layer...
+ *
+ * For TODOs,FIXMEs also look in Documentation/swsusp.txt
+ */
+
+#define SWSUSP_MAIN_C
+
+#include "common.h"
+#include <asm/i387.h> /* for kernel_fpu_end */
+
+unsigned char software_suspend_enabled = 0;
+unsigned int suspend_task = 0;
+unsigned int nr_suspends = 0;
+struct sysinfo swapinfo;
+
+/* Variables to be preserved over suspend */
+static int resume_status = 0;
+int pageset2_sizelow = 0;
+int expected_size1, expected_size2; 
+struct pagedir __nosavedata pagedir_nosave;
+
+static int pm_suspend_state = 0;
+int pagedir1_size = 0, pagedir2_size = 0;
+
+int swsusp_act_used = 0;
+int swsusp_lvl_used = 0;
+int swsusp_dbg_used = 0;
+
+int now_resuming = 0;
+char resume_file[256] = "";	/* For resume= kernel option */
+
+unsigned long orig_mem_free = 0;
+unsigned long base_mem_free = 0;
+unsigned long swapforimage = 0;
+int orig_loglevel = 0;
+
+static void ide_unsuspend(void);
+static void ide_suspend(void);
+static int drivers_suspend(void);
+static void drivers_resume(int);
+unsigned long * inusemap = NULL;
+unsigned long * pageset2map = NULL;
+unsigned long * pagedirmap = NULL;
+
+#ifdef DEFAULT_SUSPEND_CONSOLE
+extern void reset_terminal(int currcons, int do_clear);
+#endif
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+extern unsigned long checkpage;
+#endif
+
+kdev_t resume_device;
+
+/* Suspend pagedir is allocated before final copy, and saved with data
+ * as well as separately, so it can be used to load pageset2 at resume.
+ *
+ * At resume, the original pagedir is loaded as pagedir_nosave and then
+ * moved to a place where it doesn't collide with the data to be copied
+ * back. Then the data is read (again into spots that don't collide) and
+ * then copied back, giving us access to the saved pagedir again and
+ * forgetting the loaded pagedir at the same time. We then used the saved
+ * pagedir to load pageset2 (if necessary) before freeing that pagedir.
+ */
+
+struct pagedir pagedir1 = { 0, 0, 0, 0, NULL}, pagedir2 = {0, 0, 0, 0, NULL};
+
+unsigned long swsusp_debug_state = 0;
+int swsusp_default_console_level = 0;
+
+unsigned long swsusp_action = 0;
+unsigned long swsusp_result = 0;
+
+int image_size_limit = 0;
+int max_async_ios = 100;
+int currentbeep = 260;
+
+/* Locks */
+spinlock_t suspend_pagedir_lock __nosavedata = SPIN_LOCK_UNLOCKED;
+__nosavedata unsigned long pagedirflags;
+
+/* Pagedir.c */
+extern int calcpagedirsize(int size);
+extern pageset_sizes_t count_data_pages(int whichpagedir);
+extern int create_pagedir(struct pagedir * p, int pageset_size, int alloc_from);
+extern void copy_pageset1(void);
+extern int allocatemap(unsigned long ** pagemap, int setnosave);
+extern void show_checksum_errors(struct pagedir * p);
+extern void check_pagedir_checksums(struct pagedir * p, int at_orig_address);
+extern void free_pagedir(struct pagedir * p);
+extern int freemap(unsigned long ** pagemap);
+extern void store_pagedir_checksums(struct pagedir * p);
+
+/* Freeze_and_free.c */
+
+extern void recalculate_stats(int amount_eaten);
+extern void display_stats(unsigned int eaten);
+extern int eat_memory_and_freeze_processes(void);
+extern void free_grabbed_memory(void);
+
+/* proc.c */
+
+extern int swsusp_init_proc(void);
+extern int swsusp_cleanup_proc(void);
+
+__inline__ int fill_suspend_header(struct suspend_header *sh)
+{
+	int i;
+
+	memset((char *)sh, 0, sizeof(*sh));
+
+	sh->version_code = LINUX_VERSION_CODE;
+	sh->num_physpages = num_physpages;
+	sh->base_mem_free = orig_mem_free;
+	sh->swapforimage = swapforimage;
+	sh->expected_size1 = expected_size1;
+	sh->expected_size2 = expected_size2;
+	strncpy(sh->machine, system_utsname.machine, 65);
+	strncpy(sh->version, system_utsname.version, 65);
+	sh->num_cpus = smp_num_cpus;
+	sh->page_size = PAGE_SIZE;
+	sh->pagedir = pagedir1;
+	sh->param0 = swsusp_result;
+	sh->param1 = swsusp_action;
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+	sh->param2 = swsusp_debug_state;
+#endif
+	sh->param3 = console_loglevel;
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	sh->param4 = checkpage;
+#endif
+#if defined(CONFIG_FBCON_SPLASHSCREEN)
+	sh->progress0 = fb_splash_progress[0];
+	sh->progress1 = fb_splash_progress[1];
+	sh->progress2 = fb_splash_progress[2];
+	sh->progress3 = fb_splash_progress[3];
+	sh->progress4 = fb_splash_progress[4];
+#endif
+
+	/* Save kdevs so we can handle multiple swap files on resume */
+	for (i = 0; i < MAX_SWAPFILES; i++)
+		if (swap_info[i].swap_device) {
+			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "Swap device %d is %x.\n", i, swap_info[i].swap_device);
+			sh->kdevs[i] = swap_info[i].swap_device;
+		}
+
+	/* TODO: needed? mounted fs' last mounted date comparison
+	 * [so they haven't been mounted since last suspend.
+	 * Maybe it isn't.] [we'd need to do this for _all_ fs-es]
+	 */
+	return 0;
+}
+
+/* Make disk drivers accept operations, again */
+static void ide_unsuspend(void)
+{
+#ifdef CONFIG_BLK_DEV_IDE
+	ide_disk_unsuspend(0);
+#endif
+}
+
+static void ide_suspend(void)
+{
+#ifdef CONFIG_BLK_DEV_IDE
+	unsigned long flags;
+	
+	spin_lock_irqsave(&io_request_lock, flags);
+
+	do_suspend_sync();
+
+	ide_disk_suspend();
+	
+	spin_unlock_irqrestore(&io_request_lock, flags);
+#endif
+}
+
+#define RESUME_PHASE1 1 /* Called from interrupts disabled */
+#define RESUME_PHASE2 2 /* Called with interrupts enabled */
+#define RESUME_ALL_PHASES (RESUME_PHASE1 | RESUME_PHASE2)
+
+/* Called from process context */
+static int drivers_suspend(void)
+{
+#ifdef CONFIG_BLK_DEV_MD
+	md_notify_reboot(NULL, SYS_HALT, NULL);
+#endif
+	ide_suspend();
+	if (!pm_suspend_state) {
+		if (pm_send_all(PM_SUSPEND,(void *)3)) {
+			printk(name_suspend "Problem while sending suspend event\n");
+			drivers_resume(RESUME_ALL_PHASES);
+			return(1);
+		}
+		pm_suspend_state=1;
+	}
+	  
+	return(0);
+}
+
+void drivers_resume(int flags)
+{
+  	if(flags & RESUME_PHASE2) {
+#ifdef CONFIG_BLK_DEV_HD
+		do_reset_hd();			/* Kill all controller state */
+#endif
+	}
+  	if (flags & RESUME_PHASE1) {
+#ifdef CONFIG_BLK_DEV_IDE
+		ide_disk_unsuspend(1);		
+#endif
+#ifdef CONFIG_BLK_DEV_MD
+		md_autostart_arrays();
+#endif
+	}
+  	if (flags & RESUME_PHASE2) {
+		if (pm_suspend_state) {
+			if (pm_send_all(PM_RESUME,(void *)0))
+				printk(name_resume "Problem while sending resume event\n");
+			pm_suspend_state=0;
+		} else
+			printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, name_resume "PM suspend state wasn't raised\n");
+
+#ifdef DEFAULT_SUSPEND_CONSOLE
+		update_screen(fg_console);
+#endif
+	}
+}
+
+/*
+ * save_image
+ * Result code (int): Zero on success, non zero on failure.
+ * Functionality    : High level routine which performs the steps necessary
+ *                    to prepare and save the image after preparatory steps
+ *                    have been taken.
+ * Key Assumptions  : Processes frozen, sufficient memory available, drivers
+ *                    suspended.
+ * Called from      : do_magic_suspend_2
+ */
+static int save_image(void)
+{
+	pageset_sizes_t result;
+	int temp_result, alloc_from, i;
+
+	recalculate_stats(0);
+	display_stats(0);
+	
+	expected_size1 = pageset1_size;
+	expected_size2 = pageset2_size;
+
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED)) 
+		goto abort_saving;
+
+	if ((RAM_TO_SUSPEND > max_mapnr) || (RAM_TO_RESUME > max_mapnr)) {
+		printk(KERN_CRIT name_suspend "Couldn't get enough free pages, on %ld pages short\n",
+			 MAX(RAM_TO_RESUME, RAM_TO_SUSPEND) - max_mapnr);
+		prepare_status(1, 1, "Couldn't get enough free pages, on %ld pages short\n",
+			 MAX(RAM_TO_RESUME, RAM_TO_SUSPEND) - max_mapnr);
+		goto abort_saving;
+	}
+	if (swapinfo.freeswap < SWAP_NEEDED)  {
+		printk(KERN_CRIT name_suspend "There's not enough swap space available (%ld pages available, need %d)\n",
+			 swapinfo.freeswap, SWAP_NEEDED);
+		prepare_status(1, 1, "There's not enough swap space available (%ld pages available, need %d)\n",
+			 swapinfo.freeswap, SWAP_NEEDED);
+		SET_RESULT_STATE(SUSPEND_ABORTED);
+		SET_RESULT_STATE(SUSPEND_INSUFFICIENT_SWAP);
+		goto abort_saving;
+	}
+
+	swapforimage = swapinfo.freeswap;
+	
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Creating pagedir1 and allocating extra pages (if any)\n");
+
+	alloc_from = (pageset1_size > pageset2_sizelow ? pageset2_sizelow : pageset1_size);
+	
+	read_swapfiles();
+
+	ide_unsuspend();
+
+	if (create_pagedir(&pagedir1, pageset1_size, alloc_from))
+		goto abort_saving;
+
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Creating pagedir2\n");
+
+	if (create_pagedir(&pagedir2, pageset2_size, pageset2_size))
+		goto abort_saving;
+	
+	ide_suspend();
+
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Calling count_data_pages to set pageset addresses.\n");
+
+	result = count_data_pages(1);
+	
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+		goto abort_saving;
+
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"--  Result of count_data_pages: %d and %d\n", result.size1, result.size2);
+	pageset2_sizelow = result.size2low;
+	pageset2_size = result.size2;
+	pageset1_size = result.size1;
+	
+	{
+		int i, unsetstart = -1;
+		struct pbe * pbe = pagedir1.data;
+		for (i = 0; i < pageset1_size; i++) {
+			if (pbe->origaddress) {
+				if (unsetstart != -1) {
+					abort_suspend("----  Pagedir1 has unset original address entries from %d-%d.\n",
+							unsetstart, i);
+					unsetstart = -1;
+				}
+			} else {
+				if (unsetstart != -1)
+					unsetstart = i;
+			}
+			pbe = get_next_pbe(pbe);
+		}
+		
+		if (unsetstart != -1) 
+			abort_suspend("----  Pagedir1 has unset original address entries from %d-%d.\n",
+							unsetstart, i);
+		unsetstart = -1;
+		
+		pbe = pagedir1.data;
+		for (i = 0; i < pageset1_size; i++) {
+			if (pbe->address) {
+				if (unsetstart != -1) {
+					abort_suspend("----  Pagedir1 has unset destination address entries from %d-%d.\n",
+							unsetstart, i);
+					unsetstart = -1;
+				}
+			} else {
+				if (unsetstart != -1)
+					unsetstart = i;
+			}
+			pbe = get_next_pbe(pbe);
+		}
+		
+		if (unsetstart != -1) 
+			abort_suspend("----  Pagedir1 has unset entries from %d-%d.\n",
+							unsetstart, i);
+		unsetstart = -1;
+
+		pbe = pagedir2.data;
+		for (i = 0; i < pageset2_size; i++) {
+			if (pbe->address) {
+				if (unsetstart != -1) {
+					abort_suspend("----  Pagedir2 has unset destination address entries from %d-%d.\n",
+							unsetstart, i);
+					unsetstart = -1;
+				}
+			} else {
+				if (!unsetstart)
+					unsetstart = i;
+			}
+			pbe = get_next_pbe(pbe);
+		}
+		
+		if (unsetstart !=-1)
+			abort_suspend("----  Pagedir2 has unset desination addresses entries from %d-%d.\n",
+							unsetstart, i);
+	}
+
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+		goto abort_saving;
+
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Copying pageset2 destination addresses from 0 to %d\n", alloc_from - 1);
+
+	{
+		/* 
+		 * We know that we don't need to check that we have enough valid pagedir2
+		 * entries because this was handled above
+		 */
+
+		struct pbe * pbe1 = pagedir1.data;
+		struct pbe * pbe2 = pagedir2.data;
+		for(i=0; i < alloc_from; i++) {
+			while (PageHighMem(pbe2->address))
+				pbe2 = get_next_pbe(pbe2);
+			pbe1->address = pbe2->address;
+			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "   Entry %d: %lx", 
+					i, 
+					(unsigned long) pbe1->address);
+			pbe1 = get_next_pbe(pbe1);
+			pbe2 = get_next_pbe(pbe2);
+		}
+		printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 0, "\n");
+	}
+
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Actual values: %d and %d.\n", 
+			pageset1_size, 
+			pageset2_size);
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	store_pagedir_checksums(&pagedir2);
+#endif
+
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Preparing to write pages\n");
+
+	swsusp_spin_unlock_irqrestore(&suspend_pagedir_lock, pagedirflags); 
+
+	ide_unsuspend();
+
+	check_shift_keys(1, "About to write pagedir2. ");
+
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+		goto abort_saving;
+
+	temp_result = write_pageset(&pagedir2, 2);
+	
+	if (temp_result || TEST_RESULT_STATE(SUSPEND_ABORTED)) {
+		goto abort_saving;
+	}
+
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Written pageset2\n");
+	
+	check_shift_keys(1, "About to copy pageset 1. ");
+
+	ide_suspend();
+
+	prepare_status(1, 1,"Copying pageset1 & storing checksums");
+
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+		goto abort_saving;
+
+	drivers_suspend();
+
+	swsusp_spin_lock_irqsave(&suspend_pagedir_lock, pagedirflags); 
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	store_pagedir_checksums(&pagedir1);
+#endif
+
+	copy_pageset1();
+	
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Done\n");
+	
+	/*
+	 *  ---------------------   FROM HERE ON, NEED TO REREAD PAGESET2 IF ABORTING!!! -----------------
+	 *  (We need to ensure saved pages are freed even if memory is still correct).
+	 */
+	
+	swsusp_spin_unlock_irqrestore(&suspend_pagedir_lock, pagedirflags);
+	
+	ide_unsuspend();
+
+	check_shift_keys(1, "About to write pageset1. ");
+
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED))
+		goto abort_reloading_pagedir_two;
+
+	/*
+	 * End of critical section. From now on, we can write to memory,
+	 * but we should not touch disk. This specially means we must _not_
+	 * touch swap space! Except we must write out our image of course.
+	 *
+	 */
+	
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Writing pageset1\n");
+
+	temp_result = write_pageset(&pagedir1, 1);
+
+	if (temp_result || TEST_RESULT_STATE(SUSPEND_ABORTED))
+		goto abort_reloading_pagedir_two;
+
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"-- Done\n");
+
+	check_shift_keys(1, "About to write pagedir. ");
+
+	if (temp_result || (TEST_RESULT_STATE(SUSPEND_ABORTED)))
+		goto abort_reloading_pagedir_two;
+
+	temp_result = write_pagedir_and_suspend_header();
+
+	if (temp_result || (TEST_RESULT_STATE(SUSPEND_ABORTED)))
+		goto abort_reloading_pagedir_two;
+
+	si_swapinfo(&swapinfo);
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW, "Finished writing image. %ld pages of swap left.\n", swapinfo.freeswap);
+	ide_suspend();
+	return 0;
+
+abort_reloading_pagedir_two:
+	printk(KERN_ERR "Reloading secondary pagedir.\n");
+	temp_result = read_secondary_pagedir(1);
+	if (temp_result)
+		panic("Attempt to reload pagedir 2 while aborting a suspend failed.");
+abort_saving:
+	free_pagedir(&pagedir2);
+	free_pagedir(&pagedir1);
+
+	{
+		int was_locked = (spin_is_locked(&suspend_pagedir_lock));
+		if (was_locked)
+			swsusp_spin_unlock_irqrestore(&suspend_pagedir_lock, pagedirflags);
+	}
+
+	ide_suspend();
+	return -1;		
+
+}
+
+/*
+ * suspend_power_down
+ * Functionality   : Powers down or reboots the computer once the image
+ *                   has been written to disk.
+ * Key Assumptions : Able to reboot/power down via code called or that
+ *                   the warning emitted if the calls fail will be visible
+ *                   to the user (ie printk resumes devices).
+ * Called From     : do_magic_suspend_2
+ */
+
+extern void (*pm_power_off)(void);
+extern void swsusp_power_off(void);
+void suspend_power_down(void)
+{
+	C_A_D = 0;
+	/* No delay should be needed - ide_disk_suspend purges cache now */
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, name_suspend "Trying to power down.\n");
+	beepOK;			/* last beep */
+	prepare_status(1, 1, "Ready to power down.");
+#ifdef CONFIG_VT
+	if (TEST_ACTION_STATE(SUSPEND_REBOOT) ^ (!!(shift_state & (1 << KG_CTRL))))
+		machine_restart(NULL);
+	else
+#endif
+	{
+		if(!pm_power_off) {
+			pm_power_off=swsusp_power_off;
+			printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, name_suspend "Trying to use an apm bios call (you should enable apm or acpi)\n"); 
+		}
+		machine_power_off();
+	}
+
+	printk(KERN_EMERG name_suspend "Probably not capable for powerdown.\n");
+	machine_halt();
+	printk(KERN_EMERG name_suspend "System is now halted.\n");
+	while (1)
+		cpu_relax();
+	/* NOTREACHED */
+}
+
+/*
+ * do_magic_resume_1
+ * Functionality   : Preparatory steps for copying the original kernel back.
+ * Called From     : include/asm/suspend.h:do_suspend_lowlevel
+ */
+
+void do_magic_resume_1(void)
+{
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	if (console_loglevel >= SUSPEND_MEDIUM) {
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_MEDIUM, "Checking pagedir1 checksums...\n");
+		check_pagedir_checksums(&pagedir_nosave, 0);
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_MEDIUM, "(There should be no differences here.)\n");
+		show_checksum_errors(&pagedir1);
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_MEDIUM, "Done.");
+		check_shift_keys(1, "Completed checking pagedir. ");
+	}
+#endif
+
+	drivers_suspend();
+	barrier();
+	mb();
+	swsusp_spin_lock_irqsave(&suspend_pagedir_lock, pagedirflags);	/* Done to disable interrupts */ 
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW, name_resume "Waiting for DMAs to settle down...\n");
+	mdelay(1000);	/* We do not want some readahead with DMA to corrupt our memory, right?
+			   Do it with disabled interrupts for best effect. That way, if some
+			   driver scheduled DMA, we have good chance for DMA to finish ;-). */
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW, name_resume "About to copy pageset1 back...\n");
+}
+
+/*
+ * do_magic_resume_2
+ * Functionality   : Steps taken after copying back the original kernel at
+ *                   resume.
+ * Key Assumptions : Will be able to read back secondary pagedir (if 
+ *                   applicable).
+ * Called From     : include/asm/suspend.h:do_suspend_lowlevel
+ */
+
+inline void restore_processor_context (void);
+extern void unblank_screen(void);
+extern int console_blanked;
+
+void do_magic_resume_2(void)
+{
+
+	__flush_tlb_global();
+	
+#ifdef DEFAULT_SUSPEND_CONSOLE
+	reset_terminal(fg_console, 1);
+	update_screen(fg_console);
+	console_blanked = fg_console + 1;
+	unblank_screen();
+#endif
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	if (console_loglevel >= SUSPEND_MEDIUM) {
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_MEDIUM, "Checked pagedir1 checksums after copying the image back...\n");
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_MEDIUM, "(Remember that having a few differences here is normal and okay.)\n");
+		show_checksum_errors(&pagedir1);
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_MEDIUM, "Done.\n");
+		check_shift_keys(1, "Ready to read pageset 2 back. ");
+	}
+#endif
+
+	tainted |= 4; /* Taint the kernel because we have suspended */
+	now_resuming = 1;
+
+	ide_unsuspend();
+	
+	kernel_fpu_end();
+
+	read_secondary_pagedir(0);
+	
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	if (console_loglevel >= SUSPEND_MEDIUM) {
+		check_pagedir_checksums(&pagedir2, 1);
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_MEDIUM, "Checking pagedir2 checksums...\n");
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_MEDIUM, "(No differences should be found here.)\n");
+		show_checksum_errors(&pagedir2);
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_MEDIUM, "Done.\n");
+		check_shift_keys(1, "Ready to cleanup. ");
+	}
+
+#endif
+
+	prepare_status(0, 0, "Cleaning up...");
+	update_status(0, 100, NULL);
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_MEDIUM, name_resume "Freeing page directories.\n");
+	free_pagedir(&pagedir2);
+	update_status(25, 100, NULL);
+	free_pagedir(&pagedir1);
+	update_status(50, 100, NULL);
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_MEDIUM, name_resume "Free pagedir lock.\n");
+	swsusp_spin_unlock_irqrestore(&suspend_pagedir_lock, pagedirflags);
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_MEDIUM, name_resume "Resume drivers.\n");
+	drivers_resume(RESUME_ALL_PHASES);
+	update_status(75, 100, NULL);
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_MEDIUM, name_resume "Fixing swap signatures... ");
+	mark_swapfiles(((swp_entry_t) {0}), MARK_SWAP_RESUME);
+	update_status(100, 100, NULL);
+	schedule(); /* Give user time to see we do reach 100! */
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_MEDIUM, "ok\n");
+}
+
+/*
+ * do_magic_suspend_1
+ * Functionality   : Steps taken prior to saving CPU state and the image
+ *                   itself.
+ * Called From     : include/asm/suspend.h:do_suspend_lowlevel
+ */
+void do_magic_suspend_1(void)
+{
+	mb();
+	barrier();
+	swsusp_spin_lock_irqsave(&suspend_pagedir_lock, pagedirflags);
+}
+
+/*
+ * do_magic_suspend_2
+ * Functionality   : Steps taken after saving CPU state to save the
+ *                   image and powerdown/reboot or recover on failure.
+ * Key Assumptions : save_image returns zero on success; otherwise we need to
+ *                   clean up and exit. The state on exiting this routine 
+ *                   should be essentially the same as if we have suspended,
+ *                   resumed and reached the end of do_magic_resume_2.
+ * Called From     : include/asm/suspend.h:do_suspend_lowlevel
+ */
+void do_magic_suspend_2(void)
+{
+	if (!save_image())
+		suspend_power_down();
+	kernel_fpu_end();
+	
+	if (!TEST_RESULT_STATE(SUSPEND_ABORT_REQUESTED))
+		printk(KERN_EMERG name_suspend "Suspend failed, trying to recover...\n");
+	MDELAY(1000); /* So user can wait and report us messages if armageddon comes :-) */
+
+	barrier();
+	mb();
+	drivers_resume(RESUME_ALL_PHASES);
+	mark_swapfiles(((swp_entry_t) {0}), MARK_SWAP_RECOVER);
+}
+
+/*
+ * display_debug_info
+ * Functionality   : At the end of resuming, displays information that may be
+ *                   helpful in debugging software suspend.
+ * Called From     : do_software_suspend
+ */
+static void display_debug_info(void)
+{
+	si_swapinfo(&swapinfo);
+	printk("\n\nPlease include the following information in any bug report:\n");
+	printk("- SWSUSP Version : %s\n", swsusp_version);
+	printk("- Compiler vers. : %d.%d\n", __GNUC__, __GNUC_MINOR__);
+	printk("- Attempt number : %d\n", nr_suspends);
+	printk("- Swap available : %ld (amount unused when preparing image).\n", swapforimage);
+	printk("- Pageset sizes  : %d and %d (%d low). (Pagedir sizes: %d and %d)\n", pageset1_size, pageset2_size,
+			pageset2_sizelow,
+			calcpagedirsize(pageset1_size), calcpagedirsize(pageset2_size));
+	printk("- Expected sizes : %d and %d.\n", expected_size1, expected_size2);
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+	printk("- Parameters     : %ld %ld %ld %d %d\n", swsusp_result, swsusp_action, swsusp_debug_state, image_size_limit, max_async_ios);
+#else
+	printk("- Parameters     : %ld %ld %d %d\n", swsusp_result, swsusp_action, image_size_limit, max_async_ios);
+#endif
+	printk("- Calculations   : Image size: %d. Ram to suspend: %ld. To resume: %ld.\n", SWAP_NEEDED, RAM_TO_SUSPEND, RAM_TO_RESUME);
+	printk("- Limits         : %lu pages RAM. Initial boot: %lu. Current boot: %lu.\n", max_mapnr, orig_mem_free, base_mem_free);
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	printk("- Image compression option compiled in.\n");
+#endif
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	printk("- Checksumming enabled.\n");
+#endif
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+	printk("- Debugging compiled in.\n");
+#endif
+}
+	
+#define SUSPEND_C
+#include <asm/suspend.h>
+
+/*
+ * do_software_suspend
+ * Functionality   : First level of code for software suspend invocations.
+ *                   Stores and restores load averages (to avoid a spike),
+ *                   allocates bitmaps, freezes processes and eats memory
+ *                   as required before suspending drivers and invoking
+ *                   the 'low level' code to save the state to disk.
+ *                   By the time we return from do_suspend_lowlevel, we
+ *                   have either failed to save the image or successfully
+ *                   suspended and reloaded the image. The difference can
+ *                   be discerned by checking SUSPEND_ABORTED.
+ * Called From     : 
+ */
+extern inline int notify_resume(void);
+#ifdef CONFIG_MAGIC_SYSRQ
+extern int sysrq_pressed;
+#endif
+
+static void do_software_suspend(void)
+{
+	unsigned long avenrun_save[3];
+	int i;
+
+	if (!software_suspend_enabled) {
+		printk(name_swsusp "Software suspend is disabled\n");
+		return;
+	}
+
+	printk(name_swsusp "Initiating a software_suspend cycle.\n");
+	BUG_ON(in_interrupt());
+	software_suspend_enabled = 0;
+	swsusp_result = 0;
+	nr_suspends++;
+	
+	/*
+	 * Running swsusp makes for a very high load average. I'm told that
+	 * sendmail and crond check the load average, so in order for them
+	 * not to be unnecessarily affected by the operation of swsusp, we
+	 * store the avenrun values prior to suspending and restore them
+	 * at the end of the resume cycle. Thus, the operation of swsusp
+	 * should be invisible to them. Thanks to Marcus Gaugusch and Bernard
+	 * Blackham for noticing the problem and suggesting the solution.
+	 */
+	
+	for (i = 0; i < 3; i++)
+		avenrun_save[i] = avenrun[i];
+
+	PRINTFREEMEM("at start of do_software_suspend");
+	si_swapinfo(&swapinfo);	/* FIXME: si_swapinfo(&i) returns all swap devices information.*/ 
+	if (!swapinfo.totalswap) {
+		printk(KERN_ERR "You need some swap space to be able to suspend to disk.\n");
+		SET_RESULT_STATE(SUSPEND_ABORTED);
+		SET_RESULT_STATE(SUSPEND_NOSWAP_AVAILABLE);
+		goto out;
+	}
+
+	now_resuming = 0;
+	last_suspend_cache_page = NULL;
+
+	/* Suspend console switch (if necessary) */
+	if (prepare_suspend_console())
+		printk(name_suspend "Can't allocate a console... proceeding\n");
+	PRINTFREEMEM("after preparing suspend_console");
+	beepOK;			/* first beep */
+
+	/* Allocate bitmaps for suspend page flags */
+	printlog(SUSPEND_MEMORY, SUSPEND_VERBOSE, "Allocating inusemap\n");
+	if (allocatemap(&inusemap, 1))
+		goto out;
+	PRINTFREEMEM("after allocating inusemap");
+	if (allocatemap(&pageset2map, 1)) {
+		freemap(&inusemap);
+		return;
+	}
+	PRINTFREEMEM("after allocating pageset2 map");
+
+	/* Allocate bitmaps for ignoring pagedir in checksumming */
+	if (allocatemap(&pagedirmap, 0)) {
+		freemap(&pageset2map);
+		freemap(&inusemap);
+		goto out;
+	}
+
+	PRINTFREEMEM("after allocating pagedir map");
+ 
+	/*
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_MEDIUM, "nr_unused_buffer_heads is %d.\n", nr_unused_buffer_heads);
+	while ((!nr_unused_buffer_heads) && (bh_tries < 50)) {
+		yield();
+		bh_tries++;
+	}
+	if (!nr_unused_buffer_heads) {
+		abort_suspend("No free buffer heads for 50 yields! I won't be able to save anything.");
+		goto out;
+	}
+	*/
+
+	/* Free up memory if necessary */
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_VERBOSE, "Eating memory.\n");
+	if (eat_memory_and_freeze_processes() || TEST_RESULT_STATE(SUSPEND_ABORTED))
+		goto out;
+
+	PRINTFREEMEM("after eating memory");
+
+	prepare_status(1, 1, "Freeing eaten memory.");
+
+	/* Release memory that has been eaten */
+	free_grabbed_memory();
+
+	beepOK;		/* second beep */
+
+#ifdef CONFIG_PREEMPT
+	preempt_disable();
+#endif
+	if (!TEST_RESULT_STATE(SUSPEND_ABORTED)) {
+		prepare_status(1, 0, "Suspending drivers.");
+		if (drivers_suspend()==0) { 
+			prepare_status(1, 0, "Starting low level suspend...");
+			do_suspend_lowlevel(0);
+			beepOK;
+		} 
+	}
+	
+	if (SUSPEND_VERBOSE)
+		display_debug_info();
+	
+	check_shift_keys(1, NULL);
+
+	finish_all_io();
+	PRINTFREEMEM("after finishing all IO");
+
+#ifdef CONFIG_PREEMPT
+	preempt_enable();
+#endif
+
+out:
+	PRINTFREEMEM("at 'out'");
+
+	free_grabbed_memory();
+
+	PRINTFREEMEM("after freeing grabbed memory");
+	if (pagedirmap)
+		freemap(&pagedirmap);
+	PRINTFREEMEM("after freeing pagedir map");
+	if (pageset2map)
+		freemap(&pageset2map);
+	PRINTFREEMEM("after freeing pageset2 map");
+	if (inusemap)
+		freemap(&inusemap);
+	PRINTFREEMEM("after freeing inuse map");
+	
+	for (i = 0; i < 3; i++)
+		avenrun[i] = avenrun_save[i];
+
+#ifdef CONFIG_MAGIC_SYSRQ
+	sysrq_pressed = 0;
+#endif
+
+	thaw_processes();
+
+	MDELAY(1000);
+	check_shift_keys(1, "About to restore original console. ");
+	restore_console();
+#ifdef DEFAULT_SUSPEND_CONSOLE
+	update_screen(fg_console);
+#endif
+	PRINTFREEMEM("at end of do_software_suspend");
+
+	if (notify_resume())
+		printk(KERN_EMERG "Failed to notify resume chain.\n");
+
+	software_suspend_enabled = 1;
+}
+
+/*
+ * This is main interface to the outside world. It needs to be
+ * called from process context. It sets the active flag, 
+ * notifies kswsuspd thread through the wake up and waits 
+ * for ACTIVE flag to be cleared.
+ */
+
+static DECLARE_WAIT_QUEUE_HEAD(swsusp_wait);
+static DECLARE_COMPLETION(cycle_complete);
+
+void software_suspend_pending(void)
+{
+	if (waitqueue_active(&swsusp_wait)) {
+		wake_up_interruptible(&swsusp_wait);
+		init_completion(&cycle_complete);
+		wait_for_completion(&cycle_complete);
+	}
+}
+
+/*
+ * This is kswsuspd, the kernel daemon which waits to be woken by a userspace
+ * daemon (via software_suspend_pending). It signals completion (failure or
+ * the end of a full suspend/resume cycle) by resetting cycle_unfinished. In
+ * this way, the userspace process blocks until the cycle is complete and a
+ * script doesn't need to poll the proc entry (there is now no way to tell
+ * from /proc/sys/kernel/swsusp whether the cycle has completed anyway).
+ */
+static int swsusp_mainloop(void *unused)
+{
+  	printk(name_swsusp "kswsuspd starting\n"); /* This will print the current version on boot */
+	daemonize();
+
+	swsusp_init_proc();
+
+	strcpy(current->comm, "kswsuspd");
+	sigfillset(&current->blocked);
+
+	for(;;) {
+		interruptible_sleep_on(&swsusp_wait);
+		swsusp_result = 0;
+		do_software_suspend();
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+		currentbeep = 100; /* not the original one, so that we know if this is first or subsequent suspend */
+#endif
+		complete(&cycle_complete);
+	}
+
+	swsusp_cleanup_proc();
+	
+	return(0);
+}
+
+/*
+ * Called from init kernel_thread.
+ * We check if we have an image and if so we try to resume.
+ * We also start kswsuspd if configuration looks right.
+ */
+
+void software_resume(void)
+{
+	orig_loglevel = console_loglevel;
+
+#ifdef CONFIG_SMP
+	printk(KERN_ERR name_swsusp "SMP not supported. Disabled.\n");
+	return;
+#else
+	if (!(cpu_has_pse||cpu_has_pse36)) {
+		printk(KERN_ERR name_swsusp "pse or pse36 is required. Disabled.");
+		return;
+	}
+	if (sizeof(swp_entry_t) != sizeof(long)) {
+		printk(KERN_WARNING name_swsusp "Size of swp_entry_t != size of long. Disabled.\n");
+		return;
+	}
+	if (PAGE_SIZE % sizeof(struct pbe)) {
+		printk(KERN_WARNING name_swsusp "Page size (%ld) mod size of struct pbe (%d) is not 0 (%ld). Disabled.\n", PAGE_SIZE, sizeof(struct pbe), PAGE_SIZE % sizeof(struct pbe));
+		return;
+	}
+#endif
+	if (!(resume_status & RESUME_SPECIFIED)) {
+		/* Without a pointer to the swap partition we can do nothing - even if noresume is given */
+		printk(KERN_ALERT name_swsusp "Missing or invalid swap partition location (resume= parameter). Disabled.\n");
+		return;
+	}
+
+	/* We enable the possibility of machine suspend */
+	software_suspend_enabled = 1;
+	orig_mem_free = nr_free_pages();
+
+	suspend_task = current->pid;
+	if (resume_status & NORESUME) {
+		printk(KERN_WARNING name_swsusp "Resuming disabled as requested.\n");
+		if (resume_file[0])
+			read_primary_suspend_image(resume_file,1); /* non fatal error ignored */
+		kernel_thread(swsusp_mainloop, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGHAND | SIGCHLD);
+		goto out;
+	}
+
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_VERBOSE, name_swsusp "Resuming from %s\n", resume_file);
+	if (read_primary_suspend_image(resume_file, 0)) { /* non fatal error (normal swap space) */
+		kernel_thread(swsusp_mainloop, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGHAND | SIGCHLD);
+		goto out;
+	}		
+
+	prepare_status(0, 0, "Copying pages back (no status - sensitive!)...");
+	
+	do_suspend_lowlevel(1);
+	BUG();
+
+out:
+	console_loglevel = orig_loglevel;
+	suspend_task = 0;
+}
+
+/*
+ * Resume setup: obtain the swap device in which the signature will be used
+ * to store a pointer to the suspend header.
+ */
+static int __init resume_setup(char *str)
+{
+	if( (str == NULL) || (strncmp(str, "/dev/h", 6)) ) {
+		printk(name_swsusp "Currently only compatible with IDE /dev/h?? swap partitions.\n");
+		resume_status |= COMMANDLINE_ERROR;
+		software_suspend_enabled = 0;
+		return 1;
+	}
+
+	strncpy(resume_file, str, 255);
+	resume_status |= RESUME_SPECIFIED;
+	return 0;
+}
+/*
+ * Allow the user to set the action parameter from lilo, prior to resuming.
+ */
+static int __init swsusp_act_setup(char *str)
+{
+	if(str)
+		swsusp_action=simple_strtol(str,NULL,0);
+	printk(name_swsusp "Debug level parameter set : %lx\n",swsusp_action);
+	if (TEST_ACTION_STATE(SUSPEND_PAUSE))
+		printk("Pausing enabled.\n");
+	if (TEST_ACTION_STATE(SUSPEND_SLOW))
+		printk("Slow down enabled.\n");
+	if (TEST_ACTION_STATE(SUSPEND_NO_ASYNC_READS))
+		printk("Asynchronous reads disabled.\n");
+	if (TEST_ACTION_STATE(SUSPEND_NO_ASYNC_WRITES))
+		printk("Asynchronous writes disabled.\n");
+	if (TEST_ACTION_STATE(SUSPEND_NOPAGESET2))
+		printk("Pageset2 enabled.\n");
+	if (TEST_ACTION_STATE(SUSPEND_LOGALL))
+		printk("Logging all messages enabled.\n");
+	if (TEST_ACTION_STATE(SUSPEND_NO_COMPRESSION))
+		printk("Image compression disabled.\n");
+	swsusp_act_used = 1;
+	return 0;
+}
+
+/*
+ * Allow the user to set the debug parameter from lilo, prior to resuming.
+ */
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+static int __init swsusp_dbg_setup(char *str)
+{
+	if(str)
+		swsusp_debug_state=simple_strtol(str,NULL,0);
+	printk(name_swsusp "Debug parameter set to %lx\n",swsusp_debug_state);
+	printlog(SUSPEND_FREEZER, SUSPEND_ERROR,"Freezer messages enabled\n");
+	printlog(SUSPEND_EAT_MEMORY, SUSPEND_ERROR,"Memory freeing enabled\n");
+	printlog(SUSPEND_PAGESETS, SUSPEND_ERROR,"Pageset debugging enabled\n");
+	printlog(SUSPEND_MARK_PAGESET2, SUSPEND_ERROR,"Marking pageset2 debugging enabled\n");
+	printlog(SUSPEND_COPY_PAGESET, SUSPEND_ERROR,"Copying pageset debugging enabled\n");
+	printlog(SUSPEND_WRITE_PAGESETS, SUSPEND_ERROR,"Writing pagesets debugging enabled\n");
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_ERROR,"Reading pagesets debugging enabled\n");
+	printlog(SUSPEND_CHECKSUMS, SUSPEND_ERROR,"Checksumming debugging enabled\n");
+	printlog(SUSPEND_SWAP, SUSPEND_ERROR,"Swap allocation debugging enabled\n");
+	printlog(SUSPEND_MEMORY, SUSPEND_ERROR,"Memory debugging enabled\n");
+	swsusp_dbg_used = 1;
+	return 0;
+}
+
+/*
+ * Allow the user to set the debug level parameter from lilo, prior to
+ * resuming.
+ */
+static int __init swsusp_lvl_setup(char *str)
+{
+	if(str) {
+		swsusp_default_console_level= simple_strtol(str,NULL,0);
+		console_loglevel = swsusp_default_console_level;
+	}
+	printk(name_swsusp "Debug parameter set to %d\n",swsusp_default_console_level);
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_LOW,"Low level debugging messages enabled\n");
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_MEDIUM,"Medium level debugging messages enabled\n");
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_HIGH,"High level debugging messages enabled\n");
+	printlog(SUSPEND_ANY_SECTION, SUSPEND_VERBOSE,"Verbose debugging enabled\n");
+	swsusp_lvl_used = 1;
+	return 0;
+}
+#endif
+
+/*
+ * Allow the user to specify that we should ignore any image found and restore
+ * the swap header to its normal value. This is equivalent to running the
+ * task queue (but not a sync) and then turning off the power. The same
+ * precautions should be taken: fsck if you're not journalled.
+ */
+static int __init noresume_setup(char *str)
+{
+	resume_status |= NORESUME;
+	/* Message printed later */
+	return 0;
+}
+
+__setup("resume=", resume_setup);
+__setup("swsusp_act=", swsusp_act_setup);
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+__setup("swsusp_dbg=", swsusp_dbg_setup);
+__setup("swsusp_lvl=", swsusp_lvl_setup);
+#endif
+__setup("noresume", noresume_setup);
+
+EXPORT_SYMBOL(software_suspend_pending);
+EXPORT_SYMBOL(refrigerator);
+EXPORT_SYMBOL(suspend_task);
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/Makefile m1/kernel/suspend/Makefile
--- m2/kernel/suspend/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/Makefile	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,11 @@
+#
+# Makefile for software suspend.
+#
+
+O_TARGET    := swsusp.o
+
+export-objs := main.o freeze_and_free.o
+
+obj-$(CONFIG_SOFTWARE_SUSPEND) += main.o io.o ui.o pagedir.o freeze_and_free.o low_level_io.o proc.o
+
+include $(TOPDIR)/Rules.make
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/pagedir.c m1/kernel/suspend/pagedir.c
--- m2/kernel/suspend/pagedir.c	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/pagedir.c	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,771 @@
+/*
+ * linux/kernel/suspend.c
+ *
+ */
+
+#define SWSUSP_PAGEDIR_C
+
+#include "common.h"
+extern unsigned long * inusemap;
+extern unsigned long * pageset2map;
+extern unsigned long * pagedirmap;
+extern struct pagedir pagedir1, pagedir2, pagedir_nosave;
+
+int get_phys_params(struct pbe * pbe);
+
+inline void set_next_pagedir_page(struct pbe * pbe, struct pbe * next)
+{
+	struct pbelink * link = (struct pbelink *) PBEPAGE_START(pbe);
+	link->next = next;
+}
+
+inline struct pbe * get_next_pagedir_page(struct pbe * pbe)
+{
+	struct pbelink * link = (struct pbelink *) PBEPAGE_START(pbe);
+	return link->next;
+}
+
+inline struct pbe * get_next_pbe(struct pbe * pbe)
+{
+	int index_within_page = (pbe - ((struct pbe *) PBEPAGE_START(pbe)));
+	struct pbe * result;
+	if (index_within_page < (PBES_PER_PAGE - 1)) {
+		result = pbe;
+		result++;
+	} else
+		result = get_next_pagedir_page(pbe);
+	return result;
+}
+
+static void clear_map(unsigned long * pagemap)
+{
+	int i;
+	for(i=0; i < (max_mapnr / (8 * sizeof(unsigned long))); i++) {
+		pagemap[i]=0;
+	}
+}
+
+int allocatemap(unsigned long ** pagemap, int setnosave)
+{
+	void * check;
+	int i;
+	if (*pagemap) {
+		printk("Error. Pagemap already allocated.\n");
+	} else {
+		check = (void *) __get_free_pages(__GFP_FAST, BITMAP_ORDER);
+		if (!check) {
+			abort_suspend("Error. Unable to allocate memory for pagemap.\n");
+			return 1;
+		}
+		if (setnosave)
+			for (i = 0; i < (1 << BITMAP_ORDER); i++)
+				SetPageNosave(virt_to_page((unsigned long) check + i * PAGE_SIZE));
+		*pagemap = (unsigned long *) check;
+	}
+	clear_map(*pagemap);
+	return 0;
+}
+
+int freemap(unsigned long ** pagemap)
+{
+	int i;
+	if (!*pagemap) {
+		printk("Error. Pagemap not allocated.\n");
+		return 1;
+	} else {
+		for (i = 0; i < (1 << BITMAP_ORDER); i++)
+			ClearPageNosave(virt_to_page((unsigned long) *pagemap + i * PAGE_SIZE));
+		free_pages((unsigned long) *pagemap, BITMAP_ORDER);
+		*pagemap = NULL;
+		return 0;
+	}
+}
+
+#define PAGENUMBER(page) (page-mem_map)
+#define PAGEINDEX(page) ((PAGENUMBER(page))/(8*sizeof(unsigned long)))
+#define PAGEBIT(page) ((int) ((PAGENUMBER(page))%(8 * sizeof(unsigned long))))
+
+/* 
+ * freepagesmap is used in two ways: 
+ * - During suspend, to tag pages which are not used (to speed up count_data_pages);
+ * - During resume, to tag pages which are is pagedir1. This does not tag pagedir2
+ *   pages, so !== first use.
+ */
+#define PageInUse(page)		test_bit(PAGEBIT(page), &inusemap[PAGEINDEX(page)])
+#define SetPageInUse(page)	set_bit(PAGEBIT(page), &inusemap[PAGEINDEX(page)])
+#define ClearPageInUse(page)	clear_bit(PAGEBIT(page), &inusemap[PAGEINDEX(page)])
+
+#define PagePageset2(page)	test_bit(PAGEBIT(page), &pageset2map[PAGEINDEX(page)])
+#define SetPagePageset2(page)	set_bit(PAGEBIT(page), &pageset2map[PAGEINDEX(page)])
+#define ClearPagePageset2(page)	clear_bit(PAGEBIT(page), &pageset2map[PAGEINDEX(page)])
+
+#define PagePagedir(page)	test_bit(PAGEBIT(page), &pagedirmap[PAGEINDEX(page)])
+#define SetPagePagedir(page)	set_bit(PAGEBIT(page), &pagedirmap[PAGEINDEX(page)])
+#define ClearPagePagedir(page)	clear_bit(PAGEBIT(page), &pagedirmap[PAGEINDEX(page)])
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+unsigned long pagechecksum(struct page * page)
+{
+	char * address = kmap_nonblock(page);
+	unsigned long checksum = 0;
+	int i = 0;
+
+	if (!address) { /* Failed to kmap */
+		printlog(SUSPEND_CHECKSUMS, SUSPEND_ERROR, "Failed to kmap page %p.\n", page);
+		return 0;
+	}
+
+	for (i = 0; i < PAGE_SIZE; i++)
+		checksum+= (int) (*(address + i) * i);
+	kunmap(page);
+	return checksum;
+}
+
+__nosavedata void check_pagedir_checksums(struct pagedir * p, int at_orig_address)
+{
+	int i;
+	struct pbe * pbe;
+	unsigned long current_checksum;
+
+	pbe = p->data;
+	for(i = 0; i < p->pageset_size; i++) {
+		if (!PagePagedir(pbe->origaddress)) { 	/* If not marked as a pagedir page */
+			if (at_orig_address)
+				current_checksum = pagechecksum(pbe->origaddress);
+			else
+				current_checksum = pagechecksum(pbe->address);
+			pbe->checksum_error =(current_checksum != pbe->checksum);
+		}
+		pbe = get_next_pbe(pbe);
+	}
+}
+
+void show_checksum_errors(struct pagedir * p)
+{
+	int i;
+	struct pbe * pbe;
+
+	pbe = p->data;
+	for(i = 0; i < p->pageset_size; i++) {
+		if (!PagePagedir(pbe->origaddress)) { 	/* If not marked as a pagedir page */
+			if (pbe->checksum_error) {
+				char * pageaddress = kmap_nonblock(pbe->origaddress);
+				printlog(SUSPEND_CHECKSUMS, SUSPEND_LOW, 
+					"Page checksum for page %d/%d doesn't match. ",
+					i+1,
+					p->pageset_size);
+				printlog(SUSPEND_CHECKSUMS, SUSPEND_LOW,
+					"Original Address: %p (%p). ",
+					pbe->origaddress,
+					pageaddress);
+				kunmap(pbe->origaddress);
+				pageaddress = kmap_nonblock(pbe->address);
+				printlog(SUSPEND_CHECKSUMS, SUSPEND_LOW,
+					"Copy Address: %p (%p).\n",
+					pbe->address,
+					pageaddress);
+				kunmap(pbe->address);
+			} 
+		}
+		pbe = get_next_pbe(pbe);
+	}
+}
+
+__nosavedata void store_pagedir_checksums(struct pagedir * p)
+{
+	int i;
+	struct pbe * pbe;
+
+	pbe = p->data;
+	for(i = 0; i < p->pageset_size; i++) {
+		/* 
+		 * For pagedir1, checksum calculated before pages are copied 
+		 * but while interrupts are disabled.
+		 * For pagedir2, checksum actual page (no copy made) 
+		 */
+		if (!PagePagedir(pbe->origaddress)) /* If not marked as a pagedir page */
+			pbe->checksum = pagechecksum(pbe->origaddress);
+		pbe = get_next_pbe(pbe);
+	}
+}
+#endif
+
+#define __calcpagedirsize(size) (SUSPEND_PD_PAGES(size))
+int calcpagedirsize(int size)
+{
+	/*
+	 * If adding the pagedir and header will mean we need to store more pages 
+	 * than fit, we need to expand the size until it does fit (the pagedir itself 
+	 * might require more than one pagedir to store, hence the while).
+	 */
+	int result;
+
+	result = __calcpagedirsize(size);
+	while (__calcpagedirsize(size + result) > result) {
+		result++;
+	}
+	return result;
+}
+
+static void generate_free_page_map(void) 
+{
+	int i, loop;
+	struct page * page;
+	pg_data_t *pgdat = pgdat_list;
+	unsigned type;
+	unsigned long flags;
+
+	for(i=0; i < max_mapnr; i++)
+		SetPageInUse(mem_map+i);
+	
+	for (type=0;type < MAX_NR_ZONES; type++) {
+		zone_t *zone = pgdat->node_zones + type;
+		int order = MAX_ORDER - 1;
+		free_area_t *area;
+		struct list_head *head, *curr;
+		swsusp_spin_lock_irqsave(&zone->lock, flags);
+		do {
+			int first_entry = 1;
+			area = zone->free_area + order;
+			head = &area->free_list;
+			curr = head;
+
+			for(;;) {
+				if(!curr) {
+//					printk(KERN_ERR name_suspend "FIXME: this should not happen but it does!!!");
+					break;
+				}
+				if (first_entry) 
+					first_entry--;
+				else {
+					page = list_entry(curr, struct page, list);
+					for(loop=0; loop < (1 << order); loop++)
+						ClearPageInUse(page+loop);
+				}
+
+				curr = curr->next;
+				if (curr == head)
+					break; 				
+			}
+		} while(order--);
+		swsusp_spin_unlock_irqrestore(&zone->lock, flags);
+	}
+}
+
+static int is_head_of_free_region(struct page * page)
+{
+	struct page * posn = page;
+
+	while (((posn-mem_map) < max_mapnr) && (!PageInUse(posn))) 
+		posn++;
+	return (posn - page);
+}
+
+pageset_sizes_t count_data_pages(int whichpagedir)
+{
+	int chunk_size, loop, numnosave = 0;
+	struct pbe * pbe1 = NULL;
+	struct pbe * pbe2 = NULL;
+
+	pageset_sizes_t result;
+	result.size1 = 0;
+	result.size2 = 0;
+	result.size2low = 0;
+
+	if (whichpagedir) {
+		pbe1 = pagedir1.data;
+		pbe2 = pagedir2.data;
+	}
+
+	generate_free_page_map();
+	if (max_mapnr != num_physpages) {
+		abort_suspend("mapnr is not expected");
+		result.size1 = -1;
+		result.size2 = -1;
+		result.size2low = -1;
+		return result;
+	}
+	for (loop = 0; loop < max_mapnr; loop++) {
+		if (!PageReserved(mem_map+loop)) {
+			if (PageNosave(mem_map+loop)) {
+				numnosave++;
+				continue;
+			}
+
+			if ((chunk_size=is_head_of_free_region(mem_map+loop))!=0) {
+				loop += chunk_size - 1;
+				continue;
+			}
+		} else {
+			if (PageNosave(mem_map+loop)) {
+				abort_suspend("Reserved page marked nosave! (%lx)\n", ADDRESS(loop));
+				result.size1 = 0;
+				result.size2 = 0;
+				result.size2low = 0;
+				return result;
+			}
+			/*
+			 * Just copy whole code segment. Hopefully it is not that big.
+			 */
+			if (ADDRESS(loop) >= (unsigned long)
+				&__nosave_begin && ADDRESS(loop) < 
+				(unsigned long)&__nosave_end) {
+				numnosave++;
+				continue;
+			}
+			/* Hmm, perhaps copying all reserved pages is not too healthy as they may contain 
+			   critical bios data? */
+
+		};
+
+		if (whichpagedir) {
+			int usepagedir2 = (PageHighMem(mem_map+loop) || PagePageset2(mem_map+loop));
+
+			if (usepagedir2) {
+				if (result.size2 <= pagedir2.pageset_size) {
+					pbe2->origaddress = mem_map+loop;
+					pbe2->address = mem_map+loop;
+					pbe2 = get_next_pbe(pbe2);
+				}
+			} else {
+				if (result.size1 <= pagedir1.pageset_size) {
+					pbe1->origaddress = mem_map+loop;
+					pbe1 = get_next_pbe(pbe1);
+				}
+			}
+		}
+
+		if (PagePageset2(mem_map+loop)) {
+			result.size2++;
+			if (!PageHighMem(mem_map+loop))
+				result.size2low++;
+		} else
+			result.size1++;
+	}
+	
+	/*
+	 * printlog(SUSPEND_VERBOSE, "\nResults: %d and %d(%d low). %d marked Nosave\n", 
+	 *		result.size1, result.size2, result.size2low, numnosave);
+	 */
+	if (whichpagedir) {
+		printnolog(SUSPEND_ANY_SECTION, SUSPEND_VERBOSE, 0, "\n");
+		if (result.size1 > pagedir1.pagedir_capacity)
+			abort_suspend("%d more pages to be copied than were allowed for! Pagedir1 capacity is %d (counted %d)\n", 
+					result.size1 - pagedir1.pagedir_capacity, 
+					pagedir1.pagedir_capacity,
+					result.size1);
+		if (result.size2 > pagedir2.pagedir_capacity)
+			abort_suspend("%d more pages to be copied than were allowed for! Pagedir1 capacity is %d (counted %d)\n", 
+					result.size2 - pagedir2.pagedir_capacity,
+					pagedir2.pagedir_capacity,
+					result.size2);
+	}
+	return result;
+}
+
+__nosavedata void copy_pageset1(void)
+{
+	int i = 0;
+	struct pbe * pbe = pagedir1.data;
+
+	for (i = 0; i < pageset1_size; i++) {
+#if 0
+		printnolog(SUSPEND_COPY_PAGESET, SUSPEND_VERBOSE, 1, "!%d! ", i);
+		printnolog(SUSPEND_COPY_PAGESET, SUSPEND_VERBOSE, 0, "[1]%lx ->", (unsigned long) page_address(pbe->origaddress)); 
+		printnolog(SUSPEND_COPY_PAGESET, SUSPEND_VERBOSE, 0, "[2]%lx.", (unsigned long) page_address(pbe->address));
+#endif
+		copy_page((char *) page_address(pbe->address), 
+				(char *) page_address(pbe->origaddress));
+		pbe = get_next_pbe(pbe);
+	}
+
+#if 0
+	printnolog(SUSPEND_COPY_PAGESET, SUSPEND_VERBOSE, 0, "\n");
+#endif
+}
+
+void free_pagedir(struct pagedir * p)
+{
+	int i, swapcount = 0;
+	struct pbe * pbe;
+
+	PRINTFREEMEM("At start of free_pagedir");
+
+	if (p->pagedir_size == 0)
+		return;
+
+	/* Entries can validly be NULL. We might be called if creating a pagedir fails to allocate a page */
+	if (p->first_allocated) {
+		pbe = p->first_allocated;
+		for(i = p->alloc_from; i < p->pagedir_capacity; i++) {
+			if (pbe->address) {
+				ClearPageNosave(pbe->address);
+				free_page((unsigned long) page_address(pbe->address));
+			}
+			pbe = get_next_pbe(pbe);
+		}
+	}
+	
+	pbe = p->data;
+	for(i = 0; i < p->pagedir_capacity; i++) {
+		swp_entry_t entry = pbe->swap_address;
+		if (entry.val) {
+			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "(Free %d %p:%lx)", i,
+				pbe,
+				entry.val);
+			swap_free(entry);
+			swapcount++;
+			pbe->swap_address.val = 0;
+		}
+		pbe = get_next_pbe(pbe);
+	}
+		
+	pbe = p->data;
+	for(i = 0; i < p->pagedir_size; i++) {
+		struct pbe * next = get_next_pagedir_page(pbe);
+		free_page((unsigned long) pbe);
+		pbe = next;
+	}
+
+	p->pagedir_size = 0;
+	p->data = 0;
+	PRINTFREEMEM("At end of free_pagedir");
+	printlog(SUSPEND_SWAP, SUSPEND_HIGH, "Freed %d swap pages in free_pagedir. Pageset size was %d.\n", swapcount, p->pageset_size);
+}
+
+int create_pagedir(struct pagedir * p, int pageset_size, int alloc_from)
+{
+	int pagedir_size = calcpagedirsize(pageset_size);
+	struct pbe * next;
+	struct pbe * last = NULL;
+	struct pbe * pbe;
+	int swapcount = 0;
+
+#undef abort_and_exit
+#define abort_and_exit(f, a...) do { \
+			abort_suspend(f, ## a); \
+			free_pagedir(p); \
+			return 0;\
+	} while(0)
+
+	prepare_status(0, 0, "Preparing page directory.");
+	if (pageset_size == 0) {
+		p->pagedir_size = p->pageset_size = p->pagedir_capacity = 0;
+		p->alloc_from = alloc_from;
+		return 0;
+	}
+
+	PRINTFREEMEM("at start of create_pagedir");
+
+	{
+		int i;
+		for (i = 0; i < pagedir_size; i++) {
+			pbe = (struct pbe *) get_zeroed_page(GFP_ATOMIC);
+			if (!pbe) {
+				int j;
+				pbe = p->data;
+				for (j = 0; j < i; j++) {
+					next = get_next_pagedir_page(pbe);
+					free_page((unsigned long) pbe);
+					pbe = next;
+				}
+				abort_suspend("Unable to allocate a pagedir.\n");
+				return 1;
+			}
+			ClearPageNosave(virt_to_page(pbe));
+			ClearPagePageset2(virt_to_page(pbe));
+			SetPagePagedir(virt_to_page(pbe));
+			if (i == 0)
+				p->data = pbe;
+			else
+				set_next_pagedir_page(last, pbe);
+			last = pbe;
+		}
+	}
+	
+	{
+		int i;
+		pbe = p->data;
+		
+		for(i=0; i < pageset_size; i++) {
+			swp_entry_t entry;
+			pbe->origaddress = 0;
+			pbe->address = 0;
+			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "");
+			entry = get_swap_page(1);
+			swapcount++;
+			if (!entry.val)
+				abort_and_exit("Not enough swapspace (this shouldn't happen!)\n");
+			pbe->swap_address = entry;
+			get_phys_params(pbe);
+			if (TEST_RESULT_STATE(SUSPEND_ABORTED)) {
+				free_pagedir(p);
+				return 0;
+			}
+			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 0, "(Get %d %p -> %lx)", i, 
+				pbe,
+				pbe->swap_address.val);
+			if (i == alloc_from)
+				p->first_allocated = pbe;
+			pbe = get_next_pbe(pbe);
+		}
+		printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 0, "\n");
+	}
+	
+	{
+		int i, numnosaveallocated=0;
+		struct pbe * pbe = p->first_allocated;
+	
+		for(i=alloc_from; i < pageset_size; i++) {
+			pbe->address = virt_to_page(get_zeroed_page(GFP_ATOMIC));
+			if (!pbe->address)
+				abort_and_exit("Unable to allocate pages for pagedir!\n");
+			SetPageNosave(pbe->address);
+			numnosaveallocated++;
+			pbe = get_next_pbe(pbe);
+		}
+		if (pageset_size > alloc_from) {
+			printlog(SUSPEND_PAGESETS, SUSPEND_VERBOSE,"   Allocated memory for pages from %d-%d (%d pages).\n", alloc_from, pageset_size - 1, pageset_size - alloc_from);
+		}
+	}
+
+	p->pagedir_size = calcpagedirsize(pageset_size);
+	p->pageset_size = p->pagedir_capacity = pageset_size;
+	p->alloc_from = alloc_from;
+
+	printlog(SUSPEND_PAGESETS, SUSPEND_VERBOSE,"   Created pagedir of %d pages at %p to store %d pages.\n",
+			p->pagedir_size,
+			p->data,
+			p->pageset_size);
+
+	PRINTFREEMEM("at end of create_pagedir");
+	printlog(SUSPEND_SWAP, SUSPEND_HIGH, "Allocated %d swap pages in create_pagedir.\n", swapcount);
+	return 0;
+}
+
+/*
+ * Mark unshared pages in processes not needed for suspend as being able to be written
+ * out in a separate pagedir. 
+ * HighMem pages are simply marked as pageset2. They won't be needed during suspend.
+ * Since we don't know which highmem pages are free, we can't return a count any more.
+ */
+
+void markpagesforpageset2(void)
+{
+	struct list_head * entry;
+	int i;
+
+	if (max_mapnr != num_physpages) {
+		abort_suspend("mapnr is not expected");
+		return;
+	}
+	
+	for (i = 0; i < max_mapnr; i++)
+		ClearPagePageset2(mem_map+i);
+
+	if (TEST_ACTION_STATE(SUSPEND_NOPAGESET2)) {
+#ifdef CONFIG_HIGHMEM
+		printlog(SUSPEND_MARK_PAGESET2, SUSPEND_ERROR, "Ignoring request for no pageset2 - HighMem support is configured.\n");
+#else
+		return;
+#endif
+	}
+
+	/*
+	 * Mark page cache pages as pageset2.
+	 */
+	
+	/*
+	 * Inactive list
+	 */
+	entry = inactive_list.prev;
+	while (entry != &inactive_list) {
+		struct page * page;
+
+		page = list_entry(entry, struct page, lru);
+		SetPagePageset2(page);
+		entry = entry->prev;
+	}
+
+	/*
+	 * Active list
+	 */
+	entry = active_list.prev;
+	while (entry != &active_list) {
+		struct page * page;
+
+		page = list_entry(entry, struct page, lru);
+		SetPagePageset2(page);
+		entry = entry->prev;
+	}
+
+	/*
+	 * Next, ensure that pagedir pages aren't marked as pageset 2
+	 */
+
+	if (pagedir1.pageset_size) {
+		struct pbe * pbe = pagedir1.data;
+		for (i = 0; i < pagedir1.pagedir_size; i++) {
+			struct page * page = virt_to_page(pbe);
+			if (PagePageset2(page)) {	// Must be assigned by the time recalc stats is called
+				printlog(SUSPEND_MARK_PAGESET2, SUSPEND_VERBOSE, "Pagedir[%d] was marked as pageset2 - unmarking.\n", i);
+				ClearPagePageset2(page);
+			}
+			pbe = get_next_pbe(pbe);
+		}
+	}
+
+	/*
+	 * Finally, ensure HighMem pages are pageset 2
+	 */
+
+	for (i = 0; i < max_mapnr; i++)
+		if (PageHighMem(mem_map+i))
+			SetPagePageset2(mem_map+i);
+}
+
+void warmup_collision_cache(void) {
+	int i;
+	struct pbe * pbe = pagedir_nosave.data;
+	
+	allocatemap(&inusemap, 0);/* Doesn't get deallocated because forgotten
+				   when we copy PageDir1 back. Doesn't matter
+				   if collides because not used during copy back.
+				 */
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "Setting up pagedir cache...");
+	for (i = 0; i < max_mapnr; i++)
+		ClearPageInUse(mem_map+i);
+
+	for(i=0; i < pagedir_nosave.pageset_size; i++) {
+		SetPageInUse(pbe->origaddress);
+		printnolog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, 1, "Marking %p as in use.", pbe->origaddress);
+		if (!(i%800)) {
+			printlog(SUSPEND_READ_PAGESETS, SUSPEND_MEDIUM, ".");
+		}
+		pbe = get_next_pbe(pbe);
+	}
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "%d", i);
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, "|\n");
+}
+
+
+/*
+ * We check here that pagedir & pages it points to won't collide with pages
+ * where we're going to restore from the loaded pages later
+ */
+
+int check_pagedir(void)
+{
+	int i, nrdone = 0;
+	void **eaten_memory = NULL;
+	void **c = eaten_memory, *f, *addr;
+	struct page * pageaddr = NULL;
+	struct pbe * pbe = pagedir_nosave.data;
+
+	// Because we're trying to make this work when we're saving as much memory as possible
+	// we need to remember the pages we reject here and then free them when we're done.
+	
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,"\nAllocating memory.\n");
+	for(i=0; i < pagedir_nosave.pageset_size; i++) {
+		while ((addr = (void *) get_zeroed_page(GFP_ATOMIC))) {
+			memset(addr, 0, PAGE_SIZE);
+			pageaddr = virt_to_page(addr);
+			if (!PageInUse(pageaddr)) {
+				break;
+			}
+			eaten_memory = addr;
+			*eaten_memory = c;
+			c = eaten_memory;
+		}
+		printnolog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, 1, "%d/%d (%p = %p)", i, pagedir_nosave.pageset_size, pbe, pageaddr);
+		pbe->address = pageaddr;
+		pbe = get_next_pbe(pbe);
+		nrdone++;
+	}
+
+	// Free unwanted memory
+	c = eaten_memory;
+	while(c) {
+		//printlog(SUSPEND_LOW, ":");
+		f = c;
+		c = *c;
+		if (f)
+			free_page((unsigned long) f);
+	}
+	eaten_memory = NULL;
+	
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,"Check_pagedir: Prepared %d of %d pages.\n", nrdone, pagedir_nosave.pageset_size);
+	
+	check_shift_keys(1, "Pagedir prepared. ");
+
+	return 0;
+}
+
+int relocate_pagedir(void)
+{
+	void **eaten_memory = NULL;
+	void **c = eaten_memory, *m = NULL, *f;
+	int oom = 0, i, numeaten = 0;
+	struct pbe * pbe = pagedir_nosave.data;
+	struct pbe * last = NULL;
+
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,"Relocating conflicting parts of pagedir.\n");
+
+	for (i = 0; i < pagedir_nosave.pagedir_size; i++) {
+		int this_collides = 0;
+
+		this_collides = PageInUse(virt_to_page(pbe));
+
+		if (this_collides) {
+			printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,"\nRelocating pbe pagedir %d.\n", i);
+			while ((m = (void *) get_zeroed_page(GFP_ATOMIC))) {
+				memset(m, 0, PAGE_SIZE);
+				if (!PageInUse(virt_to_page(m))) {
+					copy_page(m, (void *) pbe);
+					free_page((unsigned long) pbe);
+					if (i == 0)
+						pagedir_nosave.data = m;
+					else 
+						set_next_pagedir_page(last, m);
+					pbe = (struct pbe *) m;
+					break;
+				}
+				numeaten ++;
+				eaten_memory = m;
+				printnolog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE, 0, "Eaten: %d. Still to try:%d\r", numeaten, nr_free_pages()); 
+				*eaten_memory = c;
+				c = eaten_memory;
+			}
+
+			if (!m) {
+				printk("\nRan out of memory trying to relocate pagedir (tried %d pages).\n", numeaten);
+				oom = 1;
+				break;
+			}
+		}
+		SetPagePagedir(virt_to_page(pbe));
+		last = pbe;
+		pbe = get_next_pagedir_page(pbe);
+	}
+		
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,"\nFreeing rejected memory locations...");
+
+	c = eaten_memory;
+	while(c) {
+		f = c;
+		c = *c;
+		if (f)
+			free_pages((unsigned long) f, 0);
+	}
+	eaten_memory = NULL;
+	
+	printlog(SUSPEND_READ_PAGESETS, SUSPEND_VERBOSE,"\n");
+	
+	check_shift_keys(1, "Pagedir relocated. ");
+
+	if (oom) 
+		return -ENOMEM;
+	else
+		return 0;
+}
+
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/proc.c m1/kernel/suspend/proc.c
--- m2/kernel/suspend/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/proc.c	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,324 @@
+/*
+ * /drivers/swsusp/proc.c
+ *
+ * This file is to realize proc entries for tuning Software Suspend.
+ *
+ * Versions:
+ * 1: /proc/sys/kernel/swsusp the only tuning interface
+ * 2: Initial version of this file
+ * 3: Removed KDB parameter. 
+ *    Added checkpage parameter (for checking checksum of a page over time).
+ * 4: Added entry for maximum granularity in splash screen progress bar.
+ *    (Progress bar is slow, but the right setting will vary with disk & processor
+ *    speed and the user's tastes).
+ * 5: Added enable_escape to control ability to cancel aborting by pressing
+ *    ESC key.
+ */
+
+#define SWSUSP_PROC_C
+
+int swsusp_proc_version = 5;
+
+#include "common.h"
+#include <linux/proc_fs.h>
+
+extern int swsusp_default_console_level;
+extern unsigned long checkpage;
+extern int bar_granularity_limit;
+
+struct proc_param {
+	int key;
+	char * filename;
+	void * variable;
+	int bit;
+	int permissions; /* file permissions */
+};
+
+#define PROC_WRITEONLY 0200
+#define PROC_READONLY 0400
+#define PROC_RW 0600
+
+/*
+ * There's nothing special about the 'key' field. It just needs to match
+ * the entry you want run in the case statement below. I've made them
+ * increasing numbers simply to make the pattern clearer.
+ * 1-5 are straight integers.
+ * 10  is the activation case.
+ * 20+ are setting/reading bits.
+ */
+static struct proc_param proc_params[] = {
+	{ 1, "version", NULL, 0, PROC_READONLY },
+	{ 2, "last_result", &swsusp_result, 0, PROC_READONLY },
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+	{ 3, "debug_sections", &swsusp_debug_state, 0, PROC_RW },
+#endif
+	{ 4, "default_console_level", &swsusp_default_console_level, 0, PROC_RW },
+	{ 5, "image_size_limit", &image_size_limit, 0, PROC_RW },
+	{ 6, "async_io_limit", &max_async_ios, 0, PROC_RW },
+	{ 7, "interface_version", &swsusp_proc_version, 0, PROC_READONLY },
+#ifdef CONFIG_SOFTWARE_SUSPEND_CHECKSUM
+	{ 8, "checkpage", &checkpage, 0, PROC_RW },
+#endif
+#ifdef CONFIG_FBCON_SPLASHSCREEN
+	{ 9, "progressbar_granularity_limit", &bar_granularity_limit, 0, PROC_RW },
+#endif
+	{ 10, "activate", NULL, 0, PROC_WRITEONLY },
+	{ 20, "reboot", &swsusp_action, SUSPEND_REBOOT, PROC_RW },
+	{ 21, "no_output", &swsusp_action, SUSPEND_NO_OUTPUT, PROC_RW },
+	{ 22, "pause_between_steps", &swsusp_action, SUSPEND_PAUSE, PROC_RW },
+	{ 23, "slow", &swsusp_action, SUSPEND_SLOW, PROC_RW },
+	{ 24, "beeping", &swsusp_action, SUSPEND_BEEP, PROC_RW },
+	{ 25, "no_async_reads", &swsusp_action, SUSPEND_NO_ASYNC_READS, PROC_RW },
+	{ 26, "no_async_writes", &swsusp_action, SUSPEND_NO_ASYNC_WRITES, PROC_RW },
+	{ 27, "nopageset2", &swsusp_action, SUSPEND_NOPAGESET2, PROC_RW },
+	{ 28, "log_everything", &swsusp_action, SUSPEND_LOGALL, PROC_RW },
+#ifdef CONFIG_SOFTWARE_SUSPEND_COMPRESSION
+	{ 29, "disable_compression", &swsusp_action, SUSPEND_NO_COMPRESSION, PROC_RW },
+#endif
+	{ 30, "enable_escape", &swsusp_action, SUSPEND_CAN_CANCEL, PROC_RW },
+};
+
+static struct proc_dir_entry *swsusp_dir, *swsusp_files[sizeof(proc_params) / sizeof(struct proc_param)];
+static struct proc_dir_entry *compat_entry, *compat_parent;
+
+int swsusp_read_proc(char * page, char ** start, off_t off, int count,
+		int *eof, void *data)
+{
+	int len = 0;
+	struct proc_param * index = (struct proc_param *) data;
+	
+	switch (index->key) {
+		case 1:
+			len = sprintf(page, "%s\n", swsusp_version);
+			break;
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+		case 9:
+			len = sprintf(page, "%ld\n", *((unsigned long *) index->variable));
+			break;
+		case 8:
+			len = sprintf(page, "%lx\n", *((unsigned long *) index->variable));
+			break;
+		case 20:
+		case 21:
+		case 22:
+		case 23:
+		case 24:
+		case 25:
+		case 26:
+		case 27:
+		case 28:
+		case 29:
+		case 30:
+			len = sprintf(page, "%d\n", test_bit(index->bit, ((unsigned long *) index->variable))!=0);
+			break;
+	}
+
+	*eof = 1;
+	return len;
+}
+
+int swsusp_read_compat_proc(char * page, char ** start, off_t off, int count,
+		int *eof, void *data)
+{
+	int len = 0;
+
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+	len = sprintf(page, "%ld %ld %ld %d %d %d\n",
+			swsusp_result,
+			swsusp_action,
+			swsusp_debug_state,
+			swsusp_default_console_level,
+			image_size_limit,
+			max_async_ios);
+#else
+	len = sprintf(page, "%ld %ld %d %d\n",
+			swsusp_result,
+			swsusp_action,
+			image_size_limit,
+			max_async_ios);
+#endif
+	*eof = 1;
+	return len;
+}
+int swsusp_write_proc(struct file *file, const char * buffer,
+		unsigned long count, void * data)
+{
+	struct proc_param * index = (struct proc_param *) data;
+	char * buf = (char *) get_zeroed_page(GFP_ATOMIC);
+	
+	if (!buf)
+		return -ENOMEM;
+	
+	if (count > PAGE_SIZE)
+		count = PAGE_SIZE;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+	buf[count] = 0;
+
+	switch (index->key) {
+		case 1:
+		case 2:
+			break;
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+		case 8:
+		case 9:
+			if (buf)
+				*((unsigned long *) index->variable) = simple_strtoul(buf, NULL, 0);
+			break;
+		case 10:
+			software_suspend_pending();
+			break;
+		case 20:
+		case 21:
+		case 22:
+		case 23:
+		case 24:
+		case 25:
+		case 26:
+		case 27:
+		case 28:
+		case 29:
+		case 30:
+			{
+			int value = simple_strtoul(buf, NULL, 0);
+			if (value)
+				set_bit(index->bit, ((unsigned long *) index->variable));
+			else 
+				clear_bit(index->bit, ((unsigned long *) index->variable));
+			}
+			break;
+	}
+
+	free_pages((unsigned long) buf, 0);
+	return count;
+}
+
+int swsusp_write_compat_proc(struct file *file, const char * buffer,
+		unsigned long count, void * data)
+{
+	char * buf = (char *) get_zeroed_page(GFP_ATOMIC), *lastbuf;
+	int i;
+	unsigned long nextval;
+	
+	if (!buf)
+		return -ENOMEM;
+	
+	if (count > PAGE_SIZE)
+		count = PAGE_SIZE;
+
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+	for (i = 0; i < 6; i++) {
+		if (!buf)
+			break;
+		lastbuf = buf;
+		nextval = simple_strtoul(buf, &buf, 0);
+		if (buf == lastbuf)
+			break;
+		switch (i) {
+			case 0:
+				swsusp_result = nextval;
+				break;
+			case 1:
+				swsusp_action = nextval;
+#ifndef CONFIG_SOFTWARE_SUSPEND_DEBUG
+				i++;
+#endif
+				break;
+			case 2:
+				swsusp_debug_state = nextval;
+				break;
+			case 3:
+				swsusp_default_console_level = nextval;
+				break;
+			case 4:
+				image_size_limit = nextval;
+				break;
+			case 5:
+				max_async_ios = nextval;
+				break;
+
+		}
+		buf++;
+		while (*buf == ' ')
+			buf++;
+	}
+	buf[count] = 0;
+	free_pages((unsigned long) buf, 0);
+	return count;
+}
+
+
+/* Based on remove_proc_entry */
+
+struct proc_dir_entry * find_proc_dir_entry(const char *name, struct proc_dir_entry *parent)
+{
+	struct proc_dir_entry **p;
+	int len;
+
+	len = strlen(name);
+	for (p = &parent->subdir; *p; p=&(*p)->next ) {
+		if (proc_match(len, name, *p)) {
+			return *p;
+		}
+	}
+	return NULL;
+}
+
+int swsusp_init_proc(void)
+{
+	int i;
+	int numfiles = sizeof(proc_params) / sizeof(struct proc_param);
+	
+	swsusp_dir = proc_mkdir("swsusp", NULL);
+	
+	if (swsusp_dir == NULL) {
+		printk(KERN_ERR "Failed to create /proc/swsusp.\n");
+		return 1;
+	}
+
+	for (i=0; i<numfiles; i++) {
+		swsusp_files[i] = create_proc_entry(proc_params[i].filename,
+				proc_params[i].permissions, 
+				swsusp_dir);
+		swsusp_files[i]->data = &proc_params[i];
+		swsusp_files[i]->read_proc = swsusp_read_proc;
+		swsusp_files[i]->write_proc = swsusp_write_proc;
+	}
+
+	compat_parent = find_proc_dir_entry("sys", &proc_root);
+	if (compat_parent) {
+		compat_parent = find_proc_dir_entry("kernel", compat_parent);
+		if (compat_parent) {
+			compat_entry = create_proc_entry("swsusp",
+				0x600, 
+				compat_parent);
+			compat_entry->read_proc = swsusp_read_compat_proc;
+			compat_entry->write_proc = swsusp_write_compat_proc;
+		}
+	}
+
+	return 0;
+}
+
+int swsusp_cleanup_proc(void)
+{
+	int i;
+	int numfiles = sizeof(proc_params) / sizeof(struct proc_param);
+	
+	for (i = 0; i < numfiles; i++)
+		remove_proc_entry(proc_params[i].filename, swsusp_dir);
+	return 0;
+	
+	if (compat_parent && compat_entry)
+		remove_proc_entry("swsusp", compat_parent);
+}
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/suspend/ui.c m1/kernel/suspend/ui.c
--- m2/kernel/suspend/ui.c	1970-01-01 01:00:00.000000000 +0100
+++ m1/kernel/suspend/ui.c	2003-07-31 17:27:37.000000000 +0200
@@ -0,0 +1,482 @@
+
+#define SWSUSP_IO_C
+
+#include "common.h"
+
+extern void reset_terminal(int currcons, int do_clear);
+extern void hide_cursor(int currcons);
+
+#ifdef DEFAULT_SUSPEND_CONSOLE
+static int barwidth = 0, barposn = -1, newbarposn = 0;
+extern int swsusp_default_console_level;
+#endif
+#ifdef CONFIG_VT
+static int orig_fgconsole;
+static char print_buf[1024];	/* Same as printk - should be safe */
+#endif
+#ifdef DEFAULT_SUSPEND_CONSOLE
+static int orig_kmsg;
+#endif
+#define cond_console_print(chars, count) \
+	if (suspend_console == fg_console) vt_console_print((struct console *) NULL, chars, count)
+#undef video_num_columns
+#define video_num_columns	(vc_cons[suspend_console].d->vc_cols)
+#undef video_num_lines
+#define video_num_lines		(vc_cons[suspend_console].d->vc_rows)
+
+extern struct kbd_struct kbd_table[MAX_NR_CONSOLES];
+
+
+/* 
+ * Console being used for suspend - may not be default if splash screen 
+ * displayed 
+ */
+int suspend_console = 0;	
+
+static char lastheader[512];
+static int nice_display = 0;
+static int lastloglevel = 0;
+static int lastmessagelen = 0;
+static int lastshiftstate = 0;
+
+/* ------------------  Splash screen defines  -------------------------- */
+char * currentmessage;
+#if defined(CONFIG_FBCON_SPLASHSCREEN)
+extern struct display fb_display[MAX_NR_CONSOLES];
+int splash_is_on(int consolenr)
+{
+	struct display *p = &fb_display[consolenr];
+	if (p && p->splash_data)
+		return ((p->splash_data->splash_state & 1) == 1);
+	return 0;
+}
+int bar_granularity_limit = 0; /* 0 = no limit */
+#endif
+
+void abort_suspend(const char *fmt, ...)
+{
+	va_list args;
+	int printed_len = 0;
+
+	if (!TEST_RESULT_STATE(SUSPEND_ABORTED)) {
+		if ((!TEST_RESULT_STATE(SUSPEND_ABORT_REQUESTED)) && (!NO_OUTPUT_OR_PAUSING)) {
+			int locked = (spin_is_locked(&suspend_pagedir_lock));
+			if (locked)
+				swsusp_spin_unlock_irqrestore(&suspend_pagedir_lock, pagedirflags);
+			va_start(args, fmt);
+			printed_len = vsnprintf(print_buf, sizeof(print_buf), fmt, args);
+			va_end(args);
+			printed_len = sprintf(print_buf + printed_len,
+					" (Press SHIFT to continue)");
+			prepare_status(1, 1, print_buf);
+			beepERR;
+			/* 
+			 * Make sure message seen - wait for shift to be
+			 * released if being pressed 
+			 */
+			while ((shift_state & (1 << KG_SHIFT)))
+				yield();
+			while (!(shift_state & (1 << KG_SHIFT)))
+				yield();
+			lastshiftstate = shift_state;
+			if (locked)
+				swsusp_spin_lock_irqsave(&suspend_pagedir_lock, pagedirflags);
+		}
+		/* Turn on aborting flag */
+		SET_RESULT_STATE(SUSPEND_ABORTED);
+	}
+}
+
+void say_if_loglevel_changed(void)
+{
+	if (console_loglevel != lastloglevel) {
+		lastloglevel = console_loglevel;
+		printnolog(0, console_loglevel, 0, "Switched to console loglevel %d.\n", console_loglevel);
+	}
+}
+
+
+/*
+ * This function is intended to do the same job as printk, but without actually
+ * logging what is printed. The point is to be able to get debugging info on
+ * screen without filling the logs with "1/534. ^M 2/534^M. 3/534^M"
+ *
+ * It may be called from an interrupt context - can't sleep!
+ */
+//void printnolog(int restartline, const char *fmt, ...)
+void printnolog(int mask, int level, int restartline, const char *fmt, ...)
+{
+#if defined(DEFAULT_SUSPEND_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND_DEBUG)
+	va_list args;
+	int printed_len = 0;
+
+	if (console_loglevel < level)
+		return;
+
+	if (!CHECKMASK(mask))
+		return;
+
+	if (nice_display) {
+		nice_display = 0;
+		reset_terminal(suspend_console, 1);
+	}
+	
+	say_if_loglevel_changed();
+
+	if (restartline) {
+		if (SUSPEND_LOGALL)
+			printk("\n");
+		else
+			printed_len = vsnprintf(print_buf + printed_len, sizeof(print_buf) - printed_len, "\r", NULL);
+	}
+
+	va_start(args, fmt);
+	printed_len += vsnprintf(print_buf + printed_len, sizeof(print_buf) - printed_len, fmt, args);
+	va_end(args);
+
+	if (SUSPEND_LOGALL) 
+		printk(print_buf);
+	else
+		cond_console_print(print_buf, printed_len);
+#endif
+}
+
+/*
+ * This function is a wrapper around printk. It adds the log level of
+ * the message to the front, so we can use Sys-Rq to change the detail
+ * displayed at runtime.
+ */
+void printlog(int mask, int level, const char *fmt, ...)
+{
+#if defined(DEFAULT_SUSPEND_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND_DEBUG)
+	va_list args;
+	int printed_len = 0;
+
+	if (console_loglevel < level)
+		return;
+
+	if (!CHECKMASK(mask))
+		return;
+
+	if (nice_display) {
+		nice_display = 0;
+		reset_terminal(suspend_console, 1);
+	}
+	
+	say_if_loglevel_changed();
+
+	va_start(args, fmt);
+	printed_len += vsnprintf(print_buf + printed_len, sizeof(print_buf) - printed_len, fmt, args);
+	va_end(args);
+
+	printk(print_buf);
+#endif
+}
+
+void prepare_status(int printalways, int clearbar, const char *fmt, ...)
+{
+#if defined(DEFAULT_SUSPEND_CONSOLE)
+	unsigned char posn[2];
+	va_list args;
+	int message_len = 0;
+
+	if (NO_OUTPUT_OR_PAUSING)
+		return;
+
+	if (fmt) {
+		va_start(args, fmt);
+		message_len = vsnprintf(lastheader, 512, fmt, args);
+		va_end(args);
+	}
+
+	if (console_loglevel >= SUSPEND_ERROR) {
+		if (nice_display) {
+			/* Clear the screen */
+			reset_terminal(suspend_console, 1);
+			hide_cursor(suspend_console);
+			nice_display = 0;
+		}
+		say_if_loglevel_changed();
+
+		if (printalways)
+			printk("** %s\n", lastheader);
+		return;
+	}
+	
+	if (!nice_display) {
+		reset_terminal(suspend_console, 1);
+		nice_display = 1;
+		lastloglevel = console_loglevel;
+	}
+
+	hide_cursor(suspend_console);
+
+	/* Print version */
+	posn[0] = (unsigned char) (0);
+	posn[1] = (unsigned char) (video_num_lines);
+	putconsxy(suspend_console, posn);
+	cond_console_print(name_swsusp, strlen(name_swsusp));
+
+	/* Print header */
+	posn[0] = (unsigned char) ((video_num_columns - 29) / 2);
+	posn[1] = (unsigned char) ((video_num_lines / 3) -4);
+	putconsxy(suspend_console, posn);
+
+	if (now_resuming) {
+		cond_console_print(console_resume, strlen(console_resume));
+	} else {
+		cond_console_print(console_suspend, strlen(console_suspend));
+	}
+		
+	/* Print action */
+	posn[1] = (unsigned char) (video_num_lines / 3);
+	if (lastmessagelen) {
+		posn[0] = (unsigned char) ((video_num_columns - lastmessagelen) / 2);
+		putconsxy(suspend_console, posn);
+	
+		/* Blank out previous contents of line - assumes text length <= bar width */
+		for (barposn = 0; barposn < lastmessagelen; barposn++) 
+			cond_console_print(" ", 1);
+		}
+
+	posn[0] = (unsigned char) ((video_num_columns - message_len) / 2);
+	putconsxy(suspend_console, posn);
+	cond_console_print(lastheader, message_len);
+	lastmessagelen = message_len;
+	
+#if defined(CONFIG_FBCON_SPLASHSCREEN)
+	if (SPLASH_IS_ON(suspend_console)) {
+		/* proc interface ensures bar_granularity_limit >= 0 */
+		if (bar_granularity_limit)
+			barwidth = MIN(fb_splash_progress[2], bar_granularity_limit);
+		else
+			barwidth = fb_splash_progress[2];
+	} else 
+#endif
+	{
+		/* Draw left bracket of progress bar. */
+		posn[0] = (unsigned char) (video_num_columns / 4);
+		posn[1]++;
+		putconsxy(suspend_console, posn);
+		cond_console_print("[", 1);
+
+		/* Draw right bracket of progress bar. */
+		posn[0] = (unsigned char) (video_num_columns - (video_num_columns / 4) - 1);
+		putconsxy(suspend_console, posn);
+		cond_console_print("]", 1);
+	
+		barwidth = (video_num_columns - 2 * (video_num_columns / 4) - 2);
+	}
+
+	if (clearbar) {
+		if (SPLASH_IS_ON(suspend_console))
+			fb_splash_set_progress(suspend_console, 0, 1, 1);
+		else {
+			/* Position at start of progress */
+			posn[0] = (unsigned char) (video_num_columns / 4 + 1);
+			putconsxy(suspend_console, posn);
+
+			/* Clear bar */
+			for (barposn = 0; barposn < barwidth; barposn++)
+				cond_console_print(" ", 1);
+			putconsxy(suspend_console, posn);
+		}
+	}
+
+	barposn = 0;
+	hide_cursor(suspend_console);
+#endif
+}
+
+/* NULL message does not mean that any previous message is erased! */
+/* Returns next value where status needs to be updated */
+int update_status(unsigned long value, unsigned long maximum, const char *fmt, ...)
+{
+	unsigned long next_update = 0;
+#if defined(DEFAULT_SUSPEND_CONSOLE)
+	unsigned char posn[2];
+	va_list args;
+	int message_len = 0;
+
+	if (NO_OUTPUT_OR_PAUSING || (!maximum) || (!barwidth))
+		return maximum;
+
+	newbarposn = (int) (value * barwidth / maximum);
+	
+	if (newbarposn < barposn) {
+		barposn = 0;
+		fb_splash_set_progress(suspend_console, value, maximum, 0);
+	}
+
+	next_update = (newbarposn + 1) * maximum / barwidth;
+
+	if (value < 0)
+		value = 0;
+	if (value > maximum)
+		value = maximum;
+
+	if (console_loglevel >= SUSPEND_ERROR) {
+		if (nice_display) {
+			/* Clear the screen */
+			reset_terminal(suspend_console, 1);
+			hide_cursor(suspend_console);
+			nice_display = 0;
+		}
+		say_if_loglevel_changed();
+		if ((SPLASH_IS_ON(suspend_console)) && (newbarposn != barposn)) {
+			fb_splash_set_progress(suspend_console, value, maximum, 0);
+			barposn = newbarposn;
+		}
+		return next_update;
+	}
+	
+	if (!nice_display)
+		prepare_status(0, 0, lastheader);
+
+	lastloglevel = console_loglevel;
+
+	if (SPLASH_IS_ON(suspend_console)) {
+		if (newbarposn != barposn)
+			fb_splash_set_progress(suspend_console, value, maximum, 0);
+	} else {
+		posn[1] = (unsigned char) ((video_num_lines / 3) + 1);
+
+		/* Clear bar if at start */
+		if (!barposn) {
+			posn[0] = (unsigned char) (video_num_columns / 4 + 1);
+			putconsxy(suspend_console, posn);
+			for (; barposn < barwidth; barposn++)
+				cond_console_print(" ", 1);
+			barposn = 0;
+		}
+		posn[0] = (unsigned char) (video_num_columns / 4 + 1 + barposn);
+		putconsxy(suspend_console, posn);
+
+		for (; barposn < newbarposn; barposn++)
+			cond_console_print("-", 1);
+	}
+
+	/* Don't print string in progress bar on loglevel 1 */
+	if ((fmt) && (console_loglevel)) {
+		va_start(args, fmt);
+		message_len = vsnprintf(print_buf, sizeof(print_buf), fmt, args);
+		va_end(args);
+
+		if (message_len) {
+			posn[0] = (unsigned char) ((video_num_columns - message_len) / 2);
+			posn[1] = (unsigned char) ((video_num_lines / 3) + 1);
+			putconsxy(suspend_console, posn);
+			cond_console_print(print_buf, message_len);
+		}
+	}
+
+	barposn = newbarposn;
+	hide_cursor(suspend_console);
+#else
+	next_update = maximum;
+#endif
+	return next_update;
+}
+
+void request_abort_suspend(void)
+{
+	if (TEST_RESULT_STATE(SUSPEND_ABORTED) || now_resuming) 
+		return;
+
+	prepare_status(1, 1, "   --- ESCAPE PRESSED : ABORTING PROCESS ---");
+	SET_RESULT_STATE(SUSPEND_ABORTED);
+	SET_RESULT_STATE(SUSPEND_ABORT_REQUESTED);
+	abort_suspend("Alt key pressed.\n");
+}
+#define SHIFT_AND_ALT (1 << KG_ALT | 1 << KG_SHIFT)
+
+void check_shift_keys(int pause, char * message)
+{
+#ifdef DEFAULT_SUSPEND_CONSOLE 
+	int was_locked = (spin_is_locked(&suspend_pagedir_lock));
+
+	if (was_locked)
+		swsusp_spin_unlock_irqrestore(&suspend_pagedir_lock, pagedirflags);
+
+	yield();
+
+	if (NO_OUTPUT_OR_PAUSING)
+		goto done_checking;
+
+	/* Don't pause if just toggled */
+	if (((TEST_ACTION_STATE(SUSPEND_PAUSE) && pause) || 
+	     (shift_state & (1 << KG_CTRL))) 
+	    && (console_loglevel > 1)) { 
+		prepare_status(1, 0, "%sPress SHIFT to continue.\n", message ? message : "");
+		while ((shift_state & (1 << KG_SHIFT | 1 << KG_CTRL)) &&
+				(TEST_ACTION_STATE(SUSPEND_PAUSE)) &&
+				(!TEST_RESULT_STATE(SUSPEND_ABORTED)))
+			yield();
+		while ((!(shift_state & (1 << KG_SHIFT | 1 << KG_CTRL))) &&
+				(TEST_ACTION_STATE(SUSPEND_PAUSE)) &&
+				(!TEST_RESULT_STATE(SUSPEND_ABORTED)))
+			yield();
+	}
+done_checking:
+	lastshiftstate = shift_state;
+	if (was_locked)
+		swsusp_spin_lock_irqsave(&suspend_pagedir_lock, pagedirflags);
+#endif
+}
+
+int prepare_suspend_console(void)
+{
+
+	if (TEST_ACTION_STATE(SUSPEND_NO_OUTPUT))
+		/* No output should be produced. */ 
+		return 0;
+
+	orig_loglevel = console_loglevel;
+	if (!now_resuming)
+		console_loglevel = swsusp_default_console_level;
+
+#ifdef CONFIG_VT_CONSOLE
+	orig_fgconsole = fg_console;
+
+	if ((orig_fgconsole != DEFAULT_SUSPEND_CONSOLE) && (!SPLASH_IS_ON(fg_console))) {
+		suspend_console = DEFAULT_SUSPEND_CONSOLE;
+		if (vc_allocate(DEFAULT_SUSPEND_CONSOLE))
+		  /* we can't have a free VC for now. Too bad,
+		   * we don't want to mess the screen for now. */
+			return 1;
+
+		set_console(DEFAULT_SUSPEND_CONSOLE);
+		if (vt_waitactive(DEFAULT_SUSPEND_CONSOLE)) {
+			printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, "Can't switch virtual consoles.");
+			return 1;
+		}
+	} else 
+		suspend_console = fg_console;
+	reset_terminal(suspend_console, 1);
+	orig_kmsg = kmsg_redirect;
+	kmsg_redirect = suspend_console;
+	prepare_status(0, 0, "");
+#endif
+	return 0;
+}
+
+void restore_console(void)
+{
+
+	if (TEST_ACTION_STATE(SUSPEND_NO_OUTPUT))
+		return;
+
+	console_loglevel = orig_loglevel;
+	reset_terminal(suspend_console, 1);
+	
+	if ((orig_fgconsole != suspend_console) && (!SPLASH_IS_ON(suspend_console))) {
+		set_console(orig_fgconsole);
+		if (vt_waitactive(orig_fgconsole)) {
+			printlog(SUSPEND_ANY_SECTION, SUSPEND_ERROR, "Can't switch virtual consoles.");
+			return;
+		}
+	}
+	
+	kmsg_redirect = orig_kmsg;
+	return;
+}
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/kernel/sys.c m1/kernel/sys.c
--- m2/kernel/sys.c	2003-07-30 18:13:43.000000000 +0200
+++ m1/kernel/sys.c	2003-07-31 17:27:37.000000000 +0200
@@ -4,6 +4,7 @@
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/utsname.h>
@@ -342,6 +343,16 @@ asmlinkage long sys_reboot(int magic1, i
 		machine_restart(buffer);
 		break;
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	case LINUX_REBOOT_CMD_SW_SUSPEND:
+		if(!software_suspend_enabled)
+			return -EAGAIN;
+		
+		software_suspend_pending();
+		do_exit(0);
+		break;
+#endif
+
 	default:
 		unlock_kernel();
 		return -EINVAL;
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/lib/Config.in m1/lib/Config.in
--- m2/lib/Config.in	2003-07-30 18:13:43.000000000 +0200
+++ m1/lib/Config.in	2003-07-31 17:32:06.000000000 +0200
@@ -11,6 +11,7 @@ tristate 'CRC32 functions' CONFIG_CRC32
 #
 if [ "$CONFIG_CRAMFS" = "y" -o \
      "$CONFIG_PPP_DEFLATE" = "y" -o \
+     "$CONFIG_SOFTWARE_SUSPEND_COMPRESSION" = "y" -o \
      "$CONFIG_CRYPTO_DEFLATE" = "y" -o \
      "$CONFIG_JFFS2_FS" = "y" -o \
      "$CONFIG_ZISOFS_FS" = "y" ]; then
@@ -29,6 +30,7 @@ fi
 
 if [ "$CONFIG_PPP_DEFLATE" = "y" -o \
      "$CONFIG_CRYPTO_DEFLATE" = "y" -o \
+     "$CONFIG_SOFTWARE_SUSPEND_COMPRESSION" = "y" -o \
      "$CONFIG_JFFS2_FS" = "y" ]; then
    define_tristate CONFIG_ZLIB_DEFLATE y
 else
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/MAINTAINERS m1/MAINTAINERS
--- m2/MAINTAINERS	2003-07-30 18:13:26.000000000 +0200
+++ m1/MAINTAINERS	2003-07-31 17:27:37.000000000 +0200
@@ -1643,6 +1643,13 @@ M:	neilb@cse.unsw.edu.au
 L:	linux-raid@vger.kernel.org
 S:	Maintained
 
+SOFTWARE SUSPEND:
+P:	Nigel Cunningham
+M:	ncunningham@clear.net.nz
+L:	http://lister.fornax.hu/mailman/listinfo/swsusp
+W:	http://swsusp.sf.net/
+S:	Maintained
+
 SONIC NETWORK DRIVER
 P:	Thomas Bogendoerfer
 M:	tsbogend@alpha.franken.de
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/mm/filemap.c m1/mm/filemap.c
--- m2/mm/filemap.c	2003-07-30 18:13:43.000000000 +0200
+++ m1/mm/filemap.c	2003-07-31 17:27:37.000000000 +0200
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/mm.h>
 #include <linux/iobuf.h>
+#include <linux/suspend.h>
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -79,6 +80,9 @@ static void add_page_to_hash_queue(struc
 		next->pprev_hash = &page->next_hash;
 	if (page->buffers)
 		PAGE_BUG(page);
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	last_suspend_cache_page = page;
+#endif
 	atomic_inc(&page_cache_size);
 }
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/mm/page_alloc.c m1/mm/page_alloc.c
--- m2/mm/page_alloc.c	2002-11-29 00:53:15.000000000 +0100
+++ m1/mm/page_alloc.c	2003-07-31 17:27:37.000000000 +0200
@@ -20,6 +20,7 @@
 #include <linux/pagemap.h>
 #include <linux/bootmem.h>
 #include <linux/slab.h>
+#include <linux/suspend.h>
 #include <linux/module.h>
 
 int nr_swap_pages;
@@ -98,8 +99,10 @@ static void __free_pages_ok (struct page
 
 	if (page->buffers)
 		BUG();
-	if (page->mapping)
+	if (page->mapping) {
+	  	printk("pagebug: %p\n",page);
 		BUG();
+	}
 	if (!VALID_PAGE(page))
 		BUG();
 	if (PageLocked(page))
@@ -330,7 +333,9 @@ struct page * __alloc_pages(unsigned int
 	zone_t **zone, * classzone;
 	struct page * page;
 	int freed;
-
+#if CONFIG_SOFTWARE_SUSPEND
+	static unsigned int loopcount;
+#endif	
 	zone = zonelist->zones;
 	classzone = *zone;
 	if (classzone == NULL)
@@ -374,7 +379,9 @@ struct page * __alloc_pages(unsigned int
 	}
 
 	/* here we're in the low on memory slow path */
-
+#if CONFIG_SOFTWARE_SUSPEND
+	loopcount=0;
+#endif
 rebalance:
 	if (current->flags & (PF_MEMALLOC | PF_MEMDIE)) {
 		zone = zonelist->zones;
@@ -390,6 +397,21 @@ rebalance:
 		return NULL;
 	}
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	if(gfp_mask & __GFP_FAST) {
+/* when using memeat, we ask for all pages that are really free.
+   800 calls to reschedule should be sufficient to recall all of them since
+   when a page can be found, it is after only one reschedule.
+   Actually I consider this as a bug of alloc_pages, since allocating a
+   page should not hang in an endless loop when it is clear that no
+   memory is available (cbd) */	  
+		loopcount++;
+		//if(!(loopcount%10))
+		//	printk("_");
+		if(loopcount > 5)
+			return NULL;
+	}
+#endif
 	/* Atomic allocations - we can't balance anything */
 	if (!(gfp_mask & __GFP_WAIT))
 		return NULL;
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/mm/page_io.c m1/mm/page_io.c
--- m2/mm/page_io.c	2002-11-29 00:53:15.000000000 +0100
+++ m1/mm/page_io.c	2003-07-31 17:27:37.000000000 +0200
@@ -33,7 +33,7 @@
  * that shared pages stay shared while being swapped.
  */
 
-static int rw_swap_page_base(int rw, swp_entry_t entry, struct page *page)
+int rw_swap_page_base(int rw, swp_entry_t entry, struct page *page)
 {
 	unsigned long offset;
 	int zones[PAGE_SIZE/512];
@@ -82,12 +82,19 @@ static int rw_swap_page_base(int rw, swp
  *  - it's marked as being swap-cache
  *  - it's associated with the swap inode
  */
+#if 0
+extern long suspend_device;
+#endif
 void rw_swap_page(int rw, struct page *page)
 {
 	swp_entry_t entry;
 
 	entry.val = page->index;
 
+#if 0
+	if (suspend_device)
+		panic("I refuse to corrupt memory/swap.");
+#endif
 	if (!PageLocked(page))
 		PAGE_BUG(page);
 	if (!PageSwapCache(page))
@@ -101,7 +108,7 @@ void rw_swap_page(int rw, struct page *p
  * Therefore we can't use it.  Later when we can remove the need for the
  * lock map and we can reduce the number of functions exported.
  */
-void rw_swap_page_nolock(int rw, swp_entry_t entry, char *buf)
+void __rw_swap_page_nolock(int rw, swp_entry_t entry, char *buf, int free)
 {
 	struct page *page = virt_to_page(buf);
 	
@@ -113,8 +120,10 @@ void rw_swap_page_nolock(int rw, swp_ent
 	page->mapping = &swapper_space;
 	if (rw_swap_page_base(rw, entry, page))
 		lock_page(page);
-	if (!block_flushpage(page, 0))
-		PAGE_BUG(page);
+	if(free) {
+		if (!block_flushpage(page, 0))
+			PAGE_BUG(page);
+	}
 	page->mapping = NULL;
 	UnlockPage(page);
 }
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/mm/shmem.c m1/mm/shmem.c
--- m2/mm/shmem.c	2003-07-30 18:13:43.000000000 +0200
+++ m1/mm/shmem.c	2003-07-31 17:27:37.000000000 +0200
@@ -538,7 +538,7 @@ static int shmem_writepage(struct page *
 	if (info->flags & VM_LOCKED)
 		return fail_writepage(page);
 getswap:
-	swap = get_swap_page();
+	swap = get_swap_page(0);
 	if (!swap.val)
 		return fail_writepage(page);
 
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/mm/swapfile.c m1/mm/swapfile.c
--- m2/mm/swapfile.c	2003-07-30 18:13:43.000000000 +0200
+++ m1/mm/swapfile.c	2003-07-31 17:27:37.000000000 +0200
@@ -14,6 +14,7 @@
 #include <linux/vmalloc.h>
 #include <linux/pagemap.h>
 #include <linux/shm.h>
+#include <linux/suspend-debug.h>
 
 #include <asm/pgtable.h>
 
@@ -96,7 +97,7 @@ static inline int scan_swap_map(struct s
 	return 0;
 }
 
-swp_entry_t get_swap_page(void)
+swp_entry_t get_swap_page(int must_be_partition)
 {
 	struct swap_info_struct * p;
 	unsigned long offset;
@@ -113,7 +114,8 @@ swp_entry_t get_swap_page(void)
 
 	while (1) {
 		p = &swap_info[type];
-		if ((p->flags & SWP_WRITEOK) == SWP_WRITEOK) {
+		if (((p->flags & SWP_WRITEOK) == SWP_WRITEOK) &&
+		    ((!must_be_partition) || (p->swap_device))) {
 			swap_device_lock(p);
 			offset = scan_swap_map(p);
 			swap_device_unlock(p);
@@ -141,6 +143,10 @@ swp_entry_t get_swap_page(void)
 	}
 out:
 	swap_list_unlock();
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+	if (suspend_task)
+		printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 0, "[Get SWAP %lx]", entry.val);
+#endif
 	return entry;
 }
 
@@ -202,7 +208,13 @@ static int swap_entry_free(struct swap_i
 			if (offset > p->highest_bit)
 				p->highest_bit = offset;
 			nr_swap_pages++;
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+		} else
+			if (suspend_task)
+				printlog(SUSPEND_SWAP, SUSPEND_VERBOSE, "[Free SWAP %x/%lx entry's count not zero!]\n", p->swap_device, offset);
+#else
 		}
+#endif
 	}
 	return count;
 }
@@ -217,6 +229,10 @@ void swap_free(swp_entry_t entry)
 
 	p = swap_info_get(entry);
 	if (p) {
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+		if (suspend_task)
+			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 0, "[Free SWAP %lx]", entry);
+#endif
 		swap_entry_free(p, SWP_OFFSET(entry));
 		swap_info_put(p);
 	}
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/mm/vmscan.c m1/mm/vmscan.c
--- m2/mm/vmscan.c	2002-11-29 00:53:15.000000000 +0100
+++ m1/mm/vmscan.c	2003-07-31 17:27:37.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/smp_lock.h>
 #include <linux/pagemap.h>
 #include <linux/init.h>
+#include <linux/suspend.h>
 #include <linux/highmem.h>
 #include <linux/file.h>
 
@@ -131,7 +132,7 @@ drop_pte:
 	 * page with that swap entry.
 	 */
 	for (;;) {
-		entry = get_swap_page();
+		entry = get_swap_page(0);
 		if (!entry.val)
 			break;
 		/* Add it to the swap cache and mark it dirty
@@ -345,6 +346,9 @@ static int shrink_cache(int nr_pages, zo
 	while (--max_scan >= 0 && (entry = inactive_list.prev) != &inactive_list) {
 		struct page * page;
 
+		if (unlikely(current->flags & PF_FREEZE))
+			refrigerator(PF_IOTHREAD);
+
 		if (unlikely(current->need_resched)) {
 			spin_unlock(&pagemap_lru_lock);
 			__set_current_state(TASK_RUNNING);
@@ -604,6 +608,38 @@ int try_to_free_pages_zone(zone_t *class
 	return 0;
 }
 
+int try_to_free_pages_zone_swsusp(zone_t *classzone, unsigned int gfp_mask, int priority, int nr_pages)
+{
+	gfp_mask = pf_gfp_mask(gfp_mask);
+	do {
+		nr_pages = shrink_caches(classzone, priority, gfp_mask, nr_pages);
+		if (nr_pages <= 0)
+			return 1;
+	} while (--priority);
+
+	/* No out of memory call for us! */
+	return 0;
+}
+
+int try_to_free_pages_swsusp(unsigned int gfp_mask, int amount_needed)
+{
+	pg_data_t *pgdat;
+	zonelist_t *zonelist;
+	unsigned long pf_free_pages;
+	int error = 0;
+
+	pf_free_pages = current->flags & PF_FREE_PAGES;
+	current->flags &= ~PF_FREE_PAGES;
+
+	for_each_pgdat(pgdat) {
+		zonelist = pgdat->node_zonelists + (gfp_mask & GFP_ZONEMASK);
+		error |= try_to_free_pages_zone_swsusp(zonelist->zones[0], gfp_mask, 1, amount_needed);
+	}
+
+	current->flags |= pf_free_pages;
+	return error;
+}
+
 int try_to_free_pages(unsigned int gfp_mask)
 {
 	pg_data_t *pgdat;
@@ -738,18 +774,22 @@ int kswapd(void *unused)
 	 * us from recursively trying to free more memory as we're
 	 * trying to free the first piece of memory in the first place).
 	 */
-	tsk->flags |= PF_MEMALLOC;
+	tsk->flags |= PF_MEMALLOC | PF_REFRIGERATE;
 
 	/*
 	 * Kswapd main loop.
 	 */
 	for (;;) {
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_IOTHREAD);
 		__set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue(&kswapd_wait, &wait);
 
 		mb();
-		if (kswapd_can_sleep())
+		if (kswapd_can_sleep()) {
 			schedule();
+		}
+		
 
 		__set_current_state(TASK_RUNNING);
 		remove_wait_queue(&kswapd_wait, &wait);
@@ -772,4 +812,173 @@ static int __init kswapd_init(void)
 	return 0;
 }
 
+#ifdef CONFIG_SOFTWARE_SUSPEND
+void free_suspend_cache_page(struct page * page)
+{
+	if (!page)
+		return;
+
+	if (((unsigned long) page < (unsigned long) mem_map) || (page - mem_map) > max_mapnr) {
+		printk(KERN_ERR "Warning! free_suspend_cache_page called with an invalid page address (%p).", page);
+		return;
+	}
+	if (unlikely(!PageLRU(page)))
+		return;
+	if (unlikely(PageActive(page))) 
+		return;
+
+	spin_lock(&pagemap_lru_lock);
+
+	/*
+	 * Zero page counts can happen because we unlink the pages
+	 * _after_ decrementing the usage count..
+	 */
+	if (unlikely(!page_count(page)))
+		goto outofhere;
+
+	/* Racy check to avoid trylocking when not worthwhile */
+	if (!page->buffers && (page_count(page) != 1 || !page->mapping))
+		goto outofhere;
+
+	/*
+	 * The page is locked. IO in progress?
+	 * Move it to the back of the list.
+	 */
+	if (unlikely(TryLockPage(page))) {
+		if (PageLaunder(page)) {
+			page_cache_get(page);
+			spin_unlock(&pagemap_lru_lock);
+			wait_on_page(page);
+			//printk("\nfree_suspend_cache_page: Freeing a page (%p) that had PageLaunder set!", page);
+			page_cache_release(page);
+			spin_lock(&pagemap_lru_lock);
+		}
+		goto outofhere;
+	}
+
+	if (PageDirty(page) && is_page_cache_freeable(page) && page->mapping) {
+		/*
+		 * It is not critical here to write it only if
+		 * the page is unmapped beause any direct writer
+		 * like O_DIRECT would set the PG_dirty bitflag
+		 * on the phisical page after having successfully
+		 * pinned it and after the I/O to the page is finished,
+		 * so the direct writes to the page cannot get lost.
+		 */
+		int (*writepage)(struct page *);
+
+		writepage = page->mapping->a_ops->writepage;
+		if (writepage) {
+			ClearPageDirty(page);
+			SetPageLaunder(page);
+			page_cache_get(page);
+			spin_unlock(&pagemap_lru_lock);
+
+			writepage(page);
+			
+			//printk("\nfree_suspend_cache_page: Freeing a page (%p) that had PageDirty etc!", page);
+			page_cache_release(page);
+
+			spin_lock(&pagemap_lru_lock);
+			goto outofhere;
+		}
+	}
+
+	/*
+	 * If the page has buffers, try to free the buffer mappings
+	 * associated with this page. If we succeed, the page will
+	 * not be freed because suspend_task is set.
+	 */
+	if (page->buffers) {
+		spin_unlock(&pagemap_lru_lock);
+
+		/* avoid to free a locked page */
+		page_cache_get(page);
+
+		if (try_to_release_page(page, 0)) {
+			if (!page->mapping) {
+				/*
+				 * We must not allow an anon page
+				 * with no buffers to be visible on
+				 * the LRU, so we unlock the page after
+				 * taking the lru lock
+				 */
+				spin_lock(&pagemap_lru_lock);
+				UnlockPage(page);
+				__lru_cache_del(page);
+
+				/* effectively free the page here */
+				//printk("\nfree_suspend_cache_page: Freeing a page (%p) that had buffers (path a)!", page);
+				page_cache_release(page);
+
+				goto outofhere;
+			} else {
+				/*
+				 * The page is still in pagecache so undo the stuff
+				 * before the try_to_release_page since we've not
+				 * finished and we can now try the next step.
+				 */
+				page_cache_release(page);
+
+				spin_lock(&pagemap_lru_lock);
+			}
+		} else {
+			/* failed to drop the buffers so stop here */
+			UnlockPage(page);
+			//printk("\nfree_suspend_cache_page: Freeing a page (%p) that had buffers (path b)!", page);
+			page_cache_release(page);
+
+			spin_lock(&pagemap_lru_lock);
+			goto outofhere;
+		}
+	}
+
+	spin_lock(&pagecache_lock);
+
+	/*
+	 * this is the non-racy check for busy page.
+	 */
+	if (!page->mapping || !is_page_cache_freeable(page)) {
+		spin_unlock(&pagecache_lock);
+		UnlockPage(page);
+		goto outofhere;
+
+	}
+
+	/*
+	 * It is critical to check PageDirty _after_ we made sure
+	 * the page is freeable* so not in use by anybody.
+	 */
+	if (PageDirty(page)) {
+		spin_unlock(&pagecache_lock);
+		UnlockPage(page);
+		goto outofhere;
+	}
+
+	/* point of no return */
+	if (likely(!PageSwapCache(page))) {
+		__remove_inode_page(page);
+		spin_unlock(&pagecache_lock);
+	} else {
+		swp_entry_t swap;
+		swap.val = page->index;
+		__delete_from_swap_cache(page);
+		spin_unlock(&pagecache_lock);
+		swap_free(swap);
+	}
+
+	__lru_cache_del(page);
+	UnlockPage(page);
+
+	/* effectively free the page here */
+	page_cache_release(page);
+	//printk("free_suspend_cache_page: Freeing a page (%p) at the end of the procedure!", page);
+	//printk("^%p^", page);
+
+outofhere:
+	spin_unlock(&pagemap_lru_lock);
+	return;
+}
+
+#endif
 module_init(kswapd_init)
diff -urNp --exclude-from=/home/mitica/quintela/config/misc/dontdiff m2/net/sunrpc/sched.c m1/net/sunrpc/sched.c
--- m2/net/sunrpc/sched.c	2003-06-13 16:51:39.000000000 +0200
+++ m1/net/sunrpc/sched.c	2003-07-31 17:27:37.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/spinlock.h>
+#include <linux/suspend.h>
 
 #include <linux/sunrpc/clnt.h>
 #include <linux/sunrpc/xprt.h>
@@ -996,6 +997,7 @@ rpciod(void *ptr)
 	spin_unlock_irq(&current->sigmask_lock);
 
 	strcpy(current->comm, "rpciod");
+	current->flags |= PF_REFRIGERATE;
 
 	dprintk("RPC: rpciod starting (pid %d)\n", rpciod_pid);
 	while (rpciod_users) {
@@ -1011,6 +1013,11 @@ rpciod(void *ptr)
 		}
 
 		if (!rpciod_task_pending()) {
+			if (current->flags & PF_FREEZE) { 
+				dprintk("Now suspending rpciod\n");
+				refrigerator(PF_IOTHREAD);
+				dprintk("Now resuming rpciod\n");
+			}
 			dprintk("RPC: rpciod back to sleep\n");
 			wait_event_interruptible(rpciod_idle, rpciod_task_pending());
 			dprintk("RPC: switch to rpciod\n");
