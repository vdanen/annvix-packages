From: "Andrey Borzenkov" <arvidjaar@mail.ru>
Subject: PATCH: 2.4.20-2mdk: fix slow supermount on IDE devices
To: quintela@mandrakesoft.com, chmouel@mandrakesoft.com
Cc: cooker@linux-mandrake.com
Date: Sun, 12 Jan 2003 13:10:16 +0300
X-Mailer: mPOP Web-Mail 2.19
Reply-To: "Andrey Borzenkov" <arvidjaar@mail.ru>

Danny, one more for your collection :) Should be the really last
problem known to me.

It fixes ridiculously slow read from IDE devices in some cases. The
reason was as usual very simple and is not supermount bug.

File read-ahead code never explicitly unplugs device queue after
submitting requests. Supermount checks for media change on every
operation (except read/write) and query_disk_change blocked until
queue was unplugged, i.e. tq_disk was run. This happened either
on next non-readahead IO request (not neccessarily for the same device,
it explains why supermount appeared to work normally during high
disk IO activity) or during next kupdated run that by default happens
every 5 seconds. This gives you those 4-5 second delays for every file.

The worst case was read-ahead of many files immediately followed by
close. In this case every close blocked for several seconds. And
this is exactly what happens when you run rpm - it scans all package
headers and waits several seconds between each file :)

The fix is to ensure that device IO is enabled before we are going
to sleep waiting for request. It should not break anything as far as
I can tell, SCSI layer does the same (so SCSI devices should not suffer
from this problem at all). Arguably this should happen in file read-ahead
code and comments there even suggest that it was intended but I do
not feel myself confident enough to touch the very heart of IO subsystem.

cheers

-andrey
diff -uNp t8/drivers/ide/ide-io.c.orig t8/drivers/ide/ide-io.c
--- t8/drivers/ide/ide-io.c.orig	2003-01-16 17:07:33.000000000 +0100
+++ t8/drivers/ide/ide-io.c	2003-01-16 17:08:03.000000000 +0100
@@ -1322,6 +1322,10 @@ int ide_do_drive_cmd (ide_drive_t *drive
 	ide_do_request(hwgroup, 0);
 	spin_unlock_irqrestore(&io_request_lock, flags);
 	if (action == ide_wait) {
+		/*
+		 * make sure IO is not suspended
+		 */
+		generic_unplug_device(&drive->queue);
 		/* wait for it to be serviced */
 		wait_for_completion(&wait);
 		/* return -EIO if errors */
