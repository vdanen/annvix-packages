--- linux-2.4.22/include/linux/fb.h.dv08.orig	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.22/include/linux/fb.h	2003-09-13 04:22:48.000000000 +0200
@@ -95,6 +95,7 @@
 #define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
 #define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
 #define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810                    */
 #define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
 #define FB_ACCEL_SIS_XABRE	41	/* SiS 330 ("Xabre")		*/
 
--- linux-2.4.22/drivers/video/Config.in.dv08.orig	2003-09-13 04:22:14.000000000 +0200
+++ linux-2.4.22/drivers/video/Config.in	2003-09-13 04:26:56.000000000 +0200
@@ -12,6 +12,15 @@ if [ "$CONFIG_FB" = "y" ]; then
    if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
       if [ "$CONFIG_PCI" = "y" ]; then
          tristate '  nVidia Riva support (EXPERIMENTAL)' CONFIG_FB_RIVA
+         if [ "$ARCH" = "i386" ]; then
+	       dep_tristate '  Intel 810/815 support (EXPERIMENTAL)' CONFIG_FB_I810 $CONFIG_AGP
+	       if [ "$CONFIG_FB_I810" != "n" ]; then
+		  bool '        use VESA GTF for Video Timings' CONFIG_FB_I810_GTF
+		  bool '        enable accelerated drawing functions' CONFIG_FB_I810_ACCEL
+		  dep_bool '        enable display rotation code' CONFIG_FB_I810_ROTATE $CONFIG_FB_I810_ACCEL
+		  bool '        enable device interface'  CONFIG_FB_I810_IFACE
+	       fi
+	 fi
       fi
       if [ "$CONFIG_AMIGA" = "y" -o "$CONFIG_PCI" = "y" ]; then
 	 tristate '  Cirrus Logic support (EXPERIMENTAL)' CONFIG_FB_CLGEN
@@ -307,7 +316,7 @@ if [ "$CONFIG_FB" = "y" ]; then
 	   "$CONFIG_FB_MAXINE" = "y" -o "$CONFIG_FB_TX3912" = "y" -o \
 	   "$CONFIG_FB_SIS" = "y" -o "$CONFIG_FB_NEOMAGIC" = "y" -o \
 	   "$CONFIG_FB_STI" = "y" -o "$CONFIG_FB_HP300" = "y" -o \
-	   "$CONFIG_FB_INTEL" = "y" ]; then
+	   "$CONFIG_FB_INTEL" = "y" -o "$CONFIG_FB_I810" = "y" ]; then
 	 define_tristate CONFIG_FBCON_CFB8 y
       else
 	 if [ "$CONFIG_FB_ACORN" = "m" -o "$CONFIG_FB_ATARI" = "m" -o \
@@ -329,7 +338,8 @@ if [ "$CONFIG_FB" = "y" ]; then
 	      "$CONFIG_FB_MAXINE" = "m" -o "$CONFIG_FB_RADEON" = "m" -o \
 	      "$CONFIG_FB_SA1100" = "m" -o "$CONFIG_FB_SIS" = "m" -o \
 	      "$CONFIG_FB_TX3912" = "m" -o "$CONFIG_FB_NEOMAGIC" = "m" -o \
-	      "$CONFIG_FB_STI" = "m" -o "$CONFIG_FB_INTEL" = "m" ]; then
+	      "$CONFIG_FB_STI" = "m" -o "$CONFIG_FB_INTEL" = "m" -o \
+	      "$CONFIG_FB_I810" = "m" ]; then
 	    define_tristate CONFIG_FBCON_CFB8 m
 	 fi
       fi
@@ -347,7 +357,8 @@ if [ "$CONFIG_FB" = "y" ]; then
 	   "$CONFIG_FB_CYBER2000" = "y" -o "$CONFIG_FB_3DFX" = "y"  -o \
 	   "$CONFIG_FB_SIS" = "y" -o "$CONFIG_FB_SA1100" = "y" -o \
 	   "$CONFIG_FB_PVR2" = "y" -o "$CONFIG_FB_VOODOO1" = "y" -o \
-	   "$CONFIG_FB_NEOMAGIC" = "y" -o "$CONFIG_FB_INTEL" = "y" ]; then
+	   "$CONFIG_FB_NEOMAGIC" = "y" -o "$CONFIG_FB_INTEL" = "y" -o \
+	   "$CONFIG_FB_I810" = "y" ]; then
 	 define_tristate CONFIG_FBCON_CFB16 y
       else
 	 if [ "$CONFIG_FB_ATARI" = "m" -o "$CONFIG_FB_ATY" = "m" -o \
@@ -364,7 +375,8 @@ if [ "$CONFIG_FB" = "y" ]; then
 	      "$CONFIG_FB_CYBER2000" = "m" -o "$CONFIG_FB_SIS" = "m" -o \
 	      "$CONFIG_FB_SA1100" = "m" -o "$CONFIG_FB_RADEON" = "m" -o \
 	      "$CONFIG_FB_PVR2" = "m" -o "$CONFIG_FB_VOODOO1" = "m" -o \
-	      "$CONFIG_FB_NEOMAGIC" = "m" -o "$CONFIG_FB_INTEL" = "m" ]; then
+	      "$CONFIG_FB_NEOMAGIC" = "m" -o "$CONFIG_FB_INTEL" = "m" -o \
+	      "$CONFIG_FB_I810" = "m" ]; then
 	    if [ "$CONFIG_FBCON_CFB16" != "y" ]; then
 	       define_tristate CONFIG_FBCON_CFB16 m
 	    fi
@@ -375,7 +387,8 @@ if [ "$CONFIG_FB" = "y" ]; then
 	   "$CONFIG_FB_MATROX" = "y" -o "$CONFIG_FB_PM2" = "y" -o \
            "$CONFIG_FB_ATY128" = "y" -o "$CONFIG_FB_RADEON" = "y" -o \
 	   "$CONFIG_FB_CYBER2000" = "y" -o "$CONFIG_FB_PVR2" = "y" -o \
-	   "$CONFIG_FB_VOODOO1" = "y" -o "$CONFIG_FB_NEOMAGIC" = "y" ]; then
+	   "$CONFIG_FB_VOODOO1" = "y" -o "$CONFIG_FB_NEOMAGIC" = "y" -o \
+           "$CONFIG_FB_I810" = "y" ]; then
 	 define_tristate CONFIG_FBCON_CFB24 y
       else
 	 if [ "$CONFIG_FB_ATY" = "m" -o "$CONFIG_FB_VIRTUAL" = "m" -o \
@@ -383,7 +396,8 @@ if [ "$CONFIG_FB" = "y" ]; then
 	      "$CONFIG_FB_MATROX" = "m" -o "$CONFIG_FB_PM2" = "m" -o \
 	      "$CONFIG_FB_ATY128" = "m" -o "$CONFIG_FB_RADEON" = "m" -o \
 	      "$CONFIG_FB_CYBER2000" = "m" -o "$CONFIG_FB_PVR2" = "m" -o \
-	      "$CONFIG_FB_VOODOO1" = "m" -o "$CONFIG_FB_NEOMAGIC" = "m" ]; then
+	      "$CONFIG_FB_VOODOO1" = "m" -o "$CONFIG_FB_NEOMAGIC" = "m" -o \
+	      "$CONFIG_FB_I810" = "m" ]; then
 	    define_tristate CONFIG_FBCON_CFB24 m
 	 fi
       fi
@@ -398,7 +412,8 @@ if [ "$CONFIG_FB" = "y" ]; then
 	   "$CONFIG_FB_RADEON" = "y" -o "$CONFIG_FB_PVR2" = "y" -o \
 	   "$CONFIG_FB_3DFX" = "y" -o "$CONFIG_FB_SIS" = "y" -o \
 	   "$CONFIG_FB_VOODOO1" = "y" -o "$CONFIG_FB_CYBER2000" = "y" -o \
-	   "$CONFIG_FB_STI" = "y"  -o "$CONFIG_FB_INTEL" = "y" ]; then
+	   "$CONFIG_FB_STI" = "y"  -o "$CONFIG_FB_INTEL" = "y" -o \
+	   "$CONFIG_FB_I810" = "y" ]; then
 	 define_tristate CONFIG_FBCON_CFB32 y
       else
 	 if [ "$CONFIG_FB_ATARI" = "m" -o "$CONFIG_FB_ATY" = "m" -o \
@@ -412,7 +427,7 @@ if [ "$CONFIG_FB" = "y" ]; then
 	      "$CONFIG_FB_SGIVW" = "m" -o "$CONFIG_FB_SIS" = "m" -o \
 	      "$CONFIG_FB_PVR2" = "m" -o "$CONFIG_FB_VOODOO1" = "m" -o \
 	      "$CONFIG_FB_CYBER2000" = "m" -o "$CONFIG_FB_STI" = "y" -o \
-	      "$CONFIG_FB_INTEL" = "m" ]; then
+	      "$CONFIG_FB_INTEL" = "m" -o "$CONFIG_FB_I810" = "m" ]; then
 	    define_tristate CONFIG_FBCON_CFB32 m
 	 fi
       fi
--- linux-2.4.22/drivers/video/Makefile.dv08.orig	2003-09-13 04:22:15.000000000 +0200
+++ linux-2.4.22/drivers/video/Makefile	2003-09-13 04:22:28.000000000 +0200
@@ -123,6 +123,11 @@ ifeq ($(CONFIG_FB_ATY),y)
 obj-y				  += aty/atyfb.o
 endif
 
+subdir-$(CONFIG_FB_I810)	  += i810
+ifeq ($(CONFIG_FB_I810),y)
+obj-y				  += i810/i810fb.o
+endif
+
 obj-$(CONFIG_FB_SUN3)             += sun3fb.o
 obj-$(CONFIG_FB_BWTWO)            += bwtwofb.o
 obj-$(CONFIG_FB_HGA)              += hgafb.o  
--- linux-2.4.22/drivers/video/fbmem.c.dv08.orig	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.22/drivers/video/fbmem.c	2003-09-13 04:22:28.000000000 +0200
@@ -116,6 +116,8 @@ extern int sgivwfb_init(void);
 extern int sgivwfb_setup(char*);
 extern int rivafb_init(void);
 extern int rivafb_setup(char*);
+extern int i810fb_init(void);
+extern int i810fb_setup(char*);
 extern int tdfxfb_init(void);
 extern int tdfxfb_setup(char*);
 extern int tridentfb_init(void);
@@ -200,6 +202,9 @@ static struct {
 #ifdef CONFIG_FB_RIVA
 	{ "riva", rivafb_init, rivafb_setup },
 #endif
+#ifdef CONFIG_FB_I810
+	{ "i810fb", i810fb_init, i810fb_setup },
+#endif	
 #ifdef CONFIG_FB_RADEON
 	{ "radeon", radeonfb_init, radeonfb_setup },
 #endif
--- linux-2.4.22/drivers/video/i810/Makefile.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/Makefile	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,20 @@
+#
+# Makefile for the Intel 810/815 framebuffer driver
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile...
+
+O_TARGET := i810fb.o
+
+export-objs                     := i810_main.o i810_accel.o i810_fbcon.o i810_sarea.o
+
+obj-y				:= i810_main.o i810_accel.o i810_fbcon.o i810_sarea.o
+obj-$(CONFIG_FB_I810_ACCEL)    	+= i810_fbcon_accel.o  
+obj-$(CONFIG_FB_I810_ROTATE)    += i810_fbcon_rotate.o
+obj-$(CONFIG_FB_I810_IFACE) 	+= i810_iface.o
+obj-m	                        := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
--- linux-2.4.22/drivers/video/i810/i810_accel.c.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_accel.c	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,441 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_accel.c -- Hardware Acceleration
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,14)
+#include <linux/malloc.h>
+#else
+#include <linux/slab.h>
+#endif
+
+#include <linux/tty.h>
+#include "i810_regs.h"
+#include "i810_common.h"
+#include "i810_accel.h"
+
+/* BLT Engine Routines */
+static inline void i810_report_error(void)
+{
+	printk("IIR     : 0x%04x\n"
+	       "EIR     : 0x%04x\n"
+	       "PGTBL_ER: 0x%04x\n"
+	       "IPEIR   : 0x%04x\n"
+	       "IPEHR   : 0x%04x\n",
+	       i810_readw(IIR),
+	       i810_readb(EIR),
+	       i810_readl(PGTBL_ER),
+	       i810_readl(IPEIR), 
+	       i810_readl(IPEHR));
+}
+
+/**
+ * wait_for_space - check ring buffer free space
+ * @space: amount of ringbuffer space needed in bytes
+ *
+ * DESCRIPTION:
+ * The function waits until a free space from the ringbuffer
+ * is available 
+ */	
+inline int wait_for_space(u32 space)
+{
+	u32 head, count = WAIT_COUNT, tail;
+
+	tail = i810_accel->cur_tail;
+	while (count--) {
+		head = i810_readl(IRING + 4) & RBUFFER_HEAD_MASK;	
+		if ((tail == head) || 
+		    (tail > head && (RINGBUFFER_SIZE - tail + head) >= space) || 
+		    (tail < head && (head - tail) >= space)) {
+			return 0;	
+		}
+	}
+	printk("ringbuffer lockup!!!\n");
+	i810_report_error(); 
+	i810_accel->lockup = 1;
+	i810_set_iface_lockup();
+	return 1;
+}
+
+
+
+/** 
+ * wait_for_engine_idle - waits for all hardware engines to finish
+ *
+ * DESCRIPTION:
+ * This waits for lring(0), iring(1), and batch(3), etc to finish
+ */
+inline int wait_for_engine_idle(void)
+{
+	int count = WAIT_COUNT;
+
+	while((i810_readw(INSTDONE) & 0x7B) != 0x7B && count--); 
+	if (count) return 0;
+
+	printk("accel engine lockup!!!\n");
+	printk("INSTDONE: 0x%04x\n", i810_readl(INSTDONE));
+	i810_report_error(); 
+	i810_accel->lockup = 1;
+	i810_set_iface_lockup();
+	return 1;
+}
+
+/* begin_iring - prepares the ringbuffer 
+ * @space: length of sequence in dwords
+ *
+ * DESCRIPTION:
+ * Checks/waits for sufficent space in ringbuffer of size
+ * space.  Returns the tail of the buffer
+ */ 
+inline u32 begin_iring(u32 space)
+{
+	if (i810_accel->sync) wait_for_engine_idle();
+	return wait_for_space(space);
+}
+
+/**
+ * end_iring - advances the tail, which begins execution
+ *
+ * DESCRIPTION:
+ * This advances the tail of the ringbuffer, effectively
+ * beginning the execution of the instruction sequence.
+ */
+inline void end_iring(void)
+{
+	u32 tail;
+
+	tail = i810_readl(IRING) & ~RBUFFER_TAIL_MASK;
+	i810_writel(IRING, tail | i810_accel->cur_tail);
+	if (i810_accel->sync) wait_for_engine_idle();
+}
+
+/**
+ * flush_gfx - flushes graphics pipeline
+ *
+ * DESCRIPTION:
+ * Flushes the graphics pipeline.  This is done via
+ * sending instruction packets to the ringbuffer
+ */
+inline void flush_gfx(void)
+{
+	if (begin_iring(8 + IRING_PAD)) return;
+	PUT_RING(PARSER | FLUSH);
+	PUT_RING(NOP);
+	end_iring();
+}
+
+inline void arb_on_off(u32 mode)
+{
+	if (begin_iring(8 + IRING_PAD)) return;
+	PUT_RING(PARSER | ARB_ON_OFF | mode);
+	PUT_RING(NOP);
+	end_iring();
+}
+
+/**
+ * emit_instruction - process instruction packets
+ * @dsize: length of instruction packets in dwords
+ * @pointer: pointer to physical address of buffer 
+ * @trusted: whether the source of the instruction came
+ *           from a trusted process or not (root)
+ *
+ * DESCRIPTION:
+ * This function initiates the ringbuffer, copies all packets
+ * to the ringbuffer, and initiates processing of the packets.
+ * This function is reserved for non-kernel clients doing
+ * DMA's in userland
+ */
+inline void emit_instruction (u32 dsize, u32 pointer, u32 trusted)
+{
+	if (begin_iring(16 + IRING_PAD)) return;
+	PUT_RING(PARSER | BATCH_BUFFER | 1);
+	PUT_RING(pointer | trusted);
+	PUT_RING(pointer + (dsize << 2) - 4);
+	PUT_RING(NOP);	 
+	end_iring();
+}
+
+/**
+ * mono_pat_blit - monochromatic pattern BLIT
+ * @dpitch: no of pixel per line of destination 
+ * @dheight:  height in pixels of the pattern
+ * @dwidth: width in pixels of the pattern
+ * @where: where to place the pattern
+ * @fg: foreground color
+ * @bg: background color
+ * @rop: graphics raster operation
+ * @patt_1: first part of an 8x8 pixel pattern
+ * @patt_2: second part of an 8x8 pixel pattern
+ * @blit_bpp: pixel format which can be different from the 
+ *            buffers pixel format
+ *
+ * DESCRIPTION:
+ * Immediate monochromatic pattern BLIT function.  The pattern
+ * is directly written to the ringbuffer.
+ */
+
+inline void mono_pat_blit(int dpitch, int dheight, int dwidth, int dest, 
+			  int fg, int bg, int rop, int patt_1, int patt_2, 
+			  int blit_bpp)
+{
+	if (begin_iring(32 + IRING_PAD)) return;
+	PUT_RING(BLIT | MONO_PAT_BLIT | 6);
+	PUT_RING(rop << 16 | dpitch | DYN_COLOR_EN | blit_bpp);
+	PUT_RING(dheight << 16 | dwidth);
+	PUT_RING(dest);
+	PUT_RING(bg);
+	PUT_RING(fg);
+	PUT_RING(patt_1);
+	PUT_RING(patt_2);
+	end_iring();
+}
+
+/**
+ * source_copy_blit - BLIT transfer operation
+ * @dwidth: width of rectangular graphics data
+ * @dheight: height of rectangular graphics data
+ * @dpitch: pixels per line of destination buffer
+ * @xdir: direction of copy (left to right or right to left)
+ * @spitch: pixels per line of source buffer
+ * @from: source address
+ * @where: destination address
+ * @rop: raster operation
+ * @blit_bpp: pixel format which can be different from the 
+ *            buffers pixel format
+ *
+ * DESCRIPTION:
+ * This is a BLIT operation typically used when doing
+ * a 'Copy and Paste'
+ */
+inline void source_copy_blit(int dwidth, int dheight, int dpitch, int xdir, 
+			     int spitch, int src, int dest, int rop, int blit_bpp)
+{
+	if (begin_iring(24 + IRING_PAD)) return;
+	PUT_RING(BLIT | SOURCE_COPY_BLIT | 4);
+	PUT_RING(xdir | rop << 16 | dpitch | DYN_COLOR_EN | blit_bpp);
+	PUT_RING(dheight << 16 | dwidth);
+	PUT_RING(dest);
+	PUT_RING(spitch);
+	PUT_RING(src);
+	end_iring();
+}	
+
+/**
+ * color_blit - solid color BLIT operation
+ * @width: width of destination
+ * @height: height of destination
+ * @pitch: pixels per line of the buffer
+ * @where: destination
+ * @rop: raster operation
+ * @what: color to transfer
+ * @blit_bpp: pixel format which can be different from the 
+ *            buffers pixel format
+ *
+ * DESCRIPTION:
+ * A BLIT operation which can be used for  color fill/rectangular fill
+ */
+inline void color_blit(int width, int height, int pitch, 
+		       int dest, int rop, int what, int blit_bpp)
+{
+	if (begin_iring(24 + IRING_PAD)) return;
+	PUT_RING(BLIT | COLOR_BLT | 3);
+	PUT_RING(rop << 16 | pitch | SOLIDPATTERN | DYN_COLOR_EN | blit_bpp);
+	PUT_RING(height << 16 | width);
+	PUT_RING(dest);
+	PUT_RING(what);
+	PUT_RING(NOP);
+	end_iring();
+}
+
+/* i810fb_load_front - initializes frontbuffer
+ * @offset: offset from start of framebuffer memory
+ * @pitch: pitch of buffer
+ * @async: asynchronous or synchronous flips
+ *
+ * DESCRIPTION:
+ * similar to load_start, but uses ringbuffer to transfer the instructions.
+ * This can be useful if asynchronous flips are required.
+ */
+int i810fb_load_front(u32 offset, u32 pitch, u32 async)
+{
+	u32 header;
+	
+	if (i810_accel->lockup || not_safe()) return -ENODEV;
+	header = PARSER | FRONT_BUFFER | async << 6;
+	if (!async)
+		header |= (pitch >> 3) << 8;
+	flush_gfx();
+	if (begin_iring(8 + IRING_PAD)) return -ENODEV;
+	PUT_RING(header);
+	PUT_RING((i810_accel->fb_offset << 12) + offset);
+	end_iring();
+	return 0;
+}
+
+/* i810fb_load_back - initializes backbuffer
+ * @pitch_bits: pitch of rendering surface
+ *
+ * DESCRIPTION:
+ * Required if asynchronous buffer flips are done.  
+ */
+void i810fb_load_back(u32 pitch_bits)
+{
+	if (i810_accel->lockup || not_safe()) return;
+	flush_gfx();
+	if (begin_iring(8 + IRING_PAD)) return;
+	PUT_RING(PARSER | DEST_BUFFER);
+	PUT_RING(i810_accel->fb_offset << 12 | pitch_bits);
+	end_iring();
+}
+
+/**
+ * i810fb_iring_enable - enables/disables the ringbuffer
+ * @mode: enable or disable
+ *
+ * DESCRIPTION:
+ * Enables or disables the ringbuffer, effectively enabling or
+ * disabling the instruction/acceleration engine.
+ */
+inline void i810fb_iring_enable(u32 mode)
+{
+	u32 tmp;
+	tmp = i810_readl(IRING + 12);
+	if (mode == OFF) 
+		tmp &= ~1;
+	else 
+		tmp |= 1;
+	wait_for_engine_idle();
+	flush_cache();
+	i810_writel(IRING + 12, tmp);
+}       
+
+/**
+ * i810fb_init_ringbuffer - initialize the ringbuffer
+ *
+ * DESCRIPTION:
+ * Initializes the ringbuffer by telling the device the
+ * size and location of the ringbuffer.  It also sets 
+ * the head and tail pointers = 0
+ */
+void i810fb_init_ringbuffer(void)
+{
+	u32 tmp1, tmp2;
+	
+	wait_for_engine_idle();
+	i810fb_iring_enable(OFF);
+	i810_writel(IRING, 0);
+	i810_writel(IRING + 4, 0);
+	i810_accel->cur_tail = 0;
+
+	tmp2 = i810_readl(IRING + 8) & ~RBUFFER_START_MASK; 
+	tmp1 = i810_accel->iring_start_phys;
+	i810_writel(IRING + 8, tmp2 | tmp1);
+
+	tmp1 = i810_readl(IRING + 12);
+	tmp1 &= ~RBUFFER_SIZE_MASK;
+	tmp2 = (RINGBUFFER_SIZE - I810_PAGESIZE) & RBUFFER_SIZE_MASK;
+	i810_writel(IRING + 12, tmp1 | tmp2);
+	i810fb_iring_enable(ON);
+}
+
+/**
+ * i810fb_restore_ringbuffer - restores saved ringbuffers
+ * @iring: pointer to the ringbuffe structure
+ */
+void i810fb_restore_ringbuffer(struct ringbuffer *iring)
+{
+	u32 tmp1, tmp2;
+	wait_for_engine_idle();
+	i810fb_iring_enable(OFF);
+	
+	i810_writel(IRING, 0);
+	i810_writel(IRING + 4, 0);
+	
+	tmp1 = i810_readl(IRING + 8);
+	tmp1 &= ~RBUFFER_START_MASK;
+	tmp2 = iring->start;
+	tmp2 &= RBUFFER_START_MASK;
+	i810_writel(IRING + 8, tmp1 | tmp2);
+
+	tmp1 = i810_readl(IRING + 12);
+	tmp1 &= ~RBUFFER_SIZE_MASK;
+	tmp2 = iring->size;
+	tmp2 &= RBUFFER_SIZE_MASK;
+	i810_writel(IRING + 12, tmp1 | tmp2);
+	
+	tmp1 = iring->size;
+       	i810fb_iring_enable(tmp1 & 1);
+}
+
+void i810fb_unbind_accel_mem(void)
+{
+	if (i810_accel->i810_iring_memory->is_bound)
+		agp_unbind_memory(i810_accel->i810_iring_memory);
+}
+
+int i810fb_bind_accel_mem(void)
+{
+	if (!i810_accel->i810_iring_memory->is_bound) {
+		if (agp_bind_memory(i810_accel->i810_iring_memory, 
+				    i810_accel->iring_offset)) {
+			printk("i180fb: can't rebind command buffer memory\n");
+			return -EBUSY;
+		}
+	}
+	return 0;
+}
+
+u32 __devinit i810fb_alloc_iring_mem(u32 fb_offset, u32 aper_size)
+{
+	if (fb_offset < RINGBUFFER_SIZE >> 12)
+		i810_accel->iring_offset = ((aper_size - RINGBUFFER_SIZE) >> 12) - 1;
+	else
+		i810_accel->iring_offset = fb_offset - (RINGBUFFER_SIZE >> 12);
+	if (!(i810_accel->i810_iring_memory = 
+	      agp_allocate_memory(RINGBUFFER_SIZE >> 12, 
+				  AGP_NORMAL_MEMORY))) {
+		printk("i810fb_alloc_iringmem:  cannot allocate ringbuffer memory\n");
+		return 0;
+	}	
+	if (agp_bind_memory(i810_accel->i810_iring_memory, 
+			    i810_accel->iring_offset)) {
+		printk("i810fb_alloc_iringmem: cannot bind ringbuffer memory\n");
+		return 0;
+	}	
+	return i810_accel->iring_offset;
+}
+
+void __devinit i810fb_fix_accel_pointer(u32 fb_base_phys, u32 fb_base_virtual)
+{
+	i810_accel->iring_start_phys = fb_base_phys + 
+		(i810_accel->iring_offset << 12);
+	i810_accel->iring_start_virtual = fb_base_virtual + 
+		(i810_accel->iring_offset << 12);
+}
+
+u32 __devinit i810fb_init_accel(u32 fb_offset, u32 aper_size, u32 sync)
+{
+	if (!(i810_accel = kmalloc(sizeof(struct accel_data), GFP_KERNEL)))
+		return -ENOMEM;
+	memset(i810_accel, 0, sizeof(struct accel_data));
+	i810_accel->fb_offset = fb_offset;
+	i810_accel->sync = sync;
+	return i810fb_alloc_iring_mem(fb_offset, aper_size);
+}
+
+void i810fb_accel_cleanup(void)
+{
+	if (i810_accel->i810_iring_memory) {
+		i810fb_iring_enable(OFF);
+		agp_free_memory(i810_accel->i810_iring_memory);
+	}
+	if (i810_accel)
+		kfree(i810_accel);
+}
--- linux-2.4.22/drivers/video/i810/i810_accel.h.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_accel.h	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,42 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_accel.c -- Hardware Acceleration
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#ifndef __I810_ACCEL_H__
+#define __I810_ACCEL_H__
+
+/* Macros */
+#define PUT_RING(n) {                                                                   \
+	*(volatile u32 *)(i810_accel->iring_start_virtual + i810_accel->cur_tail) = n;  \
+        i810_accel->cur_tail += 4;                                                      \
+        i810_accel->cur_tail &= RING_SIZE_MASK;                                         \
+}                                                                      
+
+struct accel_data          *i810_accel;
+
+extern inline u8   i810_readb (u32 where);
+extern inline u16  i810_readw (u32 where);
+extern inline u32  i810_readl (u32 where);
+extern inline void i810_writeb(u32 where, u8 val);
+extern inline void i810_writew(u32 where, u16 val);
+extern inline void i810_writel(u32 where, u32 val);
+extern inline void flush_cache(void);
+extern u32         get_line_length     (int xres_virtual, int bpp);
+extern void        i810fb_enable_cursor(int mode);
+extern inline int  not_safe(void);
+
+#ifdef CONFIG_FB_I810_IFACE
+extern inline void i810_set_iface_lockup(void);
+#else 
+extern inline void i810_set_iface_lockup(void);
+/*static inline void i810_set_iface_lockup(void) { } */
+#endif
+
+#endif /* __I810_ACCEL_H__ */
--- linux-2.4.22/drivers/video/i810/i810_common.h.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_common.h	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,415 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_common.h -- Intel 810 Definitions
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+/* CLUT - EGA planes equivalent */
+/* FIXME:  I can't find an easy way to load the CLUT except to
+ *         make a table.  I extrapolated the values from EGA
+ *         and I'm not sure if they're correct.  
+ */
+	 
+#ifndef __I810_COMMON_H__
+#define __I810_COMMON_H__
+
+#include <linux/list.h>
+#include <linux/agp_backend.h>
+#include <linux/fb.h>
+#include <video/fbcon.h>
+
+/* Fence */
+#define TILEWALK_X            0 << 12
+#define TILEWALK_Y            1 << 12
+
+/* Raster ops */
+#define COLOR_COPY_ROP        0xF0
+#define PAT_COPY_ROP          0xCC
+#define CLEAR_ROP             0x00
+#define WHITE_ROP             0xFF
+#define INVERT_ROP            0x55
+
+/* 2D Engine definitions */
+#define SOLIDPATTERN          0x80000000
+#define NONSOLID              0x00000000
+#define BPP8                  0 << 24
+#define BPP16                 1 << 24
+#define BPP24                 2 << 24
+#define DYN_COLOR_EN          1 << 26
+#define DYN_COLOR_DIS         0 << 26
+#define INCREMENT             0x00000000
+#define DECREMENT             0x01 << 30
+#define ARB_ON                0x00000001
+#define ARB_OFF               0x00000000
+#define SYNC_FLIP             0x00000000
+#define ASYNC_FLIP            0x00000040
+#define OPTYPE_MASK           0xE0000000
+#define PARSER_MASK           0x001F8000 
+#define D2_MASK               0x001FC000         /* 2D mask */
+
+/* Instruction type */
+/* There are more but pertains to 3D */
+#define PARSER                0x00000000
+#define BLIT                  0x02 << 29
+#define RENDER                0x03 << 29
+            
+/* Parser */
+#define NOP                   0x00               /* No operation, padding */
+#define BP_INT                0x01 << 23         /* Breakpoint interrupt */
+#define USR_INT               0x02 << 23         /* User interrupt */
+#define WAIT_FOR_EVNT         0x03 << 23         /* Wait for event */
+#define FLUSH                 0x04 << 23              
+#define CONTEXT_SEL           0x05 << 23
+#define REPORT_HEAD           0x07 << 23
+#define ARB_ON_OFF            0x08 << 23
+#define OVERLAY_FLIP          0x11 << 23
+#define LOAD_SCAN_INC         0x12 << 23
+#define LOAD_SCAN_EX          0x13 << 23
+#define FRONT_BUFFER          0x14 << 23
+#define DEST_BUFFER           0x15 << 23
+#define Z_BUFFER              0x16 << 23              /* we won't need this */
+#define STORE_DWORD_IMM       0x20 << 23
+#define STORE_DWORD_IDX       0x21 << 23
+#define BATCH_BUFFER          0x30 << 23
+
+/* Blit */
+#define SETUP_BLIT                      0x00
+#define SETUP_MONO_PATTERN_SL_BLT       0x10 << 22
+#define PIXEL_BLT                       0x20 << 22
+#define SCANLINE_BLT                    0x21 << 22 
+#define TEXT_BLT                        0x22 << 22
+#define TEXT_IMM_BLT                    0x30 << 22
+#define COLOR_BLT                       0x40 << 22
+#define MONO_PAT_BLIT                   0x42 << 22
+#define SOURCE_COPY_BLIT                0x43 << 22
+
+#define VERSION_MAJOR            0
+#define VERSION_MINOR            0
+#define VERSION_TEENIE           23
+#define BRANCH_VERSION           ""
+
+
+#ifndef PCI_DEVICE_ID_INTEL_82810_MC4
+  #define PCI_DEVICE_ID_INTEL_82810_MC4           0x7124
+#endif
+#ifndef PCI_DEVICE_ID_INTEL_82810_IG4
+  #define PCI_DEVICE_ID_INTEL_82810_IG4           0x7125
+#endif
+
+/* mvo: intel i815 */
+#ifndef PCI_DEVICE_ID_INTEL_82815_100
+  #define PCI_DEVICE_ID_INTEL_82815_100           0x1102
+#endif
+#ifndef PCI_DEVICE_ID_INTEL_82815_NOAGP
+  #define PCI_DEVICE_ID_INTEL_82815_NOAGP         0x1112
+#endif
+#ifndef PCI_DEVICE_ID_INTEL_82815_FULL_CTRL
+  #define PCI_DEVICE_ID_INTEL_82815_FULL_CTRL     0x1130
+#endif 
+#ifndef PCI_DEVICE_ID_INTEL_82815_FULL_BRG
+  #define PCI_DEVICE_ID_INTEL_82815_FULL_BRG      0x1131
+#endif 
+#ifndef PCI_DEVICE_ID_INTEL_82815_FULL
+  #define PCI_DEVICE_ID_INTEL_82815_FULL          0x1132
+#endif 
+
+/* General Defines */
+#define arraysize(x)	            (sizeof(x)/sizeof(*(x)))
+#define I810_PAGESIZE               4096
+#define MAX_DMA_SIZE                1024 * 4096
+#define SAREA_SIZE                  4096
+#define PCI_I810_MISCC              0x72
+#define MMIO_SIZE                   512*1024
+#define GTT_SIZE                    16*1024 
+#define RINGBUFFER_SIZE             128*1024
+#define CURSOR_SIZE                 4096 
+#define OFF                         0
+#define ON                          1
+#define MAX_KEY                     256
+#define WAIT_COUNT                  100000
+#define IRING_PAD                   8
+
+/* Masks (AND ops) and OR's */
+#define FB_START_MASK               0x3f << (32 - 6)
+#define MMIO_ADDR_MASK              0x1FFF << (32 - 13)
+#define FREQ_MASK                   0x1EF
+#define SCR_OFF                     0x20
+#define DRAM_ON                     0x08            
+#define DRAM_OFF                    0xE7
+#define PG_ENABLE_MASK              0x01
+#define RING_SIZE_MASK              RINGBUFFER_SIZE - 1;
+
+/* defines for restoring registers partially */
+#define ADDR_MAP_MASK               0x07 << 5
+#define DISP_CTRL                   ~0
+#define PIXCONF_0                   0x64 << 8
+#define PIXCONF_2                   0xF3 << 24
+#define PIXCONF_1                   0xF0 << 16
+#define MN_MASK                     0x3FF03FF
+#define P_OR                        0x7 << 4                    
+#define DAC_BIT                     1 << 16
+#define INTERLACE_BIT               1 << 7
+#define IER_MASK                    3 << 13
+#define IMR_MASK                    3 << 13
+
+/* Power Management */
+#define DPMS_MASK                   0xF0000
+#define POWERON                     0x00000
+#define STANDBY                     0x20000
+#define SUSPEND                     0x80000
+#define POWERDOWN                   0xA0000
+#define EMR_MASK                    ~0x3F
+#define FW_BLC_MASK                 ~(0x3F|(7 << 8)|(0x3F << 12)|(7 << 20))
+
+/* Ringbuffer */
+#define RBUFFER_START_MASK          0xFFFFF000
+#define RBUFFER_SIZE_MASK           0x001FF000
+#define RBUFFER_HEAD_MASK           0x001FFFFC
+#define RBUFFER_TAIL_MASK           0x001FFFF8
+
+/* Video Timings */
+#define REF_FREQ                    24000000
+#define TARGET_N_MAX                30
+
+#define FLYBACK                     550
+#define V_FRONTPORCH                1
+#define H_OFFSET                    40
+#define H_SCALEFACTOR               20
+#define H_BLANKSCALE                128
+#define H_GRADIENT                   600
+
+#define MAX_PIXELCLOCK              230000000
+#define MIN_PIXELCLOCK               15000000
+#define VFMAX                       60
+#define VFMIN                       60
+#define HFMAX                       30
+#define HFMIN                       30
+
+/* Cursor */
+#define CURSOR_ENABLE_MASK          0x1000             
+#define CURSOR_MODE_64_TRANS        4
+#define CURSOR_MODE_64_XOR	    5
+#define CURSOR_MODE_64_3C	    6	
+#define COORD_INACTIVE              0
+#define COORD_ACTIVE                1 << 4
+#define EXTENDED_PALETTE	    1
+  
+/* AGP Memory Types*/
+#define AGP_NORMAL_MEMORY           0
+#define AGP_DCACHE_MEMORY	    1
+#define AGP_PHYSICAL_MEMORY         2
+
+/* Display Orientation */
+#define NO_ROTATION                 0
+#define ROTATE_RIGHT                1
+#define ROTATE_180                  2
+#define ROTATE_LEFT                 3
+
+/* 
+ * IOCTL's
+ */
+
+/* surface type */
+#define AGP_DMA        1
+#define AGP_SURFACE    2
+#define AGP_SAREA      3
+
+/* command */
+#define RELEASE_FB     1
+#define EMIT_DMA       2
+
+#define I810FB_IOC_AREYOUTHERE         _IO  ('F', 0xFF)
+#define I810FB_IOC_REQUESTAGPMEM       _IOWR('F', 0xFE, agp_mem_user)
+#define I810FB_IOC_RELEASEAGPMEM       _IOW ('F', 0xFD, agp_mem_user)
+#define I810FB_IOC_COMMAND             _IOW ('F', 0xFC, i810_command) 
+#define I810FB_IOC_ACQUIREFB           _IOR ('F', 0xFB, int)
+#define I810FB_IOC_RELEASEGART         _IO  ('F', 0xFA)
+#define I810FB_IOC_CLAIMGART           _IO  ('F', 0xF9)
+
+/* Resource Management Structures */
+typedef struct __agp_surface {
+	u32 user_key;
+	u32 surface_key;
+	u32 offset;
+	u32 pgsize;
+	u32 type;
+} agp_mem_user;
+
+typedef struct __agp_mem_struct {
+	struct list_head agp_list;
+	agp_memory *surface;
+	u32 user_key;
+	u32 surface_type;
+	u32 trusted;
+} agp_mem_struct;	
+
+typedef struct __i810_command_struct {
+	u32 command;                        /* command type */ 
+	u32 user_key;                       /* user key */
+	u32 surface_key;                    /* key to the agp memory pertaining to the structure */
+	u32 dma_cmd_start;                  /* offset to start of instruction packets */
+	u32 dma_cmd_dsize;                  /* the number of instructions in dwords to DMA */
+} i810_command;
+
+/* 
+ * if cur_user_key and cur_surface_key matches, and is_valid is true, then head and tail
+ * can be read.  Otherwise, treat the DMA buffer to have undergone a sync/reset where the 
+ * software can arbitrarily choose its own tail and head values.
+ */ 
+typedef struct __i810_gtt_shared {
+	u32 reserved[4];
+	u32 cur_user_key;                   /* user key of current DMA being processed */
+	u32 cur_surface_key;                /* surface key of current DMA bing processed */
+	u32 is_valid;                       /* if true, all values in the sarea are 
+					       valid for the current user/surface key */        
+	u32 head;                           /* current IP start offset of DMA buffer */
+	u32 tail;                           /* current IP end offset of DMA buffer */
+	u32 busy;
+} i810_sarea; 
+
+/* Driver specific structures */
+
+/* Registers to set on a per display mode basis */
+struct mode_registers {
+	u32 pixclock, M, N, P;
+	u8 cr00, cr01, cr02, cr03;
+	u8 cr04, cr05, cr06, cr07;
+	u8 cr09, cr10, cr11, cr12;
+	u8 cr13, cr15, cr16, cr30;
+	u8 cr31, cr32, cr33, cr35, cr39;
+	u32 bpp8_100, bpp16_100;
+	u32 bpp24_100, bpp8_133;
+	u32 bpp16_133, bpp24_133;
+	u8 msr;
+};
+
+struct ringbuffer {
+	u32 tail;
+	u32 head;
+	u32 start;
+	u32 size;
+};
+
+/* save-state registers */
+struct state_registers {
+	struct ringbuffer iring_state;	
+	u32 dclk_1d, dclk_2d, dclk_0ds;
+	u32 pixconf, fw_blc, pgtbl_ctl;
+	u32 fence0, hws_pga;
+	u16 bltcntl, hwstam, ier, iir, imr;
+	u8 cr00, cr01, cr02, cr03, cr04;
+	u8 cr05, cr06, cr07, cr08, cr09;
+	u8 cr10, cr11, cr12, cr13, cr14;
+	u8 cr15, cr16, cr17, cr80, gr10;
+	u8 cr30, cr31, cr32, cr33, cr35;
+	u8 cr39, cr41, cr70, sr01, msr;
+};
+
+struct cursor_data {
+	u32 cursor_enable;
+	u32 cursor_show;
+	u32 blink_count;
+	u32 blink_rate;
+	struct timer_list *timer;
+};	
+
+struct accel_data {
+	agp_memory *i810_iring_memory;
+	u32 iring_start_phys;
+	u32 iring_start_virtual;
+	u32 iring_offset;
+	u32 cur_tail;
+	u32 lockup;
+	u32 fb_offset;
+	u32 sync;
+};
+
+struct iface_data {
+	struct list_head agp_list_head;
+	agp_memory *i810_sarea_memory;
+	i810_sarea *sarea;
+	u32 *gtt_map;
+	u32 *user_key_list;
+	u32 *has_sarea_list;
+	u32 *cur_dma_buf_phys;
+	u32 *cur_dma_buf_virt;
+	u32 cur_dma_size;
+	u32 fb_size;
+	u32 aper_size;
+	u32 fb_base_virt;
+	u32 fb_base_phys;
+	u32 sarea_start_phys;
+	u32 sarea_start_virt;
+	u32 sarea_offset;
+	u32 trusted;
+	u32 lockup;
+};	
+
+struct gtt_data {
+	agp_kern_info i810_gtt_info;
+	agp_memory *i810_fb_memory;
+	agp_memory *i810_cursor_memory;
+	u32 fence_size;
+	u32 tile_pitch;
+	u32 pitch_bits;
+};
+
+struct video_timings {
+	u32 pixelclock;
+	u32 htotal;
+	u32 vtotal;
+	u32 hfreq;
+	u32 vfreq;
+	u32 hblank;
+	u32 vblank;
+};
+
+struct orientation {
+	u32 xres;
+	u32 vxres;
+	u32 yres;
+	u32 vyres;
+	u32 rotate;
+	u32 xres_var;
+	u32 vxres_var;
+	u32 yres_var;
+	u32 vyres_var;
+	u32 rotate_var;
+};	
+
+struct i810_fbinfo {
+	struct fb_info         fb_info;                      
+	struct state_registers hw_state;
+	struct mode_registers  mode_params;
+	struct cursor_data     cursor;
+	struct timer_list      gart_timer;
+	struct gtt_data        i810_gtt;
+	struct display         disp;
+	struct timer_list      gart_countdown_timer;
+	u32 fb_size;
+	u32 fb_start_virtual;
+	u32 fb_start_phys;
+	u32 fb_base_phys;
+	u32 fb_base_virtual;
+	u32 fb_offset;
+	u32 mmio_start_phys;
+	u32 mmio_start_virtual;
+	u32 cursor_start_phys;
+	u32 cursor_start_virtual;
+	u32 cursor_offset;
+	u32 aper_size;
+	u32 mem_freq;
+	u32 gart_is_claimed;
+	u32 gart_countdown_active;
+	u32 in_context;
+	u32 mtrr_is_set;
+	int mtrr_reg;
+};
+
+#endif /* __I810_COMMON_H__ */
--- linux-2.4.22/drivers/video/i810/i810_fbcon.c.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_fbcon.c	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,358 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_fbcon.c -- Console Drawing Functions
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/tty.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+
+#include "i810_regs.h"
+#include "i810_common.h"
+#include "i810_fbcon.h"
+
+/*
+ * Crash Handling
+ */
+
+/**
+ * i810_gart_countdown_handler - crash handler
+ * @data: pointer to arbitrary data, presently NULL
+ *
+ * DESCRIPTION:
+ * This handler will attempt to recover the hardware state from whatever
+ * process that failed to release the device.  This is called via
+ * a timer.  It will only attempt recovery when fbcon is in context, otherwise,
+ * the handler will just exit. 
+ */
+static void i810_gart_countdown_handler(unsigned long data)
+{
+	if (!i810_info->gart_countdown_active) 
+		return;
+	if (i810_info->in_context && i810_info->gart_is_claimed)
+		i810fb_reacquire_gart();
+	del_timer(&i810_info->gart_countdown_timer);
+	i810_info->gart_countdown_active = 0; 
+}	
+
+/**
+ * i810fb_start_countdown - initiates crash handler timer
+ *
+ * DESCRIPTION:
+ * If fbcon comes into context, and the device is still claimed, this
+ * function will initiate a 5-second timer, which upon expiration will
+ * start the recovery process
+ */
+static void i810fb_start_countdown(void) 
+{
+	if (i810_info->gart_countdown_active)
+		return;
+	i810_info->gart_countdown_active = 1;
+	init_timer(&i810_info->gart_countdown_timer);	
+	i810_info->gart_countdown_timer.data = 0;
+	i810_info->gart_countdown_timer.expires = jiffies + (HZ * 5);
+	i810_info->gart_countdown_timer.function = i810_gart_countdown_handler;
+	add_timer(&i810_info->gart_countdown_timer);
+}
+
+/**
+ * not_safe - determines if it's safe to use the graphics device
+ *
+ * DESCRIPTION:
+ * Checks if the current GART is claimed or not.
+ * If the GART is claimed, then it will initiate a 5 second
+ * timer in an attempt to recover the framebuffer state.
+ *
+ * RETURNS:
+ * a nonzero if true
+ */
+
+inline int not_safe(void)
+{
+	if (!i810_info->in_context)
+		i810_info->in_context = 1;
+	if (!i810_info->gart_is_claimed) 
+		return 0;
+	i810fb_start_countdown();
+	return 1;
+}		 
+
+void i810_cursor(struct display *p, int mode, int xx, int yy)
+{
+	int temp = 0, w, h;
+	
+	h = fontheight(p);
+	w = fontwidth(p);
+	yy -= p->yscroll;
+	yy *= h;
+	xx *= w;
+	switch (i810_orient->rotate) {
+	case NO_ROTATION:
+		temp = xx & 0xFFFF;
+		temp |= yy << 16;
+		break;
+	case ROTATE_RIGHT:
+		temp = (i810_orient->xres - (yy+h)) & 0xFFFF;
+		temp |= xx << 16;
+		break;
+	case ROTATE_180:
+		temp = (i810_orient->xres - (xx+w)) & 0xFFFF;
+		temp |= (i810_orient->yres - (yy+h)) << 16;
+		break;
+	case ROTATE_LEFT:
+		temp = yy & 0xFFFF;
+		temp |= (i810_orient->yres - (xx+w)) << 16;
+		break;
+	}
+	i810fb_enable_cursor(OFF);
+	i810_writel(CURPOS, temp);
+	
+	switch (mode) {
+		case CM_ERASE:
+			i810_info->cursor.cursor_enable = 0;
+			break;
+		case CM_MOVE:
+		case CM_DRAW:
+			i810fb_enable_cursor(ON);
+			i810_info->cursor.blink_count = 
+				i810_info->cursor.blink_rate;
+			i810_info->cursor.cursor_enable = 1;
+			i810_info->cursor.cursor_show = 1;
+				
+	}
+} 
+
+/* 
+ * The following are wrappers for the generic framebuffer operations.  Each
+ * is preceeded by a call to 'not_safe' before calling the actual generic 
+ * operation.
+ */
+ 
+void i810_noaccel8_bmove(struct display *p, int sy, int sx, int dy, int dx,
+			 int height, int width)
+{
+	if (not_safe()) return;
+	fbcon_cfb8_bmove(p, sy, sx, dy, dx, height, width);
+}
+
+void i810_noaccel8_clear(struct vc_data *conp, struct display *p, 
+			 int sy, int sx, int height, int width)
+{
+	if (not_safe()) return;
+	fbcon_cfb8_clear(conp, p, sy, sx, height, width);
+}
+
+void i810_noaccel8_putc(struct vc_data *conp, struct display *p, 
+			int c, int yy, int xx)
+{	    
+	if (not_safe()) return;
+	fbcon_cfb8_putc(conp, p, c, yy, xx);
+}
+
+void i810_noaccel8_putcs(struct vc_data *conp, struct display *p,
+			 const unsigned short *s, int count, int yy, int xx)
+{
+	if (not_safe()) return;
+	fbcon_cfb8_putcs(conp, p, s, count, yy, xx);
+}
+
+void i810_noaccel8_revc(struct display *p, int xx, int yy)
+{	                        	                                     
+	if (not_safe()) return;
+	fbcon_cfb8_revc(p, xx, yy);
+}
+
+void i810_noaccel8_clear_margins(struct vc_data *conp, struct display *p,
+				 int bottom_only)
+{           
+	if (not_safe()) return;
+	fbcon_cfb8_clear_margins(conp, p, bottom_only);
+}
+
+
+void i810_noaccel16_bmove(struct display *p, int sy, int sx, int dy, int dx,
+                       int height, int width)
+{
+	if (not_safe()) return;
+	fbcon_cfb16_bmove(p, sy, sx, dy, dx, height, width);
+}
+
+void i810_noaccel16_clear(struct vc_data *conp, struct display *p, 
+			  int sy, int sx, int height, int width)
+{
+	if (not_safe()) return;
+	fbcon_cfb16_clear(conp, p, sy, sx, height, width);
+}
+
+void i810_noaccel16_putc(struct vc_data *conp, struct display *p, 
+			 int c, int yy, int xx)
+{	    
+	if (not_safe()) return;
+	fbcon_cfb16_putc(conp, p, c, yy, xx);
+}
+
+void i810_noaccel16_putcs(struct vc_data *conp, struct display *p,
+                        const unsigned short *s, int count, int yy, int xx)
+{
+	if (not_safe()) return;
+	fbcon_cfb16_putcs(conp, p, s, count, yy, xx);
+}
+
+void i810_noaccel16_revc(struct display *p, int xx, int yy)
+{	                                       	                        
+	if (not_safe()) return;
+	fbcon_cfb16_revc(p, xx, yy);
+}
+
+void i810_noaccel16_clear_margins(struct vc_data *conp, struct display *p,
+                               int bottom_only)
+{           
+	if (not_safe()) return;
+	fbcon_cfb16_clear_margins(conp, p, bottom_only);
+}
+
+void i810_noaccel24_bmove(struct display *p, int sy, int sx, int dy, int dx,
+                       int height, int width)
+{
+	if (not_safe()) return;
+	fbcon_cfb24_bmove(p, sy, sx, dy, dx, height, width);
+}
+
+void i810_noaccel24_clear(struct vc_data *conp, struct display *p, 
+			  int sy, int sx, int height, int width)
+{
+	if (not_safe()) return;
+	fbcon_cfb24_clear(conp, p, sy, sx, height, width);
+}
+
+void i810_noaccel24_putc(struct vc_data *conp, struct display *p, 
+			 int c, int yy, int xx)
+{	    
+	if (not_safe()) return;
+	fbcon_cfb24_putc(conp, p, c, yy, xx);
+}
+
+void i810_noaccel24_putcs(struct vc_data *conp, struct display *p,
+                        const unsigned short *s, int count, int yy, int xx)
+{
+	if (not_safe()) return;
+	fbcon_cfb24_putcs(conp, p, s, count, yy, xx);
+}
+
+void i810_noaccel24_revc(struct display *p, int xx, int yy)
+{	                                    	                        
+	if (not_safe()) return;
+	fbcon_cfb24_revc(p, xx, yy);
+}
+
+void i810_noaccel24_clear_margins(struct vc_data *conp, struct display *p,
+                               int bottom_only)
+{           
+	if (not_safe()) return;
+	fbcon_cfb24_clear_margins(conp, p, bottom_only);
+}
+
+void i810_noaccel32_bmove(struct display *p, int sy, int sx, int dy, int dx,
+                       int height, int width)
+{
+	if (not_safe()) return;
+	fbcon_cfb32_bmove(p, sy, sx, dy, dx, height, width);
+}
+
+void i810_noaccel32_clear(struct vc_data *conp, struct display *p, 
+			  int sy, int sx, int height, int width)
+{
+	if (not_safe()) return;
+	fbcon_cfb32_clear(conp, p, sy, sx, height, width);
+}
+
+void i810_noaccel32_putc(struct vc_data *conp, struct display *p, 
+			 int c, int yy, int xx)
+{	    
+	if (not_safe()) return;
+	fbcon_cfb32_putc(conp, p, c, yy, xx);
+}
+
+void i810_noaccel32_putcs(struct vc_data *conp, struct display *p,
+                        const unsigned short *s, int count, int yy, int xx)
+{
+	if (not_safe()) return;
+	fbcon_cfb32_putcs(conp, p, s, count, yy, xx);
+}
+
+void i810_noaccel32_revc(struct display *p, int xx, int yy)
+{	                                    	                        
+	if (not_safe()) return;
+	fbcon_cfb32_revc(p, xx, yy);
+}
+
+void i810_noaccel32_clear_margins(struct vc_data *conp, struct display *p,
+                               int bottom_only)
+{           
+	if (not_safe()) return;
+	fbcon_cfb32_clear_margins(conp, p, bottom_only);
+}
+
+struct display_switch i810_noaccel8 = {
+	fbcon_cfb8_setup,
+	i810_noaccel8_bmove,
+	i810_noaccel8_clear,
+	i810_noaccel8_putc,
+	i810_noaccel8_putcs,
+	i810_noaccel8_revc,
+	NULL,
+	NULL,
+	i810_noaccel8_clear_margins,
+	FONTWIDTH(8) | FONTWIDTH(16)
+};
+
+struct display_switch i810_noaccel16 = {	
+	fbcon_cfb16_setup,
+	i810_noaccel16_bmove,
+	i810_noaccel16_clear,
+	i810_noaccel16_putc,
+	i810_noaccel16_putcs,
+	i810_noaccel16_revc,
+	NULL,
+	NULL,
+	i810_noaccel16_clear_margins,
+	FONTWIDTH(8) | FONTWIDTH(16)
+};
+
+struct display_switch i810_noaccel24 = {	
+	fbcon_cfb24_setup,
+	i810_noaccel24_bmove,
+	i810_noaccel24_clear,
+	i810_noaccel24_putc,
+	i810_noaccel24_putcs,
+	i810_noaccel24_revc,
+	NULL,
+	NULL,
+	i810_noaccel24_clear_margins,
+	FONTWIDTH(8) | FONTWIDTH(16)
+};
+
+struct display_switch i810_noaccel32 = {	
+	fbcon_cfb32_setup,
+	i810_noaccel32_bmove,
+	i810_noaccel32_clear,
+	i810_noaccel32_putc,
+	i810_noaccel32_putcs,
+	i810_noaccel32_revc,
+	NULL,
+	NULL,
+	i810_noaccel32_clear_margins,
+	FONTWIDTH(8) | FONTWIDTH(16)
+};
+
--- linux-2.4.22/drivers/video/i810/i810_fbcon.h.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_fbcon.h	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,32 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_fbcon.h -- Console Drawing Functions
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#ifndef __I810_FBCON_H__
+#define __I810_FBCON_H__
+
+extern struct i810_fbinfo *i810_info;
+extern struct orientation *i810_orient;
+extern inline void i810_writel          (u32 where, u32 val);
+extern int         i810fb_reacquire_gart(void);
+extern u32         get_line_length      (int xres_virtual, int bpp);
+extern void        i810fb_enable_cursor (int mode);
+
+extern inline void mono_pat_blit        (int dpitch, int dheight, int dwidth, int dest, 
+					 int fg, int bg, int rop, int patt_1, int patt_2, 
+					 int blit_bpp);
+extern inline void source_copy_blit     (int dwidth, int dheight, int dpitch, int xdir, 
+					 int spitch, int src, int dest, int rop, int blit_bpp);
+extern inline void color_blit           (int width, int height, int pitch, 
+					 int dest, int rop, int what, int blit_bpp);
+
+extern inline void arb_on_off            (u32 mode);
+#endif /* __I810_FBCON_H__ */
--- linux-2.4.22/drivers/video/i810/i810_fbcon_accel.c.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_fbcon_accel.c	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,388 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_fbcon_accel.c -- Accelereted Console Drawing Functions
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/tty.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+
+#include "i810_regs.h"
+#include "i810_common.h"
+#include "i810_fbcon_accel.h"
+
+/* 
+ * Helper functions
+ */
+
+inline int i810_accel8_getbg(struct display *p, int c)
+{
+	return attr_bgcol(p, c);
+}
+
+inline int i810_accel8_getfg(struct display *p, int c)
+{
+	return attr_fgcol(p, c);
+}
+
+inline int i810_accel16_getbg(struct display *p, int c)
+{
+	return (int) ((u16 *) p->dispsw_data)[attr_bgcol(p, c)];
+}
+
+inline int i810_accel16_getfg(struct display *p, int c)
+{
+	return (int) ((u16 *) p->dispsw_data)[attr_fgcol(p, c)];
+}
+
+inline int i810_accel24_getbg(struct display *p, int c)
+{
+	return ((int *) p->dispsw_data)[attr_bgcol(p, c)];
+}
+
+inline int i810_accel24_getfg(struct display *p, int c)
+{
+	return ((int *) p->dispsw_data)[attr_fgcol(p, c)];
+}
+void i810_accel_setup(struct display *p)
+{
+	p->next_line = p->line_length ? p->line_length : 
+		get_line_length(i810_orient->vxres, p->var.bits_per_pixel);
+	p->next_plane = 0;
+}
+
+/*
+ * Start of actual drawing functions
+ */
+void i810_accel_bmove(struct display *p, int sy, int sx, 
+		      int dy, int dx, int height, int width)
+{
+	int pitch, xdir, src, dest, mult, blit_bpp = 0;
+	
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	dy *= fontheight(p);
+	sy *= fontheight(p);
+	height *= fontheight(p);
+ 	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		break;
+	}
+
+	sx *= fontwidth(p) * mult;
+	dx *= fontwidth(p) * mult;
+	width *= fontwidth(p) * mult;			
+
+	if (dx <= sx) 
+		xdir = INCREMENT;
+	else {
+		xdir = DECREMENT;
+		sx += width - 1;
+		dx += width - 1;
+	}
+	if (dy <= sy) 
+		pitch = p->next_line;
+	else {
+		pitch = (-(p->next_line)) & 0xFFFF; 
+		sy += height - 1;
+		dy += height - 1;
+	}
+	src = (i810_accel->fb_offset << 12) + (sy * p->next_line) + sx; 
+	dest = (i810_accel->fb_offset << 12) + (dy * p->next_line) + dx;
+	source_copy_blit(width, height, pitch, xdir, 
+			 pitch, src, dest, PAT_COPY_ROP, blit_bpp);
+}
+
+void i810_accel_putc(struct vc_data *conp, struct display *p, 
+		     int c, int yy, int xx)
+{
+	u8 *cdat;
+	int dheight, dwidth, dpitch, fg = 0, bg = 0;
+	int dest, fontwidth, mult, blit_bpp = 8;
+	int i, j, cols, rows, pattern = 0;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	/* 8x8 pattern blit */
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	dheight = 8;              
+	dwidth = mult << 3;
+	dpitch = p->next_line;
+	switch (mult) {
+	case 1:
+		fg = (int) attr_fgcol(p,c);
+		bg = (int) attr_bgcol(p,c);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bg = (int) ((u16 *)p->dispsw_data)[attr_bgcol(p, c)];
+		fg = (int) ((u16 *)p->dispsw_data)[attr_fgcol(p, c)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		fg = ((int *) p->dispsw_data)[attr_fgcol(p, c)];
+		bg = ((int *) p->dispsw_data)[attr_bgcol(p, c)];
+		blit_bpp = BPP24;
+	}
+	rows = fontheight(p) >> 3;
+	if(fontwidth(p) <= 8) {
+		fontwidth = 8;
+		cdat = p->fontdata + ((c & p->charmask) * fontheight(p));
+		cols = 1;
+	}
+	else {
+		fontwidth = fontwidth(p);
+		cdat = p->fontdata + 
+			((c & p->charmask) * (fontwidth >> 3) * fontheight(p));
+		cols = fontwidth >> 3;
+	}
+	dest = (i810_accel->fb_offset << 12) + 
+		(yy * fontheight(p) * p->next_line) + 
+		xx * (fontwidth * mult);
+
+	for (i = cols; i--; ) {
+		for (j = 0; j < rows; j++) {
+			pattern = j << (cols + 2);
+			mono_pat_blit(dpitch, dheight, dwidth, 
+				      dest + (j * (dpitch << 3)),
+				      fg, bg, COLOR_COPY_ROP, 
+				      *(u32 *)(cdat + pattern), 
+				      *(u32 *)(cdat + pattern + (cols << 2)),
+				      blit_bpp);
+		}
+		cdat += 4;
+		dest += dwidth;
+	}
+}
+
+
+void i810_accel_putcs(struct vc_data *conp, struct display *p,
+			const unsigned short *s, int count, int yy, int xx)
+{
+	u8 *cdat, *cdat0;
+	int chars, dpitch, dheight, dwidth, dest, next;
+	int mult, fontwidth, blit_bpp = 0, cols, rows;
+	int c, dest0, i, j;
+	int (*get_bg)(struct display *p, int c) = NULL;
+	int (*get_fg)(struct display *p, int c) = NULL;
+	
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		get_bg = i810_accel8_getbg;
+		get_fg = i810_accel8_getfg;
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		get_bg = i810_accel16_getbg;
+		get_fg = i810_accel16_getfg;
+		blit_bpp = BPP16;
+		break;
+	case 3:	
+		get_bg = i810_accel24_getbg;
+		get_fg = i810_accel24_getfg;
+		blit_bpp = BPP24;
+	}
+	
+	dwidth = mult << 3;
+	dheight = 8;
+	dpitch = p->next_line;
+	rows = fontheight(p) >> 3;
+
+	if(fontwidth(p) <= 8) {
+		cols = 1;
+		fontwidth = 8;
+	}
+	else {
+		cols = fontwidth(p) >> 3;
+		fontwidth = fontwidth(p);
+	}
+
+	dest = (i810_accel->fb_offset << 12) + 
+		(yy * fontheight(p) * p->next_line) + 
+		(xx * (fontwidth * mult));
+	chars = p->next_line/fontwidth;
+	next = 1 << (cols + 2);
+	while(count--) {
+		c = scr_readw(s++);
+		cdat = p->fontdata + ((c & p->charmask)*cols*fontheight(p));
+		for (i = cols; i--; ) {
+			dest0 = dest;
+			cdat0 = cdat;
+			for(j = rows; j--; ) {
+				mono_pat_blit(dpitch, dheight, dwidth, dest0, 
+					      get_fg(p, c), get_bg(p, c), 
+					      COLOR_COPY_ROP, 
+					      *((u32 *) (cdat0)),
+					      *((u32 *) (cdat0 + (cols << 2))),
+					      blit_bpp);
+				dest0 += dpitch << 3;      	      
+				cdat0 += next;
+			}
+			dest += dwidth;
+			cdat += 4;
+		}
+		if(++xx > chars) {
+			xx = 0;
+			yy++;
+			dest = (i810_accel->fb_offset << 12) + 
+				(yy * fontheight(p) * p->next_line);
+		}
+		
+	}	 
+}
+
+void i810_accel_revc(struct display *p, int xx, int yy)
+{
+	int width, height, dest, pitch, mult, blit_bpp = 0;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		break;
+	}
+	pitch = p->next_line;
+	if (fontwidth(p) <= 8)
+		width = 8*mult;
+	else
+		width = fontwidth(p)*mult;
+	height = fontheight(p);
+	dest = (i810_accel->fb_offset << 12) + 
+		(yy * height * p->next_line) + 
+		(xx * width);
+	color_blit(width, height, pitch, dest, INVERT_ROP, 0x0F, blit_bpp);
+}
+
+void i810_accel_clear(struct vc_data *conp, struct display *p, 
+		      int sy, int sx, int height, int width)
+{
+	int mult, blit_bpp = 0;
+	u32 bgx = 0, dest = 0;
+	
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	height *= fontheight(p);
+	sy *= fontheight(p);
+
+	switch(mult) {
+	case 1:
+		bgx = (u32) attr_bgcol_ec(p, conp);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bgx = (int) ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		bgx = ((int *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP24;
+	}	         	         
+
+	width *= fontwidth(p) * mult;
+	sx *= fontwidth(p) * mult;
+	dest = (i810_accel->fb_offset << 12) + 
+		(sy * p->next_line) + sx;
+	color_blit(width, height, p->next_line, dest, 
+		   COLOR_COPY_ROP, bgx, blit_bpp);
+}
+
+void i810_accel_clear_margins(struct vc_data *conp, struct display *p,
+			       int bottom_only)
+{
+	int bytes = p->next_line, blit_bpp = 0;
+	u32 bgx = 0, mult;
+	unsigned int right_start;
+	unsigned int bottom_start;
+	unsigned int right_width, bottom_height;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+
+	switch(mult) {
+	case 1:
+		bgx = (u32) attr_bgcol_ec(p, conp);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bgx = (int) ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		bgx = ((int *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+	}	         	         
+
+	right_width = p->var.xres % fontwidth(p);
+	right_start = p->var.xres - right_width;
+	if (!bottom_only && right_width) 
+		color_blit(right_width*mult, p->var.yres_virtual, bytes, 
+			   (i810_accel->fb_offset << 12) + 
+			   ((right_start+p->var.xoffset)*mult), 
+			   COLOR_COPY_ROP, bgx, blit_bpp); 
+	bottom_height = p->var.yres % fontheight(p);
+	if (bottom_height) {
+		bottom_start = p->var.yres - bottom_height;
+		color_blit(right_start*mult, bottom_height, bytes, 
+			   (i810_accel->fb_offset << 12) + 
+			   (p->var.yoffset+bottom_start)*bytes, 
+			   COLOR_COPY_ROP, bgx, blit_bpp);
+	}
+}
+
+struct display_switch i810_accel_upright = {
+	i810_accel_setup,
+	i810_accel_bmove,
+	i810_accel_clear,
+	i810_accel_putc,
+	i810_accel_putcs,
+	i810_accel_revc,
+	NULL,
+	NULL,
+	i810_accel_clear_margins,
+	FONTWIDTH(8) | FONTWIDTH(16)
+};
+
--- linux-2.4.22/drivers/video/i810/i810_fbcon_accel.h.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_fbcon_accel.h	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,33 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_fbcon_accel.h -- Accelerated Console Drawing Functions
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#ifndef __I810_FBCON_ACCEL_H__
+#define __I810_FBCON_ACCEL_H__
+
+extern struct accel_data*  i810_accel;
+extern struct orientation* i810_orient;  
+extern inline void i810_writel          (u32 where, u32 val);
+extern int         i810fb_reacquire_gart(void);
+extern u32         get_line_length      (int xres_virtual, int bpp);
+extern void        i810fb_enable_cursor (int mode);
+
+extern inline void mono_pat_blit        (int dpitch, int dheight, int dwidth, int dest, 
+					 int fg, int bg, int rop, int patt_1, int patt_2, 
+					 int blit_bpp);
+extern inline void source_copy_blit     (int dwidth, int dheight, int dpitch, int xdir, 
+					 int spitch, int src, int dest, int rop, int blit_bpp);
+extern inline void color_blit           (int width, int height, int pitch, 
+					 int dest, int rop, int what, int blit_bpp);
+
+extern void        i810_cursor          (struct display *p, int mode, int xx, int yy);
+extern inline int  not_safe             (void);
+#endif /* __I810_FBCON_ACCEL_H__ */
--- linux-2.4.22/drivers/video/i810/i810_fbcon_rotate.c.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_fbcon_rotate.c	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,1180 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_fbcon_rotate.c -- Console Rotated Drawing Functions
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/tty.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+
+#include "i810_regs.h"
+#include "i810_common.h"
+#include "i810_fbcon_rotate.h"
+
+/*
+ * 8x8 (2D array) pixel monochrome pattern operations
+ */
+
+/**
+ * pat_test_bit - test if bit in a pattern is set
+ * @rows: y-position of bit
+ * @cols: x-position of bit
+ * @pat: pointer to pixel array
+ * @width: fontwidth
+ */
+static inline u32 pat_test_bit(u32 rows, u32 cols, u32 *pat, u32 width)
+{
+	return (test_bit((rows * width) + cols, pat));
+}
+
+/**
+ * pat_set_bit - set a bit in a pattern
+ * @rows: y-position of bit
+ * @cols: x-position of bit
+ * @pat: pointer to pixel array
+ * @width: fontwidth
+ */
+static inline void pat_set_bit(u32 rows, u32 cols, u32 *pat, u32 width)
+{
+	set_bit((rows * width) + cols, pat);
+}
+
+/**
+ * rotate_left - rotate pattern 90 degrees to the left
+ * @pat1: original pattern
+ * @pat2: where to place result of rotation
+ * @width: fontwidth
+ */
+static inline void rotate_left(u32 *pat1, u32 *pat2, u32 width)
+{
+	u32 rows, cols;
+	
+	memset((void *) pat2, 0, 8);
+	for (rows = 0; rows < 8; rows++) {
+		for (cols = 0; cols < 8; cols++) {
+			if (pat_test_bit(7 - cols, rows, pat1, width))
+				pat_set_bit(rows, cols, pat2, width);
+		}
+	}
+}
+
+/**
+ * rotate_right - rotate pattern 90 degrees to the right
+ * @pat1: original pattern
+ * @pat2: where to place result of rotation
+ * @width: font width
+ */
+static inline void rotate_right(u32 *pat1, u32 *pat2, u32 width)
+{
+	u32 rows, cols;
+	
+	memset((void *) pat2, 0, 8);
+	for (rows = 0; rows < 8; rows++) {
+		for (cols = 0; cols < 8; cols++) {
+			if (pat_test_bit(cols, 7 - rows, pat1, width))
+				pat_set_bit(rows, cols, pat2, width);
+		}
+	}
+}
+
+/**
+ * rotate_180 - rotate pattern 180 degrees
+ * @pat1: original pattern
+ * @pat2: where to place result of rotation
+ * @width: font width
+ */
+static inline void rotate_180(u32 *pat1, u32 *pat2, u32 width)
+{
+	u32 rows, cols;
+	
+	memset((void *) pat2, 0, 8);
+	for (rows = 0; rows < 8; rows++) {
+		for (cols = 0; cols < 8; cols++) {
+			if (pat_test_bit(7 - rows, 7 - cols, pat1, width))
+				pat_set_bit(rows, cols, pat2, width);
+		}
+	}
+}
+
+/* 
+ * The next functions are the accelerated equivalents of the
+ * generic framebuffer operation.  Each function will only 
+ * proceed if the graphics table is valid.  They all finally
+ * end up calling one of the BLIT functions.
+ */
+
+void i810_accel_ud_bmove(struct display *p, int sy, int sx, 
+			 int dy, int dx, int height, int width)
+{
+	int pitch, xdir, src, dest, mult, blit_bpp = 0;
+	u32 xstart, ystart;
+	
+	if (i810_accel->lockup || not_safe())
+		return;
+
+ 	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		break;
+	}
+
+	dy *= fontheight(p);
+	sy *= fontheight(p);
+	height *= fontheight(p);
+
+	sx *= fontwidth(p) * mult;
+	dx *= fontwidth(p) * mult;
+	width *= fontwidth(p) * mult;			
+
+	if (dx >= sx) { 
+		xdir = INCREMENT;
+		sx += width;
+		dx += width;
+	}
+	else 
+		xdir = DECREMENT;
+
+	if (dy >= sy) { 
+		pitch = p->next_line;
+		sy += height;
+		dy += height;
+	}
+	else 
+		pitch = (-(p->next_line)) & 0xFFFF; 
+
+	xstart = i810_orient->vxres * mult;
+	ystart = i810_orient->vyres;
+
+	src = (i810_accel->fb_offset << 12) + 
+		((ystart - sy) * p->next_line) + 
+		(xstart - sx); 
+	dest = (i810_accel->fb_offset << 12) + 
+		((ystart - dy) * p->next_line) + 
+		(xstart - dx); 
+	source_copy_blit(width, height, pitch, xdir, 
+			 pitch, src, dest, PAT_COPY_ROP, blit_bpp);
+}
+
+void i810_accel_rl_bmove(struct display *p, int sy, int sx, 
+			 int dy, int dx, int height, int width)
+{
+	int pitch, xdir, src, dest, mult, blit_bpp = 0;
+	u32 ystart;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		break;
+	}
+
+	sx *= fontwidth(p);
+	dx *= fontwidth(p);
+	width *= fontwidth(p);			
+
+	dy *= fontheight(p) * mult;
+	sy *= fontheight(p) * mult;
+	height *= fontheight(p) * mult;
+
+	if (dy <= sy) 
+		xdir = INCREMENT;
+	else {
+		xdir = DECREMENT;
+		sy += height - 1;
+		dy += height - 1;
+	}
+	if (dx >= sx) {
+		pitch = p->next_line;
+		sx += width;
+		dx += width;
+	}
+	else 
+		pitch = (-(p->next_line)) & 0xFFFF; 
+
+	ystart = i810_orient->vyres;
+
+	src = (i810_accel->fb_offset << 12) + sy +
+		((ystart - sx) * p->next_line);
+	dest = (i810_accel->fb_offset << 12) + dy +
+		((ystart - dx) * p->next_line);
+	source_copy_blit(height, width, pitch, xdir, 
+			 pitch, src, dest, PAT_COPY_ROP, blit_bpp);
+}
+
+void i810_accel_rr_bmove(struct display *p, int sy, int sx, 
+			 int dy, int dx, int height, int width)
+{
+	int pitch, xdir, src, dest, mult, blit_bpp = 0;
+	u32 xstart;
+	
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		break;
+	}
+
+	sx *= fontwidth(p);
+	dx *= fontwidth(p);
+	width *= fontwidth(p);			
+
+	dy *= fontheight(p) * mult;
+	sy *= fontheight(p) * mult;
+	height *= fontheight(p) * mult;
+
+	if (dy >= sy) {
+		xdir = INCREMENT;
+		sy += height;
+		dy += height;
+	}
+	else 
+		xdir = DECREMENT;
+
+	if (dx <= sx) 
+		pitch = p->next_line;
+	else {
+		pitch = (-(p->next_line)) & 0xFFFF; 
+		sx += width - 1;
+		dx += width - 1;
+	}
+	xstart = i810_orient->vxres * mult;
+	
+	src = (i810_accel->fb_offset << 12) + 
+		(sx * p->next_line) + 
+		(xstart - sy);
+	dest = (i810_accel->fb_offset << 12) +
+		(dx * p->next_line) +
+		(xstart - dy);
+	source_copy_blit(height, width, pitch, xdir, 
+			 pitch, src, dest, PAT_COPY_ROP, blit_bpp);
+}
+
+void i810_accel_ud_clear(struct vc_data *conp, struct display *p, 
+			 int sy, int sx, int height, int width)
+{
+	int mult, blit_bpp = 0;
+	u32 bgx = 0, dest = 0, xstart, ystart;
+	
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+
+	switch(mult) {
+	case 1:
+		bgx = (u32) attr_bgcol_ec(p, conp);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bgx = (int) ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		bgx = ((int *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP24;
+	}	         	         
+
+	height *= fontheight(p);
+	sy *= fontheight(p);
+	sy += height;
+
+	width *= fontwidth(p) * mult;
+	sx *= fontwidth(p) * mult;
+	sx += width;
+
+	xstart = i810_orient->vxres * mult;
+	ystart = i810_orient->vyres;
+	
+	dest = (i810_accel->fb_offset << 12) + 
+		((ystart - sy) * p->next_line) +
+		(xstart - sx);
+	color_blit(width, height, p->next_line, dest, 
+		   COLOR_COPY_ROP, bgx, blit_bpp);
+}
+
+void i810_accel_rl_clear(struct vc_data *conp, struct display *p, 
+			 int sy, int sx, int height, int width)
+{
+	int mult, blit_bpp = 0;
+	u32 bgx = 0, dest = 0;
+	u32 ystart;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+
+	switch(mult) {
+	case 1:
+		bgx = (u32) attr_bgcol_ec(p, conp);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bgx = (int) ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		bgx = ((int *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP24;
+	}	         	         
+
+	width *= fontwidth(p);
+	sx *= fontwidth(p);
+	sx += width;
+
+	height *= fontheight(p) * mult;
+	sy *= fontheight(p) * mult;
+	ystart = i810_orient->vyres;
+	
+	dest = (i810_accel->fb_offset << 12) + sy +
+		((ystart - sx) * p->next_line);
+	color_blit(height, width, p->next_line, dest, 
+		   COLOR_COPY_ROP, bgx, blit_bpp);
+}
+
+void i810_accel_rr_clear(struct vc_data *conp, struct display *p, 
+			 int sy, int sx, int height, int width)
+{
+	int mult, blit_bpp = 0;
+	u32 bgx = 0, dest = 0;
+	u32 xstart;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+
+	switch(mult) {
+	case 1:
+		bgx = (u32) attr_bgcol_ec(p, conp);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bgx = (int) ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		bgx = ((int *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP24;
+	}	         	         
+
+	width *= fontwidth(p);
+	sx *= fontwidth(p);
+
+	height *= fontheight(p) * mult;
+	sy *= fontheight(p) * mult;
+	sy += height;
+
+	xstart = i810_orient->vxres * mult;
+	
+	dest = (i810_accel->fb_offset << 12) +
+		(xstart - sy) +
+		(sx * p->next_line);
+	color_blit(height, width, p->next_line, dest, 
+		   COLOR_COPY_ROP, bgx, blit_bpp);
+}
+
+void i810_accel_ud_putc(struct vc_data *conp, struct display *p, 
+			int c, int yy, int xx)
+{
+	u8 *cdat;
+	int dheight, dwidth, dpitch, fg = 0, bg = 0;
+	int dest, fontwidth, mult, blit_bpp = 8;
+	int i, j, cols, rows, pattern = 0;
+	u32 pat1[2], pat2[2];
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	/* 8x8 pattern blit */
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	dheight = 8;              
+	dwidth = mult << 3;
+	dpitch = p->next_line;
+	switch (mult) {
+	case 1:
+		fg = (int) attr_fgcol(p,c);
+		bg = (int) attr_bgcol(p,c);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bg = (int) ((u16 *)p->dispsw_data)[attr_bgcol(p, c)];
+		fg = (int) ((u16 *)p->dispsw_data)[attr_fgcol(p, c)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		fg = ((int *) p->dispsw_data)[attr_fgcol(p, c)];
+		bg = ((int *) p->dispsw_data)[attr_bgcol(p, c)];
+		blit_bpp = BPP24;
+	}
+	rows = fontheight(p) >> 3;
+	if(fontwidth(p) <= 8) {
+		fontwidth = 8;
+		cdat = p->fontdata + ((c & p->charmask) * fontheight(p));
+		cols = 1;
+	}
+	else {
+		fontwidth = fontwidth(p);
+		cdat = p->fontdata + 
+			((c & p->charmask) * (fontwidth >> 3) * fontheight(p));
+		cols = fontwidth >> 3;
+	}
+	dest = (i810_accel->fb_offset << 12) + 
+		((i810_orient->vyres - ((yy*fontheight(p)) + 8)) * p->next_line) +
+		((i810_orient->vxres - ((xx*fontwidth) + 8)) * mult);
+
+	for (i = cols; i--; ) {
+		for (j = 0; j < rows; j++) {
+			pattern = j << (cols + 2);
+			pat1[0] = *((u32 *) (cdat + pattern));
+			pat1[1] = *((u32 *) (cdat + pattern + (cols << 2)));
+			rotate_180(pat1, pat2, fontwidth);
+			mono_pat_blit(dpitch, dheight, dwidth, 
+				      dest - (j * (dpitch << 3)),
+				      fg, bg, COLOR_COPY_ROP, 
+				      pat2[0], pat2[1], blit_bpp);
+		}
+		cdat += 4;
+		dest -= dwidth;
+	}
+}
+
+void i810_accel_rl_putc(struct vc_data *conp, struct display *p, 
+			int c, int yy, int xx)
+{
+	u8 *cdat;
+	int dheight, dwidth, dpitch, fg = 0, bg = 0;
+	int dest, fontwidth, mult, blit_bpp = 8;
+	int i, j, cols, rows, pattern;
+	u32 pat1[2], pat2[2];
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	/* 8x8 pattern blit */
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		fg = (int) attr_fgcol(p,c);
+		bg = (int) attr_bgcol(p,c);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bg = (int) ((u16 *)p->dispsw_data)[attr_bgcol(p, c)];
+		fg = (int) ((u16 *)p->dispsw_data)[attr_fgcol(p, c)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		fg = ((int *) p->dispsw_data)[attr_fgcol(p, c)];
+		bg = ((int *) p->dispsw_data)[attr_bgcol(p, c)];
+		blit_bpp = BPP24;
+	}
+	dheight = mult << 3;              
+	dwidth = 8;
+	dpitch = p->next_line;
+	rows = fontheight(p) >> 3;
+	if(fontwidth(p) <= 8) {
+		fontwidth = 8;
+		cdat = p->fontdata + ((c & p->charmask) * fontheight(p));
+		cols = 1;
+	}
+	else {
+		fontwidth = fontwidth(p);
+		cdat = p->fontdata + 
+			((c & p->charmask) * (fontwidth >> 3) * fontheight(p));
+		cols = fontwidth >> 3;
+	}
+	dest = (i810_accel->fb_offset << 12) + 
+		(yy * fontheight(p) * mult) +
+		((i810_orient->vyres - ((xx*fontwidth) + 8)) * p->next_line);
+
+	for (i = cols; i--; ) {
+		for (j = 0; j < rows; j++) {
+			pattern = j << (cols + 2);
+			pat1[0] = *((u32 *) (cdat + pattern));
+			pat1[1] = *((u32 *) (cdat + pattern + (cols << 2)));
+			rotate_left(pat1, pat2, fontwidth);
+			mono_pat_blit(dpitch, dheight, dwidth, 
+				      dest + (j * dheight),
+				      fg, bg, COLOR_COPY_ROP, 
+				      pat2[0], pat2[1], blit_bpp);
+		}
+		cdat += 4;
+		dest -= dpitch << 3;
+	}
+}
+
+void i810_accel_rr_putc(struct vc_data *conp, struct display *p, 
+			int c, int yy, int xx)
+{
+	u8 *cdat;
+	int dheight, dwidth, dpitch, fg = 0, bg = 0;
+	int dest, fontwidth, mult, blit_bpp = 8;
+	int i, j, cols, rows, pattern = 0;
+	u32 pat1[2], pat2[2];
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	/* 8x8 pattern blit */
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		fg = (int) attr_fgcol(p,c);
+		bg = (int) attr_bgcol(p,c);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bg = (int) ((u16 *)p->dispsw_data)[attr_bgcol(p, c)];
+		fg = (int) ((u16 *)p->dispsw_data)[attr_fgcol(p, c)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		fg = ((int *) p->dispsw_data)[attr_fgcol(p, c)];
+		bg = ((int *) p->dispsw_data)[attr_bgcol(p, c)];
+		blit_bpp = BPP24;
+	}
+	dheight = mult << 3;              
+	dwidth = 8;
+	dpitch = p->next_line;
+	rows = fontheight(p) >> 3;
+	if(fontwidth(p) <= 8) {
+		fontwidth = 8;
+		cdat = p->fontdata + ((c & p->charmask) * fontheight(p));
+		cols = 1;
+	}
+	else {
+		fontwidth = fontwidth(p);
+		cdat = p->fontdata + 
+			((c & p->charmask) * (fontwidth >> 3) * fontheight(p));
+		cols = fontwidth >> 3;
+	}
+	dest = (i810_accel->fb_offset << 12) + 
+		(xx * fontwidth * p->next_line) + 
+		((i810_orient->vxres - ((yy * fontheight(p)) + 8)) * mult);
+
+	for (i = cols; i--; ) { 
+		for (j = 0; j < rows; j++) {
+			pattern = j << (cols + 2);
+			pat1[0] = *((u32 *) (cdat + pattern));
+			pat1[1] = *((u32 *) (cdat + pattern + (cols << 2)));
+			rotate_right(pat1, pat2, fontwidth);
+			mono_pat_blit(dpitch, dheight, dwidth, 
+				      dest - (j * dheight),
+				      fg, bg, COLOR_COPY_ROP, 
+				      pat2[0], pat2[1], blit_bpp);
+
+		}
+		cdat += 4;
+		dest += dpitch << 3;
+	}
+}
+
+void i810_accel_ud_putcs(struct vc_data *conp, struct display *p,
+			 const unsigned short *s, int count, int yy, int xx)
+{
+	u8 *cdat, *cdat0;
+	int chars, dpitch, dheight, dwidth, dest, next;
+	int mult, fontwidth, blit_bpp = 0, cols, rows;
+	int c, dest0, i, j;
+	u32 pat1[2], pat2[2];
+	int (*get_bg)(struct display *p, int c) = NULL;
+	int (*get_fg)(struct display *p, int c) = NULL;
+	
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		get_bg = i810_accel8_getbg;
+		get_fg = i810_accel8_getfg;
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		get_bg = i810_accel16_getbg;
+		get_fg = i810_accel16_getfg;
+		blit_bpp = BPP16;
+		break;
+	case 3:	
+		get_bg = i810_accel24_getbg;
+		get_fg = i810_accel24_getfg;
+		blit_bpp = BPP24;
+	}
+	
+	dwidth = mult << 3;
+	dheight = 8;
+	dpitch = p->next_line;
+	rows = fontheight(p) >> 3;
+
+	if(fontwidth(p) <= 8) {
+		cols = 1;
+		fontwidth = 8;
+	}
+	else {
+		cols = fontwidth(p) >> 3;
+		fontwidth = fontwidth(p);
+	}
+
+	dest = (i810_accel->fb_offset << 12) + 
+		((i810_orient->vyres - ((yy*fontheight(p)) + 8)) * p->next_line) + 
+		((i810_orient->vxres - ((xx*fontwidth) + 8)) * mult);
+	chars = p->next_line/fontwidth;
+	next = 1 << (cols + 2);
+	while(count--) {
+		c = scr_readw(s++);
+		cdat = p->fontdata + ((c & p->charmask)*cols*fontheight(p));
+		for (i = 0; i < cols; i++ ) {
+			dest0 = dest;
+			cdat0 = cdat;
+			for(j = 0; j < rows; j++ ) {
+				pat1[0] = *((u32 *) (cdat0));
+				pat1[1] = *((u32 *) (cdat0 + (cols << 2)));
+				rotate_180(pat1, pat2, fontwidth);
+				mono_pat_blit(dpitch, dheight, dwidth, dest0, 
+					      get_fg(p, c), get_bg(p, c), 
+					      COLOR_COPY_ROP, pat2[0], pat2[1],
+					      blit_bpp);
+				dest0 -= dpitch << 3;      	      
+				cdat0 += next;
+			}
+			dest -= dwidth;
+			cdat += 4;
+		}
+		if(++xx > chars) {
+			xx = 0;
+			yy++;
+			dest = (i810_accel->fb_offset << 12) + 
+				((i810_orient->vyres - ((yy*fontheight(p)) + 8)) * p->next_line) + 
+				((i810_orient->vxres - 8) * mult);
+		}
+		
+	}	 
+}
+
+void i810_accel_rl_putcs(struct vc_data *conp, struct display *p,
+			 const unsigned short *s, int count, int yy, int xx)
+{
+	u8 *cdat, *cdat0;
+	u32 pat1[2], pat2[2];
+	int chars, dpitch, dheight, dwidth, dest, next;
+	int mult, fontwidth, blit_bpp = 0, cols, rows;
+	int c, dest0, i, j;
+	int (*get_bg)(struct display *p, int c) = NULL;
+	int (*get_fg)(struct display *p, int c) = NULL;
+	
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		get_bg = i810_accel8_getbg;
+		get_fg = i810_accel8_getfg;
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		get_bg = i810_accel16_getbg;
+		get_fg = i810_accel16_getfg;
+		blit_bpp = BPP16;
+		break;
+	case 3:	
+		get_bg = i810_accel24_getbg;
+		get_fg = i810_accel24_getfg;
+		blit_bpp = BPP24;
+	}
+	
+	dwidth = 8;
+	dheight = mult << 3;
+	dpitch = p->next_line;
+	rows = fontheight(p) >> 3;
+
+	if(fontwidth(p) <= 8) {
+		cols = 1;
+		fontwidth = 8;
+	}
+	else {
+		cols = fontwidth(p) >> 3;
+		fontwidth = fontwidth(p);
+	}
+
+	dest = (i810_accel->fb_offset << 12) +
+		(yy * fontheight(p) * mult) +
+		((i810_orient->vyres - ((xx+1) * fontwidth)) * p->next_line);
+	chars = i810_orient->vxres/fontwidth;
+	next = 1 << (cols + 2);
+	while(count--) {
+		c = scr_readw(s++);
+		cdat = p->fontdata + ((c & p->charmask)*cols*fontheight(p));
+		for (i = cols; i--; ) {
+			dest0 = dest;
+			cdat0 = cdat;
+			for(j = rows; j--; ) {
+				pat1[0] = *((u32 *) (cdat0));
+				pat1[1] = *((u32 *) (cdat0 + (cols << 2)));
+				rotate_left(pat1, pat2, fontwidth);
+				mono_pat_blit(dpitch, dwidth, dheight, dest0, 
+					      get_fg(p, c), get_bg(p, c), 
+					      COLOR_COPY_ROP, pat2[0], pat2[1], 
+					      blit_bpp);
+				dest0 += dheight;      	      
+				cdat0 += next;
+			}
+			dest -= dpitch << 3;
+			cdat += 4;
+		}
+		if(++xx > chars) {
+			xx = 0;
+			yy++;
+			dest = (i810_accel->fb_offset << 12) + 
+				(yy * fontheight(p) * mult) +
+				((i810_orient->vyres - fontwidth) * p->next_line);
+		}
+		
+	}	 
+}
+
+void i810_accel_rr_putcs(struct vc_data *conp, struct display *p,
+			 const unsigned short *s, int count, int yy, int xx)
+{
+	u8 *cdat, *cdat0;
+	u32 pat1[2], pat2[2];
+	int chars, dpitch, dheight, dwidth, dest, next;
+	int mult, fontwidth, blit_bpp = 0, cols, rows;
+	int c, dest0, i, j;
+	int (*get_bg)(struct display *p, int c) = NULL;
+	int (*get_fg)(struct display *p, int c) = NULL;
+	
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		get_bg = i810_accel8_getbg;
+		get_fg = i810_accel8_getfg;
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		get_bg = i810_accel16_getbg;
+		get_fg = i810_accel16_getfg;
+		blit_bpp = BPP16;
+		break;
+	case 3:	
+		get_bg = i810_accel24_getbg;
+		get_fg = i810_accel24_getfg;
+		blit_bpp = BPP24;
+	}
+	
+	dwidth = 8;
+	dheight = mult << 3;
+	dpitch = p->next_line;
+	rows = fontheight(p) >> 3;
+
+	if(fontwidth(p) <= 8) {
+		cols = 1;
+		fontwidth = 8;
+	}
+	else {
+		cols = fontwidth(p) >> 3;
+		fontwidth = fontwidth(p);
+	}
+
+	dest = (i810_accel->fb_offset << 12) + 
+		(xx * fontwidth * p->next_line) + 
+		((i810_orient->vxres - ((yy * fontheight(p)) + 8)) * mult);
+	chars = i810_orient->vxres/fontwidth;
+	next = 1 << (cols + 2);
+	while(count--) {
+		c = scr_readw(s++);
+		cdat = p->fontdata + ((c & p->charmask)*cols*fontheight(p));
+		for (i = cols; i--; ) {
+			dest0 = dest;
+			cdat0 = cdat;
+			for(j = rows; j--; ) {
+				pat1[0] = *((u32 *) (cdat0));
+				pat1[1] = *((u32 *) (cdat0 + (cols << 2)));
+				rotate_right(pat1, pat2, fontwidth);
+				mono_pat_blit(dpitch, dwidth, dheight, dest0, 
+					      get_fg(p, c), get_bg(p, c), 
+					      COLOR_COPY_ROP, pat2[0], pat2[1], 
+					      blit_bpp);
+				dest0 -= dheight;      	      
+				cdat0 += next;
+			}
+			dest += dpitch << 3;
+			cdat += 4;
+		}
+		if(++xx > chars) {
+			xx = 0;
+			yy++;
+			dest = (i810_accel->fb_offset << 12) + 
+				((i810_orient->vxres - 
+				  ((yy * fontheight(p)) + 8)) * mult);
+		}
+		
+	}	 
+}
+
+void i810_accel_ud_revc(struct display *p, int xx, int yy)
+{
+	int width, height, dest, pitch, mult, blit_bpp = 0;
+	u32 xstart, ystart;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		break;
+	}
+	pitch = p->next_line;
+
+	if (fontwidth(p) <= 8)
+		width = 8;
+	else
+		width = fontwidth(p);
+	height = fontheight(p);
+
+	xx *= width * mult;
+	width *= mult;
+	xx += width;
+	yy *= height;
+	yy += height;
+
+	xstart = i810_orient->vxres * mult;
+	ystart = i810_orient->vyres;
+
+	dest = (i810_accel->fb_offset << 12) + 
+		((ystart - yy) * p->next_line) + 
+		(xstart - xx);
+	color_blit(width, height, pitch, dest, INVERT_ROP, 0x0F, blit_bpp);
+}
+
+void i810_accel_rl_revc(struct display *p, int xx, int yy)
+{
+	int width, height, dest, pitch, mult, blit_bpp = 0;
+	u32 ystart;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		break;
+	}
+	pitch = p->next_line;
+	if (fontwidth(p) <= 8)
+		width = 8;
+	else
+		width = fontwidth(p);
+	height = fontheight(p);
+	xx *= width;
+	xx += width;
+
+	yy *= height * mult;
+	height *= mult;
+
+	ystart = i810_orient->vyres;
+
+	dest = (i810_accel->fb_offset << 12) + yy +
+		((ystart - xx) * p->next_line);
+	color_blit(height, width, pitch, dest, INVERT_ROP, 0x0F, blit_bpp);
+}
+
+void i810_accel_rr_revc(struct display *p, int xx, int yy)
+{
+	int width, height, dest, pitch, mult, blit_bpp = 0;
+	u32 xstart;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+	switch (mult) {
+	case 1:
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		break;
+	}
+	pitch = p->next_line;
+	if (fontwidth(p) <= 8)
+		width = 8;
+	else
+		width = fontwidth(p);
+	height = fontheight(p);
+	yy *= height * mult;
+	height *= mult;
+	yy += height;
+
+	xx *= width;
+	xstart = i810_orient->vxres * mult;
+
+	dest = (i810_accel->fb_offset << 12) + 
+		(xstart - yy) +
+		(xx * p->next_line);
+	color_blit(height, width, pitch, dest, INVERT_ROP, 0x0F, blit_bpp);
+}
+
+void i810_accel_ud_clear_margins(struct vc_data *conp, struct display *p,
+				 int bottom_only)
+{
+	int bytes = p->next_line, blit_bpp = 0;
+	u32 bgx = 0, mult;
+	unsigned int right_width, bottom_height;
+	u32 right_start;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+
+	switch(mult) {
+	case 1:
+		bgx = (u32) attr_bgcol_ec(p, conp);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bgx = (int) ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		bgx = ((int *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+	}	         	         
+
+	right_width = p->var.xres % fontwidth(p);
+	right_start = p->var.xres - right_width;
+	if (!bottom_only && right_width) 
+		color_blit(right_width*mult, p->var.yres_virtual, bytes, 
+			   (i810_accel->fb_offset << 12) + 
+			   ((i810_orient->vxres - 
+			    (p->var.xoffset+p->var.xres))*mult), 
+			   COLOR_COPY_ROP, bgx, blit_bpp); 
+	bottom_height = p->var.yres % fontheight(p);
+	if (bottom_height) {
+		color_blit(right_start*mult, bottom_height, bytes, 
+			   (i810_accel->fb_offset << 12) + 
+			   ((i810_orient->vyres - 
+			     (p->var.yoffset+p->var.yres))*bytes) +
+			   ((i810_orient->vxres - right_start) * mult), 
+			   COLOR_COPY_ROP, bgx, blit_bpp);
+	}
+}
+
+void i810_accel_rl_clear_margins(struct vc_data *conp, struct display *p,
+				  int bottom_only)
+{
+	int bytes = p->next_line, blit_bpp = 0;
+	u32 bgx = 0, mult;
+	unsigned int right_start;
+	unsigned int bottom_start = (conp->vc_rows)*fontheight(p);
+	unsigned int right_width, bottom_height;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+
+	switch(mult) {
+	case 1:
+		bgx = (u32) attr_bgcol_ec(p, conp);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bgx = (int) ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		bgx = ((int *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+	}	         	         
+
+	right_width = p->var.xres % fontwidth(p);
+	right_start = p->var.xres - right_width;
+	if (!bottom_only)
+		color_blit(i810_orient->vxres*mult, right_width, bytes, 
+			   (i810_accel->fb_offset << 12) +
+			   ((i810_orient->vyres - p->var.xoffset - 
+			     right_start - right_width) * p->next_line),
+			   COLOR_COPY_ROP, bgx, blit_bpp); 
+	bottom_height = p->var.yres % fontheight(p);
+	if (bottom_height) {
+		bottom_start = p->var.yres - bottom_height;
+		color_blit(bottom_height*mult, right_start, bytes, 
+			   (i810_accel->fb_offset << 12) + 
+			   (i810_orient->vyres - p->var.xres) * p->next_line +
+			   ((p->var.yoffset + bottom_start) * mult),
+			   COLOR_COPY_ROP, bgx, blit_bpp);
+	}
+}
+
+void i810_accel_rr_clear_margins(struct vc_data *conp, struct display *p,
+				  int bottom_only)
+{
+	int bytes = p->next_line, blit_bpp = 0;
+	u32 bgx = 0, mult;
+	unsigned int right_start;
+	unsigned int right_width, bottom_height;
+
+	if (i810_accel->lockup || not_safe())
+		return;
+
+	mult = (p->var.bits_per_pixel >> 3);
+	if (!mult) mult = 1;
+
+	switch(mult) {
+	case 1:
+		bgx = (u32) attr_bgcol_ec(p, conp);
+		blit_bpp = BPP8;
+		break;
+	case 2:
+		bgx = (int) ((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+		blit_bpp = BPP16;
+		break;
+	case 3:
+		blit_bpp = BPP24;
+		bgx = ((int *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+	}	         	         
+
+	right_width = p->var.xres % fontwidth(p);
+	right_start = p->var.xres - right_width;
+	if (!bottom_only)
+		color_blit(i810_orient->vxres*mult, right_width, bytes, 
+			   (i810_accel->fb_offset << 12) +
+			   ((p->var.xoffset + right_start) * p->next_line),
+			   COLOR_COPY_ROP, bgx, blit_bpp); 
+	bottom_height = p->var.yres % fontheight(p);
+	if (bottom_height) {
+		color_blit(bottom_height*mult, right_start, bytes, 
+			   (i810_accel->fb_offset << 12) + 
+			   (p->var.xoffset * p->next_line) +
+			   ((i810_orient->vxres - (p->var.yoffset + 
+			    p->var.yres)) * mult),
+			   COLOR_COPY_ROP, bgx, blit_bpp);
+	}
+}
+
+
+/*
+ * ops for 180-degree rotate display
+ */
+struct display_switch i810_accel_ud = {
+	i810_accel_setup,
+	i810_accel_ud_bmove,
+	i810_accel_ud_clear,
+	i810_accel_ud_putc,
+	i810_accel_ud_putcs,
+	i810_accel_ud_revc,
+	NULL,
+	NULL,
+	i810_accel_ud_clear_margins,
+	FONTWIDTH(8) | FONTWIDTH(16)
+};
+
+/*
+ * ops for 90-degree left rotated display
+ */
+struct display_switch i810_accel_rl = {
+	i810_accel_setup,
+	i810_accel_rl_bmove,
+	i810_accel_rl_clear,
+	i810_accel_rl_putc,
+	i810_accel_rl_putcs,
+	i810_accel_rl_revc,
+	NULL,
+	NULL,
+	i810_accel_rl_clear_margins,
+	FONTWIDTH(8) | FONTWIDTH(16)
+};
+
+/*
+ * ops for 90-degree right rotated display
+ */
+struct display_switch i810_accel_rr = {
+	i810_accel_setup,
+	i810_accel_rr_bmove,
+	i810_accel_rr_clear,
+	i810_accel_rr_putc,
+	i810_accel_rr_putcs,
+	i810_accel_rr_revc,
+	NULL,
+	NULL,
+	i810_accel_rr_clear_margins,
+	FONTWIDTH(8) | FONTWIDTH(16)
+};
+
--- linux-2.4.22/drivers/video/i810/i810_fbcon_rotate.h.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_fbcon_rotate.h	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,40 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_fbcon_rotate.h -- Optional Console Rotated Drawing Functions
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#ifndef __I810_FBCON_ROTATE_H__
+#define __I810_FBCON_ROTATE_H__
+
+extern struct accel_data  *i810_accel;
+extern struct orientation *i810_orient;
+extern inline void i810_writel          (u32 where, u32 val);
+extern int         i810fb_reacquire_gart(void);
+extern u32         get_line_length      (int xres_virtual, int bpp);
+extern void        i810fb_enable_cursor (int mode);
+
+extern inline void mono_pat_blit        (int dpitch, int dheight, int dwidth, int dest, 
+					 int fg, int bg, int rop, int patt_1, int patt_2, 
+					 int blit_bpp);
+extern inline void source_copy_blit     (int dwidth, int dheight, int dpitch, int xdir, 
+					 int spitch, int src, int dest, int rop, int blit_bpp);
+extern inline void color_blit           (int width, int height, int pitch, 
+					 int dest, int rop, int what, int blit_bpp);
+
+extern void       i810_accel_setup      (struct display *p);
+extern void       i810_cursor           (struct display *p, int mode, int xx, int yy);
+extern inline int i810_accel8_getbg     (struct display *p, int c);
+extern inline int i810_accel8_getfg     (struct display *p, int c);
+extern inline int i810_accel16_getbg    (struct display *p, int c);
+extern inline int i810_accel16_getfg    (struct display *p, int c);
+extern inline int i810_accel24_getbg    (struct display *p, int c);
+extern inline int i810_accel24_getfg    (struct display *p, int c);
+extern inline int not_safe              (void);
+#endif /* __I810_FBCON_ROTATE_H__ */
--- linux-2.4.22/drivers/video/i810/i810_iface.c.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_iface.c	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,515 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_iface.c -- Hardware Interface
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/types.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,14)
+#include <linux/malloc.h>
+#else
+#include <linux/slab.h>
+#endif
+
+#include "i810_regs.h"
+#include "i810_common.h"
+#include "i810_iface.h"
+
+/*
+ * Resource Management
+ */
+
+/**
+ * i810fb_find_free_block - finds a block of unbound gart memory
+ * @pgsize: size in pages (4096)
+ *
+ * DESCRIPTION:
+ * This function finds a free block of gart memory as determined
+ * by gtt_map
+ *
+ * RETURNS:
+ * start page offset of block
+ */
+static int i810fb_find_free_block(u32 pgsize)
+{
+	u32 offset, cur_size = 0;
+
+	offset = i810_iface->sarea_offset;
+	while (cur_size < pgsize && offset) {
+		offset--;
+		if (!test_bit(offset, i810_iface->gtt_map)) 
+			++cur_size;
+		else if (cur_size < pgsize) 
+			cur_size = 0;
+	} 
+	return (cur_size < pgsize) ? -1 : (int) offset;
+}
+
+/**
+ * i810fb_allocate_agpmemory - allocates and binds agp memory
+ * @agp_mem: pointer to agp_mem_user
+ *
+ * DESCRIPTION:
+ * Allocates a requested agp memory type and size, then writes the surface
+ * key and page offset to @agp_mem, if successful.  
+ */
+int i810fb_allocate_agpmemory(agp_mem_user *agp_mem)
+{
+	agp_mem_struct *new;
+
+	if (!test_bit(agp_mem->user_key, i810_iface->user_key_list))
+		return -EACCES;
+
+	switch (agp_mem->type) {
+	case AGP_DMA:
+		if (agp_mem->pgsize > MAX_DMA_SIZE >> 12)
+			return -EINVAL;
+		if (!agp_mem->pgsize)
+			agp_mem->pgsize = 4;
+		break;
+	case AGP_SURFACE:
+		if (!agp_mem->pgsize)
+			return -EINVAL;
+		break;
+	case AGP_SAREA:
+		agp_mem->pgsize = SAREA_SIZE >> 12;
+		agp_mem->surface_key = i810_iface->i810_sarea_memory->key;
+		agp_mem->offset = ((i810_iface->fb_size + MMIO_SIZE + i810_iface->aper_size) >> 12) +
+			agp_mem->user_key;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	if (NULL == (new = vmalloc(sizeof(agp_mem_struct))))
+		return -ENOMEM;
+	memset((void *) new, 0, sizeof(new));
+	agp_mem->offset = i810fb_find_free_block(agp_mem->pgsize);
+	if (agp_mem->offset == -1)
+		return -ENOMEM;
+	new->surface = agp_allocate_memory(agp_mem->pgsize, AGP_NORMAL_MEMORY);
+	if (new->surface == NULL) {
+		vfree(new);
+		return -ENOMEM;
+	}
+	if (agp_bind_memory(new->surface, agp_mem->offset)) {
+		agp_free_memory(new->surface);
+		vfree(new);
+		return -EBUSY;
+	}
+	i810fb_set_gttmap(new->surface);
+	new->surface_type = agp_mem->type;
+	new->user_key = agp_mem->user_key;
+	agp_mem->surface_key = new->surface->key;
+	list_add(&new->agp_list, &i810_iface->agp_list_head);
+	return 0;
+}
+
+/**
+ * i810fb_free_agpmemory - allocates and binds agp memory
+ * @agp_mem: pointer to agp_mem_user
+ *
+ * DESCRIPTION:
+ * Free a previously requested agp memory. 
+ */
+int i810fb_free_agpmemory(agp_mem_user *agp_mem)
+{
+	struct list_head *list;
+	agp_mem_struct *agp_list;
+
+	list_for_each(list, &i810_iface->agp_list_head) {
+		agp_list = (agp_mem_struct *) list;
+		if (agp_list->surface->key == agp_mem->surface_key && 
+		    agp_list->user_key == agp_mem->user_key &&
+		    agp_list->surface->pg_start == agp_mem->offset &&
+		    agp_list->surface->page_count == agp_mem->pgsize &&
+		    agp_list->surface_type == agp_mem->type) {
+			wait_for_engine_idle();
+			i810fb_clear_gttmap(agp_list->surface);
+			agp_unbind_memory(agp_list->surface);
+			agp_free_memory(agp_list->surface);
+			list_del(list);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/**
+ * i810fb_acquire_fb - acquires the framebuffer
+ *
+ * DESCRIPTION:
+ * Acquires the framebuffer device.  If successful, returns a 
+ * user key which should be passed to the fb  driver each time 
+ * a service is requested.
+ */
+int i810fb_acquire_fb(void)
+{
+	int key;
+
+	key = find_first_zero_bit(i810_iface->user_key_list, MAX_KEY);
+	if (key >= MAX_KEY)
+		return -1;
+	if (i810fb_bind_all())	return -1;
+	set_bit(key, i810_iface->user_key_list);
+	return key;
+}
+
+
+/**
+ * i810fb_check_mmap - check if area to be mmaped is valid
+ * @offset: offset to start of aperture space
+ *
+ * DESCRIPTION:
+ * Checks if @offset matches any of the agp memory in the list.
+ */
+int i810fb_check_agp_mmap(u32 offset, uid_t uid)
+{
+	struct list_head *list;
+	agp_mem_struct *agp_list;
+	
+	list_for_each(list, &i810_iface->agp_list_head) {
+		agp_list = (agp_mem_struct *) list;
+		if (offset >= agp_list->surface->pg_start  && 
+		    offset < agp_list->surface->pg_start + 
+		    agp_list->surface->page_count) {
+			if (!uid)
+				agp_list->trusted = 1;
+			else
+				agp_list->trusted = 0;
+			return ((agp_list->surface->pg_start + 
+				 agp_list->surface->page_count) - 
+				offset) << 12;
+		}
+	}
+	return 0;
+
+}
+
+/**
+ * i810fb_check_sarea - check if shared area can be mapped 
+ * @offset: offset to map (equivalent to user key)
+ * @uid: uid of requestor
+ * 
+ * DESCRIPTION:
+ * This function checks of the sarea can be mapped to user space.
+ */
+int i810fb_check_sarea(u32 offset, uid_t uid)
+{
+	if (uid) {
+		printk("sarea: go away, you don't have permission\n");
+		return 0;
+	}
+	if (test_bit(offset, i810_iface->user_key_list)) {
+		set_bit(offset, i810_iface->has_sarea_list);
+		return SAREA_SIZE;
+	}
+	printk("sarea: invalid user key\n");
+	return 0;
+}
+
+/**
+ * i810fb_release_fb - release the framebuffer device
+ * @command: pointer to i810_command
+ *
+ * DESCRIPTION:
+ * Release the framebuffer device.  All allocated resources 
+ * will be released, and the user key will be removed from the list.  
+ */
+static int i810fb_release_fb(i810_command *command)
+{
+	i810fb_release_all(command->user_key);
+	clear_bit(command->user_key, i810_iface->user_key_list);
+	clear_bit(command->user_key, i810_iface->has_sarea_list);
+	(u32) i810_iface->cur_dma_buf_virt = 0;
+	(u32) i810_iface->cur_dma_buf_phys = 0;
+	(u32) i810_iface->sarea->cur_surface_key = MAX_KEY;
+	(u32) i810_iface->sarea->cur_user_key = MAX_KEY;
+	(u32) i810_iface->sarea->is_valid = 0;
+	return 0;
+}
+			
+/**
+ * i810fb_update_dma - updates the current user DMA buffer pointer
+ * @command: pointer to i810_command structure
+ *
+ */
+static int i810fb_update_dma(i810_command *command)
+{
+	struct list_head *list;
+	agp_mem_struct *agp_list;
+
+	list_for_each(list, &i810_iface->agp_list_head) {
+		agp_list = (agp_mem_struct *) list;
+		if (agp_list->surface->key == command->surface_key && 
+		    agp_list->user_key == command->user_key &&
+		    agp_list->surface_type == AGP_DMA) {
+			i810_iface->cur_dma_buf_virt = 
+				(u32 *) (i810_iface->fb_base_virt + 
+					 (agp_list->surface->pg_start << 12));
+			i810_iface->cur_dma_buf_phys = 
+				(u32 *) (i810_iface->fb_base_phys + 
+					 (agp_list->surface->pg_start << 12));
+			i810_iface->sarea->cur_surface_key = 
+				command->surface_key;
+			i810_iface->sarea->cur_user_key = command->user_key;
+			i810_iface->sarea->is_valid = 1;
+			i810_iface->trusted = agp_list->trusted;
+			i810_iface->cur_dma_size = 
+				agp_list->surface->page_count << 12;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/**
+ * i810fb_parse_parser - verifies parser type instructions (opcode 00)
+ * @pointer:  the offset to the current user DMA buffer
+ * @dsize: the number of dwords from the offset to the end of the 
+ * instruction packets
+ *
+ * DESCRIPTION:
+ * Process parser-type instructions.  The only verification done is 
+ * the size of the instruction on a per opcode basis.
+ */
+
+static int i810fb_parse_parser(u32 *pointer, u32 dsize)
+{
+	u32 cur_header;
+	int i;
+	
+	cur_header = *pointer;
+	if ((cur_header & (0x3F << 23)) < (0x09 << 23)) 
+		i = 1;
+	else
+		i = (cur_header & 0x3F) + 2; 
+	return (i > dsize || i > i810_iface->cur_dma_size >> 2) ?
+		-1 : i;
+}
+
+/**
+ * i810fb_parse_blitter - verifies blitter type instructions (opcode 02)
+ * @pointer:  the offset to the current user DMA buffer
+ * @dsize: the number of dwords from the offset to the end of 
+ * the instruction packets
+ *
+ * DESCRIPTION:
+ * Process blit-type instructions.  The only verification done is
+ * checking the size of the instruction in dwords.
+ */
+static int i810fb_parse_blitter(u32 *pointer, u32 dsize)
+{
+	u32 cur_header;
+	int i;
+
+	cur_header = *pointer;
+	i = (cur_header & 0x1F) + 2;
+	return (i > dsize || i > i810_iface->cur_dma_size >> 2) ?
+		-1 : i;
+}
+
+/**
+ * i810fb_parse_render - verifies render type instructions (opcode 03)
+ * @pointer:  the offset to the current user DMA buffer
+ * @dsize: the number of dwords from the offset to the end of 
+ * the instruction packets
+ *
+ * DESCRIPTION:
+ * Process render-type instructions. It verifies the size of the packets based
+ * on the opcode. All invalid opcodes will result in an error.
+ */
+static int i810fb_parse_render(u32 *pointer, u32 dsize)
+{
+	u32 cur_header, opcode;
+	int i;
+
+	cur_header = *pointer;
+	opcode = cur_header & (0x1F << 24);
+	
+	switch(opcode) {
+	case 0 ... (0x18 << 24):
+	case (0x1C << 24):
+		i = 1;
+		break;
+	case (0x1D << 24) ... (0x1E << 24):
+		i = (cur_header & 0xFF) + 2;
+		break;
+	case (0x1F << 24):
+		i = (cur_header & 0x3FF) + 2;
+		break;
+	default:
+		return -1; 
+	}
+	return (i > dsize || i > i810_iface->cur_dma_size >> 2) ?
+	        -1 : i;
+}
+
+/**
+ * process_buffer_with_verify - process command buffer contents
+ * @v_pointer: virtual pointer to start of instruction;
+ * @p: physical pointer to start of instruction
+ * @dsize: length of instruction sequence in dwords
+ * @command: pointer to i810_command
+ *
+ * DESCRIPTION:
+ * Processes command buffer instructions prior to execution.  This 
+ * includes verification of each instruction header for validity.
+ * This is reserved for clients which are not trusted.
+ */
+static inline u32 process_buffer_with_verify(u32 v_pointer, u32 p, u32 dsize,
+					    i810_command *command)
+{
+	u32  dcount = 0, i = 0, opcode;
+	
+	if (dsize & 1) {
+		*((u32 *) (v_pointer + (dsize << 2))) = 0;
+		dsize++;
+	}
+	do {
+		opcode =  *((u32 *) v_pointer) & (0x7 << 29);
+		switch (opcode) {
+		case PARSER:
+			i = i810fb_parse_parser((u32 *) v_pointer, 
+						dsize);
+			break;
+		case BLIT:
+			i = i810fb_parse_blitter((u32 *) v_pointer, 
+						 dsize);
+			break;
+		case RENDER:
+			i = i810fb_parse_render((u32 *) v_pointer, 
+						dsize);
+			break;
+		default:
+			i = -1;
+		}
+		if (i == -1) 
+			break;
+		v_pointer += i << 2;
+		dcount += i;
+		dsize -= i;
+	} while (dsize);
+	emit_instruction(dcount, p, 1); 
+	wait_for_engine_idle();
+	return dsize;
+}
+
+
+/**
+ * process_buffer_no_verify - process command buffer contents
+ * @v_pointer: virtual pointer to start of instruction;
+ * @p: physical pointer to start of instruction
+ * @dsize: length of instruction sequence in dwords
+ * @command: pointer to i810_command
+ *
+ * DESCRIPTION:
+ * processes command buffer instructions prior to execution.  If
+ * client has shared area, will update current head and tail.
+ * This is reserved for trusted clients.
+ */
+static inline u32 process_buffer_no_verify(u32 v_pointer, u32 p, u32 dsize,
+					    i810_command *command)
+{
+	u32 tail_pointer, tail;
+		
+	if (!test_bit(command->user_key, i810_iface->has_sarea_list)) {
+		if (dsize & 1) {
+			*((u32 *) (v_pointer + (dsize << 2))) = 0;
+			dsize++;
+		}
+		emit_instruction(dsize, p, 0);
+		wait_for_engine_idle();
+		return 0;
+	}
+
+	if (!(dsize & 1)) {
+		*((u32 *) (v_pointer + (dsize << 2))) = 0;
+		dsize++;
+	}
+	dsize += 3;
+	
+	tail = (command->dma_cmd_start + dsize) << 2;
+	i810_iface->sarea->tail = tail;
+	tail_pointer = v_pointer + ((dsize - 3) << 2);
+	*((u32 *) (tail_pointer))      = PARSER | STORE_DWORD_IDX | 1;
+	*((u32 *) (tail_pointer + 4))  = 7 << 2;
+	*((u32 *) (tail_pointer + 8))  = tail;
+	emit_instruction(dsize, p, 0);
+	return 0;
+}
+
+/**
+ * i810fb_emit_dma - processes DMA instructions from client
+ * @command: pointer to i810_command
+ *
+ * DESCRIPTION:
+ * Clients cannot directly use the ringbuffer.  To instruct the hardware 
+ * engine, the client writes all instruction packets to the current user 
+ * DMA buffer, and tells the fb driver to process those instructions.  
+ * The fb driver on the other hand, will verify if the packets are valid 
+ * _if_ the instructions come from a nontrusted source (not root).  
+ * Once verification is finished, the instruction sequence will be processed 
+ * via batch buffers. If an invalid instruction is encountered, the sequence will
+ * be truncated from that point and the function will exit with an 
+ * error.  Instruction sequences can be chained, resulting in faster 
+ * performance.  
+ *
+ * If the source is trusted, the verfication stage is skipped, resulting 
+ * in greater performance at the expense of increasing the chances of 
+ * locking the machine.  If the client is using shared memory, the start (head)
+ * and end (tail) of the currently processed instruction sequence will be 
+ * written to the shared area.
+ */
+static int i810fb_emit_dma(i810_command *command)
+{
+
+	u32 cur_pointer, phys_pointer, dsize, ret;
+	
+	if (i810_iface->lockup) return -EINVAL;
+	if (i810_iface->sarea->cur_surface_key != command->surface_key) { 
+		if (i810fb_update_dma(command))
+			return -EACCES;
+	}
+	else if (i810_iface->sarea->cur_user_key != command->user_key)
+		return -EINVAL;
+
+	dsize = command->dma_cmd_dsize;
+	if (dsize + command->dma_cmd_start > 
+	    (i810_iface->cur_dma_size >> 2) - 3 || 
+	    !dsize)
+		return -EINVAL;
+	phys_pointer = (u32) i810_iface->cur_dma_buf_phys + 
+		(command->dma_cmd_start << 2);
+	cur_pointer = (u32) i810_iface->cur_dma_buf_virt + 
+		(command->dma_cmd_start << 2);
+
+	if (!i810_iface->trusted) 
+		ret = process_buffer_with_verify(cur_pointer, phys_pointer, dsize,
+					   command);
+	else 
+		ret = process_buffer_no_verify(cur_pointer, phys_pointer, dsize,
+					 command);
+	
+	return (ret) ? -EINVAL : 0;
+}
+
+
+int i810fb_process_command(i810_command *command)
+{
+	switch (command->command) {
+	case EMIT_DMA:
+		return i810fb_emit_dma(command);
+	case RELEASE_FB:
+		return i810fb_release_fb(command);
+	default:
+		return -EINVAL;
+	}
+}
+
--- linux-2.4.22/drivers/video/i810/i810_iface.h.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_iface.h	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,23 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_iface.h -- Hardware Interface
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#ifndef __I810_IFACE_H__
+#define __I810_IfACE_H__
+
+extern struct iface_data* i810_iface;
+extern void               i810fb_release_all  (u32 key);
+extern int                i810fb_bind_all     (void);
+extern inline void        i810fb_clear_gttmap (agp_memory *surface); 
+extern inline void        i810fb_set_gttmap   (agp_memory *surface); 
+extern inline int         wait_for_engine_idle(void);
+extern inline void        emit_instruction    (u32 dsize, u32 pointer, u32 trusted);
+
+#endif /* __I810_IFACE_H__ */
--- linux-2.4.22/drivers/video/i810/i810_main.c.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_main.c	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,2599 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_main.c -- Intel 810 frame buffer device
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *      Contributors:
+ *         Michael Vogt <mvogt@acm.org> - added support for Intel 815 chipsets
+ *                                        and enabling the power-on state of 
+ *                                        external VGA connectors for 
+ *                                        secondary displays
+ *
+ *	The code framework is a modification of vfb.c by Geert Uytterhoeven.
+ *      DotClock and PLL calculations are partly based on i810_driver.c 
+ *              in xfree86 v4.0.3 by Precision Insight.
+ *      Watermark calculation and tables are based on i810_wmark.c 
+ *              in xfre86 v4.0.3 by Precision Insight.  Slight modifications 
+ *              only to allow for integer operations instead of floating point.
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,14)
+#include <linux/malloc.h>
+#else
+#include <linux/slab.h>
+#endif
+
+#include <linux/vmalloc.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/resource.h>
+#include <linux/selection.h>
+#include <linux/console.h>
+#include <linux/vt_kern.h>
+#include <linux/unistd.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif 
+
+#include <asm/page.h>
+
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+
+#include "i810_regs.h"
+#include "i810_common.h"
+#include "i810_main.h"
+
+/* 
+ * IOCTL operations
+ */
+
+/**
+ * i810fb_release_gart - release GART (pagetable) for use by others
+ *
+ * DESCRIPTION:
+ * If the graphics device needs to be acquired by another app, it can
+ * request the i810fb driver (via ioctl I810FB_IOC_CLAIMGART).  All
+ * memory currently bound will be unbound and the backend released.
+ */
+
+static void i810fb_release_gart(void)
+{
+	i810_info->gart_is_claimed = 1;
+	i810_info->in_context = 0;
+	wait_for_engine_idle();
+	if (i810_info->i810_gtt.i810_fb_memory->is_bound)
+		agp_unbind_memory(i810_info->i810_gtt.i810_fb_memory);
+	i810fb_unbind_accel_mem();
+	if (hwcur && i810_info->i810_gtt.i810_cursor_memory->is_bound) 
+		agp_unbind_memory(i810_info->i810_gtt.i810_cursor_memory);
+	i810fb_unbind_iface_mem();
+	i810fb_restore_regs();   
+	agp_backend_release();
+}
+
+/**
+ * i810fb_bind_all - bind all unbound memory
+ *
+ * DESCRIPTION:
+ * This attempts to bind all the drivers gtt memory, and all gtt memory
+ * requested by clients.  Failure to bind the driver's memory will exit 
+ * with an -EBUSY. 
+ */
+int i810fb_bind_all(void)
+{
+	int err = 0;
+
+	if (!i810_info->i810_gtt.i810_fb_memory->is_bound) {
+		if (agp_bind_memory(i810_info->i810_gtt.i810_fb_memory, 
+				    i810_info->fb_offset)) { 
+                        /* if we reach this, somethng bad just happened */
+			printk("i810fb: cannot rebind framebuffer memory\n");
+			return -EBUSY;
+		}	
+	}
+	if ((err = i810fb_bind_accel_mem()))
+		return err;
+
+	if (hwcur && !i810_info->i810_gtt.i810_cursor_memory->is_bound) {
+		if (agp_bind_memory(i810_info->i810_gtt.i810_cursor_memory, 
+				    i810_info->cursor_offset)) {
+			printk("i810fb: can't rebind cursor memory\n");
+			return -EBUSY;
+		}
+	}
+	return ((err = (i810fb_bind_iface_mem()))) ? err : 0;
+}
+/**
+ * i810fb_reacquire_gart - reacquire the GART for use by the framebuffer
+ *
+ * DESCRIPTION:
+ * An application which is currently holding the graphics device can tell
+ * the framebuffer driver (via IOCTL I810FB_IOC_RELEASEGART) that it can
+ * have control of the graphics device.  This should be done if the app 
+ * needs to switch to the console or is exiting. 
+ */
+int i810fb_reacquire_gart(void)
+{
+	wait_for_engine_idle();
+	i810fb_save_regs();   
+
+	/* We'll do what X is doing, disregard the -EBUSY return 
+	   of agp_backend_acquire */
+	agp_backend_acquire();
+	if (i810fb_bind_all()) 
+		agp_backend_release();
+	else 
+		i810_info->gart_is_claimed = 0;
+	return 0;
+}
+
+
+static struct fb_ops i810fb_ops = {
+    THIS_MODULE, 
+    i810fb_open, 
+    i810fb_release, 
+    i810fb_get_fix, 
+    i810fb_get_var, 
+    i810fb_set_var, 
+    i810fb_get_cmap, 
+    i810fb_set_cmap, 
+    i810fb_pan_display, 
+    i810fb_ioctl, 
+    i810fb_mmap
+};
+
+
+
+    /*
+     *  Open/Release the frame buffer device
+     */
+
+static int i810fb_open(struct fb_info *info, int user)
+{
+	if (i810_info->gart_is_claimed)
+		return -EBUSY;
+
+	MOD_INC_USE_COUNT;
+	return(0);                              
+}
+        
+static int i810fb_release(struct fb_info *info, int user)
+{
+	MOD_DEC_USE_COUNT;
+	return(0);                                                    
+}
+
+
+    /*
+     *  Get the Fixed Part of the Display
+     */
+
+static int i810fb_get_fix(struct fb_fix_screeninfo *fix, int con,
+		       struct fb_info *info)
+{
+	struct fb_var_screeninfo *var;
+	if (con == -1)
+		var = &i810fb_default;
+	else
+		var = &fb_display[con].var;
+	i810fb_encode_fix(fix, var);
+	return 0;
+}
+
+    /*
+     *  Get the User Defined Part of the Display
+     */
+
+static int i810fb_get_var(struct fb_var_screeninfo *var, int con,
+		       struct fb_info *info)
+{
+	if (con == -1)
+		*var = i810fb_default;
+	else
+		*var = fb_display[con].var;
+	set_color_bitfields(var);
+	return 0;
+}
+
+    /*
+     *  Round off values to capability of hardware
+     */
+static  void i810fb_round_off(struct fb_var_screeninfo *var)
+{
+	/*
+	 *  Presently supports only these configurations 
+	 */
+	round_off_xres(var);
+	if (var->xres < 8)
+		var->xres = 8;
+	if (var->xres >= 1600) 
+		var->xres = 1600;
+	var->xres = (var->xres + 7) & ~0x07;
+	if (var->xres_virtual < var->xres) 
+		var->xres_virtual = var->xres;
+
+	round_off_yres(var);
+	if (var->yres < 8)
+		var->yres = 8;
+	if (var->yres >= 1600)
+		var->yres = 1600;
+	var->yres = (var->yres + 7) & ~0x07;
+	if (var->yres_virtual < var->yres) 
+		var->yres_virtual = var->yres;
+
+	if (var->bits_per_pixel < 16)
+		var->bits_per_pixel = 8;
+	else if (var->bits_per_pixel < 24) 
+		var->bits_per_pixel = 16;
+	else if (var->bits_per_pixel < 32)
+		var->bits_per_pixel = 24;
+	else 
+		var->bits_per_pixel = 32;
+
+	if ((accel && var->accel_flags) && 
+	     (var->bits_per_pixel < 24 ||
+	      (!render && var->bits_per_pixel < 32))) {
+		switch (rotate) {
+		case NO_ROTATION:
+		case ROTATE_180:
+			i810_orient->xres_var = var->xres;
+			i810_orient->yres_var = var->yres;
+			i810_orient->vxres_var = var->xres_virtual;
+			i810_orient->vyres_var = var->yres_virtual;
+			break;
+		case ROTATE_RIGHT:
+		case ROTATE_LEFT:
+			i810_orient->xres_var = var->yres;
+			i810_orient->yres_var = var->xres;
+			i810_orient->vxres_var = var->yres_virtual;
+			i810_orient->vyres_var = var->xres_virtual;
+		}
+		i810_orient->rotate_var = rotate;
+	}
+	else {
+		i810_orient->xres_var = var->xres;
+		i810_orient->yres_var = var->yres;
+		i810_orient->vxres_var = var->xres_virtual;
+		i810_orient->vyres_var = var->yres_virtual;
+		i810_orient->rotate_var = NO_ROTATION;
+	}
+	
+}	
+    /*
+     * check if parameters passed to var are valid
+     */
+static int i810fb_check_params(struct fb_var_screeninfo *var, 
+			       struct fb_info *info)
+{
+	int line_length, vidmem;
+
+	/*
+	 *  Memory limit
+	 */
+	line_length = get_line_length(i810_orient->vxres_var, 
+				      var->bits_per_pixel);
+	vidmem = line_length*i810_orient->vyres_var;
+	if (vidmem > i810_info->fb_size || !vidmem) {
+		printk("i810fb: required video memory, %dMB, is out of range\n",
+		       vidmem/1000000);
+		return -ENOMEM;
+	}
+	switch (i810_orient->rotate_var) {
+	case NO_ROTATION:
+	case ROTATE_180:
+		var->xres_virtual = line_length/(var->bits_per_pixel >> 3);
+		i810_orient->vxres_var = var->xres_virtual;
+		break;
+	case ROTATE_RIGHT:
+	case ROTATE_LEFT:
+		var->yres_virtual = line_length/(var->bits_per_pixel >> 3);
+		i810_orient->vxres_var = var->yres_virtual;
+	}
+
+			
+	/*
+	 * Monitor limit
+	 */
+	return (i810fb_get_timings(info, i810_timings, i810_orient->xres_var,
+				   i810_orient->yres_var)) ? -EINVAL : 0; 
+}	
+     /*
+      * Update parameters from var once they pass the initial check
+      */
+static void i810fb_set_params(struct fb_var_screeninfo *var)
+{
+		
+	i810_orient->xres = i810_orient->xres_var;
+	i810_orient->yres = i810_orient->yres_var;
+	i810_orient->vxres = i810_orient->vxres_var;
+	i810_orient->vyres = i810_orient->vyres_var;
+	i810_orient->rotate = i810_orient->rotate_var;
+
+	if (render) {
+		switch (i810_orient->vxres * (var->bits_per_pixel >> 3)) {
+		case 0 ... 512:
+			i810_info->i810_gtt.tile_pitch = 2 << 4;
+			i810_info->i810_gtt.pitch_bits = 0;
+			break;
+		case 513 ... 1024:
+			i810_info->i810_gtt.tile_pitch = 3 << 4 ;
+			i810_info->i810_gtt.pitch_bits = 1;
+			break;
+		case 1025 ... 2048:
+			i810_info->i810_gtt.tile_pitch = 4 << 4;
+			i810_info->i810_gtt.pitch_bits = 2;
+			break;
+		case 2049 ... 4096:
+			i810_info->i810_gtt.tile_pitch = 5 << 4;
+			i810_info->i810_gtt.pitch_bits = 3;
+			break;
+		}
+	}
+	set_color_bitfields(var);
+}
+
+     /*
+      *  Set the User Defined Part of the Display
+      */
+
+static int i810fb_set_var(struct fb_var_screeninfo *var, int con,
+			  struct fb_info *info)
+{
+	int err, activate = var->activate;
+	struct display *display;
+	struct fb_var_screeninfo vartmp;
+	if (con >= 0)
+		display = &fb_display[con];
+	else
+	    display = &i810_info->disp;	/* used during initialization */
+	
+	/*
+	 *  FB_VMODE_CONUPDATE and FB_VMODE_SMOOTH_XPAN are equal!
+	 *  as FB_VMODE_SMOOTH_XPAN is only used internally
+	 */
+
+	if (var->vmode & FB_VMODE_CONUPDATE) {
+		var->vmode |= FB_VMODE_YWRAP;
+		var->xoffset = display->var.xoffset;
+		var->yoffset = display->var.yoffset;
+	}
+	vartmp = display->var;
+	i810fb_round_off(var);
+	if ((err = i810fb_check_params(var, info))) 
+		return err;
+	i810fb_set_params(var);
+	if ((activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) {
+		display->var = *var;
+		info->var = *var;
+		if (vartmp.xres != var->xres || 
+		    vartmp.yres != var->yres ||
+		    vartmp.xres_virtual != var->xres_virtual || 
+		    vartmp.yres_virtual != var->yres_virtual ||
+		    vartmp.bits_per_pixel != var->bits_per_pixel || 
+		    vartmp.accel_flags != var->accel_flags) {
+			struct fb_fix_screeninfo fix;
+			
+			i810fb_encode_fix(&fix, var);
+			display->screen_base = 
+				(char *) i810_info->fb_start_virtual;
+			display->visual = fix.visual;
+			display->type = fix.type;
+			display->type_aux = fix.type_aux;
+			display->ypanstep = fix.ypanstep;
+			display->ywrapstep = fix.ywrapstep;
+			/* Choose the most efficient scrolling method */
+			if (var->yres_virtual > var->yres) 
+				display->scrollmode = SCROLL_YNOMOVE;
+			else
+				display->scrollmode = SCROLL_YREDRAW;
+			display->line_length = fix.line_length;
+			display->can_soft_blank = 1;
+			display->inverse = 0;
+
+			switch (var->bits_per_pixel) {
+			case 8:
+				set_var8(display, var);
+				break;
+			case 16:
+				set_var16(display, var);
+				break;
+			case 24:
+				set_var24(display, var);
+				break;
+			case 32:
+				set_var32(display, var);
+				break;
+			default:
+				display->dispsw = &fbcon_dummy;
+				break;
+			}
+			if (i810_info->fb_info.changevar)
+				(*i810_info->fb_info.changevar)(con);
+		}
+		if (con < currcon)
+			return 0;
+/*		if (vartmp.bits_per_pixel != var->bits_per_pixel) { */
+			if ((err = fb_alloc_cmap(&display->cmap, 0, 0))) 
+				return err;
+			do_install_cmap(con, info);
+/*		} */
+		i810_calc_dclk(&i810_info->mode_params, i810_timings->pixelclock);
+		i810fb_fill_vga_registers(info, display);
+
+		i810fb_load_regs(display);
+		i810fb_update_display(display, con, info);
+		if (hwcur) {
+			i810fb_init_cursor();
+			i810fb_set_cursor(display);
+		}
+
+	}
+	return 0;
+}
+
+    /*
+     *  Pan or Wrap the Display
+     *
+     *  This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag
+     */
+
+static int i810fb_pan_display(struct fb_var_screeninfo *var, int con,
+			   struct fb_info *info)
+{
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset < 0 ||
+		    var->yoffset >= fb_display[con].var.yres_virtual ||
+		    var->xoffset)
+			return -EINVAL;
+	} else {
+		if (var->xoffset+fb_display[con].var.xres >
+		    fb_display[con].var.xres_virtual ||
+		    var->yoffset+fb_display[con].var.yres >
+		    fb_display[con].var.yres_virtual)
+			return -EINVAL;
+	}
+	fb_display[con].var.xoffset = var->xoffset;
+	fb_display[con].var.yoffset = var->yoffset;
+	i810fbcon_updatevar(con, info);
+	if (var->vmode & FB_VMODE_YWRAP)
+		fb_display[con].var.vmode |= FB_VMODE_YWRAP;
+	else
+		fb_display[con].var.vmode &= ~FB_VMODE_YWRAP;
+	return 0;
+}
+
+    /*
+     *  Get the Colormap
+     */
+ 
+static int i810fb_get_cmap(struct fb_cmap *cmap, int kspc, int con,
+			struct fb_info *info)
+{
+	if (con == currcon) /* current console? */
+		return fb_get_cmap(cmap, kspc, i810fb_getcolreg, info);
+	else if (fb_display[con].cmap.len) /* non default colormap? */
+		fb_copy_cmap(&fb_display[con].cmap, cmap, kspc ? 0 : 2);
+	else 
+		fb_copy_cmap(fb_default_cmap(1<<fb_display[con].var.bits_per_pixel),
+			     cmap, kspc ? 0 : 2);
+	return 0;
+}
+
+    /*
+     *  Set the Colormap
+     */
+
+static int i810fb_set_cmap(struct fb_cmap *cmap, int kspc, int con,
+			struct fb_info *info)
+{
+	int err;
+	
+	if (!fb_display[con].cmap.len) {	/* no colormap allocated? */
+		if ((err = fb_alloc_cmap(&fb_display[con].cmap,
+					 1<<fb_display[con].var.bits_per_pixel,
+					 0)))
+			return err;
+	}
+	if (con == currcon)			/* current console? */
+		return fb_set_cmap(cmap, kspc, i810fb_setcolreg, info);
+	else
+		fb_copy_cmap(cmap, &fb_display[con].cmap, kspc ? 0 : 1);
+	return 0;
+}
+
+    /*
+     *  i810 Frame Buffer Specific ioctls
+     */
+
+static int i810fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
+		     u_long arg, int con, struct fb_info *info)
+{
+	agp_mem_user agp_mem;
+	i810_command command;
+	int err = 0;
+	
+	switch(cmd) {
+	case I810FB_IOC_COMMAND:
+		if (copy_from_user(&command, (void *) arg, sizeof(command))) 
+			return -EFAULT;
+		return i810fb_process_command(&command);
+	case I810FB_IOC_REQUESTAGPMEM:
+		if (copy_from_user(&agp_mem, (void *) arg, sizeof(agp_mem)))
+			return -EFAULT;
+		if ((err = i810fb_allocate_agpmemory(&agp_mem)))
+			return err;
+		return (copy_to_user((void *) arg, &agp_mem, 
+				     sizeof(agp_mem))) ? -EFAULT : 0;
+	case I810FB_IOC_RELEASEAGPMEM:
+		if (copy_from_user(&agp_mem, (void *) arg, sizeof(agp_mem)))
+			return -EFAULT;
+		return i810fb_free_agpmemory(&agp_mem);
+	case I810FB_IOC_ACQUIREFB:
+		if (i810_info->gart_is_claimed && 
+		    !i810_info->gart_countdown_active)
+			return -EINVAL;
+		if (-1 == (err = i810fb_acquire_fb()))
+			return -EINVAL;
+		put_user(err, (int *) arg);
+		return 0;
+	case I810FB_IOC_AREYOUTHERE:
+		return 0;
+	case I810FB_IOC_CLAIMGART:
+		i810fb_release_gart();
+		return 0;
+	case I810FB_IOC_RELEASEGART:
+		return 	i810fb_reacquire_gart();
+	default:
+		return -EINVAL;
+	}
+}
+
+/**
+ * i810fb_mmap - mmap framebuffer, mmio and off-screen surface
+ * @info: pointer to fb_info
+ * @file: file descriptor
+ * @vma: virtual memory area structure
+ *
+ * DESCRIPTION:
+ * This is a specialized mmap service for the i810fb.  Aside from memory 
+ * mapping the framebuffer and MMIO space, it also allows mapping of 
+ * off-screen surfaces for use as DMA/FIFO buffers which have been previously 
+ * allocated via I810FB_IOC_REQUESTAGPMEM ioctl. The format to map the 
+ * off-screen surface is fix->smem_len + fix->mmio_len + surface offset.  
+ * The "surface offset" is returned by the previous ioctl call.
+ */
+static int i810fb_mmap(struct fb_info *info, struct file *file, 
+		       struct vm_area_struct *vma)
+{
+	u32 off, start;
+	u32 len;
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
+		return -EINVAL;
+	off = vma->vm_pgoff << PAGE_SHIFT;
+	start =i810_info->fb_start_phys;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + i810_info->fb_size);
+	if (off >= len && off < len + MMIO_SIZE) {
+		/* memory mapped io */
+		off -= len;
+		if (info->var.accel_flags)
+			return -EINVAL;
+		start = i810_info->mmio_start_phys;
+		len = PAGE_ALIGN((start & ~PAGE_MASK) + MMIO_SIZE);
+	}
+	else if (off >= len + MMIO_SIZE && off < len + MMIO_SIZE + i810_info->aper_size) { 
+		/* Client off-screen memory */
+		off -= len + MMIO_SIZE;
+		if (info->var.accel_flags)
+			return -EINVAL;
+		if (!(len = i810fb_check_agp_mmap(off >> 12, file->f_owner.uid)))
+			return -EINVAL;
+		start = i810_info->fb_base_phys + off;
+		len += PAGE_ALIGN(start & ~PAGE_MASK);
+		off = 0;
+	}
+	else if (off >= len + MMIO_SIZE + i810_info->aper_size) {
+		/* sarea */
+		off -= len + MMIO_SIZE + i810_info->aper_size;
+		if (info->var.accel_flags)
+			return -EINVAL;
+		if (!(len = i810fb_check_sarea(off >> 12, file->f_owner.uid)))
+			return -ENODEV;
+		start = i810fb_get_sarea_start();
+		len += PAGE_ALIGN(start & ~PAGE_MASK);
+		off = 0;
+	}
+	start &= PAGE_MASK;
+	if ((vma->vm_end - vma->vm_start + off) > len) 
+		return -EINVAL;
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+#if defined(__i386__) || defined(__x86_64__)
+ 	if (boot_cpu_data.x86 > 3)
+		pgprot_val(vma->vm_page_prot) |= _PAGE_PCD;
+#endif 
+	return (io_remap_page_range(vma->vm_start, off, 
+				vma->vm_end - vma->vm_start, 
+				vma->vm_page_prot)) ?
+		-EAGAIN : 0;
+}
+
+
+int __init i810fb_setup(char *options)
+{
+	char *this_opt;
+	
+	fontname[0] = '\0';
+	i810fb_initialized = 1;
+	if (!options || !*options)
+		return 0;
+	
+	for (this_opt = strtok(options, ":"); this_opt;
+	     this_opt = strtok(NULL, ":")) {
+		if (!strncmp(this_opt, "font=", 5))
+			strcpy(fontname, this_opt+5);
+		else if (!strncmp(this_opt, "mtrr", 4))
+			mtrr = 1;
+		else if (!strncmp(this_opt, "accel", 5))
+			accel = 1;
+		else if (!strncmp(this_opt, "ext_vga", 7))
+			ext_vga = 1;
+		else if (!strncmp(this_opt, "hwcur", 5))
+			hwcur = 1;
+		else if (!strncmp(this_opt, "sync_on_pan", 11))
+			sync_on_pan = 1;
+		else if (!strncmp(this_opt, "sync", 4))
+			sync = 1;
+		else if (!strncmp(this_opt, "vram=", 5))
+			vram = (simple_strtoul(this_opt+5, NULL, 0));
+		else if (!strncmp(this_opt, "xres=", 5))
+			xres = simple_strtoul(this_opt+5, NULL, 0);
+		else if (!strncmp(this_opt, "yres=", 5))
+			yres = simple_strtoul(this_opt+5, NULL, 0);
+		else if (!strncmp(this_opt, "vyres=", 6))
+			vyres = simple_strtoul(this_opt+6, NULL, 0);
+		else if (!strncmp(this_opt, "bpp=", 4))
+			bpp = simple_strtoul(this_opt+4, NULL, 0);
+		else if (!strncmp(this_opt, "hsync1=", 7))
+			hsync1 = simple_strtoul(this_opt+7, NULL, 0);
+		else if (!strncmp(this_opt, "hsync2=", 7))
+			hsync2 = simple_strtoul(this_opt+7, NULL, 0);
+		else if (!strncmp(this_opt, "vsync1=", 7))
+			vsync1 = simple_strtoul(this_opt+7, NULL, 0);
+		else if (!strncmp(this_opt, "vsync2=", 7))
+			vsync2 = simple_strtoul(this_opt+7, NULL, 0);
+		else if (!strncmp(this_opt, "render", 6))
+			render = 1;
+		else if (!strncmp(this_opt, "rotate=", 7))
+			rotate = simple_strtoul(this_opt+7, NULL, 0);
+	}
+	return 0;
+}
+
+
+/* Internal  routines */
+/* 
+ * Helper inline functions
+ */
+inline u8 i810_readb(u32 where)
+{
+        return readb(i810_info->mmio_start_virtual + where);
+}
+
+inline u16 i810_readw(u32 where)
+{
+	return readw(i810_info->mmio_start_virtual + where);
+}
+
+inline u32 i810_readl(u32 where)
+{
+	return readl(i810_info->mmio_start_virtual + where);
+}
+
+inline void i810_writeb(u32 where, u8 val)
+{
+	writeb(val, i810_info->mmio_start_virtual + where);
+}
+
+inline void i810_writew(u32 where, u16 val)
+{
+	writew(val, i810_info->mmio_start_virtual + where);
+}
+
+inline void i810_writel(u32 where, u32 val)
+{
+	writel(val, i810_info->mmio_start_virtual + where);
+}
+
+static inline u8 is_cga(void)
+{	
+	return i810_readb(MSR_READ) & 1;
+}
+
+static inline void i810_wait_for_scan_start(void)
+{
+	u32 count = WAIT_COUNT;
+
+	while((i810_readw(DISP_SL) & 0xFFF) && count--);
+}
+
+static inline void vsync_is_active(u32 port)
+{
+	u32 count = WAIT_COUNT;
+
+	while ((i810_readb(port) & 0x08) && count--);
+}
+
+static inline void vsync_is_inactive(u32 port)
+{
+	u32 count = WAIT_COUNT;
+
+	while (!(i810_readb(port) & 0x08) && count--);
+}
+
+static inline void i810_wait_for_hsync(void)
+{
+	u32 count = WAIT_COUNT;
+
+	while((i810_readw(DISP_SL) & 0xFFF) < 5 && count--);
+}
+	
+static inline void i810_wait_for_vsync(int count)
+{
+	u32 port;	
+
+	if (!count) return;
+
+	if (is_cga) port = ST01_CGA;
+	else port =  ST01_MDA;
+		
+	while(count--) {
+		 vsync_is_active(port);
+		 vsync_is_inactive(port);
+	}
+}       
+
+/* Internal Routines */
+
+/**
+ * i810fb_screen_off - turns off/on display
+ * @mode: on or off
+ *
+ * DESCRIPTION:
+ * Blanks/unblanks the display
+ */
+static void i810fb_screen_off(u8 mode)
+{
+	u8 val;
+
+	i810_writeb(SR_INDEX, SR01);
+	val = i810_readb(SR_DATA);
+	if (mode == OFF) 
+		val |= SCR_OFF;
+	else
+		val &= ~SCR_OFF;
+
+	i810_wait_for_scan_start(); 
+	i810_writeb(SR_INDEX, SR01);
+	i810_writeb(SR_DATA, val);
+}
+
+
+/**
+ * i810fb_dram_off - turns off/on dram refresh
+ * @mode: on or off
+ *
+ * DESCRIPTION:
+ * Turns off DRAM refresh.  Must be off for only 2 vsyncs
+ * before data becomes corrupt
+ */
+static void i810fb_dram_off(u8 mode)
+{
+	u8 val;
+
+	val = i810_readb(DRAMCH);
+	if (mode == OFF)
+		val &= DRAM_OFF;
+	else {
+		val &= DRAM_OFF;
+		val |= DRAM_ON;
+	}
+	i810_writeb(DRAMCH, val);
+}
+
+/**
+ * i810fb_protect_regs - allows rw/ro mode of certain VGA registers
+ * @mode: protect/unprotect
+ *
+ * DESCRIPTION:
+ * The IBM VGA standard allows protection of certain VGA registers.  
+ * This will  protect or unprotect them. 
+ */
+static void i810fb_protect_regs(int mode)
+{
+	u32 dataport;
+	u32 indexport;
+	u8 reg;
+
+	if (is_cga()) {
+		indexport = CR_INDEX_CGA;
+		dataport = CR_DATA_CGA;
+	}
+	else {
+		indexport = CR_INDEX_MDA;
+		dataport = CR_DATA_MDA;
+	}
+	i810_writeb(indexport, CR11);
+	reg = i810_readb(dataport);
+	if (mode == OFF)
+		reg &= ~0x80;
+	else 
+		reg |= 0x80;
+ 		
+	i810_writeb(indexport, CR11);
+	i810_writeb(dataport, reg);
+}
+
+/**
+ * i810fb_get_mem_freq - get RAM BUS frequency
+ *
+ * DESCRIPTION:
+ * Determines if RAM bus frequency is 100 or 133 MHz. Writes the result
+ * to info->mem_freq
+ */
+static void __devinit i810fb_get_mem_freq(void)
+{
+	u8 reg;
+	pci_read_config_byte(i810_info->i810_gtt.i810_gtt_info.device, 
+			     0x50, &reg);
+	reg &= FREQ_MASK;
+	if (reg)
+		i810_info->mem_freq = 133;
+	else
+		i810_info->mem_freq = 100;
+}
+
+/* Best to avoid floating point calculations in the kernel ...	*/
+/**
+ * i810_calc_dclk - calculates the P, M, and N values or a pixelclock value
+ * @params: pointer to structure of video registervalues
+ * @freq: pixclock to calculate
+ *
+ * DESCRIPTION:
+ * Based on the formula Freq_actual = (4*M*Freq_ref)/(N^P)
+ * Repeatedly computes the Freq until the actual Freq is equal to
+ * the target Freq or until the loop count is zero.  In the latter
+ * case, the actual frequency nearest the target will be used.
+ * M, N, P registers are write to the params structure.
+ */
+static void i810_calc_dclk(struct mode_registers *params, u32 freq)
+{
+	u32 m_reg, n_reg, p_divisor, n_target_max;
+	u32 m_target, n_target, p_target, val_min, n_best, m_best;
+	u32 f_out, ref_freq, target_freq, diff = 0, target_val;
+
+	n_best = m_best = m_target = f_out = 0;
+	ref_freq = 24000;
+	/* Make target frequency divisible by 125000 */
+	target_freq =  ((((freq + 999)/1000) + 124)/125) * 125;
+	n_target_max = 30;
+	target_val = 0xFFFF;
+	val_min = 0xFFFF;
+
+        /* Let's get a P divisor such that 
+	 * (16 * ref_freq)/(target_freq * p)  < 1 
+	 */
+	p_divisor = 1;
+	p_target = 0;
+	while(((32 * ref_freq)/(target_freq * p_divisor)) && p_divisor < 32) {
+		p_divisor <<= 1;
+		++p_target;
+	}
+
+	n_reg = m_reg = n_target = 3;	
+	while ((target_val) && (n_target < n_target_max)) {
+		f_out = (4 * m_reg * ref_freq)/(n_reg * p_divisor);
+		m_target = m_reg;
+		n_target = n_reg;
+		if (f_out <= target_freq) {
+			++m_reg;
+			diff = target_freq - f_out;
+		}
+		else {
+			++n_reg;
+			diff = f_out - target_freq;
+		}
+		if (diff > 10000) 
+			target_val = 0xFFFF;
+		else 
+			target_val = (diff*10000)/target_freq;
+		if (val_min > target_val) {
+			val_min = target_val;
+			n_best = n_target;
+			m_best = m_target;
+		}		 
+
+	} 
+	params->M = (m_best - 2) & 0x3FF;
+	params->N = (n_best - 2) & 0x3FF;
+	params->P = (p_target << 4);
+	params->pixclock = f_out;
+}
+
+/**
+ * i810fb_get_vblank - get vertical blank time
+ * @hfreq: horizontal freq
+ *
+ * DESCRIPTION:
+ * vblank = front porch + sync + back porch 
+ *    where: front porch = 1;
+ *           sync + back porch = flyback * hfreq
+ *                               ---------------
+ *                                  1000000
+ *           and flyback is set to 550
+ */
+static u32 i810fb_get_vblank(u32 hfreq)
+{
+	u32 vblank;
+
+	vblank = (hfreq * FLYBACK)/1000; 
+	vblank = (vblank + 500)/1000;
+	return (vblank + V_FRONTPORCH);
+}
+
+/** 
+ * i810fb_get_hblank - get horizontal blank time
+ * @hfreq: horizontal freq
+ * @xres: horizontal resolution in pixels
+ *
+ * DESCRIPTION:
+ * duty cycle = C - (M/Hfreq)
+ * where: C = ((offset - scale factor) * blank_scale)
+ *            -------------------------------------- + scale factor
+ *                        256 
+ *        M = blank_scale * gradient
+ */
+static u32 i810fb_get_hblank(u32 hfreq, u32 xres)
+{
+	u32 c_val, m_val, duty_cycle, hblank;
+
+	c_val = (((H_OFFSET - H_SCALEFACTOR) * H_BLANKSCALE)/256 + H_SCALEFACTOR) * 1000;
+	m_val = (H_BLANKSCALE * H_GRADIENT)/256;
+	m_val = (m_val * 1000000)/hfreq;
+	duty_cycle = c_val - m_val;
+	hblank = (xres * duty_cycle)/(100000 - duty_cycle);
+	hblank = (hblank + 4) & ~7;
+	return (hblank);
+}
+
+/**
+ * i810fb_estimate_hfreq - estimate hsync
+ * @vfreq: vertical refresh rate
+ * @yres: vertical resolution
+ *
+ * DESCRIPTION:
+ * Based on:
+ *
+ * (yres + front_port) * vfreq * 1000000
+ * -------------------------------------
+ * (1000000 - (vfreq * FLYBACK)
+ * 
+ */
+
+static u32 i810fb_estimate_hfreq(u32 vfreq, u32 yres)
+{
+	u64 hfreq;
+	u32 divisor;
+	
+	divisor = 1000000 - (vfreq * FLYBACK);
+	
+	hfreq = (u64) (yres + V_FRONTPORCH) *  
+		(u64) (vfreq)  * 1000000;
+	do_div(hfreq, divisor);
+	
+	return ((u32) hfreq);
+}
+
+
+/**
+ * i810fb_get_timings - calculate video timings 
+ * @info: pointer to fb_info structure
+ * @timings: pointer to video_timings structure
+ * @xres: horizontal resolution
+ * @yres: vertical resolution
+ * 
+ * DESCRIPTION:
+ * Calculates necessary timing information based on 
+ * monitor specifications.  This will use the 
+ * VESA general timing foruula
+ */                      
+static int i810fb_get_timings(struct fb_info *info, 
+			      struct video_timings *timings,
+			      int xres, int yres)
+{
+	u32 htotal = 0, vtotal, hfreq, vfreq, hblank, vblank, dclk;
+
+	memset(timings, 0, sizeof(struct video_timings));
+	hfreq = info->monspecs.hfmax;
+	vblank = i810fb_get_vblank(hfreq);
+	vtotal = yres + vblank;
+	vfreq = hfreq/vtotal;
+	if (vfreq > info->monspecs.vfmax) { 
+		vfreq = info->monspecs.vfmax;
+		hfreq = i810fb_estimate_hfreq(vfreq, yres);
+		vblank = i810fb_get_vblank(hfreq);
+		vtotal = yres + vblank;
+	}	
+	hblank = i810fb_get_hblank(hfreq, xres);
+	htotal = xres + hblank;
+	dclk = htotal * hfreq;
+	while(dclk > MAX_PIXELCLOCK         &&  
+	      hfreq >= info->monspecs.hfmin &&
+	      vfreq >= info->monspecs.vfmin)   {
+		hfreq -= 1000;
+		vblank = i810fb_get_vblank(hfreq);
+		vtotal = yres + vblank;
+		vfreq = hfreq/vtotal;
+		hblank = i810fb_get_hblank(hfreq, xres);
+		htotal = xres + hblank;
+		dclk = hfreq * htotal;
+	} 
+	if (vfreq < info->monspecs.vfmin) {
+		printk("i810fb: required vertical refresh, %dHz, "
+		       "for %dx%d is out of range\n",
+		       vfreq, xres, yres);
+		return -1;
+	}
+	if (hfreq < info->monspecs.hfmin) {
+		printk("i810fb: required horizontal sync frequency, %dKHz, "
+		       "for %dx%d is out of range\n", hfreq/1000, xres, yres);
+		return -1;
+	}
+	if (dclk < MIN_PIXELCLOCK) {
+		printk("i810fb: required pixelclock, %dMHz, for %dx%d"
+		       " is out of range\n", dclk/1000000, xres, yres);
+		return -1;
+	}
+	timings->htotal = htotal;
+	timings->vtotal = vtotal;
+	timings->vfreq = vfreq;
+	timings->hfreq = hfreq;
+	timings->hblank = hblank;
+	timings->vblank = vblank;
+	timings->pixelclock = dclk;
+	return 0;
+}
+
+
+/**
+ * i810fb_load_pll
+ * @disp: pointer to display structure
+ *
+ * DESCRIPTION:
+ * Loads the P, M, and N registers.  
+ * USES:
+ * info->mode_params
+ */
+static void i810fb_load_pll(struct display *disp)
+{
+ 	u32 tmp1, tmp2;
+	
+	tmp1 = i810_info->mode_params.M | i810_info->mode_params.N << 16;
+	tmp2 = i810_readl(DCLK_2D);
+	tmp2 &= ~MN_MASK;
+	i810_writel(DCLK_2D, tmp1 | tmp2);
+	
+	tmp1 = i810_info->mode_params.P;
+	tmp2 = i810_readl(DCLK_0DS);
+	tmp2 &= ~(P_OR << 16);
+	i810_writel(DCLK_0DS, (tmp1 << 16) | tmp2);
+
+	i810_writeb(MSR_WRITE, 0xC8);
+
+}
+
+/**
+ * i810fb_load_vga - load standard VGA registers
+ *
+ * DESCRIPTION:
+ * Load values to VGA registers
+ */
+static void i810fb_load_vga(void)
+{	
+	u32 indexport, dataport;
+      
+	if (is_cga()) {
+		indexport = CR_INDEX_CGA;
+		dataport = CR_DATA_CGA;
+	}
+	else {
+		indexport = CR_INDEX_MDA;
+		dataport = CR_DATA_MDA;
+	}
+	i810_writeb(indexport, CR00);
+	i810_writeb(dataport, i810_info->mode_params.cr00);
+	i810_writeb(indexport, CR01);
+	i810_writeb(dataport, i810_info->mode_params.cr01);
+	i810_writeb(indexport, CR02);
+	i810_writeb(dataport, i810_info->mode_params.cr02);
+	i810_writeb(indexport, CR03);
+	i810_writeb(dataport, i810_info->mode_params.cr03);
+	i810_writeb(indexport, CR04);
+	i810_writeb(dataport, i810_info->mode_params.cr04);
+	i810_writeb(indexport, CR05);
+	i810_writeb(dataport, i810_info->mode_params.cr05);
+	i810_writeb(indexport, CR06);
+	i810_writeb(dataport, i810_info->mode_params.cr06);
+	i810_writeb(indexport, CR09);
+	i810_writeb(dataport, i810_info->mode_params.cr09);
+	i810_writeb(indexport, CR10);
+	i810_writeb(dataport, i810_info->mode_params.cr10);
+	i810_writeb(indexport, CR11);
+	i810_writeb(dataport, i810_info->mode_params.cr11);
+	i810_writeb(indexport, CR12);
+	i810_writeb(dataport, i810_info->mode_params.cr12);
+	i810_writeb(indexport, CR15);
+	i810_writeb(dataport, i810_info->mode_params.cr15);
+	i810_writeb(indexport, CR16);
+	i810_writeb(dataport, i810_info->mode_params.cr16);
+}
+
+
+/**
+ * i810fb_load_vgax - load extended VGA registers
+ *
+ * DESCRIPTION:
+ * Load values to extended VGA registers
+ */
+
+static void i810fb_load_vgax(void)
+{
+	u32 indexport, dataport;
+
+	if (is_cga()) {
+		indexport = CR_INDEX_CGA;
+		dataport = CR_DATA_CGA;
+	}
+	else {
+		indexport = CR_INDEX_MDA;
+		dataport = CR_DATA_MDA;
+	}
+	i810_writeb(indexport, CR30);
+	i810_writeb(dataport, i810_info->mode_params.cr30);
+	i810_writeb(indexport, CR31);
+	i810_writeb(dataport, i810_info->mode_params.cr31);
+	i810_writeb(indexport, CR32);
+	i810_writeb(dataport, i810_info->mode_params.cr32);
+	i810_writeb(indexport, CR33);
+	i810_writeb(dataport, i810_info->mode_params.cr33);
+	i810_writeb(indexport, CR35);
+	i810_writeb(dataport, i810_info->mode_params.cr35);
+	i810_writeb(indexport, CR39);
+	i810_writeb(dataport, i810_info->mode_params.cr39);
+}
+
+/**
+ * i810fb_load_2d - load grahics registers
+ * @wm: watermark
+ *
+ * DESCRIPTION:
+ * Load values to graphics registers
+ */
+
+static void i810fb_load_2d(u32 wm)
+{
+	u32 tmp;
+
+  	i810_writel(FW_BLC, wm); 
+	tmp = i810_readl(PIXCONF);
+	tmp |= 1;
+	i810_writel(PIXCONF, tmp);
+	i810fb_write_sarea_reg(); 
+
+}	
+
+/**
+ * i810fb_hires - enables high resolution mode
+ */
+static void i810fb_hires(void)
+{
+	u32 indexport, dataport;
+	u8 val;
+	
+	if (is_cga()) {
+		indexport = CR_INDEX_CGA;
+		dataport = CR_DATA_CGA;
+	}
+	else {
+		indexport = CR_INDEX_MDA;
+		dataport = CR_DATA_MDA;
+	}
+
+
+	i810_writeb(indexport, CR80);
+	val = i810_readb(dataport);
+	i810_writeb(indexport, CR80);
+	i810_writeb(dataport, val | 1);
+}
+
+/**
+ * i810fb_load_fbstart - loads pointer of the framebuffer
+ * @offset: where to start display from the start of framebuffer
+ */
+static void i810fb_load_fbstart(int offset)
+{
+	u32 addr, indexport, dataport, vidmem;
+	u8 val;
+
+	vidmem = i810_info->fb_start_phys + offset;
+	if (is_cga()) {
+		indexport = CR_INDEX_CGA;
+		dataport = CR_DATA_CGA;
+	}
+	else {
+		indexport = CR_INDEX_MDA;
+		dataport = CR_DATA_MDA;
+	}
+	
+	addr = ((vidmem + 2) >> 2) & 0xFF;
+	i810_writeb(indexport, CR0D);
+	i810_writeb(dataport, (u8) addr);
+	
+	addr = (vidmem >> 10) & 0xFF;
+	i810_writeb(indexport, CR0C);
+	i810_writeb(dataport, (u8) addr);
+	
+	addr = (vidmem >> 18) & 0x3F;
+	i810_writeb(indexport, CR40);
+	val = i810_readb(dataport) & ~0x3F;
+	i810_writeb(indexport, CR40);
+	i810_writeb(dataport, (u8) addr | val);
+	
+	addr = vidmem >> 24;
+	i810_writeb(indexport, CR42);
+	i810_writeb(dataport, (u8) addr);
+	
+	i810_writeb(indexport, CR40);
+	val = i810_readb(dataport) | 0x80;
+	i810_writeb(indexport, CR40);
+	i810_writeb(dataport, val);
+}
+	
+/**
+ * i810fb_load_pitch - loads the characters per line of the display
+ * @var: pointer to fb_var_screeninfo
+ *
+ * DESCRIPTION:
+ * Loads the characters per line
+ */	
+static void i810fb_load_pitch(struct fb_var_screeninfo *var)
+{
+
+	u32 tmp, indexport, dataport;
+	u32 line_length = get_line_length(i810_orient->vxres, 
+					  var->bits_per_pixel) >> 3;
+	u8 val;
+			
+	if (is_cga()) {
+		indexport = CR_INDEX_CGA;
+		dataport = CR_DATA_CGA;
+	}
+	else {
+		indexport = CR_INDEX_MDA;
+		dataport = CR_DATA_MDA;
+	}
+
+	i810_writeb(SR_INDEX, SR01);
+	val = i810_readb(SR_DATA);
+	val &= 0xE0;
+	val |= 0x01;
+	i810_writeb(SR_INDEX, SR01);
+	i810_writeb(SR_DATA, val);
+
+	tmp = line_length & 0xFF;
+	i810_writeb(indexport, CR13);
+	i810_writeb(dataport, (u8) tmp);
+	
+	tmp = line_length >> 8;
+	i810_writeb(indexport, CR41);
+	val = i810_readb(dataport) & ~0x0F;
+	i810_writeb(indexport, CR41);
+	i810_writeb(dataport, (u8) tmp | val);
+}
+
+/**
+ * i810fb_load_color - loads the color depth of the display
+ * @var: pointer to fb_var_screeninfo
+ *
+ * DESCRIPTION:
+ * Loads the color depth of the display and the graphics engine
+ */
+static void i810fb_load_color(struct fb_var_screeninfo *var)
+{
+	u32 reg1;
+	u16 reg2;
+	reg1 = i810_readl(PIXCONF) & ~0xF0000;
+	reg2 = i810_readw(BLTCNTL) & ~0x30;
+	switch(var->bits_per_pixel) {
+	case 8:
+		reg1 |= 0x20000;
+		break;
+	case 16: 
+		reg1 |= 0x50000;
+		reg2 |= 0x10;
+		break;
+	case 24:
+		reg1 |= 0x60000;
+		reg2 |= 0x20;
+		break;
+	case 32:
+		reg1 |= 0x70000;
+		reg2 |= 0x20;
+		break;
+	}
+	reg1 |= 0x8000;  
+	i810_writel(PIXCONF, reg1);
+	i810_writew(BLTCNTL, reg2);
+}
+
+static void i810fb_load_fence(void)
+{
+	u32 fence, fence_bit;
+
+	fence_bit = i810_info->i810_gtt.fence_size;
+	fence = i810_info->fb_offset << 12;
+	fence |= TILEWALK_X | i810_info->i810_gtt.fence_size << 8 |
+                 i810_info->i810_gtt.tile_pitch | 1;
+        i810_writel(FENCE, fence);
+}         
+
+
+/**
+ * i810fb_load_regs - loads all registers for the mode
+ * @disp: pointer to display structure
+ * 
+ * DESCRIPTION:
+ * Loads registers
+ */
+ 
+static void i810fb_load_regs(struct display *disp)
+{
+	i810fb_screen_off(OFF);
+	i810fb_protect_regs(OFF);
+	i810fb_dram_off(OFF);
+	i810fb_load_pll(disp);
+	i810fb_load_vga();
+	i810fb_load_vgax();
+	i810fb_dram_off(ON);	
+	i810fb_load_2d(i810fb_get_watermark(&disp->var));
+	i810fb_hires();
+	i810fb_screen_off(ON);
+	i810fb_protect_regs(ON);
+	if (render) i810fb_load_fence();
+}
+
+
+/**
+ * i810fb_update_display - initialize display
+ * @disp: pointer to display structure
+ */
+static void i810fb_update_display(struct display *disp, int con, 
+			    struct fb_info *info)
+{
+	i810fb_load_color(&disp->var);
+	i810fb_load_pitch(&disp->var); 
+	if (!i810_info->gart_is_claimed)
+		i810fb_init_ringbuffer();
+	i810fbcon_updatevar(con, info);	
+}
+
+/*
+ * Hardware Cursor Routines
+ */
+
+/**
+ * i810fb_load_cursor_image - create cursor bitmap
+ * @p: pointer to display structure
+ * 
+ * DESCRIPTION:
+ * Creates the cursor bitmap using the 2bpp, 2plane
+ * with transparency format of the i810.  The first plane
+ * is the actual monochrome bitmap, and the second plane is 
+ * the transparency bit. This particular cursor is a 
+ * rectangular block, a fontwidth wide and 2 scanlines high, 
+ * starting just below the fontbase.  
+ */
+static void i810fb_load_cursor_image(struct display *p)
+{
+ 	int i, j, h, w;
+ 	u8 *addr;
+ 	
+	h = fontheight(p);
+	w = fontwidth(p);
+	(u32)addr = i810_info->cursor_start_virtual;
+	for (i = 64; i--; ) {
+		for (j = 0; j < 8; j++) {
+			addr[j] = 0xFF;               /* transparent - yes */
+			addr[j+8] = 0x00;             /* use background  0x00*/
+		}	
+		addr +=16;
+	}
+	
+	switch (i810_orient->rotate) {
+	case NO_ROTATION:
+		(u32)addr = i810_info->cursor_start_virtual + ((h-1) << 4);	
+		for (i = 0; i < 2; i++) {
+			for (j = 0; j < (w >> 3); j++) {
+				addr[(j+0) << 3] = 0x00;        /* transparent - no */
+				addr[(j+1) << 3] = 0xFF;        /* use foreground */
+				addr +=16;
+			}
+		}
+		break;
+	case ROTATE_RIGHT:
+		(u32) addr = i810_info->cursor_start_virtual;
+		for (i = 0; i < w; i++) {
+			addr[0] = (~(3 << 6)) & 0xFF;
+			addr[8] = 3 << 6;
+			addr += 16;
+		}	
+		break;
+	case ROTATE_180:
+		(u32)addr = i810_info->cursor_start_virtual;	
+		for (i = 0; i < 2; i++) {
+			for (j = 0; j < (w >> 3); j++) {
+				addr[(j+0) << 3] = 0x00;        /* transparent - no */
+				addr[(j+1) << 3] = 0xFF;        /* use foreground */
+				addr +=16;
+			}
+		}
+		break;
+	case ROTATE_LEFT:
+		(u32) addr = i810_info->cursor_start_virtual + ((h-8) >> 3);
+		for (i = 0; i < w; i++) {
+			addr[0] = ~3;
+			addr[8] = 3;
+			addr += 16;
+		}	
+		break;
+	}
+	flush_cache();
+}	 			
+
+/**
+ * i810fb_set_cursor_color - set the cursor CLUT
+ * @p: pointer to display structure
+ *
+ * DESCRIPTION:
+ * The i810 has two DACS, the standard 256-index CLUT and the
+ * alternate 8-index CLUT. The alternate CLUT is where the
+ * cursor gets the color information.
+ */
+static void i810fb_set_cursor_color(struct display *p)
+{
+	u32 fgr, fgg, fgb, fgt;
+	u32 bgr, bgg, bgb, bgt;
+	u8 temp;
+	
+	i810fb_getcolreg(p->bgcol, &bgr, &bgg, &bgb, &bgt, p->fb_info);
+	i810fb_getcolreg(p->fgcol, &fgr, &fgg, &fgb, &fgt, p->fb_info);
+
+	temp = i810_readb(PIXCONF1);
+	i810_writeb(PIXCONF1, temp | EXTENDED_PALETTE);
+
+	i810_writeb(DACMASK, 0xFF); 
+        i810_writeb(CLUT_INDEX_WRITE, 0x04);	
+
+	i810_writeb(CLUT_DATA, (u8) bgr);
+	i810_writeb(CLUT_DATA, (u8) bgg);
+	i810_writeb(CLUT_DATA, (u8) bgb);
+
+	i810_writeb(CLUT_DATA, (u8) fgr);
+	i810_writeb(CLUT_DATA, (u8) fgg);
+	i810_writeb(CLUT_DATA, (u8) fgb);
+
+	temp = i810_readb(PIXCONF1);
+	i810_writeb(PIXCONF1, temp & ~EXTENDED_PALETTE);
+	
+}		 
+
+static void i810fb_set_cursor(struct display *disp)
+{
+	i810fb_set_cursor_color(disp); 
+	i810fb_load_cursor_image(disp);
+}	
+	
+/**
+ * i810fb_enable_cursor - show or hide the hardware cursor
+ * @mode: show (1) or hide (0)
+ *
+ * Description:
+ * Shows or hides the hardware cursor
+ */
+void i810fb_enable_cursor(int mode)
+{
+	u32 temp;
+	
+	temp = i810_readl(PIXCONF);
+	if (mode == ON)
+		temp |= CURSOR_ENABLE_MASK;
+	else
+		temp &= ~CURSOR_ENABLE_MASK;
+	i810_writel(PIXCONF, temp);
+}
+			
+/**
+ * i810_cursor_timer_handler - cursor timer handler
+ * @data: arbitrary data which points to cursor structure
+ *
+ * DESCRIPTION:
+ * The cursor timer handler.  This handles the blinking
+ * of the cursor
+ */
+static void i810_cursor_timer_handler(unsigned long data)
+{ 
+	struct cursor_data *cur;
+	(u32) cur = data;
+	if (cur->cursor_enable && !cur->blink_count) {
+		if (cur->cursor_show) {
+			i810fb_enable_cursor(OFF);
+			cur->cursor_show = 0; 
+		}
+		else {
+			i810fb_enable_cursor(ON);
+			cur->cursor_show = 1;
+		}
+		cur->blink_count = cur->blink_rate;
+	}	
+	--cur->blink_count;
+	cur->timer->expires = jiffies + (HZ/100);
+	add_timer(cur->timer);
+}				
+
+
+/**
+ * i810fb_init_cursor - initializes the cursor
+ *
+ * DESCRIPTION:
+ * Initializes the cursor registers
+ */
+static void i810fb_init_cursor(void)
+{
+	i810fb_enable_cursor(OFF);
+	i810_writel(CURBASE, i810_info->cursor_start_phys);
+	i810_writew(CURCNTR, COORD_ACTIVE | CURSOR_MODE_64_TRANS);
+}	
+
+
+
+
+static int i810fbcon_switch(int con, struct fb_info *info)
+{
+	currcon = con;
+	i810fb_set_var(&fb_display[con].var, con, info);
+    	return 0;
+}
+
+    /*
+     *  Update the `var' structure (called by fbcon.c)
+     */
+static int i810fbcon_updatevar(int con, struct fb_info *info)
+{
+  	struct display *p = &fb_display[con];
+	int yoffset, xoffset, depth, total = 0;
+	
+	yoffset = p->var.yoffset; 
+	xoffset = p->var.xoffset;
+	depth = p->var.bits_per_pixel >> 3;
+
+	switch (i810_orient->rotate) {
+	case NO_ROTATION:
+		if (p->var.xres + xoffset <= p->var.xres_virtual)
+			total += xoffset * depth;
+		if (p->var.yres + yoffset <= p->var.yres_virtual)
+			total += yoffset * p->next_line;
+		break;
+	case ROTATE_RIGHT:
+		if (p->var.xres + xoffset <= p->var.xres_virtual)
+			total += xoffset * p->next_line;
+		if (p->var.yres + yoffset <= p->var.yres_virtual)
+			total += (i810_orient->vxres - p->var.yres - 
+				  yoffset) * depth;
+		break;
+	case ROTATE_180:
+		if (p->var.xres + xoffset <= p->var.xres_virtual)
+			total += (i810_orient->vxres - 
+				  p->var.xres - xoffset) * depth;
+		if (p->var.yres + yoffset <= p->var.yres_virtual)
+			total += (i810_orient->vyres - 
+				  p->var.yres - yoffset) * p->next_line;
+		break;
+	case ROTATE_LEFT:
+		if (p->var.xres + xoffset <= p->var.xres_virtual)
+			total += (i810_orient->vyres - p->var.xres - 
+				  xoffset) * p->next_line;
+		if (p->var.yres + yoffset <= p->var.yres_virtual)
+			total += yoffset * depth;
+	}
+
+	if (!i810_info->gart_is_claimed && render) {
+		if (!sync_on_pan)
+			i810fb_load_back(i810_info->i810_gtt.pitch_bits);
+		if (i810fb_load_front(total, p->next_line, (sync_on_pan) ? 0 : 1))
+			i810fb_load_fbstart(total);
+	}
+	else
+		i810fb_load_fbstart(total);
+	return 0;
+}
+
+    /*
+     *  Blank the display.
+     */
+static void i810fbcon_blank(int blank, struct fb_info *info)
+{
+	int mode = 0;
+	
+	switch(blank) {
+	case VESA_NO_BLANKING:
+		mode = POWERON;
+		break;
+	case VESA_VSYNC_SUSPEND:
+		mode = STANDBY;
+		break;
+	case VESA_HSYNC_SUSPEND:
+		mode = SUSPEND;
+		break;
+	case VESA_POWERDOWN:
+		mode = POWERDOWN;
+	}
+	i810_writel(HVSYNC, mode);
+	
+}
+
+u32 get_line_length(int xres_virtual, int bpp)
+{
+	u32 length;
+	
+	length = xres_virtual*bpp;
+	length = (length+31)&-32;
+	length >>= 3;
+	
+	if (render) {
+		switch (length) {
+		case 0 ... 512:
+			length = 512;
+			break;
+		case 513 ... 1024:
+			length = 1024;
+			break;
+		case 1025 ... 2048:
+			length = 2048;
+			break;
+		case 2049 ... 4096:
+			length = 4096;
+			break;
+		default:
+			length = 0;
+		}
+	}
+	return(length);
+}
+
+static void i810fb_encode_fix(struct fb_fix_screeninfo *fix,
+			   struct fb_var_screeninfo *var)
+{
+    	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+    	strcpy(fix->id, i810fb_name);
+    	fix->smem_start = i810_info->fb_start_phys;
+    	fix->smem_len = i810_info->fb_size;
+    	fix->type = FB_TYPE_PACKED_PIXELS;
+    	fix->type_aux = 0;
+    	switch (var->bits_per_pixel) {
+
+	case 8:
+	    	fix->visual = FB_VISUAL_PSEUDOCOLOR;
+	    	break;
+	case 16:
+	case 24:
+	case 32:
+	    	fix->visual = FB_VISUAL_TRUECOLOR;
+	    	break;
+    }
+    	fix->ywrapstep = 0;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+    	fix->line_length = get_line_length(i810_orient->vxres, 
+					   var->bits_per_pixel);
+	fix->mmio_start = i810_info->mmio_start_phys;
+	fix->mmio_len = MMIO_SIZE;
+	fix->accel = FB_ACCEL_I810;
+		
+}
+
+static void set_color_bitfields(struct fb_var_screeninfo *var)
+{
+	switch (var->bits_per_pixel) {
+	case 8:       
+		var->red.offset = 0;
+		var->red.length = 8;
+		var->green.offset = 0;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 16:	/* RGB 565 */
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 24:	/* RGB 888 */
+		var->red.offset = 16;
+		var->red.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 32:	/* RGB 888 */
+		var->red.offset = 16;
+		var->red.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		break;
+	}
+	var->red.msb_right = 0;
+	var->green.msb_right = 0;
+	var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+}
+
+
+    /*
+     *  Read a single color register and split it into
+     *  colors/transparent. Return != 0 for invalid regno.
+     */
+
+static int i810fb_getcolreg(u_int regno, u_int *red, u_int *green, u_int *blue,
+                         u_int *transp, struct fb_info *info)
+{
+	if (regno > 255) return 1;
+ 	i810_writeb(CLUT_INDEX_READ, (u8) regno);
+ 	*red = (u32) i810_readb(CLUT_DATA);
+ 	*green = (u32) i810_readb(CLUT_DATA);
+ 	*blue = (u32) i810_readb(CLUT_DATA);
+    	*transp = 0;
+    	return 0;
+}
+
+
+    /*
+     *  Set a single color register. The values supplied are already
+     *  rounded down to the hardware's capabilities (according to the
+     *  entries in the var structure). Return != 0 for invalid regno.
+     */
+
+static int i810fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+                         u_int transp, struct fb_info *info)
+{
+    	if (regno > 255) return 1;
+	i810_writeb(CLUT_INDEX_WRITE, (u8) regno);
+	i810_writeb(CLUT_DATA, (u8) red);
+	i810_writeb(CLUT_DATA, (u8) green);
+	i810_writeb(CLUT_DATA, (u8) blue); 	
+	if (regno < 16) {
+		switch (info->var.bits_per_pixel) {
+		case 16:		/* RGB 565 */
+			((u16 *)(palette))[regno] = (red & 0xf800) |
+				((green & 0xfc00) >> 5) |
+				((blue & 0xf800) >> 11);
+			break;
+		case 24:		/* RGB 888 */
+		case 32:		/* RGBA 8888 */
+			((u32 *)(palette))[regno] = ((red & 0xff00) << 8) |
+				(green & 0xff00) |
+				((blue & 0xff00) >> 8);
+			break;
+		}
+	}
+      	return 0;
+}
+
+
+static void do_install_cmap(int con, struct fb_info *info)
+{
+	if (con != currcon) return;
+	if (fb_display[con].cmap.len)
+		fb_set_cmap(&fb_display[con].cmap, 1, i810fb_setcolreg, info);
+	else
+		fb_set_cmap(fb_default_cmap(1<<fb_display[con].var.bits_per_pixel), 1,
+			    i810fb_setcolreg, info);
+}
+
+
+/**
+ * i810fb_create_cursor - creates the cursor structure
+ *
+ * DESCRIPTION:
+ * Creates the hardware cursor structure and starts the 
+ * cursor timer
+ *
+ * RETURNS: nonzero if success
+ */
+static int __devinit i810fb_create_cursor(void) {
+	i810_info->cursor.timer = kmalloc(sizeof(struct timer_list), 
+					  GFP_KERNEL); 
+	if (!i810_info->cursor.timer) return 0;
+	init_timer(i810_info->cursor.timer);
+	i810_info->cursor.blink_rate = 40;
+	i810_info->cursor.blink_count = i810_info->cursor.blink_rate; 
+	i810_info->cursor.cursor_show = 0;
+	i810_info->cursor.cursor_enable = 0;
+	i810_info->cursor.timer->data = (u32) &i810_info->cursor;
+	i810_info->cursor.timer->expires = jiffies + (HZ/100);
+	i810_info->cursor.timer->function = i810_cursor_timer_handler;
+	return 1;
+}
+
+/**
+ * i810fb_init_monspecs
+ * @fb_info: pointer to device specific info structure
+ *
+ * DESCRIPTION:
+ * Sets the the user monitor's horizontal and vertical
+ * frequency limits
+ */
+
+static void __devinit i810fb_init_monspecs(struct fb_info *fb_info)
+{
+	if (!hsync1)
+		hsync1 = HFMIN;
+	if (!hsync2) 
+		hsync2 = HFMAX;
+	fb_info->monspecs.hfmax = hsync2 * 1000;
+	fb_info->monspecs.hfmin = hsync1 * 1000;
+	if (hsync2 < hsync1) 
+		fb_info->monspecs.hfmin = hsync2 * 1000;
+
+	if (!vsync2)
+		vsync2 = VFMAX;
+	if (!vsync1) 
+		vsync1 = VFMIN;
+	fb_info->monspecs.vfmax = vsync2;
+	fb_info->monspecs.vfmin = vsync1;		
+	if (vsync2 < vsync1) 
+		fb_info->monspecs.vfmin = vsync2;
+}
+
+/**
+ * i810fb_init_defaults - initializes default values to use
+ */
+static void __devinit i810fb_init_defaults(void)
+{
+	i810fb_default.xres = xres;
+	i810fb_default.yres = yres;
+	i810fb_default.yres_virtual = vyres;
+	i810fb_default.bits_per_pixel = bpp;
+	i810fb_init_monspecs(&i810_info->fb_info);
+	if (!has_mtrr()) mtrr = 0;
+	if (!has_rotate()) rotate = 0;
+	if (!has_accel()) accel = 0;
+	if (accel) i810fb_default.accel_flags = 1;
+	if (rotate > 3) rotate = NO_ROTATION;
+	if (hwcur) {
+		fix_cursor_accel();
+		fix_cursor_rotate();
+		i810_noaccel8.cursor = i810_cursor;
+		i810_noaccel16.cursor = i810_cursor;
+		i810_noaccel24.cursor = i810_cursor;
+		i810_noaccel32.cursor = i810_cursor;
+		fbcon_dummy.cursor = i810_cursor;
+	}
+}
+
+
+/**
+ * i810fb_save_vgax - save extended register states
+ */
+static void i810fb_save_vgax(void)
+{
+	u32 indexport, dataport;
+	u8 i;
+
+	if (is_cga()) {
+		dataport = CR_DATA_CGA;
+		indexport = CR_INDEX_CGA;
+	}
+	else {
+		dataport = CR_DATA_MDA;
+		indexport = CR_INDEX_MDA;
+	}
+	
+	for (i = 0; i < 4; i++) {
+		i810_writeb(indexport, CR30 + i);
+		*(&(i810_info->hw_state.cr30) + i) = i810_readb(dataport);
+	}
+	i810_writeb(indexport, CR35);
+	i810_info->hw_state.cr35 = i810_readb(dataport);
+	i810_writeb(indexport, CR39);
+	i810_info->hw_state.cr39 = i810_readb(dataport);
+	i810_writeb(indexport, CR41);
+	i810_info->hw_state.cr41 = i810_readb(dataport);
+	i810_writeb(indexport, CR70);
+	i810_info->hw_state.cr70 = i810_readb(dataport);	
+	i810_info->hw_state.msr = i810_readb(MSR_READ);
+	i810_writeb(indexport, CR80);
+	i810_info->hw_state.cr80 = i810_readb(dataport);
+	i810_writeb(SR_INDEX, SR01);
+	i810_info->hw_state.sr01 = i810_readb(SR_DATA);
+}
+
+/**
+ * i810fb_save_vgax - save standard register states
+ */
+static void i810fb_save_vga(void)
+{
+	u32 indexport, dataport;
+	u8 i;
+	if (is_cga()) {
+		dataport = CR_DATA_CGA;
+		indexport = CR_INDEX_CGA;
+	}
+	else {
+		dataport = CR_DATA_MDA;
+		indexport = CR_INDEX_MDA;
+	}	
+	for (i = 0; i < 10; i++) {
+		i810_writeb(indexport, CR00 + i);
+		*((&i810_info->hw_state.cr00) + i) = i810_readb(dataport);
+	}
+	for (i = 0; i < 8; i++) {
+		i810_writeb(indexport, CR10 + i);
+		*((&i810_info->hw_state.cr10) + i) = i810_readb(dataport);
+	}
+}
+
+/**
+ * i810fb_restore_pll - restores saved PLL register
+ */
+static void i810fb_restore_pll(void)
+{
+	u32 tmp1, tmp2;
+	
+	tmp1 = i810_info->hw_state.dclk_2d;
+	tmp2 = i810_readl(DCLK_2D);
+	tmp1 &= ~MN_MASK;
+	tmp2 &= MN_MASK;
+	i810_writel(DCLK_2D, tmp1 | tmp2);
+
+	tmp1 = i810_info->hw_state.dclk_1d;
+	tmp2 = i810_readl(DCLK_1D);
+	tmp1 &= ~MN_MASK;
+	tmp2 &= MN_MASK;
+	i810_writel(DCLK_1D, tmp1 | tmp2);
+
+	i810_writel(DCLK_0DS, i810_info->hw_state.dclk_0ds);
+
+
+}
+
+/**
+ * i810fb_restore_dac - restores saved DAC register
+ */
+static void i810fb_restore_dac(void)
+{
+	u32 tmp1, tmp2;
+
+	tmp1 = i810_info->hw_state.pixconf;
+	tmp2 = i810_readl(PIXCONF);
+	tmp1 &= DAC_BIT;
+	tmp2 &= ~DAC_BIT;
+	i810_writel(PIXCONF, tmp1 | tmp2);
+}
+
+/**
+ * i810fb_restore_vgax - restores saved extended VGA registers
+ */
+static void i810fb_restore_vgax(void)
+{
+	u32 indexport, dataport;
+	u8 i, j;
+	
+	if (is_cga()) {
+		dataport = CR_DATA_CGA;
+		indexport = CR_INDEX_CGA;
+	}
+	else {
+		dataport = CR_DATA_MDA;
+		indexport = CR_INDEX_MDA;
+	}
+			
+	for (i = 0; i < 4; i++) {
+		i810_writeb(indexport, CR30+i);
+		i810_writeb(dataport, *(&(i810_info->hw_state.cr30) + i));
+	}
+	i810_writeb(indexport, CR35);
+	i810_writeb(dataport, i810_info->hw_state.cr35);
+	i810_writeb(indexport, CR39);
+	i810_writeb(dataport, i810_info->hw_state.cr39);
+	i810_writeb(indexport, CR41);
+	i810_writeb(dataport, i810_info->hw_state.cr39);
+
+	/*restore interlace*/
+	i810_writeb(indexport, CR70);
+	i = i810_info->hw_state.cr70;
+	i &= INTERLACE_BIT;
+	j = i810_readb(dataport);
+	i810_writeb(indexport, CR70);
+	i810_writeb(dataport, j | i);
+
+	i810_writeb(indexport, CR80);
+	i810_writeb(dataport, i810_info->hw_state.cr80);
+	i810_writeb(MSR_WRITE, i810_info->hw_state.msr);
+	i810_writeb(SR_INDEX, SR01);
+	i = (i810_info->hw_state.sr01) & ~0xE0 ;
+	j = i810_readb(SR_DATA) & 0xE0;
+	i810_writeb(SR_INDEX, SR01);
+	i810_writeb(SR_DATA, i | j);
+}
+
+/**
+ * i810fb_restore_vga - restores saved standard VGA registers
+ */
+static void i810fb_restore_vga(void)
+{
+	u32 indexport, dataport;
+	u8 i;
+	
+	if (is_cga()) {
+		dataport = CR_DATA_CGA;
+		indexport = CR_INDEX_CGA;
+	}
+	else {
+		dataport = CR_DATA_MDA;
+		indexport = CR_INDEX_MDA;
+	}
+	for (i = 0; i < 10; i++) {
+		i810_writeb(indexport, CR00 + i);
+		i810_writeb(dataport, *((&i810_info->hw_state.cr00) + i));
+	}
+	for (i = 0; i < 8; i++) {
+		i810_writeb(indexport, CR10 + i);
+		i810_writeb(dataport, *((&i810_info->hw_state.cr10) + i));
+	}
+}
+
+/**
+ * i810fb_restore_addr_map - restores saved address registers
+ */
+static void i810fb_restore_addr_map(void)
+{
+	u8 tmp;
+	i810_writeb(GR_INDEX, GR10);
+	tmp = i810_readb(GR_DATA);
+	tmp &= ADDR_MAP_MASK;
+	tmp |= i810_info->hw_state.gr10;
+	i810_writeb(GR_INDEX, GR10);
+	i810_writeb(GR_DATA, tmp);
+}
+
+/**
+ * i810fb_restore_2D - restores saved graphics registers
+ */
+static void i810fb_restore_2d(void)
+{
+	u32 tmp_long;
+	u16 tmp_word;
+
+	tmp_word = i810_readw(BLTCNTL);
+	tmp_word &= ~(3 << 4); 
+	tmp_word |= i810_info->hw_state.bltcntl;
+	i810_writew(BLTCNTL, tmp_word);
+       
+	i810_wait_for_hsync(); 
+	i810fb_dram_off(OFF);
+	i810_writel(PIXCONF, i810_info->hw_state.pixconf);
+	i810fb_dram_off(ON);
+
+	tmp_word = i810_readw(HWSTAM);
+	tmp_word &= 3 << 13;
+	tmp_word |= i810_info->hw_state.hwstam;
+	i810_writew(HWSTAM, tmp_word);
+
+	tmp_long = i810_readl(FW_BLC);
+	tmp_long &= FW_BLC_MASK;
+	tmp_long |= i810_info->hw_state.fw_blc;
+	i810_writel(FW_BLC, tmp_long);
+
+	i810_writel(HWS_PGA, i810_info->hw_state.hws_pga); 
+	if (render)
+		i810_writel(FENCE, i810_info->hw_state.fence0);
+}
+	
+/**
+ * i810fb_save_2d - save graphics register states
+ */
+static void i810fb_save_2d(void)
+{
+	i810_info->hw_state.iring_state.head = i810_readl(IRING);
+	i810_info->hw_state.iring_state.tail = i810_readl(IRING + 4);
+	i810_info->hw_state.iring_state.start = i810_readl(IRING + 8);
+	i810_info->hw_state.iring_state.size = i810_readl(IRING + 12);
+	i810_info->hw_state.dclk_2d = i810_readl(DCLK_2D);
+	i810_info->hw_state.dclk_1d = i810_readl(DCLK_1D);
+	i810_info->hw_state.dclk_0ds = i810_readl(DCLK_0DS);
+	i810_info->hw_state.pixconf = i810_readl(PIXCONF);
+	i810_info->hw_state.fw_blc = i810_readl(FW_BLC);
+	i810_info->hw_state.bltcntl = i810_readw(BLTCNTL);
+	i810_info->hw_state.hwstam = i810_readw(HWSTAM); 
+	i810_info->hw_state.hws_pga = i810_readl(HWS_PGA); 
+	if (render)
+		i810_info->hw_state.fence0 = i810_readl(FENCE);
+}
+	     
+
+/**
+ * i810fb_save_regs - saves the register state
+ * 
+ * DESCRIPTION:
+ * Saves the ALL the registers' state
+ */
+
+static void i810fb_save_regs(void)
+{
+	i810fb_save_vga();
+	i810fb_save_vgax();
+	i810fb_save_2d();
+}
+
+	
+/**
+ * i810b_init_device - initialize device
+ */
+static void __devinit i810fb_init_device(void)
+{
+	i810fb_save_regs();
+	if (hwcur) { 
+		i810fb_init_cursor();
+		add_timer(i810_info->cursor.timer);
+	}
+	/* mvo: enable external vga-connector (for laptops) */
+	if(ext_vga) {
+		i810_writel(HVSYNC, 0);
+		i810_writel(PWR_CLKC, 3);
+	}
+  	i810fb_get_mem_freq();
+}
+
+/**
+ * i810fb_restore_regs - loads the saved register state
+ * 
+ * DESCRIPTION:
+ * Restores ALL of the registers' save state
+ */
+static void i810fb_restore_regs(void)
+{
+	i810fb_screen_off(OFF);
+	i810fb_protect_regs(OFF);
+	i810fb_dram_off(OFF);
+	i810fb_restore_pll();
+	i810fb_restore_dac();
+	i810fb_restore_vga();
+	i810fb_restore_vgax();
+	i810fb_restore_addr_map();
+	i810fb_dram_off(ON);
+	i810fb_restore_2d();
+	i810fb_restore_ringbuffer(&i810_info->hw_state.iring_state); 
+	i810fb_screen_off(ON);
+	i810fb_protect_regs(ON);
+}
+
+static int __devinit i810fb_alloc_fbmem(void)
+{
+
+
+	/* align surface for memory tiling*/
+	if (render) {
+		int i = 0;
+		render = vram << 10;
+		while (i < arraysize(i810_fence) &&
+		       render > i810_fence[i]) 
+			i++; 
+		if (i >= arraysize(i810_fence))
+			i--;
+		i810_info->i810_gtt.fence_size = i;
+		render = i810_fence[i];
+		i810_info->fb_size = render << 10;
+		if (i810_info->fb_size >= 16 << 20)
+			i810_info->fb_offset = i810_info->aper_size - 
+				i810_info->fb_size - 4096;
+		else
+			i810_info->fb_offset = i810_info->aper_size -
+				(16 << 20) - 4096;
+		i810_info->fb_offset &= ~(((512 << i) * 1024) - 1);
+	}
+	else {	
+		i810_info->fb_size = vram << 20;
+		if (vram >= 16)
+			i810_info->fb_offset = i810_info->aper_size - 
+				i810_info->fb_size - 4096;
+		else
+			i810_info->fb_offset = i810_info->aper_size -
+				(16 << 20) - 4096;
+		i810_info->fb_offset &= ~((16 << 20) - 1); 
+	}
+	i810_info->fb_offset >>= 12;
+
+	if (!(i810_info->i810_gtt.i810_fb_memory = 
+	      agp_allocate_memory(i810_info->fb_size >> 12, 
+				  AGP_NORMAL_MEMORY))) {
+		printk("i810fb_alloc_fbmem: can't allocate framebuffer memory\n");
+		return -ENOMEM;
+	}
+	if (agp_bind_memory(i810_info->i810_gtt.i810_fb_memory, 
+			    i810_info->fb_offset)) {
+		printk("i810fb_alloc_fbmem: can't bind framebuffer memory\n");
+		return -EBUSY;
+	}	
+	return 0;
+}	
+
+
+static int __devinit i810fb_alloc_cursormem(u32 iring_offset)
+{
+	if (iring_offset < CURSOR_SIZE >> 12)
+		i810_info->cursor_offset = ((i810_info->aper_size - CURSOR_SIZE) >> 12) - 1;
+	else
+		i810_info->cursor_offset = iring_offset - 
+			(CURSOR_SIZE >> 12);
+	if (!(i810_info->i810_gtt.i810_cursor_memory = 
+	      agp_allocate_memory(CURSOR_SIZE >> 12, AGP_PHYSICAL_MEMORY))) {
+		printk("i810fb_alloc_cursormem:  can't allocate" 
+		       "cursor memory\n");
+		return -ENOMEM;
+	}
+	if (agp_bind_memory(i810_info->i810_gtt.i810_cursor_memory, 
+			    i810_info->cursor_offset)) {
+		printk("i810fb_alloc_cursormem: cannot bind cursor memory bound\n");
+		return -EBUSY;
+	}	
+	return 0;
+}
+
+
+static int __devinit i810fb_init_agp(void)
+{
+	int err;
+	u32 iring_offset;
+	u32 sarea_offset;
+
+	if ((err = agp_backend_acquire())) {
+		printk("i810fb_init_agp: agpgart is busy\n");
+		return err;
+	}	
+	if ((err = i810fb_alloc_fbmem())) return err;
+	if (!(iring_offset = i810fb_init_accel(i810_info->fb_offset, 
+					       i810_info->aper_size,
+					       sync                 )))
+		return -ENOMEM;
+	if (hwcur) {
+		if ((err = i810fb_alloc_cursormem(iring_offset))) return err;
+		sarea_offset = i810_info->cursor_offset - (SAREA_SIZE >> 12);
+	}	
+	else
+		sarea_offset = iring_offset - (SAREA_SIZE >> 12);
+
+	/* any failures are not critical */
+	if ((i810fb_init_iface(sarea_offset))) return 0;
+	return 0;
+}
+
+static int __devinit i810fb_fix_pointers(void)
+{
+      	i810_info->fb_start_phys = i810_info->fb_base_phys + 
+		(i810_info->fb_offset << 12);
+	i810_info->fb_start_virtual = i810_info->fb_base_virtual + 
+		(i810_info->fb_offset << 12);
+	i810fb_fix_accel_pointer(i810_info->fb_base_phys, i810_info->fb_base_virtual);
+	if (hwcur) {
+		i810_info->cursor_start_phys = 
+			i810_info->i810_gtt.i810_cursor_memory->physical;
+		i810_info->cursor_start_virtual = 
+			i810_info->fb_base_virtual + 
+			(i810_info->cursor_offset << 12);
+		if (!i810fb_create_cursor()) {
+			i810fb_release_resource();
+			return -ENOMEM;
+		}
+	}		
+	i810fb_fix_iface_pointers(i810_info->fb_size, i810_info->aper_size, 
+				  i810_info->fb_base_phys, i810_info->fb_base_virtual);
+	return 0;
+}
+
+    /*
+     *  Initialisation
+     */
+
+static int __devinit i810fb_init_pci (struct pci_dev *dev, 
+				      const struct pci_device_id *entry)
+{
+	struct resource *res;
+	int err;
+
+	if (!i810fb_initialized)
+		return -EINVAL;
+	if(!(i810_info = kmalloc(sizeof(struct i810_fbinfo), GFP_KERNEL)))
+		return -ENOMEM;
+	memset(i810_info, 0, sizeof(struct i810_fbinfo));
+	if(!(i810_orient = kmalloc(sizeof(struct orientation), GFP_KERNEL)))
+		return -ENOMEM;
+	memset(i810_orient, 0, sizeof(struct orientation));
+	if(!(i810_timings = kmalloc(sizeof(struct video_timings), GFP_KERNEL)))
+		return -ENOMEM;
+	memset(i810_timings, 0, sizeof(struct video_timings));
+	if ((err = pci_enable_device(dev))) { 
+		printk("i810fb_init: cannot enable device\n");
+		return err;		
+	}
+	if ((err = load_agpgart())) {
+		printk("i810fb_init: cannot initialize agpgart\n");
+		return err;
+	}
+
+	agp_copy_info(&i810_info->i810_gtt.i810_gtt_info);
+	if (!(i810_info->i810_gtt.i810_gtt_info.aper_size)) {
+		printk("i810fb_init: device is disabled\n");
+		return -ENOMEM;
+	}
+	res = &dev->resource[0];
+	i810_info->fb_base_phys = i810_info->i810_gtt.i810_gtt_info.aper_base;
+	i810_info->aper_size = 
+		(i810_info->i810_gtt.i810_gtt_info.aper_size) << 20;
+
+	if (!request_mem_region(i810_info->fb_base_phys, 
+				i810_info->aper_size, 
+				i810_pci_list[entry->driver_data])) {
+		printk("i810fb_init: cannot request framebuffer region\n");
+		kfree(i810_info);
+		return -ENODEV;
+	}
+	res = &dev->resource[1];
+	i810_info->mmio_start_phys = res->start;
+	if (!request_mem_region(i810_info->mmio_start_phys, 
+				MMIO_SIZE, 
+				i810_pci_list[entry->driver_data])) {
+		printk("i810fb_init: cannot request mmio region\n");
+		release_mem_region(i810_info->fb_base_phys, i810_info->aper_size);
+		kfree(i810_info);
+		return -ENODEV;
+	}
+
+	if ((err = i810fb_init_agp())) {
+		i810fb_release_resource();
+		return err;
+	}
+	i810_info->fb_base_virtual = 
+		(u32) ioremap_nocache(i810_info->fb_base_phys, 
+				      i810_info->aper_size);
+        i810_info->mmio_start_virtual = 
+		(u32) ioremap_nocache(i810_info->mmio_start_phys, MMIO_SIZE);
+
+	if ((err = i810fb_fix_pointers())) {
+		printk("i810fb_init: cannot fix pointers, no memory\n");
+		return err;
+	}
+	
+	if (mtrr) set_mtrr();
+	i810fb_init_device();        
+	i810fb_init_defaults();
+	strcpy(i810_info->fb_info.modename, i810fb_name);
+	strcpy(i810_info->fb_info.fontname, fontname);
+	i810_info->fb_info.changevar = NULL;
+	i810_info->fb_info.node = -1;
+	i810_info->fb_info.fbops = &i810fb_ops;
+	i810_info->fb_info.disp = &i810_info->disp;
+	i810_info->fb_info.switch_con = &i810fbcon_switch;
+	i810_info->fb_info.updatevar = &i810fbcon_updatevar;
+	i810_info->fb_info.blank = &i810fbcon_blank;
+	i810_info->fb_info.flags = FBINFO_FLAG_DEFAULT;
+
+	if((err = i810fb_set_var(&i810fb_default, -1, &i810_info->fb_info))) {
+		i810fb_release_resource();
+		printk("i810fb_init: cannot set display video mode\n");
+		return err;
+	}
+
+   	if((err = register_framebuffer(&i810_info->fb_info))) {
+    		i810fb_release_resource(); 
+		printk("i810fb_init: cannot register framebuffer device\n");
+    		return err;  
+    	}   
+	i810fb_initialized = 0;
+      	printk("fb%d: %s v%d.%d.%d%s, Tony Daplas\n"
+      	       "     Video RAM      : %dK\n" 
+	       "     Mode           : %dx%d-%dbpp\n"
+	       "     Acceleration   : %sabled\n"
+	       "     MTRR           : %sabled\n"
+	       "     External VGA   : %sabled\n"
+	       "     Hardware cursor: %sabled\n" 
+	       "     Video Timings  : %s\n"	
+	       "     Rotation Code  : %sbuilt\n" 
+	       "     Interface      : %sabled\n"
+	       "     Memory Tiling  : %sabled\n",
+	       GET_FB_IDX(i810_info->fb_info.node), 
+	       i810_pci_list[entry->driver_data],
+	       VERSION_MAJOR, VERSION_MINOR, VERSION_TEENIE, BRANCH_VERSION,
+	       (int) i810_info->fb_size>>10, i810fb_default.xres, 
+	       i810fb_default.yres, i810fb_default.bits_per_pixel,
+	       (accel) ? "en" : "dis", 
+	       (i810_info->mtrr_is_set) ? "en" : "dis", 
+	       (ext_vga) ? "en" : "dis", (hwcur) ? "en" : "dis",
+	       (is_std()) ? "Intel" : "VESA GTF (US)", (has_rotate()) ? "" : "not ",
+               (has_iface()) ? "en" : "dis", 
+	       (render) ? "en" : "dis");
+	
+	return 0;
+}
+
+static void i810fb_release_resource(void)
+{
+
+	unset_mtrr();
+	i810fb_iface_cleanup();
+	if (hwcur) {
+		if (i810_info->cursor.timer) {
+			del_timer(i810_info->cursor.timer);
+			kfree(i810_info->cursor.timer);
+		}
+		if (i810_info->i810_gtt.i810_cursor_memory) 
+			agp_free_memory(i810_info->i810_gtt.i810_cursor_memory);
+	}	
+	if (i810_info->i810_gtt.i810_fb_memory) 
+		agp_free_memory(i810_info->i810_gtt.i810_fb_memory);
+	i810fb_accel_cleanup();
+	agp_backend_release();
+	if (i810_info->mmio_start_virtual) 
+		iounmap((void *) i810_info->mmio_start_virtual);
+	if (i810_info->fb_base_virtual) 
+		iounmap((void *) i810_info->fb_base_virtual);
+	release_mem_region(i810_info->fb_base_phys, i810_info->aper_size);
+	release_mem_region(i810_info->mmio_start_phys, MMIO_SIZE);
+	pci_disable_device(i810_info->i810_gtt.i810_gtt_info.device); 
+	if (i810_orient)
+		kfree(i810_orient);
+	if (i810_timings)
+		kfree(i810_timings);
+	if (i810_info) 
+		kfree(i810_info);
+}
+
+static void __devexit i810fb_remove_pci(struct pci_dev *dev)
+{
+	i810fb_restore_regs();
+	unregister_framebuffer(&i810_info->fb_info);  
+	i810fb_release_resource();
+	printk("cleanup_module:  unloaded i810 framebuffer device\n");
+}                                                	
+
+
+/* Modularization */
+
+int __init i810fb_init(void)
+{
+	int err;
+
+	i810fb_initialized = 1;
+	if ((err = pci_module_init(&i810fb_driver)))
+		return err;
+#ifdef MODULE
+	i810fb_set_var(&i810fb_default, -1, &i810_info->fb_info);
+#endif
+	return 0;
+}
+
+#ifdef MODULE
+
+MODULE_PARM(vram, "i");
+MODULE_PARM_DESC(vram, "System RAM to allocate to framebuffer in MiB" 
+		 " (default=4)");
+MODULE_PARM(bpp, "i");
+MODULE_PARM_DESC(bpp, "Color depth for display in bits per pixel"
+		 " (default = 8)");
+MODULE_PARM(xres, "i");
+MODULE_PARM_DESC(xres, "Hozizontal resolution in pixels (default = 640)");
+MODULE_PARM(yres, "i");
+MODULE_PARM_DESC(yres, "Vertical resolution in scanlines (default = 480)");
+MODULE_PARM(vyres, "i");
+MODULE_PARM_DESC(vyres, "Virtual vertical resolution in scanlines"
+		 " (default = 480)");
+MODULE_PARM(hsync1, "i");
+MODULE_PARM_DESC(hsync1, "Mimimum horizontal frequency of monitor in KHz"
+		 " (default = 31)");
+MODULE_PARM(hsync2, "i");
+MODULE_PARM_DESC(hsync2, "Maximum horizontal frequency of monitor in KHz"
+		 " (default = 31)");
+MODULE_PARM(vsync1, "i");
+MODULE_PARM_DESC(vsync1, "Minimum vertical frequency of monitor in Hz"
+		 " (default = 50)");
+MODULE_PARM(vsync2, "i");
+MODULE_PARM_DESC(vsync2, "Maximum vertical frequency of monitor in Hz" 
+		 " (default = 60)");
+MODULE_PARM(accel, "i");
+MODULE_PARM_DESC(accel, "Use Acceleration (BLIT) engine (default = 0)");
+MODULE_PARM(mtrr, "i");
+MODULE_PARM_DESC(mtrr, "Use MTRR (default = 0)");
+MODULE_PARM(ext_vga, "i");
+MODULE_PARM_DESC(ext_vga, "Enable external VGA connector (default = 0)");
+MODULE_PARM(hwcur, "i");
+MODULE_PARM_DESC(hwcur, "use hardware cursor (default = 0)");
+MODULE_PARM(render, "i");
+MODULE_PARM_DESC(render, "if true, use Memory tiling and alignment"
+		 " (default = not set)");
+MODULE_PARM(sync_on_pan, "i");
+MODULE_PARM_DESC(sync_on_pan, "wait for vsync before panning the display"
+		 " (default = 0)");
+MODULE_PARM(sync, "i");
+MODULE_PARM_DESC(sync, "wait for accel engine to finish drawing"
+		 " (default = 0)");
+MODULE_PARM(rotate, "i");
+MODULE_PARM_DESC(rotate, "rotate display: 0 - normal; 1 - rotate right; 2 - "
+		 "upside down; 3 - rotate left (default = 0)");
+
+
+MODULE_AUTHOR("Tony A. Daplas");
+MODULE_DESCRIPTION("Framebuffer device for the Intel 810/815 and"
+		   " compatible cards");
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,9)
+MODULE_LICENSE("GPL"); 
+#endif
+
+static void __exit i810fb_exit(void)
+{
+	pci_unregister_driver(&i810fb_driver);
+}
+module_init(i810fb_init);
+module_exit(i810fb_exit);
+
+#endif
+
--- linux-2.4.22/drivers/video/i810/i810_main.h.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_main.h	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,1104 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_main.h -- Intel 810 frame buffer device header file
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#ifndef __I810_MAIN_H__
+#define __I810_MAIN_H__
+
+#ifdef CONFIG_FB_I810_GTF
+/*
+ * FIFO and Watermark tables - based almost wholly on i810_wmark.c in XFree86 v4.03 by
+ * Precision Insight.  Slightly modified for integer operation, instead of float
+ */
+
+struct wm_info {
+   u32 freq;
+   u32  wm;
+};
+
+struct wm_info i810_wm_8_100[] = {
+	{ 25, 0x22003000 },
+	{ 28, 0x22003000 },
+	{ 31, 0x22003000 },
+	{ 36, 0x22007000 },
+	{ 40, 0x22007000 },
+	{ 45, 0x22007000 },
+	{ 49, 0x22008000 },
+	{ 50, 0x22008000 },
+	{ 56, 0x22008000 },
+	{ 65, 0x22008000 },
+	{ 75, 0x22008000 },
+	{ 78, 0x22008000 },
+	{ 80, 0x22008000 },
+	{ 94, 0x22008000 },
+	{ 96, 0x22107000 },
+	{ 99, 0x22107000 },
+	{ 108, 0x22107000 },
+	{ 121, 0x22107000 },
+	{ 128, 0x22107000 },
+	{ 132, 0x22109000 },
+	{ 135, 0x22109000 },
+	{ 157, 0x2210b000 },
+	{ 162, 0x2210b000 },
+	{ 175, 0x2210b000 },
+	{ 189, 0x2220e000 },
+	{ 202, 0x2220e000 },
+};
+
+struct wm_info i810_wm_16_100[] = {
+	{ 25, 0x22006000 },
+	{ 28, 0x22006000 },
+	{ 31, 0x22007000 },
+	{ 36, 0x22007000 },
+	{ 40, 0x22007000 },
+	{ 45, 0x22007000 },
+	{ 49, 0x22009000 },
+	{ 50, 0x22009000 },
+	{ 56, 0x22108000 },
+	{ 65, 0x2210e000 },
+	{ 75, 0x2210e000 },
+	{ 78, 0x2210e000 },
+	{ 80, 0x22210000 },
+	{ 94, 0x22210000 },
+	{ 96, 0x22210000 },
+	{ 99, 0x22210000 },
+	{ 108, 0x22210000 },
+	{ 121, 0x22210000 },
+	{ 128, 0x22210000 },
+	{ 132, 0x22314000 },
+	{ 135, 0x22314000 },
+	{ 157, 0x22415000 },
+	{ 162, 0x22416000 },
+	{ 175, 0x22416000 },
+	{ 189, 0x22416000 },
+	{ 195, 0x22416000 },
+	{ 202, 0x22416000 },
+};
+
+
+struct wm_info i810_wm_24_100[] = {
+	{ 25, 0x22009000 },
+	{ 28, 0x22009000 },
+	{ 31, 0x2200a000 },
+	{ 36, 0x2210c000 },
+	{ 40, 0x2210c000 },
+	{ 45, 0x2210c000 },
+	{ 49, 0x22111000 },
+	{ 50, 0x22111000 },
+	{ 56, 0x22111000 },
+	{ 65, 0x22214000 },
+	{ 75, 0x22214000 },
+	{ 78, 0x22215000 },
+	{ 80, 0x22216000 },
+	{ 94, 0x22218000 },
+	{ 96, 0x22418000 },
+	{ 99, 0x22418000 },
+	{ 108, 0x22418000 },
+	{ 121, 0x22418000 },
+	{ 128, 0x22419000 },
+	{ 132, 0x22519000 },
+	{ 135, 0x4441d000 },
+	{ 157, 0x44419000 },
+	{ 162, 0x44419000 },
+	{ 175, 0x44419000 },
+	{ 189, 0x44419000 },
+	{ 195, 0x44419000 },
+	{ 202, 0x44419000 },
+};
+
+
+
+struct wm_info i810_wm_8_133[] = {
+	{ 25, 0x22003000 },
+	{ 28, 0x22003000 },
+	{ 31, 0x22003000 },
+	{ 36, 0x22007000 },
+	{ 40, 0x22007000 },
+	{ 45, 0x22007000 },
+	{ 49, 0x22008000 },
+	{ 50, 0x22008000 },
+	{ 56, 0x22008000 },
+	{ 65, 0x22008000 },
+	{ 75, 0x22008000 },
+	{ 78, 0x22008000 },
+	{ 80, 0x22008000 },
+	{ 94, 0x22008000 },
+	{ 96, 0x22107000 },
+	{ 99, 0x22107000 },
+	{ 108, 0x22107000 },
+	{ 121, 0x22107000 },
+	{ 128, 0x22107000 },
+	{ 132, 0x22109000 },
+	{ 135, 0x22109000 },
+	{ 157, 0x2210b000 },
+	{ 162, 0x2210b000 },
+	{ 175, 0x2210b000 },
+	{ 189, 0x2220e000 },
+	{ 202, 0x2220e000 },
+};
+
+
+struct wm_info i810_wm_16_133[] = {
+	{ 25, 0x22006000 },
+	{ 28, 0x22006000 },
+	{ 31, 0x22007000 },
+	{ 36, 0x22007000 },
+	{ 40, 0x22007000 },
+	{ 45, 0x22007000 },
+	{ 49, 0x22009000 },
+	{ 50, 0x22009000 },
+	{ 56, 0x22108000 },
+	{ 65, 0x2210e000 },
+	{ 75, 0x2210e000 },
+	{ 78, 0x2210e000 },
+	{ 80, 0x22210000 },
+	{ 94, 0x22210000 },
+	{ 96, 0x22210000 },
+	{ 99, 0x22210000 },
+	{ 108, 0x22210000 },
+	{ 121, 0x22210000 },
+	{ 128, 0x22210000 },
+	{ 132, 0x22314000 },
+	{ 135, 0x22314000 },
+	{ 157, 0x22415000 },
+	{ 162, 0x22416000 },
+	{ 175, 0x22416000 },
+	{ 189, 0x22416000 },
+	{ 195, 0x22416000 },
+	{ 202, 0x22416000 },
+};
+
+struct wm_info i810_wm_24_133[] = {
+	{ 25, 0x22009000 },
+	{ 28, 0x22009000 },
+	{ 31, 0x2200a000 },
+	{ 36, 0x2210c000 },
+	{ 40, 0x2210c000 },
+	{ 45, 0x2210c000 },
+	{ 49, 0x22111000 },
+	{ 50, 0x22111000 },
+	{ 56, 0x22111000 },
+	{ 65, 0x22214000 },
+	{ 75, 0x22214000 },
+	{ 78, 0x22215000 },
+	{ 80, 0x22216000 },
+	{ 94, 0x22218000 },
+	{ 96, 0x22418000 },
+	{ 99, 0x22418000 },
+	{ 108, 0x22418000 },
+	{ 121, 0x22418000 },
+	{ 128, 0x22419000 },
+	{ 132, 0x22519000 },
+	{ 135, 0x4441d000 },
+	{ 157, 0x44419000 },
+	{ 162, 0x44419000 },
+	{ 175, 0x44419000 },
+	{ 189, 0x44419000 },
+	{ 195, 0x44419000 },
+	{ 202, 0x44419000 },
+};
+
+#else
+struct mode_registers std_modes[] = {
+	/* 640x480 @ 60Hz */
+	{ 25000, 0x0013, 0x0003, 0x40, 0x5F, 0x4F, 0x50, 0x82, 0x51, 0x9D,
+	  0x0B, 0x10, 0x40, 0xE9, 0x0B, 0xDF, 0x50, 0xE7, 0x04, 0x02,
+	  0x01, 0x01, 0x01, 0x00, 0x01, 0x22002000, 0x22004000, 0x22006000,
+	  0x22002000, 0x22004000, 0x22006000, 0xC0 }, 
+	  
+	/* 640x480 @ 70Hz */
+	{ 28000, 0x0053, 0x0010, 0x40, 0x61, 0x4F, 0x4F, 0x85, 0x52, 0x9A,
+	  0xF2, 0x10, 0x40, 0xE0, 0x03, 0xDF, 0x50, 0xDF, 0xF3, 0x01, 
+	  0x01, 0x01, 0x01, 0x00, 0x01, 0x22002000, 0x22004000, 0x22005000,
+          0x22002000, 0x22004000, 0x22005000, 0xC0 },
+          
+        /* 640x480 @ 72Hz */
+        { 31000, 0x0013, 0x0002, 0x40, 0x63, 0x4F, 0x4F, 0x87, 0x52, 0x97,
+          0x06, 0x0F, 0x40, 0xE8, 0x0B, 0xDF, 0x50, 0xDF, 0x07, 0x02, 
+          0x01, 0x01, 0x01, 0x00, 0x01, 0x22003000, 0x22005000, 0x22007000,
+          0x22003000, 0x22005000, 0x22007000, 0xC0 },
+          
+        /* 640x480 @ 75Hz */
+        { 31000, 0x0013, 0x0002, 0x40, 0x64, 0x4F, 0x4F, 0x88, 0x51, 0x99, 
+          0xF2, 0x10, 0x40, 0xE0, 0x03, 0xDF, 0x50, 0xDF, 0xF3, 0x01, 
+          0x01, 0x01, 0x01, 0x00, 0x01, 0x22003000, 0x22005000, 0x22007000, 
+          0x22003000, 0x22005000, 0x22007000, 0xC0 },
+          
+        /* 640x480 @ 85Hz */
+        { 36000, 0x0010, 0x0001, 0x40, 0x63, 0x4F, 0x4F, 0x87, 0x56, 0x9D,
+          0xFB, 0x10, 0x40, 0xE0, 0x03, 0xDF, 0x50, 0xDF, 0xFC, 0x01,
+          0x01, 0x01, 0x01, 0x00, 0x01, 0x22003000, 0x22005000, 0x22107000,
+          0x22003000, 0x22005000, 0x22107000, 0xC0 },
+          
+        /* 800x600 @ 56Hz */
+        { 36000, 0x0010, 0x0001, 0x40, 0x7B, 0x63, 0x63, 0x9F, 0x66, 0x8F,
+          0x6F, 0x10, 0x40, 0x58, 0x0A, 0x57, 0xC8, 0x57, 0x70, 0x02, 
+          0x02, 0x02, 0x02, 0x00, 0x01, 0x22003000, 0x22005000, 0x22107000,
+          0x22003000, 0x22005000, 0x22107000, 0x00 },
+          
+        /* 800x600 @ 60Hz */
+        { 40000, 0x0008, 0x0001, 0x30, 0x7F, 0x63, 0x63, 0x83, 0x68, 0x18, 
+          0x72, 0x10, 0x40, 0x58, 0x0C, 0x57, 0xC8, 0x57, 0x73, 0x02,
+          0x02, 0x02, 0x02, 0x00, 0x00, 0x22003000, 0x22006000, 0x22108000,
+          0x22003000, 0x22006000, 0x22108000, 0x00 },
+          
+        /* 800x600 @ 70Hz */
+        { 45000, 0x0054, 0x0015, 0x30, 0x7D, 0x63, 0x63, 0x81, 0x68, 0x12,
+          0x6f, 0x10, 0x40, 0x58, 0x0b, 0x57, 0x64, 0x57, 0x70, 0x02, 
+          0x02, 0x02, 0x02, 0x00, 0x00, 0x22004000, 0x22007000, 0x2210A000, 
+          0x22004000, 0x22007000, 0x2210A000, 0x00 },
+          
+        /* 800x600 @ 72Hz */
+        { 50000, 0x0017, 0x0004, 0x30, 0x7D, 0x63, 0x63, 0x81, 0x6A, 0x19,
+          0x98, 0x10, 0x40, 0x7C, 0x02, 0x57, 0xC8, 0x57, 0x99, 0x02, 
+          0x02, 0x02, 0x02, 0x00, 0x00, 0x22004000, 0x22007000, 0x2210A000,
+          0x22004000, 0x22007000, 0x2210A000, 0x00 }, 
+          
+        /* 800x600 @ 75Hz */
+        { 49000, 0x001F, 0x0006, 0x30, 0x7F, 0x63, 0x63, 0x83, 0x65, 0x0F,
+          0x6F, 0x10, 0x40, 0x58, 0x0B, 0x57, 0xC8, 0x57, 0x70, 0x02, 
+          0x02, 0x02, 0x02, 0x00, 0x00, 0x22004000, 0x22007000, 0x2210B000,
+          0x22004000, 0x22007000, 0x2210B000, 0x00 },
+          
+        /* 800x600 @ 85Hz */
+        { 56000, 0x0049, 0x000E, 0x30, 0x7E, 0x63, 0x63, 0x82, 0x67, 0x0F,
+          0x75, 0x10, 0x40, 0x58, 0x0B, 0x57, 0xC8, 0x57, 0x76, 0x02,
+          0x02, 0x02, 0x02, 0x00, 0x00, 0x22004000, 0x22108000, 0x2210b000, 
+          0x22004000, 0x22108000, 0x2210b000, 0x00 },
+          
+        /* 1024x768 @ 60Hz */
+        { 65000, 0x003F, 0x000A, 0x30, 0xA3, 0x7F, 0x7F, 0x87, 0x83, 0x94,
+          0x24, 0x10, 0x40, 0x02, 0x08, 0xFF, 0x80, 0xFF, 0x25, 0x03,
+          0x02, 0x03, 0x02, 0x00, 0x00, 0x22005000, 0x22109000, 0x2220D000,
+          0x22005000, 0x22109000, 0x2220D000, 0xC0 },
+          
+        /* 1024x768 @ 70Hz */
+	{ 75000, 0x0017, 0x0002, 0x30, 0xA1, 0x7F, 0x7F, 0x85, 0x82, 0x93,
+	  0x24, 0x10, 0x40, 0x02, 0x08, 0xFF, 0x80, 0xFF, 0x25, 0x03,
+	  0x02, 0x03, 0x02, 0x00, 0x00, 0x22005000, 0x2210A000, 0x2220F000,
+	  0x22005000, 0x2210A000, 0x2220F000, 0xC0 }, 
+	  
+	/* 1024x768 @ 75Hz */          
+	{ 78000, 0x0050, 0x0017, 0x20, 0x9F, 0x7F, 0x7F, 0x83, 0x81, 0x8D,
+	  0x1E, 0x10, 0x40, 0x00, 0x03, 0xFF, 0x80, 0xFF, 0x1F, 0x03,
+	  0x02, 0x03, 0x02, 0x00, 0x00, 0x22006000, 0x2210B000, 0x22210000,
+	  0x22006000, 0x2210B000, 0x22210000, 0x00 },
+	  
+	/* 1024x768 @ 85Hz */
+	{ 94000, 0x003D, 0x000E, 0x20, 0xA7, 0x7F, 0x7F, 0x8B, 0x85, 0x91,
+	  0x26, 0x10, 0x40, 0x00, 0x03, 0xFF, 0x80, 0xFF, 0x27, 0x03,
+	  0x02, 0x03, 0x02, 0x00, 0x00, 0x22007000, 0x2220E000, 0x22212000,
+	  0x22007000, 0x2220E000, 0x22212000, 0x00 },
+	  
+	/* 1152x864 @ 60Hz */ 
+	{ 80000, 0x0008, 0x0001, 0x20, 0xB3, 0x8F, 0x8F, 0x97, 0x93, 0x9f,
+	  0x87, 0x10, 0x40, 0x60, 0x03, 0x5F, 0x90, 0x5f, 0x88, 0x03,
+	  0x03, 0x03, 0x03, 0x00, 0x00, 0x2220C000, 0x22210000, 0x22415000,   
+	  0x2220C000, 0x22210000, 0x22415000, 0x00 },
+	  
+	/* 1152x864 @ 70Hz */
+	{ 96000, 0x000a, 0x0001, 0x20, 0xbb, 0x8F, 0x8F, 0x9f, 0x98, 0x87, 
+	  0x82, 0x10, 0x40, 0x60, 0x03, 0x5F, 0x90, 0x5F, 0x83, 0x03,
+	  0x03, 0x03, 0x03, 0x00, 0x00, 0x22107000, 0x22210000, 0x22415000,
+	  0x22107000, 0x22210000, 0x22415000, 0x00 },
+	  
+	/* 1152x864 @ 72Hz */
+	{ 99000, 0x001f, 0x0006, 0x20, 0xbb, 0x8F, 0x8F, 0x9f, 0x98, 0x87,
+	  0x83, 0x10, 0x40, 0x60, 0x03, 0x5F, 0x90, 0x5F, 0x84, 0x03,
+	  0x03, 0x03, 0x03, 0x00, 0x00, 0x22107000, 0x22210000, 0x22415000,
+	  0x22107000, 0x22210000, 0x22415000, 0x00 },
+	  
+	/* 1152x864 @ 75Hz */
+	{ 108000, 0x0010, 0x0002, 0x20, 0xC3, 0x8F, 0x8F, 0x87, 0x97, 0x07,
+	  0x82, 0x10, 0x40, 0x60, 0x03, 0x5F, 0x90, 0x5F, 0x83, 0x03, 
+	  0x03, 0x03, 0x03, 0x00, 0x01, 0x22107000, 0x22210000, 0x22415000,
+	  0x22107000, 0x22210000, 0x22415000, 0x00 },
+	  
+	/* 1152x864 @ 85Hz */
+	{ 121000, 0x006D, 0x0014, 0x20, 0xc0, 0x8F, 0x8F, 0x84, 0x97, 0x07,
+	  0x93, 0x10, 0x40, 0x60, 0x03, 0x5F, 0x90, 0x5F, 0x94, 0x03, 
+	  0x03, 0x03, 0x03, 0x00, 0x01, 0x2220C000, 0x22210000, 0x22415000,
+	  0x2220C000, 0x22210000, 0x22415000, 0x0 },
+	  
+	/* 1280x960 @ 60Hz */
+	{ 108000, 0x0010, 0x0002, 0x20, 0xDC, 0x9F, 0x9F, 0x80, 0xAB, 0x99,
+	  0xE6, 0x10, 0x40, 0xC0, 0x03, 0xBF, 0xA0, 0xBF, 0xE7, 0x03,
+	  0x03, 0x03, 0x03, 0x00, 0x01, 0x2210A000, 0x22210000, 0x22415000,
+	  0x2210A000, 0x22210000, 0x22415000, 0x00 },
+	  
+	/* 1280x960 @ 75Hz */
+	{ 129000, 0x0029, 0x0006, 0x20, 0xD3, 0x9F, 0x9F, 0x97, 0xaa, 0x1b,
+	  0xE8, 0x10, 0x40, 0xC0, 0x03, 0xBF, 0xA0, 0xBF, 0xE9, 0x03,
+	  0x03, 0x03, 0x03, 0x00, 0x01, 0x2210A000, 0x22210000, 0x2241B000,
+	  0x2210A000, 0x22210000, 0x2241B000, 0x00 },
+	  
+	/* 1280x960 @ 85Hz */
+	{ 148000, 0x0042, 0x0009, 0x20, 0xD3, 0x9F, 0x9F, 0x97, 0xA7, 0x1B,
+	  0xF1, 0x10, 0x40, 0xC0, 0x03, 0xBF, 0xA0, 0xBF, 0xF2, 0x03,
+	  0x03, 0x03, 0x03, 0x00, 0x01, 0x2210A000, 0x22220000, 0x2241D000,       
+	  0x2210A000, 0x22220000, 0x2241D000, 0x00 },
+	  
+	/* 1600x1200 @ 60Hz */
+	{ 162000, 0x0019, 0x0006, 0x10, 0x09, 0xC7, 0xC7, 0x8D, 0xcf, 0x07,
+	  0xE0, 0x10, 0x40, 0xB0, 0x03, 0xAF, 0xC8, 0xAF, 0xE1, 0x04, 
+	  0x04, 0x04, 0x04, 0x01, 0x00, 0x2210b000, 0x22416000, 0x44419000,
+	  0x2210b000, 0x22416000, 0x44419000, 0x00 },
+	  
+	/* 1600x1200 @ 65 Hz */
+	{ 175000, 0x005d, 0x0018, 0x10, 0x09, 0xC7, 0xC7, 0x8D, 0xcf, 0x07,
+	  0xE0, 0x10, 0x40, 0xB0, 0x03, 0xAF, 0xC8, 0xAF, 0xE1, 0x04, 
+	  0x04, 0x04, 0x04, 0x01, 0x00, 0x2210c000, 0x22416000, 0x44419000,     
+	  0x2210c000, 0x22416000, 0x44419000, 0x00 },
+	  
+	/* 1600x1200 @ 70 Hz */
+	{ 189000, 0x003D, 0x000e, 0x10, 0x09, 0xC7, 0xC7, 0x8d, 0xcf, 0x07,
+	  0xE0, 0x10, 0x40, 0xb0, 0x03, 0xAF, 0xC8, 0xaf, 0xE1, 0x04, 
+	  0x04, 0x04, 0x04, 0x01, 0x00, 0x2220e000, 0x22416000, 0x44419000,
+	  0x2220e000, 0x22416000, 0x44419000, 0x00 },
+	  
+ 	/* 1600x1200 @ 72 Hz */
+ 	{ 195000, 0x003f, 0x000e, 0x10, 0x0b, 0xC7, 0xC7, 0x8f, 0xd5, 0x0b,
+ 	  0xE1, 0x10, 0x40, 0xb0, 0x03, 0xAF, 0xC8, 0xaf, 0xe2, 0x04, 0x04,
+ 	  0x04, 0x04, 0x01, 0x00, 0x2220e000, 0x22416000, 0x44419000,
+ 	  0x2220e000, 0x22416000, 0x44419000, 0x00 }, 
+ 	  
+ 	/* 1600x1200 @ 75 Hz */
+ 	{ 202000, 0x0024, 0x0007, 0x10, 0x09, 0xC7, 0xC7, 0x8d, 0xcf, 0x07,
+ 	  0xE0, 0x10, 0x40, 0xb0, 0x03, 0xAF, 0xC8, 0xaf, 0xE1, 0x04, 0x04,
+ 	  0x04, 0x04, 0x01, 0x00, 0x2220e000, 0x22416000, 0x44419000,      
+ 	  0x2220e000, 0x22416000, 0x44419000,  0x00 },
+ 	  
+ 	/* 1600x1200 @ 85 Hz */
+	{ 229000, 0x0029, 0x0007, 0x10, 0x09, 0xC7, 0xC7, 0x8d, 0xcf, 0x07,
+	  0xE0, 0x10, 0x40, 0xb0, 0x03, 0xAF, 0xC8, 0xaf, 0xE1, 0x04, 0x04,
+	  0x04, 0x04, 0x01, 0x00, 0x22210000, 0x22416000, 0x0,
+	  0x22210000, 0x22416000, 0x0, 0x00 },
+};	 
+#endif /* CONFIG_FB_I810_GTF */	    
+
+/* Fence */
+static u32 i810_fence[] __devinitdata = {
+	512,
+	1024,
+	2048,
+	4096,
+	8192,
+	16384,
+	32768
+};
+
+/* PCI */
+static const char *i810_pci_list[] __devinitdata = {
+	"Intel 810 Framebuffer Device"                                 ,
+	"Intel 810-DC100 Framebuffer Device"                           ,
+	"Intel 810E Framebuffer Device"                                ,
+	"Intel 815 (Internal Graphics 100Mhz FSB) Framebuffer Device"  ,
+	"Intel 815 (Internal Graphics only) Framebuffer Device"        , 
+	"Intel 815 (Internal Graphics with AGP) Framebuffer Device"  
+};
+
+static struct pci_device_id i810_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810_IG1, 
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, 
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810_IG3,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1  },
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810_IG4,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2 },
+	/* mvo: added i815 PCI-ID */  
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_100,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3 },
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_NOAGP,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4 },
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_FULL,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5 }
+};	  
+	             
+static int __devinit i810fb_init_pci (struct pci_dev *dev, 
+				      const struct pci_device_id *entry);
+static void __devexit i810fb_remove_pci(struct pci_dev *dev);
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,17)
+static struct pci_driver i810fb_driver = {
+	name:		"i810fb",
+	id_table:	i810_pci_tbl,
+	probe:		i810fb_init_pci,
+	remove:		i810fb_remove_pci,
+};	
+#else 
+static struct pci_driver i810fb_driver = {
+	name:		"i810fb",
+	id_table:	i810_pci_tbl,
+	probe:		i810fb_init_pci,
+	remove:		__devexit_p(i810fb_remove_pci),
+};	
+#endif 
+ 
+struct i810_fbinfo   *i810_info;
+struct orientation   *i810_orient;
+struct video_timings *i810_timings;
+static u32            palette[16];
+static int i810fb_initialized = 0;
+static int currcon            = 0;
+static int hwcur              = 0;
+static int bpp                = 8;
+static int mtrr               = 0;
+static int accel              = 0;
+static int hsync1             = 0;
+static int hsync2             = 0;
+static int vsync1             = 0;
+static int vsync2             = 0;
+static int xres               = 640;
+static int yres               = 480;
+static int vyres              = 480;
+static int render             = 0;
+static int rotate             = NO_ROTATION;
+static int sync_on_pan        = 0;
+static int sync               = 0;
+
+/* "use once" vars */
+static char i810fb_name[16]  = "i810fb";
+static struct fb_var_screeninfo i810fb_default __devinitdata = {
+	/* 640x480, 8 bpp */
+	640, 480, 640, 480, 0, 0, 8, 0,
+	{0, 8, 0}, {0, 8, 0}, {0, 8, 0}, {0, 0, 0},
+	0, 0, -1, -1, 0, 20000, 64, 64, 32, 32, 64, 2,
+	0, FB_VMODE_NONINTERLACED
+};
+
+static char fontname[40]  __devinitdata = { 0 };
+static u32 vram __devinitdata = 4;
+static int ext_vga __devinitdata = 0;
+
+    /*
+     *  Interface used by the world
+     */
+int __init  i810fb_setup               (char *options);
+static int  i810fb_open                (struct fb_info *info, int user);
+static int  i810fb_release             (struct fb_info *info, int user);
+static int  i810fb_get_fix             (struct fb_fix_screeninfo *fix, int con,
+					struct fb_info *info);
+static int  i810fb_get_var             (struct fb_var_screeninfo *var, int con,
+					struct fb_info *info);
+static int  i810fb_set_var             (struct fb_var_screeninfo *var, int con,
+					struct fb_info *info);
+static int  i810fb_pan_display         (struct fb_var_screeninfo *var, int con,
+					struct fb_info *info);
+static int  i810fb_get_cmap            (struct fb_cmap *cmap, int kspc, int con,
+					struct fb_info *info);
+static int  i810fb_set_cmap            (struct fb_cmap *cmap, int kspc, int con,
+					struct fb_info *info);
+static int  i810fb_ioctl               (struct inode *inode, struct file *file, u_int cmd,
+					u_long arg, int con, struct fb_info *info);
+static int  i810fb_mmap                (struct fb_info *info, struct file *file, 
+					struct vm_area_struct *vma);
+
+    /*
+     *  Interface to the low level console driver
+     */
+int __init  i810fb_init                (void);
+static int  i810fbcon_switch           (int con, struct fb_info *info);
+static int  i810fbcon_updatevar        (int con, struct fb_info *info);
+static void i810fbcon_blank            (int blank, struct fb_info *info);
+
+    /*
+     *  Internal routines
+     */
+static void i810fb_encode_fix          (struct fb_fix_screeninfo *fix,
+					struct fb_var_screeninfo *var);
+static void set_color_bitfields        (struct fb_var_screeninfo *var);
+static int  i810fb_getcolreg           (u_int regno, u_int *red, u_int *green, u_int *blue,
+					u_int *transp, struct fb_info *info);
+static int  i810fb_setcolreg           (u_int regno, u_int red, u_int green, u_int blue,
+					u_int transp, struct fb_info *info);
+static void do_install_cmap            (int con, struct fb_info *info);
+static void i810fb_init_monspecs       (struct fb_info *fb_info);
+static void i810fb_load_regs           (struct display *disp);
+static void i810fb_restore_regs        (void);
+static void i810fb_save_regs           (void);
+static void i810fb_protect_regs        (int mode);
+static void i810fb_update_display      (struct display *disp, int con,
+					struct fb_info *info);
+static int  i810fb_get_timings         (struct fb_info *info, struct video_timings *timings,
+					int xres, int yres);
+static void i810fb_fill_vga_registers  (struct fb_info *info, struct display *disp);
+static void i810fb_release_resource    (void);
+static void i810fb_set_cursor          (struct display *disp);
+static void i810_calc_dclk             (struct mode_registers *params, u32 freq);
+static void i810fb_screen_off          (u8 mode);
+static void i810fb_init_cursor         (void);
+       void i810fb_enable_cursor       (int mode);
+       int  i810fb_reacquire_gart      (void);
+       u32 get_line_length             (int xres_virtual, int bpp);
+
+inline  u8  i810_readb                 (u32 where);
+inline u16  i810_readw                 (u32 where);
+inline u32  i810_readl                 (u32 where);
+inline void i810_writeb                (u32 where, u8 val);
+inline void i810_writew                (u32 where, u16 val);
+inline void i810_writel                (u32 where, u32 val);
+
+/* Console Drawing Functions */
+extern struct display_switch i810_noaccel8;
+extern struct display_switch i810_noaccel16;
+extern struct display_switch i810_noaccel24;
+extern struct display_switch i810_noaccel32;
+extern struct display_switch i810_accel_upright;
+extern struct display_switch i810_accel_ud;
+extern struct display_switch i810_accel_rl;
+extern struct display_switch i810_accel_rr;
+extern void i810_cursor(struct display *p, int mode, int xx, int yy);
+
+/* Accelerated Functions */
+extern inline int     wait_for_engine_idle     (void);
+extern inline void    emit_instruction         (u32 dsize, u32 pointer, u32 trusted);
+extern int            i810fb_load_front        (u32 offset, u32 pitch, u32 async);
+extern void           i810fb_load_back         (u32 pitch_bits);
+extern u32 __devinit  i810fb_init_accel        (u32 fb_offset, u32 aper_size, u32 sync);
+extern void __devinit i810fb_fix_accel_pointer (u32 fb_base_phys, u32 fb_base_virtual);
+extern void           i810fb_accel_cleanup     (void);
+extern int            i810fb_bind_accel_mem    (void);
+extern void           i810fb_unbind_accel_mem  (void);
+extern void           i810fb_restore_ringbuffer(struct ringbuffer *iring);
+extern void           i810fb_init_ringbuffer   (void);
+extern inline void    i810fb_iring_enable      (u32 mode);
+
+/* Resource Manager */
+extern int  __devinit i810fb_init_iface        (u32 sarea_offset);
+extern void __devinit i810fb_fix_iface_pointers(u32 fb_size, u32 aper_size,
+						u32 fb_base_phys, u32 fb_base_virt);
+extern void           i810fb_iface_cleanup     (void);
+extern void           i810fb_unbind_iface_mem  (void);
+extern int            i810fb_bind_iface_mem    (void);
+extern inline u32     i810fb_get_sarea_start   (void);
+extern inline u32     i810fb_write_sarea_reg   (void);
+
+#ifdef CONFIG_FB_I810_IFACE
+static int  __devinit has_iface                (void) { return 1; }
+extern int            i810fb_allocate_agpmemory(agp_mem_user *agp_mem);
+extern int            i810fb_free_agpmemory    (agp_mem_user *agp_mem);
+extern int            i810fb_acquire_fb        (void);
+extern int            i810fb_check_agp_mmap    (u32 offset, uid_t uid);
+extern int            i810fb_check_sarea       (u32 offset, uid_t uid);
+extern int            i810fb_process_command   (i810_command *command);
+#else
+static int  __devinit has_iface                (void) { return 0; }
+static inline int     i810fb_allocate_agpmemory(agp_mem_user *agp_mem) { return -ENODEV; }
+static inline int     i810fb_free_agpmemory    (agp_mem_user *agp_mem) { return -ENODEV; }
+static inline int     i810fb_acquire_fb        (void)                  { return -ENODEV; }
+static inline int     i810fb_check_agp_mmap    (u32 offset, uid_t uid) { return -ENODEV; }
+static inline int     i810fb_check_sarea       (u32 offset, uid_t uid) { return -ENODEV; }
+static inline int     i810fb_process_command   (i810_command *command) { return -ENODEV; }
+#endif /* CONFIG_FB_I810_IFACE */
+
+
+/* Conditional functions */
+
+
+#if defined(__i386__)
+inline void flush_cache(void)
+{
+	asm volatile ("wbinvd":::"memory");
+}
+#else
+inline void flush_cache(void) { }
+#endif 
+
+#ifdef CONFIG_FB_I810_ACCEL
+static inline int __init has_accel(void) { return 1; }
+static inline void __init fix_cursor_accel(void)
+{
+	i810_accel_upright.cursor = i810_cursor;
+}
+#else
+static inline int __init has_accel(void) { return 0; }
+static inline void __init fix_cursor_accel(void) { }
+#endif
+
+#ifdef CONFIG_MTRR
+static inline int __init has_mtrr(void) { return 1; }
+static inline void __devinit set_mtrr(void)
+{
+	i810_info->mtrr_reg = mtrr_add((u32) i810_info->fb_base_phys, 
+		 i810_info->aper_size, MTRR_TYPE_WRCOMB, 1);
+	if (i810_info->mtrr_reg < 0) {
+		printk("set_mtrr: unable to set MTRR/n");
+		return;
+	}
+	i810_info->mtrr_is_set = 1;
+}
+static inline void unset_mtrr(void)
+{
+  	if (i810_info->mtrr_is_set) 
+  		mtrr_del(i810_info->mtrr_reg, (u32) i810_info->fb_base_phys, 
+			 i810_info->aper_size); 
+}
+#else
+static inline int __init has_mtrr(void) { return 0; }
+static inline void __devinit set_mtrr(void)
+{
+	printk("set_mtrr: MTRR is disabled in the kernel\n");
+}
+static inline void unset_mtrr(void) { }
+#endif /* CONFIG_MTRR */
+
+
+#ifdef CONFIG_FB_I810_GTF
+static inline int __devinit is_std(void) {  return 0; }
+
+/**
+ * i810fb_fill_vga_registers - calculates all values for graphics registers
+ * @info: pointer to info structure
+ * @disp: pointer to display structure
+ *
+ * htotal: calculated using general timings formula
+ * vtotal: calculated using general timings formula
+ * hsync pulse: default at 8% of htotal
+ * vsync pulse: defaults at 3 
+ * left margin : (htotal - xres)/2 - hsync
+ * right margin: sync + left margin
+ * upper margin: defaults at 1
+ * lower margin: vtotal - (yres + vsync + upper margin)
+ * 
+ * DESCRIPTION: 
+ * Uses VESA general timings formula, and generic defaults.  
+ */
+static void i810fb_fill_vga_registers(struct fb_info *info, struct display *disp)
+{
+	int n, sync, gt1, gt2, blank_s, blank_e, xres, yres;
+	struct mode_registers *params = &i810_info->mode_params;
+
+	xres = i810_orient->xres;
+	yres = i810_orient->yres;
+
+	/* Horizontal */
+	sync = (i810_timings->htotal * 8)/100;
+	sync = (sync + 4) & ~7;
+	gt1 = (i810_timings->hblank >> 1) - sync;
+	gt1 = (gt1 + 4) & ~7;
+	gt2 = sync + gt1;
+	gt2 = (gt2 + 4) & ~7;
+
+	/* htotal */
+	n = ((xres + gt1 + sync + gt2) >> 3) - 5;
+	params->cr00 =  (u8) n;
+	params->cr35 = (u8) ((n >> 8) & 1);
+	
+	/* xres */
+	params->cr01 = (u8) ((xres >> 3) - 1);
+
+	/* hblank */
+	blank_e = (xres + gt1 + sync) >> 3;
+	blank_s = blank_e - 63;
+	if (blank_s < (xres >> 3))
+		blank_s = xres >> 3;
+	params->cr02 = (u8) blank_s;
+	params->cr03 = (u8) (blank_e & 0x1F);
+	params->cr05 = (u8) ((blank_e & (1 << 5)) << 2);
+	params->cr39 = (u8) ((blank_e >> 6) & 1);
+
+	/* hsync */
+	params->cr04 = (u8) ((xres + gt1) >> 3);
+	params->cr05 |= (u8) (((xres + gt1 + sync) >> 3) & 0x1F);
+	
+	/* Setup var_screeninfo */
+	disp->var.pixclock = 1000000000/params->pixclock;
+	disp->var.left_margin = gt2;
+	disp->var.right_margin = gt1;
+	disp->var.hsync_len = sync;
+	disp->var.sync = FB_SYNC_HOR_HIGH_ACT | 
+		FB_SYNC_VERT_HIGH_ACT | 
+		FB_SYNC_ON_GREEN;
+	disp->var.vmode = FB_VMODE_NONINTERLACED;
+	
+       	/* Vertical */
+	sync = 3;
+	gt1 = 1;
+	gt2 = i810_timings->vblank - (sync + gt1);
+
+	/* vtotal */
+	n = (yres + gt1 + sync + gt2) - 2;
+	params->cr06 = (u8) (n & 0xFF);
+	params->cr30 = (u8) ((n >> 8) & 0x0F);
+
+	/* vsync */ 
+	n = yres + gt1;
+	params->cr10 = (u8) (n & 0xFF);
+	params->cr32 = (u8) ((n >> 8) & 0x0F);
+	params->cr11 = i810_readb(CR11) & ~0x0F;
+	params->cr11 |= (u8) ((yres + gt1 + sync) & 0x0F);
+
+	/* yres */
+	n = yres - 1;
+	params->cr12 = (u8) (n & 0xFF);
+	params->cr31 = (u8) ((n >> 8) & 0x0F);
+	
+	/* vblank */
+	blank_e = yres + gt1 + sync;
+	blank_s = blank_e - 127;
+	if (blank_s < yres)
+		blank_s = yres;
+	params->cr15 = (u8) (blank_s & 0xFF);
+	params->cr33 = (u8) ((blank_s >> 8) & 0x0F);
+	params->cr16 = (u8) (blank_e & 0xFF);
+	params->cr09 = 0;	
+
+	/* var_screeninfo */
+	disp->var.upper_margin = gt2;
+	disp->var.lower_margin = gt1;
+	disp->var.vsync_len = sync;
+}	
+
+/**
+ * i810fb_get_watermark - gets watermark
+ * @var: pointer to fb_var_screeninfo
+ *
+ * DESCRIPTION:
+ * Load values to graphics registers
+ * 
+ * RETURNS:
+ * watermark
+ */
+
+static u32 i810fb_get_watermark(struct fb_var_screeninfo *var)
+{
+	struct wm_info *wmark = 0;
+	u32 i, size = 0, pixclock, wm_best = 0, min, diff;
+
+	if (i810_info->mem_freq == 100) {
+		switch (var->bits_per_pixel) { 
+		case 8:
+			wmark = i810_wm_8_100;
+			size = arraysize(i810_wm_8_100);
+			break;
+		case 16:
+			wmark = i810_wm_16_100;
+			size = arraysize(i810_wm_16_100);
+			break;
+		case 24:
+		case 32:
+			wmark = i810_wm_24_100;
+			size = arraysize(i810_wm_24_100);
+		}
+	}	
+	else {
+		switch(var->bits_per_pixel) {
+		case 8:
+			wmark = i810_wm_8_133;
+			size = arraysize(i810_wm_8_133);
+			break;
+		case 16:
+			wmark = i810_wm_16_133;
+			size = arraysize(i810_wm_16_133);
+			break;
+		case 24:
+		case 32:
+			wmark = i810_wm_24_133;
+			size = arraysize(i810_wm_24_133);
+		}
+	}
+
+	pixclock = i810_info->mode_params.pixclock/1000;
+	min = ~0;
+	for (i = 0; i < size; i++) {
+		if (pixclock <= wmark[i].freq) 
+			diff = wmark[i].freq - pixclock;
+		else 
+			diff = pixclock - wmark[i].freq;
+		if (diff < min) {
+			wm_best = wmark[i].wm;
+			min = diff;
+		}
+	}
+	return wm_best;		
+}	
+
+static inline void round_off_xres(struct fb_var_screeninfo *var) { }
+static inline void round_off_yres(struct fb_var_screeninfo *var) { }
+
+#else /* standard video modes */
+static inline int __devinit is_std(void) { return 1; }
+
+static void i810fb_fill_vga_registers(struct fb_info *info, struct display *disp)
+{ 
+	struct mode_registers *params = &i810_info->mode_params;
+
+	u32 diff = 0, diff_best = 0xFFFFFFFF, i = 0, i_best = 0; 
+	u32 res, total;
+	u8 xres;
+	
+	xres = (u8) ((i810_orient->xres >> 3) - 1);
+	for (i = 0; i < arraysize(std_modes); i++) { 
+		if (std_modes[i].cr01 == xres) { 
+			if (std_modes[i].pixclock < params->pixclock)
+				diff = params->pixclock - std_modes[i].pixclock;
+			if (diff < diff_best) {	 
+		    		i_best = i;
+		    		diff_best = diff;
+			}
+		}
+	}
+	*params = std_modes[i_best];
+
+	/* Setup var_screeninfo */
+	total = ((params->cr00 | (params->cr35 & 1) << 8) + 3) << 3;
+	res = i810_orient->xres;
+
+	disp->var.pixclock = 1000000000/params->pixclock;
+	disp->var.right_margin = (params->cr04 << 3) - res;
+	disp->var.hsync_len = ((params->cr05 & 0x1F) - 
+			       (params->cr04 & 0x1F)) << 3;
+	disp->var.left_margin = (total - (res + disp->var.right_margin + 
+					  disp->var.hsync_len));
+	disp->var.sync = FB_SYNC_HOR_HIGH_ACT | 
+		         FB_SYNC_VERT_HIGH_ACT |
+		         FB_SYNC_ON_GREEN;
+	disp->var.vmode = FB_VMODE_NONINTERLACED;
+
+	total = ((params->cr06 | (params->cr30 & 0x0F)  << 8)) + 2;
+	res = disp->var.yres;
+	disp->var.lower_margin = (params->cr10 | 
+				  (params->cr32 & 0x0F) << 8) - res;
+	disp->var.vsync_len = (params->cr11 & 0x0F) - 
+		(disp->var.lower_margin & 0x0F);
+	disp->var.upper_margin = total - (res + disp->var.lower_margin + 
+					  disp->var.vsync_len);
+}
+static u32 i810fb_get_watermark(struct fb_var_screeninfo *var)
+{
+	struct mode_registers *params = &i810_info->mode_params;
+	u32 wmark = 0;
+	
+	if (i810_info->mem_freq == 100) {
+		switch (var->bits_per_pixel) {
+		case 8:
+			wmark = params->bpp8_100;
+			break;
+		case 16:
+			wmark = params->bpp16_100;
+			break;
+		case 24:
+		case 32:
+			wmark = params->bpp24_100;
+		}
+	}
+	else {					
+		switch (var->bits_per_pixel) {
+		case 8:
+			wmark = params->bpp8_133;
+			break;
+		case 16:
+			wmark = params->bpp16_133;
+			break;
+		case 24:
+		case 32:
+			wmark = params->bpp24_133;
+		}
+	}
+	return wmark;
+}	
+
+static inline void round_off_xres(struct fb_var_screeninfo *var) 
+{
+	if ((accel && var->accel_flags) && 
+	    (rotate == ROTATE_RIGHT || rotate == ROTATE_LEFT) &&
+	    (var->bits_per_pixel < 24 || 
+	     (!render && var->bits_per_pixel < 32))) {
+		if (var->xres < 600) 
+			var->xres = 480;
+		if (var->xres < 768 && var->xres >= 600 ) 
+			var->xres = 600;
+		if (var->xres < 864 && var->xres >= 768) 
+			var->xres = 768;
+		if (var->xres < 960 && var->xres >= 864)
+			var->xres = 864;
+		if (var->xres < 1200 && var->xres >= 960)
+			var->xres = 960;
+		if (var->xres >= 1200)
+			var->xres = 1200;
+	}
+	else {
+		if (var->xres < 800) 
+			var->xres = 640;
+		if (var->xres < 1024 && var->xres >= 800) 
+			var->xres = 800;
+		if (var->xres < 1152 && var->xres >= 1024)
+			var->xres = 1024;
+		if (var->xres < 1280 && var->xres >= 1152)
+			var->xres = 1152;
+		if (var->xres < 1600 && var->xres >= 1280)
+			var->xres = 1280;
+		if (var->xres >= 1600)
+			var->xres = 1600;
+	}		
+}
+
+static inline void round_off_yres(struct fb_var_screeninfo *var)
+{
+	if ((accel && var->accel_flags) && 
+	    (rotate == ROTATE_RIGHT || rotate == ROTATE_LEFT) &&
+	    (var->bits_per_pixel < 24 || 
+	     (!render && var->bits_per_pixel < 32))) 
+		var->yres = (var->xres << 2)/ 3;
+	else
+		var->yres = (var->xres * 3) >> 2;
+}
+
+#endif /* CONFIG_FB_I810_GTF */
+
+
+#ifdef MODULE
+static inline int __devinit load_agpgart(void) { return 0; }
+#else
+static inline int __devinit load_agpgart(void) 
+{
+	if (i810fb_agp_init()) {
+		printk("i810fb_init: cannot initialize agp\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+#endif /* MODULE */
+
+
+#ifdef CONFIG_FB_I810_ACCEL
+#ifdef CONFIG_FB_I810_ROTATE
+static inline int __init has_rotate(void) { return 1; }
+static inline void __init fix_cursor_rotate(void)
+{
+	i810_accel_rl.cursor = i810_cursor;
+	i810_accel_rr.cursor = i810_cursor;
+	i810_accel_ud.cursor = i810_cursor;
+}
+static inline void set_var8(struct display *display, struct fb_var_screeninfo *var)
+{
+	if (accel && var->accel_flags) {
+		switch (i810_orient->rotate) {
+		case NO_ROTATION:
+			display->dispsw = &i810_accel_upright;
+			break;
+		case ROTATE_RIGHT:
+			display->dispsw = &i810_accel_rr;
+			break;
+		case ROTATE_180:
+			display->dispsw = &i810_accel_ud;
+			break;
+		case ROTATE_LEFT:
+			display->dispsw = &i810_accel_rl;
+			break;
+		}
+	}
+	else 
+		display->dispsw = &i810_noaccel8;
+} 
+
+static inline void set_var16(struct display *display, struct fb_var_screeninfo *var)
+{
+	if (accel && var->accel_flags) {
+		switch (i810_orient->rotate) {
+		case NO_ROTATION:
+			display->dispsw = &i810_accel_upright;
+			break;
+		case ROTATE_RIGHT:
+			display->dispsw = &i810_accel_rr;
+			break;
+		case ROTATE_180:
+			display->dispsw = &i810_accel_ud;
+			break;
+		case ROTATE_LEFT:
+			display->dispsw = &i810_accel_rl;
+			break;
+		}
+	}
+	else 
+		display->dispsw = &i810_noaccel16;
+	display->dispsw_data = (u16 *) palette;
+}
+
+static inline void set_var24(struct display *display, struct fb_var_screeninfo *var)
+{
+	if (accel && var->accel_flags) {
+		switch (i810_orient->rotate) {
+		case NO_ROTATION:
+			display->dispsw = &i810_accel_upright;
+			break;
+		case ROTATE_RIGHT:
+			display->dispsw = &i810_accel_rr;
+			break;
+		case ROTATE_180:
+			display->dispsw = &i810_accel_ud;
+			break;
+		case ROTATE_LEFT:
+			display->dispsw = &i810_accel_rl;
+			break;
+		}
+	}
+	else 
+		display->dispsw = &i810_noaccel24;
+	display->dispsw_data = (u32 *) palette;
+}
+#else  /* CONFIG_FB_I810_ROTATE */
+static inline int __init has_rotate(void) { return 0; }
+static inline void __init fix_cursor_rotate(void) { }
+static inline void set_var8(struct display *display, struct fb_var_screeninfo *var)
+{
+	if (accel && var->accel_flags) 
+		display->dispsw = &i810_accel_upright;
+	else 
+		display->dispsw = &i810_noaccel8;
+} 
+
+static inline void set_var16(struct display *display, struct fb_var_screeninfo *var)
+{
+	if (accel && var->accel_flags) 
+		display->dispsw = &i810_accel_upright;
+	else 
+		display->dispsw = &i810_noaccel16;
+	display->dispsw_data = (u16 *) palette;
+}
+
+static inline void set_var24(struct display *display, struct fb_var_screeninfo *var)
+{
+	if (accel && var->accel_flags) 
+		display->dispsw = &i810_accel_upright;
+	else 
+		display->dispsw = &i810_noaccel24;
+	display->dispsw_data = (u32 *) palette;
+}
+#endif /* CONFIG_FB_I810_ROTATE */
+#else /* CONFIG_FB_I810_ACCEL */
+static inline int __init has_rotate(void) { return 0; }
+static inline void __init fix_cursor_rotate(void) { }
+static inline void set_var8(struct display *display, struct fb_var_screeninfo *var)
+{
+	display->dispsw = &i810_noaccel8;
+} 
+
+static inline void set_var16(struct display *display, struct fb_var_screeninfo *var)
+{
+	display->dispsw = &i810_noaccel16;
+	display->dispsw_data = (u16 *) palette;
+}
+
+static inline void set_var24(struct display *display, struct fb_var_screeninfo *var)
+{
+	display->dispsw = &i810_noaccel24;
+	display->dispsw_data = (u32 *) palette;
+}
+#endif /* CONFIG_FB_I810_ACCEL */
+
+static inline void set_var32(struct display *display, 
+			     struct fb_var_screeninfo *var)
+{
+	display->dispsw = &i810_noaccel32;
+	display->dispsw_data = (u32 *) palette;
+}
+
+#endif /* __I810_MAIN_H__ */
--- linux-2.4.22/drivers/video/i810/i810_regs.h.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_regs.h	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,274 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_regs.h -- Intel 810/815 Register List
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+
+/*
+ * Intel 810 Chipset Family PRM 15 3.1 
+ * GC Register Memory Address Map 
+ *
+ * Based on:
+ * Intel (R) 810 Chipset Family 
+ * Programmer s Reference Manual 
+ * November 1999 
+ * Revision 1.0 
+ * Order Number: 298026-001 R
+ *
+ * All GC registers are memory-mapped. In addition, the VGA and extended VGA registers 
+ * are I/O mapped. 
+ */
+ 
+#ifndef __I810_REGS_H__
+#define __I810_REGS_H__
+
+/*  Instruction and Interrupt Control Registers (01000h 02FFFh) */
+#define FENCE                 0x02000                
+#define PGTBL_CTL             0x02020 
+#define PGTBL_ER              0x02024               
+#define    LRING              0x02030
+#define    IRING              0x02040
+#define HWS_PGA               0x02080 
+#define IPEIR                 0x02088
+#define IPEHR                 0x0208C 
+#define INSTDONE              0x02090 
+#define NOPID                 0x02094
+#define HWSTAM                0x02098 
+#define IER                   0x020A0
+#define IIR                   0x020A4
+#define IMR                   0x020A8 
+#define ISR                   0x020AC 
+#define EIR                   0x020B0 
+#define EMR                   0x020B4 
+#define ESR                   0x020B8 
+#define INSTPM                0x020C0
+#define INSTPS                0x020C4 
+#define BBP_PTR               0x020C8 
+#define ABB_SRT               0x020CC
+#define ABB_END               0x020D0
+#define DMA_FADD              0x020D4 
+#define FW_BLC                0x020D8
+#define MEM_MODE              0x020DC        
+
+/*  Memory Control Registers (03000h 03FFFh) */
+#define DRT                   0x03000
+#define DRAMCL                0x03001
+#define DRAMCH                0x03002
+ 
+
+/* Span Cursor Registers (04000h 04FFFh) */
+#define UI_SC_CTL             0x04008 
+
+/* I/O Control Registers (05000h 05FFFh) */
+#define HVSYNC                0x05000 
+#define GPIOA                 0x05010
+#define GPIOB                 0x05014 
+
+/* Clock Control and Power Management Registers (06000h 06FFFh) */
+#define DCLK_0D               0x06000
+#define DCLK_1D               0x06004
+#define DCLK_2D               0x06008
+#define LCD_CLKD              0x0600C
+#define DCLK_0DS              0x06010
+#define PWR_CLKC              0x06014
+
+/* Graphics Translation Table Range Definition (10000h 1FFFFh) */
+#define GTT                   0x10000  
+
+/*  Overlay Registers (30000h 03FFFFh) */
+#define OVOADDR               0x30000
+#define DOVOSTA               0x30008
+#define GAMMA                 0x30010
+#define OBUF_0Y               0x30100
+#define OBUF_1Y               0x30104
+#define OBUF_0U               0x30108
+#define OBUF_0V               0x3010C
+#define OBUF_1U               0x30110
+#define OBUF_1V               0x30114 
+#define OVOSTRIDE             0x30118
+#define YRGB_VPH              0x3011C
+#define UV_VPH                0x30120
+#define HORZ_PH               0x30124
+#define INIT_PH               0x30128
+#define DWINPOS               0x3012C 
+#define DWINSZ                0x30130
+#define SWID                  0x30134
+#define SWIDQW                0x30138
+#define SHEIGHT               0x3013F
+#define YRGBSCALE             0x30140 
+#define UVSCALE               0x30144
+#define OVOCLRCO              0x30148
+#define OVOCLRC1              0x3014C
+#define DCLRKV                0x30150
+#define DLCRKM                0x30154
+#define SCLRKVH               0x30158
+#define SCLRKVL               0x3015C
+#define SCLRKM                0x30160
+#define OVOCONF               0x30164
+#define OVOCMD                0x30168
+#define AWINPOS               0x30170
+#define AWINZ                 0x30174
+
+/*  BLT Engine Status (40000h 4FFFFh) (Software Debug) */
+#define BR00                  0x40000
+#define BRO1                  0x40004
+#define BR02                  0x40008
+#define BR03                  0x4000C
+#define BR04                  0x40010
+#define BR05                  0x40014
+#define BR06                  0x40018
+#define BR07                  0x4001C
+#define BR08                  0x40020
+#define BR09                  0x40024
+#define BR10                  0x40028
+#define BR11                  0x4002C
+#define BR12                  0x40030
+#define BR13                  0x40034
+#define BR14                  0x40038
+#define BR15                  0x4003C
+#define BR16                  0x40040
+#define BR17                  0x40044
+#define BR18                  0x40048
+#define BR19                  0x4004C
+#define SSLADD                0x40074
+#define DSLH                  0x40078
+#define DSLRADD               0x4007C
+
+
+/* LCD/TV-Out and HW DVD Registers (60000h 6FFFFh) */
+/* LCD/TV-Out */
+#define HTOTAL                0x60000
+#define HBLANK                0x60004
+#define HSYNC                 0x60008
+#define VTOTAL                0x6000C
+#define VBLANK                0x60010
+#define VSYNC                 0x60014
+#define LCDTV_C               0x60018
+#define OVRACT                0x6001C
+#define BCLRPAT               0x60020
+
+/*  Display and Cursor Control Registers (70000h 7FFFFh) */
+#define DISP_SL               0x70000
+#define DISP_SLC              0x70004
+#define PIXCONF               0x70008
+#define PIXCONF1              0x70009
+#define BLTCNTL               0x7000C
+#define SWF                   0x70014
+#define DPLYBASE              0x70020
+#define DPLYSTAS              0x70024
+#define CURCNTR               0x70080
+#define CURBASE               0x70084
+#define CURPOS                0x70088
+
+
+/* VGA Registers */
+
+/* SMRAM Registers */
+#define SMRAM                 0x10
+
+/* Graphics Control Registers */
+#define GR_INDEX              0x3CE
+#define GR_DATA               0x3CF
+
+#define GR10                  0x10
+#define GR11                  0x11
+
+/* CRT Controller Registers */
+#define CR_INDEX_MDA          0x3B4
+#define CR_INDEX_CGA          0x3D4
+#define CR_DATA_MDA           0x3B5
+#define CR_DATA_CGA           0x3D5
+
+#define CR30                  0x30
+#define CR31                  0x31
+#define CR32                  0x32
+#define CR33                  0x33
+#define CR35                  0x35
+#define CR39                  0x39
+#define CR40                  0x40
+#define CR41                  0x41
+#define CR42                  0x42
+#define CR70                  0x70
+#define CR80                  0x80 
+#define CR81                  0x82
+
+/* Extended VGA Registers */
+
+/* General Control and Status Registers */
+#define ST00                  0x3C2
+#define ST01_MDA              0x3BA
+#define ST01_CGA              0x3DA
+#define FRC_READ              0x3CA
+#define FRC_WRITE_MDA         0x3BA
+#define FRC_WRITE_CGA         0x3DA
+#define MSR_READ              0x3CC
+#define MSR_WRITE             0x3C2
+
+/* Sequencer Registers */
+#define SR_INDEX              0x3C4
+#define SR_DATA               0x3C5
+
+#define SR01                  0x01
+#define SR02                  0x02
+#define SR03                  0x03
+#define SR04                  0x04
+#define SR07                  0x07
+
+/* Graphics Controller Registers */
+#define GR00                  0x00   
+#define GR01                  0x01
+#define GR02                  0x02
+#define GR03                  0x03
+#define GR04                  0x04
+#define GR05                  0x05
+#define GR06                  0x06
+#define GR07                  0x07
+#define GR08                  0x08  
+
+/* Attribute Controller Registers */
+#define ATTR_WRITE              0x3C0
+#define ATTR_READ               0x3C1
+
+/* VGA Color Palette Registers */
+
+/* CLUT */
+#define CLUT_DATA             0x3C9        /* DACDATA */
+#define CLUT_INDEX_READ       0x3C7        /* DACRX */
+#define CLUT_INDEX_WRITE      0x3C8        /* DACWX */
+#define DACMASK               0x3C6
+
+/* CRT Controller Registers */
+#define CR00                  0x00
+#define CR01                  0x01
+#define CR02                  0x02
+#define CR03                  0x03
+#define CR04                  0x04
+#define CR05                  0x05
+#define CR06                  0x06
+#define CR07                  0x07
+#define CR08                  0x08
+#define CR09                  0x09
+#define CR0A                  0x0A
+#define CR0B                  0x0B
+#define CR0C                  0x0C
+#define CR0D                  0x0D
+#define CR0E                  0x0E
+#define CR0F                  0x0F
+#define CR10                  0x10
+#define CR11                  0x11
+#define CR12                  0x12
+#define CR13                  0x13
+#define CR14                  0x14
+#define CR15                  0x15
+#define CR16                  0x16
+#define CR17                  0x17
+#define CR18                  0x18
+
+#endif /* __I810_REGS_H__ */
--- linux-2.4.22/drivers/video/i810/i810_sarea.c.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_sarea.c	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,224 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_sarea.c -- Shared Area Allocation
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+#include <linux/types.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,14)
+#include <linux/malloc.h>
+#else
+#include <linux/slab.h>
+#endif
+
+#include "i810_regs.h"
+#include "i810_common.h"
+#include "i810_sarea.h"
+
+
+inline void i810fb_write_sarea_reg(void)
+{
+	i810_writel(HWS_PGA, i810_iface->i810_sarea_memory->physical);  
+}
+
+/**
+ * i810fb_set/clear_gttmap - updates/clears the gtt usage map
+ * @surface: pointer to agp_memory 
+ */
+inline void i810fb_set_gttmap(agp_memory *surface)
+{
+	int i;
+
+	for (i = surface->pg_start; 
+	     i < surface->pg_start + surface->page_count; 
+	     i++) 
+		set_bit(i, i810_iface->gtt_map); 
+}
+
+inline void i810fb_clear_gttmap(agp_memory *surface)
+{
+	int i;
+
+	for (i = surface->pg_start; 
+	     i < surface->pg_start + surface->page_count; 
+	     i++)
+		clear_bit(i, i810_iface->gtt_map);
+}
+
+int i810fb_bind_iface_mem(void) {
+	struct list_head *list;
+	agp_mem_struct *agp_list;
+
+	if (!i810_iface->i810_sarea_memory->is_bound) {
+		if (agp_bind_memory(i810_iface->i810_sarea_memory,
+				    i810_iface->sarea_offset)) {
+			printk("i810fb: can't rebind sarea memory\n");
+			return -EBUSY;
+		}
+	}
+	list_for_each(list, &i810_iface->agp_list_head) {
+		agp_list = (agp_mem_struct *) list;
+		if (!agp_list->surface->is_bound &&
+		    agp_bind_memory(agp_list->surface, 
+				    agp_list->surface->pg_start)) {
+			printk("i810fb: can't rebind client memory\n");
+			return -EBUSY;
+		}
+	}
+	return 0;
+}
+
+
+inline u32 i810fb_get_sarea_start(void)
+{
+	return i810_iface->sarea_start_phys;
+}
+
+inline void i810_set_iface_lockup(void)
+{
+	i810_iface->lockup = 1;
+}
+
+void i810fb_unbind_iface_mem(void) {
+	struct list_head *list;
+	agp_mem_struct *agp_list;
+
+	list_for_each(list, &i810_iface->agp_list_head) {
+		agp_list = (agp_mem_struct *) list;
+		if (!agp_list->surface->is_bound) 
+			agp_unbind_memory(agp_list->surface);
+	}
+	if (i810_iface->i810_sarea_memory->is_bound) 
+		agp_unbind_memory(i810_iface->i810_sarea_memory);
+}
+
+static int __devinit i810fb_alloc_resmem(void)
+{
+	if (!(i810_iface->gtt_map = vmalloc(GTT_SIZE >> 3))) 
+		return 1;
+	memset((void *) i810_iface->gtt_map, 0, GTT_SIZE >> 3);
+	if (!(i810_iface->user_key_list = vmalloc(MAX_KEY >> 3))) 
+		return 1;
+	memset((void *) i810_iface->user_key_list, 0, 
+	       MAX_KEY >> 3);
+	INIT_LIST_HEAD(&i810_iface->agp_list_head);
+	if (!(i810_iface->has_sarea_list = vmalloc(MAX_KEY >> 3))) 
+		return 1;
+	memset ((void *) i810_iface->has_sarea_list, 0,
+		MAX_KEY >> 3);
+	return 0;
+}
+
+static int __devinit i810fb_alloc_sharedmem(void)
+{
+	if (!(i810_iface->i810_sarea_memory = 
+	      agp_allocate_memory(SAREA_SIZE >> 12, AGP_PHYSICAL_MEMORY))) 
+		return 1;
+	return agp_bind_memory(i810_iface->i810_sarea_memory,
+			    i810_iface->sarea_offset);
+}
+
+void __devinit i810fb_fix_iface_pointers(u32 fb_size, u32 aper_size,
+					 u32 fb_base_phys, u32 fb_base_virtual)
+{
+	i810_iface->sarea_start_phys = fb_base_phys + 
+		(i810_iface->sarea_offset << 12);
+	i810_iface->sarea_start_virt = fb_base_virtual +
+		(i810_iface->sarea_offset << 12);
+	
+	i810_iface->sarea = (i810_sarea *) i810_iface->sarea_start_virt;
+	memset((void *) i810_iface->sarea, 0, SAREA_SIZE);
+	
+	(u32) i810_iface->sarea->cur_surface_key = MAX_KEY;
+	(u32) i810_iface->sarea->cur_user_key = MAX_KEY;
+	(u32) i810_iface->cur_dma_buf_virt = 0;
+	(u32) i810_iface->cur_dma_buf_phys = 0;
+	i810_iface->fb_size = fb_size;
+	i810_iface->aper_size = aper_size;
+	i810_iface->fb_base_phys = fb_base_phys;
+	i810_iface->fb_base_virt = fb_base_virtual;
+}
+
+int __devinit i810fb_init_iface(u32 sarea_offset)
+{
+	if(!(i810_iface = kmalloc(sizeof(struct iface_data), GFP_KERNEL)))
+		return -ENOMEM;
+	memset(i810_iface, 0, sizeof(struct iface_data));
+	i810_iface->sarea_offset = sarea_offset;
+	if (i810fb_alloc_sharedmem()) return -ENOMEM;
+	if (i810fb_alloc_resmem()) return -ENOMEM;
+	return 0;
+}
+
+/**
+ * i810fb_release_all - release all agpmemory on a per user key basis
+ * @key: user key of the currently active process
+ *
+ * DESCRIPTION:
+ * Walks through the linked list, and all agpmemory that matches the user key
+ * will be unbound, deleted and removed from the list.
+ */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,9)
+void i810fb_release_all(u32 key)
+{
+	struct list_head *list1, *list2;
+	agp_mem_struct *agp_list;
+
+	wait_for_engine_idle();
+	list_for_each_safe(list1, list2, &i810_iface->agp_list_head) {
+		agp_list = (agp_mem_struct *) list1;
+		if (agp_list->user_key == key) {
+			i810fb_clear_gttmap(agp_list->surface);
+			agp_unbind_memory(agp_list->surface);
+			agp_free_memory(agp_list->surface);
+			list_del(list1);
+		}
+	}
+}
+
+#else
+void i810fb_release_all(u32 key)
+{
+	struct list_head *list ;
+	agp_mem_struct *agp_list;
+
+	wait_for_engine_idle();
+	list_for_each(list, &i810_iface->agp_list_head) {
+		agp_list = (agp_mem_struct *) list;
+		if (agp_list->user_key == key) {
+			i810fb_clear_gttmap(agp_list->surface);
+			agp_unbind_memory(agp_list->surface);
+			agp_free_memory(agp_list->surface);
+			list_del(list);
+		}
+	}
+}
+#endif 
+
+void i810fb_iface_cleanup(void)
+{
+	u32 i;
+
+	if (i810_iface->user_key_list) {
+		for (i = 0; i < MAX_KEY; i++) {
+			if (test_bit(i, i810_iface->user_key_list))
+				i810fb_release_all(i);
+		}
+		vfree(i810_iface->user_key_list);
+	}
+	if (i810_iface->gtt_map)
+		vfree(i810_iface->gtt_map);
+	if (i810_iface->has_sarea_list)
+		vfree(i810_iface->has_sarea_list);
+	if (i810_iface->i810_sarea_memory)
+		agp_free_memory(i810_iface->i810_sarea_memory);
+	if (i810_iface)
+		kfree(i810_iface);
+}
+
--- linux-2.4.22/drivers/video/i810/i810_sarea.h.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/drivers/video/i810/i810_sarea.h	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,19 @@
+/*-*- linux-c -*-
+ *  linux/drivers/video/i810_iface.h -- Shared Memory Allocation
+ *
+ *      Copyright (C) 2001 Antonino Daplas
+ *      All Rights Reserved      
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#ifndef __I810_SAREA_H__
+#define __I810_SAREA_H__
+
+struct iface_data  *i810_iface;
+extern inline void i810_writel(u32 where, u32 val);
+extern inline int  wait_for_engine_idle(void);
+
+#endif /* __I810_SAREA_H__ */
--- linux-2.4.22/Documentation/fb/intel810.txt.dv08.orig	2003-09-13 04:22:28.000000000 +0200
+++ linux-2.4.22/Documentation/fb/intel810.txt	2003-09-13 04:22:28.000000000 +0200
@@ -0,0 +1,293 @@
+Intel 810/815 Framebuffer driver
+ 	Tony Daplas <adaplas@pol.net>
+	http://i810fb.sourceforge.net
+
+	March 17, 2002
+
+	First Released: July 2001
+================================================================
+
+A. Introduction
+	This is a framebuffer driver for various Intel 810/815 compatible
+graphics devices.  These would include:
+
+	Intel 810
+	Intel 810E
+	Intel 810-DC100
+	Intel 815 Internal graphics only, 100Mhz FSB
+	Intel 815 Internal graphics only
+	Intel 815 Internal graphics and AGP
+
+B.  Problems in writing a framebuffer driver for the Intel 810/815 chipsets.
+
+	First and foremost, these chipsets do not have dedicated video
+memory.  They do have a reserved logical space for graphics memory (up to
+64MB), but this space is empty.  For this space to become usable at all,
+pages of System RAM must be mapped to this space.  However, as with all
+video memory, the space must appear linear to anybody trying to access the
+graphics device.  That's where GART comes in.  GART (which stands for
+Graphics Address Relocation Table) or GTT (Graphics Translation Table) as
+Intel(c) calls it, basically does all the memory address juggling acts such
+that this logical space becomes functional as linear graphics memory.
+
+	Besides this 64MB logical space, the i810/i815 chipsets can access
+"stolen memory" of up to 1 MB.  This memory is typically used for VGA, but
+because this memory is banked, you cannot access more than 16KB at a time
+without some form of bank switching. 
+
+	In the end, some form of GART service must exist in order for the
+i810/i815 to become usable at high resolutions.  For kernels 2.2.19 and
+above, such an entity exists, agpgart written by Jeff Hartmann.
+
+	The present agpgart kernel module currently supports only one user
+at a time.  As we probably all know, the primary user of this module is
+xfree86, whether directly or via the Direct Rendering Manager (DRM).  It is
+relatively easy to write a framebuffer device for the i810/i815, making it
+co-exist with other users of agpgart (like X), is the most difficult part.   
+
+	So how do we approach this problem:
+
+	a.  Use VGA.
+
+	A framebuffer driver already exists for this, VGA16.  However, since
+you can only access 16KB at a time, you will be limited to 640x480 at 8bpp. 
+Most people will not be satisfied with this.
+
+	b.  Use the entire "stolen memory"
+
+	Stolen memory is actually a good idea.  You'll be able to access 1
+MB of memory, enough for 1024x768 at 8bpp or 800x600 at 16bpp.  The downside
+is, the coder must be patient enough to write code for banked switching,
+else, you'll be stuck with 16KB.  (And I do know of someone who successfully
+wrote banked switching for the i810).
+
+	Another downside is lack of accelerated support.  Overall, this is
+the safest option, since it will leave X with exclusive access to agpgart.
+
+	c.  Use customized AGPGART codes.
+
+	This was the first approach of the early versions of the driver.  At
+first glance, this seems to be the correct technique, but actually it isn't. 
+Even though the driver will be able to have it's own AGP memory, at some
+point down the hardware level, contention of critical hardware registers
+cannot be avoided.  Therefore, the framebufer driver must be careful in
+saving and restoring the register states each time X, or any agpgart
+requiring applcation becomes active. This is actually more complicated than
+it sounds.
+
+	d.  Allow AGPGART memory sharing
+
+	I consider this the best method and there are two techniques.  The
+first technique is to have Xfree86 communicate with the kernel framebuffer
+driver whenever it needs to acquire or release agpgart.  This is how the
+current i810/i815 driver works.  Whenever X becomes active, it tells the
+framebuffer driver to release the device, and when X becomes inactive or
+exits, it tells the driver that it can reacquire the device.  The solution
+is simple, and we avoid a lot of hacks/workarounds and code bloat.
+
+	Another novel idea is to make AGP memory shareable.  Shareable means
+it becomes like any other graphics device.  In a few words, more than one
+application will be able to use the same memory space that another
+application is already using.  The very distinct advantage of this method is
+that we save a lot of RAM.  Since the current agpgart does not allow more
+than one user at a time, if an application needs 8 MB of video RAM, and
+another requires another 8MB, then agpgart will allocate a total of 16MB. 
+However, if the AGP memory is shareable, agpgart needs to only allocate 8MB
+of RAM and then let both applications share the same memory block.
+
+C.  Features
+
+	- Supports a range of horizontal resolutions from 640 to 1600 in
+	  multiples of 8 if "NonStandard Video Modes" is enabled.
+        - Supports color depths of 8, 16, 24 and 32 bits per pixel
+        - Supports accelerated (8, 16 and 24 bpp only) and unaccelerated modes
+        - MTRR support 
+	- Utilizes monitor specifications to automatically compute modelines
+	- Can coexist with xfree86 running with native i810 drivers under certain
+	  precautions
+	- hardware cursor support
+	- hardware y-panning support
+	- Supports tiled memory
+	- Resource Manager and Instruction Buffer interface
+ 	- Variable Display Aspect Ratio 
+	- Console Display Rotation
+ 
+E.  Kernel boot parameters
+	
+   a. "video=i810fb"  
+	enables the i810 driver
+ 
+   b. "xres=<value>"  
+	horizontal resolution in pixels 
+	(default = 640)
+
+   c. "yres=<value>"
+	vertical resolution in scanlines. Computed as 3*xres/4.  If 
+	VESA GTF is enabled, this must be specified as well.
+	(default = 480)
+		
+   d. "vyres=<value>" 
+	virtual vertical resolution in scanlines. If greater than "yres",
+	hardware y-panning will be automatically enabled. 
+	(default = 480)
+
+   e. "vram=<value>"
+	amount of system RAM in MB to allocate for the device 
+	(default = 4)
+
+   f. "bpp=<value>"   
+	bits per pixel 
+	(default = 8)
+
+   g. "hsync1/hsync2=<value>" 
+	the minimum and maximum Horizontal Sync Frequency of the monitor KHz
+	hsync1 must be equal to hsync2 if a fixed frequency monitor is to be
+	used.
+	default (30/31)
+
+   h. "vsync1/vsync2=<value>" 
+	the minimum and maximum Vertical Sync Frequency of the monitor in Hz
+	You can also use this to fix/limit the refresh rate of your monitor. 
+	So, if you need fix the refresh rate at 60Hz (no more, no less),
+	then set vsync1=60 and vsync2=60.  (default = 60/60)
+
+   i. "accel" 
+	enable text acceleration 
+	(default = not set) 
+
+   j. "mtrr" 
+	enable MTRR.  This allows data transfers to the framebuffer memory
+	to occur in bursts which can significantly increase performance. 
+	(default = not set) 
+   k. "hwcur"
+	enable hardware cursor 
+	(default = not set)
+
+   l. "extvga"
+	enables secondary/external VGA output 
+	(default = not set)
+	
+   m. "sync_on_pan" 
+ 	Forces display refresh during vsync only.  This may be useful if
+	display panning causes the display to flicker.  Enabling this option
+	will limit the flicker.	(default = not set)
+
+   n. "sync" 
+	Forces the hardware engine to do a "sync" for each accelerated
+	function.  This will produce a more stable setup, but will be slower.	
+	(default = not set)
+
+   o. "render=<value>"
+	This forces the framebuffer memory to be aligned at "value"
+	multiplied by 1024.  At the same time, "memory tiling" will be
+	enabled. Memory tiling is a method to localize graphics data which
+	speeds up hardware access to surface data.  This might be useful for
+	high-bandwidth modes (3D, Video, or just plain high resolution, high
+	bit depth modes).  
+	(default = not set)
+
+   p. "rotate=<value>"
+	This will rotate console display.  "rotate=0" = no rotation;
+	"rotate=1" = rotate to the right; "rotate=2" = rotate 180 degrees;
+	and "rotate=3" = rotate to the left.  Prerequisite: "accel" must be
+	enabled, swap xres value with yres if displaye is rotated by 90
+	degrees.  
+	(default = no rotation)
+		
+##############
+Sample Usage
+##############
+
+In /etc/lilo.conf, add the line:
+
+append="video=i810fb:vram=2:xres=1024:bpp=16:hsync1=30:hsync2=55:vsync1=50:vsync2=85:accel:mtrr"
+
+This will initialize the framebuffer to 1024x768 @ 16bpp.  The framebuffer
+will use 2 MB of System RAM. MTRR support is enabled. The refresh rate will
+be computed based on the hsync1/hsync2 and vsync1/vsync2 values.  REMEMBER:
+you need to include hsync1, hsync2, vsync1 and vsync2 to enable video modes
+better than 640x480 at 60Hz.
+
+G.  Module options
+	
+	The module parameters are essentially similar to kernel parameters. 
+The main difference is that you need to include a Boolean value (1 for TRUE,
+and 0 for FALSE) for those options that does have an assignment.  Example,
+to enable MTRR, include "mtrr=1".
+
+##############
+Sample Usage
+#############
+Using the same setup as described above, load the module like this:
+
+	modprobe i810fb vram=2 xres=1024 bpp=16 hsync1=30 hsync2=55 vsync1=50 vsync2=85 accel=1 mtrr=1
+
+Or just add the following to /etc/modules.conf
+
+	options i810fb vram=2 xres=1024 bpp=16 hsync1=30 hsync2=55 vsync1=50 \
+	vsync2=85 accel=1 mtrr=1
+
+and just do a 
+
+	modprobe i810fb
+
+
+H.  Compilation
+
+  	a.  Get the kernel patches from http://www.sourceforge.net/projects/i810fb.  
+
+	b.  Apply the patch.  Each patch has a version number and the kernel
+version number that has to be patched.  Thus i810fb-2.4.17-0.0.10 will patch
+linux-2.4.17 to add i810 framebuffer support version 0.0.10.
+
+	Assuming your kernel tree is in /usr/src/linux
+
+	cd /usr/src
+	bzip2 -dc /patch/location/patch-i810fb-2.4.17-0.0.10.bz2 | patch -p0
+
+	c.  Configuring the kernel.
+
+ 	Agpgart support is REQUIRED.  How support for the i810 will be added
+depends on how you enabled agpgart. Then just enable i810 Framebuffer
+support in Console->Video->Framebuffer.  If you want to experiment with
+nonstandard modes (like 936x702 at 72 Hz for instance), enable "NonStandard
+Intel Video Timings".  
+  
+	d.  Recompile the kernel as usual.
+	  	
+	e.  In order to use X with the i810/i815 framebuffer driver, you
+must get the patched i810 driver from the Sourceforge site.  Just copy the
+file i810_drv.o to /usr/X11R6/lib/modules/drivers. 
+
+	If you want to do it the hard way by recompiling X, then:
+
+	- Grab the XFree86-4.1 source from http://www.xfree86.org
+	- Untar the package somewhere
+	- cd xc/programs/Xserver/hw/xfree86/drivers
+	- bzip2 -dc patch-xc410-i810fb.bz2 | patch -p0
+	- recompile X
+
+J.  Acknowledgment:
+	
+	1.  Geert Uytterhoeven - his excellent howto and the virtual
+framebuffer driver code makes this possible.
+
+	2.  Jeff Hartmann for his agpgart code.  
+
+	3.  The X developers.  Providing X with a means for a save and
+restore greatly decreased the difficulty in coding.
+
+	4.  Intel(c).  For this value-oriented chipset driver and for
+providing documentation.
+
+	5. Matt Sottek.  His inputs and ideas  helped in making some
+	optimizations possible.
+
+K.  Home Page:
+
+	A more complete, and probably updated information is provided at
+http://i810fb.sourceforge.net.
+
+###########################
+Tony
+
--- linux-2.4.22/Documentation/Configure.help.dv08.orig	2003-09-13 04:22:24.000000000 +0200
+++ linux-2.4.22/Documentation/Configure.help	2003-09-13 04:22:28.000000000 +0200
@@ -5542,6 +5542,69 @@ CONFIG_FB_VIRTUAL
 
   If unsure, say N.
 
+Intel 810/815 display support (EXPERIMENTAL)
+CONFIG_FB_I810
+  This driver supports the on-board graphics built-in to the Intel 810 
+  and 815 chipsets.  Say Y if you have and plan to use such a board.
+
+  The driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). 
+  The module will be called i810fb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  For more information, please read Documentation/fb/intel810.txt
+ 
+Intel 810/815 VESA Generalized Timing Formula  (EXPERIMENTAL)
+CONFIG_FB_I810_GTF
+  If you say Y, then the VESA standard, Generalized Timing  Formula, 
+  or GTF, will be used to calculate the required video timing
+  values per video mode.  Since the GTF allows nondiscrete timings 
+  (nondiscrete being a range of values as opposed to discrete being a
+  set of values), you'll be able to use a range of resolutions 
+  (640 to 1600), vertical refresh rates (limited only by hardware), 
+  and variable display aspect ratios. If you want to maximize the 
+  capability of your display, or if you have a display with 
+  nonstandard dimensions (aspect ratio != 4:3), then select this 
+  option. The timings may not be compliant with Intel's recommended 
+  values. Use at your own risk.
+
+  If you say N, the driver will revert to a set of timing values as
+  recommended by Intel in their documentation.
+  
+  If unsure, say N.
+
+Intel 810/815 Hardware Acceleration Code (EXPERIMENTAL)
+CONFIG_FB_I810_ACCEL
+  To enable accelerated console drawing functions, enable this option, 
+  then pass the "accel" boot option or "accel=1" module option.  You 
+  will also need to select this option if you need console display 
+  rotation. Selecting this option will add 2 KB to your kernel.
+
+  If unsure, say N.
+
+Intel 810/815 Console Display Rotation Code (EXPERIMENTAL)
+CONFIG_FB_I810_ROTATE
+  If you select this option, you'll be able to rotate the console 
+  display 90 degrees to the left or to the right, or 180 degrees. You'll 
+  have to pass the "rotate=" boot parameter/module option to select the 
+  axis of rotation. Please read /usr/src/linux/Documentation/fb/intel810.txt 
+  for more information. Selecting this option will add 4 KB to your kernel.
+
+  If unsure, say N.
+
+Intel 810/815 Hardware Interface (VERY EXPERIMENTAL!)
+CONFIG_FB_I810_IFACE
+  If you select this option, a user-to-kernel interface will be included 
+  with the driver. Through this interface, userland programs can pass 
+  instructions to the driver and access the hardware's "accelerated" 
+  functions.  This is a very likely security risk, so unless you need this 
+  feature, do NOT select this option. Selecting this option will add 2 KB 
+  to your kernel.
+
+  This interface is necessary if you want to try the Directfb 
+  (http://www.direcfb.org) gfxdriver for the Intel 810.  The driver is 
+  available at http://www.sourceforge.net/projects/i810fb.
+
 Mach64 CT/VT/GT/LT (incl. 3D RAGE) support
 CONFIG_FB_ATY_CT
   Say Y here to support use of ATI's 64-bit Rage boards (or other
