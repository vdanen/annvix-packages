diff -uN linux-2.4.20/drivers/usb.spca/Config.in linux-2.4.20/drivers/usb/Config.in
--- linux-2.4.20/drivers/usb.spca/Config.in	2003-04-17 01:09:57.000000000 +0200
+++ linux-2.4.20/drivers/usb/Config.in	2003-04-17 01:10:37.000000000 +0200
@@ -83,6 +83,7 @@
       dep_tristate '  D-Link USB FM radio support (EXPERIMENTAL)' CONFIG_USB_DSBR $CONFIG_USB $CONFIG_VIDEO_DEV $CONFIG_EXPERIMENTAL
       dep_tristate '  Nogatech USBVISION video support' CONFIG_USB_USBVISION $CONFIG_USB $CONFIG_VIDEO_DEV $CONFIG_EXPERIMENTAL
       dep_tristate '  DABUSB driver' CONFIG_USB_DABUSB $CONFIG_USB
+      dep_tristate '  USB SPCA50X Camera support' CONFIG_USB_SPCA50X $CONFIG_USB $CONFIG_VIDEO_DEV
    fi
 
    comment 'USB Network adaptors'
Les sous-répertoires linux-2.4.20/drivers/usb.spca/host et linux-2.4.20/drivers/usb/host sont identiques.
diff -uN linux-2.4.20/drivers/usb.spca/jpegdecoder.c linux-2.4.20/drivers/usb/jpegdecoder.c
--- linux-2.4.20/drivers/usb.spca/jpegdecoder.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/jpegdecoder.c	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,728 @@
+/* 
+ *    linux/drivers/video/fbcon-jpegdec.c - a tiny jpeg decoder.
+ *      
+ *      (w) August 2001 by Michael Schroeder, <mls@suse.de>
+ *
+ *    I severly gutted this beast and hardcoded it to the palette and subset
+ *    of jpeg needed for the spca50x driver. Also converted it from K&R style
+ *    C to a more modern form ;). Michael can't be blamed for what is left.
+ *    All nice features are his, all bugs are mine. - till
+ *                  
+ */
+
+#ifndef __KERNEL__
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#else /* __KERNEL__ */
+#include <linux/string.h>
+#endif /* __KERNEL__ */
+
+#define VIDEO_PALETTE_RGB32  5       /* 32bit RGB */
+#define VIDEO_PALETTE_RGB24  4       /* 24bit RGB */
+
+#include "jpegdecoder.h"
+#include "jpeg_header.h"
+
+static void dec_makehuff (struct dec_hufftbl *, int *, unsigned char *);
+static void idctqtab (unsigned char *, int *);
+static void scaleidctqtab (int *, int);
+static void initcol (int[][64]);
+
+static void col221111(int *, unsigned char *, int, int force_rgb);
+static void col221111_32(int *, unsigned char *, int, int force_rgb);
+
+static struct comp comps[MAXCOMP] =
+{
+    { 0x01, 0x22, 0x00 },
+    { 0x02, 0x11, 0x01 },
+    { 0x03, 0x11, 0x01 },
+    { 0x00, 0x00, 0x00 }
+};
+
+static struct scan dscans[MAXCOMP];
+
+static unsigned char quant[4][64];
+
+static struct dec_hufftbl dhuff[4];
+
+#define dec_huffdc (dhuff + 0)
+#define dec_huffac (dhuff + 2)
+
+static struct in in;
+
+int dquant[3][64];
+
+void
+jpeg_reset_input_context(unsigned char *buf)
+{
+	/* set input context */
+	in.p = buf; 
+	in.left = 0;
+	in.bits = 0;
+	in.marker = 0;
+}
+
+int jpeg_decode(unsigned char *pic, unsigned char * buf, int width, int height, 
+		 int format, int force_rgb)
+{
+	int mcusx, mcusy, mx, my;
+	int dcts[6 * 64 + 16];
+	int out[64 * 6];
+	int max[6];
+	int i;
+	int bpp;
+
+	bpp= (format==VIDEO_PALETTE_RGB32)?4:3;
+
+	if ((height & 15) || (width & 15))
+		return 1;
+
+	mcusx = width >> 4;
+	mcusy = height >> 4;
+
+	jpeg_reset_input_context(buf);
+	
+	/* for each component. Reset dc values. */
+	for (i = 0; i < 3; i++)
+		dscans[i].dc = 0;
+	
+	/* Decode to the correct format.
+	 * Ugly copy-paste to avoid tests in the loop.
+	 */
+	if(format==VIDEO_PALETTE_RGB24) { 
+	  for (my = 0; my < mcusy; my++) {
+	    for (mx = 0; mx < mcusx; mx++) {
+	      decode_mcus(&in, dcts, 6, dscans, max);
+	      idct(dcts, out, dquant[0], IFIX(128.5), max[0]);
+	      idct(dcts + 64, out + 64, dquant[0], IFIX(128.5), max[1]);
+	      idct(dcts + 128, out + 128, dquant[0], IFIX(128.5), max[2]);
+	      idct(dcts + 192, out + 192, dquant[0], IFIX(128.5), max[3]);
+	      idct(dcts + 256, out + 256, dquant[1], IFIX(0.5), max[4]);
+	      idct(dcts + 320, out + 320, dquant[2], IFIX(0.5), max[5]);
+	      /* Up to here we are fine, performance wise. This 
+	       * color space conversion is dead slow and is killing
+	       * performance for large resolutions. It should not be
+	       * necessary, as v4l provides support for planar yuv.
+	       * */
+	      col221111(out, pic + (my * 16 * mcusx + mx) * 16 * 3, 
+			mcusx * 16 * 3, force_rgb);
+	    }
+	  }
+	} else if(format==VIDEO_PALETTE_RGB32){
+	  for (my = 0; my < mcusy; my++) {
+	    for (mx = 0; mx < mcusx; mx++) {
+	      decode_mcus(&in, dcts, 6, dscans, max);
+	      idct(dcts, out, dquant[0], IFIX(128.5), max[0]);
+	      idct(dcts + 64, out + 64, dquant[0], IFIX(128.5), max[1]);
+	      idct(dcts + 128, out + 128, dquant[0], IFIX(128.5), max[2]);
+	      idct(dcts + 192, out + 192, dquant[0], IFIX(128.5), max[3]);
+	      idct(dcts + 256, out + 256, dquant[1], IFIX(0.5), max[4]);
+	      idct(dcts + 320, out + 320, dquant[2], IFIX(0.5), max[5]);
+	      /* Up to here we are fine, performance wise. This 
+	       * color space conversion is dead slow and is killing
+	       * performance for large resolutions. It should not be
+	       * necessary, as v4l provides support for planar yuv.
+	       * */
+	      col221111_32(out, pic + (my * 16 * mcusx + mx) * 16 * 4, 
+			mcusx * 16 * 4, force_rgb);
+	    }
+	  }
+	}
+
+	return 0;
+}
+
+/****************************************************************/
+/**************       huffman decoder             ***************/
+/****************************************************************/
+
+static int fillbits (struct in *, int, unsigned int);
+static int dec_rec2 (struct in *, struct dec_hufftbl *, int *, int, int);
+
+static int fillbits(struct in *in, int le, unsigned int bi)
+{
+	int b;
+
+	if (in->marker) {
+		if (le <= 16)
+			in->bits = bi << 16, le += 16;
+		return le;
+	}
+	while (le <= 24) {
+		b = *in->p++;
+		bi = bi << 8 | b;
+		le += 8;
+	}
+	in->bits = bi;		/* tmp... 2 return values needed */
+	return le;
+}
+
+#define LEBI_GET(in)	(le = in->left, bi = in->bits)
+#define LEBI_PUT(in)	(in->left = le, in->bits = bi)
+
+#define GETBITS(in, n) (					\
+  (le < (n) ? le = fillbits(in, le, bi), bi = in->bits : 0),	\
+  (le -= (n)),							\
+  bi >> le & ((1 << (n)) - 1)					\
+)
+
+#define UNGETBITS(in, n) (	\
+  le += (n)			\
+)
+
+
+static int dec_rec2(struct in *in, struct dec_hufftbl *hu, int *runp, int c, int i)
+{
+	int le, bi;
+
+	le = in->left;
+	bi = in->bits;
+	if (i) {
+		UNGETBITS(in, i & 127);
+		*runp = i >> 8 & 15;
+		i >>= 16;
+	} else {
+		for (i = DECBITS; (c = ((c << 1) | GETBITS(in, 1))) >= (hu->maxcode[i]); i++);
+		if (i >= 16) {
+			in->marker = M_BADHUFF;
+			return 0;
+		}
+		i = hu->vals[hu->valptr[i] + c - hu->maxcode[i - 1] * 2];
+		*runp = i >> 4;
+		i &= 15;
+	}
+	if (i == 0) {		/* sigh, 0xf0 is 11 bit */
+		LEBI_PUT(in);
+		return 0;
+	}
+	/* receive part */
+	c = GETBITS(in, i);
+	if (c < (1 << (i - 1)))
+		c += (-1 << i) + 1;
+	LEBI_PUT(in);
+	return c;
+}
+
+#define DEC_REC(in, hu, r, i)	 (	\
+  r = GETBITS(in, DECBITS),		\
+  i = hu->llvals[r],			\
+  i & 128 ?				\
+    (					\
+      UNGETBITS(in, i & 127),		\
+      r = i >> 8 & 15,			\
+      i >> 16				\
+    )					\
+  :					\
+    (					\
+      LEBI_PUT(in),			\
+      i = dec_rec2(in, hu, &r, r, i),	\
+      LEBI_GET(in),			\
+      i					\
+    )					\
+)
+
+void decode_mcus(struct in *in, int *dct, int n, struct scan *sc, int *maxp)
+{
+	struct dec_hufftbl *hu;
+	int i, r, t;
+	int le, bi;
+
+	memset(dct, 0, n * 64 * sizeof(*dct));
+	le = in->left;
+	bi = in->bits;
+
+	while (n-- > 0) {
+		hu = sc->hudc.dhuff;
+		*dct++ = (sc->dc += DEC_REC(in, hu, r, t));
+
+		hu = sc->huac.dhuff;
+		i = 63;
+		while (i > 0) {
+			t = DEC_REC(in, hu, r, t);
+			if (t == 0 && r == 0) {
+				dct += i;
+				break;
+			}
+			dct += r;
+			*dct++ = t;
+			i -= r + 1;
+		}
+		*maxp++ = 64 - i;
+		if (n == sc->next)
+			sc++;
+	}
+	LEBI_PUT(in);
+}
+
+static void dec_makehuff(struct dec_hufftbl *hu, int *hufflen, unsigned char *huffvals)
+{
+	int code, k, i, j, d, x, c, v;
+	for (i = 0; i < (1 << DECBITS); i++)
+		hu->llvals[i] = 0;
+
+/*
+ * llvals layout:
+ *
+ * value v already known, run r, backup u bits:
+ *  vvvvvvvvvvvvvvvv 0000 rrrr 1 uuuuuuu
+ * value unknown, size b bits, run r, backup u bits:
+ *  000000000000bbbb 0000 rrrr 0 uuuuuuu
+ * value and size unknown:
+ *  0000000000000000 0000 0000 0 0000000
+ */
+	code = 0;
+	k = 0;
+	for (i = 0; i < 16; i++, code <<= 1) {	/* sizes */
+		hu->valptr[i] = k;
+		for (j = 0; j < hufflen[i]; j++) {
+			hu->vals[k] = *huffvals++;
+			if (i < DECBITS) {
+				c = code << (DECBITS - 1 - i);
+				v = hu->vals[k] & 0x0f;	/* size */
+				for (d = 1 << (DECBITS - 1 - i); --d >= 0;) {
+					if (v + i < DECBITS) {	/* both fit in table */
+						x = d >> (DECBITS - 1 - v -
+							  i);
+						if (v && x < (1 << (v - 1)))
+							x += (-1 << v) + 1;
+						x = x << 16 | (hu-> vals[k] & 0xf0) << 4 |
+							(DECBITS - (i + 1 + v)) | 128;
+					} else
+						x = v << 16 | (hu-> vals[k] & 0xf0) << 4 |
+						        (DECBITS - (i + 1));
+					hu->llvals[c | d] = x;
+				}
+			}
+			code++;
+			k++;
+		}
+		hu->maxcode[i] = code;
+	}
+	hu->maxcode[16] = 0x20000;	/* always terminate decode */
+}
+
+/****************************************************************/
+/**************             idct                  ***************/
+/****************************************************************/
+
+#define ONE ((int)IFIX(1.))
+#define S2  ((int)IFIX(0.382683432))
+#define C2  ((int)IFIX(0.923879532))
+#define C4  ((int)IFIX(0.707106781))
+
+#define S22 ((int)IFIX(2 * 0.382683432))
+#define C22 ((int)IFIX(2 * 0.923879532))
+#define IC4 ((int)IFIX(1 / 0.707106781))
+
+#define C3IC1 ((int)IFIX(0.847759065))	/* c3/c1 */
+#define C5IC1 ((int)IFIX(0.566454497))	/* c5/c1 */
+#define C7IC1 ((int)IFIX(0.198912367))	/* c7/c1 */
+
+#define XPP(a,b) (t = a + b, b = a - b, a = t)
+#define XMP(a,b) (t = a - b, b = a + b, a = t)
+#define XPM(a,b) (t = a + b, b = b - a, a = t)
+
+#define ROT(a,b,s,c) (	t = IMULT(a + b, s),	\
+			a = IMULT(a, c - s) + t,	\
+			b = IMULT(b, c + s) - t)
+
+#define IDCT		\
+(			\
+  XPP(t0, t1),		\
+  XMP(t2, t3),		\
+  t2 = IMULT(t2, IC4) - t3,	\
+  XPP(t0, t3),		\
+  XPP(t1, t2),		\
+  XMP(t4, t7),		\
+  XPP(t5, t6),		\
+  XMP(t5, t7),		\
+  t5 = IMULT(t5, IC4),	\
+  ROT(t4, t6, S22, C22),\
+  t6 -= t7,		\
+  t5 -= t6,		\
+  t4 -= t5,		\
+  XPP(t0, t7),		\
+  XPP(t1, t6),		\
+  XPP(t2, t5),		\
+  XPP(t3, t4)		\
+)
+
+static unsigned char zig2[64] = {
+	0, 2, 3, 9, 10, 20, 21, 35,
+	14, 16, 25, 31, 39, 46, 50, 57,
+	5, 7, 12, 18, 23, 33, 37, 48,
+	27, 29, 41, 44, 52, 55, 59, 62,
+	15, 26, 30, 40, 45, 51, 56, 58,
+	1, 4, 8, 11, 19, 22, 34, 36,
+	28, 42, 43, 53, 54, 60, 61, 63,
+	6, 13, 17, 24, 32, 38, 47, 49
+};
+
+void idct( int *in, int *out, int *quant, int off, int max)
+{
+	int t0, t1, t2, t3, t4, t5, t6, t7, t;
+	int tmp[64], *tmpp;
+	int i, j;
+	unsigned char *zig2p;
+
+	t0 = off;
+	if (max == 1) {
+		t0 += in[0] * quant[0];
+		for (i = 0; i < 64; i++)
+			out[i] = ITOINT(t0);
+		return;
+	}
+	zig2p = zig2;
+	tmpp = tmp;
+	for (i = 0; i < 8; i++) {
+		j = *zig2p++;
+		t0 += in[j] * quant[j];
+		j = *zig2p++;
+		t5 = in[j] * quant[j];
+		j = *zig2p++;
+		t2 = in[j] * quant[j];
+		j = *zig2p++;
+		t7 = in[j] * quant[j];
+		j = *zig2p++;
+		t1 = in[j] * quant[j];
+		j = *zig2p++;
+		t4 = in[j] * quant[j];
+		j = *zig2p++;
+		t3 = in[j] * quant[j];
+		j = *zig2p++;
+		t6 = in[j] * quant[j];
+		IDCT;
+		tmpp[0 * 8] = t0;
+		tmpp[1 * 8] = t1;
+		tmpp[2 * 8] = t2;
+		tmpp[3 * 8] = t3;
+		tmpp[4 * 8] = t4;
+		tmpp[5 * 8] = t5;
+		tmpp[6 * 8] = t6;
+		tmpp[7 * 8] = t7;
+		tmpp++;
+		t0 = 0;
+	}
+	for (i = 0; i < 8; i++) {
+		t0 = tmp[8 * i + 0];
+		t1 = tmp[8 * i + 1];
+		t2 = tmp[8 * i + 2];
+		t3 = tmp[8 * i + 3];
+		t4 = tmp[8 * i + 4];
+		t5 = tmp[8 * i + 5];
+		t6 = tmp[8 * i + 6];
+		t7 = tmp[8 * i + 7];
+		IDCT;
+		out[8 * i + 0] = ITOINT(t0);
+		out[8 * i + 1] = ITOINT(t1);
+		out[8 * i + 2] = ITOINT(t2);
+		out[8 * i + 3] = ITOINT(t3);
+		out[8 * i + 4] = ITOINT(t4);
+		out[8 * i + 5] = ITOINT(t5);
+		out[8 * i + 6] = ITOINT(t6);
+		out[8 * i + 7] = ITOINT(t7);
+	}
+}
+
+static unsigned char zig[64] = {
+	0, 1, 5, 6, 14, 15, 27, 28,
+	2, 4, 7, 13, 16, 26, 29, 42,
+	3, 8, 12, 17, 25, 30, 41, 43,
+	9, 11, 18, 24, 31, 40, 44, 53,
+	10, 19, 23, 32, 39, 45, 52, 54,
+	20, 22, 33, 38, 46, 51, 55, 60,
+	21, 34, 37, 47, 50, 56, 59, 61,
+	35, 36, 48, 49, 57, 58, 62, 63
+};
+
+static int aaidct[8] = {
+	IFIX(0.3535533906), IFIX(0.4903926402),
+	IFIX(0.4619397663), IFIX(0.4157348062),
+	IFIX(0.3535533906), IFIX(0.2777851165),
+	IFIX(0.1913417162), IFIX(0.0975451610)
+};
+
+
+inline static void idctqtab(unsigned char *qin, int *qout)
+{
+	int i, j;
+
+	for (i = 0; i < 8; i++)
+		for (j = 0; j < 8; j++)
+			qout[zig[i * 8 + j]] = qin[zig[i * 8 + j]] * 
+			  			IMULT(aaidct[i], aaidct[j]);
+}
+
+inline static void scaleidctqtab(int *q, int sc)
+{
+	int i;
+
+	for (i = 0; i < 64; i++)
+		q[i] = IMULT(q[i], sc);
+}
+
+/****************************************************************/
+/**************          color decoder            ***************/
+/****************************************************************/
+
+#define ROUND
+
+/*
+ * YCbCr Color transformation:
+ *
+ * y:0..255   Cb:-128..127   Cr:-128..127
+ *
+ *      R = Y                + 1.40200 * Cr
+ *      G = Y - 0.34414 * Cb - 0.71414 * Cr
+ *      B = Y + 1.77200 * Cb
+ *
+ * =>
+ *      Cr *= 1.40200;
+ *      Cb *= 1.77200;
+ *      Cg = 0.19421 * Cb + .50937 * Cr;
+ *      R = Y + Cr;
+ *      G = Y - Cg;
+ *      B = Y + Cb;
+ *
+ * =>
+ *      Cg = (50 * Cb + 130 * Cr + 128) >> 8;
+ */
+
+inline static void initcol(int q[][64])
+{
+	scaleidctqtab(q[1], IFIX(1.77200));
+	scaleidctqtab(q[2], IFIX(1.40200));
+}
+
+/* This is optimized for the stupid sun SUNWspro compiler. */
+#define STORECLAMP(a,x)				\
+(						\
+  (a) = (x),					\
+  (unsigned int)(x) >= 256 ? 			\
+    ((a) = (x) < 0 ? 0 : 255)			\
+  :						\
+    0						\
+)
+
+#ifdef ROUND
+
+#define CBCRCG(xin)			\
+(						\
+  cb = outc[0 +xin],			\
+  cr = outc[64+xin],			\
+  cg = (50 * cb + 130 * cr + 128) >> 8		\
+)
+
+#else
+
+#define CBCRCG(xin)			\
+(						\
+  cb = outc[0 +xin],			\
+  cr = outc[64+xin],			\
+  cg = (3 * cb + 8 * cr) >> 4			\
+)
+
+#endif
+
+#define PIC(yin, xin, p, xout)			\
+(						\
+  y = outy[(yin) * 8 + xin],			\
+  STORECLAMP(p[(xout) * 3 + r_offset], y + cr),	\
+  STORECLAMP(p[(xout) * 3 + g_offset], y - cg),	\
+  STORECLAMP(p[(xout) * 3 + b_offset], y + cb)	\
+  )
+
+#define PIC_32(yin, xin, p, xout)			\
+(						\
+  y = outy[(yin) * 8 + xin],			\
+  STORECLAMP(p[(xout) * 4 + r_offset], y + cr),	\
+  STORECLAMP(p[(xout) * 4 + g_offset], y - cg),	\
+  STORECLAMP(p[(xout) * 4 + b_offset], y + cb)	\
+  )
+
+static void col221111(int *out, unsigned char *pic, int width, int force_rgb)
+{
+	int i, j, k;
+	unsigned char *pic0, *pic1;
+	int *outy, *outc;
+	int cr, cg, cb, y;
+	int r_offset, g_offset, b_offset;
+
+	pic0 = pic;
+	pic1 = pic + width;
+	outy = out;
+	outc = out + 64 * 4;
+
+	if (force_rgb)
+	{
+		r_offset = 0;
+		g_offset = 1;
+		b_offset = 2;
+	}
+	else 
+	{
+		r_offset = 2;
+		g_offset = 1;
+		b_offset = 0;
+	}
+	
+	for (i = 2; i > 0; i--) {
+		for (j = 4; j > 0; j--) {
+			for (k = 0; k < 8; k++) {
+				CBCRCG(k);
+				PIC(k/4*8+0, (k & 3) * 2 + 0, pic0, k * 2 + 0);
+				PIC(k/4*8+0, (k & 3) * 2 + 1, pic0, k * 2 + 1);
+				PIC(k/4*8+1, (k & 3) * 2 + 0, pic1, k * 2 + 0);
+				PIC(k/4*8+1, (k & 3) * 2 + 1, pic1, k * 2 + 1);
+			}
+			outc += 8;
+			outy += 16;
+			pic0 += 2 * width;
+			pic1 += 2 * width;
+		}
+		outy += 64 * 2 - 16 * 4;
+	}
+}
+
+static void col221111_32(int *out, unsigned char *pic, int width, int force_rgb)
+{
+	int i, j, k;
+	unsigned char *pic0, *pic1;
+	int *outy, *outc;
+	int cr, cg, cb, y;
+	int r_offset, g_offset, b_offset;
+
+	pic0 = pic;
+	pic1 = pic + width;
+	outy = out;
+	outc = out + 64 * 4;
+
+	if (force_rgb)
+	{
+		r_offset = 2;
+		g_offset = 1;
+		b_offset = 0;
+	}
+	else 
+	{
+		r_offset = 0;
+		g_offset = 1;
+		b_offset = 2;
+	}
+	
+	for (i = 2; i > 0; i--) {
+		for (j = 4; j > 0; j--) {
+			for (k = 0; k < 8; k++) {
+				CBCRCG(k);
+				PIC_32(k/4*8+0, (k & 3) * 2 + 0, pic0, k * 2 + 0);
+				PIC_32(k/4*8+0, (k & 3) * 2 + 1, pic0, k * 2 + 1);
+				PIC_32(k/4*8+1, (k & 3) * 2 + 0, pic1, k * 2 + 0);
+				PIC_32(k/4*8+1, (k & 3) * 2 + 1, pic1, k * 2 + 1);
+			}
+			outc += 8;
+			outy += 16;
+			pic0 += 2 * width;
+			pic1 += 2 * width;
+		}
+		outy += 64 * 2 - 16 * 4;
+	}
+}
+
+
+/* Reduce to the necessary minimum. FIXME */
+void init_jpeg_decoder() 
+{
+	unsigned int   i, j, k, l;
+	unsigned int   qIndex = 2;
+	int            tc, th, tt, tac, tdc;
+	unsigned char *ptr;
+
+	/* set up a quantization table */
+	for (i = 0; i < 2; i++)
+	{
+		for (j = 0; j < 64; j++)
+		{
+			quant[i][j] = GsmartQTable[qIndex * 2 + i][j];
+		}
+	}
+
+	/* set up the huffman table */
+	ptr = (unsigned char *) GsmartJPEGHuffmanTable;
+	l   = GSMART_JPG_HUFFMAN_TABLE_LENGTH;
+	while (l > 0)
+	{
+		int           hufflen[16];
+		unsigned char huffvals[256];
+
+		tc = *ptr++;
+		th = tc & 15;
+		tc >>= 4;
+		tt = tc * 2 + th;
+		if (tc > 1 || th > 1)
+		{
+			//printf("died whilst setting up huffman table.\n");
+			//abort();
+		}
+		for (i = 0; i < 16; i++)
+			hufflen[i] = *ptr++;
+		l -= 1 + 16;
+		k = 0;
+		for (i = 0; i < 16; i++)
+		{
+			for (j = 0; j < hufflen[i]; j++)
+				huffvals[k++] = *ptr++;
+			l -= hufflen[i];
+		}
+		dec_makehuff(dhuff + tt, hufflen, huffvals);
+	}
+
+	/* set up the scan table */
+	ptr = (unsigned char *) GsmartJPEGScanTable;
+	for (i = 0; i < 3; i++) {
+		dscans[i].cid = *ptr++;
+		tdc = *ptr++;
+		tac = tdc & 15;
+		tdc >>= 4;
+		if (tdc > 1 || tac > 1)
+		{
+			//printf("died whilst setting up scan table.\n");
+			//abort();
+		}
+		/* for each component */
+		for (j = 0; j < 3; j++)
+			if (comps[j].cid == dscans[i].cid)
+				break;
+		
+		dscans[i].hv = comps[j].hv;
+		dscans[i].tq = comps[j].tq;
+		dscans[i].hudc.dhuff = dec_huffdc + tdc;
+		dscans[i].huac.dhuff = dec_huffac + tac;
+	}
+
+	if (dscans[0].cid != 1 ||
+	    dscans[1].cid != 2 ||
+	    dscans[2].cid != 3)
+	{
+		//printf("invalid cid found.\n");
+		//abort();
+	}
+
+	if (dscans[0].hv != 0x22 ||
+	    dscans[1].hv != 0x11 ||
+	    dscans[2].hv != 0x11)
+	{
+		//printf("invalid hv found.\n");
+		//abort();
+	}
+
+	idctqtab(quant[dscans[0].tq], dquant[0]);
+	idctqtab(quant[dscans[1].tq], dquant[1]);
+	idctqtab(quant[dscans[2].tq], dquant[2]);
+	initcol(dquant);
+	
+	dscans[0].next = 6 - 4;
+	dscans[1].next = 6 - 4 - 1;
+	dscans[2].next = 6 - 4 - 1 - 1;	/* 411 encoding */
+
+}
diff -uN linux-2.4.20/drivers/usb.spca/jpegdecoder.h linux-2.4.20/drivers/usb/jpegdecoder.h
--- linux-2.4.20/drivers/usb.spca/jpegdecoder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/jpegdecoder.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,91 @@
+#ifndef JPEGDECODER_H
+#define JPEGDECODER_H
+
+
+#define ISHIFT 11
+
+#define IFIX(a) ((int)((a) * (1 << ISHIFT) + .5))
+#define IMULT(a, b) (((a) * (b)) >> ISHIFT)
+#define ITOINT(a) ((a) >> ISHIFT)
+
+/* special markers */
+#define M_BADHUFF	-1
+
+struct in {
+	unsigned char *p;
+	unsigned int bits;
+	int left;
+	int marker;
+};
+
+/*********************************/
+struct dec_hufftbl;
+struct enc_hufftbl;
+
+union hufftblp {
+	struct dec_hufftbl *dhuff;
+	struct enc_hufftbl *ehuff;
+};
+
+struct scan {
+	int dc;			/* old dc value */
+
+	union hufftblp hudc;
+	union hufftblp huac;
+	int next;		/* when to switch to next scan */
+
+	int cid;		/* component id */
+	int hv;			/* horiz/vert, copied from comp */
+	int tq;			/* quant tbl, copied from comp */
+};
+
+/*********************************/
+
+#define DECBITS 10		/* seems to be the optimum */
+
+struct dec_hufftbl {
+	int maxcode[17];
+	int valptr[16];
+	unsigned char vals[256];
+	unsigned int llvals[1 << DECBITS];
+};
+
+
+/*********************************/
+
+void idct (int *, int *, int *, int, int);
+/*********************************/
+
+/*********************************/
+struct comp {
+	int cid;
+	int hv;
+	int tq;
+};
+
+#define MAXCOMP 4
+#define ERR_NO_SOI 1
+#define ERR_NOT_8BIT 2
+#define ERR_HEIGHT_MISMATCH 3
+#define ERR_WIDTH_MISMATCH 4
+#define ERR_BAD_WIDTH_OR_HEIGHT 5
+#define ERR_TOO_MANY_COMPPS 6
+#define ERR_ILLEGAL_HV 7
+#define ERR_QUANT_TABLE_SELECTOR 8
+#define ERR_NOT_YCBCR_221111 9
+#define ERR_UNKNOWN_CID_IN_SCAN 10
+#define ERR_NOT_SEQUENTIAL_DCT 11
+#define ERR_WRONG_MARKER 12
+#define ERR_NO_EOI 13
+#define ERR_BAD_TABLES 14
+#define ERR_DEPTH_MISMATCH 15
+
+void init_jpeg_decoder(void);
+int jpeg_decode(unsigned char* pdest, unsigned char* psrc, int width, int height, 
+		 int format, int force_rgb);
+void decode_mcus (struct in *, int *, int, struct scan *, int *);
+void jpeg_reset_input_context(unsigned char *buf);
+
+
+
+#endif /* JPEGDECODER_H */
diff -uN linux-2.4.20/drivers/usb.spca/jpeg_header.h linux-2.4.20/drivers/usb/jpeg_header.h
--- linux-2.4.20/drivers/usb.spca/jpeg_header.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/jpeg_header.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,322 @@
+#ifndef JPEG_HEADER_H
+#define JPEG_HEADER_H
+
+/* 
+ *  Start from 0 -> 588
+ *    7 -  70 : Quantization Table[0]
+ *   72 - 135 : Quantization Table[1]
+ */ 
+#define GSMART_JPG_DEFAULT_HEADER_PART1_LENGTH 136
+#define GSMART_JPG_DEFAULT_HEADER_PART2_LENGTH 420
+#define GSMART_JPG_DEFAULT_HEADER_PART3_LENGTH 33
+#define GSMART_JPG_DEFAULT_HEADER_LENGTH 589
+
+#define GSMART_JPG_HUFFMAN_TABLE_LENGTH 0x1A0
+
+const unsigned char GsmartJPEGHuffmanTable[GSMART_JPG_HUFFMAN_TABLE_LENGTH] =
+{
+	0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x01,0x00,0x03,
+	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
+	0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x10,0x00,0x02,0x01,0x03,0x03,
+	0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,
+	0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,
+	0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,0x24,0x33,0x62,0x72,0x82,
+	0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34,0x35,0x36,
+	0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,
+	0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,
+	0x77,0x78,0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,
+	0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,
+	0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,
+	0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
+	0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0x11,0x00,0x02,
+	0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,0x02,0x77,0x00,0x01,
+	0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,
+	0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,0x15,0x62,
+	0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,0x27,0x28,
+	0x29,0x2A,0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,
+	0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,
+	0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
+	0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,
+	0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,
+	0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xE2,0xE3,
+	0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA
+};
+
+const unsigned char GsmartJPEGScanTable[6] =
+{
+	0x01,0x00,
+	0x02,0x11,
+	0x03,0x11
+};
+
+const unsigned char GsmartJPGDefaultHeaderPart1[GSMART_JPG_DEFAULT_HEADER_PART1_LENGTH] = {   
+	//SOI(Start of Image)
+	0xFF,0xD8,
+	//DQT(Define Quantization Table)
+	0xFF,0xDB,
+	0x00,0x84,
+	0x00,
+	0x05,0x03,0x04,0x04,0x04,0x03,0x05,0x04,0x04,0x04,0x06,0x05,0x05,0x06,0x08,0x0D,
+	0x08,0x08,0x07,0x07,0x08,0x10,0x0C,0x0C,0x0A,0x0D,0x14,0x11,0x15,0x14,0x13,0x11,
+	0x13,0x13,0x16,0x18,0x1F,0x1A,0x16,0x17,0x1E,0x17,0x13,0x13,0x1B,0x25,0x1C,0x1E,
+	0x20,0x21,0x23,0x23,0x23,0x15,0x1A,0x27,0x29,0x26,0x22,0x29,0x1F,0x22,0x23,0X22,
+	0X01,
+	0x05,0x06,0x06,0x08,0x07,0x08,0x10,0x08,0x08,0x10,0x22,0x16,0x13,0x16,0x22,0x22,
+	0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
+	0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
+	0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22
+};
+const unsigned char GsmartJPGDefaultHeaderPart2[GSMART_JPG_DEFAULT_HEADER_PART2_LENGTH] = {   
+	//DHT(Define Huffman Table)
+	0xFF,0xC4,
+	0x01,0xA2,
+	0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x01,0x00,0x03,
+	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
+	0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x10,0x00,0x02,0x01,0x03,0x03,
+	0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,
+	0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,
+	0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,0x24,0x33,0x62,0x72,0x82,
+	0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34,0x35,0x36,
+	0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,
+	0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,
+	0x77,0x78,0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,
+	0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,
+	0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,
+	0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
+	0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0x11,0x00,0x02,
+	0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,0x02,0x77,0x00,0x01,
+	0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,
+	0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,0x15,0x62,
+	0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,0x27,0x28,
+	0x29,0x2A,0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,
+	0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,
+	0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
+	0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,
+	0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,
+	0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xE2,0xE3,
+	0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA
+};
+/*
+ *  5 - 6 : Image Height(H Byte,L Byte)
+ *  7 - 8 : Image Width(H Byte,L Byte)
+ */
+const unsigned char GsmartJPGDefaultHeaderPart3[GSMART_JPG_DEFAULT_HEADER_PART3_LENGTH] = {
+	//SOFn(Start of Frame)
+	0xFF,0xC0,
+	0x00,0x11,
+	0x08,0x00,0x78,0x00,0xA0,0x03,0x01,0x21,0x00,0x02,0x11,0x01,0x03,0x11,0x01,
+	//SOS(Start of Scan)
+	0xFF,0xDA,
+	0x00,0x0C,
+	0x03,0x01,0x00,0x02,0x11,0x03,0x11,0x00,0x3F,0x00
+};
+
+const unsigned char GsmartQTable[22][64]=
+{
+	// index 0, Q50
+	{  16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40,
+       26, 24, 22, 22, 24, 49, 35, 37, 29, 40, 58, 51, 61, 60, 57, 51,
+       56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55, 56, 80,109, 81, 87,
+       95, 98,103,104,103, 62, 77,113,121,112,100,120, 92,101,103, 99 },
+	{  17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99,
+       99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+	   99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+       99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99 },
+
+	// index 1, Q70
+	{  10,  7,  7,  8,  7,  6, 10,  8,  8,  8, 11, 10, 10, 11, 14, 24,
+	   16, 14, 13, 13, 14, 29, 21, 22, 17, 24, 35, 31, 37, 36, 34, 31,
+	   34, 33, 38, 43, 55, 47, 38, 41, 52, 41, 33, 34, 48, 65, 49, 52,
+	   57, 59, 62, 62, 62, 37, 46, 68, 73, 67, 60, 72, 55, 61, 62, 59 },
+	{  10, 11, 11, 14, 13, 14, 28, 16, 16, 28, 59, 40, 34, 40, 59, 59,
+	   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
+	   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
+	   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59 },
+
+	// index 2, Q80
+	{   6,  4,  5,  6,  5,  4,  6,  6,  5,  6,  7,  7,  6,  8, 10, 16,
+	   10, 10,  9,  9, 10, 20, 14, 15, 12, 16, 23, 20, 24, 24, 23, 20,
+	   22, 22, 26, 29, 37, 31, 26, 27, 35, 28, 22, 22, 32, 44, 32, 35,
+	   38, 39, 41, 42, 41, 25, 31, 45, 48, 45, 40, 48, 37, 40, 41, 40 },
+	{   7,  7,  7, 10,  8, 10, 19, 10, 10, 19, 40, 26, 22, 26, 40, 40,
+	   40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+	   40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+	   40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40 },
+
+	// index 3, Q85
+	{   5,  3,  4,  4,  4,  3,  5,  4,  4,  4,  5,  5,  5,  6,  7, 12,
+	    8,  7,  7,  7,  7, 15, 11, 11,  9, 12, 17, 15, 18, 18, 17, 15,
+	   17, 17, 19, 22, 28, 23, 19, 20, 26, 21, 17, 17, 24, 33, 24, 26,
+	   29, 29, 31, 31, 31, 19, 23, 34, 36, 34, 30, 36, 28, 30, 31, 30 },
+	{   5,  5,  5,  7,  6,  7, 14,  8,  8, 14, 30, 20, 17, 20, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30 },
+
+	// index 4, Q90
+	{   3,  2,  2,  3,  2,  2,  3,  3,  3,  3,  4,  3,  3,  4,  5,  8,
+	    5,  5,  4,  4,  5, 10,  7,  7,  6,  8, 12, 10, 12, 12, 11, 10,
+	   11, 11, 13, 14, 18, 16, 13, 14, 17, 14, 11, 11, 16, 22, 16, 17,
+	   19, 20, 21, 21, 21, 12, 15, 23, 24, 22, 20, 24, 18, 20, 21, 20 },
+	{   3,  4,  4,  5,  4,  5,  9,  5,  5,  9, 20, 13, 11, 13, 20, 20,
+	   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+	   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+	   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
+
+	// index 5, Q60
+	{  13,  9, 10, 11, 10,  8, 13, 11, 10, 11, 14, 14, 13, 15, 19, 32,
+	   21, 19, 18, 18, 19, 39, 28, 30, 23, 32, 46, 41, 49, 48, 46, 41,
+	   45, 44, 51, 58, 74, 62, 51, 54, 70, 55, 44, 45, 64, 87, 65, 70,
+	   76, 78, 82, 83, 82, 50, 62, 90, 97, 90, 80, 96, 74, 81, 82, 79 },
+	{  14, 14, 14, 19, 17, 19, 38, 21, 21, 38, 79, 53, 45, 53, 79, 79,
+	   79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
+	   79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
+	   79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79 },
+
+	// index 6, Q25
+	{  32, 22, 24, 28, 24, 20, 32, 28, 26, 28, 36, 34, 32, 38, 48, 80,
+	   52, 48, 44, 44, 48, 98, 70, 74, 58, 80,116,102,122,120,114,102,
+	  112,110,128,144,184,156,128,136,174,138,110,112,160,218,162,174,
+	  190,196,206,208,206,124,154,226,242,224,200,240,184,202,206,198 },
+	{  34, 36, 36, 48, 42, 48, 94, 52, 52, 94,198,132,112,132,198,198,
+	  198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,
+	  198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,
+	  198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198 },
+
+	// index 7, Q95
+	{   2,  1,  1,  1,  1,  1,  2,  1,  1,  1,  2,  2,  2,  2,  2,  4,
+	    3,  2,  2,  2,  2,  5,  4,  4,  3,  4,  6,  5,  6,  6,  6,  5,
+	    6,  6,  6,  7,  9,  8,  6,  7,  9,  7,  6,  6,  8, 11,  8,  9,
+	   10, 10, 10, 10, 10,  6,  8, 11, 12, 11, 10, 12,  9, 10, 10, 10 },
+	{   2,  2,  2,  2,  2,  2,  5,  3,  3,  5, 10,  7,  6,  7, 10, 10,
+	   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+	   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+	   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
+
+	// index 8, Q93
+	{   2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  3,  2,  2,  3,  3,  6,
+	    4,  3,  3,  3,  3,  7,  5,  5,  4,  6,  8,  7,  9,  8,  8,  7,
+	    8,  8,  9, 10, 13, 11,  9, 10, 12, 10,  8,  8, 11, 15, 11, 12,
+	   13, 14, 14, 15, 14,  9, 11, 16, 17, 16, 14, 17, 13, 14, 14, 14 },
+	{   2,  3,  3,  3,  3,  3,  7,  4,  4,  7, 14,  9,  8,  9, 14, 14,
+	   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+	   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+	   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14 },
+
+	// index 9, Q40
+	{  20, 14, 15, 18, 15, 13, 20, 18, 16, 18, 23, 21, 20, 24, 30, 50,
+	   33, 30, 28, 28, 30, 61, 44, 46, 36, 50, 73, 64, 76, 75, 71, 64,
+	   70, 69, 80, 90,115, 98, 80, 85,109, 86, 69, 70,100,136,101,109,
+	  119,123,129,130,129, 78, 96,141,151,140,125,150,115,126,129,124 },
+	{  21, 23, 23, 30, 26, 30, 59, 33, 33, 59,124, 83, 70, 83,124,124,
+	  124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,
+	  124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,
+	  124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124 },
+
+	// index 10, pccam300
+	{   5,  3,  3,  5,  7, 12, 15, 18,  4,  4,  4,  6,  8, 17, 18, 17,
+	    4,  4,  5,  7, 12, 17, 21, 17,  4,  5,  7,  9, 15, 26, 24, 19,
+	    5,  7, 11, 17, 20, 33, 31, 23,  7, 11, 17, 19, 24, 31, 34, 28,
+	   15, 19, 23, 26, 31, 36, 36, 30, 22, 28, 29, 29, 34, 30, 31, 30 },
+	{   5,  5,  7, 14, 30, 30, 30, 30,  5,  6,  8, 20, 30, 30, 30, 30,
+	    7,  8, 17, 30, 30, 30, 30, 30, 14, 20, 30, 30, 30, 30, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30 }
+};
+
+const unsigned char GsmartOriginal_QTable_4NF_M[18][64]=	//not Z-Z
+{
+	// index 0, Q50
+	{  16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55,
+	   14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62,
+	   18, 22, 37, 56, 68,109,103, 77, 24, 35, 55, 64, 81,104,113, 92,
+	   49, 64, 78, 87,103,121,120,101, 72, 92, 95, 98,112,100,103, 99 },
+	{  17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99,
+	   24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99,
+	   99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+	   99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99 },
+
+	// index 1, Q70
+	{  10,  7,  6, 10, 14, 24, 31, 37,  7,  7,  8, 11, 16, 35, 36, 33,
+	    8,  8, 10, 14, 24, 34, 41, 34,  8, 10, 13, 17, 31, 52, 48, 37,
+	   11, 13, 22, 34, 41, 65, 62, 46, 14, 21, 33, 38, 49, 62, 68, 55,
+	   29, 38, 47, 52, 62, 73, 72, 61, 43, 55, 57, 59, 67, 60, 62, 59 },
+	{  10, 11, 14, 28, 59, 59, 59, 59, 11, 13, 16, 40, 59, 59, 59, 59,
+	   14, 16, 34, 59, 59, 59, 59, 59, 28, 40, 59, 59, 59, 59, 59, 59,
+	   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
+	   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59 },
+
+	// index 2, Q80
+	{   6,  4,  4,  6, 10, 16, 20, 24,  5,  5,  6,  8, 10, 23, 24, 22,
+        6,  5,  6, 10, 16, 23, 28, 22,  6,  7,  9, 12, 20, 35, 32, 25,
+        7,  9, 15, 22, 27, 44, 41, 31, 10, 14, 22, 26, 32, 42, 45, 37,
+       20, 26, 31, 35, 41, 48, 48, 40, 29, 37, 38, 39, 45, 40, 41, 40 },
+	{   7,  7, 10, 19, 40, 40, 40, 40,  7,  8, 10, 26, 40, 40, 40, 40,
+       10, 10, 22, 40, 40, 40, 40, 40, 19, 26, 40, 40, 40, 40, 40, 40,
+       40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+       40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40 },
+
+	// index 3, Q85
+	{   5,  3,  3,  5,  7, 12, 15, 18,  4,  4,  4,  6,  8, 17, 18, 17,
+        4,  4,  5,  7, 12, 17, 21, 17,  4,  5,  7,  9, 15, 26, 24, 19,
+        5,  7, 11, 17, 20, 33, 31, 23,  7, 11, 17, 19, 24, 31, 34, 28,
+	   15, 19, 23, 26, 31, 36, 36, 30, 22, 28, 29, 29, 34, 30, 31, 30 },
+	{   5,  5,  7, 14, 30, 30, 30, 30,  5,  6,  8, 20, 30, 30, 30, 30,
+        7,  8, 17, 30, 30, 30, 30, 30, 14, 20, 30, 30, 30, 30, 30, 30,
+       30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
+       30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30 },
+
+	// index 4, Q90
+	{   3,  2,  2,  3,  5,  8, 10, 12,  2,  2,  3,  4,  5, 12, 12, 11,
+	    3,  3,  3,  5,  8, 11, 14, 11,  3,  3,  4,  6, 10, 17, 16, 12,
+	    4,  4,  7, 11, 14, 22, 21, 15,  5,  7, 11, 13, 16, 21, 23, 18,
+	   10, 13, 16, 17, 21, 24, 24, 20, 14, 18, 19, 20, 22, 20, 21, 20 },
+	{   3,  4,  5,  9, 20, 20, 20, 20,  4,  4,  5, 13, 20, 20, 20, 20,
+	    5,  5, 11, 20, 20, 20, 20, 20,  9, 13, 20, 20, 20, 20, 20, 20,
+	   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+	   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
+
+	// index 5, Q60
+	{  13,  9,  8, 13, 19, 32, 41, 49, 10, 10, 11, 15, 21, 46, 48, 44,
+	   11, 10, 13, 19, 32, 46, 55, 45, 11, 14, 18, 23, 41, 70, 64, 50,
+	   14, 18, 30, 45, 54, 87, 82, 62, 19, 28, 44, 51, 65, 83, 90, 74,
+	   39, 51, 62, 70, 82, 97, 96, 81, 58, 74, 76, 78, 90, 80, 82, 79 },
+	{  14, 14, 19, 38, 79, 79, 79, 79, 14, 17, 21, 53, 79, 79, 79, 79,
+	   19, 21, 45, 79, 79, 79, 79, 79, 38, 53, 79, 79, 79, 79, 79, 79,
+	   79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
+	   79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79 },
+
+	// index 6, Q25
+	{  32, 22, 20, 32, 48, 80,102,122, 24, 24, 28, 38, 52,116,120,110,
+	   28, 26, 32, 48, 80,114,138,112, 28, 34, 44, 58,102,174,160,124,
+	   36, 44, 74,112,136,218,206,154, 48, 70,110,128,162,208,226,184,
+	   98,128,156,174,206,242,240,202,144,184,190,196,224,200,206,198 },
+	{  34, 36, 48, 94,198,198,198,198, 36, 42, 52,132,198,198,198,198,
+	   48, 52,112,198,198,198,198,198, 94,132,198,198,198,198,198,198,
+	  198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,
+	  198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198 },
+
+	// index 7, Q95
+	{   2,  1,  1,  2,  2,  4,  5,  6,  1,  1,  1,  2,  3,  6,  6,  6,
+	    1,  1,  2,  2,  4,  6,  7,  6,  1,  2,  2,  3,  5,  9,  8,  6,
+	    2,  2,  4,  6,  7, 11, 10,  8,  2,  4,  6,  6,  8, 10, 11,  9,
+	    5,  6,  8,  9, 10, 12, 12, 10,  7,  9, 10, 10, 11, 10, 10, 10 },
+	{   2,  2,  2,  5, 10, 10, 10, 10,  2,  2,  3,  7, 10, 10, 10, 10,
+	    2,  3,  6, 10, 10, 10, 10, 10,  5,  7, 10, 10, 10, 10, 10, 10,
+	   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+	   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
+
+	// index 8, Q93
+	{   2,  2,  1,  2,  3,  6,  7,  9,  2,  2,  2,  3,  4,  8,  8,  8,
+	    2,  2,  2,  3,  6,  8, 10,  8,  2,  2,  3,  4,  7, 12, 11,  9,
+	    3,  3,  5,  8, 10, 15, 14, 11,  3,  5,  8,  9, 11, 15, 16, 13,
+	    7,  9, 11, 12, 14, 17, 17, 14, 10, 13, 13, 14, 16, 14, 14, 14 },
+	{   2,  3,  3,  7, 14, 14, 14, 14,  3,  3,  4,  9, 14, 14, 14, 14,
+	    3,  4,  8, 14, 14, 14, 14, 14,  7,  9, 14, 14, 14, 14, 14, 14,
+	   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+	   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14 }
+};
+
+#endif /* JPEG_HEADER_H */
diff -uNp t1/drivers/usb/Makefile.du13.orig t1/drivers/usb/Makefile
--- t1/drivers/usb/Makefile.du13.orig	2003-08-01 16:38:44.000000000 +0200
+++ t1/drivers/usb/Makefile	2003-08-01 16:40:03.000000000 +0200
@@ -121,7 +121,9 @@ obj-$(CONFIG_USB_BRLVGER)	+= brlvger.o
 obj-$(CONFIG_USB_LCD)		+= usblcd.o
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= speedtch.o
 obj-$(CONFIG_USB_USBVISION)	+= usbvision.o i2c-algo-usb.o \
- 				saa7111-new.o saa7113-new.o bt819-new.o
+				saa7111-new.o saa7113-new.o bt819-new.o
+obj-$(CONFIG_USB_SPCA50X)	+= spca50x.o jpegdecoder.o
+
 # Object files in subdirectories
 mod-subdirs	:= serial host ov511
 
diff -uN linux-2.4.20/drivers/usb.spca/spca500_init.h linux-2.4.20/drivers/usb/spca500_init.h
--- linux-2.4.20/drivers/usb.spca/spca500_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/spca500_init.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,100 @@
+/*
+ * SPCA500 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA500_INIT_H
+#define SPCA500_INIT_H
+
+static unsigned char spca500_pccam_qtable[2][64] =
+{
+  { /* Q-table Y-components */
+    0x05, 0x03, 0x03, 0x05, 0x07, 0x0c, 0x0f, 0x12,
+    0x04, 0x04, 0x04, 0x06, 0x08, 0x11, 0x12, 0x11,
+    0x04, 0x04, 0x05, 0x07, 0x0c, 0x11, 0x15, 0x11,
+    0x04, 0x05, 0x07, 0x09, 0x0f, 0x1a, 0x18, 0x13,
+    0x05, 0x07, 0x0b, 0x11, 0x14, 0x21, 0x1f, 0x17,
+    0x07, 0x0b, 0x11, 0x13, 0x18, 0x1f, 0x22, 0x1c,
+    0x0f, 0x13, 0x17, 0x1a, 0x1f, 0x24, 0x24, 0x1e,
+    0x16, 0x1c, 0x1d, 0x1d, 0x22, 0x1e, 0x1f, 0x1e
+  },
+  { /* Q-table C-components */
+    0x05, 0x05, 0x07, 0x0e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x05, 0x06, 0x08, 0x14, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x07, 0x08, 0x11, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x0e, 0x14, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e
+  }
+};
+
+static unsigned char spca500_ez200_qtable[2][64] =
+{
+  { /* Q-table Y-components */
+    0x02, 0x01, 0x01, 0x02, 0x02, 0x04, 0x05, 0x06,
+    0x01, 0x01, 0x01, 0x02, 0x03, 0x06, 0x06, 0x06,
+    0x01, 0x01, 0x02, 0x02, 0x04, 0x06, 0x07, 0x06,
+    0x01, 0x02, 0x02, 0x03, 0x05, 0x09, 0x08, 0x06,
+    0x02, 0x02, 0x04, 0x06, 0x07, 0x0b, 0x0a, 0x08,
+    0x02, 0x04, 0x06, 0x06, 0x08, 0x0a, 0x0b, 0x09,
+    0x05, 0x06, 0x08, 0x09, 0x0a, 0x0c, 0x0c, 0x0a,
+    0x07, 0x09, 0x0a, 0x0a, 0x0b, 0x0a, 0x0a, 0x0a
+  },
+  { /* Q-table C-components */
+    0x02, 0x02, 0x02, 0x05, 0x0a, 0x0a, 0x0a, 0x0a,
+    0x02, 0x02, 0x03, 0x07, 0x0a, 0x0a, 0x0a, 0x0a,
+    0x02, 0x03, 0x06, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+    0x05, 0x07, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a
+  }
+};
+
+#if 0
+static __u16 spca500_read_stats[][3] = {
+  { 0x0c, 0x0000, 0x0000 },
+  { 0x30, 0x03fd, 0x0001 },
+  /* possible values for following call: 0x01b3, 0x01e6, 0x01f7, 0x0218 */
+  { 0x30, 0x01b3, 0x0002 },
+  /* possible values for following call: 0x0000, 0x0001, 0x0002 */
+  { 0x30, 0x0000, 0x0003 },
+  { 0x30, 0x003b, 0x0004 },
+  /* possible values for following call: 0x00aa, 0x00e0 */
+  { 0x30, 0x00e0, 0x0005 },
+  { 0x30, 0x0001, 0x0006 },
+  { 0x30, 0x0080, 0x0007 },
+  { 0x30, 0x0004, 0x0000 },
+  { 0,0,0 }
+};
+#endif
+
+static __u16 spca500_visual_defaults[][3] = {
+  { 0x00, 0x0003, 0x816b }, /* SSI not active sync with vsync,
+                             * hue (H byte) = 0,
+                             * saturation/hue enable,
+                             * brightness/contrast enable.
+                             */
+  { 0x00, 0x0000, 0x8167 }, /* brightness = 0 */
+  { 0x00, 0x0020, 0x8168 }, /* contrast = 0 */
+  { 0x00, 0x0003, 0x816b }, /* SSI not active sync with vsync,
+                             * hue (H byte) = 0, saturation/hue enable,
+                             * brightness/contrast enable.
+                             * was 0x0003, now 0x0000.
+                             */
+  { 0x00, 0x0000, 0x816a }, /* hue (L byte) = 0 */
+  { 0x00, 0x0020, 0x8169 }, /* saturation = 0x20 */
+  { 0x00, 0x0050, 0x8157 }, /* edge gain high threshold */
+  { 0x00, 0x0030, 0x8158 }, /* edge gain low threshold */
+  { 0x00, 0x0028, 0x8159 }, /* edge bandwidth high threshold */
+  { 0x00, 0x000a, 0x815a }, /* edge bandwidth low threshold */
+  { 0x00, 0x0001, 0x8202 }, /* clock rate compensation = 1/25 sec/frame */
+  { 0x0c, 0x0004, 0x0000 },
+  /* set interface */
+
+  { 0,0,0 }
+};
+
+#endif /* SPCA500_INIT_H */
diff -uN linux-2.4.20/drivers/usb.spca/spca501_init.h linux-2.4.20/drivers/usb/spca501_init.h
--- linux-2.4.20/drivers/usb.spca/spca501_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/spca501_init.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,501 @@
+/* 
+ * SPCA501 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA501_INIT_H
+#define SPCA501_INIT_H
+
+/*
+ * Data to initialize a SPCA501. From a capture file provided by Bill Roehl
+ * With SPCA501 chip description
+ */
+
+#define CCDSP_SET  // set CCDSP parameters
+#define TG_SET     // set time generator set
+#undef DSPWIN_SET  // set DSP windows parameters
+#undef ALTER_GAMA  // Set alternate set to YUV transform coeffs.
+
+/* Data for video camera initialization before capturing */
+static __u16 spca501_open_data[][3]=
+{
+	/* bmRequest,value,index */
+
+	{ 0x2, 0x50, 0x0 }, //C/S enable soft reset
+	{ 0x2, 0x40, 0x0 }, //C/S disable soft reset
+	{ 0x2, 0x02, 0x5 }, //C/S general purpose I/O data
+	{ 0x2, 0x03, 0x5 }, //C/S general purpose I/O data
+
+#ifdef CCDSP_SET
+	{ 0x1, 0x38, 0x1 }, // CCDSP options
+	{ 0x1, 0x05, 0x2 }, // CCDSP Optical black level for user settings
+	{ 0x1, 0xC0, 0x3 }, // CCDSP Optical black settings
+
+	{ 0x1, 0x67, 0x7 },
+	{ 0x1, 0x63, 0x3f }, // CCDSP CCD gamma enable
+	{ 0x1, 0x03, 0x56 }, // Add gamma correction
+
+	{ 0x1, 0xFF, 0x15 }, //CCDSP High luminance for white balance
+	{ 0x1, 0x01, 0x16 }, //CCDSP Low luminance for white balance
+
+	/* Color correction and RGB-to-YUV transformation coefficients changing */
+#ifdef ALTER_GAMA
+	{ 0x0, 0x00, 0x08 }, //A11
+	{ 0x0, 0x00, 0x09 }, //A12
+	{ 0x0, 0x90, 0x0A }, //A13
+	{ 0x0, 0x12, 0x0B }, //A21
+	{ 0x0, 0x00, 0x0C }, //A22
+	{ 0x0, 0x00, 0x0D }, //A23
+	{ 0x0, 0x00, 0x0E }, //A31
+	{ 0x0, 0x02, 0x0F }, //A32
+	{ 0x0, 0x00, 0x10 }, //A33
+#else
+	{ 0x1, 0x31, 0x08 }, //A11
+	{ 0x1, 0x00, 0x09 }, //A12
+	{ 0x1, 0x00, 0x0A }, //A13
+	{ 0x1, 0x00, 0x0B }, //A21
+	{ 0x1, 0x14, 0x0C }, //A22
+	{ 0x1, 0x00, 0x0D }, //A23
+	{ 0x1, 0x00, 0x0E }, //A31
+	{ 0x1, 0x00, 0x0F }, //A32
+	{ 0x1, 0x1E, 0x10 }, //A33
+#endif
+	{ 0x1, 0x00, 0x11 }, // R offset
+	{ 0x1, 0x00, 0x12 }, // G offset
+	{ 0x1, 0x00, 0x13 }, // B offset
+	{ 0x1, 0x00, 0x14 }, // GB offset
+
+#endif
+	
+#ifdef TG_SET
+	/* Time generator manipulations */
+	{ 0x0, 0xfc, 0x0 }, // Set up high bits of shutter speed
+	{ 0x0, 0x01, 0x1 }, // Set up low bits of shutter speed
+	
+	{ 0x0, 0xe4, 0x04 }, // DCLK*2 clock phase adjustment
+	{ 0x0, 0x08, 0x05 }, // ADCK phase adjustment, inv. ext. VB
+	{ 0x0, 0x03, 0x06 }, // FR phase adjustment
+	{ 0x0, 0x01, 0x07 }, // FCDS phase adjustment
+	{ 0x0, 0x39, 0x08 }, // FS phase adjustment
+	{ 0x0, 0x88, 0x0a }, // FH1 phase and delay adjustment
+	{ 0x0, 0x03, 0x0f }, // pixel identification
+	{ 0x0, 0x00, 0x11 }, // clock source selection (default)
+	
+	/*VERY strange manipulations with 
+	 * select DMCLP or OBPX to be ADCLP output (0x0C)
+	 * OPB always toggle or not (0x0D) but they allow
+	 * us to set up brightness
+	 */
+	{ 0x0, 0x01, 0x0c }, 
+	{ 0x0, 0xe0, 0x0d }, 
+	/* Done */
+#endif
+
+#ifdef DSPWIN_SET
+	{ 0x1, 0xa0, 0x01 }, //Setting image processing parameters
+  { 0x1, 0x1c, 0x17 }, //Changing Windows positions X1
+  { 0x1, 0xe2, 0x19 }, //X2
+  { 0x1, 0x1c, 0x1b }, //X3
+  { 0x1, 0xe2, 0x1d }, //X4
+  { 0x1, 0x5f, 0x1f }, //X5
+  { 0x1, 0x32, 0x20 }, //Y5
+  { 0x1, 0x01, 0x10 }, //Changing A33
+#endif
+  
+	{ 0x2, 0x204a, 0x07 }, //Setting video compression & resolution 160x120
+	{ 0x2, 0x94, 0x06 },  //Setting video no compression
+  {0,0,0}
+};
+
+/*
+   The SPCAxxx docs from Sunplus document these values
+   in tables, one table per register number.  In the data
+   below, dmRequest is the register number, index is the Addr,
+   and value is a combination of Bit values.  
+   Bit  Value (hex)
+   0    01
+   1    02
+   2    04
+   3    08
+   4    10
+   5    20
+   6    40
+   7    80
+ */
+
+/* Data for chip initialization (set default values) */
+static __u16 spca501_init_data[][3]=
+{
+	/* Set all the values to powerup defaults */
+  /* bmRequest,value,index */
+	{ 0x0, 0xAA, 0x00 },
+	{ 0x0, 0x02, 0x01 },
+	{ 0x0, 0x01, 0x02 },
+	{ 0x0, 0x02, 0x03 },
+	{ 0x0, 0xCE, 0x04 },
+	{ 0x0, 0x00, 0x05 },
+	{ 0x0, 0x00, 0x06 },
+	{ 0x0, 0x00, 0x07 },
+	{ 0x0, 0x00, 0x08 },
+	{ 0x0, 0x00, 0x09 },
+	{ 0x0, 0x90, 0x0A },
+	{ 0x0, 0x12, 0x0B },
+	{ 0x0, 0x00, 0x0C },
+	{ 0x0, 0x00, 0x0D },
+	{ 0x0, 0x00, 0x0E },
+	{ 0x0, 0x02, 0x0F },
+	{ 0x0, 0x00, 0x10 },
+	{ 0x0, 0x00, 0x11 },
+	{ 0x0, 0x00, 0x12 },
+	{ 0x0, 0x00, 0x13 },
+	{ 0x0, 0x00, 0x14 },
+	{ 0x0, 0x00, 0x15 },
+	{ 0x0, 0x00, 0x16 },
+	{ 0x0, 0x00, 0x17 },
+	{ 0x0, 0x00, 0x18 },
+	{ 0x0, 0x00, 0x19 },
+	{ 0x0, 0x00, 0x1A },
+	{ 0x0, 0x00, 0x1B },
+	{ 0x0, 0x00, 0x1C },
+	{ 0x0, 0x00, 0x1D },
+	{ 0x0, 0x00, 0x1E },
+	{ 0x0, 0x00, 0x1F },
+	{ 0x0, 0x00, 0x20 },
+	{ 0x0, 0x00, 0x21 },
+	{ 0x0, 0x00, 0x22 },
+	{ 0x0, 0x00, 0x23 },
+	{ 0x0, 0x00, 0x24 },
+	{ 0x0, 0x00, 0x25 },
+	{ 0x0, 0x00, 0x26 },
+	{ 0x0, 0x00, 0x27 },
+	{ 0x0, 0x00, 0x28 },
+	{ 0x0, 0x00, 0x29 },
+	{ 0x0, 0x00, 0x2A },
+	{ 0x0, 0x00, 0x2B },
+	{ 0x0, 0x00, 0x2C },
+	{ 0x0, 0x00, 0x2D },
+	{ 0x0, 0x00, 0x2E },
+	{ 0x0, 0x00, 0x2F },
+	{ 0x0, 0x00, 0x30 },
+	{ 0x0, 0x00, 0x31 },
+	{ 0x0, 0x00, 0x32 },
+	{ 0x0, 0x00, 0x33 },
+	{ 0x0, 0x00, 0x34 },
+	{ 0x0, 0x00, 0x35 },
+	{ 0x0, 0x00, 0x36 },
+	{ 0x0, 0x00, 0x37 },
+	{ 0x0, 0x00, 0x38 },
+	{ 0x0, 0x00, 0x39 },
+	{ 0x0, 0x00, 0x3A },
+	{ 0x0, 0x00, 0x3B },
+	{ 0x0, 0x00, 0x3C },
+	{ 0x0, 0x00, 0x3D },
+	{ 0x0, 0x00, 0x3E },
+	{ 0x0, 0x00, 0x3F },
+	{ 0x0, 0x00, 0x40 },
+	{ 0x0, 0x00, 0x41 },
+	{ 0x0, 0x00, 0x42 },
+	{ 0x0, 0x00, 0x43 },
+	{ 0x0, 0x00, 0x44 },
+	{ 0x0, 0x00, 0x45 },
+	{ 0x0, 0x00, 0x46 },
+	{ 0x0, 0x00, 0x47 },
+	{ 0x0, 0x00, 0x48 },
+	{ 0x0, 0x00, 0x49 },
+	{ 0x0, 0x00, 0x4A },
+	{ 0x0, 0x00, 0x4B },
+	{ 0x0, 0x00, 0x4C },
+	{ 0x0, 0x00, 0x4D },
+	{ 0x0, 0x00, 0x4E },
+	{ 0x0, 0x00, 0x4F },
+	{ 0x0, 0x00, 0x50 },
+	{ 0x0, 0x00, 0x51 },
+	{ 0x0, 0x00, 0x52 },
+	{ 0x0, 0x00, 0x53 },
+	{ 0x0, 0x00, 0x54 },
+	{ 0x0, 0x00, 0x55 },
+	{ 0x0, 0x00, 0x56 },
+	{ 0x0, 0x00, 0x57 },
+	{ 0x0, 0x00, 0x58 },
+	{ 0x0, 0x00, 0x59 },
+	{ 0x0, 0x00, 0x5A },
+	{ 0x0, 0x00, 0x5B },
+	{ 0x0, 0x00, 0x5C },
+	{ 0x0, 0x00, 0x5D },
+	{ 0x0, 0x00, 0x5E },
+	{ 0x0, 0x00, 0x5F },
+	{ 0x0, 0x00, 0x60 },
+	{ 0x0, 0x00, 0x61 },
+	{ 0x0, 0x00, 0x62 },
+	{ 0x0, 0x00, 0x63 },
+	{ 0x0, 0x00, 0x64 },
+	{ 0x0, 0x00, 0x65 },
+	{ 0x0, 0x00, 0x66 },
+	{ 0x0, 0x00, 0x67 },
+	{ 0x0, 0x00, 0x68 },
+	{ 0x0, 0x00, 0x69 },
+	{ 0x0, 0x00, 0x6A },
+	{ 0x0, 0x00, 0x6B },
+	{ 0x0, 0x00, 0x6C },
+	{ 0x0, 0x00, 0x6D },
+	{ 0x0, 0x00, 0x6E },
+	{ 0x0, 0x00, 0x6F },
+	{ 0x0, 0x00, 0x70 },
+	{ 0x0, 0x00, 0x71 },
+	{ 0x0, 0x00, 0x72 },
+	{ 0x0, 0x00, 0x73 },
+	{ 0x0, 0x00, 0x74 },
+	{ 0x0, 0x00, 0x75 },
+	{ 0x0, 0x00, 0x76 },
+	{ 0x0, 0x00, 0x77 },
+	{ 0x0, 0x00, 0x78 },
+	{ 0x0, 0x00, 0x79 },
+	{ 0x0, 0x00, 0x7A },
+	{ 0x0, 0x00, 0x7B },
+	{ 0x0, 0x00, 0x7C },
+	{ 0x0, 0x00, 0x7D },
+	{ 0x0, 0x00, 0x7E },
+	{ 0x0, 0x00, 0x7F },
+	{ 0x0, 0x00, 0x80 },
+	{ 0x0, 0x00, 0x81 },
+	{ 0x0, 0x00, 0x82 },
+	{ 0x0, 0x00, 0x83 },
+	{ 0x0, 0x00, 0x84 },
+	{ 0x0, 0x00, 0x85 },
+	{ 0x0, 0x00, 0x86 },
+	{ 0x0, 0x00, 0x87 },
+	{ 0x0, 0x00, 0x88 },
+	{ 0x0, 0x00, 0x89 },
+	{ 0x0, 0x00, 0x8A },
+	{ 0x0, 0x00, 0x8B },
+	{ 0x0, 0x00, 0x8C },
+	{ 0x0, 0x00, 0x8D },
+	{ 0x0, 0x00, 0x8E },
+	{ 0x0, 0x00, 0x8F },
+	{ 0x0, 0x00, 0x90 },
+	{ 0x0, 0x00, 0x91 },
+	{ 0x0, 0x00, 0x92 },
+	{ 0x0, 0x00, 0x93 },
+	{ 0x0, 0x00, 0x94 },
+	{ 0x0, 0x00, 0x95 },
+	{ 0x0, 0x00, 0x96 },
+	{ 0x0, 0x00, 0x97 },
+	{ 0x0, 0x00, 0x98 },
+	{ 0x0, 0x00, 0x99 },
+	{ 0x0, 0x00, 0x9A },
+	{ 0x0, 0x00, 0x9B },
+	{ 0x0, 0x00, 0x9C },
+	{ 0x0, 0x00, 0x9D },
+	{ 0x0, 0x00, 0x9E },
+	{ 0x0, 0x00, 0x9F },
+	{ 0x0, 0x00, 0xA0 },
+	{ 0x0, 0x00, 0xA1 },
+	{ 0x0, 0x00, 0xA2 },
+	{ 0x0, 0x00, 0xA3 },
+	{ 0x0, 0x00, 0xA4 },
+	{ 0x0, 0x00, 0xA5 },
+	{ 0x0, 0x00, 0xA6 },
+	{ 0x0, 0x00, 0xA7 },
+	{ 0x0, 0x00, 0xA8 },
+	{ 0x0, 0x00, 0xA9 },
+	{ 0x0, 0x00, 0xAA },
+	{ 0x0, 0x00, 0xAB },
+	{ 0x0, 0x00, 0xAC },
+	{ 0x0, 0x00, 0xAD },
+	{ 0x0, 0x00, 0xAE },
+	{ 0x0, 0x00, 0xAF },
+	{ 0x0, 0x00, 0xB0 },
+	{ 0x0, 0x00, 0xB1 },
+	{ 0x0, 0x00, 0xB2 },
+	{ 0x0, 0x00, 0xB3 },
+	{ 0x0, 0x00, 0xB4 },
+	{ 0x0, 0x00, 0xB5 },
+	{ 0x0, 0x00, 0xB6 },
+	{ 0x0, 0x00, 0xB7 },
+	{ 0x0, 0x00, 0xB8 },
+	{ 0x0, 0x00, 0xB9 },
+	{ 0x0, 0x00, 0xBA },
+	{ 0x0, 0x00, 0xBB },
+	{ 0x0, 0x00, 0xBC },
+	{ 0x0, 0x00, 0xBD },
+	{ 0x0, 0x00, 0xBE },
+	{ 0x0, 0x00, 0xBF },
+	{ 0x0, 0x00, 0xC0 },
+	{ 0x0, 0x00, 0xC1 },
+	{ 0x0, 0x00, 0xC2 },
+	{ 0x0, 0x00, 0xC3 },
+	{ 0x0, 0x00, 0xC4 },
+	{ 0x0, 0x00, 0xC5 },
+	{ 0x0, 0x00, 0xC6 },
+	{ 0x0, 0x00, 0xC7 },
+	{ 0x0, 0x00, 0xC8 },
+	{ 0x0, 0x00, 0xC9 },
+	{ 0x0, 0x00, 0xCA },
+	{ 0x0, 0x00, 0xCB },
+	{ 0x0, 0x00, 0xCC },
+	{ 0x1, 0xF4, 0x00 },
+	{ 0x1, 0x38, 0x01 },
+	{ 0x1, 0x40, 0x02 },
+	{ 0x1, 0x0A, 0x03 },
+	{ 0x1, 0x40, 0x04 },
+	{ 0x1, 0x40, 0x05 },
+	{ 0x1, 0x40, 0x06 },
+	{ 0x1, 0x67, 0x07 },
+	{ 0x1, 0x31, 0x08 },
+	{ 0x1, 0x00, 0x09 },
+	{ 0x1, 0x00, 0x0A },
+	{ 0x1, 0x00, 0x0B },
+	{ 0x1, 0x14, 0x0C },
+	{ 0x1, 0x00, 0x0D },
+	{ 0x1, 0x00, 0x0E },
+	{ 0x1, 0x00, 0x0F },
+	{ 0x1, 0x1E, 0x10 },
+	{ 0x1, 0x00, 0x11 },
+	{ 0x1, 0x00, 0x12 },
+	{ 0x1, 0x00, 0x13 },
+	{ 0x1, 0x00, 0x14 },
+	{ 0x1, 0xFF, 0x15 },
+	{ 0x1, 0x01, 0x16 },
+	{ 0x1, 0x32, 0x17 },
+	{ 0x1, 0x23, 0x18 },
+	{ 0x1, 0xCE, 0x19 },
+	{ 0x1, 0x23, 0x1A },
+	{ 0x1, 0x32, 0x1B },
+	{ 0x1, 0x8D, 0x1C },
+	{ 0x1, 0xCE, 0x1D },
+	{ 0x1, 0x8D, 0x1E },
+	{ 0x1, 0x00, 0x1F },
+	{ 0x1, 0x00, 0x20 },
+	{ 0x1, 0xFF, 0x3E },
+	{ 0x1, 0x02, 0x3F },
+	{ 0x1, 0x00, 0x40 },
+	{ 0x1, 0x00, 0x41 },
+	{ 0x1, 0x00, 0x42 },
+	{ 0x1, 0x00, 0x43 },
+	{ 0x1, 0x00, 0x44 },
+	{ 0x1, 0x00, 0x45 },
+	{ 0x1, 0x00, 0x46 },
+	{ 0x1, 0x00, 0x47 },
+	{ 0x1, 0x00, 0x48 },
+	{ 0x1, 0x00, 0x49 },
+	{ 0x1, 0x00, 0x4A },
+	{ 0x1, 0x00, 0x4B },
+	{ 0x1, 0x00, 0x4C },
+	{ 0x1, 0x00, 0x4D },
+	{ 0x1, 0x00, 0x4E },
+	{ 0x1, 0x00, 0x4F },
+	{ 0x1, 0x00, 0x50 },
+	{ 0x1, 0x00, 0x51 },
+	{ 0x1, 0x00, 0x52 },
+	{ 0x1, 0x00, 0x53 },
+	{ 0x1, 0x00, 0x54 },
+	{ 0x1, 0x00, 0x55 },
+	{ 0x1, 0x00, 0x56 },
+	{ 0x1, 0x00, 0x57 },
+	{ 0x1, 0x00, 0x58 },
+	{ 0x1, 0x00, 0x59 },
+	{ 0x1, 0x00, 0x5A },
+	{ 0x2, 0x03, 0x00 },
+	{ 0x2, 0x00, 0x01 },
+	{ 0x2, 0x00, 0x05 },
+	{ 0x2, 0x00, 0x06 },
+	{ 0x2, 0x00, 0x07 },
+	{ 0x2, 0x00, 0x10 },
+	{ 0x2, 0x00, 0x11 },
+	/* Strange - looks like the 501 driver doesn't do anything 
+	 * at insert time except read the EEPROM 
+	 */
+	{ 0x0, 0x0, 0x0 } 
+};
+
+/* Data for video camera init before capture.
+ * Capture and decoding by Colin Peart.
+ * This is is for the 3com HomeConnect Lite which is spca501a based.
+ */
+static __u16 spca501_3com_open_data[][3]=
+{
+	/* bmRequest,value,index */
+	{0x2, 0x0050, 0x0000},		//C/S Enable TG soft reset, timing mode=010
+	{0x2, 0x0043, 0x0000},		//C/S Disable TG soft reset, timing mode=010
+	{0x2, 0x0002, 0x0005},		//C/S GPIO
+	{0x2, 0x0003, 0x0005},		//C/S GPIO
+
+#ifdef CCDSP_SET
+	{0x1, 0x0020, 0x0001},		//CCDSP Options
+	
+	{0x1, 0x0020, 0x0002},		//CCDSP Black Level
+	{0x1, 0x006e, 0x0007},		//CCDSP Gamma options
+	{0x1, 0x0090, 0x0015},		//CCDSP Luminance Low
+	{0x1, 0x00ff, 0x0016},		//CCDSP Luminance High
+	{0x1, 0x0003, 0x003F},		//CCDSP Gamma correction toggle
+
+#ifdef ALTER_GAMMA
+	{0x1, 0x0010, 0x0008},		//CCDSP YUV A11 
+	{0x1, 0x0000, 0x0009},		//CCDSP YUV A12 
+	{0x1, 0x0000, 0x000a},		//CCDSP YUV A13 
+	{0x1, 0x0000, 0x000b},		//CCDSP YUV A21 
+	{0x1, 0x0010, 0x000c},		//CCDSP YUV A22 
+	{0x1, 0x0000, 0x000d},		//CCDSP YUV A23 
+	{0x1, 0x0000, 0x000e},		//CCDSP YUV A31 
+	{0x1, 0x0000, 0x000f},		//CCDSP YUV A32 
+	{0x1, 0x0010, 0x0010},		//CCDSP YUV A33 
+	{0x1, 0x0000, 0x0011},		//CCDSP R Offset
+	{0x1, 0x0000, 0x0012},		//CCDSP G Offset
+	{0x1, 0x0001, 0x0013},		//CCDSP B Offset
+	{0x1, 0x0001, 0x0014},		//CCDSP BG Offset
+	{0x1, 0x003f, 0x00C1},		//CCDSP Gamma Correction Enable
+#endif
+#endif
+
+#ifdef TG_SET
+	{0x0, 0x00fc, 0x0000},		//TG Shutter Speed High Bits
+	{0x0, 0x0000, 0x0001},		//TG Shutter Speed Low Bits
+	{0x0, 0x00e4, 0x0004},		//TG DCLK*2 Adjust
+	{0x0, 0x0008, 0x0005},		//TG ADCK Adjust
+	{0x0, 0x0003, 0x0006},		//TG FR Phase Adjust
+	{0x0, 0x0001, 0x0007},		//TG FCDS Phase Adjust
+	{0x0, 0x0039, 0x0008},		//TG FS Phase Adjust
+	{0x0, 0x0088, 0x000a},		//TG MH1
+	{0x0, 0x0003, 0x000f},		//TG Pixel ID
+
+	/* Like below, unexplained toglleing */
+	{0x0, 0x0080, 0x000c},
+	{0x0, 0x0000, 0x000d},
+	{0x0, 0x0080, 0x000c},
+	{0x0, 0x0004, 0x000d},
+	{0x0, 0x0000, 0x000c},
+	{0x0, 0x0000, 0x000d},
+	{0x0, 0x0040, 0x000c},
+	{0x0, 0x0017, 0x000d},
+	{0x0, 0x00c0, 0x000c},
+	{0x0, 0x0000, 0x000d},
+	{0x0, 0x0080, 0x000c},
+	{0x0, 0x0006, 0x000d},
+	{0x0, 0x0080, 0x000c},
+	{0x0, 0x0004, 0x000d},
+	{0x0, 0x0002, 0x0003},
+#endif
+	
+#ifdef DSPWIN_SET
+	{0x1, 0x001c, 0x0017},		//CCDSP W1 Start X
+	{0x1, 0x00e2, 0x0019},		//CCDSP W2 Start X
+	{0x1, 0x001c, 0x001b},		//CCDSP W3 Start X
+	{0x1, 0x00e2, 0x001d},		//CCDSP W4 Start X
+	{0x1, 0x00aa, 0x001f},		//CCDSP W5 Start X
+	{0x1, 0x0070, 0x0020},		//CCDSP W5 Start Y
+#endif
+	{0x0, 0x0001, 0x0010},		//TG Start Clock
+
+//{0x2, 0x006a, 0x0001},		//C/S Enable ISOSYNCH Packet Engine
+	{0x2, 0x0068, 0x0001},		//C/S Diable ISOSYNCH Packet Engine
+	{0x2, 0x0000, 0x0005},
+	{0x2, 0x0043, 0x0000},		//C/S Set Timing Mode, Disable TG soft reset
+	{0x2, 0x0043, 0x0000},		//C/S Set Timing Mode, Disable TG soft reset
+	{0x2, 0x0002, 0x0005},		//C/S GPIO
+	{0x2, 0x0003, 0x0005},		//C/S GPIO
+	
+	{0x2, 0x006a, 0x0001},		//C/S Enable ISOSYNCH Packet Engine
+	{0,0,0}
+};
+
+#endif /* SPCA501_INIT_H */
+//eof
diff -uN linux-2.4.20/drivers/usb.spca/spca504_init.h linux-2.4.20/drivers/usb/spca504_init.h
--- linux-2.4.20/drivers/usb.spca/spca504_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/spca504_init.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,179 @@
+/* 
+ * SPCA504 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA504_INIT_H
+#define SPCA504_INIT_H
+
+#define IGN(x) /* nothing */
+
+/*
+   Initialization data: this is the first set-up data written to the
+   device (before the open data).
+ */
+#if 0
+static __u16 spca504_init_data[][3]=
+{
+  /*  line   URB    req,  value, index */
+  { 0,0,0 }
+};
+#endif
+
+/*
+ * Data to initialize the camera using the internal CCD
+ */
+static __u16 spca504_open_data[][3]=
+{
+  /* line       bmRequest,value,index */
+/* 
+ *    {0x00, 0x0005, 0x270c},
+ *    {0x00, 0x0005, 0x2310},
+ *    {0x00, 0x0000, 0x21a7},
+ *    {0x00, 0x0020, 0x21a8},
+ *    {0x00, 0x0000, 0x21ad},
+ *    {0x00, 0x0001, 0x21ac},
+ *    {0x00, 0x0020, 0x21ae},
+ *    {0x00, 0x0000, 0x21a3},
+ */
+	/* Write qtables to the camera */
+   {0x00, 0x0005, 0x2800},
+   {0x00, 0x0005, 0x2840},
+   {0x00, 0x0003, 0x2801},
+   {0x00, 0x0005, 0x2841},
+   {0x00, 0x0003, 0x2802},
+   {0x00, 0x0007, 0x2842},
+   {0x00, 0x0005, 0x2803},
+   {0x00, 0x000e, 0x2843},
+   {0x00, 0x0007, 0x2804},
+   {0x00, 0x001e, 0x2844},
+   {0x00, 0x000c, 0x2805},
+   {0x00, 0x001e, 0x2845},
+   {0x00, 0x000f, 0x2806},
+   {0x00, 0x001e, 0x2846},
+   {0x00, 0x0012, 0x2807},
+   {0x00, 0x001e, 0x2847},
+   {0x00, 0x0004, 0x2808},
+   {0x00, 0x0005, 0x2848},
+   {0x00, 0x0004, 0x2809},
+   {0x00, 0x0006, 0x2849},
+   {0x00, 0x0004, 0x280a},
+   {0x00, 0x0008, 0x284a},
+   {0x00, 0x0006, 0x280b},
+   {0x00, 0x0014, 0x284b},
+   {0x00, 0x0008, 0x280c},
+   {0x00, 0x001e, 0x284c},
+   {0x00, 0x0011, 0x280d},
+   {0x00, 0x001e, 0x284d},
+   {0x00, 0x0012, 0x280e},
+   {0x00, 0x001e, 0x284e},
+   {0x00, 0x0011, 0x280f},
+   {0x00, 0x001e, 0x284f},
+   {0x00, 0x0004, 0x2810},
+   {0x00, 0x0007, 0x2850},
+   {0x00, 0x0004, 0x2811},
+   {0x00, 0x0008, 0x2851},
+   {0x00, 0x0005, 0x2812},
+   {0x00, 0x0011, 0x2852},
+   {0x00, 0x0007, 0x2813},
+   {0x00, 0x001e, 0x2853},
+   {0x00, 0x000c, 0x2814},
+   {0x00, 0x001e, 0x2854},
+   {0x00, 0x0011, 0x2815},
+   {0x00, 0x001e, 0x2855},
+   {0x00, 0x0015, 0x2816},
+   {0x00, 0x001e, 0x2856},
+   {0x00, 0x0011, 0x2817},
+   {0x00, 0x001e, 0x2857},
+   {0x00, 0x0004, 0x2818},
+   {0x00, 0x000e, 0x2858},
+   {0x00, 0x0005, 0x2819},
+   {0x00, 0x0014, 0x2859},
+   {0x00, 0x0007, 0x281a},
+   {0x00, 0x001e, 0x285a},
+   {0x00, 0x0009, 0x281b},
+   {0x00, 0x001e, 0x285b},
+   {0x00, 0x000f, 0x281c},
+   {0x00, 0x001e, 0x285c},
+   {0x00, 0x001a, 0x281d},
+   {0x00, 0x001e, 0x285d},
+   {0x00, 0x0018, 0x281e},
+   {0x00, 0x001e, 0x285e},
+   {0x00, 0x0013, 0x281f},
+   {0x00, 0x001e, 0x285f},
+   {0x00, 0x0005, 0x2820},
+   {0x00, 0x001e, 0x2860},
+   {0x00, 0x0007, 0x2821},
+   {0x00, 0x001e, 0x2861},
+   {0x00, 0x000b, 0x2822},
+   {0x00, 0x001e, 0x2862},
+   {0x00, 0x0011, 0x2823},
+   {0x00, 0x001e, 0x2863},
+   {0x00, 0x0014, 0x2824},
+   {0x00, 0x001e, 0x2864},
+   {0x00, 0x0021, 0x2825},
+   {0x00, 0x001e, 0x2865},
+   {0x00, 0x001f, 0x2826},
+   {0x00, 0x001e, 0x2866},
+   {0x00, 0x0017, 0x2827},
+   {0x00, 0x001e, 0x2867},
+   {0x00, 0x0007, 0x2828},
+   {0x00, 0x001e, 0x2868},
+   {0x00, 0x000b, 0x2829},
+   {0x00, 0x001e, 0x2869},
+   {0x00, 0x0011, 0x282a},
+   {0x00, 0x001e, 0x286a},
+   {0x00, 0x0013, 0x282b},
+   {0x00, 0x001e, 0x286b},
+   {0x00, 0x0018, 0x282c},
+   {0x00, 0x001e, 0x286c},
+   {0x00, 0x001e, 0x286c},
+   {0x00, 0x001f, 0x282d},
+   {0x00, 0x001e, 0x286d},
+   {0x00, 0x0022, 0x282e},
+   {0x00, 0x001e, 0x286e},
+   {0x00, 0x001c, 0x282f},
+   {0x00, 0x001e, 0x286f},
+   {0x00, 0x000f, 0x2830},
+   {0x00, 0x001e, 0x2870},
+   {0x00, 0x0013, 0x2831},
+   {0x00, 0x001e, 0x2871},
+   {0x00, 0x0017, 0x2832},
+   {0x00, 0x001e, 0x2872},
+   {0x00, 0x001a, 0x2833},
+   {0x00, 0x001e, 0x2873},
+   {0x00, 0x001f, 0x2834},
+   {0x00, 0x001e, 0x2874},
+   {0x00, 0x0024, 0x2835},
+   {0x00, 0x001e, 0x2875},
+   {0x00, 0x0024, 0x2836},
+   {0x00, 0x001e, 0x2876},
+   {0x00, 0x001e, 0x2837},
+   {0x00, 0x001e, 0x2877},
+   {0x00, 0x0016, 0x2838},
+   {0x00, 0x001e, 0x2878},
+   {0x00, 0x001c, 0x2839},
+   {0x00, 0x001e, 0x2879},
+   {0x00, 0x001d, 0x283a},
+   {0x00, 0x001e, 0x287a},
+   {0x00, 0x001d, 0x283b},
+   {0x00, 0x001e, 0x287b},
+   {0x00, 0x001d, 0x283c},
+   {0x00, 0x001e, 0x287c},
+   {0x00, 0x001e, 0x283d},
+   {0x00, 0x001e, 0x287d},
+   {0x00, 0x001f, 0x283e},
+   {0x00, 0x001e, 0x287e},
+   {0x00, 0x001e, 0x283f},
+   {0x00, 0x001e, 0x287f}, // that's it ?
+   {0,0,0}
+};
+
+/*
+ * 0x00    0x0000 0x2000
+ * 0x24    0x0000 0x0000
+ * Reset?
+ */
+
+#endif /* SPCA504_INIT_H */
+
+//eof
diff -uN linux-2.4.20/drivers/usb.spca/spca505_init.h linux-2.4.20/drivers/usb/spca505_init.h
--- linux-2.4.20/drivers/usb.spca/spca505_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/spca505_init.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,263 @@
+/* 
+ * SPCA505 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA505_INIT_H
+#define SPCA505_INIT_H
+
+/*
+ * Data to initialize a SPCA505. Common to the CCD and external modes
+ */
+static __u16 spca505_init_data[][3]=
+{
+  /* line       bmRequest,value,index */
+  /* 1819 */ { SPCA50X_REG_GLOBAL,SPCA50X_GMISC3_SAA7113RST,SPCA50X_GLOBAL_MISC3 }, /* Sensor reset */
+  /* 1822 */ { SPCA50X_REG_GLOBAL,0x0,SPCA50X_GLOBAL_MISC3 },
+  /* 1825 */ { SPCA50X_REG_GLOBAL,0x0,SPCA50X_GLOBAL_MISC1 }, /* Block USB reset */
+  /* 1828 */ { SPCA50X_REG_GLOBAL,SPCA50X_GMISC0_IDSEL,SPCA50X_GLOBAL_MISC0 },
+
+  /* 1831 */ { 0x5,0x1,0x10 }, /* Maybe power down some stuff */
+  /* 1834 */ { 0x5,0xf,0x11 },
+
+  /* Setup internal CCD  ? */
+  /* 1837 */ { 0x6,0x10,0x8 },
+  /* 1840 */ { 0x6,0x0,0x9 },
+  /* 1843 */ { 0x6,0x0,0x0a },
+  /* 1846 */ { 0x6,0x0,0x0b },
+  /* 1849 */ { 0x6,0x10,0xc },
+  /* 1852 */ { 0x6,0x0,0xd },
+  /* 1855 */ { 0x6,0x0,0xe },
+  /* 1858 */ { 0x6,0x0,0xf },
+  /* 1861 */ { 0x6,0x10,0x10 },
+  /* 1864 */ { 0x6,0x2,0x11 },
+  /* 1867 */ { 0x6,0x0,0x12 },
+  /* 1870 */ { 0x6,0x4,0x13 },
+  /* 1873 */ { 0x6,0x2,0x14 },
+  /* 1876 */ { 0x6,0x8a,0x51 },
+  /* 1879 */ { 0x6,0x40,0x52 },
+  /* 1882 */ { 0x6,0xb6,0x53 },
+  /* 1885 */ { 0x6,0x3d,0x54 },
+  { 0,0,0 }
+};
+
+/*
+ * Data to initialize the camera using the internal CCD
+ */
+static __u16 spca505_open_data_ccd[][3]=
+{
+  /* line       bmRequest,value,index */
+  /* Internal CCD data set */
+  /* 1891 */ { 0x3,0x4,0x1 }, /* This could be a reset */
+  /* 1894 */ { 0x3,0x0,0x1 },
+
+  /* Setup compression and image registers. 0x6 and 0x7 seem to be
+     related to H&V hold, and are resolution mode specific */
+  /* 1897 */ { 0x4,0x10,0x1 }, /* DIFF(0x50), was (0x10) */
+  /* 1900 */ { 0x4,0x0,0x4 },
+  /* 1903 */ { 0x4,0x0,0x5 },
+  /* 1906 */ { 0x4,0x20,0x6 },
+  /* 1909 */ { 0x4,0x20,0x7 },
+
+  /* 1912 */ { 0x8,0xa,0x0 }, /* DIFF (0x4a), was (0xa) */
+
+  /* 1915 */ { 0x5,0x0,0x10 },
+  /* 1918 */ { 0x5,0x0,0x11 },
+  /* 1921 */ { 0x5,0x0,0x0 }, /* DIFF not written */
+  /* 1924 */ { 0x5,0x0,0x1 }, /* DIFF not written */
+  /* 1927 */ { 0x5,0x0,0x2 }, /* DIFF not written */
+  /* 1930 */ { 0x5,0x0,0x3 }, /* DIFF not written */
+  /* 1933 */ { 0x5,0x0,0x4 }, /* DIFF not written */
+  /* 1936 */ { 0x5,0x80,0x5 }, /* DIFF not written */
+  /* 1939 */ { 0x5,0xe0,0x6 }, /* DIFF not written */
+  /* 1942 */ { 0x5,0x20,0x7 }, /* DIFF not written */
+  /* 1945 */ { 0x5,0xa0,0x8 }, /* DIFF not written */
+  /* 1948 */ { 0x5,0x0,0x12 }, /* DIFF not written */
+  /* 1951 */ { 0x5,0x2,0xf}, /* DIFF not written */
+  /* 1954 */ { 0x5,0x10,0x46 }, /* DIFF not written */
+  /* 1957 */ { 0x5,0x8,0x4a }, /* DIFF not written */
+
+  /* 1960 */ { 0x3,0x8,0x3 },
+			     /* DIFF (0x3,0x28,0x3) */
+  /* 1963 */ { 0x3,0x8,0x1 },
+  /* 1966 */ { 0x3,0xc,0x3 }, /* DIFF not written */
+  /* 1969 */ { 0x3,0x21,0x0 }, /* DIFF (0x39) */
+
+  /* Extra block copied from init to hopefully ensure CCD is in a sane state */
+  /* 1837 */ { 0x6,0x10,0x8 },
+  /* 1840 */ { 0x6,0x0,0x9 },
+  /* 1843 */ { 0x6,0x0,0x0a },
+  /* 1846 */ { 0x6,0x0,0x0b },
+  /* 1849 */ { 0x6,0x10,0xc },
+  /* 1852 */ { 0x6,0x0,0xd },
+  /* 1855 */ { 0x6,0x0,0xe },
+  /* 1858 */ { 0x6,0x0,0xf },
+  /* 1861 */ { 0x6,0x10,0x10 },
+  /* 1864 */ { 0x6,0x2,0x11 },
+  /* 1867 */ { 0x6,0x0,0x12 },
+  /* 1870 */ { 0x6,0x4,0x13 },
+  /* 1873 */ { 0x6,0x2,0x14 },
+  /* 1876 */ { 0x6,0x8a,0x51 },
+  /* 1879 */ { 0x6,0x40,0x52 },
+  /* 1882 */ { 0x6,0xb6,0x53 },
+  /* 1885 */ { 0x6,0x3d,0x54 },
+  /* End of extra block */
+
+  /* 1972 */ { 0x6,0x3f,0x1 }, /* Block skipped */
+  /* 1975 */ { 0x6,0x10,0x2 },
+  /* 1978 */ { 0x6,0x64,0x7 },
+  /* 1981 */ { 0x6,0x10,0x8 },
+  /* 1984 */ { 0x6,0x0,0x9 },
+  /* 1987 */ { 0x6,0x0,0xa },
+  /* 1990 */ { 0x6,0x0,0xb },
+  /* 1993 */ { 0x6,0x10,0xc },
+  /* 1996 */ { 0x6,0x0,0xd },
+  /* 1999 */ { 0x6,0x0,0xe },
+  /* 2002 */ { 0x6,0x0,0xf },
+  /* 2005 */ { 0x6,0x10,0x10 },
+  /* 2008 */ { 0x6,0x2,0x11 },
+  /* 2011 */ { 0x6,0x0,0x12 },
+  /* 2014 */ { 0x6,0x4,0x13 },
+  /* 2017 */ { 0x6,0x2,0x14 },
+  /* 2020 */ { 0x6,0x8a,0x51 },
+  /* 2023 */ { 0x6,0x40,0x52 },
+  /* 2026 */ { 0x6,0xb6,0x53 },
+  /* 2029 */ { 0x6,0x3d,0x54 },
+  /* 2032 */ { 0x6,0x60,0x57 },
+  /* 2035 */ { 0x6,0x20,0x58 },
+  /* 2038 */ { 0x6,0x15,0x59 },
+  /* 2041 */ { 0x6,0x5,0x5a },
+
+  /* 2044 */ { 0x5,0x1,0xc0 },
+  /* 2047 */ { 0x5,0x10,0xcb },
+  /* 2050 */ { 0x5,0x80,0xc1 }, /* */
+  /* 2053 */ { 0x5,0x0,0xc2 }, /* 4 was 0 */
+  /* 2056 */ { 0x5,0x0,0xca },
+  /* 2059 */ { 0x5,0x80,0xc1 }, /*  */
+  /* 2062 */ { 0x5,0x4,0xc2 },
+  /* 2065 */ { 0x5,0x0,0xca },
+  /* 2068 */ { 0x5,0x0,0xc1 }, /*  */
+  /* 2071 */ { 0x5,0x0,0xc2 },
+  /* 2074 */ { 0x5,0x0,0xca },
+  /* 2077 */ { 0x5,0x40,0xc1 }, /* */
+  /* 2080 */ { 0x5,0x17,0xc2 },
+  /* 2083 */ { 0x5,0x0,0xca },
+  /* 2086 */ { 0x5,0x80,0xc1 }, /* */
+  /* 2089 */ { 0x5,0x6,0xc2 },
+  /* 2092 */ { 0x5,0x0,0xca },
+  /* 2095 */ { 0x5,0x80,0xc1 }, /* */
+  /* 2098 */ { 0x5,0x4,0xc2 },
+  /* 2101 */ { 0x5,0x0,0xca },
+
+  /* 2104 */ { 0x3,0x4c,0x3 },
+  /* 2107 */ { 0x3,0x18,0x1 },
+
+  /* 2110 */ { 0x6,0x70,0x51 },
+  /* 2113 */ { 0x6,0xbe,0x53 },
+  /* 2116 */ { 0x6,0x71,0x57 },
+  /* 2119 */ { 0x6,0x20,0x58 },
+  /* 2122 */ { 0x6,0x5,0x59 },
+  /* 2125 */ { 0x6,0x15,0x5a },
+
+  /* 2128 */ { 0x4,0x0,0x8 }, /* Compress = OFF (0x1 to turn on) */
+  /* 2131 */ { 0x4,0x12,0x9 },
+  /* 2134 */ { 0x4,0x21,0xa },
+  /* 2137 */ { 0x4,0x10,0xb },
+  /* 2140 */ { 0x4,0x21,0xc },
+  /* 2143 */ { 0x4,0x5,0x0 }, /* was 5 (Image Type ? )*/
+  /* 2146 */ { 0x4,0x0,0x1 },
+
+  /* 2149 */ { 0x6,0x3f,0x1 },
+
+  /* 2152 */ { 0x4,0x0,0x4 },
+  /* 2155 */ { 0x4,0x0,0x5 },
+  /* 2158 */ { 0x4,0x40,0x6 },
+  /* 2161 */ { 0x4,0x40,0x7 },
+
+  /* 2164 */ { 0x6,0x1c,0x17 },
+  /* 2167 */ { 0x6,0xe2,0x19 },
+  /* 2170 */ { 0x6,0x1c,0x1b },
+  /* 2173 */ { 0x6,0xe2,0x1d },
+  /* 2176 */ { 0x6,0xaa,0x1f },
+  /* 2179 */ { 0x6,0x70,0x20 },
+
+  /* 2182 */ { 0x5,0x1,0x10 },
+  /* 2185 */ { 0x5,0x0,0x11 },
+  /* 2188 */ { 0x5,0x1,0x0 },
+  /* 2191 */ { 0x5,0x5,0x1 },
+  /* 2194 */ { 0x5,0x0,0xc1 }, /* */
+  /* 2197 */ { 0x5,0x0,0xc2 },
+  /* 2200 */ { 0x5,0x0,0xca },
+
+  /* 2203 */ { 0x6,0x70,0x51 },
+  /* 2206 */ { 0x6,0xbe,0x53 },
+  {0,0,0}
+};
+
+/*
+ * Data to initialize the camera in external video mode
+ */
+static __u16 spca505_open_data_ext[][3]= {
+  /* line       bmRequest,value,index */
+  /* External video input dataset */
+  /* 0808 */ { 0x3,0x4,0x1 },
+  /* 0809 */ { 0x3,0x0,0x1 },
+
+  /* 0810 */ { 0x4,0x50,0x1 },
+  /* 0811 */ { 0x4,0x0,0x4 },
+  /* 0812 */ { 0x4,0xa,0x5 },
+  /* 0813 */ { 0x4,0x20,0x6 },
+  /* 0814 */ { 0x4,0x20,0x7 },
+
+  /* 0815 */ { 0x8,0x4a,0x0 },
+
+  /* 0816 */ { 0x5,0x0,0x10 },
+  /* 0817 */ { 0x5,0x0,0x11 },
+
+  /* 0818 */ { 0x3,0x8,0x3 },
+  /* 0819 */ { 0x3,0x28,0x3 },
+  /* 0820 */ { 0x3,0x8,0x1 },
+  /* 0821 */ { 0x3,0x39,0x0 },
+
+  /* 0822 */ { 0x5,0x1,0xc0 },
+  /* 0823 */ { 0x5,0x10,0xcb },
+  /* 0824 */ { 0x5,0x80,0xc1 },
+  /* 0825 */ { 0x5,0x5,0xc2 },
+  /* 0826 */ { 0x5,0x0,0xca },
+  /* 0827 */ { 0x5,0x0,0xc1 },
+  /* 0828 */ { 0x5,0x1,0xc2 },
+  /* 0829 */ { 0x5,0x0,0xca },
+  /* 0830 */ { 0x5,0x1,0x10 },
+  /* 0831 */ { 0x5,0xf,0x11 },
+
+  { 0,0,0 }
+
+};
+
+/*
+ * Additional data needed to initialze the camera in external mode
+ */
+static __u16 spca505_open_data2[][3]=
+{
+  /* line       bmRequest,value,index */
+  /* 1384 */ { 0x3,0x68,0x3 },
+  /* 1385 */ { 0x3,0x10,0x1 },
+  /* 1386 */ { 0x8,0x4a,0x0 },
+  /* 1387 */ { 0x4,0x0,0x8 }, /* was 1 COMPRESSION ENABLE !*/
+  /* 1388 */ { 0x4,0x12,0x9 }, /* Think these are the compression registers */
+  /* 1389 */ { 0x4,0x21,0xa },
+  /* 1390 */ { 0x4,0x10,0xb },
+  /* 1391 */ { 0x4,0x21,0xc },
+  /* 1392 */ { 0x4,0x5,0x0 }, /* This may be the picture type code (5=160x120 as YUV4:2:0) */
+  /* 1393 */ { 0x4,0x0,0x1 },
+  /* 1394 */ { 0x6,0x3f,0x1 },
+  /* 1395 */ { 0x4,0x0,0x4 },
+  /* 1396 */ { 0x4,0xa,0x5 },
+  /* 1397 */ { 0x4,0x40,0x6 }, /* was 40 */
+  /* 1398 */ { 0x4,0x40,0x7 }, /* was 50 */
+  /* 1399 */ { 0x4,0x2,0x5 },
+  /* 1400 */ { 0x4,0x0,0x4 },
+  {0,0,0}
+};
+
+#endif /* SPCA505_INIT_H */
+//eof
diff -uN linux-2.4.20/drivers/usb.spca/spca506_init.h linux-2.4.20/drivers/usb/spca506_init.h
--- linux-2.4.20/drivers/usb.spca/spca506_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/spca506_init.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,96 @@
+/* 
+ * SPCA506 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA506_INIT_H
+#define SPCA506_INIT_H
+
+static __u16 spca506_init_data[][3]=
+{
+  /* line       bmRequest,value,index */
+  /* 1819 */ { SPCA50X_REG_GLOBAL,SPCA50X_GMISC3_SAA7113RST,SPCA50X_GLOBAL_MISC3 }, /* Sensor reset */
+  /* 1822 */ { SPCA50X_REG_GLOBAL,0x0,SPCA50X_GLOBAL_MISC3 },
+  /* 1825 */ { SPCA50X_REG_GLOBAL,0x0,SPCA50X_GLOBAL_MISC1 }, /* Block USB reset */
+  /* 1828 */ { SPCA50X_REG_GLOBAL,SPCA50X_GMISC0_IDSEL,SPCA50X_GLOBAL_MISC0 },
+  { 0,0,0 }
+};
+
+/*
+ * Data to initialize the camera in external video mode
+ */
+static __u16 spca506_open_data_ext[][3]= {
+  /* line       bmRequest,value,index */
+  /* External video input dataset */
+  /* 0808 */ { SPCA50X_REG_GLOBAL,0x4,SPCA50X_GLOBAL_MISC1 },
+  /* 0809 */ { SPCA50X_REG_GLOBAL,0x0,SPCA50X_GLOBAL_MISC1 },
+
+  /* 0810 */ { SPCA50X_REG_COMPRESS,0x10 | SPCA50X_CMISC1_TVFIELDPROCESS,SPCA50X_COMPRESS_MISC1 },
+#if 0
+  /* These registers are reserved on the 506 */
+  /* 0811 */ { SPCA50X_REG_COMPRESS,0x0,0x4 },
+  /* 0812 */ { SPCA50X_REG_COMPRESS,0xa,0x5 },
+  /* 0813 */ { SPCA50X_REG_COMPRESS,0x20,0x6 },
+  /* 0814 */ { SPCA50X_REG_COMPRESS,0x20,0x7 },
+#endif
+
+  /* 0815 */ { SPCA50X_REG_TV,SPCA50X_TMISC0_SINGLECHANNEL | SPCA50X_TMISC0_INVFIELD,SPCA50X_TV_MISC0 }, /* May not be correct */
+
+#if 0
+  /* SPCA506 doesn't have these registers */
+  /* 0816 */ { 0x5,0x0,0x10 },
+  /* 0817 */ { 0x5,0x0,0x11 },
+#endif
+
+  /* 0818 */ { SPCA50X_REG_GLOBAL,0x8,SPCA50X_GLOBAL_MISC3 }, /* Input select ? */
+  /* 0819 */ { SPCA50X_REG_GLOBAL,0x28,SPCA50X_GLOBAL_MISC3 }, /* Enable SAA7113 ? */
+  /* 0820 */ { SPCA50X_REG_GLOBAL,0x8,SPCA50X_GLOBAL_MISC1 }, /* ? */
+  /* 0821 */ { SPCA50X_REG_GLOBAL,0x39,SPCA50X_GLOBAL_MISC0 }, /* ? */
+
+#if 0
+  /* SPCA506 doesn't have these registers */
+  /* 0822 */ { 0x5,0x1,0xc0 },
+  /* 0823 */ { 0x5,0x10,0xcb },
+  /* 0824 */ { 0x5,0x80,0xc1 },
+  /* 0825 */ { 0x5,0x5,0xc2 },
+  /* 0826 */ { 0x5,0x0,0xca },
+  /* 0827 */ { 0x5,0x0,0xc1 },
+  /* 0828 */ { 0x5,0x1,0xc2 },
+  /* 0829 */ { 0x5,0x0,0xca },
+  /* 0830 */ { 0x5,0x1,0x10 },
+  /* 0831 */ { 0x5,0xf,0x11 },
+#endif
+  { 0,0,0 }
+
+};
+
+/*
+ * Additional data needed to initialze the camera in external mode
+ */
+static __u16 spca506_open_data2[][3]=
+{
+  /* line       bmRequest,value,index */
+  /* 1384 */ { 0x3,0x68,0x3 },
+  /* 1385 */ { 0x3,0x10,0x1 },
+  /* 1386 */ { 0x8,0x4a,0x0 },
+  /* 1387 */ { SPCA50X_REG_COMPRESS,0x0,SPCA50X_COMPRESS_ENABLE }, /* was 1 COMPRESSION ENABLE !*/
+  /* 1388 */ { SPCA50X_REG_COMPRESS,0x12,0x9 }, /* Think these are the compression registers */
+  /* 1389 */ { SPCA50X_REG_COMPRESS,0x21,0xa },
+  /* 1390 */ { SPCA50X_REG_COMPRESS,0x10,0xb },
+  /* 1391 */ { SPCA50X_REG_COMPRESS,0x21,0xc },
+  /* 1392 */ { SPCA50X_REG_COMPRESS,0x5,0x0 }, /* This may be the picture type code (5=160x120 as YUV4:2:0) */
+  /* 1393 */ { SPCA50X_REG_COMPRESS,0x0,0x1 },
+#if 0
+  /* SPCA506 doesn't have these registers */
+  /* 1394 */ { 0x6,0x3f,0x1 },
+  /* 1395 */ { 0x4,0x0,0x4 },
+  /* 1396 */ { 0x4,0xa,0x5 },
+  /* 1397 */ { 0x4,0x40,0x6 },
+  /* 1398 */ { 0x4,0x40,0x7 },
+  /* 1399 */ { 0x4,0x2,0x5 },
+  /* 1400 */ { 0x4,0x0,0x4 },
+#endif
+  {0,0,0}
+};
+
+#endif /* SPCA506_INIT_H */
+//eof
diff -uN linux-2.4.20/drivers/usb.spca/spca508_init.h linux-2.4.20/drivers/usb/spca508_init.h
--- linux-2.4.20/drivers/usb.spca/spca508_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/spca508_init.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,709 @@
+/* 
+ * SPCA508 chip based cameras initialization data
+ *
+ */
+#ifndef SPCA508_INIT_H
+#define SPCA508_INIT_H
+
+/*
+   Initialization data: this is the first set-up data written to the
+   device (before the open data).
+ */
+static __u16 spca508_init_data[][3]=
+#define IGN(x) /* nothing */
+{
+  /*  line   URB    req,  value, index */
+  /*    22     1 */ /* READ { 0, 0x0 IGN(URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:), 0x00   } ->
+                0000: 12 01 10 01 00 00 00 08 33 07 10 01 00 00 01 02
+                0010: 00 01  */
+  /*    44     2 */ /* READ { 0, 0x0 IGN(URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:), 0x00   } ->
+                0000: 09 02 89 00 01 01 00 80 32 09 04 00 00 01 ff 00
+                0010: 00 00 07 05 81 01 00 00 01 09 04 00 01 01 ff 00
+                0020: 00 00 07 05 81 01 80 00 01 09 04 00 02 01 ff 00
+                0030: 00 00 07 05 81 01 80 01 01 09 04 00 03 01 ff 00  */
+  /*    68     3 */ /* READ { 0, 0x0 IGN(URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:), 0x00   } ->
+                0000: 09 02 89 00 01 01 00 80 32 09 04 00 00 01 ff 00
+                0010: 00 00 07 05 81 01 00 00 01 09 04 00 01 01 ff 00
+                0020: 00 00 07 05 81 01 80 00 01 09 04 00 02 01 ff 00
+                0030: 00 00 07 05 81 01 80 01 01 09 04 00 03 01 ff 00
+                0040: 00 00 07 05 81 01 00 02 01 09 04 00 04 01 ff 00
+                0050: 00 00 07 05 81 01 80 02 01 09 04 00 05 01 ff 00
+                0060: 00 00 07 05 81 01 00 03 01 09 04 00 06 01 ff 00
+                0070: 00 00 07 05 81 01 80 03 01 09 04 00 07 01 ff 00
+                0080: 00 00 07 05 81 01 ff 03 01  */
+  /*   104     4 */ /* UNKNOWN DIRECTION (URB_FUNCTION_SELECT_CONFIGURATION:)*/
+  /* 44274  1804 */ { 0, 0x0000, 0x870b }, // 
+
+
+
+  /* 44299  1805 */ { 0, 0x0020, 0x8112 }, // Video drop enable, ISO streaming disable
+  /* 44324  1806 */ { 0, 0x0003, 0x8111 }, // Reset compression & memory
+  /* 44349  1807 */ { 0, 0x0000, 0x8110 }, // Disable all outputs
+  /* 44372  1808 */ /* READ { 0, 0x0000, 0x8114 } ->
+                0000: 00  */
+  /* 44398  1809 */ { 0, 0x0000, 0x8114 }, // SW GPIO data
+  /* 44423  1810 */ { 0, 0x0008, 0x8110 }, // Enable charge pump output
+  /* 44527  1811 */ { 0, 0x0002, 0x8116 }, // 200 kHz pump clock
+  /* 44555  1812 */ /* UNKNOWN DIRECTION (URB_FUNCTION_SELECT_INTERFACE:)*/
+  /* 44590  1813 */ { 0, 0x0003, 0x8111 }, // Reset compression & memory
+  /* 44615  1814 */ { 0, 0x0000, 0x8111 }, // Normal mode (not reset)
+  /* 44640  1815 */ { 0, 0x0098, 0x8110 }, // Enable charge pump output, sync.serial,external 2x clock
+  /* 44665  1816 */ { 0, 0x000d, 0x8114 }, // SW GPIO data
+  /* 44690  1817 */ { 0, 0x0002, 0x8116 }, // 200 kHz pump clock
+  /* 44715  1818 */ { 0, 0x0020, 0x8112 }, // Video drop enable, ISO streaming disable
+
+
+  // ---------------------------------------
+  /* 44740  1819 */ { 0, 0x000f, 0x8402 }, // memory bank
+  /* 44765  1820 */ { 0, 0x0000, 0x8403 }, // ... address
+
+
+  // ---------------------------------------
+  // 0x88__ is Synchronous Serial Interface.
+  // TBD: This table could be expressed more compactly
+  // using spca508_write_i2c_vector().
+  // TBD: Should see if the values in spca50x_i2c_data
+  // would work with the VQ110 instead of the values
+  // below.
+
+  /* 44790  1821 */ { 0, 0x00c0, 0x8804 }, // SSI slave addr
+  /* 44815  1822 */ { 0, 0x0008, 0x8802 }, // 375 Khz SSI clock
+  /* 44838  1823 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 44862  1824 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 44888  1825 */ { 0, 0x0008, 0x8802 }, // 375 Khz SSI clock
+  /* 44913  1826 */ { 0, 0x0012, 0x8801 }, // SSI reg addr
+  /* 44938  1827 */ { 0, 0x0080, 0x8800 }, // SSI data to write
+  /* 44961  1828 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 44985  1829 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45009  1830 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 45035  1831 */ { 0, 0x0008, 0x8802 }, // 375 Khz SSI clock
+  /* 45060  1832 */ { 0, 0x0012, 0x8801 }, // SSI reg addr
+  /* 45085  1833 */ { 0, 0x0000, 0x8800 }, // SSI data to write
+  /* 45108  1834 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45132  1835 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45156  1836 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 45182  1837 */ { 0, 0x0008, 0x8802 }, // 375 Khz SSI clock
+  /* 45207  1838 */ { 0, 0x0011, 0x8801 }, // SSI reg addr
+  /* 45232  1839 */ { 0, 0x0040, 0x8800 }, // SSI data to write
+  /* 45255  1840 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45279  1841 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45303  1842 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 45329  1843 */ { 0, 0x0008, 0x8802 },
+  /* 45354  1844 */ { 0, 0x0013, 0x8801 },
+  /* 45379  1845 */ { 0, 0x0000, 0x8800 },
+  /* 45402  1846 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45426  1847 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45450  1848 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 45476  1849 */ { 0, 0x0008, 0x8802 },
+  /* 45501  1850 */ { 0, 0x0014, 0x8801 },
+  /* 45526  1851 */ { 0, 0x0000, 0x8800 },
+  /* 45549  1852 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45573  1853 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45597  1854 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 45623  1855 */ { 0, 0x0008, 0x8802 },
+  /* 45648  1856 */ { 0, 0x0015, 0x8801 },
+  /* 45673  1857 */ { 0, 0x0001, 0x8800 },
+  /* 45696  1858 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45720  1859 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45744  1860 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 45770  1861 */ { 0, 0x0008, 0x8802 },
+  /* 45795  1862 */ { 0, 0x0016, 0x8801 },
+  /* 45820  1863 */ { 0, 0x0003, 0x8800 },
+  /* 45843  1864 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45867  1865 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 45891  1866 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 45917  1867 */ { 0, 0x0008, 0x8802 },
+  /* 45942  1868 */ { 0, 0x0017, 0x8801 },
+  /* 45967  1869 */ { 0, 0x0036, 0x8800 },
+  /* 45990  1870 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46014  1871 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46038  1872 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 46064  1873 */ { 0, 0x0008, 0x8802 },
+  /* 46089  1874 */ { 0, 0x0018, 0x8801 },
+  /* 46114  1875 */ { 0, 0x00ec, 0x8800 },
+  /* 46137  1876 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46161  1877 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46185  1878 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 46211  1879 */ { 0, 0x0008, 0x8802 },
+  /* 46236  1880 */ { 0, 0x001a, 0x8801 },
+  /* 46261  1881 */ { 0, 0x0094, 0x8800 },
+  /* 46284  1882 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46308  1883 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46332  1884 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 46358  1885 */ { 0, 0x0008, 0x8802 },
+  /* 46383  1886 */ { 0, 0x001b, 0x8801 },
+  /* 46408  1887 */ { 0, 0x0000, 0x8800 },
+  /* 46431  1888 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46455  1889 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46479  1890 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 46505  1891 */ { 0, 0x0008, 0x8802 },
+  /* 46530  1892 */ { 0, 0x0027, 0x8801 },
+  /* 46555  1893 */ { 0, 0x00a2, 0x8800 },
+  /* 46578  1894 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46602  1895 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46626  1896 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 46652  1897 */ { 0, 0x0008, 0x8802 },
+  /* 46677  1898 */ { 0, 0x0028, 0x8801 },
+  /* 46702  1899 */ { 0, 0x0040, 0x8800 },
+  /* 46725  1900 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46749  1901 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46773  1902 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 46799  1903 */ { 0, 0x0008, 0x8802 },
+  /* 46824  1904 */ { 0, 0x002a, 0x8801 },
+  /* 46849  1905 */ { 0, 0x0084, 0x8800 },
+  /* 46872  1906 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46896  1907 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 46920  1908 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 46946  1909 */ { 0, 0x0008, 0x8802 },
+  /* 46971  1910 */ { 0, 0x002b, 0x8801 },
+  /* 46996  1911 */ { 0, 0x00a8, 0x8800 },
+  /* 47019  1912 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47043  1913 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47067  1914 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 47093  1915 */ { 0, 0x0008, 0x8802 },
+  /* 47118  1916 */ { 0, 0x002c, 0x8801 },
+  /* 47143  1917 */ { 0, 0x00fe, 0x8800 },
+  /* 47166  1918 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47190  1919 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47214  1920 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 47240  1921 */ { 0, 0x0008, 0x8802 },
+  /* 47265  1922 */ { 0, 0x002d, 0x8801 },
+  /* 47290  1923 */ { 0, 0x0003, 0x8800 },
+  /* 47313  1924 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47337  1925 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47361  1926 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 47387  1927 */ { 0, 0x0008, 0x8802 },
+  /* 47412  1928 */ { 0, 0x0038, 0x8801 },
+  /* 47437  1929 */ { 0, 0x0083, 0x8800 },
+  /* 47460  1930 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47484  1931 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47508  1932 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 47534  1933 */ { 0, 0x0008, 0x8802 },
+  /* 47559  1934 */ { 0, 0x0033, 0x8801 },
+  /* 47584  1935 */ { 0, 0x0081, 0x8800 },
+  /* 47607  1936 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47631  1937 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47655  1938 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 47681  1939 */ { 0, 0x0008, 0x8802 },
+  /* 47706  1940 */ { 0, 0x0034, 0x8801 },
+  /* 47731  1941 */ { 0, 0x004a, 0x8800 },
+  /* 47754  1942 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47778  1943 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47802  1944 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 47828  1945 */ { 0, 0x0008, 0x8802 },
+  /* 47853  1946 */ { 0, 0x0039, 0x8801 },
+  /* 47878  1947 */ { 0, 0x0000, 0x8800 },
+  /* 47901  1948 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47925  1949 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 47949  1950 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 47975  1951 */ { 0, 0x0008, 0x8802 },
+  /* 48000  1952 */ { 0, 0x0010, 0x8801 },
+  /* 48025  1953 */ { 0, 0x00a8, 0x8800 },
+  /* 48048  1954 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48072  1955 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48096  1956 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 48122  1957 */ { 0, 0x0008, 0x8802 },
+  /* 48147  1958 */ { 0, 0x0006, 0x8801 },
+  /* 48172  1959 */ { 0, 0x0058, 0x8800 },
+  /* 48195  1960 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48219  1961 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48243  1962 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 48269  1963 */ { 0, 0x0008, 0x8802 },
+  /* 48294  1964 */ { 0, 0x0000, 0x8801 },
+  /* 48319  1965 */ { 0, 0x0004, 0x8800 },
+  /* 48342  1966 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48366  1967 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48390  1968 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 48416  1969 */ { 0, 0x0008, 0x8802 },
+  /* 48441  1970 */ { 0, 0x0040, 0x8801 },
+  /* 48466  1971 */ { 0, 0x0080, 0x8800 },
+  /* 48489  1972 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48513  1973 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48537  1974 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 48563  1975 */ { 0, 0x0008, 0x8802 },
+  /* 48588  1976 */ { 0, 0x0041, 0x8801 },
+  /* 48613  1977 */ { 0, 0x000c, 0x8800 },
+  /* 48636  1978 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48660  1979 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48684  1980 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 48710  1981 */ { 0, 0x0008, 0x8802 },
+  /* 48735  1982 */ { 0, 0x0042, 0x8801 },
+  /* 48760  1983 */ { 0, 0x000c, 0x8800 },
+  /* 48783  1984 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48807  1985 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48831  1986 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 48857  1987 */ { 0, 0x0008, 0x8802 },
+  /* 48882  1988 */ { 0, 0x0043, 0x8801 },
+  /* 48907  1989 */ { 0, 0x0028, 0x8800 },
+  /* 48930  1990 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48954  1991 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 48978  1992 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 49004  1993 */ { 0, 0x0008, 0x8802 },
+  /* 49029  1994 */ { 0, 0x0044, 0x8801 },
+  /* 49054  1995 */ { 0, 0x0080, 0x8800 },
+  /* 49077  1996 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49101  1997 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49125  1998 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 49151  1999 */ { 0, 0x0008, 0x8802 },
+  /* 49176  2000 */ { 0, 0x0045, 0x8801 },
+  /* 49201  2001 */ { 0, 0x0020, 0x8800 },
+  /* 49224  2002 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49248  2003 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49272  2004 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 49298  2005 */ { 0, 0x0008, 0x8802 },
+  /* 49323  2006 */ { 0, 0x0046, 0x8801 },
+  /* 49348  2007 */ { 0, 0x0020, 0x8800 },
+  /* 49371  2008 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49395  2009 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49419  2010 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 49445  2011 */ { 0, 0x0008, 0x8802 },
+  /* 49470  2012 */ { 0, 0x0047, 0x8801 },
+  /* 49495  2013 */ { 0, 0x0080, 0x8800 },
+  /* 49518  2014 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49542  2015 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49566  2016 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 49592  2017 */ { 0, 0x0008, 0x8802 },
+  /* 49617  2018 */ { 0, 0x0048, 0x8801 },
+  /* 49642  2019 */ { 0, 0x004c, 0x8800 },
+  /* 49665  2020 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49689  2021 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49713  2022 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 49739  2023 */ { 0, 0x0008, 0x8802 },
+  /* 49764  2024 */ { 0, 0x0049, 0x8801 },
+  /* 49789  2025 */ { 0, 0x0084, 0x8800 },
+  /* 49812  2026 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49836  2027 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49860  2028 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 49886  2029 */ { 0, 0x0008, 0x8802 },
+  /* 49911  2030 */ { 0, 0x004a, 0x8801 },
+  /* 49936  2031 */ { 0, 0x0084, 0x8800 },
+  /* 49959  2032 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 49983  2033 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 50007  2034 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 50033  2035 */ { 0, 0x0008, 0x8802 },
+  /* 50058  2036 */ { 0, 0x004b, 0x8801 },
+  /* 50083  2037 */ { 0, 0x0084, 0x8800 },
+  /* 50106  2038 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+
+  // ---------------------------------------
+  /* 50132  2039 */ { 0, 0x0012, 0x8700 }, // Clock speed 48Mhz/(2+2)/2= 6 Mhz
+  /* 50157  2040 */ { 0, 0x0000, 0x8701 }, // CKx1 clock delay adj
+  /* 50182  2041 */ { 0, 0x0000, 0x8701 }, // CKx1 clock delay adj
+  /* 50207  2042 */ { 0, 0x0001, 0x870c }, // CKOx2 output
+
+  // ---------------------------------------
+  /* 50232  2043 */ { 0, 0x0080, 0x8600 }, // Line memory read counter (L)
+  /* 50257  2044 */ { 0, 0x0001, 0x8606 }, // reserved
+  /* 50282  2045 */ { 0, 0x0064, 0x8607 }, // Line memory read counter (H) 0x6480=25,728
+  /* 50307  2046 */ { 0, 0x002a, 0x8601 }, // CDSP sharp interpolation mode, line sel for color sep, edge enhance enab
+  /* 50332  2047 */ { 0, 0x0000, 0x8602 }, // optical black level for user settng = 0
+  /* 50357  2048 */ { 0, 0x0080, 0x8600 }, // Line memory read counter (L)
+  /* 50382  2049 */ { 0, 0x000a, 0x8603 }, // optical black level calc mode: auto; optical black offset = 10
+  /* 50407  2050 */ { 0, 0x00df, 0x865b }, // Horiz offset for valid pixels (L)=0xdf
+  /* 50432  2051 */ { 0, 0x0012, 0x865c }, // Vert offset for valid lines (L)=0x12
+
+  // The following two lines seem to be the "wrong" resolution.
+  // But perhaps these indicate the actual size of the sensor
+  // rather than the size of the current video mode.
+  /* 50457  2052 */ { 0, 0x0058, 0x865d }, // Horiz valid pixels (*4) (L) = 352
+  /* 50482  2053 */ { 0, 0x0048, 0x865e }, // Vert valid lines (*4) (L) = 288
+
+  /* 50507  2054 */ { 0, 0x0015, 0x8608 }, // A11 Coef ...
+  /* 50532  2055 */ { 0, 0x0030, 0x8609 },
+  /* 50557  2056 */ { 0, 0x00fb, 0x860a },
+  /* 50582  2057 */ { 0, 0x003e, 0x860b },
+  /* 50607  2058 */ { 0, 0x00ce, 0x860c },
+  /* 50632  2059 */ { 0, 0x00f4, 0x860d },
+  /* 50657  2060 */ { 0, 0x00eb, 0x860e },
+  /* 50682  2061 */ { 0, 0x00dc, 0x860f },
+  /* 50707  2062 */ { 0, 0x0039, 0x8610 },
+  /* 50732  2063 */ { 0, 0x0001, 0x8611 }, // R offset for white balance ...
+  /* 50757  2064 */ { 0, 0x0000, 0x8612 },
+  /* 50782  2065 */ { 0, 0x0001, 0x8613 },
+  /* 50807  2066 */ { 0, 0x0000, 0x8614 },
+  /* 50832  2067 */ { 0, 0x005b, 0x8651 }, // R gain for white balance ...
+  /* 50857  2068 */ { 0, 0x0040, 0x8652 },
+  /* 50882  2069 */ { 0, 0x0060, 0x8653 },
+  /* 50907  2070 */ { 0, 0x0040, 0x8654 },
+  /* 50932  2071 */ { 0, 0x0000, 0x8655 },
+  /* 50957  2072 */ { 0, 0x0001, 0x863f }, // Fixed gamma correction enable, USB control, lum filter disable, lum noise clip disable
+  /* 50982  2073 */ { 0, 0x00a1, 0x8656 }, // Window1 size 256x256, Windows2 size 64x64, gamma look-up disable, new edge enhancement enable
+  /* 51007  2074 */ { 0, 0x0018, 0x8657 }, // Edge gain high thresh
+  /* 51032  2075 */ { 0, 0x0020, 0x8658 }, // Edge gain low thresh
+  /* 51057  2076 */ { 0, 0x000a, 0x8659 }, // Edge bandwidth high threshold
+  /* 51082  2077 */ { 0, 0x0005, 0x865a }, // Edge bandwidth low threshold
+
+  //--------------------------------
+  /* 51107  2078 */ { 0, 0x0030, 0x8112 }, // Video drop enable, ISO streaming enable
+  /* 51130  2079 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 51154  2080 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 51180  2081 */ { 0, 0xa908, 0x8802 },
+  /* 51205  2082 */ { 0, 0x0034, 0x8801 }, // SSI reg addr
+  /* 51230  2083 */ { 0, 0x00ca, 0x8800 }, // SSI data to write
+  /* 51253  2084 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 51277  2085 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 51301  2086 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 51327  2087 */ { 0, 0x1f08, 0x8802 },
+  /* 51352  2088 */ { 0, 0x0006, 0x8801 },
+  /* 51377  2089 */ { 0, 0x0080, 0x8800 },
+  /* 51400  2090 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+
+
+  //----- Read back coefs we wrote earlier.
+  /* 51424  2091 */ /* READ { 0, 0x0000, 0x8608 } ->
+                0000: 15  */
+  /* 51448  2092 */ /* READ { 0, 0x0000, 0x8609 } ->
+                0000: 30  */
+  /* 51472  2093 */ /* READ { 0, 0x0000, 0x860a } ->
+                0000: fb  */
+  /* 51496  2094 */ /* READ { 0, 0x0000, 0x860b } ->
+                0000: 3e  */
+  /* 51520  2095 */ /* READ { 0, 0x0000, 0x860c } ->
+                0000: ce  */
+  /* 51544  2096 */ /* READ { 0, 0x0000, 0x860d } ->
+                0000: f4  */
+  /* 51568  2097 */ /* READ { 0, 0x0000, 0x860e } ->
+                0000: eb  */
+  /* 51592  2098 */ /* READ { 0, 0x0000, 0x860f } ->
+                0000: dc  */
+  /* 51616  2099 */ /* READ { 0, 0x0000, 0x8610 } ->
+                0000: 39  */
+  /* 51640  2100 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 51664  2101 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 08  */
+  /* 51690  2102 */ { 0, 0xb008, 0x8802 },
+  /* 51715  2103 */ { 0, 0x0006, 0x8801 },
+  /* 51740  2104 */ { 0, 0x007d, 0x8800 },
+  /* 51763  2105 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+
+#if 0
+  /* experimental.  dark version. */
+  { 0, 0xba, 0x8705}, /* total pixel clocks per hsync cycle (L) */
+  { 0, 0x00, 0x8706}, /* total pixel clocks per hsync cycle (H in 2:0) */
+  { 0, 0x5a, 0x8707}, /* total pixel clocks per hsync blank period (L) */
+#elif 0
+  /* experimental.  factory default. */
+  { 0, 0x8e, 0x8705}, /* total pixel clocks per hsync cycle (L) */
+  { 0, 0x03, 0x8706}, /* total pixel clocks per hsync cycle (H in 2:0) */
+  { 0, 0x5a, 0x8707}, /* total pixel clocks per hsync blank period (L) */
+#elif 0
+  /* experimental.  light. */
+  { 0, 0xba, 0x8705}, /* total pixel clocks per hsync cycle (L) */
+  { 0, 0x01, 0x8706}, /* total pixel clocks per hsync cycle (H in 2:0) */
+  { 0, 0x10, 0x8707}, /* total pixel clocks per hsync blank period (L) */
+#endif
+
+#if 1
+  // This chunk is seemingly redundant with
+  // earlier commands (A11 Coef...), but if I disable it,
+  // the image appears too dark.  Maybe there was some kind of
+  // reset since the earlier commands, so this is necessary again.
+  /* 51789  2106 */ { 0, 0x0015, 0x8608 },
+  /* 51814  2107 */ { 0, 0x0030, 0x8609 },
+  /* 51839  2108 */ { 0, 0xfffb, 0x860a },
+  /* 51864  2109 */ { 0, 0x003e, 0x860b },
+  /* 51889  2110 */ { 0, 0xffce, 0x860c },
+  /* 51914  2111 */ { 0, 0xfff4, 0x860d },
+  /* 51939  2112 */ { 0, 0xffeb, 0x860e },
+  /* 51964  2113 */ { 0, 0xffdc, 0x860f },
+  /* 51989  2114 */ { 0, 0x0039, 0x8610 },
+  /* 52014  2115 */ { 0, 0x0018, 0x8657 },
+#endif
+
+  /* 52039  2116 */ { 0, 0x0000, 0x8508 }, // Disable compression.
+  // Previous line was: /* 52039  2116 */ { 0, 0x0021, 0x8508 }, // Enable compression.
+  /* 52064  2117 */ { 0, 0x0032, 0x850b }, // compression stuff
+  /* 52089  2118 */ { 0, 0x0003, 0x8509 }, // compression stuff
+  /* 52114  2119 */ { 0, 0x0011, 0x850a }, // compression stuff
+  /* 52139  2120 */ { 0, 0x0021, 0x850d }, // compression stuff
+  /* 52164  2121 */ { 0, 0x0010, 0x850c }, // compression stuff
+  /* 52189  2122 */ { 0, 0x0003, 0x8500 }, // *** Video mode: 160x120
+  /* 52214  2123 */ { 0, 0x0001, 0x8501 }, // Hardware-dominated snap control
+  /* 52239  2124 */ { 0, 0x0061, 0x8656 }, // Window1 size 128x128, Windows2 size 128x128, gamma look-up disable, new edge enhancement enable
+  /* 52264  2125 */ { 0, 0x0018, 0x8617 }, // Window1 start X (*2)
+  /* 52289  2126 */ { 0, 0x0008, 0x8618 }, // Window1 start Y (*2)
+  /* 52314  2127 */ { 0, 0x0061, 0x8656 }, // Window1 size 128x128, Windows2 size 128x128, gamma look-up disable, new edge enhancement enable
+  /* 52339  2128 */ { 0, 0x0058, 0x8619 }, // Window2 start X (*2)
+  /* 52364  2129 */ { 0, 0x0008, 0x861a }, // Window2 start Y (*2)
+  /* 52389  2130 */ { 0, 0x00ff, 0x8615 }, // High lum thresh for white balance
+  /* 52414  2131 */ { 0, 0x0000, 0x8616 }, // Low lum thresh for white balance
+  /* 52439  2132 */ { 0, 0x0012, 0x8700 },  // Clock speed 48Mhz/(2+2)/2= 6 Mhz
+  /* 52464  2133 */ { 0, 0x0012, 0x8700 },  // Clock speed 48Mhz/(2+2)/2= 6 Mhz
+  /* 52487  2134 */ /* READ { 0, 0x0000, 0x8656 } ->
+                0000: 61  */
+
+
+  /* 52513  2135 */ { 0, 0x0028, 0x8802 },  // 375 Khz SSI clock, SSI r/w sync with VSYNC
+  /* 52536  2136 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 52560  2137 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 28  */
+  /* 52586  2138 */ { 0, 0x1f28, 0x8802 }, // 375 Khz SSI clock, SSI r/w sync with VSYNC
+  /* 52611  2139 */ { 0, 0x0010, 0x8801 }, // SSI reg addr
+  /* 52636  2140 */ { 0, 0x003e, 0x8800 }, // SSI data to write
+  /* 52659  2141 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 52685  2142 */ { 0, 0x0028, 0x8802 },
+  /* 52708  2143 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 52732  2144 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 28  */
+  /* 52758  2145 */ { 0, 0x1f28, 0x8802 },
+  /* 52783  2146 */ { 0, 0x0000, 0x8801 },
+  /* 52808  2147 */ { 0, 0x001f, 0x8800 },
+  /* 52831  2148 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 52857  2149 */ { 0, 0x0001, 0x8602 },  // optical black level for user settning = 1
+
+#if 0
+  // NOTE: Code like this case lets this driver (often) work
+  // in 352x288 resolution, apparently by slowing down the
+  // clock.
+
+  /* 52464  2133 */ { 0, 0x002F, 0x8700 },  // Clock speed 
+#else
+  // Original:
+  /* 52882  2150 */ { 0, 0x0023, 0x8700 },  // Clock speed 48Mhz/(3+2)/4= 2.4 Mhz
+#endif
+
+  /* 52907  2151 */ { 0, 0x000f, 0x8602 },  // optical black level for user settning = 15
+
+  /* 52932  2152 */ { 0, 0x0028, 0x8802 },
+  /* 52955  2153 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 52979  2154 */ /* READ { 0, 0x0001, 0x8802 } ->
+                0000: 28  */
+  /* 53005  2155 */ { 0, 0x1f28, 0x8802 },
+  /* 53030  2156 */ { 0, 0x0010, 0x8801 },
+  /* 53055  2157 */ { 0, 0x007b, 0x8800 },
+  /* 53078  2158 */ /* READ { 0, 0x0001, 0x8803 } ->
+                0000: 00  */
+  /* 53104  2159 */ { 0, 0x002f, 0x8651 }, // R gain for white balance ...
+  /* 53129  2160 */ { 0, 0x0080, 0x8653 },
+  /* 53152  2161 */ /* READ { 0, 0x0000, 0x8655 } ->
+                0000: 00  */
+  /* 53178  2162 */ { 0, 0x0000, 0x8655 },
+
+  /* 53203  2163 */ { 0, 0x0030, 0x8112 }, // Video drop enable, ISO streaming enable
+  /* 53228  2164 */ { 0, 0x0020, 0x8112 }, // Video drop enable, ISO streaming disable
+  /* 53252  2165 */ /* UNKNOWN DIRECTION (URB_FUNCTION_SELECT_INTERFACE: (ALT=0) )*/
+
+  { 0,0,0 }
+};
+
+/*
+ * Data to initialize the camera using the internal CCD
+ */
+static __u16 spca508_open_data[][3]=
+{
+  /* line       bmRequest,value,index */
+  {0,0,0}
+};
+
+/*
+ * Initialization data for Intel EasyPC Camera CS110
+ */
+static __u16 spca508cs110_init_data[][3] =
+{
+  { 0, 0x0000, 0x870b }, /* Reset CTL3 */
+  { 0, 0x0003, 0x8111 }, /* Soft Reset compression, memory, TG & CDSP */
+  { 0, 0x0000, 0x8111 }, /* Normal operation on reset */
+  { 0, 0x0090, 0x8110 }, /* External Clock 2x & Synchronous Serial Interface Output */
+  { 0, 0x0020, 0x8112 }, /* Video Drop packet enable */
+  { 0, 0x0000, 0x8114 }, /* Software GPIO output data */
+  { 0, 0x0001, 0x8114 },
+  { 0, 0x0001, 0x8114 },
+  { 0, 0x0001, 0x8114 },
+  { 0, 0x0003, 0x8114 },
+
+  /* Initial sequence Synchronous Serial Interface */
+  { 0, 0x000f, 0x8402 }, /* Memory bank Address */
+  { 0, 0x0000, 0x8403 }, /* Memory bank Address */
+  { 0, 0x00ba, 0x8804 }, /* SSI Slave address */
+  { 0, 0x0010, 0x8802 }, /* 93.75kHz SSI Clock Two DataByte */
+  { 0, 0x0010, 0x8802 }, /* 93.75kHz SSI Clock two DataByte */
+
+  { 0, 0x0001, 0x8801 },
+  { 0, 0x000a, 0x8805 }, /* a - NWG: Dunno what this is about */
+  { 0, 0x0000, 0x8800 },
+  { 0, 0x0010, 0x8802 },
+
+  { 0, 0x0002, 0x8801 },
+  { 0, 0x0000, 0x8805 },
+  { 0, 0x0000, 0x8800 },
+  { 0, 0x0010, 0x8802 },
+
+  { 0, 0x0003, 0x8801 },
+  { 0, 0x0027, 0x8805 },
+  { 0, 0x0001, 0x8800 },
+  { 0, 0x0010, 0x8802 },
+
+  { 0, 0x0004, 0x8801 },
+  { 0, 0x0065, 0x8805 },
+  { 0, 0x0001, 0x8800 },
+  { 0, 0x0010, 0x8802 },
+
+  { 0, 0x0005, 0x8801 },
+  { 0, 0x0003, 0x8805 },
+  { 0, 0x0000, 0x8800 },
+  { 0, 0x0010, 0x8802 },
+
+  { 0, 0x0006, 0x8801 },
+  { 0, 0x001c, 0x8805 },
+  { 0, 0x0000, 0x8800 },
+  { 0, 0x0010, 0x8802 },
+
+  { 0, 0x0007, 0x8801 },
+  { 0, 0x002a, 0x8805 },
+  { 0, 0x0000, 0x8800 },
+  { 0, 0x0010, 0x8802 },
+
+
+
+  { 0, 0x0002, 0x8704 }, /* External input CKIx1 */
+  { 0, 0x0001, 0x8606 }, /* 1 Line memory Read Counter (H) Result: (d)410 */
+  { 0, 0x009a, 0x8600 }, /* Line memory Read Counter (L) */
+  { 0, 0x0001, 0x865b }, /* 1 Horizontal Offset for Valid Pixel(L) */
+  { 0, 0x0003, 0x865c }, /* 3 Vertical Offset for Valid Lines(L) */
+  { 0, 0x0058, 0x865d }, /* 58 Horizontal Valid Pixel Window(L) */
+
+
+  { 0, 0x0006, 0x8660 }, /* Nibble data + input order */
+
+
+  { 0, 0x000a, 0x8602 }, /* Optical black level set to 0x0a */
+/* 1945 */  { 0, 0x0000, 0x8603 }, /* Optical black level Offset */
+
+/* 1962 */ // { 0, 0x0000, 0x8611 }, /* 0 R  Offset for white Balance */
+/* 1963 */ // { 0, 0x0000, 0x8612 }, /* 1 Gr Offset for white Balance */
+/* 1964 */ // { 0, 0x0000, 0x8613 }, /* 1f B  Offset for white Balance */
+/* 1965 */ // { 0, 0x0000, 0x8614 }, /* f0 Gb Offset for white Balance */
+
+  { 0, 0x0040, 0x8651 }, /* 2b BLUE gain for white balance  good at all 60 */
+  { 0, 0x0030, 0x8652 }, /* 41 Gr Gain for white Balance (L) */
+  { 0, 0x0035, 0x8653 }, /* 26 RED gain for white balance */
+  { 0, 0x0035, 0x8654 }, /* 40Gb Gain for white Balance (L) */
+  { 0, 0x0041, 0x863f }, /* Fixed Gamma correction enabled (makes colours look better) */
+
+/* 2422 */  { 0, 0x0000, 0x8655 }, /* High bits for white balance*****brightness control*** */
+
+  { 0,0,0 }
+};
+
+#endif /* SPCA508_INIT_H */
diff -uN linux-2.4.20/drivers/usb.spca/spca50x.c linux-2.4.20/drivers/usb/spca50x.c
--- linux-2.4.20/drivers/usb.spca/spca50x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/spca50x.c	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,5080 @@
+/*
+ * SPCA50x based usb camera driver (currently supports spca501, spca505, 
+ * spca508, and untested spca506).
+ * Cameras using this series of briges are Intel PC Camera Pro, Intel Create and Share
+ * and Viewquest Technologies camera line
+ *
+ * Based on :
+ * OmniVision OV511 Camera-to-USB Bridge Driver
+ *
+ * Copyright (c) 1999-2000 Mark W. McClelland
+ * Many improvements by Bret Wallach <bwallac1@san.rr.com>
+ * Color fixes by by Orion Sky Lawlor <olawlor@acm.org> (2/26/2000)
+ * Snapshot code by Kevin Moore
+ * OV7620 fixes by Charl P. Botha <cpbotha@ieee.org>
+ * Changes by Claudio Matsuoka <claudio@conectiva.com>
+ * SPCA50x version by Joel Crisp <cydergoth@users.sourceforge.net>
+ *
+ * Based on the Linux CPiA driver written by Peter Pregler,
+ * Scott J. Bertin and Johannes Erdfelt.
+ *
+ * Please see the README file in this package
+ * Please see the file: linux/Documentation/usb/ov511.txt
+ * and the website at:  http://alpha.dyndns.org/ov511
+ * for more info.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+static const char version[] = SPCA50X_VERSION;
+static const char SPCA50X_C_CVS_VERSION[]="$Id: spca50x.c,v 1.52 2003/02/17 07:23:18 polesworth Exp $";
+
+#include <linux/config.h>
+#ifdef CONFIG_MODVERSIONS
+#include <linux/modversions.h>
+#endif /* CONFIG_MODVERSIONS */
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/usb.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+#include <linux/wrapper.h>
+#include <linux/param.h>
+#ifdef SPCA50X_ENABLE_OSD
+#ifdef CONFIG_FB
+#include <video/font.h>
+#endif /* CONFIG_FB */
+#endif /* SPCA50X_ENABLE_OSD */
+
+#include "spca50x.h"
+
+/* V4L API extension for raw JPEG (=JPEG without header)   
+ */
+#define VIDEO_PALETTE_RAW_JPEG  20
+
+/*
+ * Let's include the initialization data for each camera type
+ */
+
+#include "spca500_init.h"
+#include "spca501_init.h"
+#include "spca504_init.h"
+#include "spca505_init.h"
+#include "spca506_init.h"
+#include "spca508_init.h"
+#include "spcai2c_init.h"
+
+#include "jpegdecoder.h"
+
+#define PROC_NAME_LEN 10 //length of the proc name
+
+#ifndef CONFIG_FB
+/* Force OSD off if required dependencies not enabled */
+/* Turning OSD on requires a kernel patch to the fbcon__ routines */
+#undef SPCA50X_ENABLE_OSD
+#endif /* CONFIG_FB */
+
+/* Video Size 640 x 480 x 4 bytes for RGB */
+#define MAX_FRAME_SIZE (640 * 480 * 4)
+#define MAX_DATA_SIZE (MAX_FRAME_SIZE + sizeof(struct timeval))
+
+#ifdef SPCA50X_ENABLE_OSD
+struct fbcon_font_desc *osd_font = NULL;
+#endif /* SPCA50X_ENABLE_OSD */
+
+/* PARAMETER VARIABLES: */
+static int autoadjust = 0;    /* CCD dynamically changes exposure, etc... */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,5)
+/* Video device number (-1 is first available) */
+static int video_nr = -1;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,5) */
+
+/* 0=no debug messages
+ * 1=init/detection/unload and other significant messages,
+ * 2=some warning messages
+ * 3=config/control function calls
+ * 4=most function calls and data parsing messages
+ * 5=highly repetitive mesgs
+ * NOTE: This should be changed to 0, 1, or 2 for production kernels
+ */
+static int debug = 0;
+
+/* Snapshot mode enabled flag */
+static int snapshot = 0;
+
+/* Force image to be read in RGB instead of BGR. This option allow
+ * programs that expect RGB data (e.g. gqcam) to work with this driver. */
+static int force_rgb = 0;
+
+/* Number of seconds before inactive buffers are deallocated */
+static int buf_timeout = 5;
+
+#ifdef SPCA50X_ENABLE_CAMS
+/* Number of cameras to stream from simultaneously */
+static int cams = 1;
+#endif /* SPCA50X_ENABLE_CAMS */
+
+/* Prevent apps from timing out if frame is not done in time */
+static int retry_sync = 0;
+
+#ifdef SPCA50X_ENABLE_COMPRESSION
+/* Enable compression. This is for experimentation only; compressed images
+ * still cannot be decoded yet. */
+static int compress = 0;
+#endif /* SPCA50X_ENABLE_COMPRESSION */
+
+#ifdef SPCA50X_ENABLE_TESTPATTERN
+/* Display test pattern - doesn't work yet either */
+static int testpat = 0;
+#endif /* SPCA50X_ENABLE_TESTPATTERN */
+
+/* Dump raw pixel data, in one of many formats. */
+static int dumppix = 0;
+
+/* Initial brightness & contrast (for debug purposes) */
+static int bright = 0x80;
+static int contrast = 0x60;
+
+/* Internal/external CCD flag, initially internal CCD */
+static int ccd = 0;
+
+/* Parameter that enables you to set the minimal suitable bpp */
+static int min_bpp = 0;
+
+/* Parameter defines the average luminance that should be kept */
+static int lum_level = 0x20;
+
+#ifdef SPCA50X_ENABLE_OSD
+/* Enable On-screen display of some data (frame sequence, time) */
+static int osd = 1;
+#endif /* SPCA50X_ENABLE_OSD */
+
+MODULE_PARM(autoadjust, "i");
+MODULE_PARM_DESC(autoadjust, "CCD dynamically changes exposure (spca501x only)");
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Debug level: 0=none, 1=init/detection, 2=warning, 3=config/control, 4=function call, 5=max");
+MODULE_PARM(snapshot, "i");
+MODULE_PARM_DESC(snapshot, "Enable snapshot mode");
+MODULE_PARM(force_rgb, "i");
+MODULE_PARM_DESC(force_rgb, "Read RGB instead of BGR");
+MODULE_PARM(buf_timeout, "i");
+MODULE_PARM_DESC(buf_timeout, "Number of seconds before buffer deallocation");
+#ifdef SPCA50X_ENABLE_CAMS
+MODULE_PARM(cams, "i");
+MODULE_PARM_DESC(cams, "Number of simultaneous cameras (currently only 1 supported)");
+#endif /* SPCA50X_ENABLE_CAMS */
+MODULE_PARM(retry_sync, "i");
+MODULE_PARM_DESC(retry_sync, "Prevent apps from timing out");
+#ifdef SPCA50X_ENABLE_COMPRESSION
+MODULE_PARM(compress, "i");
+MODULE_PARM_DESC(compress, "Turn on/off compression (not functional yet)");
+#endif /* SPCA50X_ENABLE_COMPRESSION */
+MODULE_PARM(dumppix, "i");
+MODULE_PARM_DESC(dumppix, "Dump raw pixel data, in one of 3 formats. See spca50x_dumppix() for details");
+MODULE_PARM(bright, "i");
+MODULE_PARM_DESC(bright, "Initial brightness factor (0-255)");
+MODULE_PARM(contrast, "i");
+MODULE_PARM_DESC(contrast, "Initial contrast factor (0-255)");
+MODULE_PARM(ccd, "i");
+MODULE_PARM_DESC(ccd, "If zero, default to the internal CCD, otherwise use the external video input");
+#ifdef SPCA50X_ENABLE_OSD
+MODULE_PARM(osd, "i");
+MODULE_PARM_DESC(osd, "If non-zero, enable various types of on-screen display");
+#endif /* SPCA50X_ENABLE_OSD */
+MODULE_PARM(min_bpp, "i");
+MODULE_PARM_DESC(min_bpp, "The minimal color depth that may be set (default 0)");
+MODULE_PARM(lum_level, "0-255i");
+MODULE_PARM_DESC(lum_level, "Luminance level for brightness autoadjustment (default 32)");
+
+MODULE_AUTHOR("Joel Crisp <cydergoth@users.sourceforge.net>, based on ov511 driver by Mark McClelland <mwm@i.am> & Bret Wallach & Orion Sky Lawlor <olawlor@acm.org> & Kevin Moore & Charl P. Botha <cpbotha@ieee.org> & Claudio Matsuoka <claudio@conectiva.com>");
+MODULE_DESCRIPTION("SPCA50X USB Camera Driver");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif /* MODULE_LICENSE */
+
+static int spca50x_move_data(struct usb_spca50x *spca50x, struct urb *urb);
+static void auto_bh(void* data);
+static void spca504_acknowledged_command(struct usb_spca50x *spca50x, 
+                                         __u16               reg,
+                                         __u16               idx,
+                                         __u16               val);
+
+static struct usb_driver spca50x_driver;
+
+#ifndef max
+static inline int max(int a, int b)
+{
+	return (a > b)? a: b;
+}
+#endif /* max */
+
+/**********************************************************************
+ * List of known SPCA50X-based cameras
+ **********************************************************************/
+
+static struct cam_list clist[] = {
+	{   0, "Unknown" },
+	{   1, "Intel PC Camera Pro" },
+	{   2, "Intel Create and Share" },
+	{   3, "Grandtec V.cap" },
+	{   4, "ViewQuest M318B" },
+	{   5, "ViewQuest VQ110" },
+	{   6, "Kodak DVC-325" },
+	{   7, "Mustek gSmart mini 2" },
+	{   8, "Mustek gSmart mini 3" },
+	{   9, "Creative PC-CAM 300" },
+	{  10, "D-Link DSC-350" },
+	{  11, "Creative PC-CAM 600" },
+	{  12, "Intel Pocket PC Camera" },
+	{  13, "Intel Easy PC Camera" },
+	{  14, "3Com Home Connect Lite"},
+	{  15, "Kodak EZ200"},
+	{  -1, NULL }
+};
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+static __devinitdata struct usb_device_id device_table [] = {
+	{ USB_DEVICE(0x0733, 0x0430) },  /* Intel PC Camera Pro */
+	{ USB_DEVICE(0x0733, 0x0401) },  /* Intel Create and Share */
+	{ USB_DEVICE(0x99FA, 0x8988) },  /* Grandtec V.cap */
+	{ USB_DEVICE(0x0733, 0x0402) },  /* ViewQuest M318B */
+	{ USB_DEVICE(0x0733, 0x0110) },  /* ViewQuest VQ110 */
+	{ USB_DEVICE(0x040A, 0x0002) },  /* Kodak DVC-325 */
+	{ USB_DEVICE(0x055f, 0xc420) },  /* Mustek gSmart Mini 2 */
+	{ USB_DEVICE(0x055f, 0xc520) },  /* Mustek gSmart Mini 3 */
+	{ USB_DEVICE(0x041E, 0x400A) },  /* Creative PC-CAM 300 */
+	{ USB_DEVICE(0x084D, 0x0003) },  /* D-Link DSC-350 */
+	{ USB_DEVICE(0x041E, 0x400B) },  /* Creative PC-CAM 600 */
+	{ USB_DEVICE(0x8086, 0x0630) },  /* Intel Pocket PC Camera */
+	{ USB_DEVICE(0x8086, 0x0110) },  /* Intel Easy PC Camera */
+	{ USB_DEVICE(0x0506, 0x00df) },  /* 3Com HomeConnect Lite */
+	{ USB_DEVICE(0x040a, 0x0300) },  /* Kodak EZ200 */
+	{ }  /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, device_table);
+/* 
+ We also setup the function for getting 
+ page number from the virtual address 
+*/
+#define VIRT_TO_PAGE virt_to_page 
+#else /* LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0) */
+#define VIRT_TO_PAGE MAP_NR 
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0) */
+
+/* Mode list for spca50x on external input */
+/* Must be in descending order as the closest match which is equal or smaller than
+ * the requested size is returned */
+
+#define GET_EXT_MODES(bridge) (\
+	(bridge) == BRIDGE_SPCA500 ? spca500_ext_modes : \
+	(bridge) == BRIDGE_SPCA501 ? spca501_ext_modes : \
+	(bridge) == BRIDGE_SPCA504 ? spca504_ext_modes : \
+	(bridge) == BRIDGE_SPCA508 ? spca508_ext_modes : \
+	spca50x_ext_modes)
+
+static __u16 spca500_ext_modes[][6] =
+{
+	/* x , y , Code, x multiplier, y multiplier, pipe */
+	{ 640, 480, 0, 40, 30, 1023 },
+	{ 352, 288, 0, 22, 18, 1023 },
+	{ 320, 240, 1, 40, 30, 1023 },
+	{ 176, 144, 1, 22, 18, 1023 },
+	{ 160, 128, 1, 20, 16, 768 },
+	/* FIXME: 160x120 format is currently disabled,
+	 *        since the jpeg decoder can't handle
+	 *        half lines, which 120 turns out to
+	 *        be.
+	 *        NWG: Sun 16th February 2003.
+	 *
+	 * { 160, 120, 2, 40, 30, 768 },
+	 */
+	{ 160, 112, 2, 40, 28, 768 },
+	{ 0, 0, 0, 0, 0, 0 }
+};
+
+static __u16 spca501_ext_modes[][6] =
+{
+	/* x , y , Code, Value (6), Value (7), pipe */
+	{ 640, 480, 0, 0x94, 0x004A, 1023 },
+	{ 320, 240, 0, 0x94, 0x104A, 896 },
+	{ 160, 120, 0, 0x94, 0x204A, 384 },
+	{ 0, 0, 0, 0, 0 }
+};
+
+static __u16 spca504_ext_modes[][6] =
+{
+	/* x , y , Code, Value (6), Value (7), pipe */
+	{ 640, 480, 1, 4, 0, 1023 },
+	{ 320, 240, 2, 5, 0, 896 },
+	/* FIXME: todo add 160*120 format.
+	 *        Should be a line like:
+	 *        { 160, 120, 2, 5, 0, 384 }
+	 *        but with correct register values.
+	 *        FEB: sat feb 15 2003
+	 */
+	{ 0, 0, 0, 0, 0 }
+};
+
+static __u16 spca50x_ext_modes[][6] =
+{
+	/* x , y , Code, Value (6), Value (7), pipe */
+	{ 352, 288, 1, 0x1a, 0x1a, 1023 }, /* Tested */
+#if 0
+	{ 320, 240, 2, 0x1c, 0x1d, 896 }, /* Guessed values - if you are brave, uncomment and play with these !*/
+	{ 240, 180, 3, 0x20, 0x20, 640 }, /* Guessed values */
+#endif
+	{ 176, 144, 4, 0x34, 0x34, 512 }, /* Tested */
+	{ 160, 120, 5, 0x40, 0x40, 384 }, /* Tested */
+	{ 0, 0, 0, 0, 0 }
+};
+
+static __u16 spca508_ext_modes[][6] =
+{
+	/* In this table, element 3 (clk) controls the
+	 * clock, and gets written to 0x8700.
+	 */
+	/* x , y , Code, clk, n/a,  pipe */
+	{ 352, 288, 0, 0x28, 0x00, 1023},
+	{ 320, 240, 1, 0x28, 0x00, 1023},
+	{ 176, 144, 2, 0x23, 0x00, 1023}, 
+	{ 160, 120, 3, 0x23, 0x00, 1023},
+	{ 0, 0, 0, 0, 0 }
+};
+
+#ifdef CONFIG_PROC_FS
+/* Not sure what we should do with this. I think it is V4L level 2 stuff */
+/* Currently only use RGB24 */
+static struct palette_list plist[] = {
+	{ VIDEO_PALETTE_GREY,      "GREY" },
+	{ VIDEO_PALETTE_HI240,     "HI240" },
+	{ VIDEO_PALETTE_RGB565,    "RGB565" },
+	{ VIDEO_PALETTE_RGB24,     "RGB24" },
+	{ VIDEO_PALETTE_RGB32,     "RGB32" },
+	{ VIDEO_PALETTE_RGB555,    "RGB555" },
+	{ VIDEO_PALETTE_YUV422,    "YUV422" },
+	{ VIDEO_PALETTE_YUYV,      "YUYV" },
+	{ VIDEO_PALETTE_UYVY,      "UYVY" },
+	{ VIDEO_PALETTE_YUV420,    "YUV420" },
+	{ VIDEO_PALETTE_YUV411,    "YUV411" },
+	{ VIDEO_PALETTE_RAW,       "RAW" },
+	{ VIDEO_PALETTE_YUV422P,   "YUV422P" },
+	{ VIDEO_PALETTE_YUV411P,   "YUV411P" },
+	{ VIDEO_PALETTE_YUV420P,   "YUV420P" },
+	{ VIDEO_PALETTE_YUV410P,   "YUV410P" },
+	{ VIDEO_PALETTE_RAW_JPEG , "RJPG" },
+	{ -1, NULL }
+};
+#endif /* CONFIG_PROC_FS */
+
+/* Common functions prototype */
+static int spca50x_reg_read(struct usb_device *dev,
+                            __u16              reg,
+                            __u16              index,
+                            __u16              length);
+static int spca50x_reg_write(struct usb_device *dev,
+                             __u16              reg,
+                             __u16              index,
+                             __u16              value);
+
+static int spca500_initialise(struct usb_spca50x *spca50x);
+static int spca500_full_reset(struct usb_spca50x *spca50x);
+static int spca500_setup_qtable(struct usb_spca50x *spca50x,
+                                unsigned int        request,
+                                unsigned int        ybase,
+                                unsigned int        cbase,
+                                unsigned char       qtable[2][64]);
+
+static void spca504_initialize(struct usb_spca50x *spca50x);
+
+/*
+ * Simple function to wait for a given 8-bit value to be returned from
+ * a spca50x_reg_read call.
+ * Returns: negative is error or timeout, zero is success.
+ */
+static int spca50x_reg_readwait(struct usb_device *dev,
+                                __u16              reg,
+                                __u16              index,
+                                __u16              value)
+{
+	int count = 0;
+	int result = 0;
+
+	while (count < 20)
+	{
+		result = spca50x_reg_read(dev, reg, index, 1);
+		if (result == value) return 0;
+
+		wait_ms(50);
+
+		count++;
+	}
+
+	PDEBUG(2, "spca50x_reg_readwait failed");
+
+	return -EIO;
+}
+
+/**********************************************************************
+ *
+ * Memory management
+ *
+ * This is a shameless copy from the USB-cpia driver (linux kernel
+ * version 2.3.29 or so, I have no idea what this code actually does ;).
+ * Actually it seems to be a copy of a shameless copy of the bttv-driver.
+ * Or that is a copy of a shameless copy of ... (To the powers: is there
+ * no generic kernel-function to do this sort of stuff?)
+ *
+ * Yes, it was a shameless copy from the bttv-driver. IIRC, Alan says
+ * there will be one, but apparentely not yet -jerdfelt
+ *
+ * So I copied it again for the ov511 driver -claudio
+ * And again for the spca50x driver -jcrisp
+ **********************************************************************/
+
+/* Given PGD from the address space's page table, return the kernel
+ * virtual mapping of the physical memory mapped at ADR.
+ */
+static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
+{
+	unsigned long ret = 0UL;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+
+	if (!pgd_none(*pgd)) {
+		pmd = pmd_offset(pgd, adr);
+		if (!pmd_none(*pmd)) {
+			ptep = pte_offset(pmd, adr);
+			pte = *ptep;
+			if (pte_present(pte)) {
+				ret = (unsigned long) page_address(pte_page(pte));
+				ret |= (adr & (PAGE_SIZE - 1));
+			}
+		}
+	}
+
+	return ret;
+}
+
+/* Here we want the physical address of the memory.
+ * This is used when initializing the contents of the
+ * area and marking the pages as reserved.
+ */
+static inline unsigned long kvirt_to_pa(unsigned long adr)
+{
+	unsigned long va, kva, ret;
+
+	va = VMALLOC_VMADDR(adr);
+	kva = uvirt_to_kva(pgd_offset_k(va), va);
+	ret = __pa(kva);
+	return ret;
+}
+
+static void *rvmalloc(unsigned long size)
+{
+	void *mem;
+	unsigned long adr, page;
+
+	/* Round it off to PAGE_SIZE */
+	size += (PAGE_SIZE - 1);
+	size &= ~(PAGE_SIZE - 1);
+
+	mem = vmalloc_32(size);
+	if (!mem)
+		return NULL;
+
+	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
+	adr = (unsigned long) mem;
+	while (size > 0) {
+		page = kvirt_to_pa(adr);
+		mem_map_reserve(VIRT_TO_PAGE(__va(page)));
+		adr += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return mem;
+}
+
+static void rvfree(void *mem, unsigned long size)
+{
+	unsigned long adr, page;
+
+	if (!mem)
+		return;
+
+	size += (PAGE_SIZE - 1);
+	size &= ~(PAGE_SIZE - 1);
+
+	adr=(unsigned long) mem;
+	while (size > 0) {
+		page = kvirt_to_pa(adr);
+		mem_map_unreserve(VIRT_TO_PAGE(__va(page)));
+		adr += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+	vfree(mem);
+}
+
+/**********************************************************************
+ * Get average luminance
+ **********************************************************************/
+static inline __u8 get_avg_lum(struct usb_spca50x *spca50x)
+{
+	__u8 luminance; //The average luminance from camera
+	switch(spca50x->bridge)
+	{
+		case BRIDGE_SPCA501:
+			luminance = spca50x_reg_read(spca50x->dev, SPCA501_REG_CCDSP, 
+				0x26, 2) >> 8;
+			break;
+		default:
+			luminance = 0;
+			break;
+	}
+	return luminance;
+}
+
+/**********************************************************************
+ * Get average R-G and B-G
+ **********************************************************************/
+static inline __u8 get_avg_RG(struct usb_spca50x *spca50x)
+{
+	__u8 rg; //The average R-G for window5
+	switch(spca50x->bridge)
+	{
+		case BRIDGE_SPCA501:
+			rg = spca50x_reg_read(spca50x->dev, SPCA501_REG_CCDSP, 0x30, 
+				2) >> 8;
+			break;
+		default:
+			rg = 0;
+			break;
+	}
+	return rg;
+}
+
+/**********************************************************************
+ * Get average B-G
+ **********************************************************************/
+static inline __u8 get_avg_BG(struct usb_spca50x *spca50x)
+{
+	__u8 bg; //The average B-G for window5
+	switch(spca50x->bridge)
+	{
+		case BRIDGE_SPCA501:
+			bg = spca50x_reg_read(spca50x->dev, SPCA501_REG_CCDSP, 0x2f, 
+				2) >> 8;
+			break;
+		default:
+			bg = 0;
+			break;
+	}
+	return bg;
+}
+
+/**********************************************************************
+ * /proc interface
+ * Based on the CPiA driver version 0.7.4 -claudio
+ * ..and again copied from the ov511 driver for the SPCA50x driver - jac
+ **********************************************************************/
+
+#ifdef CONFIG_PROC_FS
+
+static struct proc_dir_entry *spca50x_proc_entry = NULL;
+#ifdef CONFIG_VIDEO_PROC_FS
+extern struct proc_dir_entry *video_proc_entry;
+#endif /* CONFIG_VIDEO_PROC_FS */
+
+#define YES_NO(x) ((x) ? "yes" : "no")
+
+static int spca50x_read_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	char *out = page;
+	int i, j, len;
+	struct usb_spca50x *spca50x = data;
+
+	/* IMPORTANT: This output MUST be kept under PAGE_SIZE
+	 *            or we need to get more sophisticated. */
+
+	out += sprintf (out, "driver          : SPCA50X USB Camera\n");
+	out += sprintf (out, "driver_version  : %s\n", version);
+	out += sprintf (out, "model           : %s\n", (spca50x->desc) ?
+	                     clist[spca50x->desc].description : "unknown");
+	out += sprintf (out, "streaming       : %s\n", YES_NO (spca50x->streaming));
+	out += sprintf (out, "grabbing        : %s\n", YES_NO (spca50x->grabbing));
+	out += sprintf (out, "compress        : %s\n", YES_NO (spca50x->compress));
+	out += sprintf (out, "data_format     : %s\n", spca50x->force_rgb ? "RGB" : "BGR");
+	out += sprintf (out, "brightness      : %d\n", spca50x->brightness >> 8);
+	out += sprintf (out, "colour          : %d\n", spca50x->colour >> 8);
+	out += sprintf (out, "hue             : %d\n", spca50x->hue >> 8);
+	out += sprintf (out, "contrast        : %d\n", spca50x->contrast);
+	out += sprintf (out, "num_frames      : %d\n", SPCA50X_NUMFRAMES);
+	out += sprintf (out, "curframe        : %d\n", spca50x->curframe);
+	out += sprintf (out, "lastFrameRead   : %d\n", spca50x->lastFrameRead);
+	spca50x->avg_lum = get_avg_lum(spca50x);
+	out += sprintf (out, "Avg. luminance  : 0x%X %d\n", 
+	                     spca50x->avg_lum, spca50x->avg_lum);
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++) {
+		out += sprintf (out, "frame           : %d\n", i);
+		out += sprintf (out, "  sequence      : %d\n", spca50x->frame[i].seq);
+		out += sprintf (out, "  grabstate     : %d\n", spca50x->frame[i].grabstate);
+		out += sprintf (out, "  depth         : %d\n",
+		                     spca50x->frame[i].depth);
+		out += sprintf (out, "  size          : %d %d\n",
+		                     spca50x->frame[i].width, spca50x->frame[i].height);
+		out += sprintf (out, "  format        : ");
+		for (j = 0; plist[j].num >= 0; j++) {
+			if (plist[j].num == spca50x->frame[i].format) {
+				out += sprintf (out, "%s\n", plist[j].name);
+				break;
+			}
+		}
+		if (plist[j].num < 0)
+			out += sprintf (out, "unknown\n");
+		out += sprintf (out, "  data_buffer   : 0x%p\n",
+		                     spca50x->frame[i].data);
+	}
+	out += sprintf (out, "snap_enabled    : %s\n", YES_NO (spca50x->snap_enabled));
+	out += sprintf (out, "packet_size     : %d\n", spca50x->packet_size);
+	out += sprintf (out, "internal ccd    : %s\n", YES_NO (!spca50x->ccd));
+	out += sprintf (out, "framebuffer     : 0x%p\n", spca50x->fbuf);
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	out += sprintf (out, "stable          : %d\n", spca50x->nstable);
+	out += sprintf (out, "unstable        : %d\n", spca50x->nunstable);
+	out += sprintf (out, "whiteness       : %d\n", spca50x->whiteness >> 12);
+	spca50x->avg_rg = get_avg_RG(spca50x);
+	spca50x->avg_bg = get_avg_BG(spca50x);
+	out += sprintf (out, "Avg. R-G/B-G  : 0x%X/0x%X %d/%d\n", 
+	                     spca50x->avg_rg, spca50x->avg_bg, 
+	                     (char)spca50x->avg_rg, (char)spca50x->avg_bg);
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0) 
+			return 0;
+	} else
+		len = count;
+
+	*start = page + off;
+
+	return len;
+}
+
+static int spca50x_write_proc(struct file *file, const char *buffer,
+			   unsigned long count, void *data)
+{
+	return -EINVAL;
+}
+
+/*
+ * Function services read requests to control proc entry
+ * and prints all the static variables
+ */
+static int spca50x_ctlread_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	char *out = page;
+	int len = 0;
+	struct usb_spca50x *spca50x = data;
+
+	out += sprintf(out, "force_rgb = %d\n", spca50x->force_rgb);
+	out += sprintf(out, "min_bpp = %d\n", spca50x->min_bpp);
+	out += sprintf(out, "lum_level = %d\n", spca50x->lum_level);
+	out += sprintf(out, "debug = %d\n", debug);
+#ifdef SPCA50X_ENABLE_OSD
+	out += sprintf(out, "osd = %d\n", osd);
+#endif /* SPCA50X_ENABLE_OSD */
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0) 
+			return 0;
+	} else
+		len = count;
+
+	*start = page + off;
+
+	return len;
+}
+
+/*
+ * Function compares two strings.
+ * Return offset in pussy where prick ends if "prick" may penetrate 
+ * int "pussy" like prick into pussy, -1 otherwise.
+ */
+static inline int match(const char* prick, const char* pussy, int len2)
+{
+	int len1 = strlen(prick); //length of male string
+	int i; //just an index variable
+	const char* tmp; //temporary pointer for my own pleasure
+
+	// We skip all spaces and tabs
+	for (i = 0; i < len2 && (pussy[i] == ' ' || pussy[i] == '\t'); i++)
+	{
+	} 
+
+	tmp = pussy + i; // pointer to pussy with skipped shit (spaces and tabs)
+	len2 = strlen(tmp); //calculate length again
+
+	if (len1 > len2)
+		return -1; //Fuck off, no fucking
+
+	if (!strncmp(prick, tmp, len1))
+		return i + len1;
+
+	return -1;
+}
+
+#ifdef SPCA50X_ENABLE_RAWPROCENTRY
+static int spca50x_rawread_proc(char  *page,
+                                char **start,
+                                off_t  off,
+                                int    count,
+                                int   *eof,
+                                void  *data)
+{
+	struct usb_spca50x *spca50x = data;
+
+	*start = page;
+
+	/* check whether the buffer exists */
+	if (spca50x->rawBuffer == NULL)
+	{
+		*eof = 1;
+		return 0;
+	}
+
+	/* check offset is valid */
+	if (off > spca50x->rawBufferSize)
+	{
+		*eof = 1;
+		return 0;
+	}
+
+	/* can't read more than exists in the buffer, either */
+	if ((count+off) > spca50x->rawBufferSize)
+	{
+		count = spca50x->rawBufferSize - off;
+	}
+
+	/* can't read more than is available in the output buffer */
+	if (count > PAGE_SIZE)
+	{
+		count = PAGE_SIZE;
+	}
+
+	if (count == 0)
+	{
+		*eof = 1;
+		return 0;
+	}
+
+	/* populate the output buffer */
+	memcpy(page, spca50x->rawBuffer + off, count);
+
+	/* return read count */
+	return count;
+}
+
+static int spca50x_rawwrite_proc(struct file  *file,
+                                 const char   *buffer,
+                                 unsigned long count,
+                                 void         *data)
+{
+	struct usb_spca50x *spca50x = data;
+
+	/* if anything is written, flush the buffer */
+	PDEBUG(3, "flushed raw proc entry buffer");
+	spca50x->rawBufferSize = 0;
+
+	return count;
+}
+#endif /* SPCA50X_ENABLE_RAWPROCENTRY */
+
+/*
+ * Try to calculate value from string (atoi). Converts  
+ * decimal integer
+ */
+static inline int atoi(const char* str)
+{
+	int result = 0; //result of the function
+	int i; //just an index variable
+
+	for (i = 0; str[i] >= '0' && str[i] <= '9'; i++)
+	{
+		result *= 10;
+		result += str[i] - '0';
+	}
+	return result;
+}
+
+
+static int spca50x_ctlwrite_proc(struct file *file, const char *buffer,
+			   unsigned long count, void *data)
+{
+	int off; //where look for a value
+	struct usb_spca50x *spca50x = data;
+
+	if ((off = match("lum_level=", buffer, count)) >= 0)
+		spca50x->lum_level = atoi(buffer + off);
+	if ((off = match("min_bpp=", buffer, count)) >= 0)
+		spca50x->min_bpp = atoi(buffer + off);
+	if ((off = match("force_rgb=", buffer, count)) >= 0)
+		spca50x->force_rgb = atoi(buffer + off);
+	if ((off = match("debug=", buffer, count)) >= 0)
+		debug = atoi(buffer + off);
+
+	return count;
+}
+
+static void create_proc_spca50x_cam (struct usb_spca50x *spca50x)
+{
+	char name[PROC_NAME_LEN];
+	struct proc_dir_entry *ent;
+
+	if (!spca50x_proc_entry || !spca50x)
+		return;
+
+//Create videoxx proc entry
+	sprintf(name, "video%d", spca50x->vdev.minor);
+	PDEBUG (4, "creating /proc/video/spca50x/%s", name);
+
+	ent = create_proc_entry(name, S_IFREG|S_IRUGO|S_IWUSR, spca50x_proc_entry);
+
+	if (!ent)
+		return;
+
+	ent->data = spca50x;
+	ent->read_proc = spca50x_read_proc;
+	ent->write_proc = spca50x_write_proc;
+	spca50x->proc_entry = ent;
+
+// Create the controlxx proc entry
+	sprintf(name, "control%d", spca50x->vdev.minor);
+	PDEBUG (4, "creating /proc/video/spca50x/%s", name);
+	ent = create_proc_entry(name, S_IFREG|S_IRUGO|S_IWUSR, 
+		spca50x_proc_entry);
+
+	if (!ent)
+		return;
+
+	ent->data = spca50x;
+	ent->read_proc = spca50x_ctlread_proc;
+	ent->write_proc = spca50x_ctlwrite_proc;
+	spca50x->ctl_proc_entry = ent;
+
+#ifdef SPCA50X_ENABLE_RAWPROCENTRY
+// Create the rawxx proc entry
+	sprintf(name, "raw%d", spca50x->vdev.minor);
+	PDEBUG (4, "creating /proc/video/spca50x/%s", name);
+	ent = create_proc_entry(name, S_IFREG|S_IRUGO|S_IWUSR, 
+		spca50x_proc_entry);
+
+	if (!ent)
+		return;
+
+	ent->data = spca50x;
+	ent->read_proc = spca50x_rawread_proc;
+	ent->write_proc = spca50x_rawwrite_proc;
+	spca50x->raw_proc_entry = ent;
+	spca50x->rawBufferSize = 0;
+	spca50x->rawBuffer = vmalloc(10*1024*1024);
+	if (spca50x->rawBuffer != NULL)
+	{
+		spca50x->rawBufferMax = 10*1024*1024;
+		PDEBUG(3, "allocated 10Mb raw proc entry buffer");
+	}
+	else
+	{
+		PDEBUG(3, "vmalloc of raw proc entry buffer failed");
+		spca50x->rawBufferMax  = 0;
+	}
+#endif /* SPCA50X_ENABLE_RAWPROCENTRY */
+}
+
+static void destroy_proc_spca50x_cam (struct usb_spca50x *spca50x)
+{
+	char name[PROC_NAME_LEN];
+
+	if (!spca50x || !spca50x_proc_entry)
+		return;
+
+	/* destroy videoxx proc entry */
+	if (spca50x->proc_entry != NULL)
+	{
+		sprintf(name, "video%d", spca50x->vdev.minor);
+		PDEBUG (4, "destroying %s", name);
+		remove_proc_entry(name, spca50x_proc_entry);
+		spca50x->proc_entry = NULL;
+	}
+
+	/* destroy controlxx proc entry */
+	if (spca50x->ctl_proc_entry != NULL)
+	{
+		sprintf(name, "control%d", spca50x->vdev.minor);
+		PDEBUG (4, "destroying %s", name);
+		remove_proc_entry(name, spca50x_proc_entry);
+		spca50x->ctl_proc_entry = NULL;
+	}
+
+#ifdef SPCA50X_ENABLE_RAWPROCENTRY
+	/* destroy rawxx proc entry */
+	if (spca50x->raw_proc_entry != NULL)
+	{
+		sprintf(name, "raw%d", spca50x->vdev.minor);
+		remove_proc_entry(name, spca50x_proc_entry);
+		spca50x->raw_proc_entry = NULL;
+		vfree(spca50x->rawBuffer);
+	}
+#endif /* SPCA50X_ENABLE_RAWPROCENTRY */
+
+	/* free the temporary jpeg workspace */
+	vfree(spca50x->tmpBuffer);
+}
+
+static void proc_spca50x_create(void)
+{
+	/* No current standard here. Alan prefers /proc/video/ as it keeps
+	 * /proc "less cluttered than /proc/randomcardifoundintheshed/"
+	 * -claudio
+	 */
+
+#ifdef CONFIG_VIDEO_PROC_FS
+	if (video_proc_entry == NULL) {
+		err("Unable to initialise /proc/video/spca50x");
+		return;
+	}
+	spca50x_proc_entry = create_proc_entry("spca50x", S_IFDIR, video_proc_entry);
+#else /* CONFIG_VIDEO_PROC_FS */
+	spca50x_proc_entry = create_proc_entry("spca50x", S_IFDIR, 0);
+#endif /* CONFIG_VIDEO_PROC_FS */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+	if (spca50x_proc_entry)
+		spca50x_proc_entry->owner = THIS_MODULE;
+	else
+#ifdef CONFIG_VIDEO_PROC_FS
+		err("Unable to initialise /proc/video/spca50x");
+#else /* CONFIG_VIDEO_PROC_FS */
+		err("Unable to initialise /proc/spca50x");
+#endif /* CONFIG_VIDEO_PROC_FS */
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0) */
+}
+
+static void proc_spca50x_destroy(void)
+{
+#ifdef CONFIG_VIDEO_PROC_FS
+	PDEBUG (3, "removing /proc/video/spca50x");
+#else /* CONFIG_VIDEO_PROC_FS */
+	PDEBUG (3, "removing /proc/spca50x");
+#endif /* CONFIG_VIDEO_PROC_FS */
+
+	if (spca50x_proc_entry == NULL)
+		return;
+
+#ifdef CONFIG_VIDEO_PROC_FS
+	remove_proc_entry("spca50x", video_proc_entry);
+#else /* CONFIG_VIDEO_PROC_FS */
+	remove_proc_entry("spca50x", 0);
+#endif /* CONFIG_VIDEO_PROC_FS */
+}
+#endif /* CONFIG_PROC_FS */
+
+/**********************************************************************
+ *
+ * Camera interface
+ *
+ **********************************************************************/
+
+static int spca50x_reg_write(struct usb_device *dev,
+			   __u16 reg,
+			   __u16 index,
+			   __u16 value)
+{
+	int rc;
+
+	rc = usb_control_msg(dev,
+		usb_sndctrlpipe(dev, 0),
+		reg,
+		USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		value, index, NULL, 0, HZ);
+
+	PDEBUG(5, "reg write: 0x%02X,0x%02X:0x%02X, 0x%x", reg, index, value, rc);
+
+	if (rc < 0)
+		err("reg write: error %d", rc);
+
+	return rc;
+}
+
+static int spca50x_reg_read_with_value(struct usb_device *dev,
+                                       __u16              reg, // bRequest
+                                       __u16              value, // wValue
+                                       __u16              index, // wIndex
+                                       __u16              length) // wLength
+{
+	int rc;
+	unsigned char buffer[4]={0,0,0,0};
+
+	rc = usb_control_msg(dev,
+		usb_rcvctrlpipe(dev, 0),
+		reg,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		(__u16)value, (__u16)index, buffer, length, HZ);
+
+	PDEBUG(5, "reg read: 0x%02X,0x%02X:0x%04X", reg, index, *(int *)&buffer[0]);
+
+	if (rc < 0) {
+		err("reg read: error %d", rc);
+		return rc;
+	} else {
+		return *(int *)&buffer[0];
+	}
+}
+
+/* returns: negative is error, pos or zero is data */
+static int spca50x_reg_read(struct usb_device *dev, 
+                            __u16              reg, // bRequest
+                            __u16              index, // wIndex
+                            __u16              length) // wLength
+{
+	return spca50x_reg_read_with_value(dev, reg, 0, index, length);
+}
+
+/* Read a value from the I2C bus. Returns the value read */
+static int spca50x_read_i2c(struct usb_spca50x *spca50x,__u16 device,__u16 address)
+{
+	struct usb_device *dev = spca50x->dev;
+	int err_code;
+	int retry;
+	int ctrl = spca50x->i2c_ctrl_reg; //The I2C control register
+	int base = spca50x->i2c_base; //The I2C base address
+
+	err_code = spca50x_reg_write(dev, ctrl, base + SPCA50X_I2C_DEVICE, device);
+	err_code = spca50x_reg_write(dev, ctrl, base + SPCA50X_I2C_SUBADDR, address);
+	err_code = spca50x_reg_write(dev, ctrl, base + SPCA50X_I2C_TRIGGER, 
+		SPCA50X_I2C_TRIGGER_BIT);
+	/* Hmm. 506 docs imply we should poll the ready register before reading the return value */
+	/* Poll the status register for a ready status*/
+	/* Doesn't look like the windows driver does tho' */
+	retry = 60;
+	while(--retry)
+	{
+		err_code = spca50x_reg_read(dev, ctrl, base + SPCA50X_I2C_STATUS, 1);
+		if (err_code < 0) 
+			PDEBUG(1, "Error reading I2C status register");
+		if (!err_code) 
+			break;
+	}
+	if (!retry) 
+		PDEBUG(1, "Too many retries polling I2C status after write to register");
+	err_code = spca50x_reg_read(dev, ctrl, base + SPCA50X_I2C_READ, 1);
+	if (err_code < 0) 
+		PDEBUG(1, "Failed to read I2C register at %d:%d",device,address);
+	PDEBUG(3, "Read %d from %d:%d",err_code,device,address);
+	return err_code;
+}
+
+static int spca50x_read_SAA7113_status(struct usb_spca50x *spca50x)
+{
+	int value=0;
+
+	value=spca50x_read_i2c(spca50x,SAA7113_I2C_BASE_READ,SAA7113_REG_STATUS);
+	if(value<0) PDEBUG(1,"Failed to read SAA7113 status");
+
+	PDEBUG(1,"7113 status : ");
+	PDEBUG(1,"  READY %s",(SAA7113_STATUS_READY(value)?"YES":"NO"));
+	PDEBUG(1,"  COPRO %s",(SAA7113_STATUS_COPRO(value)?"YES":"NO"));
+	/*PDEBUG(1,"  SLTCA %s",(SAA7113_STATUS_SLTCA(value)?"YES":"NO"));*/
+	PDEBUG(1,"  WIPA  %s",(SAA7113_STATUS_WIPA(value)?"YES":"NO"));
+	PDEBUG(1,"  GLIMB %s",(SAA7113_STATUS_GLIMB(value)?"YES":"NO"));
+	PDEBUG(1,"  GLIMT %s",(SAA7113_STATUS_GLIMT(value)?"YES":"NO"));
+	PDEBUG(1,"  FIDT  %s",(SAA7113_STATUS_FIDT(value)?"YES":"NO"));
+	PDEBUG(1,"  HLVLN %s",(SAA7113_STATUS_HLVLN(value)?"YES":"NO"));
+	PDEBUG(1,"  INTL  %s",(SAA7113_STATUS_INTL(value)?"YES":"NO"));
+
+	return value;
+}
+
+static int spca50x_write_i2c(struct usb_spca50x *spca50x,__u16 device,__u16 subaddress,__u16 data)
+{
+	struct usb_device *dev=spca50x->dev;
+	int err_code;
+	int retry;
+	int ctrl = spca50x->i2c_ctrl_reg; //The I2C control register
+	int base = spca50x->i2c_base; //The I2C base address
+
+	/* Tell the SPCA50x i2c subsystem the device address of the i2c device */
+	err_code = spca50x_reg_write(dev, ctrl, base + SPCA50X_I2C_DEVICE,device);
+
+	/* Poll the status register for a ready status*/
+	retry = 60; // Arbitrary
+	while(--retry)
+	{
+		err_code = spca50x_reg_read(dev, ctrl, base + SPCA50X_I2C_STATUS, 1);
+		if (err_code < 0) 
+			PDEBUG(1,"Error reading I2C status register");
+		if (!err_code) 
+			break;
+	}
+	if (!retry) 
+		PDEBUG(1, "Too many retries polling I2C status");
+
+	err_code = spca50x_reg_write(dev, ctrl, base + SPCA50X_I2C_SUBADDR, subaddress);
+	err_code = spca50x_reg_write(dev, ctrl, base + SPCA50X_I2C_VALUE,data);
+	if (spca50x->i2c_trigger_on_write)
+		err_code = spca50x_reg_write(dev, ctrl, base + SPCA50X_I2C_TRIGGER,
+			SPCA50X_I2C_TRIGGER_BIT);
+
+	/* Poll the status register for a ready status*/
+	retry = 60;
+	while(--retry)
+	{
+		err_code=spca50x_reg_read(dev, ctrl, SPCA50X_I2C_STATUS, 2);
+		if (err_code < 0) 
+			PDEBUG(1,"Error reading I2C status register");
+		if (!err_code) 
+			break;
+	}
+	if (!retry) 
+		PDEBUG(1, "Too many retries polling I2C status after write to register");
+
+	if (debug > 2)
+	{
+		err_code = spca50x_read_i2c(spca50x, device, subaddress);
+		if (err_code < 0) 
+		{
+			PDEBUG(3, "Can't read back I2C register value for %d:%d",
+				device, subaddress); 
+		}
+		else if ((err_code & 0xff) != (data & 0xff)) 
+			PDEBUG(3, "Read back %x should be %x at subaddr %x",
+				err_code, data, subaddress);
+	}
+	return 0;
+}
+
+static int spca50x_write_i2c_vector(struct usb_spca50x *spca50x,__u16 device,__u16 data[][2])
+{
+	int I=0;
+
+	while(data[I][0])
+	{
+		spca50x_write_i2c(spca50x,device,data[I][0],data[I][1]);
+		I++;
+	}
+	return 0;
+}
+
+static int spca50x_write_vector(struct usb_spca50x *spca50x,__u16 data[][3])
+{
+	struct usb_device *dev=spca50x->dev;
+	int err_code;
+
+	int I=0;
+	while((data[I][0])!=(__u16)0 || (data[I][1])!=(__u16)0 || (data[I][2])!=(__u16)0)
+	{
+		err_code = spca50x_reg_write(dev, data[I][0], (__u16)(data[I][2]), 
+			(__u16)(data[I][1]));
+		if(err_code < 0) 
+		{ 
+			PDEBUG(1, "Register write failed for 0x%x,0x%x,0x%x", 
+				data[I][0],data[I][1], data[I][2]); 
+			return -1; 
+		}
+		I++;
+	}
+	return 0;
+}
+
+static int spca50x_reset(struct usb_device *dev, unsigned char reset_type)
+{
+	PDEBUG(4, "Reset: type=0x%X (Currently unimplemented)", reset_type);
+
+	return 0;
+}
+
+/* Temporarily stops SPCA50X from functioning. Must do this before changing
+ * registers while the camera is streaming */
+static inline int spca50x_stop(struct usb_device *dev)
+{
+	PDEBUG(4, "stopping (unimplemented)");
+	return 0;
+}
+
+/* Restarts SPCA50X after spca50x_stop() is called */
+static inline int spca50x_restart(struct usb_device *dev)
+{
+	PDEBUG(4, "restarting (unimplemented)");
+	return 0;
+}
+
+static int spca50x_set_packet_size(struct usb_spca50x *spca50x, int size)
+{
+	int alt, mult;
+
+	if (spca50x_stop(spca50x->dev) < 0)
+		return -EIO;
+
+	mult = size >> 5;
+
+	if      (size == 0)    alt = SPCA50X_ALT_SIZE_0;
+	else if (size == 128)  alt = SPCA50X_ALT_SIZE_128;
+	else if (size == 256)  alt = SPCA50X_ALT_SIZE_256;
+	else if (size == 384)  alt = SPCA50X_ALT_SIZE_384;
+	else if (size == 512)  alt = SPCA50X_ALT_SIZE_512;
+	else if (size == 640)  alt = SPCA50X_ALT_SIZE_640;
+	else if (size == 768)  alt = SPCA50X_ALT_SIZE_768;
+	else if (size == 896)  alt = SPCA50X_ALT_SIZE_896;
+	else if (size == 1023) alt = SPCA50X_ALT_SIZE_1023;
+	else
+	{
+		/* if an unrecognised size, default to the minimum */
+		PDEBUG(5,"Set packet size: invalid size (%d), defaulting to %d",
+		         size, SPCA50X_ALT_SIZE_128);
+		alt = SPCA50X_ALT_SIZE_128;
+	}
+
+	PDEBUG(3, "set packet size: %d, mult=%d, alt=%d", size, mult, alt);
+
+	/* FIXME: Should do this. Don't know how to on SPCA50x.
+	 *        if (spca50x_reg_write(spca50x->dev, SPCA50X_REG_FIFO_PACKET_SIZE, mult) < 0)
+	 *            return -ENOMEM;
+	 */
+
+	if (usb_set_interface(spca50x->dev, spca50x->iface, alt) < 0) {
+		err("Set packet size: set interface error");
+		return -EBUSY;
+	}
+
+	/* FIXME: Should we only reset the FIFO?
+	 *        if (spca50x_reset(spca50x->dev, SPCA50X_RESET_NOREGS) < 0)
+	 *            return -ENOMEM;
+	 */
+
+	spca50x->packet_size = size;
+
+	if (spca50x_restart(spca50x->dev) < 0)
+		return -EIO;
+
+	return 0;
+}
+
+/* Returns number of bits per pixel (regardless of where they are located; planar or
+ * not), or zero for unsupported format.
+ */
+static int spca50x_get_depth(int palette)
+{
+	switch (palette)
+	{
+	case VIDEO_PALETTE_GREY:     return 8;
+	case VIDEO_PALETTE_RGB565:   return 16;
+	case VIDEO_PALETTE_RGB24:    return 24;
+	case VIDEO_PALETTE_YUV422:   return 16;
+	case VIDEO_PALETTE_YUYV:     return 16;
+	case VIDEO_PALETTE_YUV420:   return 24;
+	case VIDEO_PALETTE_YUV422P:  return 24; /* Planar */
+	case VIDEO_PALETTE_RGB32:    return 32;
+	case VIDEO_PALETTE_RAW_JPEG: return 24; /* raw jpeg. what should we return ?? */
+	default:                     return 0;  /* Invalid format */
+	}
+}
+
+/**********************************************************************
+* spca50x_isoc_irq
+* Function processes the finish of the USB transfer by calling 
+* spca50x_move_data function to move data from USB buffer to internal
+* driver structures 
+***********************************************************************/
+static void spca50x_isoc_irq(struct urb *urb)
+{
+	int len;
+	struct usb_spca50x *spca50x;
+
+	if (!urb->context) 
+	{
+		PDEBUG(4, "no context");
+		return;
+	}
+
+	spca50x = (struct usb_spca50x *) urb->context;
+
+	if (!spca50x->dev || !spca50x->user) {
+		PDEBUG(4, "no device, or not open");
+		return;
+	}
+
+	if (!spca50x->streaming) {
+	  /* Always get some of these after close but before packet engine stops */
+		PDEBUG(4, "hmmm... not streaming, but got interrupt");
+		return;
+	}
+
+	/* Copy the data received into our scratch buffer */
+	if (spca50x->curframe >= 0) {
+		len = spca50x_move_data(spca50x, urb);
+	}
+	else if (waitqueue_active(&spca50x->wq)) {
+		wake_up_interruptible(&spca50x->wq);
+	}
+
+	/* Move to the next sbuf */
+	spca50x->cursbuf = (spca50x->cursbuf + 1) % SPCA50X_NUMSBUF;
+
+	urb->dev = spca50x->dev;
+
+	/* let's try to set up brightness for the next frame*/
+	if (autoadjust && !spca50x->bh_requested)
+	{
+		spca50x->task.data = spca50x;
+		spca50x->task.sync = 0;
+		spca50x->task.routine = auto_bh;
+		SCHEDULE_TASK(&spca50x->task);
+		spca50x->bh_requested = 1;
+	}
+	return;
+}
+
+
+/**********************************************************************
+* spca50x_init_isoc
+* Function starts the ISO USB transfer by enabling this process
+* from USB side and enabling ISO machine from the chip side
+***********************************************************************/
+static int spca50x_init_isoc(struct usb_spca50x *spca50x)
+{
+	struct usb_device *dev=spca50x->dev;
+	struct urb *urb;
+	int fx, err, n;
+	int err_code;
+
+	PDEBUG(3, "*** Initializing capture ***");
+
+	spca50x->compress = 0;
+	spca50x->curframe = 0;
+	spca50x->cursbuf = 0;
+	spca50x->scratchlen = 0;
+
+	spca50x_set_packet_size(spca50x, spca50x->pipe_size);
+	PDEBUG(3, "setpacketsize %d",spca50x->pipe_size);
+
+	for (n = 0; n < SPCA50X_NUMSBUF; n++) {
+		urb = usb_alloc_urb(FRAMES_PER_DESC);
+
+		if (!urb) {
+			err("init isoc: usb_alloc_urb ret. NULL");
+			return -ENOMEM;
+		}
+		spca50x->sbuf[n].urb = urb;
+		urb->dev = spca50x->dev;
+		urb->context = spca50x;
+		urb->pipe = usb_rcvisocpipe(spca50x->dev, SPCA50X_ENDPOINT_ADDRESS);
+		urb->transfer_flags = USB_ISO_ASAP;
+		urb->transfer_buffer = spca50x->sbuf[n].data;
+		urb->complete = spca50x_isoc_irq;
+		urb->number_of_packets = FRAMES_PER_DESC;
+		urb->transfer_buffer_length = spca50x->packet_size * FRAMES_PER_DESC;
+		for (fx = 0; fx < FRAMES_PER_DESC; fx++) {
+			urb->iso_frame_desc[fx].offset = spca50x->packet_size * fx;
+			urb->iso_frame_desc[fx].length = spca50x->packet_size;
+		}
+	}
+
+	spca50x->sbuf[SPCA50X_NUMSBUF - 1].urb->next = spca50x->sbuf[0].urb;
+	for (n = 0; n < SPCA50X_NUMSBUF - 1; n++)
+		spca50x->sbuf[n].urb->next = spca50x->sbuf[n + 1].urb;
+
+	for (n = 0; n < SPCA50X_NUMSBUF; n++) {
+		spca50x->sbuf[n].urb->dev = spca50x->dev;
+		err = usb_submit_urb(spca50x->sbuf[n].urb);
+		if (err)
+			err("init isoc: usb_submit_urb(%d) ret %d", n, err);
+	}
+
+	for (n = 0; n < SPCA50X_NUMFRAMES; n++)
+	{
+		spca50x->frame[n].grabstate = FRAME_UNUSED;
+		spca50x->frame[n].scanstate = STATE_SCANNING;
+	}
+
+	switch(spca50x->bridge)
+	{
+		case BRIDGE_SPCA500:
+		{
+			err_code = spca500_initialise(spca50x);
+			if (err_code < 0)
+			{
+				PDEBUG(2, "spca500_initialise() failed");
+				goto failure;
+			}
+
+			init_jpeg_decoder();
+			break;
+		}
+
+		case BRIDGE_SPCA501:
+		{
+			/* Enable ISO packet machine CTRL reg=2,
+			 * index=1 bitmask=0x2 (bit ordinal 1)
+			 */
+			err_code = spca50x_reg_write(dev, SPCA501_REG_CTLRL, 
+			                             (__u16)0x1, (__u16)0x2);
+			break;
+		}
+
+		case BRIDGE_SPCA504:
+			spca504_initialize(spca50x);
+			init_jpeg_decoder();
+			break;
+
+		case BRIDGE_SPCA505:
+		case BRIDGE_SPCA506:
+		{
+			/* Enable ISO packet machine - should we do this here or in ISOC init ? */
+			err_code = spca50x_reg_write(dev, SPCA50X_REG_USB,
+				SPCA50X_USB_CTRL, SPCA50X_CUSB_ENABLE);
+			if(err_code < 0)
+			{
+				PDEBUG(1, "register write failed for  err=%d", err_code);
+				goto failure;
+			}
+			spca50x_reg_write(dev, 0x5, 0x0, 0x0);
+			spca50x_reg_write(dev, 0x5, 0x0, 0x1);
+			spca50x_reg_write(dev, 0x5, 0x11, 0x2);
+			break;
+		}
+
+		case BRIDGE_SPCA508:
+		{
+			/* Video ISO enable, Video Drop Packet enable: */
+			err_code = spca50x_reg_write(dev, 0, 0x8112, 0x10 | 0x20); 
+			break;
+		}
+	}
+
+	usb_clear_halt(dev, 1);
+
+	spca50x->streaming = 1;
+
+	return 0;
+
+failure:
+	spca50x_set_packet_size(spca50x, 0);
+
+	/* Unschedule all of the iso td's */
+	for (n = SPCA50X_NUMSBUF - 1; n >= 0; n--) {
+		if (spca50x->sbuf[n].urb) {
+			spca50x->sbuf[n].urb->next = NULL;
+			usb_unlink_urb(spca50x->sbuf[n].urb);
+			usb_free_urb(spca50x->sbuf[n].urb);
+			spca50x->sbuf[n].urb = NULL;
+		}
+	}
+
+	return -EIO;
+}
+
+
+/**********************************************************************
+* spca50x_stop_isoc
+* Function stops the USB ISO pipe by stopping the chip ISO machine
+* and stopping USB transfer
+***********************************************************************/
+static void spca50x_stop_isoc(struct usb_spca50x *spca50x)
+{
+	int n;
+
+	if (!spca50x->streaming || !spca50x->dev)
+		return;
+
+	PDEBUG (3, "*** Stopping capture ***");
+
+	/* For some reason this seems to lock the driver on close as
+	 * still in use
+	 */
+	switch(spca50x->bridge)
+	{
+		case BRIDGE_SPCA500:
+		{
+			/* stop the transfer */
+			spca50x_reg_write(spca50x->dev, 0xe1, 0x0001, 0x0000);
+			if (spca50x_reg_readwait(spca50x->dev, 0x06, 0, 0) != 0)
+			{
+				PDEBUG(2, "spca50x_reg_readwait() failed");
+			}
+
+			spca50x_reg_write(spca50x->dev, 0x0c, 0x0000, 0x0000);
+			spca50x_reg_write(spca50x->dev, 0x30, 0x0000, 0x0004);
+			if (spca500_full_reset(spca50x) < 0)
+			{
+				PDEBUG(2, "spca50x_full_reset() failed");
+			}
+			break;
+		}
+		case BRIDGE_SPCA501:
+		{
+			/* Disable ISO packet machine CTRL reg=2, index=1 bitmask=0x0 (bit ordinal 1)*/
+			spca50x_reg_write(spca50x->dev, SPCA501_REG_CTLRL, 
+				(__u16)0x1, (__u16)0x0);
+			break;
+		}
+		case BRIDGE_SPCA504:
+			spca50x_reg_write(spca50x->dev, 0x00, 0x2000, 0x0000);
+			spca504_acknowledged_command(spca50x, 0x24, 0x0000, 0x0000);
+			spca50x_reg_write(spca50x->dev, 0x01, 0x000f, 0x0);
+			break;
+		case BRIDGE_SPCA505:
+		case BRIDGE_SPCA506:
+		{
+			spca50x_reg_write(spca50x->dev,0x2,0x0,0x0); //Disable ISO packet machine
+			break;
+		}
+		case BRIDGE_SPCA508:
+		{
+			// Video ISO disable, Video Drop Packet enable:
+			spca50x_reg_write(spca50x->dev, 0, 0x8112, 0x20); 
+			break;
+		}
+	}
+
+	spca50x_set_packet_size(spca50x, 0);
+
+	spca50x->streaming = 0;
+
+	/* Unschedule all of the iso td's */
+	for (n = SPCA50X_NUMSBUF - 1; n >= 0; n--) {
+		if (spca50x->sbuf[n].urb) {
+			spca50x->sbuf[n].urb->next = NULL;
+			usb_unlink_urb(spca50x->sbuf[n].urb);
+			usb_free_urb(spca50x->sbuf[n].urb);
+			spca50x->sbuf[n].urb = NULL;
+		}
+	}
+	PDEBUG (3, "*** Capture stopped ***");
+}
+
+/**********************************************************************
+* spca50x_find_mode_index
+* Function finds the mode index in the modes table
+***********************************************************************/
+static inline int spca50x_find_mode_index(int   width,
+                                          int   height, 
+                                          __u16 ext_modes [][6])
+{
+	int i = 0;
+
+	/* search through the mode list until we hit one which has
+	 * a smaller or equal resolution, or we run out of modes.
+	 */
+	for (i = 0; ext_modes[i][0] && 
+		(ext_modes[i][0] > width || ext_modes[i][1] > height);
+		i++)
+	{
+	}
+
+	/* check whether we found the requested mode, or ran out of
+	 * modes in the list.
+	 */
+	if (!ext_modes[i][0]         ||
+	    ext_modes[i][0] != width ||
+	    ext_modes[i][1] != height)
+	{
+		PDEBUG(3, "Failed to find mode %d x %d", width, height);
+		return -EINVAL;
+	}
+
+	/* return the index of the requested mode */
+	return i;
+}
+
+/**********************************************************************
+* spca50x_smallest_mode_index
+* Function finds the mode index in the modes table of the smallest
+* available mode.
+***********************************************************************/
+static inline int spca50x_smallest_mode_index(__u16 ext_modes [][6],
+                                              int  *cols,
+                                              int  *rows)
+{
+	int i;
+	int width  = INT_MAX;
+	int height = INT_MAX;
+	int index  = -EINVAL;
+
+	/* search through the mode list until we run out of modes */
+	for (i = 0; ext_modes[i][0]; i++)
+	{
+		if (ext_modes[i][0] < width || ext_modes[i][1] < height)
+		{
+			width  = ext_modes[i][0];
+			height = ext_modes[i][1];
+			index  = i;
+		}
+	}
+
+	/* return the index of the smallest mode */
+	if (index != -EINVAL)
+	{
+		if (cols != NULL)
+			*cols = width;
+		if (rows != NULL)
+			*rows = height;
+	}
+	return i;
+}
+
+/**********************************************************************
+* spca50x_set_mode
+* Function sets up the resolution directly. 
+* Attention!!! index, the index in modes array is NOT checked. 
+***********************************************************************/
+static inline int spca50x_set_mode(struct usb_spca50x *spca50x,
+                                   int                 index,
+                                   __u16               ext_modes [][6])
+{
+	struct usb_device *dev = spca50x->dev;
+	int i;
+
+	if (spca50x->bridge == BRIDGE_SPCA505 || spca50x->bridge == BRIDGE_SPCA506)
+	{
+		spca50x_reg_write(dev, SPCA50X_REG_COMPRESS, 0x0, ext_modes[index][2]);
+		if (spca50x->bridge == BRIDGE_SPCA505)
+		{
+			spca50x_reg_write(dev, SPCA50X_REG_COMPRESS, 0x6, 
+				ext_modes[index][3]);
+			spca50x_reg_write(dev, SPCA50X_REG_COMPRESS, 0x7, 
+				ext_modes[index][4]);
+		}
+	}
+	else if (spca50x->bridge == BRIDGE_SPCA501)
+	{
+		spca50x_reg_write(dev, SPCA50X_REG_USB, 0x6, ext_modes[index][3]);
+		spca50x_reg_write(dev, SPCA50X_REG_USB, 0x7, ext_modes[index][4]);
+	} 
+	else if (spca50x->bridge == BRIDGE_SPCA508) 
+	{
+		spca50x_reg_write(dev, 0, 0x8500, ext_modes[index][2]); // mode
+		spca50x_reg_write(dev, 0, 0x8700, ext_modes[index][3]); // clock
+	}
+	else if (spca50x->bridge == BRIDGE_SPCA500)
+	{
+		/* do nothing */
+	}
+	else if (spca50x->bridge == BRIDGE_SPCA504)
+	{
+		spca504_acknowledged_command(spca50x,0x8, ext_modes[index][3],0);
+	}
+
+	spca50x->pipe_size = ext_modes[index][5];
+
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++) 
+	{
+		spca50x->frame[i].width = spca50x->width;
+		spca50x->frame[i].height = spca50x->height;
+		spca50x->frame[i].scanlength = spca50x->width * spca50x->height * 3 / 2; 
+		// assumes 4:2:0 data
+	}
+
+	return 0;
+}
+
+/**********************************************************************
+* spca50x_mode_init_regs
+* Function sets up the resolution with checking if it's necessary 
+***********************************************************************/
+static int
+spca50x_mode_init_regs(struct usb_spca50x *spca50x,
+		       int width, int height, int mode, __u16 ext_modes [][6])
+{
+	int i;
+	int r;
+	int was_streaming;
+
+	/* Avoid changing to already selected mode */
+	if(spca50x->width == width && spca50x->height == height) 
+		return 0;
+
+	/* Can't do this yet on the CCD .. or can we ? It appears we can ! */
+	/*        if(spca50x->ccd) return -ECHRNG; */
+
+	/* find a suitable mode */
+	if ((i = spca50x_find_mode_index(width, height, ext_modes)) == -EINVAL)
+		return -EINVAL;
+
+	/* make sure that the suitable mode isn't the current mode */
+	if (spca50x->width  == ext_modes[i][0] &&
+	    spca50x->height == ext_modes[i][1]) 
+		return 0;
+
+	PDEBUG(1, "Mode changing to %d,%d", width, height);
+
+	down(&spca50x->lock);
+
+	was_streaming = spca50x->streaming;
+	if (was_streaming) 
+		spca50x_stop_isoc(spca50x);
+
+	spca50x->width  = ext_modes[i][0];
+	spca50x->height = ext_modes[i][1];
+
+	spca50x_set_mode(spca50x, i, ext_modes);
+
+	r = 0;
+	if (was_streaming) 
+		r = spca50x_init_isoc(spca50x);
+
+	up(&spca50x->lock);
+
+	return r;
+}
+
+/**********************************************************************
+* spca50x_get_brightness
+* Function reads the brightness from the camera
+* Receives the pointer to the description structure
+* returns the value of prightness
+**********************************************************************/
+static inline __u16 spca50x_get_brightness(struct usb_spca50x *spca50x)
+{
+	__u16 brightness; // value of the brightness
+	if(spca50x->ccd)
+		brightness = spca50x_read_i2c(spca50x, SAA7113_I2C_BASE_READ, 0xa);
+	else	
+	{
+		switch(spca50x->bridge)
+		{
+			case BRIDGE_SPCA500:
+			{
+				/* brightness is stored by the bridge as
+				 * 129 -> 128, with 0 being the midpoint.
+				 * v4l always keeps these values unsigned
+				 * 16 bit, that is 0 to 65535.
+				 * scale accordingly.
+				 */
+				brightness = spca50x_reg_read(spca50x->dev, 0x00, 0x8167, 1);
+				brightness = brightness << 8;
+				break;
+			}
+#ifdef SPCA50X_ENABLE_EXP_BRIGHTNESS
+			case BRIDGE_SPCA505:
+				brightness = spca50x_reg_read(spca50x->dev, 6, 0x51, 2);
+				break;
+#endif /* SPCA50X_ENABLE_EXP_BRIGHTNESS */
+			case BRIDGE_SPCA501:
+			{
+				brightness = spca50x_reg_read(spca50x->dev, 0x0, 0x00, 2) & 0xFF;
+				brightness -= 125;
+				brightness <<= 1;
+				break;
+			}
+			case BRIDGE_SPCA504:
+			{
+				/* The chip keeps the brightness as
+				 * 129 -> 128 with 0 being the midpoint.
+				 * v4l always keeps these values unsigned
+				 * 16 bit, that is 0 to 65535.
+				 * Scale accordingly.
+				 */
+				brightness = spca50x_reg_read(spca50x->dev, 0x0, 0x21a7, 2);
+
+				brightness = (((brightness&&0xFF)-128)%255)<<8;
+				 break;
+			}
+			default:
+			{
+				brightness = 0;
+				break;
+			}
+		}
+	}
+	return brightness;
+}
+
+/**********************************************************************
+* spca50x_set_brightness
+* Function sets the brightness to the camera
+* Receives the pointer to the description structure 
+* and brightness value
+**********************************************************************/
+static inline void spca50x_set_brightness(struct usb_spca50x *spca50x, 
+	__u8 brightness)
+{
+	if(spca50x->ccd)
+		spca50x_write_i2c(spca50x, SAA7113_I2C_BASE_WRITE, 0xa, brightness);
+	else	
+	{
+		switch(spca50x->bridge)
+		{
+			case BRIDGE_SPCA500:
+			{
+				/* 0 - 255 with zero at 128 */
+				spca50x_reg_write(spca50x->dev,
+				                  0x00, 0x8167, brightness);
+				break;
+			}
+#ifdef SPCA50X_ENABLE_EXP_BRIGHTNESS
+			case BRIDGE_SPCA505:
+			{
+				spca50x_reg_write(spca50x->dev, 6, 0x51, brightness);
+				spca50x_reg_write(spca50x->dev, 6, 0x52, brightness);
+				spca50x_reg_write(spca50x->dev, 6, 0x53, brightness);
+				break;
+			}
+#endif /* SPCA50X_ENABLE_EXP_BRIGHTNESS */
+			case BRIDGE_SPCA501:
+			{
+				spca50x_reg_write(spca50x->dev, 0x0, 0x00, 
+					(brightness >> 1) + 125);
+				break;
+			}
+			case BRIDGE_SPCA504:
+			{
+				/* 0 - 255 with zero at 128 */
+				spca50x_reg_write(spca50x->dev, 0x0, 0x21a7,
+				                  brightness); 
+				break;
+			}
+			default:
+			{
+				break;
+			}
+		}
+	}
+}
+
+/**********************************************************************
+* spca50x_get_whiteness
+* Function reads the "whiteness parameter" from the camera
+* Actually "whiteness" is a parameter that close to brighness
+* but currently ununderstanded
+* Receives the pointer to the description structure
+* returns the value of whiteness
+**********************************************************************/
+static inline __u16 spca50x_get_whiteness(struct usb_spca50x *spca50x)
+{
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	__u16 whiteness = 0; //the "whiteness" parameter
+	__u16 br = 0; //the brightness value
+	int i;   // just an index variable
+	__u16 mask; //the bit mask to set bit in p.contrast
+	__u8 br_table[] = { 128, 64, 32, 16, 0 }; //the brightness table
+
+	//this parameter is known for spca501 only
+	if (spca50x->bridge != BRIDGE_SPCA501) 
+		return 0;
+
+	/* Getting "whiteness" (strange parameters in TG 0x0D */
+	br = spca50x_reg_read(spca50x->dev, 0x0, 0x0d, 2);
+	for (i = 0, mask = 1; br_table[i]; i++, mask <<= 1)
+	{
+		if (br & br_table[i])
+			whiteness |= mask;
+	}
+	whiteness <<= 4;
+	return whiteness;
+#else /* SPCA50X_ENABLE_EXPERIMENTAL */
+	return 0;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+}
+
+/**********************************************************************
+* spca50x_set_whiteness
+* Function sets the "whiteness parameter" from the camera
+* Actually "whiteness" is a parameter that close to brighness
+* but currently ununderstanded
+* Receives the pointer to the description structure 
+* and whiteness value
+**********************************************************************/
+static inline void spca50x_set_whiteness(struct usb_spca50x *spca50x, 
+	__u8 whiteness)
+{
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	__u8 br_high = 0; //the contrast value
+	__u8 br_out = 0; // contrast output value
+	int i;   // just an index variable
+	__u16 mask; //the bit mask to set bit in contrast
+	__u8 br_table[] = { 128, 64, 32, 16, 0 }; //the brightness table
+
+
+	//this parameter is known for spca501 only
+	if (spca50x->bridge != BRIDGE_SPCA501) 
+		return;
+
+	PDEBUG(3, "Setting whiteness %d", whiteness);
+	br_high = whiteness >> 4;
+	for (i = 0, mask = 1; br_table[i]; i++, mask <<= 1)
+	{
+		if (br_high & mask)
+			br_out |= br_table[i];
+	}
+	PDEBUG(3, "Writing whiteness %d", br_out);
+	spca50x_reg_write(spca50x->dev, 0x0, 0x0d, br_out);
+#else /* SPCA50X_ENABLE_EXPERIMENTAL */
+	return;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+}
+
+/**********************************************************************
+* autobrightness
+* Function tries to control brightness
+* Receives the pointer to camera descriptor and 
+* target average luminance
+***********************************************************************/
+static inline void autobrightness(struct usb_spca50x *spca50x)
+{
+	__u8 cur_lum = 0; //The current luminance
+	__u8 brightness = 0;
+	char br_set = 0; //If the brightness should be set
+	__u8 lum = spca50x->lum_level; //The desired luminance level
+	__u8 delta = lum >> 3; //overshooting that we shouldn't care
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	__u8 whiteness = 0; //whiteness level
+	char wh_set = 0; //If whiteness must be set
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+
+	if (in_interrupt())
+	{
+		PDEBUG(2, "In intr");
+		return;
+	}
+	////
+	/*
+	* This algorithm may be dangerous. We MUST be sure that the 
+	* !spca50x->streaming will be set to 0 BEFORE kfree(spca50x)
+	*/
+	////
+	if (!spca50x->streaming) //No isoc
+		return;
+	cur_lum = get_avg_lum(spca50x);
+	brightness = spca50x->brightness >> 8;
+	if (cur_lum < (lum - delta))
+	{
+		if (brightness < 255)
+		{
+			brightness++;
+			br_set = 1;
+		}
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+		else 
+		{
+			whiteness = spca50x->whiteness >> 12;
+			if (whiteness < 15)
+			{   
+				whiteness++;
+				wh_set = 1;
+			}
+		}
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+	}
+	if (cur_lum > (lum + delta) && brightness > 0)
+	{
+		brightness--;
+		br_set = 1;
+	}
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	if ((spca50x->nstable == NSTABLE_MAX || 
+		spca50x->nunstable == NUNSTABLE_MAX) && 
+		brightness < MIN_BRIGHTNESS)
+	{
+		whiteness = spca50x->whiteness >> 12;
+		if (whiteness > 0)
+		{   
+			whiteness--;
+			wh_set = 1;
+		}
+	}        
+	if (wh_set)
+	{
+		spca50x_set_whiteness(spca50x, whiteness << 4);
+		spca50x->whiteness = whiteness << 12;
+		spca50x->nstable = 0;
+		spca50x->nunstable = 0;
+		return; //if we have set whiteness, we needn't care about brightness
+	}
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+	if (br_set)
+	{
+		spca50x_set_brightness(spca50x, brightness);
+		spca50x->brightness = brightness << 8;
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+		if (spca50x->nunstable < NUNSTABLE_MAX)
+			spca50x->nunstable++;
+		spca50x->nstable = 0;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+	}
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	else
+	{
+		if (spca50x->nstable < NSTABLE_MAX)
+			spca50x->nstable++;
+		else
+			spca50x->nunstable = 0;
+	}
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+}
+
+static void auto_bh(void* data)
+{
+	struct usb_spca50x *spca50x = (struct usb_spca50x*)data;
+	
+	autobrightness(spca50x);
+	spca50x->bh_requested = 0; /* bottom half process finished */
+}
+
+/**********************************************************************
+ *
+ * Color correction functions
+ *
+ **********************************************************************/
+
+/*
+ * Turn a YUV4:2:0 block into an RGB block
+ * Blatently stolen from the ov511 driver - JAC
+ *
+ * Video4Linux seems to use the blue, green, red channel
+ * order convention-- rgb[0] is blue, rgb[1] is green, rgb[2] is red.
+ *
+ * Color space conversion coefficients taken from the excellent
+ * http://www.inforamp.net/~poynton/ColorFAQ.html
+ * In his terminology, this is a CCIR 601.1 YCbCr -> RGB.
+ * Y values are given for all 4 pixels, but the U (Pb)
+ * and V (Pr) are assumed constant over the 2x2 block.
+ *
+ * To avoid floating point arithmetic, the color conversion
+ * coefficients are scaled into 16.16 fixed-point integers.
+ * They were determined as follows:
+ *
+ *	double brightness = 1.0;  (0->black; 1->full scale)
+ *	double saturation = 1.0;  (0->greyscale; 1->full color)
+ *	double fixScale = brightness * 256 * 256;
+ *	int rvScale = (int)(1.402 * saturation * fixScale);
+ *	int guScale = (int)(-0.344136 * saturation * fixScale);
+ *	int gvScale = (int)(-0.714136 * saturation * fixScale);
+ *	int buScale = (int)(1.772 * saturation * fixScale);
+ *	int yScale = (int)(fixScale);
+ */
+
+/* LIMIT: convert a 16.16 fixed-point value to a byte, with clipping. */
+#define LIMIT(x) ((x)>0xffffff ? 0xff: ((x)<=0xffff ? 0: ((x)>>16)))
+
+static inline void
+spca50x_move_420_block(int yTL, int yTR, int yBL, int yBR, int u, int v,
+	int rowPixels, unsigned char * rgb, int bits, __u8 isforce_rgb)
+{
+	const int rvScale = 91881;
+	const int guScale = -22553; 
+	const int gvScale = -46801;
+	const int buScale = 116129;
+	const int yScale  = 65536;
+	int r, g, b;
+
+	g = guScale * u + gvScale * v;
+	if (isforce_rgb) 
+	{
+		r = buScale * u;
+		b = rvScale * v;
+	} 
+	else 
+	{
+		r = rvScale * v;
+		b = buScale * u;
+	}
+
+	yTL *= yScale; yTR *= yScale;
+	yBL *= yScale; yBR *= yScale;
+
+	if (bits == 24) 
+	{
+		/* Write out top two pixels */
+		rgb[0] = LIMIT(b + yTL); rgb[1] = LIMIT(g + yTL); rgb[2] = LIMIT(r + yTL);
+		rgb[3] = LIMIT(b + yTR); rgb[4] = LIMIT(g + yTR); rgb[5] = LIMIT(r + yTR);
+
+		/* Skip down to next line to write out bottom two pixels */
+		rgb += 3 * rowPixels;
+		rgb[0] = LIMIT(b + yBL); rgb[1] = LIMIT(g + yBL); rgb[2] = LIMIT(r + yBL);
+		rgb[3] = LIMIT(b + yBR); rgb[4] = LIMIT(g + yBR); rgb[5] = LIMIT(r + yBR);
+	} 
+	else if (bits == 16) 
+	{
+		/* Write out top two pixels */
+		rgb[0] = ((LIMIT(b + yTL) >> 3) & 0x1F) | ((LIMIT(g + yTL) << 3) & 0xE0);
+		rgb[1] = ((LIMIT(g + yTL) >> 5) & 0x07) | (LIMIT(r + yTL) & 0xF8);
+
+		rgb[2] = ((LIMIT(b + yTR) >> 3) & 0x1F) | ((LIMIT(g + yTR) << 3) & 0xE0);
+		rgb[3] = ((LIMIT(g + yTR) >> 5) & 0x07) | (LIMIT(r + yTR) & 0xF8);
+
+		/* Skip down to next line to write out bottom two pixels */
+		rgb += 2 * rowPixels;
+
+		rgb[0] = ((LIMIT(b + yBL) >> 3) & 0x1F) | ((LIMIT(g + yBL) << 3) & 0xE0);
+		rgb[1] = ((LIMIT(g + yBL) >> 5) & 0x07) | (LIMIT(r + yBL) & 0xF8);
+
+		rgb[2] = ((LIMIT(b + yBR) >> 3) & 0x1F) | ((LIMIT(g + yBR) << 3) & 0xE0);
+		rgb[3] = ((LIMIT(g + yBR) >> 5) & 0x07) | (LIMIT(r + yBR) & 0xF8);
+	}
+}
+
+/**********************************************************************
+ *
+ * SPCA50X data transfer, IRQ handler
+ *
+ **********************************************************************/
+
+#ifdef SPCA50X_ENABLE_OSD
+
+static void spca50x_osd_text(struct spca50x_frame *frame,int x,int y,char *text)
+{
+	int I;
+	int J;
+	int K;
+	int limit;
+	limit=strlen(text);
+
+	for(I=0;I<limit;I++)
+	{
+		/* Offest into font table for first byte of character data */
+		int charBase=8*text[I];
+		/* Frame pointer */
+		char *fp=frame->data+I*3*8+y*8*frame->width*3+x*3;
+		/* pointer to character data */
+		char *font_char=((char *)(osd_font->data))+charBase;
+		for(J=0;J<8;J++)
+		{
+			int line=font_char[J];
+			for(K=0;K<8;K++)
+			{
+				int level=(line & 0x80)?255:0;
+				*(fp+3*K)=level; // R
+				*(fp+3*K+1)=level; // G
+				*(fp+3*K+2)=level; // B
+				line<<=1;
+			}
+			fp+=frame->width*3; // skip a line of RGB
+		}
+	}
+}
+
+/* On screen display */
+static int spca50x_osd_render(struct spca50x_frame *frame,struct timeval *ts)
+{
+	char seq[40];
+	int frameSeq;
+
+	if(!osd_font)
+	{
+		osd_font=fbcon_find_font("VGA8x8");
+	}
+
+	/* No font available */
+	if(!osd_font || osd_font->data==NULL) return -EBFONT;
+
+	frameSeq=frame->seq;
+	if(frameSeq<0) frameSeq+=256;
+	sprintf(seq,"Frame: %3.3d ",frameSeq);
+
+	spca50x_osd_text(frame,0,0,seq);
+
+	sprintf(seq,"%dx%d",frame->width,frame->height);
+
+	spca50x_osd_text(frame,0,1,seq);
+
+	return 0;
+}
+
+#endif /* SPCA50X_ENABLE_OSD */
+
+static struct spca50x_frame *spca50x_next_frame(struct usb_spca50x *spca50x,unsigned char *cdata)
+{
+	int iFrameNext;
+	struct spca50x_frame *frame=NULL;
+
+	/* Cycle through the frame buffer looking for a free frame to overwrite */
+	iFrameNext = (spca50x->curframe + 1) % SPCA50X_NUMFRAMES;
+	while(frame==NULL && iFrameNext!=(spca50x->curframe))
+	{
+		if (spca50x->frame[iFrameNext].grabstate == FRAME_READY  ||
+		    spca50x->frame[iFrameNext].grabstate == FRAME_UNUSED ||
+		    spca50x->frame[iFrameNext].grabstate == FRAME_ERROR)
+		{
+			spca50x->curframe = iFrameNext;
+			frame=&spca50x->frame[iFrameNext];
+			break;
+		}
+		else
+		{
+			iFrameNext=(iFrameNext+1)%SPCA50X_NUMFRAMES;
+		}
+	}
+
+	if(frame==NULL)
+	{
+		PDEBUG(3,"Can't find a free frame to grab into...using next. "
+		         "This is caused by the application not reading fast enough.");
+		spca50x->curframe=(spca50x->curframe+1)%SPCA50X_NUMFRAMES;
+		frame=&spca50x->frame[spca50x->curframe];
+	}
+
+	frame->grabstate=FRAME_GRABBING;
+
+	/* Record the frame sequence number the camera has told us */
+	if(cdata)
+	{
+		switch(spca50x->bridge)
+		{
+			case BRIDGE_SPCA500: frame->seq=cdata[SPCA500_OFFSET_FRAMSEQ]; break;
+			case BRIDGE_SPCA501: frame->seq=cdata[SPCA501_OFFSET_FRAMSEQ]; break;
+			case BRIDGE_SPCA504: frame->seq=cdata[SPCA50X_OFFSET_FRAMSEQ]; break;
+			case BRIDGE_SPCA505: frame->seq=cdata[SPCA50X_OFFSET_FRAMSEQ]; break;
+			case BRIDGE_SPCA508: frame->seq=cdata[SPCA508_OFFSET_FRAMSEQ]; break;
+		}
+	}
+
+	/* Reset some per-frame variables */
+	frame->highwater=frame->data;
+	frame->scanstate = STATE_LINES;
+	frame->segment = 0;
+	frame->curpix=0;
+	frame->curline=0;
+	frame->last_packet=-1;
+	frame->mcu = 0;
+
+	return frame;
+}
+
+/* ******************************************************************
+* spca50x_move_data
+* Function serves for moving data from USB transfer buffers
+* to internal driver frame buffers.
+******************************************************************* */
+static int spca50x_move_data(struct usb_spca50x *spca50x, struct urb *urb)
+{
+	unsigned char *cdata;  //Pointer to buffer where we do store next packet
+	unsigned char *pData;  //Pointer to buffer where we do store next packet
+	int i, totlen = 0;
+	struct spca50x_frame *frame; //Pointer to frame data
+	int datacount;
+	int copycount;
+	int err;
+	int iPix; //Offset of pixel data in the ISO packet
+	int pixel_shift = 0; //shift of the YUV->RGB translation after 2x2 block
+	int row_shift = 0; //shift of the row in YUV->RGB translation
+
+	// PDEBUG (4, "Moving %d packets", urb->number_of_packets);
+
+	// Lock the buffers to ensure that they don't vanish while we are 
+	// writing to them !
+	down(&spca50x->buf_lock);
+
+	// Verify the buffers still exist
+	if(!spca50x->fbuf)
+	{
+		up(&spca50x->buf_lock);
+		return -ENOBUFS;
+	}
+
+	for (i = 0; i < urb->number_of_packets; i++)
+	{
+		int datalength = urb->iso_frame_desc[i].actual_length;
+		int st = urb->iso_frame_desc[i].status;
+		int sequenceNumber;
+
+		/* PDEBUG(5,"Packet data [%d,%d,%d]", datalength, st,
+		         urb->iso_frame_desc[i].offset); */
+
+		urb->iso_frame_desc[i].actual_length = 0;
+		urb->iso_frame_desc[i].status = 0;
+
+		cdata = ((unsigned char *) urb->transfer_buffer) +
+		        urb->iso_frame_desc[i].offset;
+
+		/* Check for zero length block or no selected frame buffer */
+		if (!datalength || spca50x->curframe == -1) 
+			continue;
+
+		PDEBUG(5,"Packet data [%d,%d,%d] Status: %d", datalength, st,
+		         urb->iso_frame_desc[i].offset, st);
+
+		if (st) 
+			PDEBUG(2, "data error: [%d] len=%d, status=%d", i, datalength, st);
+
+		frame = &spca50x->frame[spca50x->curframe];
+
+#ifdef SPCA50X_ENABLE_RAWPROCENTRY
+		if (spca50x->rawBuffer != NULL)
+		{
+			/* check that there's enough space in the buffer */
+			if ((spca50x->rawBufferMax - spca50x->rawBufferSize) < (datalength + 5))
+			{
+				PDEBUG(3, "raw proc entry buffer is full");
+			}
+			else
+			{
+				strncpy(spca50x->rawBuffer + spca50x->rawBufferSize, "FRAME", 5);
+				memcpy(spca50x->rawBuffer + spca50x->rawBufferSize + 5,
+				       cdata,
+				       datalength);
+				spca50x->rawBufferSize += datalength + 5;
+			}
+		}
+#endif /* SPCA50X_ENABLE_RAWPROCENTRY */
+
+		/* read the sequence number */
+		sequenceNumber = cdata[SPCA50X_OFFSET_SEQUENCE];
+
+		/* check if this is a SPCA500 based device */
+		if (spca50x->bridge == BRIDGE_SPCA500)
+		{
+			if (sequenceNumber == SPCA50X_SEQUENCE_DROP)
+			{
+				if (cdata[1] == 0x01)
+				{
+					sequenceNumber = 0;
+				}
+				else
+				{
+					/* drop packet */
+					PDEBUG(5, "Dropped packet (expected seq 0x%02x)",
+					          frame->last_packet + 1);
+					continue;
+				}
+			}
+			else
+			{
+				sequenceNumber ++;
+			}
+		}
+		else if (spca50x->bridge == BRIDGE_SPCA504)
+		{
+					switch (sequenceNumber)
+			{
+				case 0xfe:
+					sequenceNumber = 0;
+					break;
+				case SPCA50X_SEQUENCE_DROP:
+					/* drop packet */
+					PDEBUG(5, "Dropped packet (expected seq 0x%02x)",
+					          frame->last_packet + 1);
+					continue;
+				default:
+					sequenceNumber ++;
+					break;
+			}
+		}
+		else
+		{
+			/* check if this is a drop packet */
+			if (sequenceNumber == SPCA50X_SEQUENCE_DROP)
+			{
+				PDEBUG(3, "Dropped packet (expected seq 0x%02x)",
+					  frame->last_packet + 1);
+				continue;
+			}
+		}
+
+		PDEBUG(3, "spca50x: Packet seqnum = 0x%02x.  curframe=%2d",
+		          sequenceNumber, spca50x->curframe);
+
+		pData = cdata;
+		// Offset of pixel data in iso packet, after sequence byte at offset 0
+		iPix = 1; 
+
+		/* Can we find a frame start */
+		if (sequenceNumber == 0)
+		{
+			iPix = spca50x->header_len;
+			PDEBUG(3, "spca50x: Found Frame Start!, framenum = %d", spca50x->curframe);
+			switch(spca50x->bridge)
+			{
+				case BRIDGE_SPCA500:
+				{
+					PDEBUG(3, "Padding = 0x%02x%02x",
+					          cdata[SPCA500_OFFSET_PADDINGHB],
+					          cdata[SPCA500_OFFSET_PADDINGLB]);
+					PDEBUG(3, "Camera operation mode = %u", cdata[SPCA500_OFFSET_MODE]);
+					PDEBUG(3, "Image width = %u, height = %u",
+					          cdata[SPCA500_OFFSET_IMGWIDTH],
+					          cdata[SPCA500_OFFSET_IMGHEIGHT]);
+					PDEBUG(3, "Image mode = %u", cdata[SPCA500_OFFSET_IMGMODE]);
+					PDEBUG(3, "Q-table index = %u", cdata[SPCA500_OFFSET_QTBLINDEX]);
+					PDEBUG(3, "Frame sequence = %d", cdata[SPCA500_OFFSET_FRAMSEQ]);
+					PDEBUG(3, "CDSP information = %d", cdata[SPCA500_OFFSET_CDSPINFO]);
+					PDEBUG(3, "GPIO = %d", cdata[SPCA500_OFFSET_GPIO]);
+					PDEBUG(3, "AUGPIO = %d", cdata[SPCA500_OFFSET_AUGPIO]);
+					break;
+				}
+				case BRIDGE_SPCA501:
+				{
+					PDEBUG(3, "GPIO: 0x%02X", cdata[SPCA501_OFFSET_GPIO]);
+					PDEBUG(3, "Image type: %d with snapbit %d and snap control %d",
+						(cdata[SPCA501_OFFSET_TYPE] & 0xF),
+						(cdata[SPCA501_OFFSET_TYPE] & SPCA501_SNAPBIT), 
+						(cdata[SPCA501_OFFSET_TYPE] & SPCA501_SNAPCTRL));
+					PDEBUG(3,"Frame sequence %d",cdata[SPCA501_OFFSET_FRAMSEQ]);
+					PDEBUG(3,"Compression status = %d, Threshold = %d, Quant = %d",
+						SPCA501_PROP_COMP_ENABLE(cdata[SPCA501_OFFSET_COMPRESS]), 
+						SPCA501_PROP_COMP_THRESH(cdata[SPCA501_OFFSET_COMPRESS]),
+						SPCA501_PROP_COMP_QUANT(cdata[SPCA501_OFFSET_COMPRESS]) );
+					break;
+				}
+				case BRIDGE_SPCA505:
+				case BRIDGE_SPCA506:
+				{
+					PDEBUG(3, "Image type: %d with snapbit %d and snap control %d",
+						(cdata[SPCA50X_OFFSET_TYPE] & 0xF),
+						(cdata[SPCA50X_OFFSET_TYPE] & SPCA50X_SNAPBIT), 
+						(cdata[SPCA50X_OFFSET_TYPE] & SPCA50X_SNAPCTRL));
+					PDEBUG(3,"Frame sequence %d",cdata[SPCA50X_OFFSET_FRAMSEQ]);
+					PDEBUG(3,"Compression status = %d, ThreeBandNormalizarion = %d, Threshold 3D = %d",
+						SPCA50X_PROP_COMP_ENABLE(cdata[SPCA50X_OFFSET_COMPRESS]), 
+						SPCA50X_PROP_COMP_T3A(cdata[SPCA50X_OFFSET_COMPRESS]), 
+						SPCA50X_PROP_COMP_T3D(cdata[SPCA50X_OFFSET_COMPRESS]) );
+					break;
+				}
+				case BRIDGE_SPCA508:
+				{
+					PDEBUG(3, "Image type: %d with snapbit %d and snap control %d",(cdata[SPCA508_OFFSET_TYPE] & 0xF),
+						(cdata[SPCA508_OFFSET_TYPE] & 0x20),
+						((cdata[SPCA508_OFFSET_TYPE] & 0x40) != 0));
+					PDEBUG(3,"Frame sequence %d", cdata[SPCA508_OFFSET_FRAMSEQ]);
+					PDEBUG(3,"Compression status = %d",
+						cdata[SPCA508_OFFSET_COMPRESS] & 0x02);
+					PDEBUG(3,"Average luminance = %3d\n", cdata[SPCA508_OFFSET_WIN1LUM]);
+					break;
+				}
+			}
+			// Start of frame is implicit end of previous frame
+			// Check for a previous frame and finish it off if one exists
+			if(frame->scanstate == STATE_LINES)
+			{
+#ifdef SPCA50X_ENABLE_OSD
+			 struct timeval* ts;
+				PDEBUG(4, "Frame end, curframe = %d, has %d bytes",
+					spca50x->curframe,(frame->highwater - frame->data));
+				ts = (struct timeval*)(frame->data + MAX_FRAME_SIZE);
+				do_gettimeofday(ts);
+				if(osd) 
+					spca50x_osd_render(frame, ts);
+#endif /* SPCA50X_ENABLE_OSD */
+
+				/* Compressed raw jpeg data is already present in frame->data.
+				   So for VIDEO_PALETTE_RAW_JPEG we have nothing to do.
+				 */
+				if ( (spca50x->bridge == BRIDGE_SPCA500 ||
+				      spca50x->bridge == BRIDGE_SPCA504) &&
+				     dumppix!=7 && 
+				     ((frame->format == VIDEO_PALETTE_RGB32) ||
+				      (frame->format == VIDEO_PALETTE_RGB24) ))
+				{
+					memcpy(spca50x->tmpBuffer, frame->data, 
+					       frame->highwater - frame->data);
+
+					err = jpeg_decode(frame->data, spca50x->tmpBuffer, 
+					                  frame->width, frame->height, 
+					                  frame->format,
+					                  force_rgb);
+					if (err != 0)
+					{
+						PDEBUG(2, "jpeg decoder failed (%d)", err);
+					}
+				}
+
+				frame->grabstate = FRAME_DONE;
+				if (waitqueue_active(&frame->wq)) 
+					wake_up_interruptible(&frame->wq);
+				/* If someone decided to wait for ANY frame - wake him up */
+				if (waitqueue_active(&spca50x->wq))
+					wake_up_interruptible(&spca50x->wq);
+
+				frame = spca50x_next_frame(spca50x, cdata);
+			}
+			else 
+				frame->scanstate=STATE_LINES;
+		}
+
+		/* Are we in a frame? */
+		if (frame == NULL || frame->scanstate != STATE_LINES) 
+			continue;
+
+		PDEBUG(5,"Pkt sequence number %d", sequenceNumber);
+		if(sequenceNumber != frame->last_packet + 1 && 
+		   frame->last_packet != -1)
+		{
+			/* Note, may get one of these for the first packet after opening */
+			PDEBUG(2,"Out of order packet, last = %d, this = %d",
+			         frame->last_packet, sequenceNumber);
+		}
+		frame->last_packet = sequenceNumber;
+
+		if (dumppix == 4)
+		{
+			// Raw data from camera - JAC (this also includes sequence numbers and other codes)
+			// The external file raw.c decodes this data if grabbed as a pnm with vgrabber
+			if((frame->highwater - frame->data + datalength) < MAX_FRAME_SIZE)
+			{
+				memcpy(frame->highwater, cdata, datalength);
+				frame->highwater += datalength;
+				totlen += datalength;
+			}
+			continue;
+		}
+
+		if (dumppix == 5)
+		{
+			// Y channel from packets. Assuming compression off, the data
+			// seems to be a row of Y data equal to the image width,
+			// then a second row of Y data equal to the image width,
+			// then a row of U/V data also equal to the image width,
+			// each U/V line being half width U then half width V
+			// OK, so this is not true for the create and share, which seems
+			// to use a row of Y, a half row of U, a row of Y and a half row of V
+			// TBD: This doesn't work right for the SPCA508A/VQ110.
+			// For this camera, format is row of Y, row of U/V, second row of Y.
+			// That case isn't handled right here.
+			datalength -= iPix;   // correct length for packet header
+			pData = cdata + iPix; // Skip packet header (1 or 10 bytes)
+			// Consume data
+			PDEBUG(5, "Processing packet starting at %d, %d, %d",
+				frame->curpix,frame->segment, frame->width);
+			while (datalength > 0)
+			{
+			 int pixels = 0;
+				// datacount is bytes remaining in this segment
+				datacount=frame->width * 3 - frame->curpix;
+				copycount=datacount;
+				
+				// Don't copy more bytes than exist in the packet
+				if(copycount > datalength) 
+					copycount = datalength;
+				
+				// frame->curline is number of bytes aleady copied in 
+				// the current Y channel
+				if(frame->curline < frame->width * 2) // Do first 2 of three stripes
+				{
+				 int J;
+					
+					// Pixels is remaining count to copy of the Y channel
+					pixels=frame->width*2-frame->curline;
+					// Don't copy more data than is available
+					if (pixels > copycount) 
+						pixels = copycount;
+					for(J = 0; J < pixels; J++)
+					{
+						// triple so we have RGB like grayscale data
+						*(frame->highwater++) = (*pData);
+						*(frame->highwater++) = (*pData);
+						*(frame->highwater++) = (*pData);
+						pData++;
+					}
+				}
+				pData += copycount - pixels;
+				// Update number of pixels copied
+				frame->curline += pixels;
+				// Update total bytes consumed
+				frame->curpix += copycount;
+				datalength -= copycount;
+				PDEBUG(5, "Copied %d bytes for packet %d leaving %d",
+					copycount, frame->last_packet, datalength);
+				if(frame->curpix>=frame->width*3)
+				{
+					// End of segment
+					frame->segment++;
+					frame->curpix = 0;
+					if(frame->curline != frame->width * 2)
+						PDEBUG(2,"Incomplete line %d in packet %d",
+							frame->curline, frame->last_packet);
+				
+					frame->curline = 0;
+					if (frame->segment >= 60) 
+						break;
+				}
+				totlen+=copycount;
+			}
+			continue;
+		}
+
+		/* This is the real conversion of the raw camera data to BGR for V4L */
+		datalength -= iPix; // correct length for packet header
+		pData = cdata + iPix; // Skip packet header (1 or 10 bytes)
+		// Calculate shifts
+		switch (frame->depth)
+		{
+			case 16:
+			{
+				pixel_shift = 4; // 2 * 2;
+				row_shift = frame->width * 2;
+				break;
+			}
+			case 24:
+			{
+				pixel_shift = 6; // 2 * 3;
+				row_shift = frame->width * 3;
+				break;
+			}
+		}
+		
+		// Consume data
+		PDEBUG(5, "Processing packet starting at %d, %d, %d",
+		          frame->curpix, frame->segment, frame->width);
+
+		/* Move raw data to the output buffer */
+		if (spca50x->bridge == BRIDGE_SPCA500 ||
+		    spca50x->bridge == BRIDGE_SPCA504)
+		{
+			memcpy(frame->highwater, pData, datalength);
+			frame->highwater += datalength;
+			totlen += datalength;
+			continue;
+		}
+
+		while(datalength > 0)
+		{
+			// datacount is bytes remaining in this segment
+			datacount = frame->width * 3 - frame->curpix;
+			copycount = datacount;
+			
+			// Don't copy more bytes than exist in the packet
+			if (copycount > datalength) 
+				copycount = datalength;
+			
+			if(frame->curpix + copycount > SCRATCH_BUF_SIZE || frame->curpix < 0)
+			{
+				PDEBUG(1,"Won't overwrite memory!");
+				continue;
+			}
+
+			memcpy(spca50x->scratch + frame->curpix, pData, copycount);
+			pData += copycount;
+			frame->curpix += copycount;
+			datalength -= copycount;
+			if (frame->curpix >= 3 * frame->width)
+			{
+			 int I;
+			 char* scratch = spca50x->scratch;
+				// Have read a complete segment into scratch buffer */
+				frame->segment++;
+				frame->curpix = 0;
+				
+				// Now decode the segment into 2 lines of BGR data
+				if (frame->highwater + 2 * frame->width-frame->data > MAX_FRAME_SIZE 
+					|| frame->highwater<frame->data)
+				{
+					PDEBUG(1,"Won't overwrite frame memory!");
+					continue;
+				}
+				if (dumppix == 6)
+				{
+				 int J;
+					// Copy just luminance to frame as gray RGB for debug
+					switch(spca50x->bridge)
+					{
+						case BRIDGE_SPCA505:
+						case BRIDGE_SPCA506:
+						{
+							// Decode 2 lines of luminesece data followed by a half line of 
+							// U and a half line of V
+							for(J = 0; J < frame->width * 2; J++)
+							{
+								// triple so we have RGB like grayscale data
+								*(frame->highwater++) = scratch[J];
+								*(frame->highwater++) = scratch[J];
+								*(frame->highwater++) = scratch[J];
+							}
+							break;
+						}
+						case BRIDGE_SPCA501:
+						{
+							// For create and share, decode one line Y, one half line U, 
+							// one line Y and one half line V
+							/*
+							 Idea taken by Igor Knizhny
+							 Y may be stored (and IS stored in this case) in "balanced"
+							 form (-128 - 127). So 128 must be added to get right Y
+							 */
+							for(J = 0; J < frame->width; J++)
+							{
+								// triple so we have RGB like grayscale data
+								scratch[J] += 128;
+								*(frame->highwater++) = scratch[J];
+								*(frame->highwater++) = scratch[J];
+								*(frame->highwater++) = scratch[J];
+							}
+							J += frame->width / 2;
+							for(; J < frame->width * 2 + frame->width / 2; J++)
+							{
+								scratch[J] += 128;
+								*(frame->highwater++) = scratch[J];
+								*(frame->highwater++) = scratch[J];
+								*(frame->highwater++) = scratch[J];
+							}
+							break;
+						}
+						case BRIDGE_SPCA508:
+						{
+							// Or, for SPCA508 ViewQuest VQ110, decode one line Y, one half line U, 
+							// one half line V, and one line Y
+							int line;
+							for (line = 0; line <= 1; line++) {
+								for(J = 0; J < frame->width; J++)
+									{
+										// triple so we have RGB like grayscale data
+										*(frame->highwater++) = scratch[J + line * frame->width * 2] + 128;
+										*(frame->highwater++) = scratch[J + line * frame->width * 2] + 128;
+										*(frame->highwater++) = scratch[J + line * frame->width * 2] + 128;
+									}
+							}
+							break;
+						}
+					}
+				}
+				else
+				{
+					switch(spca50x->bridge)
+					{
+						case BRIDGE_SPCA505:
+						case BRIDGE_SPCA506:
+						{
+							int UVoffset = 2 * frame->width;
+							for(I = 0; I < frame->width; I += 2)
+							{
+#ifdef SPCA50X_ENABLE_EXP_505_BRIGHTNESS
+								spca50x_move_420_block(scratch[I] + 128,
+								                       scratch[I + 1] + 128,
+								                       scratch[frame->width + I] + 128,
+								                       scratch[frame->width + I + 1] + 128,
+#else /* SPCA50X_ENABLE_EXP_505_BRIGHTNESS */
+								spca50x_move_420_block(scratch[I],
+								                       scratch[I + 1],
+								                       scratch[frame->width + I],
+								                       scratch[frame->width + I + 1],
+#endif /* SPCA50X_ENABLE_EXP_505_BRIGHTNESS */
+								                       scratch[UVoffset + (I >> 1)], 
+								                       scratch[UVoffset + (frame->width >> 1) + (I >> 1)],
+								                       frame->width, frame->highwater, 24, 
+								                       spca50x->force_rgb);
+
+								/* Bump the pointer for the two BGR pixels on this row */
+								frame->highwater += pixel_shift;
+							}
+							// Bump the pointer for the entire second row of BGR pixels
+							frame->highwater += row_shift;
+							break;
+						}
+						case BRIDGE_SPCA501:
+						{
+						 int Uoffset = frame->width;
+						 int Voffset = (frame->width << 1) + (frame->width >> 1); // 2.5
+						 int Ynoffset = frame->width + (frame->width >> 1); // 1.5
+						 int J; 
+							/*
+							 Idea by Igor Knizhny and Petr Nejedly
+							 Y may be stored (and IS stored in this case) in "balanced"
+							 form (-128 - 127). So 128 must be added to get right Y
+							 */
+							/*
+							 I prefer to do one increment rather that two shifts
+							 */ 
+							for(I = 0, J = 0; I < frame->width; I += 2, J++)
+							{
+								spca50x_move_420_block(scratch[I] + 128, scratch[I + 1] + 128,
+									scratch[Ynoffset + I] + 128, scratch[Ynoffset + I + 1] + 128,
+									scratch[Uoffset + J],
+									scratch[Voffset + J],
+									frame->width, frame->highwater, frame->depth,
+									spca50x->force_rgb);
+								// Bump the pointer for the two BGR pixels on this row
+								frame->highwater += pixel_shift;
+							}
+							// Bump the pointer for the entire second row of BGR pixels
+							frame->highwater += row_shift;
+							break;
+						}
+						case BRIDGE_SPCA508:
+						{
+						 int UVoffset = 1 * frame->width;
+							for(I = 0; I < frame->width; I += 2)
+							{
+								spca50x_move_420_block(scratch[I] + 128, scratch[I + 1] + 128,
+									scratch[frame->width*2 + I] + 128, scratch[frame->width*2 + I + 1] + 128,
+									scratch[UVoffset + (I >> 1)], 
+									scratch[UVoffset + (frame->width >> 1) + (I >> 1)],
+									frame->width, frame->highwater, 24, 
+									spca50x->force_rgb);
+								// Bump the pointer for the two BGR pixels on this row
+								frame->highwater += pixel_shift;
+							}
+							// Bump the pointer for the entire second row of BGR pixels
+							frame->highwater += row_shift;
+							break;
+						}
+					}
+				}
+				if(frame->segment >= frame->height / 2) 
+					break;
+			}
+			continue;
+		}
+	}
+	up(&spca50x->buf_lock);
+	return totlen;
+}
+
+/****************************************************************************
+ *
+ * Buffer management
+ *
+ ***************************************************************************/
+static int spca50x_alloc(struct usb_spca50x *spca50x)
+{
+	int i;
+
+	PDEBUG(4, "entered");
+
+	/* FIXME: temporary buffer used for jpeg decoding. Much too big,
+	 *        obviously, but hey. Since this buffer is never mmaped,
+	 *        there is no need to use rvmalloc and reserve it, I think.
+	 *        till
+	 *        Also, I'm not sure that this should precede down()?
+	 *        NWG: Wed 22nd January 2003.
+	 */
+	spca50x->tmpBuffer = vmalloc(MAX_FRAME_SIZE);
+
+	down(&spca50x->buf_lock);
+
+	if (spca50x->buf_state == BUF_PEND_DEALLOC) {
+		spca50x->buf_state = BUF_ALLOCATED;
+		del_timer(&spca50x->buf_timer);
+	}
+
+	if (spca50x->buf_state == BUF_ALLOCATED)
+		goto out;
+
+	spca50x->fbuf = rvmalloc(SPCA50X_NUMFRAMES * MAX_DATA_SIZE);
+	if (!spca50x->fbuf)
+		goto error;
+
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++) {
+		spca50x->frame[i].grabstate = FRAME_UNUSED;
+		spca50x->frame[i].scanstate = STATE_SCANNING;
+		spca50x->frame[i].data = spca50x->fbuf + i * MAX_DATA_SIZE;
+		spca50x->frame[i].highwater=spca50x->frame[i].data;
+		PDEBUG(4, "frame[%d] @ %p", i, spca50x->frame[i].data);
+	}
+	
+	for (i = 0; i < SPCA50X_NUMSBUF; i++) {
+		spca50x->sbuf[i].data = kmalloc(FRAMES_PER_DESC *
+			MAX_FRAME_SIZE_PER_DESC, GFP_KERNEL);
+		if (!spca50x->sbuf[i].data)
+			goto error; 
+		PDEBUG(4, "sbuf[%d] @ %p", i, spca50x->sbuf[i].data);
+	}
+	spca50x->buf_state = BUF_ALLOCATED;
+out:
+	up(&spca50x->buf_lock);
+	PDEBUG(4, "leaving");
+	return 0;
+error:
+	/* FIXME: IMHO, it's better to move error deallocation code here. */
+	for (i = 0; i < SPCA50X_NUMSBUF; i++) {
+
+		if (spca50x->sbuf[i].data) {
+			kfree(spca50x->sbuf[i].data);
+			spca50x->sbuf[i].data = NULL;
+		}
+	}
+	if (spca50x->fbuf)
+	{
+		rvfree(spca50x->fbuf, SPCA50X_NUMFRAMES * MAX_DATA_SIZE);
+		spca50x->fbuf = NULL;
+	}
+	if (spca50x->tmpBuffer)
+	{
+		vfree(spca50x->tmpBuffer);
+		spca50x->tmpBuffer = NULL;
+	}
+
+	spca50x->buf_state = BUF_NOT_ALLOCATED;
+	up(&spca50x->buf_lock);
+	PDEBUG(1, "errored");
+	return -ENOMEM;
+}
+
+/*
+ * - You must acquire buf_lock before entering this function.
+ * - Because this code will free any non-null pointer, you must be sure to null
+ *   them if you explicitly free them somewhere else!
+ */
+static void spca50x_do_dealloc(struct usb_spca50x *spca50x)
+{
+	int i;
+	PDEBUG(2, "entered");
+
+	if (spca50x->fbuf) {
+		rvfree(spca50x->fbuf, SPCA50X_NUMFRAMES * MAX_DATA_SIZE);
+		spca50x->fbuf = NULL;
+		for(i = 0; i < SPCA50X_NUMFRAMES; i++)
+			spca50x->frame[i].data = NULL;
+	}
+
+	if (spca50x->tmpBuffer)
+	{
+		vfree(spca50x->tmpBuffer);
+		spca50x->tmpBuffer = NULL;
+	}
+
+	for (i = 0; i < SPCA50X_NUMSBUF; i++) {
+		if (spca50x->sbuf[i].data) {
+			kfree(spca50x->sbuf[i].data);
+			spca50x->sbuf[i].data = NULL;
+		}
+	}
+
+	PDEBUG(2, "buffer memory deallocated");
+	spca50x->buf_state = BUF_NOT_ALLOCATED;
+	PDEBUG(2, "leaving");
+}
+
+static void spca50x_buf_callback(unsigned long data)
+{
+	struct usb_spca50x *spca50x = (struct usb_spca50x *)data;
+	PDEBUG(4, "entered");
+	down(&spca50x->buf_lock);
+
+	if (spca50x->buf_state == BUF_PEND_DEALLOC)
+		spca50x_do_dealloc(spca50x);
+
+	up(&spca50x->buf_lock);
+	PDEBUG(4, "leaving");
+}
+
+static void spca50x_dealloc(struct usb_spca50x *spca50x, int now)
+{
+	struct timer_list *bt = &(spca50x->buf_timer);
+	PDEBUG(2, "entered");
+	down(&spca50x->buf_lock);
+
+	PDEBUG(2, "deallocating buffer memory %s", now ? "now" : "later");
+
+	if (spca50x->buf_state == BUF_PEND_DEALLOC) {
+		spca50x->buf_state = BUF_ALLOCATED;
+		del_timer(bt);
+	}
+
+	if (now)
+		spca50x_do_dealloc(spca50x);
+	else {
+		spca50x->buf_state = BUF_PEND_DEALLOC;
+		init_timer(bt);
+		bt->function = spca50x_buf_callback;
+		bt->data = (unsigned long)spca50x;
+		bt->expires = jiffies + buf_timeout * HZ;
+		add_timer(bt);
+	}
+	up(&spca50x->buf_lock);
+	PDEBUG(2, "leaving");
+}
+
+/**
+ * Reset the camera and send the correct initialization sequence for the
+ * currently selected source
+ */
+static int spca50x_init_source(struct usb_spca50x *spca50x)
+{
+	int err_code;
+	struct usb_device *dev=spca50x->dev;
+	int index; // index in the modes table
+
+	switch(spca50x->bridge)
+	{
+		case BRIDGE_SPCA500:
+		{
+			/* initialisation of spca500 based cameras is deferred */
+			break;
+		}
+		case BRIDGE_SPCA501:
+		{
+			PDEBUG(2, "Initializing SPCA501 started");
+			if(spca50x->dev->descriptor.idVendor  == 0x0506 &&
+			   spca50x->dev->descriptor.idProduct == 0x00df) 
+			{
+				/* Special handling for 3com data */
+				spca50x_write_vector(spca50x, spca501_3com_open_data);
+			}
+			else
+			{
+				/* Generic 501 open data */
+				spca50x_write_vector(spca50x, spca501_open_data);
+			}
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+			spca50x->a_blue  = spca50x_reg_read(spca50x->dev, 
+				SPCA501_REG_CCDSP, SPCA501_A11, 2) & 0xFF;
+			spca50x->a_green = spca50x_reg_read(spca50x->dev, 
+				SPCA501_REG_CCDSP, SPCA501_A21, 2) & 0xFF;
+			spca50x->a_red   = spca50x_reg_read(spca50x->dev, 
+				SPCA501_REG_CCDSP, SPCA501_A31, 2) & 0xFF;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+			PDEBUG(2, "Initializing SPCA501 finished");
+			break;
+		}
+		case BRIDGE_SPCA504:
+		{
+			PDEBUG(2,"Opening SPCA504");   
+			/* Write qtable values into the cam. */
+			spca50x_write_vector(spca50x, spca504_open_data);
+			break;
+		}
+		case BRIDGE_SPCA505:
+		{
+			PDEBUG(2,"Initializing SPCA505 for sensor type %s",
+				((spca50x->ccd == 0)? "CCD": "Video In"));
+			if(!spca50x->ccd)
+			{
+				spca50x_write_vector(spca50x, spca505_open_data_ccd);
+			}
+			else
+			{
+				spca50x_write_vector(spca50x, spca505_open_data_ext);
+				spca50x_write_i2c_vector(spca50x, SAA7113_I2C_BASE_WRITE, 
+					spca50x_i2c_data);
+				spca50x_write_vector(spca50x, spca505_open_data2);
+			}
+
+			err_code = 0;
+			err_code = spca50x_reg_read(dev, 6, (__u16)0x16, 2);
+			
+			if(err_code < 0)
+			{
+				PDEBUG(1, "register read failed for after vector read err = %d",
+					err_code);
+				return -EIO;
+			}
+			else 
+			{
+				PDEBUG(3, "After vector read returns : 0x%x should be 0x0101",
+					err_code & 0xFFFF);
+			}
+			
+			err_code = spca50x_reg_write(dev, 6, (__u16)0x16, (__u16)0xa);
+			if(err_code < 0)
+			{
+				PDEBUG(1, "register write failed for (6,0xa,0x16) err=%d", err_code);
+				return -EIO;
+			}
+			
+			if(spca50x->ccd)
+			{
+				spca50x_write_i2c(spca50x, SAA7113_I2C_BASE_WRITE, 0xa, bright & 0xff);
+				spca50x_write_i2c(spca50x, SAA7113_I2C_BASE_WRITE, 0xb, contrast & 0xff);
+			
+				spca50x_read_SAA7113_status(spca50x);
+			}
+			else
+			{
+				spca50x_reg_write(spca50x->dev, 5, 0xc2, 18);
+			}
+			
+			break;
+		}
+		case BRIDGE_SPCA506:
+		{
+			// Untested */
+			spca50x_write_vector(spca50x, spca506_open_data_ext);
+			spca50x_write_i2c_vector(spca50x, SAA7113_I2C_BASE_WRITE, 
+				spca50x_i2c_data);
+			spca50x_write_vector(spca50x, spca506_open_data2);
+			
+			spca50x_write_i2c(spca50x, SAA7113_I2C_BASE_WRITE, 0xa, bright & 0xff);
+			spca50x_write_i2c(spca50x, SAA7113_I2C_BASE_WRITE, 0xb, contrast & 0xff);
+			
+			spca50x_read_SAA7113_status(spca50x);
+			
+			break;
+		}
+		case BRIDGE_SPCA508:
+		{
+			spca50x_write_vector(spca50x,spca508_open_data);
+			break;
+		}
+		default:
+		{
+			err("Unimplemented bridge type");
+			return -EINVAL;
+		}
+	}
+
+	if ((index = spca50x_find_mode_index(spca50x->width, 
+	    spca50x->height, GET_EXT_MODES(spca50x->bridge))) == -EINVAL)
+	{
+		err("Can't find proper mode?!!");
+	}
+	else
+	{
+		err_code = spca50x_set_mode(spca50x, index,
+		                            GET_EXT_MODES(spca50x->bridge));
+		if (err_code)
+		{
+			err("Can't set proper camera mode");
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+
+/****************************************************************************
+ *
+ * V4L API
+ *
+ ***************************************************************************/
+
+static int spca50x_open(struct video_device *vdev, int flags)
+{
+	struct usb_spca50x *spca50x = (struct usb_spca50x *)vdev;
+	int err;
+
+	MOD_INC_USE_COUNT;
+
+	PDEBUG(2, "opening");
+
+	down(&spca50x->lock);
+
+	err = -EBUSY;
+	if (spca50x->user) goto out;
+
+	err = -ENOMEM;
+	if (spca50x_alloc(spca50x)) goto out;
+
+	err = spca50x_init_source(spca50x);
+	if (err != 0) goto out;
+
+	spca50x->curframe = 0;
+	PDEBUG(5," frame[0]=0x%p frame[0].grabstata=Frameready\n", &(spca50x->frame[0]));
+	spca50x->frame[0].grabstate = FRAME_READY;
+	spca50x->frame[0].seq = -1;
+	spca50x->lastFrameRead = -1;
+
+	err = spca50x_init_isoc(spca50x);
+	if (err)
+	{
+		PDEBUG(4,"4 DEALLOC error on spca50x_init\n");
+		spca50x_dealloc(spca50x, 0);
+		goto out;
+	}
+
+	/* Now, let's get brightness from the camera */
+	spca50x->brightness = spca50x_get_brightness(spca50x) << 8;
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	spca50x->whiteness = spca50x_get_whiteness(spca50x) << 8;
+#else /* SPCA50X_ENABLE_EXPERIMENTAL */
+	spca50x->whiteness = 0;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+	spca50x->user++;
+out:
+	up(&spca50x->lock);
+
+	if (err) 
+		MOD_DEC_USE_COUNT;
+
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	spca50x->nstable = 0;
+	spca50x->nunstable = 0;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+
+	if (err)
+	{
+		PDEBUG(2, "Open failed");
+	}
+	else
+	{
+		PDEBUG(2, "Open done");
+	}
+
+	return err;
+}
+
+static void spca50x_close_callback(unsigned long data)
+{
+  struct usb_spca50x *spca50x = (struct usb_spca50x *)data;
+
+  PDEBUG(4, "entered close CB");
+
+  del_timer(&spca50x->buf_timer);
+
+  video_unregister_device(&spca50x->vdev);
+  kfree(spca50x);
+  spca50x = NULL;
+
+  MOD_DEC_USE_COUNT;
+
+  PDEBUG(4, "leaving close CB");
+}
+
+
+
+static void spca50x_close(struct video_device *dev)
+{
+	struct usb_spca50x *spca50x = (struct usb_spca50x *)dev;
+	int i;
+
+	PDEBUG(2, "spca50x_close");
+
+	down(&spca50x->lock);
+
+	spca50x->user--;
+	spca50x->curframe = -1;
+
+	spca50x_stop_isoc(spca50x);
+
+	for(i = 0; i < SPCA50X_NUMFRAMES; i++)
+	{
+		if (waitqueue_active(&spca50x->frame[i].wq)) 
+			wake_up_interruptible(&spca50x->frame[i].wq);
+	}
+
+	if (spca50x->dev)
+	{
+		if (spca50x->bridge == BRIDGE_SPCA505 ||
+			spca50x->bridge == BRIDGE_SPCA506)
+		{
+			spca50x_reg_write(spca50x->dev, 0x3, 0x3, 0x20); // This maybe reset or power control
+			spca50x_reg_write(spca50x->dev, 0x3, 0x1, 0x0);
+			spca50x_reg_write(spca50x->dev, 0x3, 0x0, 0x1);
+			spca50x_reg_write(spca50x->dev, 0x5, 0x10, 0x1);
+			spca50x_reg_write(spca50x->dev, 0x5, 0x11,0xF);
+		}
+		else if (spca50x->bridge == BRIDGE_SPCA501)
+		{
+			// This maybe reset or power control
+			spca50x_reg_write(spca50x->dev, SPCA501_REG_CTLRL, 0x5, 0x0); 
+		}
+		spca50x_dealloc(spca50x, 0);
+	}
+
+	up(&spca50x->lock);
+
+	if (!spca50x->dev)
+	{
+          /* The camera is already disconnected, but cleanup delayed
+             bcz the video device was open by an user. FEB: 2002-2-2.
+          */
+	  struct timer_list *bt = &(spca50x->buf_timer);
+	  
+	  PDEBUG(3,"spca50x_close close on disconnected cam");
+          spca50x_dealloc(spca50x, 1);
+
+          /* Don't call video_unregister_device here or you will get a
+             deadlock. Using a timer to avoid that problem.
+           */
+          MOD_INC_USE_COUNT;
+          init_timer(bt);
+          bt->function = spca50x_close_callback;
+          bt->data = (unsigned long)spca50x;
+          bt->expires = jiffies + buf_timeout * HZ;
+          add_timer(bt);
+	}
+
+	MOD_DEC_USE_COUNT;
+}
+
+static int spca50x_init_done(struct video_device *dev)
+{
+#ifdef CONFIG_PROC_FS
+	create_proc_spca50x_cam((struct usb_spca50x *)dev);
+#endif /* CONFIG_PROC_FS */
+
+	return 0;
+}
+
+static long spca50x_write(struct video_device *dev, const char *buf, unsigned long count, int noblock)
+{
+	return -EINVAL;
+}
+
+static int spca50x_ioctl(struct video_device *vdev, unsigned int cmd, void *arg)
+{
+	struct usb_spca50x *spca50x = (struct usb_spca50x *)vdev;
+
+	PDEBUG(4, "IOCtl: 0x%X", cmd);
+
+	if (!spca50x->dev)
+		return -EIO;
+
+	switch (cmd) {
+	case VIDIOCGCAP:
+	{
+	 struct video_capability b;
+
+		PDEBUG (4, "VIDIOCGCAP");
+
+		strcpy(b.name, "SPCA50X USB Camera");
+		b.type = VID_TYPE_CAPTURE;
+		b.channels = ((spca50x->bridge == BRIDGE_SPCA506)? 2: 1);
+		b.audios = 0;
+		b.maxwidth = spca50x->maxwidth;
+		b.maxheight = spca50x->maxheight;
+
+		b.minwidth = 160;
+		b.minheight = 120;
+
+		if (copy_to_user(arg, &b, sizeof(b)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case VIDIOCGCHAN:
+	{
+	 struct video_channel v;
+
+		if (copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+		if (v.channel > ((spca50x->bridge == BRIDGE_SPCA505)? 1: 0) 
+			|| v.channel < 0 )
+			return -EINVAL;
+
+		switch(spca50x->bridge)
+		{
+			case BRIDGE_SPCA500:
+			{
+				strncpy(v.name, "CCD", 32);
+				break;
+			}
+			case BRIDGE_SPCA501:
+			{
+				strncpy(v.name, "CCD", 32);
+				break;
+			}
+			case BRIDGE_SPCA505:
+			{
+				strncpy(v.name, ((v.channel == 0)? "CCD": "Video In"), 32);
+				break;
+			}
+			case BRIDGE_SPCA506:
+			{
+				strncpy(v.name, "Video In", 32);
+				break;
+			}
+			case BRIDGE_SPCA508:
+			{
+				strncpy(v.name, "CCD", 32);
+				break;
+			}
+		}
+
+		v.flags = 0;
+		v.tuners = 0;
+		v.type = VIDEO_TYPE_CAMERA;
+
+		if (copy_to_user(arg, &v, sizeof(v)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case VIDIOCSCHAN:
+	{
+		/* 
+		There seems to be some confusion as to whether this is a struct 
+		video_channel or an int. This should be safe as the first element 
+		of video_channel is an int channel number
+		and we just ignore the rest 
+		*/
+		int v;
+
+		if (copy_from_user(&v, arg, sizeof(v)))
+			return -EFAULT;
+
+		if ((v > 0 && spca50x->bridge != BRIDGE_SPCA505) || v > 1 || v < 0)
+			return -EINVAL;
+
+		if(v != spca50x->ccd)
+		{
+			/* Haven't tested this yet */
+			spca50x->ccd = v;
+			if (spca50x_init_source(spca50x) != 0)
+				return -EIO;
+		}
+
+		return 0;
+	}
+	case VIDIOCGPICT:
+	{
+		struct video_picture p;
+
+		p.depth = spca50x->frame[0].depth;
+		p.palette = spca50x->frame[0].format;
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+		if (!autoadjust)
+			p.brightness = spca50x_get_brightness(spca50x) << 8;
+#else /* SPCA50X_ENABLE_EXPERIMENTAL */
+	 	p.brightness = spca50x_get_brightness(spca50x) << 8;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+
+		PDEBUG (4, "VIDIOCGPICT: depth=%d, palette=%d", p.depth, p.palette);
+
+		if(spca50x->ccd)
+		{
+			p.colour = spca50x_read_i2c(spca50x,SAA7113_I2C_BASE_READ,0xc)<<8;
+			p.whiteness = 0;
+			p.contrast = spca50x_read_i2c(spca50x,SAA7113_I2C_BASE_READ,0xb)<<8;
+			p.hue = spca50x_read_i2c(spca50x,SAA7113_I2C_BASE_READ,0xd)<<8;
+		}
+		else
+		{
+			switch(spca50x->bridge)
+			{
+				case BRIDGE_SPCA500:
+				{
+					int tmp;
+
+					p.colour     = 0;
+					p.whiteness  = 0;
+					p.contrast   = spca50x_reg_read(spca50x->dev, 0x0, 0x8168, 1) << 8;
+					p.brightness = spca50x_get_brightness(spca50x);
+
+					/* get hue */
+					tmp   = (spca50x_reg_read(spca50x->dev, 0x0, 0x816b, 1) & 12) << 6;
+					tmp  += spca50x_reg_read(spca50x->dev, 0x0, 0x816a, 1);
+					p.hue = tmp << 6;
+					PDEBUG(2, "brightness = %d",
+					       p.brightness);
+					break;
+				}
+				case BRIDGE_SPCA501:
+				{
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+					p.whiteness = spca50x_get_whiteness(spca50x) << 8;
+					if (autoadjust)
+						p.brightness = p.whiteness;
+					p.contrast = ((spca50x_reg_read(spca50x->dev, 
+						SPCA501_REG_CCDSP, SPCA501_A11, 2) & 0xFF) 
+						- spca50x->a_blue) << 8;
+					printk("Contrast = %d\n", p.contrast >> 8);
+#else /* SPCA50X_ENABLE_EXPERIMENTAL */
+					p.whiteness = 0;
+					p.contrast  = 0;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+					p.colour = (spca50x_reg_read(spca50x->dev, 
+						SPCA501_REG_CCDSP, 0x11, 2) & 0xFF) << 8;
+					p.hue = (spca50x_reg_read(spca50x->dev, 
+						SPCA501_REG_CCDSP, 0x13, 2) & 0xFF) << 8;
+					break;
+				}
+				case BRIDGE_SPCA504:
+				{
+					p.colour = spca50x_reg_read(spca50x->dev, 0x0, 0x21ae, 2)<<8;
+					p.whiteness = 0;
+					p.contrast = spca50x_reg_read(spca50x->dev, 0x0, 0x21a8, 2)<<8;
+					p.brightness = spca50x_get_brightness(spca50x);
+					p.hue = spca50x_reg_read(spca50x->dev, 0x0, 0x21ad, 2)<<8;
+					/* FIXME: how do we deal with gamma? the chip knows it, v4l doesnt */
+					PDEBUG(0, "color: 0x%02x contrast: 0x%02x brightness: 0x%02x hue: 0x%02x",
+					          p.colour, p.contrast, p.brightness, p.hue);
+					break;
+				}
+#ifdef SPCA50X_ENABLE_EXP_BRIGHTNESS
+				case BRIDGE_SPCA505:
+				{
+					p.whiteness = (spca50x_reg_read(spca50x->dev,6,0x59,2)*10)<<8;
+					p.contrast = spca50x_reg_read(spca50x->dev,5,0xc2,2)<<8;
+					p.colour = spca50x_reg_read(spca50x->dev,5,0xc2,2)<<8;
+					p.hue = spca50x_reg_read(spca50x->dev,5,0xc1,2)<<8;
+					break;
+				}
+#endif /* SPCA50X_ENABLE_EXP_BRIGHTNESS */
+				default:
+				{
+					/* default to not allowing any settings to change */
+					p.colour     = spca50x->colour;
+					p.whiteness  = spca50x->whiteness;
+					p.contrast   = spca50x->contrast;
+					p.brightness = spca50x->brightness;
+					p.hue        = spca50x->hue;
+					break;
+				}
+			}
+		}
+		if (copy_to_user(arg, &p, sizeof(p)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case VIDIOCSPICT:
+	{
+	 struct video_picture p;
+	 int i;
+
+		PDEBUG (4, "VIDIOCSPICT");
+
+		if (copy_from_user(&p, arg, sizeof(p)))
+			return -EFAULT;
+
+		if (!spca50x_get_depth(p.palette))
+			return -EINVAL;
+
+		if (p.depth < spca50x->min_bpp)
+			return -EINVAL;
+
+		PDEBUG(4, "Setting depth=%d, palette=%d", p.depth, p.palette);
+		for (i = 0; i < SPCA50X_NUMFRAMES; i++) 
+		{
+			spca50x->frame[i].depth = p.depth;
+			spca50x->frame[i].format = p.palette;
+		}
+
+		if(spca50x->ccd)
+		{
+			spca50x_write_i2c(spca50x,SAA7113_I2C_BASE_WRITE,0xa,p.brightness>>8);
+			spca50x_write_i2c(spca50x,SAA7113_I2C_BASE_WRITE,0xb,p.contrast>>8);
+			spca50x_write_i2c(spca50x,SAA7113_I2C_BASE_WRITE,0xc,p.colour>>8);
+			spca50x_write_i2c(spca50x,SAA7113_I2C_BASE_WRITE,0xd,p.hue>>8);
+		}
+		else
+		{
+			switch(spca50x->bridge)
+			{
+				case BRIDGE_SPCA500:
+				{
+					int tmp;
+
+					spca50x_set_brightness(spca50x, p.brightness >> 8);  //((p.brightness >> 8) + 128) % 255);
+					spca50x_reg_write(spca50x->dev, 0x00, 0x8168, p.contrast>>8);
+
+					/* set hue */
+					tmp  = spca50x_reg_read(spca50x->dev, 0x00, 0x816b, 1);
+					tmp  = tmp & 0xf3;
+					tmp += (p.hue & 0xc000) >> 12;
+					spca50x_reg_write(spca50x->dev, 0x00, 0x816b, tmp);
+					spca50x_reg_write(spca50x->dev, 0x00, 0x816a, (p.hue & 0x3fff)>>8);
+				}
+				case BRIDGE_SPCA501:
+				{
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+				 __u16 kred, kgreen, kblue; //coeffs of color correction
+
+					if (autoadjust)
+						p.whiteness = p.brightness;
+					spca50x_set_whiteness(spca50x, p.whiteness >> 8);
+					
+					/* Setting "contrast" (offset to color correction parameters) */
+					p.contrast >>= 8;
+					kred = spca50x->a_red + p.contrast;
+					kgreen = spca50x->a_green + p.contrast;
+					kblue = spca50x->a_blue + p.contrast;
+					PDEBUG(4, "Setting red = %d, green = %d, blue = %d", 
+						(__u8)(kred & 0xFF), (__u8)(kgreen & 0xFF), (__u8)(kblue & 0xFF));
+					if (kred < 256 && kgreen < 256 && kblue < 256)
+					{
+						spca50x_reg_write(spca50x->dev, 
+							SPCA501_REG_CCDSP, SPCA501_A11, (__u8)(kblue & 0xFF));
+						spca50x_reg_write(spca50x->dev, 
+							SPCA501_REG_CCDSP, SPCA501_A21, (__u8)(kgreen & 0xFF));
+						spca50x_reg_write(spca50x->dev, 
+							SPCA501_REG_CCDSP, SPCA501_A31, (__u8)(kred & 0xFF));
+					}
+					spca50x_reg_write(spca50x->dev, SPCA501_REG_CCDSP, 0x11, 
+						(__u8)((p.colour >> 8) & 0xFF));
+					spca50x_reg_write(spca50x->dev, SPCA501_REG_CCDSP, 0x13, 
+						(__u8)((p.hue >> 8) & 0xFF));
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+					/* Setting brightness */
+					PDEBUG(4, "Setting brightness = %d", p.brightness);
+//// This call must be moved to better place
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+					if (!autoadjust)
+						spca50x_set_brightness(spca50x, p.brightness >> 8);
+#else /* SPCA50X_ENABLE_EXPERIMENTAL */
+					spca50x_set_brightness(spca50x, p.brightness >> 8);
+#endif  /* SPCA50X_ENABLE_EXPERIMENTAL */
+					break;
+				}
+				case BRIDGE_SPCA504:
+				{
+					/* v4l docs tell me that all parameters are scaled 0-65535 
+					 * This means we keep them at that scale internally and adjust
+					 * to the actual hardware capabilites on write. */
+
+					/* 0 - 8 default on win: 1 */
+					spca50x_reg_write(spca50x->dev, 0x0, 0x21ae, p.colour >> 8);
+					p.whiteness = 0;
+					/* 1 - 8 default on win: 1 */
+					spca50x_reg_write(spca50x->dev, 0x0, 0x21a8, p.contrast >> 8);
+
+					/* The chip keeps the brightness as 129 -> 128 with 0 being the midpoint.
+					 * v4l always keeps these values unsigned 16 bit, that is 0 to 65535. 
+					 * Scale accordingly. */
+
+					spca50x_set_brightness(spca50x, ((p.brightness>>8)+128)%255);
+								
+					/* 0 - 360 default on win: 0 */
+					//spca50x_reg_write(spca50x->dev, 0x0, 0x21ad, p.hue >> 8);
+;;;
+					break;
+				}
+				case BRIDGE_SPCA505:
+				{
+#ifdef SPCA50X_ENABLE_EXP_BRIGHTNESS
+
+					spca50x_reg_write(spca50x->dev,6,0x1f,0x16);
+					spca50x_reg_write(spca50x->dev,6,0x20,0x0);
+					
+					spca50x_reg_write(spca50x->dev,5,0xc1,p.hue>>8);
+					spca50x_reg_write(spca50x->dev,5,0xc2,p.contrast>>8);
+					spca50x_reg_write(spca50x->dev,5,0xca,0x0);
+////I have no this type of camera. Please, check this and move this
+// call to better place
+					spca50x_set_brightness(spca50x, p.brightness >> 8);
+////
+					spca50x_reg_write(spca50x->dev,6,0x59,max((p.whiteness>>8)/10,20));
+#endif /* SPCA50X_ENABLE_EXP_BRIGHTNESS */
+					break;
+				}
+				default:
+				{
+					/* default to not allowing any settings to change */
+					p.colour     = spca50x->colour;
+					p.whiteness  = spca50x->whiteness;
+					p.contrast   = spca50x->contrast;
+					p.brightness = spca50x->brightness;
+					p.hue        = spca50x->hue;
+					break;
+				}
+			}
+		}
+		spca50x->contrast = p.contrast;
+		spca50x->brightness = p.brightness;
+		spca50x->colour = p.colour;
+		spca50x->hue = p.hue;
+		spca50x->whiteness = p.whiteness;
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+		spca50x->nstable = 0;
+		spca50x->nunstable = 0;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+
+		return 0;
+	}
+	case VIDIOCGCAPTURE:
+	{
+		int vf;
+
+		PDEBUG (4, "VIDIOCGCAPTURE");
+
+		if (copy_from_user(&vf, arg, sizeof(vf)))
+			return -EFAULT;
+
+		return -EINVAL;
+	}
+	case VIDIOCSCAPTURE:
+	{
+		struct video_capture vc;
+
+		if (copy_from_user(&vc, arg, sizeof(vc)))
+			return -EFAULT;
+		if (vc.flags)
+			return -EINVAL;
+		if (vc.decimation)
+			return -EINVAL;
+
+		return -EINVAL;
+	}
+	case VIDIOCSWIN:
+	{
+		struct video_window vw;
+		int result;
+
+		if (copy_from_user(&vw, arg, sizeof(vw)))
+			return -EFAULT;
+
+		PDEBUG (3, "VIDIOCSWIN: width=%d, height=%d, flags=%d",
+			vw.width, vw.height,vw.flags);
+#if 0
+		if (vw.flags) return -EINVAL;
+		if (vw.clipcount) return -EINVAL;
+#endif
+		if (vw.x) return -EINVAL;
+		if (vw.y) return -EINVAL;
+		if (vw.width  > spca50x->maxwidth)  return -EINVAL;
+		if (vw.height > spca50x->maxheight) return -EINVAL;
+#if 0
+		if (vw.chromakey !=0) return -EINVAL;
+#endif
+
+		/* If we're collecting previous frame, wait before changing
+		 * modes
+		 *
+		 * This seems to be blocking forever, dangerous not using it tho'
+		 */
+		interruptible_sleep_on(&spca50x->wq);
+		if (signal_pending(current)) return -EINTR;
+
+		result = spca50x_mode_init_regs(spca50x, vw.width, vw.height,
+		                                spca50x->frame[0].format, 
+		                                GET_EXT_MODES(spca50x->bridge));
+
+		if (result == 0) {
+			spca50x->frame[0].width = vw.width;
+			spca50x->frame[0].height = vw.height;
+		}
+
+		return result;
+	}
+	case VIDIOCGWIN:
+	{
+		struct video_window vw;
+
+		memset(&vw, 0, sizeof(vw));
+		vw.x      = 0;
+		vw.y      = 0;
+		vw.width  = spca50x->frame[0].width;
+		vw.height = spca50x->frame[0].height;
+		vw.flags  = 0;
+
+		PDEBUG (4, "VIDIOCGWIN: %dx%d", vw.width, vw.height);
+
+		if (copy_to_user(arg, &vw, sizeof(vw)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case VIDIOCGMBUF:
+	{
+		struct video_mbuf vm;
+		int               i;
+
+		memset(&vm, 0, sizeof(vm));
+		vm.size = SPCA50X_NUMFRAMES * MAX_DATA_SIZE;
+		vm.frames = SPCA50X_NUMFRAMES;
+
+		for(i=0;i<SPCA50X_NUMFRAMES;i++)
+		{
+			vm.offsets[i] = MAX_DATA_SIZE*i;
+		}
+
+		if (copy_to_user((void *)arg, (void *)&vm, sizeof(vm)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case VIDIOCMCAPTURE:
+	{
+		struct video_mmap vm;
+		int ret, depth;
+
+		if (copy_from_user((void *)&vm, (void *)arg, sizeof(vm)))
+			return -EFAULT;
+		PDEBUG(4, "CMCAPTURE");
+		PDEBUG(4, "frame: %d, size: %dx%d, format: %d",
+			vm.frame, vm.width, vm.height, vm.format);
+		depth = spca50x_get_depth(vm.format);
+		if (!depth || depth < spca50x->min_bpp) {
+			err("VIDIOCMCAPTURE: invalid format (%d)", vm.format);
+			return -EINVAL;
+		}
+
+		if ((vm.frame < 0) || (vm.frame > 3)) {
+			err("VIDIOCMCAPTURE: invalid frame (%d)", vm.frame);
+			return -EINVAL;
+		}
+
+		if (vm.width > spca50x->maxwidth || vm.height > spca50x->maxheight) {
+			err("VIDIOCMCAPTURE: requested dimensions too big");
+			return -EINVAL;
+		}
+
+		/* 
+		 * If we are grabbing the current frame, let it pass
+		 */ 
+		if (spca50x->frame[vm.frame].grabstate == FRAME_GRABBING || 
+		    (spca50x->frame[vm.frame].width != vm.width)         ||
+		    (spca50x->frame[vm.frame].height != vm.height)       ||
+		    (spca50x->frame[vm.frame].format != vm.format))
+		{
+			/* If we're collecting previous frame wait
+			   before changing modes */
+			/* If we are grabbing this frame let's wait for finish */
+			interruptible_sleep_on(&spca50x->wq);
+			if (signal_pending(current)) 
+				return -EINTR;
+		}
+
+		/* Don't compress if the size changed */
+		if ((spca50x->frame[vm.frame].width != vm.width)   ||
+		    (spca50x->frame[vm.frame].height != vm.height) ||
+		    (spca50x->frame[vm.frame].format != vm.format))
+		{
+			ret = spca50x_mode_init_regs(spca50x, vm.width, vm.height,
+			                             vm.format, 
+			                             GET_EXT_MODES(spca50x->bridge));
+			if (ret < 0)
+				return ret;
+		}
+
+		spca50x->frame[vm.frame].width  = vm.width;
+		spca50x->frame[vm.frame].height = vm.height;
+		spca50x->frame[vm.frame].format = vm.format;
+		spca50x->frame[vm.frame].depth  = depth;
+
+		/* Mark it as ready */
+		spca50x->frame[vm.frame].grabstate = FRAME_READY;
+		return 0;
+	}
+	case VIDIOCSYNC:
+	{
+		int frame;
+
+		if (copy_from_user((void *)&frame, arg, sizeof(int)))
+			return -EFAULT;
+
+		PDEBUG(4, "syncing to frame %d, grabstate = %d", frame,
+		       spca50x->frame[frame].grabstate);
+
+		switch (spca50x->frame[frame].grabstate) {
+		case FRAME_UNUSED:
+			return -EINVAL;
+                case FRAME_ABORTING:
+                        return -ENODEV;
+		case FRAME_READY:
+		case FRAME_GRABBING:
+		case FRAME_ERROR:
+redo:
+			if (!spca50x->dev)
+				return -EIO;
+
+			do {
+#if 0
+				init_waitqueue_head(&spca50x->frame[frame].wq);
+#endif
+				interruptible_sleep_on(&spca50x->frame[frame].wq);
+				if (signal_pending(current)) {
+					if (retry_sync) {
+						PDEBUG(3, "***retry sync***");
+
+						/* Polling apps will destroy frames with that! */
+						spca50x->curframe = -1;
+
+						/* This will request another frame. */
+						if (waitqueue_active(&spca50x->frame[frame].wq))
+							wake_up_interruptible(&spca50x->frame[frame].wq);
+
+						return 0;
+					} else {
+						return -EINTR;
+					}
+				}
+			} while (spca50x->frame[frame].grabstate == FRAME_GRABBING);
+
+			PDEBUG(5,"Synched on frame %d, grabstate = %d",
+			         frame, spca50x->frame[frame].grabstate);
+
+			if (spca50x->frame[frame].grabstate == FRAME_ERROR) {
+				goto redo;
+			}
+			/* Fallthrough.
+			 * We have waited in state FRAME_GRABBING until it
+			 * becomes FRAME_DONE, so now we can move along.
+			 */
+		case FRAME_DONE:
+			if (spca50x->snap_enabled && !spca50x->frame[frame].snapshot) {
+				goto redo;
+			}
+			PDEBUG(5,"Already synched %d\n",frame);
+
+			/* Release the current frame. This means that it
+			 * will be reused as soon as all other frames are
+			 * full, so the app better be done with it quickly.
+			 * Can this be avoided somehow?
+			 */
+			spca50x->frame[frame].grabstate = FRAME_UNUSED;
+
+			break;
+		} /* end switch */
+
+		return 0;
+	}
+	case VIDIOCGFBUF:
+	{
+		struct video_buffer vb;
+
+		memset(&vb, 0, sizeof(vb));
+		vb.base = NULL;	/* frame buffer not supported, not used */
+
+		if (copy_to_user((void *)arg, (void *)&vb, sizeof(vb)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case VIDIOCKEY:
+		return 0;
+	case VIDIOCCAPTURE:
+		return -EINVAL;
+	case VIDIOCSFBUF:
+		return -EINVAL;
+	case VIDIOCGTUNER:
+	case VIDIOCSTUNER:
+		return -EINVAL;
+	case VIDIOCGFREQ:
+	case VIDIOCSFREQ:
+		return -EINVAL;
+	case VIDIOCGAUDIO:
+	case VIDIOCSAUDIO:
+		return -EINVAL;
+	default:
+		return -ENOIOCTLCMD;
+	} /* end switch */
+
+	return 0;
+}
+
+static long spca50x_read(struct video_device *dev, char *buf, unsigned long count, int noblock)
+{
+	struct usb_spca50x *spca50x = (struct usb_spca50x *)dev;
+	int i;
+	int frmx = -1;
+	int reqFrame;
+	volatile struct spca50x_frame *frame;
+
+	PDEBUG(4, "%ld bytes, noblock=%d", count, noblock);
+
+restart:
+	if (signal_pending(current)) 
+		return -EINTR;
+
+	if (!dev || !buf) 
+		return -EFAULT;
+
+	if (!spca50x->dev) 
+		return -EIO;
+
+	if(!spca50x->streaming) 
+		return -EIO;
+
+	/* Wait for the end of the frame. This is the waitq for all frames,
+	 * so we get triggered as soon as any frame is DONE.
+	 */
+	interruptible_sleep_on(&spca50x->wq);
+
+	if (signal_pending(current)) 
+		return -EINTR;
+
+	if (spca50x->bridge == BRIDGE_SPCA500 ||
+	    spca50x->bridge == BRIDGE_SPCA504)
+	{
+		/* 
+		 * Ok, for the jpeg cams, we know we have received a whole
+		 * frame now. The rest of the code in this routine confuses 
+		 * frames and sequence numbers, so we do our own thing here.
+		 * */
+
+		/* One frame has just been set to DONE. Find it. */
+		for(i = 0; i < SPCA50X_NUMFRAMES; i++)
+			if (spca50x->frame[i].grabstate == FRAME_DONE)
+				frmx = i;
+		
+		PDEBUG(4, "Frame number: %d", frmx);
+		if (frmx < 0)
+		{
+			/* We havent found a frame that is DONE. Damn. Should
+			 * not happen. */
+			PDEBUG(2, "Couldnt find a frame ready to be read.");
+			return -EFAULT;
+		}
+		frame = &spca50x->frame[frmx];
+		
+		count = frame->width * frame->height * (frame->depth >> 3);
+		if ((i = copy_to_user(buf, frame->data, count))) {
+			PDEBUG(2, "Copy failed! %d bytes not copied", i);
+			return -EFAULT;
+		}
+		/* Release the frame */
+		frame->grabstate = FRAME_READY;
+		
+		return count;
+	}
+
+	if (spca50x->lastFrameRead < 0) {
+	  // If we haven't read a frame yet, start lastFrameRead at the end
+	  // of the 256-frame series, so we don't loop forever if the
+	  // 4 frames we have don't match reqFrame.
+	  spca50x->lastFrameRead = 255;
+	}
+
+	/* See if a frame is completed, then use it. */
+	reqFrame = (spca50x->lastFrameRead + 1) % 256;
+	frmx = -1;
+	while(frmx == -1 && reqFrame != spca50x->lastFrameRead)
+	{
+		// Cycle through the frames looking for one with the next sequence number
+		for(i = 0; i < SPCA50X_NUMFRAMES; i++)
+		{
+			PDEBUG(1, "Cycling through frames");
+			if (spca50x->frame[i].grabstate >= FRAME_GRABBING && 
+				spca50x->frame[i].seq==reqFrame)
+			{
+				frmx = i;
+				break;
+			}
+		}
+		// Can't find the requested frame, bump the sequence and try again
+		reqFrame = (reqFrame + 1) % 256;
+	}
+
+	/* If nonblocking we return immediately on not 
+	finding a frame or finding one in grabstate */
+	if (noblock && (frmx == -1 || spca50x->frame[frmx].grabstate == FRAME_GRABBING)) 
+		return -EAGAIN;
+
+	if (frmx == -1)
+	{
+#if 1
+		// Should never get here, try to recover gracefully if we do
+		frmx = 1;
+		spca50x->curframe = 0;
+		spca50x->frame[0].grabstate=FRAME_ERROR;
+#else
+		// Could get here if we aren't getting device interrupts (e.g. device isn't
+		// working properly).  Couldn't find a frame.
+		// fixed by D.M.A.
+		// TBD: This may not be the best fix: if we read immediately
+		// after opening, we get this error rather than waiting for
+		// data.  Would it be better to do something which
+		// forces the state to FRAME_GRABBING or in some other way
+		// makes the client process sleep?
+		PDEBUG(3, "Couldn't find a frame in queue.");
+		return -EIO;
+#endif
+	}
+
+	frame = &spca50x->frame[frmx];
+
+	/* Wait while we're grabbing the image */
+	PDEBUG(4, "Waiting image grabbing");
+	while (frame->grabstate == FRAME_GRABBING) {
+		interruptible_sleep_on(&spca50x->frame[frmx].wq);
+		if (signal_pending(current))
+			return -EINTR;
+		if(!spca50x->streaming) return -EIO;
+	}
+	PDEBUG(4, "Got image, frame = %d, frame->grabstate = %d", frmx, frame->grabstate);
+
+	if (frame->grabstate == FRAME_ERROR) {
+		frame->bytes_read = 0;
+		err("** ick! ** Errored frame %d", spca50x->curframe);
+		frame->grabstate = FRAME_UNUSED;
+		goto restart;
+	}
+
+	PDEBUG(3, "frmx=%d, bytes_read=%ld, scanlength=%ld", frmx,
+		frame->bytes_read, frame->scanlength);
+
+	/* copy bytes to user space; we allow for partials reads */
+//	if ((count + frame->bytes_read) > frame->scanlength)
+//		count = frame->scanlength - frame->bytes_read;
+
+	/* FIXME: count hardwired to be one frame... */
+	count = frame->width * frame->height * (frame->depth >> 3);
+
+	PDEBUG(4, "Copy to user space: %ld bytes", count);
+
+	if ((i = copy_to_user(buf, frame->data + frame->bytes_read, count))) {
+		PDEBUG(4, "Copy failed! %d bytes not copied", i);
+		return -EFAULT;
+	}
+
+	frame->bytes_read += count;
+	PDEBUG(4, "{copy} count used=%ld, new bytes_read=%ld",
+		count, frame->bytes_read);
+
+	if (frame->bytes_read >= frame->scanlength) { /* All data has been read */
+		frame->bytes_read = 0;
+		spca50x->lastFrameRead=spca50x->frame[frmx].seq;
+		/* Mark it as available to be used again. */
+		PDEBUG(3,"Releasing frame %d",frmx);
+		frame->grabstate = FRAME_READY;
+	}
+
+	PDEBUG(4, "read finished, returning %ld (sweet)", count);
+
+	return count;
+}
+
+static int spca50x_mmap(struct video_device *dev, const char *adr,
+	unsigned long size)
+{
+	struct usb_spca50x *spca50x = (struct usb_spca50x *)dev;
+	unsigned long start = (unsigned long)adr;
+	unsigned long page, pos;
+
+	if (spca50x->dev == NULL)
+		return -EIO;
+
+	PDEBUG(4, "mmap: %ld (%lX) bytes", size, size);
+
+	if (size > (((SPCA50X_NUMFRAMES * MAX_DATA_SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)))
+		return -EINVAL;
+
+	pos = (unsigned long)spca50x->fbuf;
+	while (size > 0) {
+		page = kvirt_to_pa(pos);
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return 0;
+}
+
+static struct video_device spca50x_template = {
+	name:		"SPCA50X USB Camera",
+	type:		VID_TYPE_CAPTURE,
+	hardware:	VID_HARDWARE_SPCA50X,
+	open:		spca50x_open,
+	close:		spca50x_close,
+	read:		spca50x_read,
+	write:		spca50x_write,
+	ioctl:		spca50x_ioctl,
+	mmap:		spca50x_mmap,
+	initialize:	spca50x_init_done,
+};
+
+/****************************************************************************
+ *
+ * SPCA50X configuration
+ *
+ ***************************************************************************/
+
+static int spca50x_configure_sensor(struct usb_spca50x *spca50x)
+{
+	struct usb_device *dev = spca50x->dev;
+
+	PDEBUG (4, "starting configuration");
+
+	if (spca50x_reset(dev,0) < 0)
+		return -1;
+
+	/* Set sensor-specific vars */
+	spca50x->maxwidth = 640;
+	spca50x->maxheight = 480;
+
+	return 0;
+}
+
+static int config_spca508(struct usb_spca50x *spca50x)
+{
+	struct usb_device *dev = spca50x->dev;
+	int data1, data2;
+	
+	// Read frm global register the USB product and vendor IDs, just to
+	// prove that we can communicate with the device.  This works, which
+	// confirms at we are communicating properly and that the device
+	// is a 508.
+	data1 = spca50x_reg_read(dev, 0, 0x8104, 1);
+	if (data1 < 0) PDEBUG(1,"Error reading USB Vendor ID from Global register");
+	data2 = spca50x_reg_read(dev, 0, 0x8105, 1);
+	if (data2 < 0) 
+		PDEBUG(1,"Error reading USB Vendor ID from Global register");
+	PDEBUG(1, "Read from GLOBAL: USB Vendor ID 0x%02x%02x", data2, data1);
+	
+	data1=spca50x_reg_read(dev, 0, 0x8106, 1);
+	if (data1 < 0) 
+		PDEBUG(1, "Error reading USB Product ID from Global register");
+	data2 = spca50x_reg_read(dev, 0, 0x8107, 1);
+	if (data2 < 0) 
+		PDEBUG(1, "Error reading USB Product ID from Global register");
+	PDEBUG(1, "Read from GLOBAL: USB Product ID 0x%02x%02x", data2, data1);
+	
+	data1=spca50x_reg_read(dev, 0, 0x8621, 1);
+	if (data1 < 0) 
+		PDEBUG(1, "Error reading Window 1 Average Luminance from Global register");
+	PDEBUG(1, "Read from GLOBAL: Window 1 average luminance %3d", data1);
+	
+	switch(spca50x->desc)
+	{
+		case 5:
+		{
+			if (spca50x_write_vector(spca50x, spca508_init_data))
+				return -1;
+			break;
+		}
+		case 13:
+		{
+			if (spca50x_write_vector(spca50x, spca508cs110_init_data))
+				return -1;
+			break;
+		}
+		default:
+			return -1;
+	}
+	return 0; // success
+}
+
+static int spca50x_configure(struct usb_spca50x *spca50x)
+{
+	int                i;
+	int                defaultcols;
+	int                defaultrows;
+	struct usb_device *dev = spca50x->dev;
+
+	/* dynamically look up the smallest available frame size */
+	i = spca50x_smallest_mode_index(GET_EXT_MODES(spca50x->bridge),
+	                                &defaultcols,
+	                                &defaultrows);
+	if (i < 0)
+		return i;
+
+	memcpy(&spca50x->vdev, &spca50x_template, sizeof(spca50x_template));
+
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+		init_waitqueue_head(&spca50x->frame[i].wq);
+
+	init_waitqueue_head(&spca50x->wq);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5)
+	if (video_register_device(&spca50x->vdev, VFL_TYPE_GRABBER) < 0) {
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5) */
+	if (video_register_device(&spca50x->vdev, VFL_TYPE_GRABBER,video_nr) < 0) {
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5) */
+		err("video_register_device failed");
+		return -EBUSY;
+	}
+
+	/* Initialise the camera bridge */
+	switch(spca50x->bridge)
+	{
+		case BRIDGE_SPCA500:
+		{
+			if(ccd) 
+				PDEBUG(1, "Forcing CCD to zero for SPCA500 which doesn't have external input !");
+			spca50x->ccd = 0;
+			if (spca500_full_reset(spca50x) < 0)
+			{
+				PDEBUG(2, "spca500_full_reset failed");
+				goto error;
+			}
+			break;
+		}
+		case BRIDGE_SPCA501:
+		{
+			/* Determine the sensor type for cameras with an
+			 * internal CCD or external input
+			 */
+			if(ccd)
+				PDEBUG(1, "Forcing CCD to zero for SPCA501? which doesn't have external input !");
+			spca50x->ccd = 0;
+			if (spca50x_write_vector(spca50x, spca501_init_data))
+				goto error;
+			break;
+		}
+		case BRIDGE_SPCA504:
+		{
+			spca50x->ccd = 0;
+			/* FIXME: What can sensibly be moved here from open? */
+			break;
+		}
+		case BRIDGE_SPCA505:
+		{
+			/* Determine the sensor type for cameras with an internal CCD or external input */
+			spca50x->ccd = ccd;
+			if (spca50x_write_vector(spca50x, spca505_init_data))
+				goto error;
+			break;
+		}
+		case BRIDGE_SPCA506:
+		{
+			if(ccd) 
+				PDEBUG(1, "Forcing CCD to one for SPCA506 which can't use one !");
+			/* Determine the sensor type for cameras with an internal CCD or external input */
+			spca50x->ccd = 1;
+			if (spca50x_write_vector(spca50x, spca506_init_data)) 
+				goto error;
+			break;
+		}
+		case BRIDGE_SPCA508:
+		{
+			/* FIXME: I've changed the following check to force ccd to be zero, instead of one.
+			 *        Since I don't have one of these cameras, I don't know whether this is
+			 *        the right thing to do.
+			 *        NWG: Mon 12th August 2002.
+			 */
+			if (ccd)
+				PDEBUG(1, "Forcing CCD to zero for SPCA508 which doesn't have external input !");
+			spca50x->ccd = 0;
+			if (config_spca508(spca50x)) 
+				goto error;
+			break;
+		}
+		default:
+		{
+			err("Unknown bridge type");
+			goto error;
+		}
+	}
+
+	spca50x_set_packet_size(spca50x, 0);
+	/* Set an initial pipe size; this will be overridden by
+	 * spca50x_set_mode(), called indirectly by the open routine.
+	 */
+	spca50x->pipe_size    = 384; 
+	spca50x->snap_enabled = snapshot;
+	spca50x->force_rgb    = force_rgb;
+	spca50x->min_bpp      = min_bpp;
+	spca50x->lum_level    = lum_level;
+	spca50x->width        = defaultcols;
+	spca50x->height       = defaultrows;
+
+	if (spca50x_reset(dev, 0) < 0)
+		goto error;
+
+	if(spca50x_configure_sensor(spca50x) < 0) {
+		err("failed to configure");
+		goto error;
+	}
+
+	/* Set default sizes in case IOCTL (VIDIOCMCAPTURE) is not used
+	 * (using read() instead). */
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+	{
+		spca50x->frame[i].width      = spca50x->width;
+		spca50x->frame[i].height     = spca50x->height;
+		spca50x->frame[i].scanlength = spca50x->width * spca50x->height * 3/2; // assumes 4:2:0 data
+		spca50x->frame[i].depth      = 24;
+		spca50x->frame[i].bytes_read = 0;
+		spca50x->frame[i].segment    = 0;
+
+		/* Note: format reflects format of data as returned to
+		 * a process, not as read from camera hardware.
+		 * This might be a good idea for dumb programs always
+		 * assuming the following settings.
+		 */
+		spca50x->frame[i].format = VIDEO_PALETTE_RGB24;
+	}
+
+	return 0;
+
+error:
+	video_unregister_device(&spca50x->vdev);
+	usb_driver_release_interface(&spca50x_driver,
+		&dev->actconfig->interface[spca50x->iface]);
+
+	return -EBUSY;
+}
+
+/***************************************************************************
+ *
+ * Model specific helper functions
+ *
+ * *************************************************************************/
+
+static int spca500_initialise(struct usb_spca50x *spca50x)
+{
+	int index;
+	int err;
+
+	/* read mode index */
+	index = spca50x_find_mode_index(spca50x->width, spca50x->height,
+	                                GET_EXT_MODES(spca50x->bridge));
+	if (index == -EINVAL)
+	{
+		PDEBUG(2, "Can't find proper mode?!!");
+		return -EINVAL;
+	}
+
+	/* do a full reset */
+	if ((err = spca500_full_reset(spca50x)) < 0)
+	{
+		PDEBUG(2, "spca500_full_reset failed");
+		return err;
+	}
+
+	if ((err = spca50x_reg_write(spca50x->dev, 0xe0, 0x0000, 0x0000)) < 0)
+	{
+		PDEBUG(2, "spca50x_reg_write() failed");
+		return err;
+	}
+	if ((err = spca50x_reg_readwait(spca50x->dev, 0x06, 0, 0)) < 0)
+	{
+		PDEBUG(2, "spca50x_reg_readwait() failed");
+		return err;
+	}
+
+	// spca50x_write_vector(spca50x, spca500_read_stats);
+
+	/* enable drop packet */
+	if ((err = spca50x_reg_write(spca50x->dev, 0x00, 0x850a, 0x0001)) < 0)
+	{
+	    PDEBUG(2, "failed to enable drop packet");
+	    return err;
+	}
+
+	/* set x multiplier */
+	spca50x_reg_write(spca50x->dev, 0, 0x8001,
+	                  GET_EXT_MODES(spca50x->bridge)[index][3]);
+
+	/* set y multiplier */
+	spca50x_reg_write(spca50x->dev, 0, 0x8002,
+	                  GET_EXT_MODES(spca50x->bridge)[index][4]);
+
+	/* use compressed mode, VGA, with mode specific subsample */
+	spca50x_reg_write(spca50x->dev, 0, 0x8003, (GET_EXT_MODES(spca50x->bridge)[index][2]<<4));
+
+	spca50x_reg_write(spca50x->dev, 0x20, 0x0001, 0x0004);
+
+	/* setup qtable */
+	switch (spca50x->desc)
+	{
+		case 9: /* Creative PC-CAM 300 */
+			err = spca50x_reg_write(spca50x->dev, 0x00, 0x8880, 3);
+			if (err < 0)
+			{
+				PDEBUG(2, "spca50x_reg_write failed");
+				return err;
+			}
+			err = spca500_setup_qtable(spca50x,
+			                           0x00, 0x8800, 0x8840,
+			                           spca500_pccam_qtable);
+			if (err < 0)
+			{
+				PDEBUG(2, "spca500_setup_qtable failed");
+				return err;
+			}
+			break;
+		case 15: /* Kodak EZ200 */
+			err = spca50x_reg_write(spca50x->dev, 0x00, 0x8880, 0);
+			if (err < 0)
+			{
+				PDEBUG(2, "spca50x_reg_write failed");
+				return err;
+			}
+			err = spca500_setup_qtable(spca50x,
+			                           0x00, 0x8800, 0x8840,
+			                           spca500_ez200_qtable);
+			if (err < 0)
+			{
+				PDEBUG(2, "spca500_setup_qtable failed");
+				return err;
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/* switch to video camera mode */
+	err = spca50x_reg_write(spca50x->dev, 0x00, 0x8000, 0x0004);
+	if (err < 0)
+	{
+		PDEBUG(2, "spca50x_reg_write failed");
+		return err;
+	}
+	if (spca50x_reg_readwait(spca50x->dev, 0, 0x8000, 0x44) != 0)
+	{
+		PDEBUG(2, "spca50x_reg_readwait() failed");
+		return -EIO;
+	}
+
+	spca50x_write_vector(spca50x, spca500_visual_defaults);
+
+	/* all ok */
+	return 0;
+}
+
+static int spca500_full_reset(struct usb_spca50x *spca50x)
+{
+	int err;
+
+	/* send the reset command */
+	err = spca50x_reg_write(spca50x->dev, 0xe0, 0x0001, 0x0000);
+	if (err < 0)
+	{
+		return err;
+	}
+
+	/* wait for the reset to complete */
+	err = spca50x_reg_readwait(spca50x->dev, 0x06, 0x0000, 0x0000);
+	if (err < 0)
+	{
+		return err;
+	}
+
+	/* all ok */
+	return 0;
+}
+
+static int spca500_setup_qtable(struct usb_spca50x *spca50x,
+                                unsigned int        request,
+                                unsigned int        ybase,
+                                unsigned int        cbase,
+                                unsigned char       qtable[2][64])
+{
+	int i;
+	int err;
+
+	/* loop over y components */
+	for (i = 0; i < 64; i++)
+	{
+		err = spca50x_reg_write(spca50x->dev, request, ybase + i, qtable[0][i]);
+		if (err < 0)
+		{
+			PDEBUG(2, "spca50x_reg_write failed");
+			return err;
+		}
+	}
+
+	/* loop over c components */
+	for (i = 0; i < 64; i++)
+	{
+		err = spca50x_reg_write(spca50x->dev, request, cbase + i, qtable[1][i]);
+		if (err < 0)
+		{
+			PDEBUG(2, "spca50x_reg_write failed");
+			return err;
+		}
+	}
+
+	/* all ok */
+	return 0;
+}
+
+static void spca504_acknowledged_command(struct usb_spca50x *spca50x, 
+				 __u16 reg,
+				 __u16 idx,
+				 __u16 val) 
+{ 
+	__u8 notdone = 0;
+
+	spca50x_reg_write(spca50x->dev,reg,idx,val);
+	notdone=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+	spca50x_reg_write(spca50x->dev,reg,idx,val);
+
+	PDEBUG(5,"before wait 0x%x",notdone);
+/* 
+ * 	
+ * 	set_current_state(TASK_INTERRUPTIBLE);
+ * 	schedule_timeout (2*HZ/10);
+ * 	
+ */
+	wait_ms(200);
+	//notdone=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+	PDEBUG(5,"after wait 0x%x",notdone);
+	
+	return;
+}
+
+/* version based on the snoops of gsmart mini3 */
+static void spca504_initialize(struct usb_spca50x *spca50x)
+{
+	__u8 i;
+	__u8 info[6];
+
+	spca504_acknowledged_command(spca50x,0x24,8,3);
+
+	for (i=0;i<6;i++)
+	{
+		info[i]=spca50x_reg_read_with_value(spca50x->dev, 0x20,i, 0x0000, 1);
+	}
+	PDEBUG(1, "Read info: %d %d %d %d %d %d . Should be 1,0,2,2,0,0\n", 
+			info[0], info[1], info[2], info[3], info[4], info[5]);
+
+	spca504_acknowledged_command(spca50x,0x24,8,3);
+
+	spca504_acknowledged_command(spca50x,0x24,0,0);
+
+	spca50x_reg_write(spca50x->dev, 0x0, 0x270c,0x5); //L92 sno1t.txt
+	
+	spca50x_reg_write(spca50x->dev, 0x0, 0x2310,0x5);
+
+	spca50x_reg_write(spca50x->dev, 0x0, 0x21a7,0x0000);  // brightness
+	spca50x_reg_write(spca50x->dev, 0x0, 0x21a8,0x0020); // contrast
+	spca50x_reg_write(spca50x->dev, 0x0, 0x21ad,0x0000);  // hue
+	spca50x_reg_write(spca50x->dev, 0x0, 0x21ac,0x0001);  // sat/hue
+	spca50x_reg_write(spca50x->dev, 0x0, 0x21ae,0x0020); // saturation
+	spca50x_reg_write(spca50x->dev, 0x0, 0x21a3,0x0000);  // gamma
+}
+
+
+/****************************************************************************
+ *
+ *  USB routines
+ *
+ ***************************************************************************/
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+static void* spca50x_probe(struct usb_device *dev, unsigned int ifnum,
+	const struct usb_device_id *id)
+#else /* LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0) */
+static void* spca50x_probe(struct usb_device *dev, unsigned int ifnum)
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0) */
+{
+	struct usb_interface_descriptor *interface;
+	struct usb_spca50x *spca50x;
+
+	PDEBUG(1, "probing for SPCA50x device...");
+
+	/* We don't handle multi-config cameras */
+	if (dev->descriptor.bNumConfigurations != 1)
+		return NULL;
+
+	interface = &dev->actconfig->interface[ifnum].altsetting[0];
+
+	/* Checking vendor/product should be enough, but what the hell */
+	if (interface->bInterfaceClass != 0xFF)
+		return NULL;
+	if (interface->bInterfaceSubClass != 0x00)
+		return NULL;
+
+	/* Since code below may sleep, we use this as a lock */
+	MOD_INC_USE_COUNT;
+
+	if ((spca50x = kmalloc(sizeof(struct usb_spca50x), GFP_KERNEL)) == NULL) {
+		err("couldn't kmalloc spca50x struct");
+		goto error;
+	}
+
+	memset(spca50x, 0, sizeof(struct usb_spca50x));
+
+	spca50x->dev = dev;
+	spca50x->iface = interface->bInterfaceNumber;
+
+	/* Is it a recognised camera ? */
+	switch(dev->descriptor.idVendor)
+	{
+		case 0x0733: /* Rebadged ViewQuest (Intel) and ViewQuest cameras */
+			switch(dev->descriptor.idProduct)
+			{
+				case 0x430:
+					spca50x->desc = 1;
+					spca50x->bridge = BRIDGE_SPCA505;
+					spca50x->sensor = SENSOR_SAA7113;
+					spca50x->header_len = SPCA50X_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg = SPCA50X_REG_I2C_CTRL;
+					spca50x->i2c_base = 0;
+					spca50x->i2c_trigger_on_write = 0;
+					info("USB SPCA50x camera found. Type Intel PC Camera Pro (SPCA505+SAA7113)");
+					break;
+				case 0x401:
+					spca50x->desc = 2;
+					spca50x->bridge = BRIDGE_SPCA501; /* This is a guess. At least the chip looks closer to the 501 than the 505 */
+					spca50x->sensor = SENSOR_SAA7113;
+					spca50x->header_len = SPCA501_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg = SPCA50X_REG_I2C_CTRL;
+					spca50x->i2c_base = 0;
+					spca50x->i2c_trigger_on_write = 0;
+					info("USB SPCA50x camera found. Type Intel Create and Share (SPCA501?+SAA7113?)");
+					break;
+				case 0x402:
+					spca50x->desc = 4;
+					spca50x->bridge = BRIDGE_SPCA501; /* This is a guess. At least the chip looks closer to the 501 than the 505 */
+					spca50x->sensor = SENSOR_SAA7113;
+					spca50x->header_len = SPCA501_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg = SPCA50X_REG_I2C_CTRL;
+					spca50x->i2c_base = 0;
+					spca50x->i2c_trigger_on_write = 0;
+					info("USB SPCA50x camera found.  ViewQuest M318B (SPCA500a)");
+					/*
+					Looks not perfectly but until we understand the difference
+					between spca501 and spca500 we'll treat them as one
+					*/
+					break;
+				case 0x110:
+					spca50x->desc = 5;
+					spca50x->bridge = BRIDGE_SPCA508;
+					spca50x->sensor = SENSOR_SAA7113;
+					spca50x->header_len = SPCA508_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg = 0;
+					spca50x->i2c_base = SPCA508_INDEX_I2C_BASE;
+					spca50x->i2c_trigger_on_write = 1;
+					info("USB SPCA50x camera found. Type ViewQuest (SPCA508?+SAA7113?)");
+					break;
+				default:
+				  goto error;
+			};
+			break;
+		case 0x99FA: /* GrandTec cameras */
+			switch(dev->descriptor.idProduct)
+			{
+				case 0x8988:
+					spca50x->desc = 3;
+					spca50x->bridge = BRIDGE_SPCA506;
+					spca50x->sensor = SENSOR_SAA7113;
+					spca50x->header_len = SPCA501_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg = SPCA50X_REG_I2C_CTRL;
+					spca50x->i2c_base = 0;
+					spca50x->i2c_trigger_on_write = 0;
+					info("USB SPCA50x camera found. Grandtec V.cap (SPCA506+SAA7113?)");
+					break;
+				default:
+					goto error;
+			};
+			break;
+		case 0x040A: /* Kodak cameras */
+			switch(dev->descriptor.idProduct)
+			{
+				case 0x0002:
+					spca50x->desc=6;
+					spca50x->bridge=BRIDGE_SPCA501;
+					spca50x->sensor=SENSOR_SAA7113;
+					spca50x->header_len=SPCA501_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg = SPCA50X_REG_I2C_CTRL;
+					spca50x->i2c_base = 0;
+					spca50x->i2c_trigger_on_write = 0;
+					info("USB SPCA50x camera found. Type Kodak DVC-325 (SPCA501A+SAA7113?)");
+					break;
+				case 0x0300:
+					switch (ifnum)
+					{
+						case 0:
+							spca50x->desc                 = 15;
+							spca50x->bridge               = BRIDGE_SPCA500;
+							spca50x->sensor               = SENSOR_SAA7113;
+							spca50x->header_len           = SPCA500_OFFSET_DATA;
+							spca50x->i2c_ctrl_reg         = SPCA50X_REG_I2C_CTRL;
+							spca50x->i2c_base             = 0;
+							spca50x->i2c_trigger_on_write = 0;
+							info("USB SPCA50x camera found. Type Kodak EZ200 (SPCA500+unknown CCD)");
+							break;
+						case 1:
+							/* ignore interface 1, as it's used for non-video connections.
+							 * NWG: Sat 15th February 2003.
+							 */
+							info("Ignoring Interface 1 of Kodak EZ200 (SPCA500A)");
+							goto error;
+					}
+					break;
+				default:
+					goto error;
+			};
+			break;
+		case 0x055f: /* Mustek cameras */
+		case 0x04fc: /* fixme */
+			switch(dev->descriptor.idProduct)
+			{
+			        case 0xc520:
+					spca50x->desc=8;
+					spca50x->bridge=BRIDGE_SPCA504;
+					spca50x->sensor=SENSOR_INTERNAL;
+					spca50x->header_len=SPCA50X_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg = 0;
+					spca50x->i2c_base = 0;
+					spca50x->i2c_trigger_on_write = 0;
+					info("USB SPCA50x camera found. Type Mustek gSmart Mini 3(SPCA504A");
+					break;
+				case 0xc420:
+				case 0x504a:
+					spca50x->desc=7;
+					spca50x->bridge=BRIDGE_SPCA504;
+					spca50x->sensor=SENSOR_INTERNAL;
+					spca50x->header_len=SPCA50X_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg = 0;
+					spca50x->i2c_base = 0;
+					spca50x->i2c_trigger_on_write = 0;
+					info("USB SPCA50x camera found. Type Mustek gSmart Mini 2(SPCA504A");
+					break;
+				default:
+					goto error;
+			};
+			break;
+		case 0x041E: /* Creative cameras */
+			switch(dev->descriptor.idProduct)
+			{
+				case 0x400A:
+					switch (ifnum)
+					{
+						case 0:
+							spca50x->desc                 = 9;
+							spca50x->bridge               = BRIDGE_SPCA500;
+							spca50x->sensor               = SENSOR_SAA7113;
+							spca50x->header_len           = SPCA500_OFFSET_DATA;
+							spca50x->i2c_ctrl_reg         = SPCA50X_REG_I2C_CTRL;
+							spca50x->i2c_base             = 0;
+							spca50x->i2c_trigger_on_write = 0;
+							info("USB SPCA50x camera found. Type Creative PC-CAM 300 (SPCA500+unknown CCD)");
+							break;
+						case 1:
+							/* ignore interface 1, as it's used for non-video connections.
+							 * NWG: Sat 17th August 2002.
+							 */
+							info("Ignoring Interface 1 of Creative PC-CAM 300 (SPCA500A)");
+							goto error;
+					}
+					break;
+				case 0x400B:
+					spca50x->desc                 = 11;
+					spca50x->bridge               = BRIDGE_SPCA504;
+					spca50x->sensor               = SENSOR_SAA7113;
+					spca50x->header_len           = SPCA500_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg         = SPCA50X_REG_I2C_CTRL;
+					spca50x->i2c_base             = 0;
+					spca50x->i2c_trigger_on_write = 0;
+					info("USB SPCA50x camera found. Type Creative PC-CAM 600 (SPCA504+unknown CCD)");
+					break;
+				default:
+					goto error;
+			};
+			break;
+		case 0x084D: /* D-Link / Minton */
+			switch(dev->descriptor.idProduct)
+			{
+				case 0x0003: /* DSC-350 / S-Cam F5 */
+					switch (ifnum)
+					{
+						case 0:
+							spca50x->desc                 = 10;
+							spca50x->bridge               = BRIDGE_SPCA500;
+							spca50x->sensor               = SENSOR_SAA7113;
+							spca50x->header_len           = SPCA500_OFFSET_DATA;
+							spca50x->i2c_ctrl_reg         = SPCA50X_REG_I2C_CTRL;
+							spca50x->i2c_base             = 0;
+							spca50x->i2c_trigger_on_write = 0;
+							info("USB SPCA50x camera found. Type D-Link DSC-350 / Minton S-Cam F5 (SPCA500+unknown CCD)");
+							break;
+						case 1:
+							/* ignore interface 1, as it's used for non-video connections.
+							 * NWG: Mon 16th September 2002.
+							 */
+							info("Ignoring Interface 1 of D-Link DSC-350 / Minton S-Cam F5 (SPCA500A)");
+							goto error;
+					}
+					break;
+				default:
+					goto error;
+			};
+			break;
+		case 0x8086: /* Intel */
+			switch(dev->descriptor.idProduct)
+			{
+				case 0x0110:
+					spca50x->desc                 = 13;
+					spca50x->bridge               = BRIDGE_SPCA508;
+					spca50x->sensor               = SENSOR_SAA7113;
+					spca50x->header_len           = SPCA508_OFFSET_DATA;
+					/* FIXME: The following two settings are a guess.
+					 *        Before, only i2c_ctrl_reg was specified,
+					 *        and in fact was being set to
+					 *        SPCA508_INDEX_I2C_BASE.
+					 *        This setting needs to be checked.
+					 *        NWG: Wed 12 Feb 2003.
+					 */
+					spca50x->i2c_ctrl_reg         = SPCA50X_REG_I2C_CTRL;
+					spca50x->i2c_base             = SPCA508_INDEX_I2C_BASE;
+					spca50x->i2c_trigger_on_write = 1;
+					info("USB SPCA50x camera found. Type Intel Easy PC Camera CS110 (SPCA508+SAA7113?)");
+					break;
+				case 0x0630: /* Pocket PC Camera */
+					switch (ifnum)
+					{
+						case 0:
+							spca50x->desc                 = 12;
+							spca50x->bridge               = BRIDGE_SPCA500;
+							spca50x->sensor               = SENSOR_SAA7113;
+							spca50x->header_len           = SPCA500_OFFSET_DATA;
+							spca50x->i2c_ctrl_reg         = SPCA50X_REG_I2C_CTRL;
+							spca50x->i2c_base             = 0;
+							spca50x->i2c_trigger_on_write = 0;
+							info("USB SPCA50x camera found. Type Intel Pocket PC Camera (SPCA500+unknown CCD)");
+							break;
+						case 1:
+							/* ignore interface 1, as it's used for non-video connections.
+							 * NWG: Sun 05th January 2003.
+							 */
+							info("Ignoring Interface 1 of Intel Pocket PC Camera (SPCA500A)");
+							goto error;
+					}
+					break;
+				default:
+					goto error;
+			};
+			break;
+		case 0x0506: /* 3COM cameras */
+			switch(dev->descriptor.idProduct)
+			{
+				case 0x00DF:
+					spca50x->desc=14;
+					spca50x->bridge=BRIDGE_SPCA501;
+					spca50x->sensor=SENSOR_SAA7113;
+					spca50x->header_len=SPCA501_OFFSET_DATA;
+					spca50x->i2c_ctrl_reg = SPCA50X_REG_I2C_CTRL;
+					spca50x->i2c_base = 0;
+					spca50x->i2c_trigger_on_write = 0;
+					info("USB SPCA50x camera found. Type 3Com HomeConnect Lite (SPCA501A+?)");
+					break;
+				default:
+					goto error;
+			};
+			break;
+			
+		default: goto error;
+	}
+
+	if (dumppix > 0) 
+		PDEBUG(1, "Using dumppix = %d", dumppix);
+
+	if (!spca50x_configure(spca50x)) {
+		spca50x->user = 0;
+		init_MUTEX(&spca50x->lock); /* to 1 == available */
+		init_MUTEX(&spca50x->buf_lock);
+		spca50x->buf_state = BUF_NOT_ALLOCATED;
+	} else {
+		err("Failed to configure camera");
+		goto error;
+	}
+
+	/* Workaround for some applications that want data in RGB
+	 * instead of BGR */
+	if (spca50x->force_rgb)
+		info("data format set to RGB");
+
+	spca50x->task.sync = 0;
+	spca50x->task.routine = auto_bh;
+	spca50x->task.data = spca50x;
+	spca50x->bh_requested = 0;
+	
+	MOD_DEC_USE_COUNT;
+	return spca50x;
+
+error:
+	if (spca50x) {
+		kfree(spca50x);
+		spca50x = NULL;
+	}
+
+	MOD_DEC_USE_COUNT;
+	return NULL;
+}
+
+
+static void
+spca50x_disconnect(struct usb_device *dev, void *ptr)
+{
+	struct usb_spca50x *spca50x = (struct usb_spca50x *) ptr;
+	int n;
+
+	MOD_INC_USE_COUNT;
+
+	PDEBUG(1, "Disconnect");
+
+	/* We don't want people trying to open up the device */
+	if (!spca50x->user)
+		video_unregister_device(&spca50x->vdev);
+	else
+		PDEBUG(3, "Device open...deferring video_unregister_device");
+
+	for (n = 0; n < SPCA50X_NUMFRAMES; n++)
+		spca50x->frame[n].grabstate = FRAME_ABORTING;
+
+	spca50x->curframe = -1;
+
+	/* This will cause the process to request another frame */
+	for (n = 0; n < SPCA50X_NUMFRAMES; n++)
+		if (waitqueue_active(&spca50x->frame[n].wq))
+			wake_up_interruptible(&spca50x->frame[n].wq);
+	if (waitqueue_active(&spca50x->wq))
+		wake_up_interruptible(&spca50x->wq);
+
+	spca50x->streaming = 0;
+
+	/* Unschedule all of the iso td's */
+	for (n = SPCA50X_NUMSBUF - 1; n >= 0; n--) {
+		if (spca50x->sbuf[n].urb) {
+			spca50x->sbuf[n].urb->next = NULL;
+			usb_unlink_urb(spca50x->sbuf[n].urb);
+			usb_free_urb(spca50x->sbuf[n].urb);
+			spca50x->sbuf[n].urb = NULL;
+		}
+	}
+
+	usb_driver_release_interface(&spca50x_driver,
+		&spca50x->dev->actconfig->interface[spca50x->iface]);
+	spca50x->dev = NULL;
+
+#ifdef CONFIG_PROC_FS
+	destroy_proc_spca50x_cam(spca50x);
+#endif /* CONFIG_PROC_FS */
+
+	/* Free the memory */
+	if (spca50x && !spca50x->user) {
+		spca50x_dealloc(spca50x, 1);
+		kfree(spca50x);
+		spca50x = NULL;
+	}
+
+	MOD_DEC_USE_COUNT;
+}
+
+static struct usb_driver spca50x_driver = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20)
+	THIS_MODULE,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20) */
+	"spca50x",
+	spca50x_probe,
+	spca50x_disconnect,
+	{ NULL, NULL }
+};
+
+
+/****************************************************************************
+ *
+ *  Module routines
+ *
+ ***************************************************************************/
+
+static int __init usb_spca50x_init(void)
+{
+#ifdef CONFIG_PROC_FS
+	proc_spca50x_create();
+#endif /* CONFIG_PROC_FS */
+
+	if (usb_register(&spca50x_driver) < 0)
+		return -1;
+
+	info("spca50x driver version %s registered", version);
+
+	return 0;
+}
+
+static void __exit usb_spca50x_exit(void)
+{
+	usb_deregister(&spca50x_driver);
+	info("driver deregistered");
+
+#ifdef CONFIG_PROC_FS
+	proc_spca50x_destroy();
+#endif /* CONFIG_PROC_FS */
+}
+
+module_init(usb_spca50x_init);
+module_exit(usb_spca50x_exit);
+
+//eof
diff -uN linux-2.4.20/drivers/usb.spca/spca50x.h linux-2.4.20/drivers/usb/spca50x.h
--- linux-2.4.20/drivers/usb.spca/spca50x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/spca50x.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,463 @@
+#ifndef SPCA50X_H
+#define SPCA50X_H
+
+/*
+ * Header file for SPCA50x based camera driver. Originally copied from ov511 driver.
+ * Originally by Mark W. McClelland
+ * SPCA50x version by Joel Crisp; all bugs are mine, all nice features are his.
+ */
+
+#ifdef __KERNEL__
+#include <asm/uaccess.h>
+#include <linux/videodev.h>
+#include <linux/smp_lock.h>
+#include <linux/usb.h>
+/*
+ *      tq_scheduler disappeared @ lk-2.4.0-test12
+ *      (right when <linux/sched.h> newly defined TQ_ACTIVE)
+ *
+ *      (snagged from linux/drivers/message/fusion/mptscsih.h)
+ *
+ */
+#define HAVE_TQ_SCHED 1
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#       include <linux/sched.h>
+#       ifdef TQ_ACTIVE
+#               undef HAVE_TQ_SCHED
+#       endif /* TQ_ACTIVE */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0) */
+#ifdef HAVE_TQ_SCHED
+#define SCHEDULE_TASK(x)                \
+	/*MOD_INC_USE_COUNT*/;          \
+	(x)->next = NULL;               \
+	queue_task(x, &tq_scheduler)
+#else /* HAVE_TQ_SCHED */
+#define SCHEDULE_TASK(x)                \
+	/*MOD_INC_USE_COUNT*/;          \
+	if (schedule_task(x) == 0) {    \
+		/*MOD_DEC_USE_COUNT*/;  \
+	}
+#endif /* HAVE_TQ_SCHED */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20)
+#define urb_t struct urb
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20) */
+
+static const char SPCA50X_H_CVS_VERSION[]="$Id: spca50x.h,v 1.23 2003/02/12 20:05:43 polesworth Exp $";
+
+#ifdef SPCA50X_ENABLE_DEBUG
+#  define PDEBUG(level, fmt, args...) \
+if (debug >= level) info("[%s:%d] " fmt, __PRETTY_FUNCTION__, __LINE__ , ## args)
+#else /* SPCA50X_ENABLE_DEBUG */
+#  define PDEBUG(level, fmt, args...) do {} while(0)
+#endif /* SPCA50X_ENABLE_DEBUG */
+
+#define FRAMES_PER_DESC		10	/* Default value, should be reasonable */
+#define MAX_FRAME_SIZE_PER_DESC 1024
+
+#define SPCA50X_MAX_WIDTH 640
+#define SPCA50X_MAX_HEIGHT 480
+
+#define SPCA50X_ENDPOINT_ADDRESS 1	/* Isoc endpoint number */
+
+/* Alternate interface transfer sizes */
+#define SPCA50X_ALT_SIZE_0       0
+#define SPCA50X_ALT_SIZE_128     1
+#define SPCA50X_ALT_SIZE_256     1
+#define SPCA50X_ALT_SIZE_384     2
+#define SPCA50X_ALT_SIZE_512     3
+#define SPCA50X_ALT_SIZE_640     4
+#define SPCA50X_ALT_SIZE_768     5
+#define SPCA50X_ALT_SIZE_896     6
+#define SPCA50X_ALT_SIZE_1023    7
+
+/* Sequence packet identifier for a dropped packet */
+#define SPCA50X_SEQUENCE_DROP 0xFF
+
+/* Type bit for 10 byte header snapshot flag */
+#define SPCA50X_SNAPBIT 0x40
+#define SPCA50X_SNAPCTRL 0x80
+
+/* Type bit for 8 byte header snapshot flag */
+#define SPCA501_SNAPBIT 0x80
+#define SPCA501_SNAPCTRL 0x10
+
+#define SPCA508_SNAPBIT 0x20
+#define SPCA508_SNAPCTRL 0x40
+
+/* Offsets into the 10 byte header on the first ISO packet */
+#define SPCA50X_OFFSET_SEQUENCE 0
+
+/* Generic frame packet header offsets */
+#define SPCA50X_OFFSET_TYPE     1
+#define SPCA50X_OFFSET_COMPRESS 2
+#define SPCA50X_OFFSET_THRESHOLD 3
+#define SPCA50X_OFFSET_QUANT 4
+#define SPCA50X_OFFSET_QUANT2 5
+#define SPCA50X_OFFSET_FRAMSEQ 6
+#define SPCA50X_OFFSET_EDGE_AUDIO 7
+#define SPCA50X_OFFSET_GPIO 8
+#define SPCA50X_OFFSET_RESERVED 9
+#define SPCA50X_OFFSET_DATA 10
+
+/* Frame packet header offsets for the spca500 */
+#define SPCA500_OFFSET_PADDINGLB 2
+#define SPCA500_OFFSET_PADDINGHB 3
+#define SPCA500_OFFSET_MODE      4
+#define SPCA500_OFFSET_IMGWIDTH  5
+#define SPCA500_OFFSET_IMGHEIGHT 6
+#define SPCA500_OFFSET_IMGMODE   7
+#define SPCA500_OFFSET_QTBLINDEX 8
+#define SPCA500_OFFSET_FRAMSEQ   9
+#define SPCA500_OFFSET_CDSPINFO  10
+#define SPCA500_OFFSET_GPIO      11
+#define SPCA500_OFFSET_AUGPIO    12
+#define SPCA500_OFFSET_DATA      16
+
+/* Frame packet header offsets for the spca501 */
+#define SPCA501_OFFSET_GPIO   1
+#define SPCA501_OFFSET_TYPE   2
+#define SPCA501_OFFSET_TURN3A 3
+#define SPCA501_OFFSET_FRAMSEQ 4
+#define SPCA501_OFFSET_COMPRESS 5
+#define SPCA501_OFFSET_QUANT 6
+#define SPCA501_OFFSET_QUANT2 7
+#define SPCA501_OFFSET_DATA 8
+
+#define SPCA508_OFFSET_TYPE 1
+#define SPCA508_OFFSET_COMPRESS 2
+#define SPCA508_OFFSET_FRAMSEQ 8
+#define SPCA508_OFFSET_WIN1LUM 11
+#define SPCA508_OFFSET_DATA 37
+
+/* Bitmask for properties at offsets above */
+#define SPCA50X_PROP_COMP_ENABLE(d) ( (d) & 1 )
+#define SPCA50X_PROP_SNAP(d) ( (d) & SPCA50X_SNAPBIT )
+#define SPCA50X_PROP_SNAP_CTRL(d) ( (d) & SPCA50X_SNAPCTRL )
+#define SPCA50X_PROP_COMP_T3A(d) ( ((d) & 0xA ) >> 2)
+#define SPCA50X_PROP_COMP_T3D(d) ( ((d) & 0x70 ) >> 4)
+
+#define SPCA501_PROP_COMP_ENABLE(d) ( (d) & 1 )
+#define SPCA501_PROP_SNAP(d) ( (d) & 0x40 )
+#define SPCA501_PROP_SNAP_CTRL(d) ( (d) & 0x10)
+#define SPCA501_PROP_COMP_THRESH(d) ( ((d) & 0xE ) >> 1)
+#define SPCA501_PROP_COMP_QUANT(d) ( ((d) & 0x70 ) >> 4)
+
+/* SPCA501 CCDSP control */
+#define SPCA501_REG_CCDSP 0x1
+/* SPCA501 control/status registers */
+#define SPCA501_REG_CTLRL 0x2
+
+//registers for color correction and YUV transformation
+#define SPCA501_A11 0x08
+#define SPCA501_A12 0x09
+#define SPCA501_A13 0x0A
+#define SPCA501_A21 0x0B
+#define SPCA501_A22 0x0C
+#define SPCA501_A23 0x0D
+#define SPCA501_A31 0x0E
+#define SPCA501_A32 0x0F
+#define SPCA501_A33 0x10
+
+/* USB control */
+#define SPCA50X_REG_USB 0x2
+
+#define SPCA50X_USB_CTRL 0x0
+#define SPCA50X_CUSB_ENABLE 0x1
+#define SPCA50X_CUSB_PREFETCH 0x2
+
+
+/* Global control register */
+#define SPCA50X_REG_GLOBAL 0x3
+
+#define SPCA50X_GLOBAL_MISC0 0x0 // Global control miscellaneous 0
+#define SPCA50X_GMISC0_IDSEL 0x1 // Global control device ID select
+#define SPCA50X_GMISC0_EXTTXEN 0x2 // Global control USB Transceiver select
+
+#define SPCA50X_GLOBAL_MISC1 0x1
+#define SPCA50X_GMISC1_BLKUSBRESET 0x1
+#define SPCA50X_GMISC1_BLKSUSPEND 0x2
+#define SPCA50X_GMISC1_DRAMOUTEN 0x10
+#define SPCA50X_GMISC1_INTRAMCRTEN 0x20
+
+#define SPCA50X_GLOBAL_MISC2 0x2
+
+#define SPCA50X_GLOBAL_MISC3 0x3
+#define SPCA50X_GMISC3_SSC 0x1
+#define SPCA50X_GMISC3_SSD 0x2
+#define SPCA50X_GMISC3_SAA7113RST 0x20 /* Not sure about this one */
+
+#define SPCA50X_GLOBAL_MISC4 0x4
+#define SPCA50X_GMISC4_SSCEN 0x1
+#define SPCA50X_GMISC4_SSDEN 0x2
+
+#define SPCA50X_GLOBAL_MISC5 0x5
+#define SPCA50X_GMISC5_SSD 0x2
+
+#define SPCA50X_GLOBAL_MISC6 0x6
+
+/* Image format and compression control */
+#define SPCA50X_REG_COMPRESS 0x4
+
+#define SPCA50X_COMPRESS_MISC1 0x1
+#define SPCA50X_CMISC1_TVFIELDPROCESS 0x40
+
+#define SPCA50X_COMPRESS_ENABLE 0x8
+#define SPCA50X_CENABLE_ENABLE 0x1
+
+/* TV control register */
+#define SPCA50X_REG_TV 0x8
+
+#define SPCA50X_TV_MISC0 0x0
+#define SPCA50X_TMISC0_PAL 0x1
+#define SPCA50X_TMISC0_SINGLECHANNEL 0x2
+#define SPCA50X_TMISC0_EXTFIELD 0x4
+#define SPCA50X_TMISC0_INVFIELD 0x8
+#define SPCA50X_TMISC0_PIXSEL 0x30 /* Not sure what this does */
+#define SPCA50x_TMISC0_ADD128 0x80
+
+/* I2C interface on an SPCA505, SPCA506, SPCA508 */
+#define SPCA50X_REG_I2C_CTRL 0x7
+#define SPCA50X_I2C_DEVICE 0x4
+#define SPCA50X_I2C_SUBADDR 0x1
+#define SPCA50X_I2C_VALUE 0x0
+#define SPCA50X_I2C_TRIGGER 0x2
+#define SPCA50X_I2C_TRIGGER_BIT 0x1
+#define SPCA50X_I2C_READ 0x0
+#define SPCA50X_I2C_STATUS 0x3
+
+#define SAA7113_REG_STATUS 0x1f
+
+#define SAA7113_I2C_BASE_WRITE 0x4A
+#define SAA7113_I2C_BASE_READ 0x4A /* SPCA50x seems to add the read bit itself */
+#define SAA7113_I2C_ALT_BASE_WRITE 0x48
+#define SAA7113_I2C_ALT_BASE_READ 0x48 /* SPCA50x seems to add the read bit itself */
+
+#define SPCA508_INDEX_I2C_BASE 0x8800
+
+/* SAA 7113 */
+#define SAA7113_STATUS_READY(d) (d & 0x1)
+#define SAA7113_STATUS_COPRO(d) (d & 0x2)
+#define SAA7113_STATUS_WIPA(d)  (d & 0x4)
+#define SAA7113_STATUS_GLIMB(d) (d & 0x8)
+#define SAA7113_STATUS_GLIMT(d) (d & 0x10)
+#define SAA7113_STATUS_FIDT(d)  (d & 0x20)
+#define SAA7113_STATUS_HLVLN(d) (d & 0x40)
+#define SAA7113_STATUS_INTL(d) (d & 0x80)
+
+/* Scratch buffer for 2 lines of YUV data */
+#define SCRATCH_BUF_SIZE 3*SPCA50X_MAX_WIDTH
+
+/* Brightness autoadjustment parameters*/
+#define NSTABLE_MAX 4
+#define NUNSTABLE_MAX 600
+#define MIN_BRIGHTNESS 10
+
+/* State machine for each frame in the frame buffer during capture */
+enum {
+	STATE_SCANNING,		/* Scanning for start */
+	STATE_HEADER,		/* Parsing header */
+	STATE_LINES,		/* Parsing lines */
+};
+
+/* Buffer states */
+enum {
+	BUF_NOT_ALLOCATED,
+	BUF_ALLOCATED,
+	BUF_PEND_DEALLOC,	/* spca50x->buf_timer is set */
+};
+
+struct usb_device;
+
+/* One buffer for the USB ISO transfers */
+struct spca50x_sbuf {
+	char       *data;
+	struct urb *urb;
+};
+
+/* States for each frame buffer. */
+enum {
+	FRAME_UNUSED,		/* Unused (no MCAPTURE) */
+	FRAME_READY,		/* Ready to start grabbing */
+	FRAME_GRABBING,		/* In the process of being grabbed into */
+	FRAME_DONE,		/* Finished grabbing, but not been synced yet */
+	FRAME_ERROR,		/* Something bad happened while processing */
+	FRAME_ABORTING,         /* Aborting everything. Caused by hot unplugging.*/
+
+};
+
+struct spca50x_frame {
+	unsigned char *data;		/* Frame buffer */
+	int seq;                /* Frame sequence number */
+
+	int depth;		/* Bytes per pixel */
+	int width;		/* Width application is expecting */
+	int height;		/* Height */
+
+	int hdrwidth;		/* Width the frame actually is */
+	int hdrheight;		/* Height */
+
+	unsigned int format;	/* Format for this frame */
+
+	volatile int grabstate;	/* State of grabbing */
+	int scanstate;		/* State of scanning */
+
+	int curline;		/* Line of frame we're working on */
+	int curpix;
+	int segment;		/* Segment from the incoming data (a segment is two lines of YUV data ) */
+
+	long scanlength;	/* uncompressed, raw data length of frame */
+	long bytes_read;	/* amount of scanlength that has been read from *data */
+
+	wait_queue_head_t wq;	/* Processes waiting */
+
+	int snapshot;		/* True if frame was a snapshot */
+	int last_packet;        /* sequence number for last packet */
+	unsigned char *highwater; /* used for debugging */
+	int mcu;                 /* The MCU currently being processed. */ 
+};
+
+#define SPCA50X_NUMFRAMES	4
+#define SPCA50X_NUMSBUF	2
+
+#define BRIDGE_SPCA505 0
+#define BRIDGE_SPCA506 1
+#define BRIDGE_SPCA501 2
+#define BRIDGE_SPCA508 3
+#define BRIDGE_SPCA504 4
+#define BRIDGE_SPCA500 5
+
+#define SENSOR_SAA7113 0
+#define SENSOR_INTERNAL 1
+
+struct usb_spca50x {
+	struct video_device vdev;
+	struct tq_struct task; /* task structure for scheduling bh */
+	char bh_requested; /* if bottom half processing requested */
+	
+	/* Device structure */
+	struct usb_device *dev;
+	
+	int customid;
+	int desc;
+	int ccd; /* If true, using the CCD otherwise the external input */
+	unsigned char iface;
+	
+	/* Determined by sensor type */
+	int maxwidth;
+	int maxheight;
+	
+	/* What we think the hardware is currently set to */
+	/* Not sure the 50x supports all of these */
+	int brightness;
+	int colour;
+	int contrast;
+	int hue;
+	int whiteness;
+	
+	struct semaphore lock;
+	int user;		/* user count for exclusive use */
+	
+	int streaming;		/* Are we streaming Isochronous? */
+	int grabbing;		/* Are we grabbing? */
+	
+	int compress;		/* Should the next frame be compressed? */
+	
+	char *fbuf;		/* Videodev buffer area */
+	
+	int curframe;		/* Current receiving frame buffer */
+	struct spca50x_frame frame[SPCA50X_NUMFRAMES];
+	
+	int cursbuf;		/* Current receiving sbuf */
+	struct spca50x_sbuf sbuf[SPCA50X_NUMSBUF];
+	
+	/* Scratch space from the Isochronous pipe */
+	unsigned char scratch[SCRATCH_BUF_SIZE];
+	int scratchlen;
+	
+	wait_queue_head_t wq;	/* Processes waiting */
+	
+	int snap_enabled;	/* Snapshot mode enabled */
+	
+	int bridge;		/* Type of bridge (BRIDGE_SPCA505 or BRIDGE_SPCA506) */
+	int sensor;		/* Type of image sensor chip */
+	
+	int packet_size;	/* Frame size per isoc desc */
+	
+				/* proc interface */
+	struct semaphore param_lock;	/* params lock for this camera */
+	struct proc_dir_entry *proc_entry;	/* /proc/spca50x/videoX */
+	struct proc_dir_entry *ctl_proc_entry;	/* /proc/spca50x/controlX */
+#ifdef SPCA50X_ENABLE_RAWPROCENTRY
+	struct proc_dir_entry *raw_proc_entry;  /* /proc/spca50x/rawX */
+	char   *rawBuffer;
+	size_t rawBufferSize;
+	size_t rawBufferMax;
+#endif /* SPCA50X_ENABLE_RAWPROCENTRY */
+
+	/* Temporary jpeg decoder workspace */
+	char   *tmpBuffer;
+
+	/* Framebuffer/sbuf management */
+	int buf_state;
+	struct semaphore buf_lock;
+	struct timer_list buf_timer;
+	struct timer_list frame_timer;
+	
+	int width;
+	int height;
+	int pipe_size; // requested pipe size set according to mode
+	int header_len;
+	int lastFrameRead;
+	/* Statistics variables */
+	int avg_lum; //The average luminance (realized for spca501 only)
+
+	uint i2c_ctrl_reg; // Camera I2C control register
+	uint i2c_base;     // Camera I2C address base
+	char i2c_trigger_on_write; //do trigger bit on write
+	
+	__u8 force_rgb; //Read RGB instead of BGR
+	__u8 min_bpp; //The minimal color depth that may be set
+	__u8 lum_level; //Luminance level for brightness autoadjustment
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	uint nstable; // the stable condition counter
+	uint nunstable; // the unstable position counter
+    
+	__u8 a_red, a_green, a_blue; //initial values of color corrections params.
+	int avg_bg, avg_rg; //The average B-G and R-G for white balancing 
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+};
+
+struct cam_list {
+	int id;
+	const char *description;
+};
+
+struct palette_list {
+	int num;
+	const char *name;
+};
+
+struct mode_list {
+	int width;
+	int height;
+	int color;		/* 0=grayscale, 1=color */
+	u8 pxcnt;		/* pixel counter */
+	u8 lncnt;		/* line counter */
+	u8 pxdv;		/* pixel divisor */
+	u8 lndv;		/* line divisor */
+	u8 m420;
+	u8 common_A;
+	u8 common_L;
+};
+
+#endif /* __KERNEL__ */
+
+/* Additional IOCTL numbers */
+struct spca50x_params
+{
+	__u16 request;
+	__u16 address;
+	__u16 value;
+};
+#endif /* SPCA50X_H */
diff -uN linux-2.4.20/drivers/usb.spca/spcai2c_init.h linux-2.4.20/drivers/usb/spcai2c_init.h
--- linux-2.4.20/drivers/usb.spca/spcai2c_init.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20/drivers/usb/spcai2c_init.h	2003-04-17 01:10:37.000000000 +0200
@@ -0,0 +1,37 @@
+/* 
+ * I2C initialization data
+ *
+ */
+#ifndef SPCA50X_I2C_INIT_H
+#define SPCA50X_I2C_INIT_H
+
+/* I assume that they think all registers are cleared to zero on a 7113 reset so
+ * don't explicity write the zeros. These comments are accurate as Philips documents the 7113.
+ * Data to initialize the SAA7113 (seems to only be used in external mode)
+ * As this data is specific to the SAA7113 it applies to all SPCA50X twinned with a 7113
+ */
+static __u16 spca50x_i2c_data[][2] =
+{
+  { 0x1,0x8 }, /* Increment delay */
+  { 0x2,0xc2 }, /* Analog input control 1 */
+  { 0x3,0x33 }, /* Analog input control 2 */
+  { 0x6,0xD },  /* Horizontal sync start */
+  { 0x7,0xf0 }, /* Horizontal sync end */
+  { 0x8,0x98 }, /* Sync control */
+  { 0x9,0x1 }, /* Luminance control */
+  { 0xa,0x80 }, /* Luminance brightness */
+  { 0xb,0x60 }, /* Luminance contrast */
+  { 0xc,0x40 }, /* Chrominance saturation */
+  { 0xe,0x1 }, /* Chrominance control */
+  { 0xf,0x2a }, /* Chrominance gain */
+  { 0x10,0x40 }, /* Format/delay control */
+  { 0x11,0xc }, /* Output control 1 */
+  { 0x12,0xb8 }, /* Output control 2 */
+  { 0x59,0x54 }, /* Horizontal offset for slicer */
+  { 0x5a,0x7 }, /* Vertical offset for slicer */
+  { 0x5b,0x83 }, /* field offset and MSB of h/v slicer offsets */
+  { 0,0}
+};
+
+#endif /* SPCA50X_I2C_INIT_H */
+//eof
Les sous-répertoires linux-2.4.20/drivers/usb.spca/storage et linux-2.4.20/drivers/usb/storage sont identiques.
