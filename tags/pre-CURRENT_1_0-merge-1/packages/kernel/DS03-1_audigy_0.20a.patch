diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/ac97_codec.c patched/drivers/sound/audigy/ac97_codec.c
--- old/drivers/sound/audigy/ac97_codec.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/ac97_codec.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,1233 @@
+
+/*
+ * ac97_codec.c: Generic AC97 mixer/modem module
+ *
+ * Derived from ac97 mixer in maestro and trident driver.
+ *
+ * Copyright 2000 Silicon Integrated System Corporation
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ **************************************************************************
+ *
+ * The Intel Audio Codec '97 specification is available at the Intel
+ * audio homepage: http://developer.intel.com/ial/scalableplatforms/audio/
+ *
+ * The specification itself is currently available at:
+ * ftp://download.intel.com/ial/scalableplatforms/ac97r22.pdf
+ *
+ **************************************************************************
+ *
+ * History
+ * Mar 28, 2002 Randolph Bentson <bentson@holmsjoen.com>
+ *	corrections to support WM9707 in ViewPad 1000
+ * v0.4 Mar 15 2000 Ollie Lho
+ *	dual codecs support verified with 4 channels output
+ * v0.3 Feb 22 2000 Ollie Lho
+ *	bug fix for record mask setting
+ * v0.2 Feb 10 2000 Ollie Lho
+ *	add ac97_read_proc for /proc/driver/{vendor}/ac97
+ * v0.1 Jan 14 2000 Ollie Lho <ollie@sis.com.tw> 
+ *	Isolated from trident.c to support multiple ac97 codec
+ */
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include "ac97_codec.h"
+#include <asm/uaccess.h>
+
+#include "emu_wrapper.h"
+
+#define CODEC_ID_BUFSZ 14
+
+static int ac97_read_mixer(struct ac97_codec *codec, int oss_channel);
+static void ac97_write_mixer(struct ac97_codec *codec, int oss_channel, 
+			     unsigned int left, unsigned int right);
+static void ac97_set_mixer(struct ac97_codec *codec, unsigned int oss_mixer, unsigned int val );
+static int ac97_recmask_io(struct ac97_codec *codec, int rw, int mask);
+static int ac97_mixer_ioctl(struct ac97_codec *codec, unsigned int cmd, unsigned long arg);
+
+static int ac97_init_mixer(struct ac97_codec *codec);
+
+static int wolfson_init00(struct ac97_codec * codec);
+static int wolfson_init03(struct ac97_codec * codec);
+static int wolfson_init04(struct ac97_codec * codec);
+static int tritech_init(struct ac97_codec * codec);
+static int tritech_maestro_init(struct ac97_codec * codec);
+static int sigmatel_9708_init(struct ac97_codec *codec);
+static int sigmatel_9721_init(struct ac97_codec *codec);
+static int sigmatel_9744_init(struct ac97_codec *codec);
+static int ad1886_init(struct ac97_codec *codec);
+static int eapd_control(struct ac97_codec *codec, int);
+static int crystal_digital_control(struct ac97_codec *codec, int mode);
+static int cmedia_init(struct ac97_codec * codec);
+static int cmedia_digital_control(struct ac97_codec *codec, int mode);
+
+
+/*
+ *	AC97 operations.
+ *
+ *	If you are adding a codec then you should be able to use
+ *		eapd_ops - any codec that supports EAPD amp control (most)
+ *		null_ops - any ancient codec that supports nothing
+ *
+ *	The three functions are
+ *		init - used for non AC97 standard initialisation
+ *		amplifier - used to do amplifier control (1=on 0=off)
+ *		digital - switch to digital modes (0 = analog)
+ *
+ *	Not all codecs support all features, not all drivers use all the
+ *	operations yet
+ */
+ 
+static struct ac97_ops null_ops = { NULL, NULL, NULL };
+static struct ac97_ops default_ops = { NULL, eapd_control, NULL };
+static struct ac97_ops wolfson_ops00 = { wolfson_init00, NULL, NULL };
+static struct ac97_ops wolfson_ops03 = { wolfson_init03, NULL, NULL };
+static struct ac97_ops wolfson_ops04 = { wolfson_init04, NULL, NULL };
+static struct ac97_ops tritech_ops = { tritech_init, NULL, NULL };
+static struct ac97_ops tritech_m_ops = { tritech_maestro_init, NULL, NULL };
+static struct ac97_ops sigmatel_9708_ops = { sigmatel_9708_init, NULL, NULL };
+static struct ac97_ops sigmatel_9721_ops = { sigmatel_9721_init, NULL, NULL };
+static struct ac97_ops sigmatel_9744_ops = { sigmatel_9744_init, NULL, NULL };
+static struct ac97_ops crystal_digital_ops = { NULL, eapd_control, crystal_digital_control };
+static struct ac97_ops ad1886_ops = { ad1886_init, eapd_control, NULL };
+static struct ac97_ops cmedia_ops = { NULL, eapd_control, NULL};
+static struct ac97_ops cmedia_digital_ops = { cmedia_init, eapd_control, cmedia_digital_control};
+
+/* sorted by vendor/device id */
+static const struct {
+	u32 id;
+	char *name;
+	struct ac97_ops *ops;
+	int flags;
+} ac97_codec_ids[] = {
+	{0x41445303, "Analog Devices AD1819",	&null_ops},
+	{0x41445340, "Analog Devices AD1881",	&null_ops},
+	{0x41445348, "Analog Devices AD1881A",	&null_ops},
+	{0x41445360, "Analog Devices AD1885",	&default_ops},
+	{0x41445361, "Analog Devices AD1886",	&ad1886_ops},
+	{0x41445460, "Analog Devices AD1885",	&default_ops},
+	{0x41445461, "Analog Devices AD1886",	&ad1886_ops},
+	{0x414B4D00, "Asahi Kasei AK4540",	&null_ops},
+	{0x414B4D01, "Asahi Kasei AK4542",	&null_ops},
+	{0x414B4D02, "Asahi Kasei AK4543",	&null_ops},
+	{0x414C4710, "ALC200/200P",		&null_ops},
+	{0x414C4720, "ALC650",			&null_ops},
+	{0x434D4941, "CMedia",			&cmedia_ops,		AC97_NO_PCM_VOLUME },
+	{0x434D4942, "CMedia",			&cmedia_ops,		AC97_NO_PCM_VOLUME },
+	{0x434D4961, "CMedia",			&cmedia_digital_ops,	AC97_NO_PCM_VOLUME },
+	{0x43525900, "Cirrus Logic CS4297",	&default_ops},
+	{0x43525903, "Cirrus Logic CS4297",	&default_ops},
+	{0x43525913, "Cirrus Logic CS4297A rev A", &default_ops},
+	{0x43525914, "Cirrus Logic CS4297A rev B", &default_ops},
+	{0x43525923, "Cirrus Logic CS4298",	&null_ops},
+	{0x4352592B, "Cirrus Logic CS4294",	&null_ops},
+	{0x4352592D, "Cirrus Logic CS4294",	&null_ops},
+	{0x43525931, "Cirrus Logic CS4299 rev A", &crystal_digital_ops},
+	{0x43525933, "Cirrus Logic CS4299 rev C", &crystal_digital_ops},
+	{0x43525934, "Cirrus Logic CS4299 rev D", &crystal_digital_ops},
+	{0x43585442, "CXT66",			&default_ops,		AC97_DELUDED_MODEM },
+	{0x44543031, "Diamond Technology DT0893", &default_ops},
+	{0x45838308, "ESS Allegro ES1988",	&null_ops},
+	{0x49434511, "ICE1232",			&null_ops}, /* I hope --jk */
+	{0x4e534331, "National Semiconductor LM4549", &null_ops},
+	{0x53494c22, "Silicon Laboratory Si3036", &null_ops},
+	{0x53494c23, "Silicon Laboratory Si3038", &null_ops},
+	{0x545200FF, "TriTech TR?????",		&tritech_m_ops},
+	{0x54524102, "TriTech TR28022",		&null_ops},
+	{0x54524103, "TriTech TR28023",		&null_ops},
+	{0x54524106, "TriTech TR28026",		&null_ops},
+	{0x54524108, "TriTech TR28028",		&tritech_ops},
+	{0x54524123, "TriTech TR A5",		&null_ops},
+	{0x574D4C00, "Wolfson WM9700A",		&wolfson_ops00},
+	{0x574D4C03, "Wolfson WM9703/WM9707",	&wolfson_ops03},
+	{0x574D4C04, "Wolfson WM9704M/WM9704Q",	&wolfson_ops04},
+	{0x83847600, "SigmaTel STAC????",	&null_ops},
+	{0x83847604, "SigmaTel STAC9701/3/4/5", &null_ops},
+	{0x83847605, "SigmaTel STAC9704",	&null_ops},
+	{0x83847608, "SigmaTel STAC9708",	&sigmatel_9708_ops},
+	{0x83847609, "SigmaTel STAC9721/23",	&sigmatel_9721_ops},
+	{0x83847644, "SigmaTel STAC9744/45",	&sigmatel_9744_ops},
+	{0x83847656, "SigmaTel STAC9756/57",	&sigmatel_9744_ops},
+	{0x83847666, "SigmaTel STAC9750T",	&sigmatel_9744_ops},
+	{0x83847684, "SigmaTel STAC9783/84?",	&null_ops},
+	{0x57454301, "Winbond 83971D",		&null_ops},
+};
+
+static const char *ac97_stereo_enhancements[] =
+{
+	/*   0 */ "No 3D Stereo Enhancement",
+	/*   1 */ "Analog Devices Phat Stereo",
+	/*   2 */ "Creative Stereo Enhancement",
+	/*   3 */ "National Semi 3D Stereo Enhancement",
+	/*   4 */ "YAMAHA Ymersion",
+	/*   5 */ "BBE 3D Stereo Enhancement",
+	/*   6 */ "Crystal Semi 3D Stereo Enhancement",
+	/*   7 */ "Qsound QXpander",
+	/*   8 */ "Spatializer 3D Stereo Enhancement",
+	/*   9 */ "SRS 3D Stereo Enhancement",
+	/*  10 */ "Platform Tech 3D Stereo Enhancement",
+	/*  11 */ "AKM 3D Audio",
+	/*  12 */ "Aureal Stereo Enhancement",
+	/*  13 */ "Aztech 3D Enhancement",
+	/*  14 */ "Binaura 3D Audio Enhancement",
+	/*  15 */ "ESS Technology Stereo Enhancement",
+	/*  16 */ "Harman International VMAx",
+	/*  17 */ "Nvidea 3D Stereo Enhancement",
+	/*  18 */ "Philips Incredible Sound",
+	/*  19 */ "Texas Instruments 3D Stereo Enhancement",
+	/*  20 */ "VLSI Technology 3D Stereo Enhancement",
+	/*  21 */ "TriTech 3D Stereo Enhancement",
+	/*  22 */ "Realtek 3D Stereo Enhancement",
+	/*  23 */ "Samsung 3D Stereo Enhancement",
+	/*  24 */ "Wolfson Microelectronics 3D Enhancement",
+	/*  25 */ "Delta Integration 3D Enhancement",
+	/*  26 */ "SigmaTel 3D Enhancement",
+	/*  27 */ "Winbond 3D Stereo Enhancement",
+	/*  28 */ "Rockwell 3D Stereo Enhancement",
+	/*  29 */ "Reserved 29",
+	/*  30 */ "Reserved 30",
+	/*  31 */ "Reserved 31"
+};
+
+/* this table has default mixer values for all OSS mixers. */
+static struct mixer_defaults {
+	int mixer;
+	unsigned int value;
+} mixer_defaults[SOUND_MIXER_NRDEVICES] = {
+	/* all values 0 -> 100 in bytes */
+	{SOUND_MIXER_VOLUME,	0x4343},
+	{SOUND_MIXER_BASS,	0x4343},
+	{SOUND_MIXER_TREBLE,	0x4343},
+	{SOUND_MIXER_PCM,	0x4343},
+	{SOUND_MIXER_SPEAKER,	0x4343},
+	{SOUND_MIXER_LINE,	0x4343},
+	{SOUND_MIXER_MIC,	0x0000},
+	{SOUND_MIXER_CD,	0x4343},
+	{SOUND_MIXER_ALTPCM,	0x4343},
+	{SOUND_MIXER_IGAIN,	0x4343},
+	{SOUND_MIXER_LINE1,	0x4343},
+	{SOUND_MIXER_PHONEIN,	0x4343},
+	{SOUND_MIXER_PHONEOUT,	0x4343},
+	{SOUND_MIXER_VIDEO,	0x4343},
+	{SOUND_MIXER_IMIX,	0x4343},
+	{-1,0}
+};
+
+/* table to scale scale from OSS mixer value to AC97 mixer register value */	
+static struct ac97_mixer_hw {
+	unsigned char offset;
+	int scale;
+} ac97_hw[SOUND_MIXER_NRDEVICES]= {
+	[SOUND_MIXER_VOLUME]	=	{AC97_MASTER_VOL_STEREO,64},
+	[SOUND_MIXER_BASS]	=	{AC97_MASTER_TONE,	16},
+	[SOUND_MIXER_TREBLE]	=	{AC97_MASTER_TONE,	16},
+	[SOUND_MIXER_PCM]	=	{AC97_PCMOUT_VOL,	32},
+	[SOUND_MIXER_SPEAKER]	=	{AC97_PCBEEP_VOL,	16},
+	[SOUND_MIXER_LINE]	=	{AC97_LINEIN_VOL,	32},
+	[SOUND_MIXER_MIC]	=	{AC97_MIC_VOL,		32},
+	[SOUND_MIXER_CD]	=	{AC97_CD_VOL,		32},
+	[SOUND_MIXER_ALTPCM]	=	{AC97_HEADPHONE_VOL,	64},
+	[SOUND_MIXER_IGAIN]	=	{AC97_RECORD_GAIN,	16},
+	[SOUND_MIXER_LINE1]	=	{AC97_AUX_VOL,		32},
+	[SOUND_MIXER_PHONEIN]	= 	{AC97_PHONE_VOL,	32},
+	[SOUND_MIXER_PHONEOUT]	= 	{AC97_MASTER_VOL_MONO,	64},
+	[SOUND_MIXER_VIDEO]	=	{AC97_VIDEO_VOL,	32},
+	[SOUND_MIXER_IMIX]	=	{AC97_SURROUND_MASTER,	32},
+};
+
+/* the following tables allow us to go from OSS <-> ac97 quickly. */
+enum ac97_recsettings {
+	AC97_REC_MIC=0,
+	AC97_REC_CD,
+	AC97_REC_VIDEO,
+	AC97_REC_AUX,
+	AC97_REC_LINE,
+	AC97_REC_STEREO, /* combination of all enabled outputs..  */
+	AC97_REC_MONO,	      /*.. or the mono equivalent */
+	AC97_REC_PHONE
+};
+
+static const unsigned int ac97_rm2oss[] = {
+	[AC97_REC_MIC] 	 = SOUND_MIXER_MIC,
+	[AC97_REC_CD] 	 = SOUND_MIXER_CD,
+	[AC97_REC_VIDEO] = SOUND_MIXER_VIDEO,
+	[AC97_REC_AUX] 	 = SOUND_MIXER_LINE1,
+	[AC97_REC_LINE]  = SOUND_MIXER_LINE,
+	[AC97_REC_STEREO]= SOUND_MIXER_IGAIN,
+	[AC97_REC_PHONE] = SOUND_MIXER_PHONEIN
+};
+
+/* indexed by bit position */
+static const unsigned int ac97_oss_rm[] = {
+	[SOUND_MIXER_MIC] 	= AC97_REC_MIC,
+	[SOUND_MIXER_CD] 	= AC97_REC_CD,
+	[SOUND_MIXER_VIDEO] 	= AC97_REC_VIDEO,
+	[SOUND_MIXER_LINE1] 	= AC97_REC_AUX,
+	[SOUND_MIXER_LINE] 	= AC97_REC_LINE,
+	[SOUND_MIXER_IGAIN]	= AC97_REC_STEREO,
+	[SOUND_MIXER_PHONEIN] 	= AC97_REC_PHONE
+};
+
+/* reads the given OSS mixer from the ac97 the caller must have insured that the ac97 knows
+   about that given mixer, and should be holding a spinlock for the card */
+static int ac97_read_mixer(struct ac97_codec *codec, int oss_channel) 
+{
+	u16 val;
+	int ret = 0;
+	int scale;
+	struct ac97_mixer_hw *mh = &ac97_hw[oss_channel];
+
+	val = codec->codec_read(codec , mh->offset);
+
+	if (val & AC97_MUTE) {
+		ret = 0;
+	} else if (AC97_STEREO_MASK & (1 << oss_channel)) {
+		/* nice stereo mixers .. */
+		int left,right;
+
+		left = (val >> 8)  & 0x7f;
+		right = val  & 0x7f;
+
+		if (oss_channel == SOUND_MIXER_IGAIN) {
+			right = (right * 100) / mh->scale;
+			left = (left * 100) / mh->scale;
+		} else {
+			/* these may have 5 or 6 bit resolution */
+			if(oss_channel == SOUND_MIXER_VOLUME || oss_channel == SOUND_MIXER_ALTPCM)
+				scale = (1 << codec->bit_resolution);
+			else
+				scale = mh->scale;
+
+			right = 100 - ((right * 100) / scale);
+			left = 100 - ((left * 100) / scale);
+		}
+		ret = left | (right << 8);
+	} else if (oss_channel == SOUND_MIXER_SPEAKER) {
+		ret = 100 - ((((val & 0x1e)>>1) * 100) / mh->scale);
+	} else if (oss_channel == SOUND_MIXER_PHONEIN) {
+		ret = 100 - (((val & 0x1f) * 100) / mh->scale);
+	} else if (oss_channel == SOUND_MIXER_PHONEOUT) {
+		scale = (1 << codec->bit_resolution);
+		ret = 100 - (((val & 0x1f) * 100) / scale);
+	} else if (oss_channel == SOUND_MIXER_MIC) {
+		ret = 100 - (((val & 0x1f) * 100) / mh->scale);
+		/*  the low bit is optional in the tone sliders and masking
+		    it lets us avoid the 0xf 'bypass'.. */
+	} else if (oss_channel == SOUND_MIXER_BASS) {
+		ret = 100 - ((((val >> 8) & 0xe) * 100) / mh->scale);
+	} else if (oss_channel == SOUND_MIXER_TREBLE) {
+		ret = 100 - (((val & 0xe) * 100) / mh->scale);
+	}
+
+#ifdef DEBUG
+	printk("ac97_codec: read OSS mixer %2d (%s ac97 register 0x%02x), "
+	       "0x%04x -> 0x%04x\n",
+	       oss_channel, codec->id ? "Secondary" : "Primary",
+	       mh->offset, val, ret);
+#endif
+
+	return ret;
+}
+
+/* write the OSS encoded volume to the given OSS encoded mixer, again caller's job to
+   make sure all is well in arg land, call with spinlock held */
+static void ac97_write_mixer(struct ac97_codec *codec, int oss_channel,
+		      unsigned int left, unsigned int right)
+{
+	u16 val = 0;
+	int scale;
+	struct ac97_mixer_hw *mh = &ac97_hw[oss_channel];
+
+#ifdef DEBUG
+	printk("ac97_codec: wrote OSS mixer %2d (%s ac97 register 0x%02x), "
+	       "left vol:%2d, right vol:%2d:",
+	       oss_channel, codec->id ? "Secondary" : "Primary",
+	       mh->offset, left, right);
+#endif
+
+	if (AC97_STEREO_MASK & (1 << oss_channel)) {
+		/* stereo mixers */
+		if (left == 0 && right == 0) {
+			val = AC97_MUTE;
+		} else {
+			if (oss_channel == SOUND_MIXER_IGAIN) {
+				right = (right * mh->scale) / 100;
+				left = (left * mh->scale) / 100;
+				if (right >= mh->scale)
+					right = mh->scale-1;
+				if (left >= mh->scale)
+					left = mh->scale-1;
+			} else {
+				/* these may have 5 or 6 bit resolution */
+				if (oss_channel == SOUND_MIXER_VOLUME ||
+				    oss_channel == SOUND_MIXER_ALTPCM)
+					scale = (1 << codec->bit_resolution);
+				else
+					scale = mh->scale;
+
+				right = ((100 - right) * scale) / 100;
+				left = ((100 - left) * scale) / 100;
+				if (right >= scale)
+					right = scale-1;
+				if (left >= scale)
+					left = scale-1;
+			}
+			val = (left << 8) | right;
+		}
+	} else if (oss_channel == SOUND_MIXER_BASS) {
+		val = codec->codec_read(codec , mh->offset) & ~0x0f00;
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val |= (left << 8) & 0x0e00;
+	} else if (oss_channel == SOUND_MIXER_TREBLE) {
+		val = codec->codec_read(codec , mh->offset) & ~0x000f;
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val |= left & 0x000e;
+	} else if(left == 0) {
+		val = AC97_MUTE;
+	} else if (oss_channel == SOUND_MIXER_SPEAKER) {
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val = left << 1;
+	} else if (oss_channel == SOUND_MIXER_PHONEIN) {
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val = left;
+	} else if (oss_channel == SOUND_MIXER_PHONEOUT) {
+		scale = (1 << codec->bit_resolution);
+		left = ((100 - left) * scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val = left;
+	} else if (oss_channel == SOUND_MIXER_MIC) {
+		val = codec->codec_read(codec , mh->offset) & ~0x801f;
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val |= left;
+		/*  the low bit is optional in the tone sliders and masking
+		    it lets us avoid the 0xf 'bypass'.. */
+	}
+#ifdef DEBUG
+	printk(" 0x%04x", val);
+#endif
+
+	codec->codec_write(codec, mh->offset, val);
+
+#ifdef DEBUG
+	val = codec->codec_read(codec, mh->offset);
+	printk(" -> 0x%04x\n", val);
+#endif
+}
+
+/* a thin wrapper for write_mixer */
+static void ac97_set_mixer(struct ac97_codec *codec, unsigned int oss_mixer, unsigned int val ) 
+{
+	unsigned int left,right;
+
+	/* cleanse input a little */
+	right = ((val >> 8)  & 0xff) ;
+	left = (val  & 0xff) ;
+
+	if (right > 100) right = 100;
+	if (left > 100) left = 100;
+
+	codec->mixer_state[oss_mixer] = (right << 8) | left;
+	codec->write_mixer(codec, oss_mixer, left, right);
+}
+
+/* read or write the recmask, the ac97 can really have left and right recording
+   inputs independantly set, but OSS doesn't seem to want us to express that to
+   the user. the caller guarantees that we have a supported bit set, and they
+   must be holding the card's spinlock */
+static int ac97_recmask_io(struct ac97_codec *codec, int rw, int mask) 
+{
+	unsigned int val;
+
+	if (rw) {
+		/* read it from the card */
+		val = codec->codec_read(codec, AC97_RECORD_SELECT);
+#ifdef DEBUG
+		printk("ac97_codec: ac97 recmask to set to 0x%04x\n", val);
+#endif
+		return (1 << ac97_rm2oss[val & 0x07]);
+	}
+
+	/* else, write the first set in the mask as the
+	   output */	
+	/* clear out current set value first (AC97 supports only 1 input!) */
+	val = (1 << ac97_rm2oss[codec->codec_read(codec, AC97_RECORD_SELECT) & 0x07]);
+	if (mask != val)
+	    mask &= ~val;
+       
+	val = ffs(mask); 
+	val = ac97_oss_rm[val-1];
+	val |= val << 8;  /* set both channels */
+
+#ifdef DEBUG
+	printk("ac97_codec: setting ac97 recmask to 0x%04x\n", val);
+#endif
+
+	codec->codec_write(codec, AC97_RECORD_SELECT, val);
+
+	return 0;
+};
+
+static int ac97_mixer_ioctl(struct ac97_codec *codec, unsigned int cmd, unsigned long arg)
+{
+	int i, val = 0;
+
+	if (cmd == SOUND_MIXER_INFO) {
+		mixer_info info;
+		strncpy(info.id, codec->name, sizeof(info.id));
+		strncpy(info.name, codec->name, sizeof(info.name));
+		info.modify_counter = codec->modcnt;
+		if (copy_to_user((void *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+	if (cmd == SOUND_OLD_MIXER_INFO) {
+		_old_mixer_info info;
+		strncpy(info.id, codec->name, sizeof(info.id));
+		strncpy(info.name, codec->name, sizeof(info.name));
+		if (copy_to_user((void *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+
+	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
+		return -EINVAL;
+
+	if (cmd == OSS_GETVERSION)
+		return put_user(SOUND_VERSION, (int *)arg);
+
+	if (_SIOC_DIR(cmd) == _SIOC_READ) {
+		switch (_IOC_NR(cmd)) {
+		case SOUND_MIXER_RECSRC: /* give them the current record source */
+			if (!codec->recmask_io) {
+				val = 0;
+			} else {
+				val = codec->recmask_io(codec, 1, 0);
+			}
+			break;
+
+		case SOUND_MIXER_DEVMASK: /* give them the supported mixers */
+			val = codec->supported_mixers;
+			break;
+
+		case SOUND_MIXER_RECMASK: /* Arg contains a bit for each supported recording source */
+			val = codec->record_sources;
+			break;
+
+		case SOUND_MIXER_STEREODEVS: /* Mixer channels supporting stereo */
+			val = codec->stereo_mixers;
+			break;
+
+		case SOUND_MIXER_CAPS:
+			val = SOUND_CAP_EXCL_INPUT;
+			break;
+
+		default: /* read a specific mixer */
+			i = _IOC_NR(cmd);
+
+			if (!supported_mixer(codec, i)) 
+				return -EINVAL;
+
+			/* do we ever want to touch the hardware? */
+		        /* val = codec->read_mixer(codec, i); */
+			val = codec->mixer_state[i];
+ 			break;
+		}
+		return put_user(val, (int *)arg);
+	}
+
+	if (_SIOC_DIR(cmd) == (_SIOC_WRITE|_SIOC_READ)) {
+		codec->modcnt++;
+		if (get_user(val, (int *)arg))
+			return -EFAULT;
+
+		switch (_IOC_NR(cmd)) {
+		case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
+			if (!codec->recmask_io) return -EINVAL;
+			if (!val) return 0;
+			if (!(val &= codec->record_sources)) return -EINVAL;
+
+			codec->recmask_io(codec, 0, val);
+
+			return 0;
+		default: /* write a specific mixer */
+			i = _IOC_NR(cmd);
+
+			if (!supported_mixer(codec, i)) 
+				return -EINVAL;
+
+			ac97_set_mixer(codec, i, val);
+
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/* entry point for /proc/driver/controller_vendor/ac97/%d */
+int ac97_read_proc (char *page, char **start, off_t off,
+		    int count, int *eof, void *data)
+{
+	int len = 0, cap, extid, val, id1, id2;
+	struct ac97_codec *codec;
+	int is_ac97_20 = 0;
+
+	if ((codec = data) == NULL)
+		return -ENODEV;
+
+	id1 = codec->codec_read(codec, AC97_VENDOR_ID1);
+	id2 = codec->codec_read(codec, AC97_VENDOR_ID2);
+	len += sprintf (page+len, "Vendor name      : %s\n", codec->name);
+	len += sprintf (page+len, "Vendor id        : %04X %04X\n", id1, id2);
+
+	extid = codec->codec_read(codec, AC97_EXTENDED_ID);
+	extid &= ~((1<<2)|(1<<4)|(1<<5)|(1<<10)|(1<<11)|(1<<12)|(1<<13));
+	len += sprintf (page+len, "AC97 Version     : %s\n",
+			extid ? "2.0 or later" : "1.0");
+	if (extid) is_ac97_20 = 1;
+
+	cap = codec->codec_read(codec, AC97_RESET);
+	len += sprintf (page+len, "Capabilities     :%s%s%s%s%s%s\n",
+			cap & 0x0001 ? " -dedicated MIC PCM IN channel-" : "",
+			cap & 0x0002 ? " -reserved1-" : "",
+			cap & 0x0004 ? " -bass & treble-" : "",
+			cap & 0x0008 ? " -simulated stereo-" : "",
+			cap & 0x0010 ? " -headphone out-" : "",
+			cap & 0x0020 ? " -loudness-" : "");
+	val = cap & 0x00c0;
+	len += sprintf (page+len, "DAC resolutions  :%s%s%s\n",
+			" -16-bit-",
+			val & 0x0040 ? " -18-bit-" : "",
+			val & 0x0080 ? " -20-bit-" : "");
+	val = cap & 0x0300;
+	len += sprintf (page+len, "ADC resolutions  :%s%s%s\n",
+			" -16-bit-",
+			val & 0x0100 ? " -18-bit-" : "",
+			val & 0x0200 ? " -20-bit-" : "");
+	len += sprintf (page+len, "3D enhancement   : %s\n",
+			ac97_stereo_enhancements[(cap >> 10) & 0x1f]);
+
+	val = codec->codec_read(codec, AC97_GENERAL_PURPOSE);
+	len += sprintf (page+len, "POP path         : %s 3D\n"
+			"Sim. stereo      : %s\n"
+			"3D enhancement   : %s\n"
+			"Loudness         : %s\n"
+			"Mono output      : %s\n"
+			"MIC select       : %s\n"
+			"ADC/DAC loopback : %s\n",
+			val & 0x8000 ? "post" : "pre",
+			val & 0x4000 ? "on" : "off",
+			val & 0x2000 ? "on" : "off",
+			val & 0x1000 ? "on" : "off",
+			val & 0x0200 ? "MIC" : "MIX",
+			val & 0x0100 ? "MIC2" : "MIC1",
+			val & 0x0080 ? "on" : "off");
+
+	extid = codec->codec_read(codec, AC97_EXTENDED_ID);
+	cap = extid;
+	len += sprintf (page+len, "Ext Capabilities :%s%s%s%s%s%s%s\n",
+			cap & 0x0001 ? " -var rate PCM audio-" : "",
+			cap & 0x0002 ? " -2x PCM audio out-" : "",
+			cap & 0x0008 ? " -var rate MIC in-" : "",
+			cap & 0x0040 ? " -PCM center DAC-" : "",
+			cap & 0x0080 ? " -PCM surround DAC-" : "",
+			cap & 0x0100 ? " -PCM LFE DAC-" : "",
+			cap & 0x0200 ? " -slot/DAC mappings-" : "");
+	if (is_ac97_20) {
+		len += sprintf (page+len, "Front DAC rate   : %d\n",
+				codec->codec_read(codec, AC97_PCM_FRONT_DAC_RATE));
+	}
+
+	return len;
+}
+
+/**
+ *	codec_id	-  Turn id1/id2 into a PnP string
+ *	@id1: Vendor ID1
+ *	@id2: Vendor ID2
+ *	@buf: CODEC_ID_BUFSZ byte buffer
+ *
+ *	Fills buf with a zero terminated PnP ident string for the id1/id2
+ *	pair. For convenience the return is the passed in buffer pointer.
+ */
+ 
+static char *codec_id(u16 id1, u16 id2, char *buf)
+{
+	if (id1&0x8080) {
+		snprintf(buf, CODEC_ID_BUFSZ, "0x%04x:0x%04x", id1, id2);
+	} else {
+		buf[0] = (id1 >> 8);
+		buf[1] = (id1 & 0xFF);
+		buf[2] = (id2 >> 8);
+		snprintf(buf+3, CODEC_ID_BUFSZ - 3, "%d", id2&0xFF);
+	}
+	return buf;
+}
+ 
+/**
+ *	ac97_check_modem - Check if the Codec is a modem
+ *	@codec: codec to check
+ *
+ *	Return true if the device is an AC97 1.0 or AC97 2.0 modem
+ */
+ 
+static int ac97_check_modem(struct ac97_codec *codec)
+{
+	/* Check for an AC97 1.0 soft modem (ID1) */
+	if(codec->codec_read(codec, AC97_RESET) & 2)
+		return 1;
+	/* Check for an AC97 2.x soft modem */
+	codec->codec_write(codec, AC97_EXTENDED_MODEM_ID, 0L);
+	if(codec->codec_read(codec, AC97_EXTENDED_MODEM_ID) & 1)
+		return 1;
+	return 0;
+}
+
+
+/**
+ *	ac97_probe_codec - Initialize and setup AC97-compatible codec
+ *	@codec: (in/out) Kernel info for a single AC97 codec
+ *
+ *	Reset the AC97 codec, then initialize the mixer and
+ *	the rest of the @codec structure.
+ *
+ *	The codec_read and codec_write fields of @codec are
+ *	required to be setup and working when this function
+ *	is called.  All other fields are set by this function.
+ *
+ *	codec_wait field of @codec can optionally be provided
+ *	when calling this function.  If codec_wait is not %NULL,
+ *	this function will call codec_wait any time it is
+ *	necessary to wait for the audio chip to reach the
+ *	codec-ready state.  If codec_wait is %NULL, then
+ *	the default behavior is to call schedule_timeout.
+ *	Currently codec_wait is used to wait for AC97 codec
+ *	reset to complete. 
+ *
+ *	Returns 1 (true) on success, or 0 (false) on failure.
+ */
+ 
+int ac97_probe_codec(struct ac97_codec *codec)
+{
+	u16 id1, id2;
+	u16 audio;
+	int i;
+	char cidbuf[CODEC_ID_BUFSZ];
+
+	/* probing AC97 codec, AC97 2.0 says that bit 15 of register 0x00 (reset) should 
+	 * be read zero.
+	 *
+	 * FIXME: is the following comment outdated?  -jgarzik 
+	 * Probing of AC97 in this way is not reliable, it is not even SAFE !!
+	 */
+	codec->codec_write(codec, AC97_RESET, 0L);
+
+	/* also according to spec, we wait for codec-ready state */	
+	if (codec->codec_wait)
+		codec->codec_wait(codec);
+	else
+		udelay(10);
+
+	if ((audio = codec->codec_read(codec, AC97_RESET)) & 0x8000) {
+		printk(KERN_ERR "ac97_codec: %s ac97 codec not present\n",
+		       (codec->id & 0x2) ? (codec->id&1 ? "4th" : "Tertiary") 
+		       : (codec->id&1 ? "Secondary":  "Primary"));
+		return 0;
+	}
+
+	/* probe for Modem Codec */
+	codec->modem = ac97_check_modem(codec);
+	codec->name = NULL;
+	codec->codec_ops = &null_ops;
+
+	id1 = codec->codec_read(codec, AC97_VENDOR_ID1);
+	id2 = codec->codec_read(codec, AC97_VENDOR_ID2);
+	for (i = 0; i < ARRAY_SIZE(ac97_codec_ids); i++) {
+		if (ac97_codec_ids[i].id == ((id1 << 16) | id2)) {
+			codec->type = ac97_codec_ids[i].id;
+			codec->name = ac97_codec_ids[i].name;
+			codec->codec_ops = ac97_codec_ids[i].ops;
+			codec->flags = ac97_codec_ids[i].flags;
+			break;
+		}
+	}
+	
+	/* A device which thinks its a modem but isnt */
+	if(codec->flags & AC97_DELUDED_MODEM)
+		codec->modem = 0;
+		
+	if (codec->name == NULL)
+		codec->name = "Unknown";
+	printk(KERN_INFO "ac97_codec: AC97 %s codec, id: %s (%s)\n", 
+		codec->modem ? "Modem" : (audio ? "Audio" : ""),
+	       codec_id(id1, id2, cidbuf), codec->name);
+
+	return ac97_init_mixer(codec);
+}
+
+static int ac97_init_mixer(struct ac97_codec *codec)
+{
+	u16 cap;
+	int i;
+
+	cap = codec->codec_read(codec, AC97_RESET);
+
+	/* mixer masks */
+	codec->supported_mixers = AC97_SUPPORTED_MASK;
+	codec->stereo_mixers = AC97_STEREO_MASK;
+	codec->record_sources = AC97_RECORD_MASK;
+	if (!(cap & 0x04))
+		codec->supported_mixers &= ~(SOUND_MASK_BASS|SOUND_MASK_TREBLE);
+	if (!(cap & 0x10))
+		codec->supported_mixers &= ~SOUND_MASK_ALTPCM;
+
+	if(codec->flags & AC97_NO_PCM_VOLUME)
+		codec->supported_mixers &= ~SOUND_MASK_PCM;
+
+	/* detect bit resolution */
+	codec->codec_write(codec, AC97_MASTER_VOL_STEREO, 0x2020);
+	if(codec->codec_read(codec, AC97_MASTER_VOL_STEREO) == 0x2020)
+		codec->bit_resolution = 6;
+	else
+		codec->bit_resolution = 5;
+
+	/* generic OSS to AC97 wrapper */
+	codec->read_mixer = ac97_read_mixer;
+	codec->write_mixer = ac97_write_mixer;
+	codec->recmask_io = ac97_recmask_io;
+	codec->mixer_ioctl = ac97_mixer_ioctl;
+
+	/* codec specific initialization for 4-6 channel output or secondary codec stuff */
+	if (codec->codec_ops->init != NULL) {
+		codec->codec_ops->init(codec);
+	}
+
+	/* initialize mixer channel volumes */
+	for (i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
+		struct mixer_defaults *md = &mixer_defaults[i];
+		if (md->mixer == -1) 
+			break;
+		if (!supported_mixer(codec, md->mixer)) 
+			continue;
+		ac97_set_mixer(codec, md->mixer, md->value);
+	}
+
+	if(codec->flags & AC97_NO_PCM_VOLUME)
+		printk(KERN_WARNING "AC97 codec does not have proper volume support.\n");
+	return 1;
+}
+
+#define AC97_SIGMATEL_ANALOG    0x6c	/* Analog Special */
+#define AC97_SIGMATEL_DAC2INVERT 0x6e
+#define AC97_SIGMATEL_BIAS1     0x70
+#define AC97_SIGMATEL_BIAS2     0x72
+#define AC97_SIGMATEL_MULTICHN  0x74	/* Multi-Channel programming */
+#define AC97_SIGMATEL_CIC1      0x76
+#define AC97_SIGMATEL_CIC2      0x78
+
+
+static int sigmatel_9708_init(struct ac97_codec * codec)
+{
+	u16 codec72, codec6c;
+
+	codec72 = codec->codec_read(codec, AC97_SIGMATEL_BIAS2) & 0x8000;
+	codec6c = codec->codec_read(codec, AC97_SIGMATEL_ANALOG);
+
+	if ((codec72==0) && (codec6c==0)) {
+		codec->codec_write(codec, AC97_SIGMATEL_CIC1, 0xabba);
+		codec->codec_write(codec, AC97_SIGMATEL_CIC2, 0x1000);
+		codec->codec_write(codec, AC97_SIGMATEL_BIAS1, 0xabba);
+		codec->codec_write(codec, AC97_SIGMATEL_BIAS2, 0x0007);
+	} else if ((codec72==0x8000) && (codec6c==0)) {
+		codec->codec_write(codec, AC97_SIGMATEL_CIC1, 0xabba);
+		codec->codec_write(codec, AC97_SIGMATEL_CIC2, 0x1001);
+		codec->codec_write(codec, AC97_SIGMATEL_DAC2INVERT, 0x0008);
+	} else if ((codec72==0x8000) && (codec6c==0x0080)) {
+		/* nothing */
+	}
+	codec->codec_write(codec, AC97_SIGMATEL_MULTICHN, 0x0000);
+	return 0;
+}
+
+
+static int sigmatel_9721_init(struct ac97_codec * codec)
+{
+	/* Only set up secondary codec */
+	if (codec->id == 0)
+		return 0;
+
+	codec->codec_write(codec, AC97_SURROUND_MASTER, 0L);
+
+	/* initialize SigmaTel STAC9721/23 as secondary codec, decoding AC link
+	   sloc 3,4 = 0x01, slot 7,8 = 0x00, */
+	codec->codec_write(codec, AC97_SIGMATEL_MULTICHN, 0x00);
+
+	/* we don't have the crystal when we are on an AMR card, so use
+	   BIT_CLK as our clock source. Write the magic word ABBA and read
+	   back to enable register 0x78 */
+	codec->codec_write(codec, AC97_SIGMATEL_CIC1, 0xabba);
+	codec->codec_read(codec, AC97_SIGMATEL_CIC1);
+
+	/* sync all the clocks*/
+	codec->codec_write(codec, AC97_SIGMATEL_CIC2, 0x3802);
+
+	return 0;
+}
+
+
+static int sigmatel_9744_init(struct ac97_codec * codec)
+{
+	// patch for SigmaTel
+	codec->codec_write(codec, AC97_SIGMATEL_CIC1, 0xabba);
+	codec->codec_write(codec, AC97_SIGMATEL_CIC2, 0x0000); // is this correct? --jk
+	codec->codec_write(codec, AC97_SIGMATEL_BIAS1, 0xabba);
+	codec->codec_write(codec, AC97_SIGMATEL_BIAS2, 0x0002);
+	codec->codec_write(codec, AC97_SIGMATEL_MULTICHN, 0x0000);
+	return 0;
+}
+
+static int cmedia_init(struct ac97_codec *codec)
+{
+	/* Initialise the CMedia 9739 */
+	/*
+		We could set various options here
+		Register 0x20 bit 0x100 sets mic as center bass
+		Also do multi_channel_ctrl &=~0x3000 |=0x1000
+		
+		For now we set up the GPIO and PC beep 
+	*/
+	
+	u16 v;
+	
+	/* MIC */
+	codec->codec_write(codec, 0x64, 0x3000);
+	v = codec->codec_read(codec, 0x64);
+	v &= ~0x8000;
+	codec->codec_write(codec, 0x64, v);
+	codec->codec_write(codec, 0x70, 0x0100);
+	codec->codec_write(codec, 0x72, 0x0020);
+	return 0;
+}
+	
+static int wolfson_init00(struct ac97_codec * codec)
+{
+	/* This initialization is suspect, but not known to be wrong.
+	   It was copied from the initialization for the WM9704Q, but
+	   that same sequence is known to fail for the WM9707.  Thus
+	   this warning may help someone with hardware to test
+	   this code. */
+	codec->codec_write(codec, 0x72, 0x0808);
+	codec->codec_write(codec, 0x74, 0x0808);
+
+	// patch for DVD noise
+	codec->codec_write(codec, 0x5a, 0x0200);
+
+	// init vol as PCM vol
+	codec->codec_write(codec, 0x70,
+		codec->codec_read(codec, AC97_PCMOUT_VOL));
+
+	codec->codec_write(codec, AC97_SURROUND_MASTER, 0x0000);
+	return 0;
+}
+
+
+static int wolfson_init03(struct ac97_codec * codec)
+{
+	/* this is known to work for the ViewSonic ViewPad 1000 */
+	codec->codec_write(codec, 0x72, 0x0808);
+	codec->codec_write(codec, 0x20, 0x8000);
+	return 0;
+}
+
+
+static int wolfson_init04(struct ac97_codec * codec)
+{
+	codec->codec_write(codec, 0x72, 0x0808);
+	codec->codec_write(codec, 0x74, 0x0808);
+
+	// patch for DVD noise
+	codec->codec_write(codec, 0x5a, 0x0200);
+
+	// init vol as PCM vol
+	codec->codec_write(codec, 0x70,
+		codec->codec_read(codec, AC97_PCMOUT_VOL));
+
+	codec->codec_write(codec, AC97_SURROUND_MASTER, 0x0000);
+	return 0;
+}
+
+
+static int tritech_init(struct ac97_codec * codec)
+{
+	codec->codec_write(codec, 0x26, 0x0300);
+	codec->codec_write(codec, 0x26, 0x0000);
+	codec->codec_write(codec, AC97_SURROUND_MASTER, 0x0000);
+	codec->codec_write(codec, AC97_RESERVED_3A, 0x0000);
+	return 0;
+}
+
+
+/* copied from drivers/sound/maestro.c */
+static int tritech_maestro_init(struct ac97_codec * codec)
+{
+	/* no idea what this does */
+	codec->codec_write(codec, 0x2A, 0x0001);
+	codec->codec_write(codec, 0x2C, 0x0000);
+	codec->codec_write(codec, 0x2C, 0XFFFF);
+	return 0;
+}
+
+
+
+/* 
+ *	Presario700 workaround 
+ * 	for Jack Sense/SPDIF Register mis-setting causing
+ *	no audible output
+ *	by Santiago Nullo 04/05/2002
+ */
+
+#define AC97_AD1886_JACK_SENSE 0x72
+
+static int ad1886_init(struct ac97_codec * codec)
+{
+	/* from AD1886 Specs */
+	codec->codec_write(codec, AC97_AD1886_JACK_SENSE, 0x0010);
+	return 0;
+}
+
+
+
+
+/*
+ *	This is basically standard AC97. It should work as a default for
+ *	almost all modern codecs. Note that some cards wire EAPD *backwards*
+ *	That side of it is up to the card driver not us to cope with.
+ *
+ */
+
+static int eapd_control(struct ac97_codec * codec, int on)
+{
+	if(on)
+		codec->codec_write(codec, AC97_POWER_CONTROL,
+			codec->codec_read(codec, AC97_POWER_CONTROL)|0x8000);
+	else
+		codec->codec_write(codec, AC97_POWER_CONTROL,
+			codec->codec_read(codec, AC97_POWER_CONTROL)&~0x8000);
+	return 0;
+}
+
+/*
+ *	Crystal digital audio control (CS4299
+ */
+ 
+static int crystal_digital_control(struct ac97_codec *codec, int mode)
+{
+	u16 cv;
+
+	switch(mode)
+	{
+		case 0: cv = 0x0; break;	/* SPEN off */
+		case 1: cv = 0x8004; break;	/* 48KHz digital */
+		case 2: cv = 0x8104; break;	/* 44.1KHz digital */
+		default:
+			return -1;		/* Not supported yet(eg AC3) */
+	}
+	codec->codec_write(codec, 0x68, cv);
+	return 0;
+}
+
+/*
+ *	CMedia digital audio control
+ *	Needs more work.
+ */
+ 
+static int cmedia_digital_control(struct ac97_codec *codec, int mode)
+{
+	u16 cv;
+
+	switch(mode)
+	{
+		case 0: cv = 0x0001; break;	/* SPEN off */
+		case 1: cv = 0x0009; break;	/* 48KHz digital */
+		default:
+			return -1;		/* Not supported yet(eg AC3) */
+	}
+	codec->codec_write(codec, 0x2A, 0x05c4);
+	codec->codec_write(codec, 0x6C, cv);
+	
+	/* Switch on mix to surround */
+	cv = codec->codec_read(codec, 0x64);
+	cv &= ~0x0200;
+	if(mode)
+		cv |= 0x0200;
+	codec->codec_write(codec, 0x64, cv);
+	return 0;
+}
+
+
+/* copied from drivers/sound/maestro.c */
+#if 0  /* there has been 1 person on the planet with a pt101 that we
+        know of.  If they care, they can put this back in :) */
+static int pt101_init(struct ac97_codec * codec)
+{
+	printk(KERN_INFO "ac97_codec: PT101 Codec detected, initializing but _not_ installing mixer device.\n");
+	/* who knows.. */
+	codec->codec_write(codec, 0x2A, 0x0001);
+	codec->codec_write(codec, 0x2C, 0x0000);
+	codec->codec_write(codec, 0x2C, 0xFFFF);
+	codec->codec_write(codec, 0x10, 0x9F1F);
+	codec->codec_write(codec, 0x12, 0x0808);
+	codec->codec_write(codec, 0x14, 0x9F1F);
+	codec->codec_write(codec, 0x16, 0x9F1F);
+	codec->codec_write(codec, 0x18, 0x0404);
+	codec->codec_write(codec, 0x1A, 0x0000);
+	codec->codec_write(codec, 0x1C, 0x0000);
+	codec->codec_write(codec, 0x02, 0x0404);
+	codec->codec_write(codec, 0x04, 0x0808);
+	codec->codec_write(codec, 0x0C, 0x801F);
+	codec->codec_write(codec, 0x0E, 0x801F);
+	return 0;
+}
+#endif
+	
+
+EXPORT_SYMBOL(ac97_read_proc);
+EXPORT_SYMBOL(ac97_probe_codec);
+
+/*
+ *	AC97 library support routines
+ */	
+ 
+/**
+ *	ac97_set_dac_rate	-	set codec rate adaption
+ *	@codec: ac97 code
+ *	@rate: rate in hertz
+ *
+ *	Set the DAC rate. Assumes the codec supports VRA. The caller is
+ *	expected to have checked this little detail.
+ */
+ 
+unsigned int ac97_set_dac_rate(struct ac97_codec *codec, unsigned int rate)
+{
+	unsigned int new_rate = rate;
+	u32 dacp;
+	u32 mast_vol, phone_vol, mono_vol, pcm_vol;
+	u32 mute_vol = 0x8000;	/* The mute volume? */
+
+	if(rate != codec->codec_read(codec, AC97_PCM_FRONT_DAC_RATE))
+	{
+		/* Mute several registers */
+		mast_vol = codec->codec_read(codec, AC97_MASTER_VOL_STEREO);
+		mono_vol = codec->codec_read(codec, AC97_MASTER_VOL_MONO);
+		phone_vol = codec->codec_read(codec, AC97_HEADPHONE_VOL);
+		pcm_vol = codec->codec_read(codec, AC97_PCMOUT_VOL);
+		codec->codec_write(codec, AC97_MASTER_VOL_STEREO, mute_vol);
+		codec->codec_write(codec, AC97_MASTER_VOL_MONO, mute_vol);
+		codec->codec_write(codec, AC97_HEADPHONE_VOL, mute_vol);
+		codec->codec_write(codec, AC97_PCMOUT_VOL, mute_vol);
+		
+		/* Power down the DAC */
+		dacp=codec->codec_read(codec, AC97_POWER_CONTROL);
+		codec->codec_write(codec, AC97_POWER_CONTROL, dacp|0x0200);
+		/* Load the rate and read the effective rate */
+		codec->codec_write(codec, AC97_PCM_FRONT_DAC_RATE, rate);
+		new_rate=codec->codec_read(codec, AC97_PCM_FRONT_DAC_RATE);
+		/* Power it back up */
+		codec->codec_write(codec, AC97_POWER_CONTROL, dacp);
+
+		/* Restore volumes */
+		codec->codec_write(codec, AC97_MASTER_VOL_STEREO, mast_vol);
+		codec->codec_write(codec, AC97_MASTER_VOL_MONO, mono_vol);
+		codec->codec_write(codec, AC97_HEADPHONE_VOL, phone_vol);
+		codec->codec_write(codec, AC97_PCMOUT_VOL, pcm_vol);
+	}
+	return new_rate;
+}
+
+EXPORT_SYMBOL(ac97_set_dac_rate);
+
+/**
+ *	ac97_set_adc_rate	-	set codec rate adaption
+ *	@codec: ac97 code
+ *	@rate: rate in hertz
+ *
+ *	Set the ADC rate. Assumes the codec supports VRA. The caller is
+ *	expected to have checked this little detail.
+ */
+
+unsigned int ac97_set_adc_rate(struct ac97_codec *codec, unsigned int rate)
+{
+	unsigned int new_rate = rate;
+	u32 dacp;
+
+	if(rate != codec->codec_read(codec, AC97_PCM_LR_ADC_RATE))
+	{
+		/* Power down the ADC */
+		dacp=codec->codec_read(codec, AC97_POWER_CONTROL);
+		codec->codec_write(codec, AC97_POWER_CONTROL, dacp|0x0100);
+		/* Load the rate and read the effective rate */
+		codec->codec_write(codec, AC97_PCM_LR_ADC_RATE, rate);
+		new_rate=codec->codec_read(codec, AC97_PCM_LR_ADC_RATE);
+		/* Power it back up */
+		codec->codec_write(codec, AC97_POWER_CONTROL, dacp);
+	}
+	return new_rate;
+}
+
+EXPORT_SYMBOL(ac97_set_adc_rate);
+
+int ac97_save_state(struct ac97_codec *codec)
+{
+	return 0;	
+}
+
+EXPORT_SYMBOL(ac97_save_state);
+
+int ac97_restore_state(struct ac97_codec *codec)
+{
+	int i;
+	unsigned int left, right, val;
+
+	for (i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
+		if (!supported_mixer(codec, i)) 
+			continue;
+
+		val = codec->mixer_state[i];
+		right = val >> 8;
+		left = val  & 0xff;
+		codec->write_mixer(codec, i, left, right);
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(ac97_restore_state);
+
+MODULE_LICENSE("GPL");
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/ac97_codec.h patched/drivers/sound/audigy/ac97_codec.h
--- old/drivers/sound/audigy/ac97_codec.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/ac97_codec.h	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,285 @@
+#ifndef _AC97_CODEC_H_
+#define _AC97_CODEC_H_
+
+#include <linux/types.h>
+#include <linux/soundcard.h>
+
+/* AC97 1.0 */
+#define  AC97_RESET               0x0000      //
+#define  AC97_MASTER_VOL_STEREO   0x0002      // Line Out
+#define  AC97_HEADPHONE_VOL       0x0004      // 
+#define  AC97_MASTER_VOL_MONO     0x0006      // TAD Output
+#define  AC97_MASTER_TONE         0x0008      //
+#define  AC97_PCBEEP_VOL          0x000a      // none
+#define  AC97_PHONE_VOL           0x000c      // TAD Input (mono)
+#define  AC97_MIC_VOL             0x000e      // MIC Input (mono)
+#define  AC97_LINEIN_VOL          0x0010      // Line Input (stereo)
+#define  AC97_CD_VOL              0x0012      // CD Input (stereo)
+#define  AC97_VIDEO_VOL           0x0014      // none
+#define  AC97_AUX_VOL             0x0016      // Aux Input (stereo)
+#define  AC97_PCMOUT_VOL          0x0018      // Wave Output (stereo)
+#define  AC97_RECORD_SELECT       0x001a      //
+#define  AC97_RECORD_GAIN         0x001c
+#define  AC97_RECORD_GAIN_MIC     0x001e
+#define  AC97_GENERAL_PURPOSE     0x0020
+#define  AC97_3D_CONTROL          0x0022
+#define  AC97_MODEM_RATE          0x0024
+#define  AC97_POWER_CONTROL       0x0026
+
+/* AC'97 2.0 */
+#define AC97_EXTENDED_ID          0x0028       /* Extended Audio ID */
+#define AC97_EXTENDED_STATUS      0x002A       /* Extended Audio Status */
+#define AC97_PCM_FRONT_DAC_RATE   0x002C       /* PCM Front DAC Rate */
+#define AC97_PCM_SURR_DAC_RATE    0x002E       /* PCM Surround DAC Rate */
+#define AC97_PCM_LFE_DAC_RATE     0x0030       /* PCM LFE DAC Rate */
+#define AC97_PCM_LR_ADC_RATE      0x0032       /* PCM LR ADC Rate */
+#define AC97_PCM_MIC_ADC_RATE     0x0034       /* PCM MIC ADC Rate */
+#define AC97_CENTER_LFE_MASTER    0x0036       /* Center + LFE Master Volume */
+#define AC97_SURROUND_MASTER      0x0038       /* Surround (Rear) Master Volume */
+#define AC97_RESERVED_3A          0x003A       /* Reserved in AC '97 < 2.2 */
+
+/* AC'97 2.2 */
+#define AC97_SPDIF_CONTROL        0x003A       /* S/PDIF Control */
+
+/* range 0x3c-0x58 - MODEM */
+#define AC97_EXTENDED_MODEM_ID    0x003C
+#define AC97_EXTEND_MODEM_STAT    0x003E
+#define AC97_LINE1_RATE           0x0040
+#define AC97_LINE2_RATE           0x0042
+#define AC97_HANDSET_RATE         0x0044
+#define AC97_LINE1_LEVEL          0x0046
+#define AC97_LINE2_LEVEL          0x0048
+#define AC97_HANDSET_LEVEL        0x004A
+#define AC97_GPIO_CONFIG          0x004C
+#define AC97_GPIO_POLARITY        0x004E
+#define AC97_GPIO_STICKY          0x0050
+#define AC97_GPIO_WAKE_UP         0x0052
+#define AC97_GPIO_STATUS          0x0054
+#define AC97_MISC_MODEM_STAT      0x0056
+#define AC97_RESERVED_58          0x0058
+
+/* registers 0x005a - 0x007a are vendor reserved */
+
+#define AC97_VENDOR_ID1           0x007c
+#define AC97_VENDOR_ID2           0x007e
+
+/* volume control bit defines */
+#define AC97_MUTE                 0x8000
+#define AC97_MICBOOST             0x0040
+#define AC97_LEFTVOL              0x3f00
+#define AC97_RIGHTVOL             0x003f
+
+/* record mux defines */
+#define AC97_RECMUX_MIC           0x0000
+#define AC97_RECMUX_CD            0x0101
+#define AC97_RECMUX_VIDEO         0x0202
+#define AC97_RECMUX_AUX           0x0303
+#define AC97_RECMUX_LINE          0x0404
+#define AC97_RECMUX_STEREO_MIX    0x0505
+#define AC97_RECMUX_MONO_MIX      0x0606
+#define AC97_RECMUX_PHONE         0x0707
+
+/* general purpose register bit defines */
+#define AC97_GP_LPBK              0x0080       /* Loopback mode */
+#define AC97_GP_MS                0x0100       /* Mic Select 0=Mic1, 1=Mic2 */
+#define AC97_GP_MIX               0x0200       /* Mono output select 0=Mix, 1=Mic */
+#define AC97_GP_RLBK              0x0400       /* Remote Loopback - Modem line codec */
+#define AC97_GP_LLBK              0x0800       /* Local Loopback - Modem Line codec */
+#define AC97_GP_LD                0x1000       /* Loudness 1=on */
+#define AC97_GP_3D                0x2000       /* 3D Enhancement 1=on */
+#define AC97_GP_ST                0x4000       /* Stereo Enhancement 1=on */
+#define AC97_GP_POP               0x8000       /* Pcm Out Path, 0=pre 3D, 1=post 3D */
+
+/* extended audio status and control bit defines */
+#define AC97_EA_VRA               0x0001       /* Variable bit rate enable bit */
+#define AC97_EA_DRA               0x0002       /* Double-rate audio enable bit */
+#define AC97_EA_SPDIF             0x0004       /* S/PDIF Enable bit */
+#define AC97_EA_VRM               0x0008       /* Variable bit rate for MIC enable bit */
+#define AC97_EA_CDAC              0x0040       /* PCM Center DAC is ready (Read only) */
+#define AC97_EA_SDAC              0x0040       /* PCM Surround DACs are ready (Read only) */
+#define AC97_EA_LDAC              0x0080       /* PCM LFE DAC is ready (Read only) */
+#define AC97_EA_MDAC              0x0100       /* MIC ADC is ready (Read only) */
+#define AC97_EA_SPCV              0x0400       /* S/PDIF configuration valid (Read only) */
+#define AC97_EA_PRI               0x0800       /* Turns the PCM Center DAC off */
+#define AC97_EA_PRJ               0x1000       /* Turns the PCM Surround DACs off */
+#define AC97_EA_PRK               0x2000       /* Turns the PCM LFE DAC off */
+#define AC97_EA_PRL               0x4000       /* Turns the MIC ADC off */
+#define AC97_EA_SLOT_MASK         0xffcf       /* Mask for slot assignment bits */
+#define AC97_EA_SPSA_3_4          0x0000       /* Slot assigned to 3 & 4 */
+#define AC97_EA_SPSA_7_8          0x0010       /* Slot assigned to 7 & 8 */
+#define AC97_EA_SPSA_6_9          0x0020       /* Slot assigned to 6 & 9 */
+#define AC97_EA_SPSA_10_11        0x0030       /* Slot assigned to 10 & 11 */
+
+/* S/PDIF control bit defines */
+#define AC97_SC_PRO               0x0001       /* Professional status */
+#define AC97_SC_NAUDIO            0x0002       /* Non audio stream */
+#define AC97_SC_COPY              0x0004       /* Copyright status */
+#define AC97_SC_PRE               0x0008       /* Preemphasis status */
+#define AC97_SC_CC_MASK           0x07f0       /* Category Code mask */
+#define AC97_SC_L                 0x0800       /* Generation Level status */
+#define AC97_SC_SPSR_MASK         0xcfff       /* S/PDIF Sample Rate bits */
+#define AC97_SC_SPSR_44K          0x0000       /* Use 44.1kHz Sample rate */
+#define AC97_SC_SPSR_48K          0x2000       /* Use 48kHz Sample rate */
+#define AC97_SC_SPSR_32K          0x3000       /* Use 32kHz Sample rate */
+#define AC97_SC_DRS               0x4000       /* Double Rate S/PDIF */
+#define AC97_SC_V                 0x8000       /* Validity status */
+
+/* powerdown control and status bit defines */
+
+/* status */
+#define AC97_PWR_MDM              0x0010       /* Modem section ready */
+#define AC97_PWR_REF              0x0008       /* Vref nominal */
+#define AC97_PWR_ANL              0x0004       /* Analog section ready */
+#define AC97_PWR_DAC              0x0002       /* DAC section ready */
+#define AC97_PWR_ADC              0x0001       /* ADC section ready */
+
+/* control */
+#define AC97_PWR_PR0              0x0100       /* ADC and Mux powerdown */
+#define AC97_PWR_PR1              0x0200       /* DAC powerdown */
+#define AC97_PWR_PR2              0x0400       /* Output mixer powerdown (Vref on) */
+#define AC97_PWR_PR3              0x0800       /* Output mixer powerdown (Vref off) */
+#define AC97_PWR_PR4              0x1000       /* AC-link powerdown */
+#define AC97_PWR_PR5              0x2000       /* Internal Clk disable */
+#define AC97_PWR_PR6              0x4000       /* HP amp powerdown */
+#define AC97_PWR_PR7              0x8000       /* Modem off - if supported */
+
+/* extended audio ID register bit defines */
+#define AC97_EXTID_VRA            0x0001
+#define AC97_EXTID_DRA            0x0002
+#define AC97_EXTID_SPDIF          0x0004
+#define AC97_EXTID_VRM            0x0008
+#define AC97_EXTID_DSA0           0x0010
+#define AC97_EXTID_DSA1           0x0020
+#define AC97_EXTID_CDAC           0x0040
+#define AC97_EXTID_SDAC           0x0080
+#define AC97_EXTID_LDAC           0x0100
+#define AC97_EXTID_AMAP           0x0200
+#define AC97_EXTID_REV0           0x0400
+#define AC97_EXTID_REV1           0x0800
+#define AC97_EXTID_ID0            0x4000
+#define AC97_EXTID_ID1            0x8000
+
+/* extended status register bit defines */
+#define AC97_EXTSTAT_VRA          0x0001
+#define AC97_EXTSTAT_DRA          0x0002
+#define AC97_EXTSTAT_SPDIF        0x0004
+#define AC97_EXTSTAT_VRM          0x0008
+#define AC97_EXTSTAT_SPSA0        0x0010
+#define AC97_EXTSTAT_SPSA1        0x0020
+#define AC97_EXTSTAT_CDAC         0x0040
+#define AC97_EXTSTAT_SDAC         0x0080
+#define AC97_EXTSTAT_LDAC         0x0100
+#define AC97_EXTSTAT_MADC         0x0200
+#define AC97_EXTSTAT_SPCV         0x0400
+#define AC97_EXTSTAT_PRI          0x0800
+#define AC97_EXTSTAT_PRJ          0x1000
+#define AC97_EXTSTAT_PRK          0x2000
+#define AC97_EXTSTAT_PRL          0x4000
+
+/* useful power states */
+#define AC97_PWR_D0               0x0000      /* everything on */
+#define AC97_PWR_D1              AC97_PWR_PR0|AC97_PWR_PR1|AC97_PWR_PR4
+#define AC97_PWR_D2              AC97_PWR_PR0|AC97_PWR_PR1|AC97_PWR_PR2|AC97_PWR_PR3|AC97_PWR_PR4
+#define AC97_PWR_D3              AC97_PWR_PR0|AC97_PWR_PR1|AC97_PWR_PR2|AC97_PWR_PR3|AC97_PWR_PR4
+#define AC97_PWR_ANLOFF          AC97_PWR_PR2|AC97_PWR_PR3  /* analog section off */
+
+/* Total number of defined registers.  */
+#define AC97_REG_CNT 64
+
+
+/* OSS interface to the ac97s.. */
+#define AC97_STEREO_MASK (SOUND_MASK_VOLUME|SOUND_MASK_PCM|\
+	SOUND_MASK_LINE|SOUND_MASK_CD|\
+	SOUND_MASK_ALTPCM|SOUND_MASK_IGAIN|\
+	SOUND_MASK_LINE1|SOUND_MASK_VIDEO)
+
+#define AC97_SUPPORTED_MASK (AC97_STEREO_MASK | \
+	SOUND_MASK_BASS|SOUND_MASK_TREBLE|\
+	SOUND_MASK_SPEAKER|SOUND_MASK_MIC|\
+	SOUND_MASK_PHONEIN|SOUND_MASK_PHONEOUT)
+
+#define AC97_RECORD_MASK (SOUND_MASK_MIC|\
+	SOUND_MASK_CD|SOUND_MASK_IGAIN|SOUND_MASK_VIDEO|\
+	SOUND_MASK_LINE1| SOUND_MASK_LINE|\
+	SOUND_MASK_PHONEIN)
+
+/* original check is not good enough in case FOO is greater than
+ * SOUND_MIXER_NRDEVICES because the supported_mixers has exactly
+ * SOUND_MIXER_NRDEVICES elements.
+ * before matching the given mixer against the bitmask in supported_mixers we
+ * check if mixer number exceeds maximum allowed size which is as mentioned
+ * above SOUND_MIXER_NRDEVICES */
+#define supported_mixer(CODEC,FOO) ((FOO >= 0) && \
+                                    (FOO < SOUND_MIXER_NRDEVICES) && \
+                                    (CODEC)->supported_mixers & (1<<FOO) )
+
+struct ac97_codec {
+	/* AC97 controller connected with */
+	void *private_data;
+
+	char *name;
+	int id;
+	int dev_mixer; 
+	int type;
+
+	int modem:1;
+
+	struct ac97_ops *codec_ops;
+
+	/* controller specific lower leverl ac97 accessing routines */
+	u16  (*codec_read)  (struct ac97_codec *codec, u8 reg);
+	void (*codec_write) (struct ac97_codec *codec, u8 reg, u16 val);
+
+	/* Wait for codec-ready.  Ok to sleep here.  */
+	void  (*codec_wait)  (struct ac97_codec *codec);
+
+	/* OSS mixer masks */
+	int modcnt;
+	int supported_mixers;
+	int stereo_mixers;
+	int record_sources;
+
+	/* Property flags */
+	int flags;
+
+	int bit_resolution;
+
+	/* OSS mixer interface */
+	int  (*read_mixer) (struct ac97_codec *codec, int oss_channel);
+	void (*write_mixer)(struct ac97_codec *codec, int oss_channel,
+			    unsigned int left, unsigned int right);
+	int  (*recmask_io) (struct ac97_codec *codec, int rw, int mask);
+	int  (*mixer_ioctl)(struct ac97_codec *codec, unsigned int cmd, unsigned long arg);
+
+	/* saved OSS mixer states */
+	unsigned int mixer_state[SOUND_MIXER_NRDEVICES];
+
+	/* Software Modem interface */
+	int  (*modem_ioctl)(struct ac97_codec *codec, unsigned int cmd, unsigned long arg);
+};
+
+/*
+ *	Operation structures for each known AC97 chip
+ */
+ 
+struct ac97_ops
+{
+	/* Initialise */
+	int (*init)(struct ac97_codec *c);
+	/* Amplifier control */
+	int (*amplifier)(struct ac97_codec *codec, int on);
+	/* Digital mode control */
+	int (*digital)(struct ac97_codec *codec, int format);
+#define AC97_DELUDED_MODEM	1	/* Audio codec reports its a modem */
+#define AC97_NO_PCM_VOLUME	2	/* Volume control is missing 	   */
+};
+
+extern int ac97_read_proc (char *page_out, char **start, off_t off,
+			   int count, int *eof, void *data);
+extern int ac97_probe_codec(struct ac97_codec *);
+extern unsigned int ac97_set_adc_rate(struct ac97_codec *codec, unsigned int rate);
+extern unsigned int ac97_set_dac_rate(struct ac97_codec *codec, unsigned int rate);
+extern int ac97_save_state(struct ac97_codec *codec);
+extern int ac97_restore_state(struct ac97_codec *codec);
+
+#endif /* _AC97_CODEC_H_ */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/audio.c patched/drivers/sound/audigy/audio.c
--- old/drivers/sound/audigy/audio.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/audio.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,1596 @@
+/*
+ **********************************************************************
+ *     audio.c -- /dev/dsp interface for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *     November 2, 1999	    Alan Cox        cleaned up types/leaks
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/bitops.h>
+#include <asm/io.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/wrapper.h>
+
+
+#include "hwaccess.h"
+#include "cardwo.h"
+#include "cardwi.h"
+#include "recmgr.h"
+#include "irqmgr.h"
+#include "audio.h"
+#include "8010.h"
+
+
+static void calculate_ofrag(struct woinst *);
+static void calculate_ifrag(struct wiinst *);
+
+/* Audio file operations */
+static ssize_t emu10k1_audio_read(struct file *file, char *buffer, size_t count, loff_t * ppos)
+{
+	struct emu10k1_wavedevice *wave_dev = (struct emu10k1_wavedevice *) file->private_data;
+	struct wiinst *wiinst = wave_dev->wiinst;
+	ssize_t ret = 0;
+	unsigned long flags;
+
+	DPD(3, "emu10k1_audio_read(), buffer=%p, count=%d\n", buffer, (u32) count);
+
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+
+	if (!access_ok(VERIFY_WRITE, buffer, count))
+		return -EFAULT;
+
+	spin_lock_irqsave(&wiinst->lock, flags);
+
+	if (wiinst->mmapped) {
+		spin_unlock_irqrestore(&wiinst->lock, flags);
+		return -ENXIO;
+	}
+
+	if (wiinst->state == WAVE_STATE_CLOSED) {
+		calculate_ifrag(wiinst);
+
+		while (emu10k1_wavein_open(wave_dev) < 0) {
+			spin_unlock_irqrestore(&wiinst->lock, flags);
+
+			if (file->f_flags & O_NONBLOCK)
+				return -EAGAIN;
+
+			interruptible_sleep_on(&wave_dev->card->open_wait);
+
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+
+			spin_lock_irqsave(&wiinst->lock, flags);
+		}
+	}
+
+	spin_unlock_irqrestore(&wiinst->lock, flags);
+
+	while (count > 0) {
+		u32 bytestocopy;
+
+		spin_lock_irqsave(&wiinst->lock, flags);
+
+		if (!(wiinst->state & WAVE_STATE_STARTED)
+		    && (wave_dev->enablebits & PCM_ENABLE_INPUT))
+			emu10k1_wavein_start(wave_dev);
+
+		emu10k1_wavein_update(wave_dev->card, wiinst);
+		emu10k1_wavein_getxfersize(wiinst, &bytestocopy);
+
+		spin_unlock_irqrestore(&wiinst->lock, flags);
+
+		DPD(3, "bytestocopy --> %d\n", bytestocopy);
+
+		if ((bytestocopy >= wiinst->buffer.fragment_size)
+		    || (bytestocopy >= count)) {
+			bytestocopy = min_t(u32, bytestocopy, count);
+
+			emu10k1_wavein_xferdata(wiinst, (u8 *) buffer, &bytestocopy);
+
+			count -= bytestocopy;
+			buffer += bytestocopy;
+			ret += bytestocopy;
+		}
+
+		if (count > 0) {
+			if ((file->f_flags & O_NONBLOCK)
+			    || (!(wave_dev->enablebits & PCM_ENABLE_INPUT)))
+				return (ret ? ret : -EAGAIN);
+
+			interruptible_sleep_on(&wiinst->wait_queue);
+
+			if (signal_pending(current))
+				return (ret ? ret : -ERESTARTSYS);
+
+		}
+	}
+
+	DPD(3, "bytes copied -> %d\n", (u32) ret);
+
+	return ret;
+}
+
+static ssize_t emu10k1_audio_write(struct file *file, const char *buffer, size_t count, loff_t * ppos)
+{
+	struct emu10k1_wavedevice *wave_dev = (struct emu10k1_wavedevice *) file->private_data;
+
+	struct woinst *woinst = wave_dev->woinst;
+	ssize_t ret;
+	unsigned long flags;
+
+	DPD(3, "emu10k1_audio_write(), buffer=%p, count=%d\n", buffer, (u32) count);
+
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+
+	if (!access_ok(VERIFY_READ, buffer, count))
+		return -EFAULT;
+
+	spin_lock_irqsave(&woinst->lock, flags);
+
+	if (woinst->mmapped) {
+		spin_unlock_irqrestore(&woinst->lock, flags);
+		return -ENXIO;
+	}
+	// This is for emu10k1 revs less than 7, we need to go through tram
+	if (woinst->format.passthrough == 1) {
+		int r;
+		
+		woinst->buffer.ossfragshift = PT_BLOCKSIZE_LOG2;
+		woinst->buffer.numfrags = PT_BLOCKCOUNT;
+		calculate_ofrag(woinst);
+		
+		r = emu10k1_pt_write(file, buffer, count);
+		spin_unlock_irqrestore(&woinst->lock, flags);
+		return r;
+	}
+
+	if (woinst->state == WAVE_STATE_CLOSED) {
+		calculate_ofrag(woinst);
+
+		while (emu10k1_waveout_open(wave_dev) < 0) {
+			spin_unlock_irqrestore(&woinst->lock, flags);
+
+			if (file->f_flags & O_NONBLOCK)
+				return -EAGAIN;
+
+			interruptible_sleep_on(&wave_dev->card->open_wait);
+
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+
+			spin_lock_irqsave(&woinst->lock, flags);
+		}
+	}
+
+	spin_unlock_irqrestore(&woinst->lock, flags);
+
+	ret = 0;
+	if (count % woinst->format.bytespersample)
+                return -EINVAL;
+
+	count /= woinst->num_voices;
+
+	while (count > 0) {
+		u32 bytestocopy;
+
+		spin_lock_irqsave(&woinst->lock, flags);
+		emu10k1_waveout_update(woinst);
+		emu10k1_waveout_getxfersize(woinst, &bytestocopy);
+		spin_unlock_irqrestore(&woinst->lock, flags);
+
+		DPD(3, "bytestocopy --> %d\n", bytestocopy);
+
+		if ((bytestocopy >= woinst->buffer.fragment_size)
+		    || (bytestocopy >= count)) {
+
+			bytestocopy = min_t(u32, bytestocopy, count);
+
+			emu10k1_waveout_xferdata(woinst, (u8 *) buffer, &bytestocopy);
+
+			count -= bytestocopy;
+			buffer += bytestocopy * woinst->num_voices;
+			ret += bytestocopy * woinst->num_voices;
+
+			spin_lock_irqsave(&woinst->lock, flags);
+			woinst->total_copied += bytestocopy;
+
+			if (!(woinst->state & WAVE_STATE_STARTED)
+			    && (wave_dev->enablebits & PCM_ENABLE_OUTPUT)
+			    && (woinst->total_copied >= woinst->buffer.fragment_size))
+				emu10k1_waveout_start(wave_dev);
+
+			spin_unlock_irqrestore(&woinst->lock, flags);
+		}
+
+		if (count > 0) {
+			if ((file->f_flags & O_NONBLOCK)
+			    || (!(wave_dev->enablebits & PCM_ENABLE_OUTPUT)))
+				return (ret ? ret : -EAGAIN);
+
+			interruptible_sleep_on(&woinst->wait_queue);
+
+			if (signal_pending(current))
+				return (ret ? ret : -ERESTARTSYS);
+		}
+	}
+
+	DPD(3, "bytes copied -> %d\n", (u32) ret);
+
+	return ret;
+}
+
+static int emu10k1_audio_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct emu10k1_wavedevice *wave_dev = (struct emu10k1_wavedevice *) file->private_data;
+	struct woinst *woinst = NULL;
+	struct wiinst *wiinst = NULL;
+	int val = 0;
+	u32 bytestocopy;
+	unsigned long flags;
+
+	DPF(4, "emu10k1_audio_ioctl()\n");
+
+	if (file->f_mode & FMODE_WRITE)
+		woinst = wave_dev->woinst;
+
+	if (file->f_mode & FMODE_READ)
+		wiinst = wave_dev->wiinst;
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		DPF(2, "OSS_GETVERSION:\n");
+		return put_user(SOUND_VERSION, (int *) arg);
+
+	case SNDCTL_DSP_RESET:
+		DPF(2, "SNDCTL_DSP_RESET:\n");
+		wave_dev->enablebits = PCM_ENABLE_OUTPUT | PCM_ENABLE_INPUT;
+
+		if (file->f_mode & FMODE_WRITE) {
+			spin_lock_irqsave(&woinst->lock, flags);
+
+			if (woinst->state & WAVE_STATE_OPEN) {
+				emu10k1_waveout_close(wave_dev);
+			}
+
+			woinst->mmapped = 0;
+			woinst->total_copied = 0;
+			woinst->total_played = 0;
+			woinst->blocks = 0;
+
+			spin_unlock_irqrestore(&woinst->lock, flags);
+		}
+
+		if (file->f_mode & FMODE_READ) {
+			spin_lock_irqsave(&wiinst->lock, flags);
+
+			if (wiinst->state & WAVE_STATE_OPEN) {
+				emu10k1_wavein_close(wave_dev);
+			}
+
+			wiinst->mmapped = 0;
+			wiinst->total_recorded = 0;
+			wiinst->blocks = 0;
+			spin_unlock_irqrestore(&wiinst->lock, flags);
+		}
+
+		break;
+
+	case SNDCTL_DSP_SYNC:
+		DPF(2, "SNDCTL_DSP_SYNC:\n");
+
+		if (file->f_mode & FMODE_WRITE) {
+
+			spin_lock_irqsave(&woinst->lock, flags);
+
+			if (woinst->state & WAVE_STATE_OPEN) {
+
+				if (woinst->state & WAVE_STATE_STARTED)
+					while ((woinst->total_played < woinst->total_copied)
+					       && !signal_pending(current)) {
+						spin_unlock_irqrestore(&woinst->lock, flags);
+						interruptible_sleep_on(&woinst->wait_queue);
+						spin_lock_irqsave(&woinst->lock, flags);
+					}
+				emu10k1_waveout_close(wave_dev);
+			}
+
+			woinst->mmapped = 0;
+			woinst->total_copied = 0;
+			woinst->total_played = 0;
+			woinst->blocks = 0;
+
+			spin_unlock_irqrestore(&woinst->lock, flags);
+		}
+
+		if (file->f_mode & FMODE_READ) {
+			spin_lock_irqsave(&wiinst->lock, flags);
+
+			if (wiinst->state & WAVE_STATE_OPEN) {
+				emu10k1_wavein_close(wave_dev);
+			}
+
+			wiinst->mmapped = 0;
+			wiinst->total_recorded = 0;
+			wiinst->blocks = 0;
+			spin_unlock_irqrestore(&wiinst->lock, flags);
+		}
+
+		break;
+
+	case SNDCTL_DSP_SETDUPLEX:
+		DPF(2, "SNDCTL_DSP_SETDUPLEX:\n");
+		break;
+
+	case SNDCTL_DSP_GETCAPS:
+		DPF(2, "SNDCTL_DSP_GETCAPS:\n");
+		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |
+				DSP_CAP_TRIGGER | DSP_CAP_MMAP |
+				DSP_CAP_COPROC| DSP_CAP_MULTI, (int *) arg);
+	case SNDCTL_DSP_SPEED:
+		DPF(2, "SNDCTL_DSP_SPEED:\n");
+
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+
+		DPD(2, "val is %d\n", val);
+
+		if (val > 0) {
+			if (file->f_mode & FMODE_READ) {
+				struct wave_format format;
+
+				spin_lock_irqsave(&wiinst->lock, flags);
+
+				format = wiinst->format;
+				format.samplingrate = val;
+
+				if (emu10k1_wavein_setformat(wave_dev, &format) < 0) {
+					spin_unlock_irqrestore(&wiinst->lock, flags);
+					return -EINVAL;
+				}
+
+				val = wiinst->format.samplingrate;
+
+				spin_unlock_irqrestore(&wiinst->lock, flags);
+
+				DPD(2, "set recording sampling rate -> %d\n", val);
+			}
+
+			if (file->f_mode & FMODE_WRITE) {
+				struct wave_format format;
+
+				spin_lock_irqsave(&woinst->lock, flags);
+
+				format = woinst->format;
+				format.samplingrate = val;
+
+				if (emu10k1_waveout_setformat(wave_dev, &format) < 0) {
+					spin_unlock_irqrestore(&woinst->lock, flags);
+					return -EINVAL;
+				}
+
+				val = woinst->format.samplingrate;
+
+				spin_unlock_irqrestore(&woinst->lock, flags);
+
+				DPD(2, "set playback sampling rate -> %d\n", val);
+			}
+
+			return put_user(val, (int *) arg);
+		} else {
+			if (file->f_mode & FMODE_READ)
+				val = wiinst->format.samplingrate;
+			else if (file->f_mode & FMODE_WRITE)
+				val = woinst->format.samplingrate;
+
+			return put_user(val, (int *) arg);
+		}
+		break;
+
+	case SNDCTL_DSP_STEREO:
+		DPF(2, "SNDCTL_DSP_STEREO:\n");
+
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+
+		DPD(2, " val is %d\n", val);
+
+		if (file->f_mode & FMODE_READ) {
+			struct wave_format format;
+
+			spin_lock_irqsave(&wiinst->lock, flags);
+
+			format = wiinst->format;
+			format.channels = val ? 2 : 1;
+
+			if (emu10k1_wavein_setformat(wave_dev, &format) < 0) {
+				spin_unlock_irqrestore(&wiinst->lock, flags);
+				return -EINVAL;
+			}
+
+			val = wiinst->format.channels - 1;
+
+			spin_unlock_irqrestore(&wiinst->lock, flags);
+			DPD(2, "set recording stereo -> %d\n", val);
+		}
+
+		if (file->f_mode & FMODE_WRITE) {
+			struct wave_format format;
+
+			spin_lock_irqsave(&woinst->lock, flags);
+
+			format = woinst->format;
+			format.channels = val ? 2 : 1;
+
+			if (emu10k1_waveout_setformat(wave_dev, &format) < 0) {
+				spin_unlock_irqrestore(&woinst->lock, flags);
+				return -EINVAL;
+			}
+
+			val = woinst->format.channels - 1;
+
+			spin_unlock_irqrestore(&woinst->lock, flags);
+
+			DPD(2, "set playback stereo -> %d\n", val);
+		}
+
+		return put_user(val, (int *) arg);
+
+		break;
+
+	case SNDCTL_DSP_CHANNELS:
+		DPF(2, "SNDCTL_DSP_CHANNELS:\n");
+
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+
+		DPD(2, " val is %d\n", val);
+
+		if (val > 0) {
+			if (file->f_mode & FMODE_READ) {
+				struct wave_format format;
+
+				spin_lock_irqsave(&wiinst->lock, flags);
+
+				format = wiinst->format;
+				format.channels = val;
+
+				if (emu10k1_wavein_setformat(wave_dev, &format) < 0) {
+					spin_unlock_irqrestore(&wiinst->lock, flags);
+					return -EINVAL;
+				}
+				val = wiinst->format.channels;
+
+				spin_unlock_irqrestore(&wiinst->lock, flags);
+				DPD(2, "set recording number of channels -> %d\n", val);
+			}
+
+			if (file->f_mode & FMODE_WRITE) {
+				struct wave_format format;
+
+				spin_lock_irqsave(&woinst->lock, flags);
+
+				format = woinst->format;
+				format.channels = val;
+
+				if (emu10k1_waveout_setformat(wave_dev, &format) < 0) {
+					spin_unlock_irqrestore(&woinst->lock, flags);
+					return -EINVAL;
+				}
+
+				val = woinst->format.channels;
+
+				spin_unlock_irqrestore(&woinst->lock, flags);
+				DPD(2, "set playback number of channels -> %d\n", val);
+			}
+
+			return put_user(val, (int *) arg);
+		} else {
+			if (file->f_mode & FMODE_READ)
+				val = wiinst->format.channels;
+			else if (file->f_mode & FMODE_WRITE)
+				val = woinst->format.channels;
+
+			return put_user(val, (int *) arg);
+		}
+
+		break;
+
+	case SNDCTL_DSP_GETFMTS:
+		DPF(2, "SNDCTL_DSP_GETFMTS:\n");
+
+		if (file->f_mode & FMODE_READ)
+			val = AFMT_S16_LE;
+		else if (file->f_mode & FMODE_WRITE) {
+			val = AFMT_S16_LE | AFMT_U8;
+			if (emu10k1_find_control_gpr(&wave_dev->card->mgr,
+						     wave_dev->card->pt.patch_name, 
+						     wave_dev->card->pt.enable_gpr_name) >= 0)
+				val |= AFMT_AC3;
+		}
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_SETFMT:	/* Same as SNDCTL_DSP_SAMPLESIZE */
+		DPF(2, "SNDCTL_DSP_SETFMT:\n");
+
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+
+		DPD(2, " val is %d\n", val);
+
+		if (val != AFMT_QUERY) {
+			if (file->f_mode & FMODE_READ) {
+				struct wave_format format;
+
+				spin_lock_irqsave(&wiinst->lock, flags);
+
+				format = wiinst->format;
+				format.id = val;
+
+				if (emu10k1_wavein_setformat(wave_dev, &format) < 0) {
+					spin_unlock_irqrestore(&wiinst->lock, flags);
+					return -EINVAL;
+				}
+
+				val = wiinst->format.id;
+
+				spin_unlock_irqrestore(&wiinst->lock, flags);
+				DPD(2, "set recording format -> %d\n", val);
+			}
+
+			if (file->f_mode & FMODE_WRITE) {
+				struct wave_format format;
+
+				spin_lock_irqsave(&woinst->lock, flags);
+
+				format = woinst->format;
+				format.id = val;
+
+				if (emu10k1_waveout_setformat(wave_dev, &format) < 0) {
+					spin_unlock_irqrestore(&woinst->lock, flags);
+					return -EINVAL;
+				}
+
+				val = woinst->format.id;
+
+				spin_unlock_irqrestore(&woinst->lock, flags);
+				DPD(2, "set playback format -> %d\n", val);
+			}
+
+			return put_user(val, (int *) arg);
+		} else {
+			if (file->f_mode & FMODE_READ)
+				val = wiinst->format.id;
+			else if (file->f_mode & FMODE_WRITE)
+				val = woinst->format.id;
+
+			return put_user(val, (int *) arg);
+		}
+		break;
+
+	case SOUND_PCM_READ_BITS:
+
+		if (file->f_mode & FMODE_READ)
+			val = wiinst->format.bitsperchannel;
+		else if (file->f_mode & FMODE_WRITE)
+			val = woinst->format.bitsperchannel;
+
+		return put_user(val, (int *) arg);
+
+	case SOUND_PCM_READ_RATE:
+
+		if (file->f_mode & FMODE_READ)
+			val = wiinst->format.samplingrate;
+		else if (file->f_mode & FMODE_WRITE)
+			val = woinst->format.samplingrate;
+
+		return put_user(val, (int *) arg);
+
+	case SOUND_PCM_READ_CHANNELS:
+
+		if (file->f_mode & FMODE_READ)
+			val = wiinst->format.channels;
+		else if (file->f_mode & FMODE_WRITE)
+			val = woinst->format.channels;
+
+		return put_user(val, (int *) arg);
+
+	case SOUND_PCM_WRITE_FILTER:
+		DPF(2, "SOUND_PCM_WRITE_FILTER: not implemented\n");
+		break;
+
+	case SOUND_PCM_READ_FILTER:
+		DPF(2, "SOUND_PCM_READ_FILTER: not implemented\n");
+		break;
+
+	case SNDCTL_DSP_SETSYNCRO:
+		DPF(2, "SNDCTL_DSP_SETSYNCRO: not implemented\n");
+		break;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		DPF(2, "SNDCTL_DSP_GETTRIGGER:\n");
+
+		if (file->f_mode & FMODE_WRITE && (wave_dev->enablebits & PCM_ENABLE_OUTPUT))
+			val |= PCM_ENABLE_OUTPUT;
+
+		if (file->f_mode & FMODE_READ && (wave_dev->enablebits & PCM_ENABLE_INPUT))
+			val |= PCM_ENABLE_INPUT;
+
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_SETTRIGGER:
+		DPF(2, "SNDCTL_DSP_SETTRIGGER:\n");
+
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+
+		if (file->f_mode & FMODE_WRITE) {
+			spin_lock_irqsave(&woinst->lock, flags);
+
+			if (val & PCM_ENABLE_OUTPUT) {
+				wave_dev->enablebits |= PCM_ENABLE_OUTPUT;
+				if (woinst->state & WAVE_STATE_OPEN)
+					emu10k1_waveout_start(wave_dev);
+			} else {
+				wave_dev->enablebits &= ~PCM_ENABLE_OUTPUT;
+				if (woinst->state & WAVE_STATE_STARTED)
+					emu10k1_waveout_stop(wave_dev);
+			}
+
+			spin_unlock_irqrestore(&woinst->lock, flags);
+		}
+
+		if (file->f_mode & FMODE_READ) {
+			spin_lock_irqsave(&wiinst->lock, flags);
+
+			if (val & PCM_ENABLE_INPUT) {
+				wave_dev->enablebits |= PCM_ENABLE_INPUT;
+				if (wiinst->state & WAVE_STATE_OPEN)
+					emu10k1_wavein_start(wave_dev);
+			} else {
+				wave_dev->enablebits &= ~PCM_ENABLE_INPUT;
+				if (wiinst->state & WAVE_STATE_STARTED)
+					emu10k1_wavein_stop(wave_dev);
+			}
+
+			spin_unlock_irqrestore(&wiinst->lock, flags);
+		}
+		break;
+
+	case SNDCTL_DSP_GETOSPACE:
+		{
+			audio_buf_info info;
+
+			DPF(4, "SNDCTL_DSP_GETOSPACE:\n");
+
+			if (!(file->f_mode & FMODE_WRITE))
+				return -EINVAL;
+
+			spin_lock_irqsave(&woinst->lock, flags);
+
+			if (woinst->state & WAVE_STATE_OPEN) {
+				emu10k1_waveout_update(woinst);
+				emu10k1_waveout_getxfersize(woinst, &bytestocopy);
+
+				info.bytes = bytestocopy;
+			} else {
+				calculate_ofrag(woinst);
+				info.bytes = woinst->buffer.size;
+			}
+			spin_unlock_irqrestore(&woinst->lock, flags);
+
+			info.bytes *= woinst->num_voices;
+			info.fragsize = woinst->buffer.fragment_size * woinst->num_voices;
+			info.fragstotal = woinst->buffer.numfrags * woinst->num_voices;
+			info.fragments = info.bytes / info.fragsize;
+
+			if (copy_to_user((int *) arg, &info, sizeof(info)))
+				return -EFAULT;
+		}
+		break;
+
+	case SNDCTL_DSP_GETISPACE:
+		{
+			audio_buf_info info;
+
+			DPF(4, "SNDCTL_DSP_GETISPACE:\n");
+
+			if (!(file->f_mode & FMODE_READ))
+				return -EINVAL;
+
+			spin_lock_irqsave(&wiinst->lock, flags);
+			if (wiinst->state & WAVE_STATE_OPEN) {
+				emu10k1_wavein_update(wave_dev->card, wiinst);
+				emu10k1_wavein_getxfersize(wiinst, &bytestocopy);
+
+				info.bytes = bytestocopy;
+			} else {
+				calculate_ifrag(wiinst);
+				info.bytes = 0;
+			}
+			spin_unlock_irqrestore(&wiinst->lock, flags);
+
+			info.fragstotal = wiinst->buffer.numfrags;
+			info.fragments = info.bytes / wiinst->buffer.fragment_size;
+			info.fragsize = wiinst->buffer.fragment_size;
+
+			if (copy_to_user((int *) arg, &info, sizeof(info)))
+				return -EFAULT;
+		}
+		break;
+
+	case SNDCTL_DSP_NONBLOCK:
+		DPF(2, "SNDCTL_DSP_NONBLOCK:\n");
+
+		file->f_flags |= O_NONBLOCK;
+		break;
+
+	case SNDCTL_DSP_GETODELAY:
+		DPF(4, "SNDCTL_DSP_GETODELAY:\n");
+
+		if (!(file->f_mode & FMODE_WRITE))
+			return -EINVAL;
+
+		spin_lock_irqsave(&woinst->lock, flags);
+		if (woinst->state & WAVE_STATE_OPEN) {
+			emu10k1_waveout_update(woinst);
+			emu10k1_waveout_getxfersize(woinst, &bytestocopy);
+
+			val = woinst->buffer.size - bytestocopy;
+		} else
+			val = 0;
+
+		val *= woinst->num_voices;
+		spin_unlock_irqrestore(&woinst->lock, flags);
+
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_GETIPTR:
+		{
+			count_info cinfo;
+
+			DPF(4, "SNDCTL_DSP_GETIPTR: \n");
+
+			if (!(file->f_mode & FMODE_READ))
+				return -EINVAL;
+
+			spin_lock_irqsave(&wiinst->lock, flags);
+
+			if (wiinst->state & WAVE_STATE_OPEN) {
+				emu10k1_wavein_update(wave_dev->card, wiinst);
+
+				cinfo.ptr = wiinst->buffer.hw_pos;
+				cinfo.bytes = cinfo.ptr + wiinst->total_recorded - wiinst->total_recorded % wiinst->buffer.size;
+				cinfo.blocks = cinfo.bytes / wiinst->buffer.fragment_size - wiinst->blocks;
+				wiinst->blocks = cinfo.bytes / wiinst->buffer.fragment_size;
+			} else {
+				cinfo.ptr = 0;
+				cinfo.bytes = 0;
+				cinfo.blocks = 0;
+			}
+
+			if (wiinst->mmapped)
+				wiinst->buffer.bytestocopy %= wiinst->buffer.fragment_size;
+
+			spin_unlock_irqrestore(&wiinst->lock, flags);
+
+			if (copy_to_user((void *) arg, &cinfo, sizeof(cinfo)))
+				return -EFAULT;
+		}
+		break;
+
+	case SNDCTL_DSP_GETOPTR:
+		{
+			count_info cinfo;
+
+			DPF(4, "SNDCTL_DSP_GETOPTR:\n");
+
+			if (!(file->f_mode & FMODE_WRITE))
+				return -EINVAL;
+
+			spin_lock_irqsave(&woinst->lock, flags);
+
+			if (woinst->state & WAVE_STATE_OPEN || 
+			    ((woinst->format.passthrough == 1) && wave_dev->card->pt.state)) {
+				int num_fragments;
+
+				if (woinst->format.passthrough == 1) {
+					emu10k1_pt_waveout_update(wave_dev);
+					cinfo.bytes = woinst->total_played;
+				} else {
+					emu10k1_waveout_update(woinst);
+					cinfo.bytes = woinst->total_played;
+				}
+
+				cinfo.ptr = woinst->buffer.hw_pos;
+				num_fragments = cinfo.bytes / woinst->buffer.fragment_size;
+				cinfo.blocks = num_fragments - woinst->blocks;
+				woinst->blocks = num_fragments;
+
+				cinfo.bytes *= woinst->num_voices;
+				cinfo.ptr *= woinst->num_voices;
+			} else {
+				cinfo.ptr = 0;
+				cinfo.bytes = 0;
+				cinfo.blocks = 0;
+			}
+
+			if (woinst->mmapped)
+				woinst->buffer.free_bytes %= woinst->buffer.fragment_size;
+
+			spin_unlock_irqrestore(&woinst->lock, flags);
+
+			if (copy_to_user((void *) arg, &cinfo, sizeof(cinfo)))
+				return -EFAULT;
+		}
+		break;
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		DPF(2, "SNDCTL_DSP_GETBLKSIZE:\n");
+
+		if (file->f_mode & FMODE_WRITE) {
+			spin_lock_irqsave(&woinst->lock, flags);
+
+			calculate_ofrag(woinst);
+			val = woinst->buffer.fragment_size * woinst->num_voices;
+
+			spin_unlock_irqrestore(&woinst->lock, flags);
+		}
+
+		if (file->f_mode & FMODE_READ) {
+			spin_lock_irqsave(&wiinst->lock, flags);
+
+			calculate_ifrag(wiinst);
+			val = wiinst->buffer.fragment_size;
+
+			spin_unlock_irqrestore(&wiinst->lock, flags);
+		}
+
+		return put_user(val, (int *) arg);
+
+		break;
+
+	case SNDCTL_DSP_POST:
+		if (file->f_mode & FMODE_WRITE) {
+			spin_lock_irqsave(&woinst->lock, flags);
+
+			if (!(woinst->state & WAVE_STATE_STARTED)
+			    && (wave_dev->enablebits & PCM_ENABLE_OUTPUT)
+			    && (woinst->total_copied > 0))
+				emu10k1_waveout_start(wave_dev);
+
+			spin_unlock_irqrestore(&woinst->lock, flags);
+		}
+
+		break;
+
+	case SNDCTL_DSP_SUBDIVIDE:
+		DPF(2, "SNDCTL_DSP_SUBDIVIDE: not implemented\n");
+		break;
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		DPF(2, "SNDCTL_DSP_SETFRAGMENT:\n");
+
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+
+		DPD(2, "val is %#x\n", val);
+
+		if (val == 0)
+			return -EIO;
+
+		if (file->f_mode & FMODE_WRITE) {
+			/* digital pass-through fragment count and size are fixed values */
+			if (woinst->state & WAVE_STATE_OPEN || (woinst->format.passthrough == 1))
+				return -EINVAL;	/* too late to change */
+
+			woinst->buffer.ossfragshift = val & 0xffff;
+			woinst->buffer.numfrags = (val >> 16) & 0xffff;
+		}
+
+		if (file->f_mode & FMODE_READ) {
+			if (wiinst->state & WAVE_STATE_OPEN)
+				return -EINVAL;	/* too late to change */
+
+			wiinst->buffer.ossfragshift = val & 0xffff;
+			wiinst->buffer.numfrags = (val >> 16) & 0xffff;
+		}
+
+		break;
+
+	case SNDCTL_COPR_LOAD:
+		{
+			copr_buffer *buf;
+			u32 i;
+
+			DPF(4, "SNDCTL_COPR_LOAD:\n");
+
+			buf = kmalloc(sizeof(copr_buffer), GFP_KERNEL);
+			if (!buf)
+				return -ENOMEM;
+
+			if (copy_from_user(buf, (copr_buffer *) arg, sizeof(copr_buffer))) {
+				kfree (buf);
+				return -EFAULT;
+			}
+
+			if ((buf->command != CMD_READ) && (buf->command != CMD_WRITE)) {
+				kfree (buf);
+				return -EINVAL;
+			}
+
+			if (buf->command == CMD_WRITE) {
+				
+#ifdef DBGEMU
+				if ((buf->offs < 0) || (buf->offs + buf->len > 0xe00) || (buf->len > 1000)) {
+#else
+				if (((buf->offs < 0x100) || (buf->offs + buf->len > (wave_dev->card->is_audigy ? 0xe00 : 0x800)) || (buf->len > 1000)
+				) && !(
+					//any register allowed raw access to users goes here:
+					(buf->offs == DBG ||
+					  buf->offs == A_DBG)
+					&& (buf->len == 1))) {
+#endif		
+					kfree(buf);
+					return -EINVAL;
+				}
+			} else {
+				if ((buf->offs < 0) || (buf->offs + buf->len > 0xe00) || (buf->len > 1000)) {
+					kfree(buf);
+					return -EINVAL;
+				}
+			}
+			
+			if (((unsigned)buf->flags) > 0x3f)
+				buf->flags = 0;
+
+			if (buf->command == CMD_READ) {
+				for (i = 0; i < buf->len; i++)
+					((u32 *) buf->data)[i] = sblive_readptr(wave_dev->card, buf->offs + i, buf->flags);
+
+				if (copy_to_user((copr_buffer *) arg, buf, sizeof(copr_buffer))) {
+					kfree(buf);
+					return -EFAULT;
+				}
+			} else {
+				for (i = 0; i < buf->len; i++)
+					sblive_writeptr(wave_dev->card, buf->offs + i, buf->flags, ((u32 *) buf->data)[i]);
+			}
+
+			kfree (buf);
+			break;
+		}
+
+	default:		/* Default is unrecognized command */
+		DPD(2, "default: %#x\n", cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct page *emu10k1_mm_nopage (struct vm_area_struct * vma, unsigned long address, int write_access)
+{
+	struct emu10k1_wavedevice *wave_dev = vma->vm_private_data;
+	struct woinst *woinst = wave_dev->woinst;
+	struct wiinst *wiinst = wave_dev->wiinst;
+	struct page *dmapage;
+	unsigned long pgoff;
+	int rd, wr;
+
+	DPF(3, "emu10k1_mm_nopage()\n");
+	DPD(3, "addr: %#lx\n", address);
+
+	if (address > vma->vm_end) {
+		DPF(1, "EXIT, returning NOPAGE_SIGBUS\n");
+		return NOPAGE_SIGBUS; /* Disallow mremap */
+	}
+
+	pgoff = vma->vm_pgoff + ((address - vma->vm_start) >> PAGE_SHIFT);
+	if (woinst != NULL)
+		wr = woinst->mmapped;
+	else
+		wr = 0;
+
+	if (wiinst != NULL)
+		rd = wiinst->mmapped;
+	else
+		rd = 0;
+
+	/* if full-duplex (read+write) and we have two sets of bufs,
+	* then the playback buffers come first, sez soundcard.c */
+	if (wr) {
+		if (pgoff >= woinst->buffer.pages) {
+			pgoff -= woinst->buffer.pages;
+			dmapage = virt_to_page ((u8 *) wiinst->buffer.addr + pgoff * PAGE_SIZE);
+		} else
+			dmapage = virt_to_page (woinst->voice[0].mem.addr[pgoff]);
+	} else {
+		dmapage = virt_to_page ((u8 *) wiinst->buffer.addr + pgoff * PAGE_SIZE);
+	}
+
+	get_page (dmapage);
+
+	DPD(3, "page: %#lx\n", (unsigned long) dmapage);
+	return dmapage;
+}
+
+struct vm_operations_struct emu10k1_mm_ops = {
+	nopage:         emu10k1_mm_nopage,
+};
+
+static int emu10k1_audio_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct emu10k1_wavedevice *wave_dev = (struct emu10k1_wavedevice *) file->private_data;
+	unsigned long max_pages, n_pages, pgoffset;
+	struct woinst *woinst = NULL;
+	struct wiinst *wiinst = NULL;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_audio_mmap()\n");
+
+	max_pages = 0;
+	if (vma->vm_flags & VM_WRITE) {
+		woinst = wave_dev->woinst;
+
+		spin_lock_irqsave(&woinst->lock, flags);
+
+		/* No m'mapping possible for multichannel */
+		if (woinst->num_voices > 1) {
+			spin_unlock_irqrestore(&woinst->lock, flags);
+                	return -EINVAL;
+		}
+
+		if (woinst->state == WAVE_STATE_CLOSED) {
+			calculate_ofrag(woinst);
+
+			if (emu10k1_waveout_open(wave_dev) < 0) {
+				spin_unlock_irqrestore(&woinst->lock, flags);
+				ERROR();
+				return -EINVAL;
+			}
+		}
+
+		woinst->mmapped = 1;
+		max_pages += woinst->buffer.pages;
+		spin_unlock_irqrestore(&woinst->lock, flags);
+	}
+
+	if (vma->vm_flags & VM_READ) {
+		wiinst = wave_dev->wiinst;
+
+		spin_lock_irqsave(&wiinst->lock, flags);
+		if (wiinst->state == WAVE_STATE_CLOSED) {
+			calculate_ifrag(wiinst);
+
+			if (emu10k1_wavein_open(wave_dev) < 0) {
+				spin_unlock_irqrestore(&wiinst->lock, flags);
+				ERROR();
+				return -EINVAL;
+			}
+		}
+
+		wiinst->mmapped = 1;
+		max_pages += wiinst->buffer.pages;
+		spin_unlock_irqrestore(&wiinst->lock, flags);
+	}
+
+	n_pages = ((vma->vm_end - vma->vm_start) + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	pgoffset = vma->vm_pgoff;
+
+	DPD(2, "vma_start: %#lx, vma_end: %#lx, vma_offset: %ld\n", vma->vm_start, vma->vm_end, pgoffset);
+	DPD(2, "n_pages: %ld, max_pages: %ld\n", n_pages, max_pages);
+
+	if (pgoffset + n_pages > max_pages)
+		return -EINVAL;
+
+	vma->vm_flags |= VM_RESERVED;
+	vma->vm_ops = &emu10k1_mm_ops;
+	vma->vm_private_data = wave_dev;
+	return 0;
+}
+
+static int emu10k1_audio_open(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(inode->i_rdev);
+	struct emu10k1_card *card = NULL;
+	struct list_head *entry;
+	struct emu10k1_wavedevice *wave_dev;
+
+	DPF(2, "emu10k1_audio_open()\n");
+
+	/* Check for correct device to open */
+
+	list_for_each(entry, &emu10k1_devs) {
+		card = list_entry(entry, struct emu10k1_card, list);
+
+		if (!((card->audio_dev ^ minor) & ~0xf) || !((card->audio_dev1 ^ minor) & ~0xf))
+			goto match;
+	}
+
+	return -ENODEV;
+
+match:
+
+	wave_dev = (struct emu10k1_wavedevice *) kmalloc(sizeof(struct emu10k1_wavedevice), GFP_KERNEL);
+
+	if (wave_dev == NULL) { 
+		ERROR();
+		return -ENOMEM;
+	}
+
+	wave_dev->card = card;
+	wave_dev->wiinst = NULL;
+	wave_dev->woinst = NULL;
+	wave_dev->enablebits = PCM_ENABLE_OUTPUT | PCM_ENABLE_INPUT;	/* Default */
+
+	if (file->f_mode & FMODE_READ) {
+		/* Recording */
+		struct wiinst *wiinst;
+
+		if ((wiinst = (struct wiinst *) kmalloc(sizeof(struct wiinst), GFP_KERNEL)) == NULL) {
+			ERROR();
+			return -ENODEV;
+		}
+
+		wiinst->recsrc = card->wavein.recsrc;
+                wiinst->fxwc = card->wavein.fxwc;
+
+		switch (wiinst->recsrc) {
+		case WAVERECORD_AC97:
+			wiinst->format.id = AFMT_S16_LE;
+			wiinst->format.samplingrate = 8000;
+			wiinst->format.bitsperchannel = 16;
+			wiinst->format.channels = 1;
+			break;
+		case WAVERECORD_MIC:
+			wiinst->format.id = AFMT_S16_LE;
+			wiinst->format.samplingrate = 8000;
+			wiinst->format.bitsperchannel = 16;
+			wiinst->format.channels = 1;
+			break;
+		case WAVERECORD_FX:
+			wiinst->format.id = AFMT_S16_LE;
+			wiinst->format.samplingrate = 48000;
+			wiinst->format.bitsperchannel = 16;
+			wiinst->format.channels = hweight32(wiinst->fxwc);
+			break;
+		default:
+			BUG();
+			break;
+		}
+
+		wiinst->state = WAVE_STATE_CLOSED;
+
+		wiinst->buffer.ossfragshift = 0;
+		wiinst->buffer.fragment_size = 0;
+		wiinst->buffer.numfrags = 0;
+
+		init_waitqueue_head(&wiinst->wait_queue);
+
+		wiinst->mmapped = 0;
+		wiinst->total_recorded = 0;
+		wiinst->blocks = 0;
+		wiinst->lock = SPIN_LOCK_UNLOCKED;
+		tasklet_init(&wiinst->timer.tasklet, emu10k1_wavein_bh, (unsigned long) wave_dev);
+		wave_dev->wiinst = wiinst;
+		emu10k1_wavein_setformat(wave_dev, &wiinst->format);
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		struct woinst *woinst;
+		int i;
+
+		if ((woinst = (struct woinst *) kmalloc(sizeof(struct woinst), GFP_KERNEL)) == NULL) {
+			ERROR();
+			return -ENODEV;
+		}
+
+		if (wave_dev->wiinst != NULL) {
+			woinst->format = wave_dev->wiinst->format;
+		} else {
+			woinst->format.id = AFMT_U8;
+			woinst->format.samplingrate = 8000;
+			woinst->format.bitsperchannel = 8;
+			woinst->format.channels = 1;
+		}
+
+		woinst->state = WAVE_STATE_CLOSED;
+
+		woinst->buffer.fragment_size = 0;
+		woinst->buffer.ossfragshift = 0;
+		woinst->buffer.numfrags = 0;
+		woinst->device = (card->audio_dev1 == minor);
+		woinst->timer.state = TIMER_STATE_UNINSTALLED;
+		woinst->num_voices = 1;
+
+		for (i = 0; i < WAVEOUT_MAXVOICES; i++) {
+			woinst->voice[i].usage = VOICE_USAGE_FREE;
+			woinst->voice[i].mem.emupageindex = -1;
+		}
+
+		init_waitqueue_head(&woinst->wait_queue);
+
+		woinst->mmapped = 0;
+		woinst->total_copied = 0;
+		woinst->total_played = 0;
+		woinst->blocks = 0;
+		woinst->lock = SPIN_LOCK_UNLOCKED;
+		tasklet_init(&woinst->timer.tasklet, emu10k1_waveout_bh, (unsigned long) wave_dev);
+		wave_dev->woinst = woinst;
+		emu10k1_waveout_setformat(wave_dev, &woinst->format);
+	}
+
+	file->private_data = (void *) wave_dev;
+
+	return 0;
+}
+
+static int emu10k1_audio_release(struct inode *inode, struct file *file)
+{
+	struct emu10k1_wavedevice *wave_dev = (struct emu10k1_wavedevice *) file->private_data;
+	struct emu10k1_card *card;
+	unsigned long flags;
+
+	card = wave_dev->card;
+
+	DPF(2, "emu10k1_audio_release()\n");
+
+	if (file->f_mode & FMODE_WRITE) {
+		struct woinst *woinst = wave_dev->woinst;
+
+		spin_lock_irqsave(&woinst->lock, flags);
+		if(woinst->format.passthrough==2)
+			card->pt.state=PT_STATE_PLAYING;
+		if (woinst->format.passthrough && card->pt.state != PT_STATE_INACTIVE){
+			spin_lock(&card->pt.lock);
+                        emu10k1_pt_stop(card);
+			spin_unlock(&card->pt.lock);
+		}
+		if (woinst->state & WAVE_STATE_OPEN) {
+			if (woinst->state & WAVE_STATE_STARTED) {
+				if (!(file->f_flags & O_NONBLOCK)) {
+					while (!signal_pending(current)
+					       && (woinst->total_played < woinst->total_copied)) {
+						DPF(4, "Buffer hasn't been totally played, sleep....\n");
+						spin_unlock_irqrestore(&woinst->lock, flags);
+						interruptible_sleep_on(&woinst->wait_queue);
+						spin_lock_irqsave(&woinst->lock, flags);
+					}
+				}
+			}
+			emu10k1_waveout_close(wave_dev);
+		}
+
+		spin_unlock_irqrestore(&woinst->lock, flags);
+		/* remove the tasklet */
+		tasklet_kill(&woinst->timer.tasklet);
+		kfree(wave_dev->woinst);
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		struct wiinst *wiinst = wave_dev->wiinst;
+
+		spin_lock_irqsave(&wiinst->lock, flags);
+
+		if (wiinst->state & WAVE_STATE_OPEN) {
+			emu10k1_wavein_close(wave_dev);
+		}
+
+		spin_unlock_irqrestore(&wiinst->lock, flags);
+		tasklet_kill(&wiinst->timer.tasklet);
+		kfree(wave_dev->wiinst);
+	}
+
+	kfree(wave_dev);
+
+	if (waitqueue_active(&card->open_wait))
+		wake_up_interruptible(&card->open_wait);
+
+	return 0;
+}
+
+/* FIXME sort out poll() + mmap() */
+static unsigned int emu10k1_audio_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct emu10k1_wavedevice *wave_dev = (struct emu10k1_wavedevice *) file->private_data;
+	struct woinst *woinst = wave_dev->woinst;
+	struct wiinst *wiinst = wave_dev->wiinst;
+	unsigned int mask = 0;
+	u32 bytestocopy;
+	unsigned long flags;
+
+	DPF(4, "emu10k1_audio_poll()\n");
+
+	if (file->f_mode & FMODE_WRITE)
+		poll_wait(file, &woinst->wait_queue, wait);
+
+	if (file->f_mode & FMODE_READ)
+		poll_wait(file, &wiinst->wait_queue, wait);
+
+	if (file->f_mode & FMODE_WRITE) {
+		spin_lock_irqsave(&woinst->lock, flags);
+
+		if (woinst->state & WAVE_STATE_OPEN) {
+			emu10k1_waveout_update(woinst);
+			emu10k1_waveout_getxfersize(woinst, &bytestocopy);
+
+			if (bytestocopy >= woinst->buffer.fragment_size)
+				mask |= POLLOUT | POLLWRNORM;
+		} else
+			mask |= POLLOUT | POLLWRNORM;
+
+		spin_unlock_irqrestore(&woinst->lock, flags);
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		spin_lock_irqsave(&wiinst->lock, flags);
+
+		if (wiinst->state & WAVE_STATE_OPEN) {
+			emu10k1_wavein_update(wave_dev->card, wiinst);
+			emu10k1_wavein_getxfersize(wiinst, &bytestocopy);
+
+			if (bytestocopy >= wiinst->buffer.fragment_size)
+				mask |= POLLIN | POLLRDNORM;
+		}
+
+		spin_unlock_irqrestore(&wiinst->lock, flags);
+	}
+
+	return mask;
+}
+
+static void calculate_ofrag(struct woinst *woinst)
+{
+	struct waveout_buffer *buffer = &woinst->buffer;
+	u32 fragsize;
+
+	if (buffer->fragment_size)
+		return;
+
+	if (!buffer->ossfragshift) {
+		fragsize = (woinst->format.bytespervoicesample * woinst->format.samplingrate * WAVEOUT_DEFAULTFRAGLEN) / 1000 - 1;
+
+		while (fragsize) {
+			fragsize >>= 1;
+			buffer->ossfragshift++;
+		}
+	}
+
+	if (buffer->ossfragshift < WAVEOUT_MINFRAGSHIFT)
+		buffer->ossfragshift = WAVEOUT_MINFRAGSHIFT;
+
+	buffer->fragment_size = 1 << buffer->ossfragshift;
+
+	while (buffer->fragment_size * WAVEOUT_MINFRAGS > WAVEOUT_MAXBUFSIZE)
+		buffer->fragment_size >>= 1;
+
+	/* now we are sure that:
+	 (2^WAVEOUT_MINFRAGSHIFT) <= (fragment_size = 2^n) <= (WAVEOUT_MAXBUFSIZE / WAVEOUT_MINFRAGS)
+	*/
+
+	if (!buffer->numfrags) {
+		u32 numfrags;
+
+		numfrags = (woinst->format.bytespervoicesample * woinst->format.samplingrate * WAVEOUT_DEFAULTBUFLEN) /
+			   (buffer->fragment_size * 1000) - 1;
+
+		buffer->numfrags = 1;
+
+		while (numfrags) {
+			numfrags >>= 1;
+			buffer->numfrags <<= 1;
+		}
+	}
+
+	if (buffer->numfrags < WAVEOUT_MINFRAGS)
+		buffer->numfrags = WAVEOUT_MINFRAGS;
+
+	if (buffer->numfrags * buffer->fragment_size > WAVEOUT_MAXBUFSIZE)
+		buffer->numfrags = WAVEOUT_MAXBUFSIZE / buffer->fragment_size;
+
+	if (buffer->numfrags < WAVEOUT_MINFRAGS)
+		BUG();
+
+	buffer->size = buffer->fragment_size * buffer->numfrags;
+	buffer->pages = buffer->size / PAGE_SIZE + ((buffer->size % PAGE_SIZE) ? 1 : 0);
+
+	DPD(2, " calculated playback fragment_size -> %d\n", buffer->fragment_size);
+	DPD(2, " calculated playback numfrags -> %d\n", buffer->numfrags);
+
+	return;
+}
+
+static void calculate_ifrag(struct wiinst *wiinst)
+{
+	struct wavein_buffer *buffer = &wiinst->buffer;
+	u32 fragsize, bufsize, size[4];
+	int i, j;
+
+	if (buffer->fragment_size)
+		return;
+
+	if (!buffer->ossfragshift) {
+		fragsize = (wiinst->format.bytespersec * WAVEIN_DEFAULTFRAGLEN) / 1000 - 1;
+
+		while (fragsize) {
+			fragsize >>= 1;
+			buffer->ossfragshift++;
+		}
+	}
+
+	if (buffer->ossfragshift < WAVEIN_MINFRAGSHIFT)
+		buffer->ossfragshift = WAVEIN_MINFRAGSHIFT;
+
+	buffer->fragment_size = 1 << buffer->ossfragshift;
+
+	while (buffer->fragment_size * WAVEIN_MINFRAGS > WAVEIN_MAXBUFSIZE)
+		buffer->fragment_size >>= 1;
+
+	/* now we are sure that:
+	   (2^WAVEIN_MINFRAGSHIFT) <= (fragment_size = 2^n) <= (WAVEIN_MAXBUFSIZE / WAVEIN_MINFRAGS)
+        */
+
+	if (!buffer->numfrags)
+		buffer->numfrags = (wiinst->format.bytespersec * WAVEIN_DEFAULTBUFLEN) / (buffer->fragment_size * 1000) - 1;
+
+	if (buffer->numfrags < WAVEIN_MINFRAGS)
+		buffer->numfrags = WAVEIN_MINFRAGS;
+
+	if (buffer->numfrags * buffer->fragment_size > WAVEIN_MAXBUFSIZE)
+		buffer->numfrags = WAVEIN_MAXBUFSIZE / buffer->fragment_size;
+
+	if (buffer->numfrags < WAVEIN_MINFRAGS)
+		BUG();
+
+	bufsize = buffer->fragment_size * buffer->numfrags;
+
+	/* the buffer size for recording is restricted to certain values, adjust it now */
+	if (bufsize >= 0x10000) {
+		buffer->size = 0x10000;
+		buffer->sizeregval = 0x1f;
+	} else {
+		buffer->size = 0;
+		size[0] = 384;
+		size[1] = 448;
+		size[2] = 512;
+		size[3] = 640;
+
+		for (i = 0; i < 8; i++)
+			for (j = 0; j < 4; j++)
+				if (bufsize >= size[j]) {
+					buffer->size = size[j];
+					size[j] *= 2;
+					buffer->sizeregval = i * 4 + j + 1;
+				} else
+					goto exitloop;
+	      exitloop:
+		if (buffer->size == 0) {
+			buffer->size = 384;
+			buffer->sizeregval = 0x01;
+		}
+	}
+
+	/* adjust the fragment size so that buffer size is an integer multiple */
+	while (buffer->size % buffer->fragment_size)
+		buffer->fragment_size >>= 1;
+
+	buffer->numfrags = buffer->size / buffer->fragment_size;
+	buffer->pages =  buffer->size / PAGE_SIZE + ((buffer->size % PAGE_SIZE) ? 1 : 0);
+
+	DPD(2, " calculated recording fragment_size -> %d\n", buffer->fragment_size);
+	DPD(2, " calculated recording numfrags -> %d\n", buffer->numfrags);
+	DPD(2, " buffer size register -> %#04x\n", buffer->sizeregval);
+
+	return;
+}
+
+void emu10k1_wavein_bh(unsigned long refdata)
+{
+	struct emu10k1_wavedevice *wave_dev = (struct emu10k1_wavedevice *) refdata;
+	struct wiinst *wiinst = wave_dev->wiinst;
+	u32 bytestocopy;
+	unsigned long flags;
+
+	if (!wiinst)
+		return;
+
+	spin_lock_irqsave(&wiinst->lock, flags);
+
+	if (!(wiinst->state & WAVE_STATE_STARTED)) {
+		spin_unlock_irqrestore(&wiinst->lock, flags);
+		return;
+	}
+
+	emu10k1_wavein_update(wave_dev->card, wiinst);
+	emu10k1_wavein_getxfersize(wiinst, &bytestocopy);
+
+	spin_unlock_irqrestore(&wiinst->lock, flags);
+
+	if (bytestocopy >= wiinst->buffer.fragment_size) {
+	 	if (waitqueue_active(&wiinst->wait_queue))
+			wake_up_interruptible(&wiinst->wait_queue);
+	} else
+		DPD(3, "Not enough transfer size, %d\n", bytestocopy);
+
+	return;
+}
+
+void emu10k1_waveout_bh(unsigned long refdata)
+{
+	struct emu10k1_wavedevice *wave_dev = (struct emu10k1_wavedevice *) refdata;
+	struct woinst *woinst = wave_dev->woinst;
+	u32 bytestocopy;
+	unsigned long flags;
+
+	if (!woinst)
+		return;
+
+	spin_lock_irqsave(&woinst->lock, flags);
+
+	if (!(woinst->state & WAVE_STATE_STARTED)) {
+		spin_unlock_irqrestore(&woinst->lock, flags);
+		return;
+	}
+
+	emu10k1_waveout_update(woinst);
+	emu10k1_waveout_getxfersize(woinst, &bytestocopy);
+
+	if (woinst->buffer.fill_silence) {
+		spin_unlock_irqrestore(&woinst->lock, flags);
+		emu10k1_waveout_fillsilence(woinst);
+	} else
+		spin_unlock_irqrestore(&woinst->lock, flags);
+
+	if (bytestocopy >= woinst->buffer.fragment_size) {
+		if (waitqueue_active(&woinst->wait_queue))
+			wake_up_interruptible(&woinst->wait_queue);
+	} else
+		DPD(3, "Not enough transfer size -> %d\n", bytestocopy);
+
+	return;
+}
+
+struct file_operations emu10k1_audio_fops = {
+	owner:		THIS_MODULE,
+	llseek:		no_llseek,
+	read:		emu10k1_audio_read,
+	write:		emu10k1_audio_write,
+	poll:		emu10k1_audio_poll,
+	ioctl:		emu10k1_audio_ioctl,
+	mmap:		emu10k1_audio_mmap,
+	open:		emu10k1_audio_open,
+	release:	emu10k1_audio_release,
+};
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/audio.h patched/drivers/sound/audigy/audio.h
--- old/drivers/sound/audigy/audio.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/audio.h	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,47 @@
+/*
+ **********************************************************************
+ *     audio.c -- /dev/dsp interface for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *     November 2, 1999	    Alan Cox        cleaned up types/leaks
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#ifndef _AUDIO_H
+#define _AUDIO_H
+
+struct emu10k1_wavedevice
+{
+        struct emu10k1_card *card;
+        struct wiinst *wiinst;
+        struct woinst *woinst;
+        u16 enablebits;
+};
+
+void emu10k1_waveout_bh(unsigned long);
+void emu10k1_wavein_bh(unsigned long);
+
+#endif /* _AUDIO_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/cardmi.c patched/drivers/sound/audigy/cardmi.c
--- old/drivers/sound/audigy/cardmi.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/cardmi.c	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,817 @@
+/*
+ **********************************************************************
+ *     sblive_mi.c - MIDI UART input HAL for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *     November 2, 1999     Alan Cox        clean up
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#include <linux/slab.h>
+#include <linux/sched.h>
+
+#include "hwaccess.h"
+#include "8010.h"
+#include "cardmi.h"
+#include "irqmgr.h"
+
+static struct {
+	int (*Fn) (struct emu10k1_mpuin *, u8);
+} midistatefn[] = {
+
+	{
+	sblive_miStateParse}, {
+	sblive_miState3Byte},	/* 0x8n, 0x9n, 0xAn, 0xBn, 0xEn */
+	{
+	sblive_miState3ByteKey},	/* Byte 1                       */
+	{
+	sblive_miState3ByteVel},	/* Byte 2                       */
+	{
+	sblive_miState2Byte},	/* 0xCn, 0xDn                   */
+	{
+	sblive_miState2ByteKey},	/* Byte 1                       */
+	{
+	sblive_miStateSysCommon2},	/* 0xF1 , 0xF3                  */
+	{
+	sblive_miStateSysCommon2Key},	/* 0xF1 , 0xF3, Byte 1          */
+	{
+	sblive_miStateSysCommon3},	/* 0xF2                         */
+	{
+	sblive_miStateSysCommon3Key},	/* 0xF2 , Byte 1                */
+	{
+	sblive_miStateSysCommon3Vel},	/* 0xF2 , Byte 2                */
+	{
+	sblive_miStateSysExNorm},	/* 0xF0, 0xF7, Normal mode      */
+	{
+	sblive_miStateSysReal}	/* 0xF4 - 0xF6 ,0xF8 - 0xFF     */
+};
+
+/* Installs the IRQ handler for the MPU in port                 */
+
+/* and initialize parameters                                    */
+
+int emu10k1_mpuin_open(struct emu10k1_card *card, struct midi_openinfo *openinfo)
+{
+	struct emu10k1_mpuin *card_mpuin = card->mpuin;
+
+	DPF(2, "emu10k1_mpuin_open\n");
+
+	if (!(card_mpuin->status & FLAGS_AVAILABLE))
+		return -1;
+
+	/* Copy open info and mark channel as in use */
+	card_mpuin->openinfo = *openinfo;
+	card_mpuin->status &= ~FLAGS_AVAILABLE;	/* clear */
+	card_mpuin->status |= FLAGS_READY;	/* set */
+	card_mpuin->status &= ~FLAGS_MIDM_STARTED;	/* clear */
+	card_mpuin->firstmidiq = NULL;
+	card_mpuin->lastmidiq = NULL;
+	card_mpuin->qhead = 0;
+	card_mpuin->qtail = 0;
+
+	sblive_miStateInit(card_mpuin);
+
+	emu10k1_mpu_reset(card);
+	emu10k1_mpu_acquire(card);
+
+	return 0;
+}
+
+int emu10k1_mpuin_close(struct emu10k1_card *card)
+{
+	struct emu10k1_mpuin *card_mpuin = card->mpuin;
+
+	DPF(2, "emu10k1_mpuin_close()\n");
+
+	/* Check if there are pending input SysEx buffers */
+	if (card_mpuin->firstmidiq != NULL) {
+		ERROR();
+		return -1;
+	}
+
+	/* Disable RX interrupt */
+	emu10k1_irq_disable(card, card->is_audigy ? A_INTE_MIDIRXENABLE : INTE_MIDIRXENABLE);
+
+	emu10k1_mpu_release(card);
+
+	card_mpuin->status |= FLAGS_AVAILABLE;	/* set */
+	card_mpuin->status &= ~FLAGS_MIDM_STARTED;	/* clear */
+
+	return 0;
+}
+
+/* Adds MIDI buffer to local queue list                         */
+
+int emu10k1_mpuin_add_buffer(struct emu10k1_mpuin *card_mpuin, struct midi_hdr *midihdr)
+{
+	struct midi_queue *midiq;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_mpuin_add_buffer()\n");
+
+	/* Update MIDI buffer flags */
+	midihdr->flags |= MIDIBUF_INQUEUE;	/* set */
+	midihdr->flags &= ~MIDIBUF_DONE;	/* clear */
+
+	if ((midiq = (struct midi_queue *) kmalloc(sizeof(struct midi_queue), GFP_ATOMIC)) == NULL) {
+		/* Message lost */
+		return -1;
+	}
+
+	midiq->next = NULL;
+	midiq->qtype = 1;
+	midiq->length = midihdr->bufferlength;
+	midiq->sizeLeft = midihdr->bufferlength;
+	midiq->midibyte = midihdr->data;
+	midiq->refdata = (unsigned long) midihdr;
+
+	spin_lock_irqsave(&card_mpuin->lock, flags);
+
+	if (card_mpuin->firstmidiq == NULL) {
+		card_mpuin->firstmidiq = midiq;
+		card_mpuin->lastmidiq = midiq;
+	} else {
+		(card_mpuin->lastmidiq)->next = midiq;
+		card_mpuin->lastmidiq = midiq;
+	}
+
+	spin_unlock_irqrestore(&card_mpuin->lock, flags);
+
+	return 0;
+}
+
+/* First set the Time Stamp if MIDI IN has not started.         */
+
+/* Then enable RX Irq.                                          */
+
+int emu10k1_mpuin_start(struct emu10k1_card *card)
+{
+	struct emu10k1_mpuin *card_mpuin = card->mpuin;
+	u8 dummy;
+
+	DPF(2, "emu10k1_mpuin_start()\n");
+
+	/* Set timestamp if not set */
+	if (card_mpuin->status & FLAGS_MIDM_STARTED) {
+		DPF(2, "Time Stamp not changed\n");
+	} else {
+		while (!emu10k1_mpu_read_data(card, &dummy));
+
+		card_mpuin->status |= FLAGS_MIDM_STARTED;	/* set */
+
+		/* Set new time stamp */
+		card_mpuin->timestart = (jiffies * 1000) / HZ;
+		DPD(2, "New Time Stamp = %d\n", card_mpuin->timestart);
+
+		card_mpuin->qhead = 0;
+		card_mpuin->qtail = 0;
+
+		emu10k1_irq_enable(card, card->is_audigy ? A_INTE_MIDIRXENABLE : INTE_MIDIRXENABLE);
+	}
+
+	return 0;
+}
+
+/* Disable the RX Irq.  If a partial recorded buffer            */
+
+/* exist, send it up to IMIDI level.                            */
+
+int emu10k1_mpuin_stop(struct emu10k1_card *card)
+{
+	struct emu10k1_mpuin *card_mpuin = card->mpuin;
+	struct midi_queue *midiq;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_mpuin_stop()\n");
+
+	emu10k1_irq_disable(card, card->is_audigy ? A_INTE_MIDIRXENABLE : INTE_MIDIRXENABLE);
+
+	card_mpuin->status &= ~FLAGS_MIDM_STARTED;	/* clear */
+
+	if (card_mpuin->firstmidiq) {
+		spin_lock_irqsave(&card_mpuin->lock, flags);
+
+		midiq = card_mpuin->firstmidiq;
+		if (midiq != NULL) {
+			if (midiq->sizeLeft == midiq->length)
+				midiq = NULL;
+			else {
+				card_mpuin->firstmidiq = midiq->next;
+				if (card_mpuin->firstmidiq == NULL)
+					card_mpuin->lastmidiq = NULL;
+			}
+		}
+
+		spin_unlock_irqrestore(&card_mpuin->lock, flags);
+
+		if (midiq) {
+			emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INLONGERROR, (unsigned long) midiq, 0);
+			kfree(midiq);
+		}
+	}
+
+	return 0;
+}
+
+/* Disable the RX Irq.  If any buffer                           */
+
+/* exist, send it up to IMIDI level.                            */
+int emu10k1_mpuin_reset(struct emu10k1_card *card)
+{
+	struct emu10k1_mpuin *card_mpuin = card->mpuin;
+	struct midi_queue *midiq;
+
+	DPF(2, "emu10k1_mpuin_reset()\n");
+
+	emu10k1_irq_disable(card, card->is_audigy ? A_INTE_MIDIRXENABLE : INTE_MIDIRXENABLE);
+
+	while (card_mpuin->firstmidiq) {
+		midiq = card_mpuin->firstmidiq;
+		card_mpuin->firstmidiq = midiq->next;
+
+		if (midiq->sizeLeft == midiq->length)
+			emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INLONGDATA, (unsigned long) midiq, 0);
+		else
+			emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INLONGERROR, (unsigned long) midiq, 0);
+
+		kfree(midiq);
+	}
+
+	card_mpuin->lastmidiq = NULL;
+	card_mpuin->status &= ~FLAGS_MIDM_STARTED;
+
+	return 0;
+}
+
+/* Passes the message with the data back to the client          */
+
+/* via IRQ & DPC callbacks to Ring 3                            */
+int emu10k1_mpuin_callback(struct emu10k1_mpuin *card_mpuin, u32 msg, unsigned long data, u32 bytesvalid)
+{
+	unsigned long timein;
+	struct midi_queue *midiq;
+	unsigned long callback_msg[3];
+	struct midi_hdr *midihdr;
+
+	/* Called during ISR. The data & code touched are:
+	 * 1. card_mpuin
+	 * 2. The function to be called
+	 */
+
+	timein = card_mpuin->timein;
+	if (card_mpuin->timestart <= timein)
+		callback_msg[0] = timein - card_mpuin->timestart;
+	else
+		callback_msg[0] = (~0x0L - card_mpuin->timestart) + timein;
+
+	if (msg == ICARDMIDI_INDATA || msg == ICARDMIDI_INDATAERROR) {
+		callback_msg[1] = data;
+		callback_msg[2] = bytesvalid;
+		DPD(2, "emu10k1_mpuin_callback: midimsg = %#lx\n", data);
+	} else {
+		midiq = (struct midi_queue *) data;
+		midihdr = (struct midi_hdr *) midiq->refdata;
+
+		callback_msg[1] = midiq->length - midiq->sizeLeft;
+		callback_msg[2] = midiq->refdata;
+		midihdr->flags &= ~MIDIBUF_INQUEUE;
+		midihdr->flags |= MIDIBUF_DONE;
+
+		midihdr->bytesrecorded = midiq->length - midiq->sizeLeft;
+	}
+
+	/* Notify client that Sysex buffer has been sent */
+	emu10k1_midi_callback(msg, card_mpuin->openinfo.refdata, callback_msg);
+
+	return 0;
+}
+
+void emu10k1_mpuin_bh(unsigned long refdata)
+{
+	u8 data;
+	unsigned idx;
+	struct emu10k1_mpuin *card_mpuin = (struct emu10k1_mpuin *) refdata;
+	unsigned long flags;
+
+	while (card_mpuin->qhead != card_mpuin->qtail) {
+		spin_lock_irqsave(&card_mpuin->lock, flags);
+		idx = card_mpuin->qhead;
+		data = card_mpuin->midiq[idx].data;
+		card_mpuin->timein = card_mpuin->midiq[idx].timein;
+		idx = (idx + 1) % MIDIIN_MAX_BUFFER_SIZE;
+		card_mpuin->qhead = idx;
+		spin_unlock_irqrestore(&card_mpuin->lock, flags);
+
+		sblive_miStateEntry(card_mpuin, data);
+	}
+
+	return;
+}
+
+/* IRQ callback handler routine for the MPU in port */
+
+int emu10k1_mpuin_irqhandler(struct emu10k1_card *card)
+{
+	unsigned idx;
+	unsigned count;
+	u8 MPUIvalue;
+	struct emu10k1_mpuin *card_mpuin = card->mpuin;
+
+	/* IRQ service routine. The data and code touched are:
+	 * 1. card_mpuin
+	 */
+
+	count = 0;
+	idx = card_mpuin->qtail;
+
+	while (1) {
+		if (emu10k1_mpu_read_data(card, &MPUIvalue) < 0) {
+			break;
+		} else {
+			++count;
+			card_mpuin->midiq[idx].data = MPUIvalue;
+			card_mpuin->midiq[idx].timein = (jiffies * 1000) / HZ;
+			idx = (idx + 1) % MIDIIN_MAX_BUFFER_SIZE;
+		}
+	}
+
+	if (count) {
+		card_mpuin->qtail = idx;
+
+		tasklet_hi_schedule(&card_mpuin->tasklet);
+	}
+
+	return 0;
+}
+
+/*****************************************************************************/
+
+/*   Supporting functions for Midi-In Interpretation State Machine           */
+
+/*****************************************************************************/
+
+/* FIXME: This should be a macro */
+int sblive_miStateInit(struct emu10k1_mpuin *card_mpuin)
+{
+	card_mpuin->status = 0;	/* For MIDI running status */
+	card_mpuin->fstatus = 0;	/* For 0xFn status only */
+	card_mpuin->curstate = STIN_PARSE;
+	card_mpuin->laststate = STIN_PARSE;
+	card_mpuin->data = 0;
+	card_mpuin->timestart = 0;
+	card_mpuin->timein = 0;
+
+	return 0;
+}
+
+/* FIXME: This should be a macro */
+int sblive_miStateEntry(struct emu10k1_mpuin *card_mpuin, u8 data)
+{
+	return midistatefn[card_mpuin->curstate].Fn(card_mpuin, data);
+}
+
+int sblive_miStateParse(struct emu10k1_mpuin *card_mpuin, u8 data)
+{
+	switch (data & 0xf0) {
+	case 0x80:
+	case 0x90:
+	case 0xA0:
+	case 0xB0:
+	case 0xE0:
+		card_mpuin->curstate = STIN_3BYTE;
+		break;
+
+	case 0xC0:
+	case 0xD0:
+		card_mpuin->curstate = STIN_2BYTE;
+		break;
+
+	case 0xF0:
+		/* System messages do not affect the previous running status! */
+		switch (data & 0x0f) {
+		case 0x0:
+			card_mpuin->laststate = card_mpuin->curstate;
+			card_mpuin->curstate = STIN_SYS_EX_NORM;
+
+			if (card_mpuin->firstmidiq) {
+				struct midi_queue *midiq;
+
+				midiq = card_mpuin->firstmidiq;
+				*midiq->midibyte = data;
+				--midiq->sizeLeft;
+				++midiq->midibyte;
+			}
+
+			return CTSTATUS_NEXT_BYTE;
+
+		case 0x7:
+			emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATAERROR, 0xf7, 0);
+			return -1;
+
+		case 0x2:
+			card_mpuin->laststate = card_mpuin->curstate;
+			card_mpuin->curstate = STIN_SYS_COMMON_3;
+			break;
+
+		case 0x1:
+		case 0x3:
+			card_mpuin->laststate = card_mpuin->curstate;
+			card_mpuin->curstate = STIN_SYS_COMMON_2;
+			break;
+
+		default:
+			/* includes 0xF4 - 0xF6, 0xF8 - 0xFF */
+			return midistatefn[STIN_SYS_REAL].Fn(card_mpuin, data);
+		}
+
+		break;
+
+	default:
+		DPF(2, "BUG: default case hit\n");
+		return -1;
+	}
+
+	return midistatefn[card_mpuin->curstate].Fn(card_mpuin, data);
+}
+
+int sblive_miState3Byte(struct emu10k1_mpuin *card_mpuin, u8 data)
+{
+	u8 temp = data & 0xf0;
+
+	if (temp < 0x80) {
+		return midistatefn[STIN_3BYTE_KEY].Fn(card_mpuin, data);
+	} else if (temp <= 0xe0 && temp != 0xc0 && temp != 0xd0) {
+		card_mpuin->status = data;
+		card_mpuin->curstate = STIN_3BYTE_KEY;
+
+		return CTSTATUS_NEXT_BYTE;
+	}
+
+	return midistatefn[STIN_PARSE].Fn(card_mpuin, data);
+}
+
+int sblive_miState3ByteKey(struct emu10k1_mpuin *card_mpuin, u8 data)
+
+/* byte 1 */
+{
+	unsigned long tmp;
+
+	if (data > 0x7f) {
+		/* Real-time messages check */
+		if (data > 0xf7)
+			return midistatefn[STIN_SYS_REAL].Fn(card_mpuin, data);
+
+		/* Invalid data! */
+		DPF(2, "Invalid data!\n");
+
+		card_mpuin->curstate = STIN_PARSE;
+		tmp = ((unsigned long) data) << 8;
+		tmp |= (unsigned long) card_mpuin->status;
+
+		emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATAERROR, tmp, 0);
+
+		return -1;
+	}
+
+	card_mpuin->data = data;
+	card_mpuin->curstate = STIN_3BYTE_VEL;
+
+	return CTSTATUS_NEXT_BYTE;
+}
+
+int sblive_miState3ByteVel(struct emu10k1_mpuin *card_mpuin, u8 data)
+
+/* byte 2 */
+{
+	unsigned long tmp;
+
+	if (data > 0x7f) {
+		/* Real-time messages check */
+		if (data > 0xf7)
+			return midistatefn[STIN_SYS_REAL].Fn(card_mpuin, data);
+
+		/* Invalid data! */
+		DPF(2, "Invalid data!\n");
+
+		card_mpuin->curstate = STIN_PARSE;
+		tmp = ((unsigned long) data) << 8;
+		tmp |= card_mpuin->data;
+		tmp = tmp << 8;
+		tmp |= (unsigned long) card_mpuin->status;
+
+		emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATAERROR, tmp, 0);
+
+		return -1;
+	}
+
+	card_mpuin->curstate = STIN_3BYTE;
+	tmp = (unsigned long) data;
+	tmp = tmp << 8;
+	tmp |= (unsigned long) card_mpuin->data;
+	tmp = tmp << 8;
+	tmp |= (unsigned long) card_mpuin->status;
+
+	emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATA, tmp, 3);
+
+	return 0;
+}
+
+int sblive_miState2Byte(struct emu10k1_mpuin *card_mpuin, u8 data)
+{
+	u8 temp = data & 0xf0;
+
+	if ((temp == 0xc0) || (temp == 0xd0)) {
+		card_mpuin->status = data;
+		card_mpuin->curstate = STIN_2BYTE_KEY;
+
+		return CTSTATUS_NEXT_BYTE;
+	}
+
+	if (temp < 0x80)
+		return midistatefn[STIN_2BYTE_KEY].Fn(card_mpuin, data);
+
+	return midistatefn[STIN_PARSE].Fn(card_mpuin, data);
+}
+
+int sblive_miState2ByteKey(struct emu10k1_mpuin *card_mpuin, u8 data)
+
+/* byte 1 */
+{
+	unsigned long tmp;
+
+	if (data > 0x7f) {
+		/* Real-time messages check */
+		if (data > 0xf7)
+			return midistatefn[STIN_SYS_REAL].Fn(card_mpuin, data);
+
+		/* Invalid data! */
+		DPF(2, "Invalid data!\n");
+
+		card_mpuin->curstate = STIN_PARSE;
+		tmp = (unsigned long) data;
+		tmp = tmp << 8;
+		tmp |= (unsigned long) card_mpuin->status;
+
+		emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATAERROR, tmp, 0);
+
+		return -1;
+	}
+
+	card_mpuin->curstate = STIN_2BYTE;
+	tmp = (unsigned long) data;
+	tmp = tmp << 8;
+	tmp |= (unsigned long) card_mpuin->status;
+
+	emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATA, tmp, 2);
+
+	return 0;
+}
+
+int sblive_miStateSysCommon2(struct emu10k1_mpuin *card_mpuin, u8 data)
+{
+	card_mpuin->fstatus = data;
+	card_mpuin->curstate = STIN_SYS_COMMON_2_KEY;
+
+	return CTSTATUS_NEXT_BYTE;
+}
+
+int sblive_miStateSysCommon2Key(struct emu10k1_mpuin *card_mpuin, u8 data)
+
+/* byte 1 */
+{
+	unsigned long tmp;
+
+	if (data > 0x7f) {
+		/* Real-time messages check */
+		if (data > 0xf7)
+			return midistatefn[STIN_SYS_REAL].Fn(card_mpuin, data);
+
+		/* Invalid data! */
+		DPF(2, "Invalid data!\n");
+
+		card_mpuin->curstate = card_mpuin->laststate;
+		tmp = (unsigned long) data;
+		tmp = tmp << 8;
+		tmp |= (unsigned long) card_mpuin->fstatus;
+
+		emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATAERROR, tmp, 0);
+
+		return -1;
+	}
+
+	card_mpuin->curstate = card_mpuin->laststate;
+	tmp = (unsigned long) data;
+	tmp = tmp << 8;
+	tmp |= (unsigned long) card_mpuin->fstatus;
+
+	emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATA, tmp, 2);
+
+	return 0;
+}
+
+int sblive_miStateSysCommon3(struct emu10k1_mpuin *card_mpuin, u8 data)
+{
+	card_mpuin->fstatus = data;
+	card_mpuin->curstate = STIN_SYS_COMMON_3_KEY;
+
+	return CTSTATUS_NEXT_BYTE;
+}
+
+int sblive_miStateSysCommon3Key(struct emu10k1_mpuin *card_mpuin, u8 data)
+
+/* byte 1 */
+{
+	unsigned long tmp;
+
+	if (data > 0x7f) {
+		/* Real-time messages check */
+		if (data > 0xf7)
+			return midistatefn[STIN_SYS_REAL].Fn(card_mpuin, data);
+
+		/* Invalid data! */
+		DPF(2, "Invalid data!\n");
+
+		card_mpuin->curstate = card_mpuin->laststate;
+		tmp = (unsigned long) data;
+		tmp = tmp << 8;
+		tmp |= (unsigned long) card_mpuin->fstatus;
+
+		emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATAERROR, tmp, 0);
+
+		return -1;
+	}
+
+	card_mpuin->data = data;
+	card_mpuin->curstate = STIN_SYS_COMMON_3_VEL;
+
+	return CTSTATUS_NEXT_BYTE;
+}
+
+int sblive_miStateSysCommon3Vel(struct emu10k1_mpuin *card_mpuin, u8 data)
+
+/* byte 2 */
+{
+	unsigned long tmp;
+
+	if (data > 0x7f) {
+		/* Real-time messages check */
+		if (data > 0xf7)
+			return midistatefn[STIN_SYS_REAL].Fn(card_mpuin, data);
+
+		/* Invalid data! */
+		DPF(2, "Invalid data!\n");
+
+		card_mpuin->curstate = card_mpuin->laststate;
+		tmp = (unsigned long) data;
+		tmp = tmp << 8;
+		tmp |= (unsigned long) card_mpuin->data;
+		tmp = tmp << 8;
+		tmp |= (unsigned long) card_mpuin->fstatus;
+
+		emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATAERROR, tmp, 0);
+
+		return -1;
+	}
+
+	card_mpuin->curstate = card_mpuin->laststate;
+	tmp = (unsigned long) data;
+	tmp = tmp << 8;
+	tmp |= (unsigned long) card_mpuin->data;
+	tmp = tmp << 8;
+	tmp |= (unsigned long) card_mpuin->fstatus;
+
+	emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATA, tmp, 3);
+
+	return 0;
+}
+
+int sblive_miStateSysExNorm(struct emu10k1_mpuin *card_mpuin, u8 data)
+{
+	unsigned long flags;
+
+	if ((data > 0x7f) && (data != 0xf7)) {
+		/* Real-time messages check */
+		if (data > 0xf7)
+			return midistatefn[STIN_SYS_REAL].Fn(card_mpuin, data);
+
+		/* Invalid Data! */
+		DPF(2, "Invalid data!\n");
+
+		card_mpuin->curstate = card_mpuin->laststate;
+
+		if (card_mpuin->firstmidiq) {
+			struct midi_queue *midiq;
+
+			midiq = card_mpuin->firstmidiq;
+			*midiq->midibyte = data;
+			--midiq->sizeLeft;
+			++midiq->midibyte;
+
+			spin_lock_irqsave(&card_mpuin->lock, flags);
+
+			card_mpuin->firstmidiq = midiq->next;
+			if (card_mpuin->firstmidiq == NULL)
+				card_mpuin->lastmidiq = NULL;
+
+			spin_unlock_irqrestore(&card_mpuin->lock, flags);
+
+			emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INLONGERROR, (unsigned long) midiq, 0);
+
+			kfree(midiq);
+		}
+
+		return -1;
+	}
+
+	if (card_mpuin->firstmidiq) {
+		struct midi_queue *midiq;
+
+		midiq = card_mpuin->firstmidiq;
+		*midiq->midibyte = data;
+		--midiq->sizeLeft;
+		++midiq->midibyte;
+	}
+
+	if (data == 0xf7) {
+		/* End of Sysex buffer */
+		/* Send down the buffer */
+
+		card_mpuin->curstate = card_mpuin->laststate;
+
+		if (card_mpuin->firstmidiq) {
+			struct midi_queue *midiq;
+
+			midiq = card_mpuin->firstmidiq;
+
+			spin_lock_irqsave(&card_mpuin->lock, flags);
+
+			card_mpuin->firstmidiq = midiq->next;
+			if (card_mpuin->firstmidiq == NULL)
+				card_mpuin->lastmidiq = NULL;
+
+			spin_unlock_irqrestore(&card_mpuin->lock, flags);
+
+			emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INLONGDATA, (unsigned long) midiq, 0);
+
+			kfree(midiq);
+		}
+
+		return 0;
+	}
+
+	if (card_mpuin->firstmidiq) {
+		struct midi_queue *midiq;
+
+		midiq = card_mpuin->firstmidiq;
+
+		if (midiq->sizeLeft == 0) {
+			/* Special case */
+
+			spin_lock_irqsave(&card_mpuin->lock, flags);
+
+			card_mpuin->firstmidiq = midiq->next;
+			if (card_mpuin->firstmidiq == NULL)
+				card_mpuin->lastmidiq = NULL;
+
+			spin_unlock_irqrestore(&card_mpuin->lock, flags);
+
+			emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INLONGDATA, (unsigned long) midiq, 0);
+
+			kfree(midiq);
+
+			return CTSTATUS_NEXT_BYTE;
+		}
+	}
+
+	return CTSTATUS_NEXT_BYTE;
+}
+
+int sblive_miStateSysReal(struct emu10k1_mpuin *card_mpuin, u8 data)
+{
+	emu10k1_mpuin_callback(card_mpuin, ICARDMIDI_INDATA, data, 1);
+
+	return CTSTATUS_NEXT_BYTE;
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/cardmi.h patched/drivers/sound/audigy/cardmi.h
--- old/drivers/sound/audigy/cardmi.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/cardmi.h	2003-07-22 21:52:40.000000000 +0300
@@ -0,0 +1,114 @@
+/*
+ **********************************************************************
+ *     sblive_mi.h
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *     November 2, 1999     Alan Cox        cleaned up
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#ifndef _CARDMI_H
+#define _CARDMI_H
+
+#include "icardmid.h"
+#include <linux/interrupt.h>
+
+typedef enum
+{
+	STIN_PARSE = 0,
+	STIN_3BYTE,                     /* 0x80, 0x90, 0xA0, 0xB0, 0xE0 */
+	STIN_3BYTE_KEY,                 /* Byte 1 */
+	STIN_3BYTE_VEL,                 /* Byte 1 */
+	STIN_2BYTE,                     /* 0xC0, 0xD0 */
+	STIN_2BYTE_KEY,                 /* Byte 1 */
+	STIN_SYS_COMMON_2,              /* 0xF1, 0xF3  */
+	STIN_SYS_COMMON_2_KEY,
+	STIN_SYS_COMMON_3,              /* 0xF2 */
+	STIN_SYS_COMMON_3_KEY,
+	STIN_SYS_COMMON_3_VEL,
+	STIN_SYS_EX_NORM,               /* 0xF0, Normal mode */
+	STIN_SYS_REAL
+} midi_in_state;
+
+
+/* flags for card MIDI in object */
+#define FLAGS_MIDM_STARTED          0x00001000      // Data has started to come in after Midm Start
+#define MIDIIN_MAX_BUFFER_SIZE      200             // Definition for struct emu10k1_mpuin
+
+struct midi_data
+{
+	u8 data;
+	u32 timein;
+};
+
+struct emu10k1_mpuin
+{
+	spinlock_t        lock;
+	struct midi_queue *firstmidiq;
+	struct midi_queue *lastmidiq;
+	unsigned          qhead, qtail;
+	struct midi_data  midiq[MIDIIN_MAX_BUFFER_SIZE];
+	struct tasklet_struct tasklet;
+	struct midi_openinfo    openinfo;
+
+	/* For MIDI state machine */
+	u8              status;        /* For MIDI running status */
+	u8              fstatus;       /* For 0xFn status only */
+	midi_in_state   curstate;
+	midi_in_state   laststate;
+	u32             timestart;
+	u32             timein;
+	u8              data;
+};
+
+int emu10k1_mpuin_open(struct emu10k1_card *, struct midi_openinfo *);
+int emu10k1_mpuin_close(struct emu10k1_card *);
+int emu10k1_mpuin_add_buffer(struct emu10k1_mpuin *, struct midi_hdr *);
+int emu10k1_mpuin_start(struct emu10k1_card *);
+int emu10k1_mpuin_stop(struct emu10k1_card *);
+int emu10k1_mpuin_reset(struct emu10k1_card *);
+
+int sblive_miStateInit(struct emu10k1_mpuin *);
+int sblive_miStateEntry(struct emu10k1_mpuin *, u8);
+int sblive_miStateParse(struct emu10k1_mpuin *, u8);
+int sblive_miState3Byte(struct emu10k1_mpuin *, u8);
+int sblive_miState3ByteKey(struct emu10k1_mpuin *, u8);
+int sblive_miState3ByteVel(struct emu10k1_mpuin *, u8);
+int sblive_miState2Byte(struct emu10k1_mpuin *, u8);
+int sblive_miState2ByteKey(struct emu10k1_mpuin *, u8);
+int sblive_miStateSysCommon2(struct emu10k1_mpuin *, u8);
+int sblive_miStateSysCommon2Key(struct emu10k1_mpuin *, u8);
+int sblive_miStateSysCommon3(struct emu10k1_mpuin *, u8);
+int sblive_miStateSysCommon3Key(struct emu10k1_mpuin *, u8);
+int sblive_miStateSysCommon3Vel(struct emu10k1_mpuin *, u8);
+int sblive_miStateSysExNorm(struct emu10k1_mpuin *, u8);
+int sblive_miStateSysReal(struct emu10k1_mpuin *, u8);
+
+int emu10k1_mpuin_irqhandler(struct emu10k1_card *);
+void emu10k1_mpuin_bh(unsigned long);
+int emu10k1_mpuin_callback(struct emu10k1_mpuin *card_mpuin, u32 msg, unsigned long data, u32 bytesvalid);
+
+#endif  /* _CARDMI_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/cardmo.c patched/drivers/sound/audigy/cardmo.c
--- old/drivers/sound/audigy/cardmo.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/cardmo.c	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,229 @@
+/*     
+ **********************************************************************
+ *     cardmo.c - MIDI UART output HAL for emu10k1 driver 
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     Date                 Author          Summary of changes 
+ *     ----                 ------          ------------------ 
+ *     October 20, 1999     Bertrand Lee    base code release 
+ *     November 2, 1999     Alan Cox        cleaned up
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */
+
+#include <linux/slab.h>
+
+#include "hwaccess.h"
+#include "8010.h"
+#include "cardmo.h"
+#include "irqmgr.h"
+
+/* Installs the IRQ handler for the MPU out port               *
+ * and initialize parameters                                    */
+
+int emu10k1_mpuout_open(struct emu10k1_card *card, struct midi_openinfo *openinfo)
+{
+	struct emu10k1_mpuout *card_mpuout = card->mpuout;
+
+	DPF(2, "emu10k1_mpuout_open()\n");
+
+	if (!(card_mpuout->status & FLAGS_AVAILABLE))
+		return -1;
+
+	/* Copy open info and mark channel as in use */
+	card_mpuout->intr = 0;
+	card_mpuout->openinfo = *openinfo;
+	card_mpuout->status &= ~FLAGS_AVAILABLE;
+	card_mpuout->laststatus = 0x80;
+	card_mpuout->firstmidiq = NULL;
+	card_mpuout->lastmidiq = NULL;
+
+	emu10k1_mpu_reset(card);
+	emu10k1_mpu_acquire(card);
+
+	return 0;
+}
+
+int emu10k1_mpuout_close(struct emu10k1_card *card)
+{
+	struct emu10k1_mpuout *card_mpuout = card->mpuout;
+	struct midi_queue *midiq;
+	struct midi_hdr *midihdr;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_mpuout_close()\n");
+
+	emu10k1_irq_disable(card, card->is_audigy ? A_INTE_MIDITXENABLE : INTE_MIDITXENABLE);
+
+	spin_lock_irqsave(&card_mpuout->lock, flags);
+
+	while (card_mpuout->firstmidiq != NULL) {
+		midiq = card_mpuout->firstmidiq;
+		midihdr = (struct midi_hdr *) midiq->refdata;
+
+		card_mpuout->firstmidiq = midiq->next;
+
+		kfree(midihdr->data);
+		kfree(midihdr);
+		kfree(midiq);
+	}
+
+	card_mpuout->lastmidiq = NULL;
+
+	emu10k1_mpu_release(card);
+
+	card_mpuout->status |= FLAGS_AVAILABLE;
+
+	spin_unlock_irqrestore(&card_mpuout->lock, flags);
+
+	return 0;
+}
+
+/* If there isn't enough buffer space, reject Midi Buffer.     *
+* Otherwise, disable TX, create object to hold Midi            *
+*  uffer, update buffer flags and other parameters             *
+* before enabling TX again.                                    */
+
+int emu10k1_mpuout_add_buffer(struct emu10k1_card *card, struct midi_hdr *midihdr)
+{
+	struct emu10k1_mpuout *card_mpuout = card->mpuout;
+	struct midi_queue *midiq;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_mpuout_add_buffer()\n");
+
+	if (card_mpuout->state == CARDMIDIOUT_STATE_SUSPEND)
+		return 0;
+
+	midihdr->flags |= MIDIBUF_INQUEUE;
+	midihdr->flags &= ~MIDIBUF_DONE;
+
+	if ((midiq = (struct midi_queue *) kmalloc(sizeof(struct midi_queue), GFP_KERNEL)) == NULL) {
+		/* Message lost */
+		return -1;
+	}
+
+	midiq->next = NULL;
+	midiq->qtype = 1;
+	midiq->length = midihdr->bufferlength;
+	midiq->sizeLeft = midihdr->bufferlength;
+	midiq->midibyte = midihdr->data;
+
+	midiq->refdata = (unsigned long) midihdr;
+
+	spin_lock_irqsave(&card_mpuout->lock, flags);
+
+	if (card_mpuout->firstmidiq == NULL) {
+		card_mpuout->firstmidiq = midiq;
+		card_mpuout->lastmidiq = midiq;
+	} else {
+		(card_mpuout->lastmidiq)->next = midiq;
+		card_mpuout->lastmidiq = midiq;
+	}
+
+	card_mpuout->intr = 0;
+
+	emu10k1_irq_enable(card, card->is_audigy ? A_INTE_MIDITXENABLE : INTE_MIDITXENABLE);
+
+	spin_unlock_irqrestore(&card_mpuout->lock, flags);
+
+	return 0;
+}
+
+void emu10k1_mpuout_bh(unsigned long refdata)
+{
+	struct emu10k1_card *card = (struct emu10k1_card *) refdata;
+	struct emu10k1_mpuout *card_mpuout = card->mpuout;
+	int cByteSent = 0;
+	struct midi_queue *midiq;
+	struct midi_queue *doneq = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&card_mpuout->lock, flags);
+
+	while (card_mpuout->firstmidiq != NULL) {
+		midiq = card_mpuout->firstmidiq;
+
+		while (cByteSent < 4 && midiq->sizeLeft) {
+			if (emu10k1_mpu_write_data(card, *midiq->midibyte) < 0) {
+				DPF(2, "emu10k1_mpuoutDpcCallback error!!\n");
+			} else {
+				++cByteSent;
+				--midiq->sizeLeft;
+				++midiq->midibyte;
+			}
+		}
+
+		if (midiq->sizeLeft == 0) {
+			if (doneq == NULL)
+				doneq = midiq;
+			card_mpuout->firstmidiq = midiq->next;
+		} else
+			break;
+	}
+
+	if (card_mpuout->firstmidiq == NULL)
+		card_mpuout->lastmidiq = NULL;
+
+	if (doneq != NULL) {
+		while (doneq != card_mpuout->firstmidiq) {
+			unsigned long callback_msg[3];
+
+			midiq = doneq;
+			doneq = midiq->next;
+
+			if (midiq->qtype) {
+				callback_msg[0] = 0;
+				callback_msg[1] = midiq->length;
+				callback_msg[2] = midiq->refdata;
+
+				emu10k1_midi_callback(ICARDMIDI_OUTLONGDATA, card_mpuout->openinfo.refdata, callback_msg);
+			} else if (((u8) midiq->refdata) < 0xF0 && ((u8) midiq->refdata) > 0x7F)
+				card_mpuout->laststatus = (u8) midiq->refdata;
+
+			kfree(midiq);
+		}
+	}
+
+	if ((card_mpuout->firstmidiq != NULL) || cByteSent) {
+		card_mpuout->intr = 0;
+		emu10k1_irq_enable(card, card->is_audigy ? A_INTE_MIDITXENABLE : INTE_MIDITXENABLE);
+	}
+
+	spin_unlock_irqrestore(&card_mpuout->lock, flags);
+
+	return;
+}
+
+int emu10k1_mpuout_irqhandler(struct emu10k1_card *card)
+{
+	struct emu10k1_mpuout *card_mpuout = card->mpuout;
+
+	DPF(4, "emu10k1_mpuout_irqhandler\n");
+
+	card_mpuout->intr = 1;
+	emu10k1_irq_disable(card, card->is_audigy ? A_INTE_MIDITXENABLE : INTE_MIDITXENABLE);
+
+	tasklet_hi_schedule(&card_mpuout->tasklet);
+
+	return 0;
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/cardmo.h patched/drivers/sound/audigy/cardmo.h
--- old/drivers/sound/audigy/cardmo.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/cardmo.h	2003-07-22 21:52:40.000000000 +0300
@@ -0,0 +1,62 @@
+/*
+ **********************************************************************
+ *     cardmo.h
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *     November 2, 1999     Alan Cox	    cleaned up
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#ifndef _CARDMO_H
+#define _CARDMO_H
+
+#include "icardmid.h"
+#include <linux/interrupt.h>
+
+#define CARDMIDIOUT_STATE_DEFAULT    0x00000000
+#define CARDMIDIOUT_STATE_SUSPEND    0x00000001
+
+struct emu10k1_mpuout
+{
+	u32			status;
+	u32			state;
+	volatile int		intr;
+	struct midi_queue	*firstmidiq;
+	struct midi_queue	*lastmidiq;
+	u8			laststatus;
+	struct tasklet_struct 	tasklet;
+	spinlock_t		lock;
+	struct midi_openinfo	openinfo;
+};
+
+int emu10k1_mpuout_open(struct emu10k1_card *, struct midi_openinfo *);
+int emu10k1_mpuout_close(struct emu10k1_card *);
+int emu10k1_mpuout_add_buffer(struct emu10k1_card *, struct midi_hdr *);
+
+int emu10k1_mpuout_irqhandler(struct emu10k1_card *);
+void emu10k1_mpuout_bh(unsigned long);
+
+#endif  /* _CARDMO_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/cardwi.c patched/drivers/sound/audigy/cardwi.c
--- old/drivers/sound/audigy/cardwi.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/cardwi.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,374 @@
+/*
+ **********************************************************************
+ *     cardwi.c - PCM input HAL for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#include <linux/poll.h>
+#include "hwaccess.h"
+#include "timer.h"
+#include "recmgr.h"
+#include "audio.h"
+#include "cardwi.h"
+
+/**
+ * query_format - returns a valid sound format
+ *
+ * This function will return a valid sound format as close
+ * to the requested one as possible. 
+ */
+void query_format(int recsrc, struct wave_format *wave_fmt)
+{
+
+	switch (recsrc) {
+	case WAVERECORD_AC97:
+
+		if ((wave_fmt->channels != 1) && (wave_fmt->channels != 2))
+			wave_fmt->channels = 2;
+
+		if (wave_fmt->samplingrate >= (0xBB80 + 0xAC44) / 2)
+			wave_fmt->samplingrate = 0xBB80;
+		else if (wave_fmt->samplingrate >= (0xAC44 + 0x7D00) / 2)
+			wave_fmt->samplingrate = 0xAC44;
+		else if (wave_fmt->samplingrate >= (0x7D00 + 0x5DC0) / 2)
+			wave_fmt->samplingrate = 0x7D00;
+		else if (wave_fmt->samplingrate >= (0x5DC0 + 0x5622) / 2)
+			wave_fmt->samplingrate = 0x5DC0;
+		else if (wave_fmt->samplingrate >= (0x5622 + 0x3E80) / 2)
+			wave_fmt->samplingrate = 0x5622;
+		else if (wave_fmt->samplingrate >= (0x3E80 + 0x2B11) / 2)
+			wave_fmt->samplingrate = 0x3E80;
+		else if (wave_fmt->samplingrate >= (0x2B11 + 0x1F40) / 2)
+			wave_fmt->samplingrate = 0x2B11;
+		else
+			wave_fmt->samplingrate = 0x1F40;
+
+		switch (wave_fmt->id) {
+		case AFMT_S16_LE:
+			wave_fmt->bitsperchannel = 16;
+			break;
+		case AFMT_U8:
+			wave_fmt->bitsperchannel = 8;
+			break;
+		default:
+			wave_fmt->id = AFMT_S16_LE;
+			wave_fmt->bitsperchannel = 16;
+			break;
+		}
+
+		break;
+
+	/* these can't be changed from the original values */
+	case WAVERECORD_MIC:
+	case WAVERECORD_FX:
+		break;
+
+	default:
+		BUG();
+		break;
+	}
+
+	wave_fmt->bytesperchannel = wave_fmt->bitsperchannel >> 3;
+	wave_fmt->bytespersample = wave_fmt->channels * wave_fmt->bytesperchannel;
+	wave_fmt->bytespersec = wave_fmt->bytespersample * wave_fmt->samplingrate;
+	wave_fmt->bytespervoicesample = wave_fmt->bytespersample;
+}
+
+static int alloc_buffer(struct emu10k1_card *card, struct wavein_buffer *buffer)
+{
+	buffer->addr = pci_alloc_consistent(card->pci_dev, buffer->size * buffer->cov,
+					    &buffer->dma_handle);
+	if (buffer->addr == NULL)
+		return -1;
+
+	return 0;
+}
+
+static void free_buffer(struct emu10k1_card *card, struct wavein_buffer *buffer)
+{
+	if (buffer->addr != NULL)
+		pci_free_consistent(card->pci_dev, buffer->size * buffer->cov,
+				    buffer->addr, buffer->dma_handle);
+}
+
+int emu10k1_wavein_open(struct emu10k1_wavedevice *wave_dev)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct wiinst *wiinst = wave_dev->wiinst;
+	struct wiinst **wiinst_tmp = NULL;
+	u16 delay;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_wavein_open()\n");
+
+	switch (wiinst->recsrc) {
+	case WAVERECORD_AC97:
+		wiinst_tmp = &card->wavein.ac97;
+		break;
+	case WAVERECORD_MIC:
+		wiinst_tmp = &card->wavein.mic;
+		break;
+	case WAVERECORD_FX:
+		wiinst_tmp = &card->wavein.fx;
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	spin_lock_irqsave(&card->lock, flags);
+	if (*wiinst_tmp != NULL) {
+		spin_unlock_irqrestore(&card->lock, flags);
+		return -1;
+	}
+
+	*wiinst_tmp = wiinst;
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	/* handle 8 bit recording */
+	if (wiinst->format.bytesperchannel == 1) {
+		if (wiinst->buffer.size > 0x8000) {
+			wiinst->buffer.size = 0x8000;
+			wiinst->buffer.sizeregval = 0x1f;
+		} else
+			wiinst->buffer.sizeregval += 4;
+
+		wiinst->buffer.cov = 2;
+	} else
+		wiinst->buffer.cov = 1;
+
+	if (alloc_buffer(card, &wiinst->buffer) < 0) {
+		ERROR();
+		emu10k1_wavein_close(wave_dev);
+		return -1;
+	}
+
+	emu10k1_set_record_src(card, wiinst);
+
+	emu10k1_reset_record(card, &wiinst->buffer);
+
+	wiinst->buffer.hw_pos = 0;
+	wiinst->buffer.pos = 0;
+	wiinst->buffer.bytestocopy = 0;
+
+	delay = (48000 * wiinst->buffer.fragment_size) / wiinst->format.bytespersec;
+
+	emu10k1_timer_install(card, &wiinst->timer, delay / 2);
+
+	wiinst->state = WAVE_STATE_OPEN;
+
+	return 0;
+}
+
+void emu10k1_wavein_close(struct emu10k1_wavedevice *wave_dev)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct wiinst *wiinst = wave_dev->wiinst;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_wavein_close()\n");
+
+	emu10k1_wavein_stop(wave_dev);
+
+	emu10k1_timer_uninstall(card, &wiinst->timer);
+
+	free_buffer(card, &wiinst->buffer);
+
+	spin_lock_irqsave(&card->lock, flags);
+	switch (wave_dev->wiinst->recsrc) {
+	case WAVERECORD_AC97:
+		card->wavein.ac97 = NULL;
+		break;
+	case WAVERECORD_MIC:
+		card->wavein.mic = NULL;
+		break;
+	case WAVERECORD_FX:
+		card->wavein.fx = NULL;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	wiinst->state = WAVE_STATE_CLOSED;
+}
+
+void emu10k1_wavein_start(struct emu10k1_wavedevice *wave_dev)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct wiinst *wiinst = wave_dev->wiinst;
+
+	DPF(2, "emu10k1_wavein_start()\n");
+
+	emu10k1_start_record(card, &wiinst->buffer);
+	emu10k1_timer_enable(wave_dev->card, &wiinst->timer);
+
+	wiinst->state |= WAVE_STATE_STARTED;
+}
+
+void emu10k1_wavein_stop(struct emu10k1_wavedevice *wave_dev)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct wiinst *wiinst = wave_dev->wiinst;
+
+	DPF(2, "emu10k1_wavein_stop()\n");
+
+	if (!(wiinst->state & WAVE_STATE_STARTED))
+		return;
+
+	emu10k1_timer_disable(card, &wiinst->timer);
+	emu10k1_stop_record(card, &wiinst->buffer);
+
+	wiinst->state &= ~WAVE_STATE_STARTED;
+}
+
+int emu10k1_wavein_setformat(struct emu10k1_wavedevice *wave_dev, struct wave_format *format)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct wiinst *wiinst = wave_dev->wiinst;
+	u16 delay;
+
+	DPF(2, "emu10k1_wavein_setformat()\n");
+
+	if (wiinst->state & WAVE_STATE_STARTED)
+		return -1;
+
+	query_format(wiinst->recsrc, format);
+
+	if ((wiinst->format.samplingrate != format->samplingrate)
+	    || (wiinst->format.bitsperchannel != format->bitsperchannel)
+	    || (wiinst->format.channels != format->channels)) {
+
+		wiinst->format = *format;
+
+		if (wiinst->state == WAVE_STATE_CLOSED)
+			return 0;
+
+		wiinst->buffer.size *= wiinst->buffer.cov;
+
+		if (wiinst->format.bytesperchannel == 1) {
+			wiinst->buffer.cov = 2;
+			wiinst->buffer.size /= wiinst->buffer.cov;
+		} else
+			wiinst->buffer.cov = 1;
+
+		emu10k1_timer_uninstall(card, &wiinst->timer);
+
+		delay = (48000 * wiinst->buffer.fragment_size) / wiinst->format.bytespersec;
+
+		emu10k1_timer_install(card, &wiinst->timer, delay / 2);
+	}
+
+	return 0;
+}
+
+void emu10k1_wavein_getxfersize(struct wiinst *wiinst, u32 * size)
+{
+	struct wavein_buffer *buffer = &wiinst->buffer;
+
+	*size = buffer->bytestocopy;
+
+	if (wiinst->mmapped)
+		return;
+
+	if (*size > buffer->size) {
+		*size = buffer->size;
+		buffer->pos = buffer->hw_pos;
+		buffer->bytestocopy = buffer->size;
+		DPF(1, "buffer overrun\n");
+	}
+}
+
+static void copy_block(u8 *dst, u8 * src, u32 str, u32 len, u8 cov)
+{
+	if (cov == 1)
+		__copy_to_user(dst, src + str, len);
+	else {
+		u8 byte;
+		u32 i;
+
+		src += 1 + 2 * str;
+
+		for (i = 0; i < len; i++) {
+			byte = src[2 * i] ^ 0x80;
+			__copy_to_user(dst + i, &byte, 1);
+		}
+	}
+}
+
+void emu10k1_wavein_xferdata(struct wiinst *wiinst, u8 * data, u32 * size)
+{
+	struct wavein_buffer *buffer = &wiinst->buffer;
+	u32 sizetocopy, sizetocopy_now, start;
+	unsigned long flags;
+
+	sizetocopy = min_t(u32, buffer->size, *size);
+	*size = sizetocopy;
+
+	if (!sizetocopy)
+		return;
+
+	spin_lock_irqsave(&wiinst->lock, flags);
+	start = buffer->pos;
+	buffer->pos += sizetocopy;
+	buffer->pos %= buffer->size;
+	buffer->bytestocopy -= sizetocopy;
+	sizetocopy_now = buffer->size - start;
+
+	spin_unlock_irqrestore(&wiinst->lock, flags);
+
+	if (sizetocopy > sizetocopy_now) {
+		sizetocopy -= sizetocopy_now;
+
+		copy_block(data, buffer->addr, start, sizetocopy_now, buffer->cov);
+		copy_block(data + sizetocopy_now, buffer->addr, 0, sizetocopy, buffer->cov);
+	} else {
+		copy_block(data, buffer->addr, start, sizetocopy, buffer->cov);
+	}
+}
+
+void emu10k1_wavein_update(struct emu10k1_card *card, struct wiinst *wiinst)
+{
+	u32 hw_pos;
+	u32 diff;
+
+	/* There is no actual start yet */
+	if (!(wiinst->state & WAVE_STATE_STARTED)) {
+		hw_pos = wiinst->buffer.hw_pos;
+	} else {
+		/* hw_pos in byte units */
+		hw_pos = sblive_readptr(card, wiinst->buffer.idxreg, 0) / wiinst->buffer.cov;
+	}
+
+	diff = (wiinst->buffer.size + hw_pos - wiinst->buffer.hw_pos) % wiinst->buffer.size;
+	wiinst->total_recorded += diff;
+	wiinst->buffer.bytestocopy += diff;
+
+	wiinst->buffer.hw_pos = hw_pos;
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/cardwi.h patched/drivers/sound/audigy/cardwi.h
--- old/drivers/sound/audigy/cardwi.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/cardwi.h	2003-07-22 21:52:47.000000000 +0300
@@ -0,0 +1,91 @@
+/*
+ **********************************************************************
+ *     cardwi.h -- header file for card wave input functions
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+#ifndef _CARDWI_H
+#define _CARDWI_H
+
+#include "icardwav.h"
+#include "audio.h"
+#include "timer.h"
+
+struct wavein_buffer {
+	u16 ossfragshift;
+        u32 fragment_size;
+        u32 numfrags;
+	u32 hw_pos;		/* hardware cursor position */
+	u32 pos;		/* software cursor position */
+	u32 bytestocopy;	/* bytes of recorded data available */
+	u32 size;
+	u32 pages;
+	u32 sizereg;
+	u32 sizeregval;
+        u32 addrreg;
+        u32 idxreg;
+        u32 adcctl;
+	void *addr;
+	u8 cov;
+	dma_addr_t dma_handle;	
+};
+
+struct wiinst
+{
+	u8 state;
+	struct emu_timer timer;
+	struct wave_format format;
+	struct wavein_buffer buffer;
+	wait_queue_head_t wait_queue;
+	u8 mmapped;
+	u32 total_recorded;	/* total bytes read() from device */
+	u32 blocks;
+	spinlock_t lock;
+	u8 recsrc;
+	u16 fxwc;
+};
+
+#define WAVEIN_MAXBUFSIZE	65536
+#define WAVEIN_MINBUFSIZE	368
+
+#define WAVEIN_DEFAULTFRAGLEN	100 
+#define WAVEIN_DEFAULTBUFLEN	1000
+
+#define WAVEIN_MINFRAGSHIFT	8 
+#define WAVEIN_MINFRAGS		2
+
+int emu10k1_wavein_open(struct emu10k1_wavedevice *);
+void emu10k1_wavein_close(struct emu10k1_wavedevice *);
+void emu10k1_wavein_start(struct emu10k1_wavedevice *);
+void emu10k1_wavein_stop(struct emu10k1_wavedevice *);
+void emu10k1_wavein_getxfersize(struct wiinst *, u32 *);
+void emu10k1_wavein_xferdata(struct wiinst *, u8 *, u32 *);
+int emu10k1_wavein_setformat(struct emu10k1_wavedevice *, struct wave_format *);
+void emu10k1_wavein_update(struct emu10k1_card *, struct wiinst *);
+
+
+#endif /* _CARDWI_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/cardwo.c patched/drivers/sound/audigy/cardwo.c
--- old/drivers/sound/audigy/cardwo.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/cardwo.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,639 @@
+/*
+ **********************************************************************
+ *     cardwo.c - PCM output HAL for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#include <linux/poll.h>
+#include "hwaccess.h"
+#include "8010.h"
+#include "voicemgr.h"
+#include "cardwo.h"
+#include "audio.h"
+
+static u32 samplerate_to_linearpitch(u32 samplingrate)
+{
+	samplingrate = (samplingrate << 8) / 375;
+	return (samplingrate >> 1) + (samplingrate & 1);
+}
+
+static void query_format(struct emu10k1_wavedevice *wave_dev, struct wave_format *wave_fmt)
+{
+	int i, j, do_passthrough = 0, is_ac3 = 0;
+	struct emu10k1_card *card = wave_dev->card;
+	struct woinst *woinst = wave_dev->woinst;
+
+	if ((wave_fmt->channels > 2) && (wave_fmt->id != AFMT_S16_LE) && (wave_fmt->id != AFMT_U8))
+		wave_fmt->channels = 2;
+
+	if ((wave_fmt->channels < 1) || (wave_fmt->channels > WAVEOUT_MAXVOICES))
+		wave_fmt->channels = 2;
+
+	if (wave_fmt->channels == 2)
+		woinst->num_voices = 1;
+	else
+		woinst->num_voices = wave_fmt->channels;
+
+	if (wave_fmt->samplingrate >= 0x2ee00)
+		wave_fmt->samplingrate = 0x2ee00;
+
+	wave_fmt->passthrough = 0;
+	do_passthrough = is_ac3 = 0;
+
+	if (card->pt.selected)
+		do_passthrough = 1;
+
+	switch (wave_fmt->id) {
+	case AFMT_S16_LE:
+		wave_fmt->bitsperchannel = 16;
+		break;
+	case AFMT_U8:
+		wave_fmt->bitsperchannel = 8;
+		break;
+	case AFMT_AC3:
+		do_passthrough = 1;
+		is_ac3 = 1;
+		break;
+	default:
+		wave_fmt->id = AFMT_S16_LE;
+		wave_fmt->bitsperchannel = 16;
+		break;
+	}	
+	if (do_passthrough) {
+		/* currently only one waveout instance may use pass-through */
+		if (woinst->state != WAVE_STATE_CLOSED || 
+		    card->pt.state != PT_STATE_INACTIVE ||
+		    (wave_fmt->samplingrate != 48000 && !is_ac3)) {
+			DPF(2, "unable to set pass-through mode\n");
+		} else if (USE_PT_METHOD1) {
+			i = emu10k1_find_control_gpr(&card->mgr, card->pt.patch_name, card->pt.intr_gpr_name);
+			j = emu10k1_find_control_gpr(&card->mgr, card->pt.patch_name, card->pt.enable_gpr_name);
+			if (i < 0 || j < 0)
+				DPF(2, "unable to set pass-through mode\n");
+			else {
+				wave_fmt->samplingrate = 48000;
+				wave_fmt->channels = 2;
+				card->pt.pos_gpr = emu10k1_find_control_gpr(&card->mgr, card->pt.patch_name,
+									    card->pt.pos_gpr_name);
+				wave_fmt->passthrough = 1;
+				card->pt.intr_gpr = i;
+				card->pt.enable_gpr = j;
+				card->pt.state = PT_STATE_INACTIVE;
+			
+				DPD(2, "is_ac3 is %d\n", is_ac3);
+				card->pt.ac3data = is_ac3;
+				wave_fmt->bitsperchannel = 16;
+			}
+		}else{
+			DPF(2, "Using Passthrough Method 2\n");
+			card->pt.enable_gpr = emu10k1_find_control_gpr(&card->mgr, card->pt.patch_name,
+								       card->pt.enable_gpr_name);
+			wave_fmt->passthrough = 2;
+			wave_fmt->bitsperchannel = 16;
+		}
+	}
+
+	wave_fmt->bytesperchannel = wave_fmt->bitsperchannel >> 3;
+	wave_fmt->bytespersample = wave_fmt->channels * wave_fmt->bytesperchannel;
+	wave_fmt->bytespersec = wave_fmt->bytespersample * wave_fmt->samplingrate;
+
+	if (wave_fmt->channels == 2)
+		wave_fmt->bytespervoicesample = wave_fmt->channels * wave_fmt->bytesperchannel;
+	else
+		wave_fmt->bytespervoicesample = wave_fmt->bytesperchannel;
+}
+
+static int get_voice(struct emu10k1_card *card, struct woinst *woinst, unsigned int voicenum)
+{
+	struct emu_voice *voice = &woinst->voice[voicenum];
+
+	/* Allocate voices here, if no voices available, return error. */
+
+	voice->usage = VOICE_USAGE_PLAYBACK;
+
+	voice->flags = 0;
+
+	if (woinst->format.channels == 2)
+		voice->flags |= VOICE_FLAGS_STEREO;
+
+	if (woinst->format.bitsperchannel == 16)
+		voice->flags |= VOICE_FLAGS_16BIT;
+
+	if (emu10k1_voice_alloc(card, voice) < 0) {
+		voice->usage = VOICE_USAGE_FREE;
+		return -1;
+	}
+
+	/* Calculate pitch */
+	voice->initial_pitch = (u16) (srToPitch(woinst->format.samplingrate) >> 8);
+	voice->pitch_target = samplerate_to_linearpitch(woinst->format.samplingrate);
+
+	DPD(2, "Initial pitch --> %#x\n", voice->initial_pitch);
+
+	voice->startloop = (voice->mem.emupageindex << 12) /
+	 woinst->format.bytespervoicesample;
+	voice->endloop = voice->startloop + woinst->buffer.size / woinst->format.bytespervoicesample;
+	voice->start = voice->startloop;
+
+	
+	voice->params[0].volume_target = 0xffff;
+	voice->params[0].initial_fc = 0xff;
+	voice->params[0].initial_attn = 0x00;
+	voice->params[0].byampl_env_sustain = 0x7f;
+	voice->params[0].byampl_env_decay = 0x7f;
+
+	
+	if (voice->flags & VOICE_FLAGS_STEREO) {
+		if (woinst->format.passthrough == 2) {
+			voice->params[0].send_routing  = voice->params[1].send_routing  = card->waveout.send_routing[ROUTE_PT];
+			voice->params[0].send_routing2 = voice->params[1].send_routing2 = card->waveout.send_routing2[ROUTE_PT];
+			voice->params[0].send_dcba = 0xff;
+			voice->params[1].send_dcba = 0xff00;
+			voice->params[0].send_hgfe = voice->params[1].send_hgfe=0;
+		} else {
+			voice->params[0].send_dcba = card->waveout.send_dcba[SEND_LEFT];
+			voice->params[0].send_hgfe = card->waveout.send_hgfe[SEND_LEFT];
+			voice->params[1].send_dcba = card->waveout.send_dcba[SEND_RIGHT];
+			voice->params[1].send_hgfe = card->waveout.send_hgfe[SEND_RIGHT];
+
+			if (woinst->device) {
+				// /dev/dps1
+				voice->params[0].send_routing  = voice->params[1].send_routing  = card->waveout.send_routing[ROUTE_PCM1];
+				voice->params[0].send_routing2 = voice->params[1].send_routing2 = card->waveout.send_routing2[ROUTE_PCM1];
+			} else {
+				voice->params[0].send_routing  = voice->params[1].send_routing  = card->waveout.send_routing[ROUTE_PCM];
+				voice->params[0].send_routing2 = voice->params[1].send_routing2 = card->waveout.send_routing2[ROUTE_PCM];
+			}
+		}
+		
+		voice->params[1].volume_target = 0xffff;
+		voice->params[1].initial_fc = 0xff;
+		voice->params[1].initial_attn = 0x00;
+		voice->params[1].byampl_env_sustain = 0x7f;
+		voice->params[1].byampl_env_decay = 0x7f;
+	} else {
+		if (woinst->num_voices > 1) {
+			// Multichannel pcm
+			voice->params[0].send_dcba=0xff;
+			voice->params[0].send_hgfe=0;
+			if (card->is_audigy) {
+				voice->params[0].send_routing = 0x3f3f3f00 + card->mchannel_fx + voicenum;
+				voice->params[0].send_routing2 = 0x3f3f3f3f;
+			} else {
+				voice->params[0].send_routing = 0xfff0 + card->mchannel_fx + voicenum;
+			}
+			
+		} else {
+			voice->params[0].send_dcba = card->waveout.send_dcba[SEND_MONO];
+			voice->params[0].send_hgfe = card->waveout.send_hgfe[SEND_MONO];
+
+			if (woinst->device) {
+				voice->params[0].send_routing = card->waveout.send_routing[ROUTE_PCM1];
+				voice->params[0].send_routing2 = card->waveout.send_routing2[ROUTE_PCM1];
+			} else {
+				voice->params[0].send_routing = card->waveout.send_routing[ROUTE_PCM];
+				voice->params[0].send_routing2 = card->waveout.send_routing2[ROUTE_PCM];
+			}
+		}
+	}
+
+	DPD(2, "voice: startloop=%#x, endloop=%#x\n", voice->startloop, voice->endloop);
+
+	emu10k1_voice_playback_setup(voice);
+
+	return 0;
+}
+
+int emu10k1_waveout_open(struct emu10k1_wavedevice *wave_dev)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct woinst *woinst = wave_dev->woinst;
+	struct waveout_buffer *buffer = &woinst->buffer;
+	unsigned int voicenum;
+	u16 delay;
+
+	DPF(2, "emu10k1_waveout_open()\n");
+
+	for (voicenum = 0; voicenum < woinst->num_voices; voicenum++) {
+		if (emu10k1_voice_alloc_buffer(card, &woinst->voice[voicenum].mem, woinst->buffer.pages) < 0) {
+			ERROR();
+			emu10k1_waveout_close(wave_dev);
+			return -1;
+		}
+
+		if (get_voice(card, woinst, voicenum) < 0) {
+			ERROR();
+			emu10k1_waveout_close(wave_dev);
+			return -1;
+		}
+	}
+
+	buffer->fill_silence = 0;
+	buffer->silence_bytes = 0;
+	buffer->silence_pos = 0;
+	buffer->hw_pos = 0;
+	buffer->free_bytes = woinst->buffer.size;
+
+	delay = (48000 * woinst->buffer.fragment_size) /
+		 (woinst->format.samplingrate * woinst->format.bytespervoicesample);
+
+	emu10k1_timer_install(card, &woinst->timer, delay);
+
+	woinst->state = WAVE_STATE_OPEN;
+
+	return 0;
+}
+
+void emu10k1_waveout_close(struct emu10k1_wavedevice *wave_dev)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct woinst *woinst = wave_dev->woinst;
+	unsigned int voicenum;
+
+	DPF(2, "emu10k1_waveout_close()\n");
+
+	emu10k1_waveout_stop(wave_dev);
+
+	emu10k1_timer_uninstall(card, &woinst->timer);
+
+	for (voicenum = 0; voicenum < woinst->num_voices; voicenum++) {
+		emu10k1_voice_free(&woinst->voice[voicenum]);
+		emu10k1_voice_free_buffer(card, &woinst->voice[voicenum].mem);
+	}
+
+	woinst->state = WAVE_STATE_CLOSED;
+}
+
+void emu10k1_waveout_start(struct emu10k1_wavedevice *wave_dev)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct woinst *woinst = wave_dev->woinst;
+	struct pt_data *pt = &card->pt;
+
+	DPF(2, "emu10k1_waveout_start()\n");
+
+	if (woinst->format.passthrough == 2) {
+		emu10k1_pt_setup(wave_dev);
+		sblive_writeptr(card, (card->is_audigy ? A_GPR_BASE : GPR_BASE) + pt->enable_gpr, 0, 1);
+		pt->state = PT_STATE_PLAYING;
+	}
+
+	/* Actual start */
+	emu10k1_voices_start(woinst->voice, woinst->num_voices, woinst->total_played);
+
+	emu10k1_timer_enable(card, &woinst->timer);
+
+	woinst->state |= WAVE_STATE_STARTED;
+}
+
+int emu10k1_waveout_setformat(struct emu10k1_wavedevice *wave_dev, struct wave_format *format)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct woinst *woinst = wave_dev->woinst;
+	unsigned int voicenum;
+	u16 delay;
+
+	DPF(2, "emu10k1_waveout_setformat()\n");
+
+	if (woinst->state & WAVE_STATE_STARTED)
+		return -1;
+
+	query_format(wave_dev, format);
+
+	if (woinst->format.samplingrate != format->samplingrate ||
+	    woinst->format.channels != format->channels ||
+	    woinst->format.bitsperchannel != format->bitsperchannel) {
+
+		woinst->format = *format;
+
+		if (woinst->state == WAVE_STATE_CLOSED)
+			return 0;
+
+		emu10k1_timer_uninstall(card, &woinst->timer);
+
+		for (voicenum = 0; voicenum < woinst->num_voices; voicenum++) {
+			emu10k1_voice_free(&woinst->voice[voicenum]);
+
+			if (get_voice(card, woinst, voicenum) < 0) {
+				ERROR();
+				emu10k1_waveout_close(wave_dev);
+				return -1;
+			}
+		}
+
+		delay = (48000 * woinst->buffer.fragment_size) /
+			 (woinst->format.samplingrate * woinst->format.bytespervoicesample);
+
+		emu10k1_timer_install(card, &woinst->timer, delay);
+	}
+
+	return 0;
+}
+
+void emu10k1_waveout_stop(struct emu10k1_wavedevice *wave_dev)
+{
+	struct emu10k1_card *card = wave_dev->card;
+	struct woinst *woinst = wave_dev->woinst;
+
+	DPF(2, "emu10k1_waveout_stop()\n");
+
+	if (!(woinst->state & WAVE_STATE_STARTED))
+		return;
+
+	emu10k1_timer_disable(card, &woinst->timer);
+
+	/* Stop actual voices */
+	emu10k1_voices_stop(woinst->voice, woinst->num_voices);
+
+	emu10k1_waveout_update(woinst);
+
+	woinst->state &= ~WAVE_STATE_STARTED;
+}
+
+/**
+ * emu10k1_waveout_getxfersize -
+ *
+ * gives the total free bytes on the voice buffer, including silence bytes
+ * (basically: total_free_bytes = free_bytes + silence_bytes).
+ *
+ */
+void emu10k1_waveout_getxfersize(struct woinst *woinst, u32 *total_free_bytes)
+{
+	struct waveout_buffer *buffer = &woinst->buffer;
+	int pending_bytes;
+
+	if (woinst->mmapped) {
+		*total_free_bytes = buffer->free_bytes;
+		return;
+	}
+
+	pending_bytes = buffer->size - buffer->free_bytes;
+
+	buffer->fill_silence = (pending_bytes < (signed) buffer->fragment_size * 2) ? 1 : 0;
+
+	if (pending_bytes > (signed) buffer->silence_bytes) {
+		*total_free_bytes = (buffer->free_bytes + buffer->silence_bytes);
+	} else {
+		*total_free_bytes = buffer->size;
+		buffer->silence_bytes = pending_bytes;
+		if (pending_bytes < 0) {
+			buffer->silence_pos = buffer->hw_pos;
+			buffer->silence_bytes = 0;
+			buffer->free_bytes = buffer->size;
+			DPF(1, "buffer underrun\n");
+		}
+	}
+}
+
+/**
+ * copy_block -
+ *
+ * copies a block of pcm data to a voice buffer.
+ * Notice that the voice buffer is actually a set of disjointed memory pages.
+ *
+ */
+static void copy_block(void **dst, u32 str, u8 *src, u32 len)
+{
+	unsigned int pg;
+	unsigned int pgoff;
+	unsigned int k;
+
+	pg = str / PAGE_SIZE;
+	pgoff = str % PAGE_SIZE;
+
+	if (len > PAGE_SIZE - pgoff) {
+		k = PAGE_SIZE - pgoff;
+		__copy_from_user((u8 *)dst[pg] + pgoff, src, k);
+		len -= k;
+		while (len > PAGE_SIZE) {
+			__copy_from_user(dst[++pg], src + k, PAGE_SIZE);
+			k += PAGE_SIZE;
+			len -= PAGE_SIZE;
+		}
+		__copy_from_user(dst[++pg], src + k, len);
+
+	} else
+		__copy_from_user((u8 *)dst[pg] + pgoff, src, len);
+}
+
+/**
+ * copy_ilv_block -
+ *
+ * copies a block of pcm data containing n interleaved channels to n mono voice buffers.
+ * Notice that the voice buffer is actually a set of disjointed memory pages.
+ *
+ */
+static void copy_ilv_block(struct woinst *woinst, u32 str, u8 *src, u32 len) 
+{
+        unsigned int pg;
+	unsigned int pgoff;
+	unsigned int voice_num;
+	struct emu_voice *voice = woinst->voice;
+
+	pg = str / PAGE_SIZE;
+	pgoff = str % PAGE_SIZE;
+
+	while (len) { 
+		for (voice_num = 0; voice_num < woinst->num_voices; voice_num++) {
+			__copy_from_user((u8 *)(voice[voice_num].mem.addr[pg]) + pgoff, src, woinst->format.bytespervoicesample);
+			src += woinst->format.bytespervoicesample;
+		}
+
+		len -= woinst->format.bytespervoicesample;
+
+		pgoff += woinst->format.bytespervoicesample;
+		if (pgoff >= PAGE_SIZE) {
+			pgoff = 0;
+			pg++;
+		}
+	}
+}
+
+/**
+ * fill_block -
+ *
+ * fills a set voice buffers with a block of a given sample.
+ *
+ */
+static void fill_block(struct woinst *woinst, u32 str, u8 data, u32 len)
+{
+	unsigned int pg;
+	unsigned int pgoff;
+	unsigned int voice_num;
+        struct emu_voice *voice = woinst->voice;
+	unsigned int  k;
+
+	pg = str / PAGE_SIZE;
+	pgoff = str % PAGE_SIZE;
+
+	if (len > PAGE_SIZE - pgoff) {
+		k = PAGE_SIZE - pgoff;
+		for (voice_num = 0; voice_num < woinst->num_voices; voice_num++)
+			memset((u8 *)voice[voice_num].mem.addr[pg] + pgoff, data, k);
+		len -= k;
+		while (len > PAGE_SIZE) {
+			pg++;
+			for (voice_num = 0; voice_num < woinst->num_voices; voice_num++)
+				memset(voice[voice_num].mem.addr[pg], data, PAGE_SIZE);
+
+			len -= PAGE_SIZE;
+		}
+		pg++;
+		for (voice_num = 0; voice_num < woinst->num_voices; voice_num++)
+			memset(voice[voice_num].mem.addr[pg], data, len);
+
+	} else {
+		for (voice_num = 0; voice_num < woinst->num_voices; voice_num++)
+			memset((u8 *)voice[voice_num].mem.addr[pg] + pgoff, data, len);
+	}
+}
+
+/**
+ * emu10k1_waveout_xferdata -
+ *
+ * copies pcm data to the voice buffer. Silence samples
+ * previously added to the buffer are overwritten.
+ *
+ */
+void emu10k1_waveout_xferdata(struct woinst *woinst, u8 *data, u32 *size)
+{
+	struct waveout_buffer *buffer = &woinst->buffer;
+	struct voice_mem *mem = &woinst->voice[0].mem;
+	u32 sizetocopy, sizetocopy_now, start;
+	unsigned long flags;
+
+	sizetocopy = min_t(u32, buffer->size, *size);
+	*size = sizetocopy;
+
+	if (!sizetocopy)
+		return;
+	
+	spin_lock_irqsave(&woinst->lock, flags);
+	start = (buffer->size + buffer->silence_pos - buffer->silence_bytes) % buffer->size;
+
+	if (sizetocopy > buffer->silence_bytes) {
+		buffer->silence_pos += sizetocopy - buffer->silence_bytes;
+		buffer->free_bytes -= sizetocopy - buffer->silence_bytes;
+		buffer->silence_bytes = 0;
+	} else
+		buffer->silence_bytes -= sizetocopy;
+
+	spin_unlock_irqrestore(&woinst->lock, flags);
+
+	sizetocopy_now = buffer->size - start;
+	if (sizetocopy > sizetocopy_now) {
+		sizetocopy -= sizetocopy_now;
+		if (woinst->num_voices > 1) {
+			copy_ilv_block(woinst, start, data, sizetocopy_now);
+			copy_ilv_block(woinst, 0, data + sizetocopy_now * woinst->num_voices, sizetocopy);
+		} else {
+			copy_block(mem->addr, start, data, sizetocopy_now);
+			copy_block(mem->addr, 0, data + sizetocopy_now, sizetocopy);
+		}
+	} else {
+		if (woinst->num_voices > 1)
+			copy_ilv_block(woinst, start, data, sizetocopy);
+		else
+			copy_block(mem->addr, start, data, sizetocopy);
+	}
+}
+
+/**
+ * emu10k1_waveout_fillsilence -
+ *
+ * adds samples of silence to the voice buffer so that we
+ * don't loop over stale pcm data.
+ *
+ */
+void emu10k1_waveout_fillsilence(struct woinst *woinst)
+{
+	struct waveout_buffer *buffer = &woinst->buffer;
+	u32 sizetocopy, sizetocopy_now, start;
+	u8 filldata;
+	unsigned long flags;
+
+	sizetocopy = buffer->fragment_size;
+
+	if (woinst->format.bitsperchannel == 16)
+		filldata = 0x00;
+	else
+		filldata = 0x80;
+
+	spin_lock_irqsave(&woinst->lock, flags);
+	buffer->silence_bytes += sizetocopy;
+	buffer->free_bytes -= sizetocopy;
+	buffer->silence_pos %= buffer->size;
+	start = buffer->silence_pos;
+	buffer->silence_pos += sizetocopy;
+	spin_unlock_irqrestore(&woinst->lock, flags);
+
+	sizetocopy_now = buffer->size - start;
+
+	if (sizetocopy > sizetocopy_now) {
+		sizetocopy -= sizetocopy_now;
+		fill_block(woinst, start, filldata, sizetocopy_now);
+		fill_block(woinst, 0, filldata, sizetocopy);
+	} else {
+		fill_block(woinst, start, filldata, sizetocopy);
+	}
+}
+
+/**
+ * emu10k1_waveout_update -
+ *
+ * updates the position of the voice buffer hardware pointer (hw_pos)
+ * and the number of free bytes on the buffer (free_bytes).
+ * The free bytes _don't_ include silence bytes that may have been
+ * added to the buffer.
+ *
+ */
+void emu10k1_waveout_update(struct woinst *woinst)
+{
+	u32 hw_pos;
+	u32 diff;
+
+	/* There is no actual start yet */
+	if (!(woinst->state & WAVE_STATE_STARTED)) {
+		hw_pos = woinst->buffer.hw_pos;
+	} else {
+		/* hw_pos in sample units */
+		hw_pos = sblive_readptr(woinst->voice[0].card, CCCA_CURRADDR, woinst->voice[0].num);
+
+		if(hw_pos < woinst->voice[0].start)
+			hw_pos += woinst->buffer.size / woinst->format.bytespervoicesample - woinst->voice[0].start;
+		else
+			hw_pos -= woinst->voice[0].start;
+
+		hw_pos *= woinst->format.bytespervoicesample;
+	}
+
+	diff = (woinst->buffer.size + hw_pos - woinst->buffer.hw_pos) % woinst->buffer.size;
+	woinst->total_played += diff;
+	woinst->buffer.free_bytes += diff;
+	woinst->buffer.hw_pos = hw_pos;
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/cardwo.h patched/drivers/sound/audigy/cardwo.h
--- old/drivers/sound/audigy/cardwo.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/cardwo.h	2003-07-22 21:52:47.000000000 +0300
@@ -0,0 +1,90 @@
+/*     
+ **********************************************************************
+ *     cardwo.h -- header file for card wave out functions
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     Date                 Author          Summary of changes 
+ *     ----                 ------          ------------------ 
+ *     October 20, 1999     Bertrand Lee    base code release 
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */
+
+#ifndef _CARDWO_H
+#define _CARDWO_H
+
+#include "icardwav.h"
+#include "audio.h"
+#include "voicemgr.h"
+#include "timer.h"
+
+/* setting this to other than a power of two may break some applications */
+#define WAVEOUT_MAXBUFSIZE	MAXBUFSIZE
+
+#define WAVEOUT_DEFAULTFRAGLEN	20 /* Time to play a fragment in ms (latency) */
+#define WAVEOUT_DEFAULTBUFLEN	500 /* Time to play the entire buffer in ms */
+
+#define WAVEOUT_MINFRAGSHIFT	6 /* Minimum fragment size in bytes is 2^6 */
+#define WAVEOUT_MINFRAGS	3 /* _don't_ go bellow 3, it would break silence filling */
+#define WAVEOUT_MAXVOICES	6
+
+struct waveout_buffer {
+	u16 ossfragshift;
+	u32 numfrags;
+	u32 fragment_size;	/* in bytes units */
+	u32 size;		/* in bytes units */
+	u32 pages;		/* buffer size in page units*/
+	u32 silence_pos;	/* software cursor position (including silence bytes) */
+	u32 hw_pos;		/* hardware cursor position */
+	u32 free_bytes;		/* free bytes available on the buffer (not including silence bytes) */
+	u8 fill_silence;
+	u32 silence_bytes;      /* silence bytes on the buffer */
+};
+
+struct woinst 
+{
+	u8 state;
+	u8 num_voices;
+	struct emu_voice voice[WAVEOUT_MAXVOICES];
+	struct emu_timer timer;
+	struct wave_format format;
+	struct waveout_buffer buffer;
+	wait_queue_head_t wait_queue;
+	u8 mmapped;
+	u32 total_copied;	/* total number of bytes written() to the buffer (excluding silence) */
+	u32 total_played;	/* total number of bytes played including silence */
+	u32 blocks;
+	u8 device;
+	spinlock_t lock;
+};
+
+int emu10k1_waveout_open(struct emu10k1_wavedevice *);
+void emu10k1_waveout_close(struct emu10k1_wavedevice *);
+void emu10k1_waveout_start(struct emu10k1_wavedevice *);
+void emu10k1_waveout_stop(struct emu10k1_wavedevice *);
+void emu10k1_waveout_getxfersize(struct woinst*, u32 *);
+void emu10k1_waveout_xferdata(struct woinst*, u8*, u32 *);
+void emu10k1_waveout_fillsilence(struct woinst*);
+int emu10k1_waveout_setformat(struct emu10k1_wavedevice*, struct wave_format*);
+void emu10k1_waveout_update(struct woinst*);
+
+#endif /* _CARDWO_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/ecard.c patched/drivers/sound/audigy/ecard.c
--- old/drivers/sound/audigy/ecard.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/ecard.c	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,157 @@
+/*     
+ **********************************************************************
+ *     ecard.c - E-card initialization code
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     Date                 Author          Summary of changes 
+ *     ----                 ------          ------------------ 
+ *     October 20, 1999     Bertrand Lee    base code release 
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */ 
+
+#include "ecard.h"
+#include "hwaccess.h"
+
+/* Private routines */
+static void ecard_setadcgain(struct emu10k1_card *, struct ecard_state *, u16);
+static void ecard_write(struct emu10k1_card *, u32);
+
+/**************************************************************************
+ * @func Set the gain of the ECARD's CS3310 Trim/gain controller.  The
+ * trim value consists of a 16bit value which is composed of two
+ * 8 bit gain/trim values, one for the left channel and one for the
+ * right channel.  The following table maps from the Gain/Attenuation
+ * value in decibels into the corresponding bit pattern for a single
+ * channel.
+ */
+
+static void ecard_setadcgain(struct emu10k1_card *card, struct ecard_state *ecard, u16 gain)
+{
+	u32 currbit;
+	ecard->adc_gain = gain;
+
+	/* Enable writing to the TRIM registers */
+	ecard_write(card, ecard->control_bits & ~EC_TRIM_CSN);
+
+	/* Do it again to insure that we meet hold time requirements */
+	ecard_write(card, ecard->control_bits & ~EC_TRIM_CSN);
+
+	for (currbit = (1L << 15); currbit; currbit >>= 1) {
+
+		u32 value = ecard->control_bits & ~(EC_TRIM_CSN|EC_TRIM_SDATA);
+
+		if (gain & currbit)
+		      value |= EC_TRIM_SDATA;
+
+		/* Clock the bit */
+		ecard_write(card, value);
+		ecard_write(card, value | EC_TRIM_SCLK);
+		ecard_write(card, value);
+	}
+
+	ecard_write(card, ecard->control_bits);
+}
+
+/**************************************************************************
+ * @func Clock bits into the Ecard's control latch.  The Ecard uses a
+ *  control latch will is loaded bit-serially by toggling the Modem control
+ *  lines from function 2 on the E8010.  This function hides these details
+ *  and presents the illusion that we are actually writing to a distinct
+ *  register.
+ */
+static void ecard_write(struct emu10k1_card *card, u32 value)
+{
+	u16 count;
+	u32 data, hcvalue;
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	hcvalue = inl(card->iobase + HCFG) & ~(HOOKN_BIT|HANDN_BIT|PULSEN_BIT);
+
+	outl(card->iobase + HCFG, hcvalue);
+
+	for (count = 0 ; count < EC_NUM_CONTROL_BITS; count++) {
+	
+		/* Set up the value */
+		data = ((value & 0x1) ? PULSEN_BIT : 0);
+		value >>= 1;
+
+		outl(card->iobase + HCFG, hcvalue | data);
+
+		/* Clock the shift register */
+		outl(card->iobase + HCFG, hcvalue | data | HANDN_BIT);
+		outl(card->iobase + HCFG, hcvalue | data);
+	}
+
+	/* Latch the bits */
+	outl(card->iobase + HCFG, hcvalue | HOOKN_BIT);
+	outl(card->iobase + HCFG, hcvalue);
+
+	spin_unlock_irqrestore(&card->lock, flags);
+}
+
+void __devinit emu10k1_ecard_init(struct emu10k1_card *card)
+{
+	u32 hcvalue;
+	struct ecard_state ecard;
+
+	/* Set up the initial settings */
+	ecard.mux0_setting = EC_DEFAULT_SPDIF0_SEL;
+	ecard.mux1_setting = EC_DEFAULT_SPDIF1_SEL;
+	ecard.mux2_setting = 0;
+	ecard.adc_gain = EC_DEFAULT_ADC_GAIN;
+	ecard.control_bits = EC_RAW_RUN_MODE | 
+                             EC_SPDIF0_SELECT(ecard.mux0_setting) |
+			     EC_SPDIF1_SELECT(ecard.mux1_setting);
+
+
+	/* Step 0: Set the codec type in the hardware control register 
+	 * and enable audio output */
+	hcvalue = emu10k1_readfn0(card, HCFG);
+	emu10k1_writefn0(card, HCFG, hcvalue | HCFG_AUDIOENABLE | HCFG_CODECFORMAT_I2S);
+
+	/* Step 1: Turn off the led and deassert TRIM_CS */
+	ecard_write(card, EC_ADCCAL | EC_LEDN | EC_TRIM_CSN);
+
+	/* Step 2: Calibrate the ADC and DAC */
+	ecard_write(card, EC_DACCAL | EC_LEDN | EC_TRIM_CSN);
+
+	/* Step 3: Wait for awhile; FIXME: Is this correct? */
+
+	current->state = TASK_INTERRUPTIBLE;
+	schedule_timeout(HZ);
+
+	/* Step 4: Switch off the DAC and ADC calibration.  Note
+	 * That ADC_CAL is actually an inverted signal, so we assert
+	 * it here to stop calibration.  */
+	ecard_write(card, EC_ADCCAL | EC_LEDN | EC_TRIM_CSN);
+
+	/* Step 4: Switch into run mode */
+	ecard_write(card, ecard.control_bits);
+
+	/* Step 5: Set the analog input gain */
+	ecard_setadcgain(card, &ecard, ecard.adc_gain);
+}
+
+
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/ecard.h patched/drivers/sound/audigy/ecard.h
--- old/drivers/sound/audigy/ecard.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/ecard.h	2003-07-22 21:52:45.000000000 +0300
@@ -0,0 +1,113 @@
+/*     
+ **********************************************************************
+ *     ecard.h
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */ 
+
+#ifndef _ECARD_H
+#define _ECARD_H
+
+#include "8010.h"
+#include "hwaccess.h"
+#include <linux/init.h>
+
+/* In A1 Silicon, these bits are in the HC register */
+#define HOOKN_BIT   (1L << 12)
+#define HANDN_BIT   (1L << 11)
+#define PULSEN_BIT  (1L << 10)
+
+#define EC_GDI1 (1 << 13)
+#define EC_GDI0 (1 << 14)
+
+#define EC_NUM_CONTROL_BITS 20
+
+#define EC_AC3_DATA_SELN  0x0001L
+#define EC_EE_DATA_SEL    0x0002L
+#define EC_EE_CNTRL_SELN  0x0004L
+#define EC_EECLK          0x0008L
+#define EC_EECS           0x0010L
+#define EC_EESDO          0x0020L
+#define EC_TRIM_CSN	  0x0040L
+#define EC_TRIM_SCLK	  0x0080L
+#define EC_TRIM_SDATA	  0x0100L
+#define EC_TRIM_MUTEN	  0x0200L
+#define EC_ADCCAL	  0x0400L
+#define EC_ADCRSTN	  0x0800L
+#define EC_DACCAL	  0x1000L
+#define EC_DACMUTEN	  0x2000L
+#define EC_LEDN		  0x4000L
+
+#define EC_SPDIF0_SEL_SHIFT	15
+#define EC_SPDIF1_SEL_SHIFT	17	
+#define EC_SPDIF0_SEL_MASK	(0x3L << EC_SPDIF0_SEL_SHIFT)
+#define EC_SPDIF1_SEL_MASK	(0x7L << EC_SPDIF1_SEL_SHIFT)
+#define EC_SPDIF0_SELECT(_x) (((_x) << EC_SPDIF0_SEL_SHIFT) & EC_SPDIF0_SEL_MASK)
+#define EC_SPDIF1_SELECT(_x) (((_x) << EC_SPDIF1_SEL_SHIFT) & EC_SPDIF1_SEL_MASK)
+#define EC_CURRENT_PROM_VERSION 0x01 /* Self-explanatory.  This should
+                                      * be incremented any time the EEPROM's
+                                      * format is changed.  */
+
+#define EC_EEPROM_SIZE	        0x40 /* ECARD EEPROM has 64 16-bit words */
+
+/* Addresses for special values stored in to EEPROM */
+#define EC_PROM_VERSION_ADDR	0x20	/* Address of the current prom version */
+#define EC_BOARDREV0_ADDR	0x21	/* LSW of board rev */
+#define EC_BOARDREV1_ADDR 	0x22	/* MSW of board rev */ 
+
+#define EC_LAST_PROMFILE_ADDR	0x2f
+
+#define EC_SERIALNUM_ADD	0x30	/* First word of serial number.  The number
+                                         * can be up to 30 characters in length
+                                         * and is stored as a NULL-terminated
+                                         * ASCII string.  Any unused bytes must be
+                                         * filled with zeros */
+#define EC_CHECKSUM_ADDR	0x3f    /* Location at which checksum is stored */
+
+
+
+/* Most of this stuff is pretty self-evident.  According to the hardware 
+ * dudes, we need to leave the ADCCAL bit low in order to avoid a DC 
+ * offset problem.  Weird.
+ */
+#define EC_RAW_RUN_MODE	(EC_DACMUTEN | EC_ADCRSTN | EC_TRIM_MUTEN | EC_TRIM_CSN)
+
+
+#define EC_DEFAULT_ADC_GAIN   0xC4C4
+#define EC_DEFAULT_SPDIF0_SEL 0x0
+#define EC_DEFAULT_SPDIF1_SEL 0x4
+
+#define HC_EA 0x01L
+
+/* ECARD state structure.  This structure maintains the state
+ * for various portions of the ECARD's onboard hardware.
+ */
+struct ecard_state {
+	u32 control_bits;
+	u16 adc_gain;
+	u16 mux0_setting;
+	u16 mux1_setting;
+	u16 mux2_setting;
+};
+
+void emu10k1_ecard_init(struct emu10k1_card *) __devinit;
+
+#endif /* _ECARD_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/efxmgr.c patched/drivers/sound/audigy/efxmgr.c
--- old/drivers/sound/audigy/efxmgr.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/efxmgr.c	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,221 @@
+/*
+ **********************************************************************
+ *     efxmgr.c
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     Date                 Author          Summary of changes 
+ *     ----                 ------          ------------------ 
+ *     October 20, 1999     Bertrand Lee    base code release 
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */
+
+#include <linux/bitops.h>
+#include "hwaccess.h"
+#include "efxmgr.h"
+
+int emu10k1_find_control_gpr(struct patch_manager *mgr, const char *patch_name, const char *gpr_name)
+{
+        struct dsp_patch *patch;
+	struct dsp_rpatch *rpatch;
+	char s[PATCH_NAME_SIZE + 4];
+	unsigned long *gpr_used;
+	int i;
+
+	DPD(2, "emu10k1_find_control_gpr(): %s %s\n", patch_name, gpr_name);
+
+	rpatch = &mgr->rpatch;
+	if (!strcmp(rpatch->name, patch_name)) {
+		gpr_used = rpatch->gpr_used;
+		goto match;
+	}
+
+	for (i = 0; i < mgr->current_pages * PATCHES_PER_PAGE; i++) {
+		patch = PATCH(mgr, i);
+			sprintf(s,"%s", patch->name);
+
+		if (!strcmp(s, patch_name)) {
+			gpr_used = patch->gpr_used;
+			goto match;
+		}
+	}
+
+	return -1;
+
+  match:
+	for (i = 0; i < NUM_GPRS; i++)
+		if (mgr->gpr[i].type == GPR_TYPE_CONTROL &&
+		    test_bit(i, gpr_used) &&
+		    !strcmp(mgr->gpr[i].name, gpr_name))
+			return i;
+
+	return -1;
+}
+
+void emu10k1_set_control_gpr(struct emu10k1_card *card, int addr, s32 val, int flag)
+{
+	struct patch_manager *mgr = &card->mgr;
+
+	DPD(2, "emu10k1_set_control_gpr(): %d %x\n", addr, val);
+
+	if (addr < 0 || addr >= NUM_GPRS)
+		return;
+
+	//fixme: once patch manager is up, remember to fix this for the audigy
+	if (card->is_audigy) {
+		sblive_writeptr(card, A_GPR_BASE + addr, 0, val);
+	} else {
+		if (flag)
+			val += sblive_readptr(card, GPR_BASE + addr, 0);
+		if (val > mgr->gpr[addr].max)
+			val = mgr->gpr[addr].max;
+		else if (val < mgr->gpr[addr].min)
+			val = mgr->gpr[addr].min;
+		sblive_writeptr(card, GPR_BASE + addr, 0, val);
+	}
+	
+	
+}
+
+//TODO: make this configurable:
+#define VOLCTRL_CHANNEL SOUND_MIXER_VOLUME
+#define VOLCTRL_STEP_SIZE        5
+
+//An internal function for setting OSS mixer controls.
+void emu10k1_set_oss_vol(struct emu10k1_card *card, int oss_mixer,
+			 unsigned int left, unsigned int right)
+{
+	extern char volume_params[SOUND_MIXER_NRDEVICES];
+
+	card->ac97.mixer_state[oss_mixer] = (right << 8) | left;
+
+	if (!card->is_aps)
+		card->ac97.write_mixer(&card->ac97, oss_mixer, left, right);
+	
+	emu10k1_set_volume_gpr(card, card->mgr.ctrl_gpr[oss_mixer][0], left,
+			       volume_params[oss_mixer]);
+
+	emu10k1_set_volume_gpr(card, card->mgr.ctrl_gpr[oss_mixer][1], right,
+			       volume_params[oss_mixer]);
+}
+
+//FIXME: mute should unmute when pressed a second time
+void emu10k1_mute_irqhandler(struct emu10k1_card *card)
+{
+	int oss_channel = VOLCTRL_CHANNEL;
+	int left, right;
+	static int val = 0;
+
+	if (val) {
+		left = val & 0xff;
+		right = (val >> 8) & 0xff;
+		val = 0;
+	} else {
+		val = card->ac97.mixer_state[oss_channel];
+		left = 0;
+		right = 0;
+	}
+
+	emu10k1_set_oss_vol(card, oss_channel, left, right);
+}
+
+void emu10k1_volincr_irqhandler(struct emu10k1_card *card)
+{
+	int oss_channel = VOLCTRL_CHANNEL;
+	int left, right;
+
+	left = card->ac97.mixer_state[oss_channel] & 0xff;
+	right = (card->ac97.mixer_state[oss_channel] >> 8) & 0xff;
+
+	if ((left += VOLCTRL_STEP_SIZE) > 100)
+		left = 100;
+
+	if ((right += VOLCTRL_STEP_SIZE) > 100)
+		right = 100;
+
+	emu10k1_set_oss_vol(card, oss_channel, left, right);
+}
+
+void emu10k1_voldecr_irqhandler(struct emu10k1_card *card)
+{
+	int oss_channel = VOLCTRL_CHANNEL;
+	int left, right;
+
+	left = card->ac97.mixer_state[oss_channel] & 0xff;
+	right = (card->ac97.mixer_state[oss_channel] >> 8) & 0xff;
+
+	if ((left -= VOLCTRL_STEP_SIZE) < 0)
+		left = 0;
+
+	if ((right -= VOLCTRL_STEP_SIZE) < 0)
+		right = 0;
+
+	emu10k1_set_oss_vol(card, oss_channel, left, right);
+}
+
+void emu10k1_set_volume_gpr(struct emu10k1_card *card, int addr, s32 vol, int scale)
+{
+	struct patch_manager *mgr = &card->mgr;
+	unsigned long flags;
+
+
+	static const s32 log2lin[4] ={           //  attenuation (dB)
+		0x7fffffff,                      //       0.0         
+		0x7fffffff * 0.840896415253715 , //       1.5          
+		0x7fffffff * 0.707106781186548,  //       3.0
+		0x7fffffff * 0.594603557501361 , //       4.5
+	};
+
+	if (addr < 0)
+		return;
+
+	vol = (100 - vol ) * scale / 100;
+
+	// Thanks to the comp.dsp newsgroup for this neat trick:
+	vol = (vol >= scale) ? 0 : (log2lin[vol & 3] >> (vol >> 2));
+
+	spin_lock_irqsave(&mgr->lock, flags);
+	emu10k1_set_control_gpr(card, addr, vol, 0);
+	spin_unlock_irqrestore(&mgr->lock, flags);
+}
+
+void emu10k1_dsp_irqhandler(struct emu10k1_card *card)
+{
+	unsigned long flags;
+
+	if (card->pt.state != PT_STATE_INACTIVE) {
+		u32 bc;
+		bc = sblive_readptr(card, GPR_BASE + card->pt.intr_gpr, 0);
+		if (bc != 0) {
+			DPD(3, "pt interrupt, bc = %d\n", bc);
+			spin_lock_irqsave(&card->pt.lock, flags);
+			card->pt.blocks_played = bc;
+			if (card->pt.blocks_played >= card->pt.blocks_copied) {
+				DPF(1, "buffer underrun in passthrough playback\n");
+				emu10k1_pt_stop(card);
+			}
+			wake_up_interruptible(&card->pt.wait);
+			spin_unlock_irqrestore(&card->pt.lock, flags);
+		}
+	}
+}
+
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/efxmgr.h patched/drivers/sound/audigy/efxmgr.h
--- old/drivers/sound/audigy/efxmgr.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/efxmgr.h	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,270 @@
+/*     
+ **********************************************************************
+ *     sblive_fx.h
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     Date                 Author          Summary of changes 
+ *     ----                 ------          ------------------ 
+ *     October 20, 1999     Bertrand Lee    base code release 
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */
+
+#ifndef _EFXMGR_H
+#define _EFXMGR_H
+
+struct emu_efx_info_t{
+	int opcode_shift;
+	int high_operand_shift;
+	int instruction_start;
+	int gpr_base;
+	int output_base;
+};
+
+
+#define WRITE_EFX(a, b, c) sblive_writeptr((a), emu_efx_info[card->is_audigy].instruction_start + (b), 0, (c))
+
+#define OP(op, z, w, x, y) \
+	do { WRITE_EFX(card, (pc) * 2, ((x) << emu_efx_info[card->is_audigy].high_operand_shift) | (y)); \
+	WRITE_EFX(card, (pc) * 2 + 1, ((op) << emu_efx_info[card->is_audigy].opcode_shift ) | ((z) << emu_efx_info[card->is_audigy].high_operand_shift) | (w)); \
+	++pc; } while (0)
+
+#define NUM_INPUTS 0x20
+#define NUM_OUTPUTS 0x20
+#define NUM_GPRS 0x100
+
+#define A_NUM_INPUTS 0x60
+#define A_NUM_OUTPUTS 0x60  //fixme: this may or may not be true
+#define A_NUM_GPRS 0x200
+
+#define GPR_NAME_SIZE   32
+#define PATCH_NAME_SIZE 32
+
+struct dsp_rpatch {
+	char name[PATCH_NAME_SIZE];
+	u16 code_start;
+	u16 code_size;
+
+	unsigned long gpr_used[NUM_GPRS / (sizeof(unsigned long) * 8) + 1];
+	unsigned long gpr_input[NUM_GPRS / (sizeof(unsigned long) * 8) + 1];
+	unsigned long route[NUM_OUTPUTS];
+	unsigned long route_v[NUM_OUTPUTS];
+};
+
+struct dsp_patch {
+	char name[PATCH_NAME_SIZE];
+	u8 id;
+	unsigned long input;                      /* bitmap of the lines used as inputs */
+	unsigned long output;                     /* bitmap of the lines used as outputs */
+	u16 code_start;
+	u16 code_size;
+
+	unsigned long gpr_used[NUM_GPRS / (sizeof(unsigned long) * 8) + 1];    /* bitmap of used gprs */
+	unsigned long gpr_input[NUM_GPRS / (sizeof(unsigned long) * 8) + 1];
+	u8 traml_istart;  /* starting address of the internal tram lines used */
+	u8 traml_isize;   /* number of internal tram lines used */
+
+	u8 traml_estart;
+	u8 traml_esize;
+
+	u16 tramb_istart;        /* starting address of the internal tram memory used */
+	u16 tramb_isize;         /* amount of internal memory used */
+	u32 tramb_estart;
+	u32 tramb_esize;
+};
+
+struct dsp_gpr {
+	u8 type;                      /* gpr type, STATIC, DYNAMIC, INPUT, OUTPUT, CONTROL */
+	char name[GPR_NAME_SIZE];       /* gpr value, only valid for control gprs */
+	s32 min, max;         /* value range for this gpr, only valid for control gprs */
+	u8 line;                    /* which input/output line is the gpr attached, only valid for input/output gprs */
+	u8 usage;
+};
+
+enum {
+	GPR_TYPE_NULL = 0,
+	GPR_TYPE_IO,
+	GPR_TYPE_STATIC,
+	GPR_TYPE_DYNAMIC,
+	GPR_TYPE_CONTROL,
+	GPR_TYPE_CONSTANT
+};
+
+#define GPR_BASE 0x100
+#define OUTPUT_BASE 0x20
+
+#define A_GPR_BASE 0x400
+#define A_OUTPUT_BASE 0x60
+
+#define MAX_PATCHES_PAGES 32
+
+struct patch_manager {
+	void *patch[MAX_PATCHES_PAGES];
+	int current_pages;
+	struct dsp_rpatch rpatch;
+	struct dsp_gpr gpr[NUM_GPRS];   /* gpr usage table */
+	spinlock_t lock;
+	s16 ctrl_gpr[SOUND_MIXER_NRDEVICES][2];
+};
+
+#define PATCHES_PER_PAGE (PAGE_SIZE / sizeof(struct dsp_patch))
+
+#define PATCH(mgr, i) ((struct dsp_patch *) (mgr)->patch[(i) / PATCHES_PER_PAGE] + (i) % PATCHES_PER_PAGE)
+
+/* PCM volume control */
+#define TMP_PCM_L     0x100 //temp PCM L (after the vol control)       
+#define TMP_PCM_R     0x101
+#define VOL_PCM_L     0x102 //vol PCM
+#define VOL_PCM_R     0x103
+
+/* Routing patch */
+#define TMP_AC_L      0x104 //tmp ac97 out
+#define TMP_AC_R      0x105
+#define TMP_REAR_L    0x106 //output - Temp Rear
+#define TMP_REAR_R    0x107
+#define TMP_DIGI_L    0x108 //output - Temp digital
+#define TMP_DIGI_R    0x109
+#define DSP_VOL_L     0x10a // main dsp volume
+#define DSP_VOL_R     0x10b
+
+/* hw inputs */
+#define PCM_IN_L 	0x00
+#define PCM_IN_R 	0x01
+
+#define PCM1_IN_L        0x04
+#define PCM1_IN_R        0x05
+//mutilchannel playback stream appear here:
+
+#define MULTI_FRONT_L	0x08
+#define MULTI_FRONT_R	0x09
+#define MULTI_REAR_L	0x0a
+#define MULTI_REAR_R	0x0b
+#define MULTI_CENTER	0x0c
+#define MULTI_LFE	0x0d
+
+#define AC97_IN_L	0x10
+#define AC97_IN_R	0x11
+#define SPDIF_CD_L	0x12
+#define SPDIF_CD_R	0x13
+
+/* hw outputs */
+#define AC97_FRONT_L	0x20
+#define AC97_FRONT_R	0x21
+#define DIGITAL_OUT_L	0x22
+#define DIGITAL_OUT_R	0x23
+#define DIGITAL_CENTER	0x24
+#define DIGITAL_LFE	0x25
+
+#define ANALOG_REAR_L	0x28
+#define ANALOG_REAR_R	0x29
+#define ADC_REC_L	0x2a
+#define ADC_REC_R	0x2b
+
+#define ANALOG_CENTER	0x31
+#define ANALOG_LFE	0x32
+
+
+#define INPUT_PATCH_START(patch, nm, ln, i)		\
+do {							\
+	patch = PATCH(mgr, patch_n);			\
+	strcpy(patch->name, nm);			\
+	patch->code_start = pc * 2;			\
+	patch->input = (1<<(0x1f&ln));			\
+	patch->output= (1<<(0x1f&ln));			\
+	patch->id = i;					\
+} while(0)
+
+#define INPUT_PATCH_END(patch)				\
+do {							\
+	patch->code_size = pc * 2 - patch->code_start;	\
+	patch_n++;					\
+} while(0)
+
+
+#define ROUTING_PATCH_START(patch, nm)	\
+do {					\
+	patch = &mgr->rpatch;		\
+	strcpy(patch->name, nm);	\
+	patch->code_start = pc * 2;	\
+} while(0)
+
+#define ROUTING_PATCH_END(patch)			\
+do {                                                    \
+	patch->code_size = pc * 2 - patch->code_start;      \
+} while(0)
+
+#define CONNECT(input, output) set_bit(input, &rpatch->route[(output) - OUTPUT_BASE]);
+
+#define CONNECT_V(input, output) set_bit(input, &rpatch->route_v[(output) - OUTPUT_BASE]);
+
+#define OUTPUT_PATCH_START(patch, nm, ln, i)		\
+do {							\
+	patch = PATCH(mgr, patch_n);			\
+	strcpy(patch->name, nm);			\
+	patch->code_start = pc * 2;			\
+	patch->input = (1<<(0x1f&ln));			\
+	patch->output= (1<<(0x1f&ln));			\
+	patch->id = i;					\
+} while(0)
+
+#define OUTPUT_PATCH_END(patch)				\
+do {							\
+	patch->code_size = pc * 2 - patch->code_start;	\
+	patch_n++;					\
+} while(0)
+
+#define GET_OUTPUT_GPR(patch, g, ln)			\
+do {							\
+	mgr->gpr[(g) - GPR_BASE].type = GPR_TYPE_IO;	\
+	mgr->gpr[(g) - GPR_BASE].usage++;		\
+	mgr->gpr[(g) - GPR_BASE].line = ln;		\
+	set_bit((g) - GPR_BASE, patch->gpr_used);	\
+} while(0)
+
+#define GET_INPUT_GPR(patch, g, ln)			\
+do {							\
+	mgr->gpr[(g) - GPR_BASE].type = GPR_TYPE_IO;	\
+	mgr->gpr[(g) - GPR_BASE].usage++;		\
+	mgr->gpr[(g) - GPR_BASE].line = ln;		\
+	set_bit((g) - GPR_BASE, patch->gpr_used);	\
+	set_bit((g) - GPR_BASE, patch->gpr_input);	\
+} while(0)
+
+#define GET_DYNAMIC_GPR(patch, g)				\
+do {								\
+	mgr->gpr[(g) - GPR_BASE].type = GPR_TYPE_DYNAMIC;	\
+	mgr->gpr[(g) - GPR_BASE].usage++;			\
+	set_bit((g) - GPR_BASE, patch->gpr_used);          	\
+} while(0)
+
+#define GET_CONTROL_GPR(patch, g, nm, a, b)			\
+do {								\
+	strcpy(mgr->gpr[(g) - GPR_BASE].name, nm);		\
+	mgr->gpr[(g) - GPR_BASE].type = GPR_TYPE_CONTROL;	\
+	mgr->gpr[(g) - GPR_BASE].usage++;			\
+	mgr->gpr[(g) - GPR_BASE].min = a;			\
+	mgr->gpr[(g) - GPR_BASE].max = b;			\
+	sblive_writeptr(card, g, 0, b);				\
+	set_bit((g) - GPR_BASE, patch->gpr_used);		\
+} while(0)
+
+#endif /* _EFXMGR_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/emuadxmg.c patched/drivers/sound/audigy/emuadxmg.c
--- old/drivers/sound/audigy/emuadxmg.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/emuadxmg.c	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,104 @@
+
+/*     
+ **********************************************************************
+ *     emuadxmg.c - Address space manager for emu10k1 driver 
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     Date                 Author          Summary of changes 
+ *     ----                 ------          ------------------ 
+ *     October 20, 1999     Bertrand Lee    base code release 
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */
+
+#include "hwaccess.h"
+
+/* Allocates emu address space */
+
+int emu10k1_addxmgr_alloc(u32 size, struct emu10k1_card *card)
+{
+	u16 *pagetable = card->emupagetable;
+	u16 index = 0;
+	u16 numpages;
+	unsigned long flags;
+
+	/* Convert bytes to pages */
+	numpages = (size / EMUPAGESIZE) + ((size % EMUPAGESIZE) ? 1 : 0);
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	while (index < (MAXPAGES - 1)) {
+		if (pagetable[index] & 0x8000) {
+			/* This block of pages is in use, jump to the start of the next block. */
+			index += (pagetable[index] & 0x7fff);
+		} else {
+			/* Found free block */
+			if (pagetable[index] >= numpages) {
+
+				/* Block is large enough */
+
+				/* If free block is larger than the block requested
+				 * then adjust the size of the block remaining */
+				if (pagetable[index] > numpages)
+					pagetable[index + numpages] = pagetable[index] - numpages;
+
+				pagetable[index] = (numpages | 0x8000);	/* Mark block as used */
+
+				spin_unlock_irqrestore(&card->lock, flags);
+
+				return index;
+			} else {
+				/* Block too small, jump to the start of the next block */
+				index += pagetable[index];
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	return -1;
+}
+
+/* Frees a previously allocated emu address space. */
+
+void emu10k1_addxmgr_free(struct emu10k1_card *card, int index)
+{
+	u16 *pagetable = card->emupagetable;
+	u16 origsize = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	if (pagetable[index] & 0x8000) {
+		/* Block is allocated - mark block as free */
+		origsize = pagetable[index] & 0x7fff;
+		pagetable[index] = origsize;
+
+		/* If next block is free, we concat both blocks */
+		if (!(pagetable[index + origsize] & 0x8000))
+			pagetable[index] += pagetable[index + origsize] & 0x7fff;
+	}
+
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	return;
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/hwaccess.c patched/drivers/sound/audigy/hwaccess.c
--- old/drivers/sound/audigy/hwaccess.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/hwaccess.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,541 @@
+/*
+ **********************************************************************
+ *     hwaccess.c -- Hardware access layer
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *     December 9, 1999     Jon Taylor      rewrote the I/O subsystem
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#include <asm/io.h>
+
+#include "hwaccess.h"
+#include "8010.h"
+#include "icardmid.h"
+
+/*************************************************************************
+* Function : srToPitch                                                   *
+* Input    : sampleRate - sampling rate                                  *
+* Return   : pitch value                                                 *
+* About    : convert sampling rate to pitch                              *
+* Note     : for 8010, sampling rate is at 48kHz, this function should   *
+*            be changed.                                                 *
+*************************************************************************/
+u32 srToPitch(u32 sampleRate)
+{
+	int i;
+
+	/* FIXME: These tables should be defined in a headerfile */
+	static u32 logMagTable[128] = {
+		0x00000, 0x02dfc, 0x05b9e, 0x088e6, 0x0b5d6, 0x0e26f, 0x10eb3, 0x13aa2,
+		0x1663f, 0x1918a, 0x1bc84, 0x1e72e, 0x2118b, 0x23b9a, 0x2655d, 0x28ed5,
+		0x2b803, 0x2e0e8, 0x30985, 0x331db, 0x359eb, 0x381b6, 0x3a93d, 0x3d081,
+		0x3f782, 0x41e42, 0x444c1, 0x46b01, 0x49101, 0x4b6c4, 0x4dc49, 0x50191,
+		0x5269e, 0x54b6f, 0x57006, 0x59463, 0x5b888, 0x5dc74, 0x60029, 0x623a7,
+		0x646ee, 0x66a00, 0x68cdd, 0x6af86, 0x6d1fa, 0x6f43c, 0x7164b, 0x73829,
+		0x759d4, 0x77b4f, 0x79c9a, 0x7bdb5, 0x7dea1, 0x7ff5e, 0x81fed, 0x8404e,
+		0x86082, 0x88089, 0x8a064, 0x8c014, 0x8df98, 0x8fef1, 0x91e20, 0x93d26,
+		0x95c01, 0x97ab4, 0x9993e, 0x9b79f, 0x9d5d9, 0x9f3ec, 0xa11d8, 0xa2f9d,
+		0xa4d3c, 0xa6ab5, 0xa8808, 0xaa537, 0xac241, 0xadf26, 0xafbe7, 0xb1885,
+		0xb3500, 0xb5157, 0xb6d8c, 0xb899f, 0xba58f, 0xbc15e, 0xbdd0c, 0xbf899,
+		0xc1404, 0xc2f50, 0xc4a7b, 0xc6587, 0xc8073, 0xc9b3f, 0xcb5ed, 0xcd07c,
+		0xceaec, 0xd053f, 0xd1f73, 0xd398a, 0xd5384, 0xd6d60, 0xd8720, 0xda0c3,
+		0xdba4a, 0xdd3b4, 0xded03, 0xe0636, 0xe1f4e, 0xe384a, 0xe512c, 0xe69f3,
+		0xe829f, 0xe9b31, 0xeb3a9, 0xecc08, 0xee44c, 0xefc78, 0xf148a, 0xf2c83,
+		0xf4463, 0xf5c2a, 0xf73da, 0xf8b71, 0xfa2f0, 0xfba57, 0xfd1a7, 0xfe8df
+	};
+
+	static char logSlopeTable[128] = {
+		0x5c, 0x5c, 0x5b, 0x5a, 0x5a, 0x59, 0x58, 0x58,
+		0x57, 0x56, 0x56, 0x55, 0x55, 0x54, 0x53, 0x53,
+		0x52, 0x52, 0x51, 0x51, 0x50, 0x50, 0x4f, 0x4f,
+		0x4e, 0x4d, 0x4d, 0x4d, 0x4c, 0x4c, 0x4b, 0x4b,
+		0x4a, 0x4a, 0x49, 0x49, 0x48, 0x48, 0x47, 0x47,
+		0x47, 0x46, 0x46, 0x45, 0x45, 0x45, 0x44, 0x44,
+		0x43, 0x43, 0x43, 0x42, 0x42, 0x42, 0x41, 0x41,
+		0x41, 0x40, 0x40, 0x40, 0x3f, 0x3f, 0x3f, 0x3e,
+		0x3e, 0x3e, 0x3d, 0x3d, 0x3d, 0x3c, 0x3c, 0x3c,
+		0x3b, 0x3b, 0x3b, 0x3b, 0x3a, 0x3a, 0x3a, 0x39,
+		0x39, 0x39, 0x39, 0x38, 0x38, 0x38, 0x38, 0x37,
+		0x37, 0x37, 0x37, 0x36, 0x36, 0x36, 0x36, 0x35,
+		0x35, 0x35, 0x35, 0x34, 0x34, 0x34, 0x34, 0x34,
+		0x33, 0x33, 0x33, 0x33, 0x32, 0x32, 0x32, 0x32,
+		0x32, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30,
+		0x30, 0x30, 0x30, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f
+	};
+
+	if (sampleRate == 0)
+		return 0;	/* Bail out if no leading "1" */
+
+	sampleRate *= 11185;	/* Scale 48000 to 0x20002380 */
+
+	for (i = 31; i > 0; i--) {
+		if (sampleRate & 0x80000000) {	/* Detect leading "1" */
+			return (u32) (((s32) (i - 15) << 20) +
+				      logMagTable[0x7f & (sampleRate >> 24)] +
+				      (0x7f & (sampleRate >> 17)) * logSlopeTable[0x7f & (sampleRate >> 24)]);
+		}
+		sampleRate = sampleRate << 1;
+	}
+
+	DPF(2, "srToPitch: BUG!\n");
+	return 0;		/* Should never reach this point */
+}
+
+/* Returns an attenuation based upon a cumulative volume value */
+
+/* Algorithm calculates 0x200 - 0x10 log2 (input) */
+u8 sumVolumeToAttenuation(u32 value)
+{
+	u16 count = 16;
+	s16 ans;
+
+	if (value == 0)
+		return 0xFF;
+
+	/* Find first SET bit. This is the integer part of the value */
+	while ((value & 0x10000) == 0) {
+		value <<= 1;
+		count--;
+	}
+
+	/* The REST of the data is the fractional part. */
+	ans = (s16) (0x110 - ((count << 4) + ((value & 0x0FFFFL) >> 12)));
+	if (ans > 0xFF)
+		ans = 0xFF;
+
+	return (u8) ans;
+}
+
+/*******************************************
+* write/read PCI function 0 registers      *
+********************************************/
+void emu10k1_writefn0(struct emu10k1_card *card, u32 reg, u32 data)
+{
+	unsigned long flags;
+
+	if (reg & 0xff000000) {
+		u32 mask;
+		u8 size, offset;
+
+		size = (reg >> 24) & 0x3f;
+		offset = (reg >> 16) & 0x1f;
+		mask = ((1 << size) - 1) << offset;
+		data = (data << offset) & mask;
+		reg &= 0x7f;
+
+		spin_lock_irqsave(&card->lock, flags);
+		data |= inl(card->iobase + reg) & ~mask;
+		outl(data, card->iobase + reg);
+		spin_unlock_irqrestore(&card->lock, flags);
+	} else {
+		spin_lock_irqsave(&card->lock, flags);
+		outl(data, card->iobase + reg);
+		spin_unlock_irqrestore(&card->lock, flags);
+	}
+
+	return;
+}
+
+void emu10k1_writefn0_2(struct emu10k1_card *card, u32 reg, u32 data, int size)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	if (size == 32)
+		outl(data, card->iobase + (reg & 0x1F));
+	else if (size == 16)
+		outw(data, card->iobase + (reg & 0x1F));
+	else
+		outb(data, card->iobase + (reg & 0x1F));
+
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	return;
+}
+
+u32 emu10k1_readfn0(struct emu10k1_card * card, u32 reg)
+{
+	u32 val;
+	unsigned long flags;
+
+	if (reg & 0xff000000) {
+		u32 mask;
+		u8 size, offset;
+
+		size = (reg >> 24) & 0x3f;
+		offset = (reg >> 16) & 0x1f;
+		mask = ((1 << size) - 1) << offset;
+		reg &= 0x7f;
+
+		spin_lock_irqsave(&card->lock, flags);
+		val = inl(card->iobase + reg);
+		spin_unlock_irqrestore(&card->lock, flags);
+
+		return (val & mask) >> offset;
+        } else {
+		spin_lock_irqsave(&card->lock, flags);
+		val = inl(card->iobase + reg);
+		spin_unlock_irqrestore(&card->lock, flags);
+		return val;
+	}
+}
+
+void emu10k1_timer_set(struct emu10k1_card * card, u16 data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->lock, flags);
+	outw(data & TIMER_RATE_MASK, card->iobase + TIMER);
+	spin_unlock_irqrestore(&card->lock, flags);
+}
+
+/************************************************************************
+* write/read Emu10k1 pointer-offset register set, accessed through      *
+*  the PTR and DATA registers                                           *
+*************************************************************************/
+#define A_PTR_ADDRESS_MASK 0x0fff0000
+void sblive_writeptr(struct emu10k1_card *card, u32 reg, u32 channel, u32 data)
+{
+	u32 regptr;
+	unsigned long flags;
+
+	regptr = ((reg << 16) & A_PTR_ADDRESS_MASK) | (channel & PTR_CHANNELNUM_MASK);
+
+	if (reg & 0xff000000) {
+		u32 mask;
+		u8 size, offset;
+
+		size = (reg >> 24) & 0x3f;
+		offset = (reg >> 16) & 0x1f;
+		mask = ((1 << size) - 1) << offset;
+		data = (data << offset) & mask;
+
+		spin_lock_irqsave(&card->lock, flags);
+		outl(regptr, card->iobase + PTR);
+		data |= inl(card->iobase + DATA) & ~mask;
+		outl(data, card->iobase + DATA);
+		spin_unlock_irqrestore(&card->lock, flags);
+	} else {
+		spin_lock_irqsave(&card->lock, flags);
+		outl(regptr, card->iobase + PTR);
+		outl(data, card->iobase + DATA);
+		spin_unlock_irqrestore(&card->lock, flags);
+	}
+}
+
+/* ... :  data, reg, ... , TAGLIST_END */
+void sblive_writeptr_tag(struct emu10k1_card *card, u32 channel, ...)
+{
+	va_list args;
+
+	unsigned long flags;
+        u32 reg;
+
+	va_start(args, channel);
+
+	spin_lock_irqsave(&card->lock, flags);
+	while ((reg = va_arg(args, u32)) != TAGLIST_END) {
+		u32 data = va_arg(args, u32);
+		u32 regptr = (((reg << 16) & A_PTR_ADDRESS_MASK)
+			      | (channel & PTR_CHANNELNUM_MASK));
+		outl(regptr, card->iobase + PTR);
+		if (reg & 0xff000000) {
+			int size = (reg >> 24) & 0x3f;
+                        int offset = (reg >> 16) & 0x1f;
+			u32 mask = ((1 << size) - 1) << offset;
+			data = (data << offset) & mask;
+
+			data |= inl(card->iobase + DATA) & ~mask;
+		}
+		outl(data, card->iobase + DATA);
+	}
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	va_end(args);
+
+	return;
+}
+
+u32 sblive_readptr(struct emu10k1_card * card, u32 reg, u32 channel)
+{
+	u32 regptr, val;
+	unsigned long flags;
+
+	regptr = ((reg << 16) & A_PTR_ADDRESS_MASK) | (channel & PTR_CHANNELNUM_MASK);
+
+	if (reg & 0xff000000) {
+		u32 mask;
+		u8 size, offset;
+
+		size = (reg >> 24) & 0x3f;
+		offset = (reg >> 16) & 0x1f;
+		mask = ((1 << size) - 1) << offset;
+
+		spin_lock_irqsave(&card->lock, flags);
+		outl(regptr, card->iobase + PTR);
+		val = inl(card->iobase + DATA);
+		spin_unlock_irqrestore(&card->lock, flags);
+
+		return (val & mask) >> offset;
+	} else {
+		spin_lock_irqsave(&card->lock, flags);
+		outl(regptr, card->iobase + PTR);
+		val = inl(card->iobase + DATA);
+		spin_unlock_irqrestore(&card->lock, flags);
+
+		return val;
+	}
+}
+
+void emu10k1_irq_enable(struct emu10k1_card *card, u32 irq_mask)
+{
+	u32 val;
+	unsigned long flags;
+
+	DPF(2,"emu10k1_irq_enable()\n");
+
+	spin_lock_irqsave(&card->lock, flags);
+        val = inl(card->iobase + INTE) | irq_mask;
+        outl(val, card->iobase + INTE);
+	spin_unlock_irqrestore(&card->lock, flags);
+	return;
+}
+
+void emu10k1_irq_disable(struct emu10k1_card *card, u32 irq_mask)
+{
+        u32 val;
+        unsigned long flags;
+
+        DPF(2,"emu10k1_irq_disable()\n");
+
+        spin_lock_irqsave(&card->lock, flags);
+        val = inl(card->iobase + INTE) & ~irq_mask;
+        outl(val, card->iobase + INTE);
+        spin_unlock_irqrestore(&card->lock, flags);
+        return;
+}
+
+void emu10k1_set_stop_on_loop(struct emu10k1_card *card, u32 voicenum)
+{
+	/* Voice interrupt */
+	if (voicenum >= 32)
+		sblive_writeptr(card, SOLEH | ((0x0100 | (voicenum - 32)) << 16), 0, 1);
+	else
+		sblive_writeptr(card, SOLEL | ((0x0100 | voicenum) << 16), 0, 1);
+
+	return;
+}
+
+void emu10k1_clear_stop_on_loop(struct emu10k1_card *card, u32 voicenum)
+{
+	/* Voice interrupt */
+	if (voicenum >= 32)
+		sblive_writeptr(card, SOLEH | ((0x0100 | (voicenum - 32)) << 16), 0, 0);
+	else
+		sblive_writeptr(card, SOLEL | ((0x0100 | voicenum) << 16), 0, 0);
+
+	return;
+}
+
+static void sblive_wcwait(struct emu10k1_card *card, u32 wait)
+{
+	volatile unsigned uCount;
+	u32 newtime = 0, curtime;
+
+	curtime = emu10k1_readfn0(card, WC_SAMPLECOUNTER);
+	while (wait--) {
+		uCount = 0;
+		while (uCount++ < TIMEOUT) {
+			newtime = emu10k1_readfn0(card, WC_SAMPLECOUNTER);
+			if (newtime != curtime)
+				break;
+		}
+
+		if (uCount >= TIMEOUT)
+			break;
+
+		curtime = newtime;
+	}
+}
+
+u16 emu10k1_ac97_read(struct ac97_codec *codec, u8 reg)
+{
+	struct emu10k1_card *card = codec->private_data;
+	u16 data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	outb(reg, card->iobase + AC97ADDRESS);
+	data = inw(card->iobase + AC97DATA);
+
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	return data;
+}
+
+void emu10k1_ac97_write(struct ac97_codec *codec, u8 reg, u16 value)
+{
+	struct emu10k1_card *card = codec->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	outb(reg, card->iobase + AC97ADDRESS);
+	outw(value, card->iobase + AC97DATA);
+	outb( AC97_EXTENDED_ID, card->iobase + AC97ADDRESS); 
+	spin_unlock_irqrestore(&card->lock, flags);
+}
+
+/*********************************************************
+*            MPU access functions                        *
+**********************************************************/
+
+int emu10k1_mpu_write_data(struct emu10k1_card *card, u8 data)
+{
+	unsigned long flags;
+	int ret;
+
+	if (card->is_audigy) {
+		if ((sblive_readptr(card, A_MUSTAT,0) & MUSTAT_ORDYN) == 0) {
+			sblive_writeptr(card, A_MUDATA, 0, data);
+			ret = 0;
+		} else
+			ret = -1;
+	} else {
+		spin_lock_irqsave(&card->lock, flags);
+
+		if ((inb(card->iobase + MUSTAT) & MUSTAT_ORDYN) == 0) {
+			outb(data, card->iobase + MUDATA);
+			ret = 0;
+		} else
+			ret = -1;
+
+		spin_unlock_irqrestore(&card->lock, flags);
+	}
+
+	return ret;
+}
+
+int emu10k1_mpu_read_data(struct emu10k1_card *card, u8 * data)
+{
+	unsigned long flags;
+	int ret;
+
+	if (card->is_audigy) {
+		if ((sblive_readptr(card, A_MUSTAT,0) & MUSTAT_IRDYN) == 0) {
+			*data = sblive_readptr(card, A_MUDATA,0);
+			ret = 0;
+		} else
+			ret = -1;
+	} else {
+		spin_lock_irqsave(&card->lock, flags);
+
+		if ((inb(card->iobase + MUSTAT) & MUSTAT_IRDYN) == 0) {
+			*data = inb(card->iobase + MUDATA);
+			ret = 0;
+		} else
+			ret = -1;
+
+		spin_unlock_irqrestore(&card->lock, flags);
+	}
+
+	return ret;
+}
+
+int emu10k1_mpu_reset(struct emu10k1_card *card)
+{
+	u8 status;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_mpu_reset()\n");
+	if (card->is_audigy) {
+		if (card->mpuacqcount == 0) {
+			sblive_writeptr(card, A_MUCMD, 0, MUCMD_RESET);
+			sblive_wcwait(card, 8);
+			sblive_writeptr(card, A_MUCMD, 0, MUCMD_RESET);
+			sblive_wcwait(card, 8);
+			sblive_writeptr(card, A_MUCMD, 0, MUCMD_ENTERUARTMODE);
+			sblive_wcwait(card, 8);
+			status = sblive_readptr(card, A_MUDATA, 0);
+			if (status == 0xfe)
+				return 0;
+			else
+				return -1;
+		}
+
+		return 0;
+	} else {
+		if (card->mpuacqcount == 0) {
+			spin_lock_irqsave(&card->lock, flags);
+			outb(MUCMD_RESET, card->iobase + MUCMD);
+			spin_unlock_irqrestore(&card->lock, flags);
+
+			sblive_wcwait(card, 8);
+
+			spin_lock_irqsave(&card->lock, flags);
+			outb(MUCMD_RESET, card->iobase + MUCMD);
+			spin_unlock_irqrestore(&card->lock, flags);
+
+			sblive_wcwait(card, 8);
+
+			spin_lock_irqsave(&card->lock, flags);
+			outb(MUCMD_ENTERUARTMODE, card->iobase + MUCMD);
+			spin_unlock_irqrestore(&card->lock, flags);
+
+			sblive_wcwait(card, 8);
+
+			spin_lock_irqsave(&card->lock, flags);
+			status = inb(card->iobase + MUDATA);
+			spin_unlock_irqrestore(&card->lock, flags);
+
+			if (status == 0xfe)
+				return 0;
+			else
+				return -1;
+		}
+
+		return 0;
+	}
+}
+
+int emu10k1_mpu_acquire(struct emu10k1_card *card)
+{
+	/* FIXME: This should be a macro */
+	++card->mpuacqcount;
+
+	return 0;
+}
+
+int emu10k1_mpu_release(struct emu10k1_card *card)
+{
+	/* FIXME: this should be a macro */
+	--card->mpuacqcount;
+
+	return 0;
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/hwaccess.h patched/drivers/sound/audigy/hwaccess.h
--- old/drivers/sound/audigy/hwaccess.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/hwaccess.h	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,249 @@
+/*
+ **********************************************************************
+ *     hwaccess.h
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date		    Author	    Summary of changes
+ *     ----		    ------	    ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#ifndef _HWACCESS_H
+#define _HWACCESS_H
+
+#include <linux/fs.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <linux/ac97_codec.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+
+#include "efxmgr.h"
+#include "passthrough.h"
+#include "midi.h"
+
+#define EMUPAGESIZE     4096            /* don't change */
+#define NUM_G           64              /* use all channels */
+#define NUM_FXSENDS     4               /* don't change */
+/* setting this to other than a power of two may break some applications */
+#define MAXBUFSIZE	65536
+#define MAXPAGES	8192 
+#define BUFMAXPAGES     (MAXBUFSIZE / PAGE_SIZE)
+
+#define FLAGS_AVAILABLE     0x0001
+#define FLAGS_READY         0x0002
+
+struct memhandle
+{
+	dma_addr_t dma_handle;
+	void *addr;
+	u32 size;
+};
+
+#define DEBUG_LEVEL 2
+
+#ifdef EMU10K1_DEBUG
+# define DPD(level,x,y...) do {if(level <= DEBUG_LEVEL) printk( KERN_NOTICE "emu10k1: %s: %d: " x , __FILE__ , __LINE__ , y );} while(0)
+# define DPF(level,x)   do {if(level <= DEBUG_LEVEL) printk( KERN_NOTICE "emu10k1: %s: %d: " x , __FILE__ , __LINE__ );} while(0)
+#else
+# define DPD(level,x,y...) do { } while (0) /* not debugging: nothing */
+# define DPF(level,x) do { } while (0)
+#endif /* EMU10K1_DEBUG */
+
+#define ERROR() DPF(1,"error\n")
+
+/* DATA STRUCTURES */
+
+struct emu10k1_waveout
+{
+	u32 send_routing[3];
+	// audigy only:
+	u32 send_routing2[3];
+
+	u32 send_dcba[3];
+	// audigy only:
+	u32 send_hgfe[3];
+};
+#define ROUTE_PCM 0
+#define ROUTE_PT 1
+#define ROUTE_PCM1 2
+
+#define SEND_MONO 0
+#define SEND_LEFT 1
+#define SEND_RIGHT 2
+
+struct emu10k1_wavein
+{
+        struct wiinst *ac97;
+        struct wiinst *mic;
+        struct wiinst *fx;
+
+        u8 recsrc;
+        u32 fxwc;
+};
+
+#define CMD_READ 1
+#define CMD_WRITE 2
+
+struct mixer_private_ioctl {
+        u32 cmd;
+        u32 val[90];
+};
+
+/* bogus ioctls numbers to escape from OSS mixer limitations */
+#define CMD_WRITEFN0            _IOW('D', 0, struct mixer_private_ioctl)
+#define CMD_READFN0		_IOR('D', 1, struct mixer_private_ioctl) 
+#define CMD_WRITEPTR		_IOW('D', 2, struct mixer_private_ioctl) 
+#define CMD_READPTR		_IOR('D', 3, struct mixer_private_ioctl) 
+#define CMD_SETRECSRC		_IOW('D', 4, struct mixer_private_ioctl) 
+#define CMD_GETRECSRC		_IOR('D', 5, struct mixer_private_ioctl) 
+#define CMD_GETVOICEPARAM	_IOR('D', 6, struct mixer_private_ioctl) 
+#define CMD_SETVOICEPARAM	_IOW('D', 7, struct mixer_private_ioctl) 
+#define CMD_GETPATCH		_IOR('D', 8, struct mixer_private_ioctl) 
+#define CMD_GETGPR		_IOR('D', 9, struct mixer_private_ioctl) 
+#define CMD_GETCTLGPR           _IOR('D', 10, struct mixer_private_ioctl)
+#define CMD_SETPATCH		_IOW('D', 11, struct mixer_private_ioctl) 
+#define CMD_SETGPR		_IOW('D', 12, struct mixer_private_ioctl) 
+#define CMD_SETCTLGPR		_IOW('D', 13, struct mixer_private_ioctl)
+#define CMD_SETGPOUT		_IOW('D', 14, struct mixer_private_ioctl)
+#define CMD_GETGPR2OSS		_IOR('D', 15, struct mixer_private_ioctl)
+#define CMD_SETGPR2OSS		_IOW('D', 16, struct mixer_private_ioctl)
+#define CMD_SETMCH_FX		_IOW('D', 17, struct mixer_private_ioctl)
+#define CMD_SETPASSTHROUGH	_IOW('D', 18, struct mixer_private_ioctl)
+#define CMD_PRIVATE3_VERSION	_IOW('D', 19, struct mixer_private_ioctl)
+#define CMD_AC97_BOOST		_IOW('D', 20, struct mixer_private_ioctl)
+
+//up this number when breaking compatibility
+#define PRIVATE3_VERSION 2
+
+struct emu10k1_card 
+{
+	struct list_head list;
+
+	struct memhandle	virtualpagetable;
+	struct memhandle	tankmem;
+	struct memhandle	silentpage;
+
+	spinlock_t		lock;
+
+	u8			voicetable[NUM_G];
+	u16			emupagetable[MAXPAGES];
+
+	struct list_head	timers;
+	u16			timer_delay;
+	spinlock_t		timer_lock;
+
+	struct pci_dev		*pci_dev;
+	unsigned long           iobase;
+	unsigned long		length;
+	unsigned short		model;
+	unsigned int irq; 
+
+	int	audio_dev;
+	int	audio_dev1;
+	int	midi_dev;
+#ifdef EMU10K1_SEQUENCER
+	int seq_dev;
+	struct emu10k1_mididevice *seq_mididev;
+#endif
+
+	struct ac97_codec ac97;
+	int ac97_supported_mixers;
+	int ac97_stereo_mixers;
+
+	/* Number of first fx voice for multichannel output */
+	u8 mchannel_fx;
+	struct emu10k1_waveout	waveout;
+	struct emu10k1_wavein	wavein;
+	struct emu10k1_mpuout	*mpuout;
+	struct emu10k1_mpuin	*mpuin;
+
+	struct semaphore	open_sem;
+	mode_t			open_mode;
+	wait_queue_head_t	open_wait;
+
+	u32	    mpuacqcount;	  // Mpu acquire count
+	u32	    has_toslink;	       // TOSLink detection
+
+	u8 chiprev;                    /* Chip revision                */
+	u8 is_audigy;
+	u8 is_aps;
+
+	struct patch_manager mgr;
+	struct pt_data pt;
+};
+
+int emu10k1_addxmgr_alloc(u32, struct emu10k1_card *);
+void emu10k1_addxmgr_free(struct emu10k1_card *, int);
+
+int emu10k1_find_control_gpr(struct patch_manager *, const char *, const char *);
+void emu10k1_set_control_gpr(struct emu10k1_card *, int , s32, int );
+
+void emu10k1_set_volume_gpr(struct emu10k1_card *, int, s32, int);
+
+
+#define VOL_6BIT 0x40
+#define VOL_5BIT 0x20
+#define VOL_4BIT 0x10
+
+#define TIMEOUT 		    16384
+
+u32 srToPitch(u32);
+u8 sumVolumeToAttenuation(u32);
+
+extern struct list_head emu10k1_devs;
+
+/* Hardware Abstraction Layer access functions */
+
+void emu10k1_writefn0(struct emu10k1_card *, u32, u32);
+void emu10k1_writefn0_2(struct emu10k1_card *, u32, u32, int);
+u32 emu10k1_readfn0(struct emu10k1_card *, u32);
+
+void emu10k1_timer_set(struct emu10k1_card *, u16);
+
+void sblive_writeptr(struct emu10k1_card *, u32, u32, u32);
+void sblive_writeptr_tag(struct emu10k1_card *, u32, ...);
+#define TAGLIST_END	0
+
+u32 sblive_readptr(struct emu10k1_card *, u32 , u32 );
+
+void emu10k1_irq_enable(struct emu10k1_card *, u32);
+void emu10k1_irq_disable(struct emu10k1_card *, u32);
+void emu10k1_set_stop_on_loop(struct emu10k1_card *, u32);
+void emu10k1_clear_stop_on_loop(struct emu10k1_card *, u32);
+
+/* AC97 Codec register access function */
+u16 emu10k1_ac97_read(struct ac97_codec *, u8);
+void emu10k1_ac97_write(struct ac97_codec *, u8, u16);
+
+/* MPU access function*/
+int emu10k1_mpu_write_data(struct emu10k1_card *, u8);
+int emu10k1_mpu_read_data(struct emu10k1_card *, u8 *);
+int emu10k1_mpu_reset(struct emu10k1_card *);
+int emu10k1_mpu_acquire(struct emu10k1_card *);
+int emu10k1_mpu_release(struct emu10k1_card *);
+
+#endif  /* _HWACCESS_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/icardmid.h patched/drivers/sound/audigy/icardmid.h
--- old/drivers/sound/audigy/icardmid.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/icardmid.h	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,163 @@
+/*
+ **********************************************************************
+ *     isblive_mid.h
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#ifndef _ICARDMIDI_H
+#define _ICARDMIDI_H
+
+/* MIDI defines */
+#define MIDI_DATA_FIRST                 0x00
+#define MIDI_DATA_LAST                  0x7F
+#define MIDI_STATUS_FIRST               0x80
+#define MIDI_STATUS_LAST                0xFF
+
+/* Channel status bytes */
+#define MIDI_STATUS_CHANNEL_FIRST       0x80
+#define MIDI_STATUS_CHANNEL_LAST        0xE0
+#define MIDI_STATUS_CHANNEL_MASK        0xF0
+
+/* Channel voice messages */
+#define MIDI_VOICE_NOTE_OFF             0x80
+#define MIDI_VOICE_NOTE_ON              0x90
+#define MIDI_VOICE_POLY_PRESSURE        0xA0
+#define MIDI_VOICE_CONTROL_CHANGE       0xB0
+#define MIDI_VOICE_PROGRAM_CHANGE       0xC0
+#define MIDI_VOICE_CHANNEL_PRESSURE     0xD0
+#define MIDI_VOICE_PITCH_BEND           0xE0
+
+/* Channel mode messages */
+#define MIDI_MODE_CHANNEL               MIDI_VOICE_CONTROL_CHANGE
+
+/* System status bytes */
+#define MIDI_STATUS_SYSTEM_FIRST        0xF0
+#define MIDI_STATUS_SYSTEM_LAST         0xFF
+
+/* System exclusive messages */
+#define MIDI_SYSEX_BEGIN                0xF0
+#define MIDI_SYSEX_EOX                  0xF7
+
+/* System common messages */
+#define MIDI_COMMON_TCQF                0xF1	/* Time code quarter frame  */
+#define MIDI_COMMON_SONG_POSITION       0xF2
+#define MIDI_COMMON_SONG_SELECT         0xF3
+#define MIDI_COMMON_UNDEFINED_F4        0xF4
+#define MIDI_COMMON_UNDEFINED_F5        0xF5
+#define MIDI_COMMON_TUNE_REQUEST        0xF6
+
+/* System real-time messages */
+#define MIDI_RTIME_TIMING_CLOCK         0xF8
+#define MIDI_RTIME_UNDEFINED_F9         0xF9
+#define MIDI_RTIME_START                0xFA
+#define MIDI_RTIME_CONTINUE             0xFB
+#define MIDI_RTIME_STOP                 0xFC
+#define MIDI_RTIME_UNDEFINED_FD         0xFD
+#define MIDI_RTIME_ACTIVE_SENSING       0xFE
+#define MIDI_RTIME_SYSTEM_RESET         0xFF
+
+/* Flags for flags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */
+#define MIDI_CACHE_ALL                  1
+#define MIDI_CACHE_BESTFIT              2
+#define MIDI_CACHE_QUERY                3
+#define MIDI_UNCACHE                    4
+
+/* Event declarations for MPU IRQ Callbacks */
+#define ICARDMIDI_INLONGDATA            0x00000001 /* MIM_LONGDATA */
+#define ICARDMIDI_INLONGERROR           0x00000002 /* MIM_LONGERROR */
+#define ICARDMIDI_OUTLONGDATA           0x00000004 /* MOM_DONE for MPU OUT buffer */
+#define ICARDMIDI_INDATA                0x00000010 /* MIM_DATA */
+#define ICARDMIDI_INDATAERROR           0x00000020 /* MIM_ERROR */
+
+/* Declaration for flags in CARDMIDIBUFFERHDR */
+/* Make it the same as MHDR_DONE, MHDR_INQUEUE in mmsystem.h */
+#define MIDIBUF_DONE                    0x00000001
+#define MIDIBUF_INQUEUE                 0x00000004
+
+/* Declaration for msg parameter in midiCallbackFn */
+#define ICARDMIDI_OUTBUFFEROK           0x00000001
+#define ICARDMIDI_INMIDIOK              0x00000002
+
+/* Declaration for technology in struct midi_caps */
+#define MT_MIDIPORT                     0x00000001	/* In original MIDIOUTCAPS structure */
+#define MT_FMSYNTH                      0x00000004	/* In original MIDIOUTCAPS structure */
+#define MT_AWESYNTH                     0x00001000
+#define MT_PCISYNTH                     0x00002000
+#define MT_PCISYNTH64                   0x00004000
+#define CARDMIDI_AWEMASK                0x0000F000
+
+enum LocalErrorCode
+{
+        CTSTATUS_NOTENABLED = 0x7000,
+        CTSTATUS_READY,
+        CTSTATUS_BUSY,
+        CTSTATUS_DATAAVAIL,
+        CTSTATUS_NODATA,
+        CTSTATUS_NEXT_BYTE
+};
+
+/* MIDI data block header */
+struct midi_hdr
+{
+	u8 *reserved;		/* Pointer to original locked data block */
+	u32 bufferlength;	/* Length of data in data block */
+	u32 bytesrecorded;	/* Used for input only */
+	u32 user;		/* For client's use */
+	u32 flags;		/* Assorted flags (see defines) */
+	struct list_head list;	/* Reserved for driver */
+	u8 *data;		/* Second copy of first pointer */
+};
+
+/* Enumeration for SetControl */
+enum
+{
+	MIDIOBJVOLUME = 0x1,
+	MIDIQUERYACTIVEINST
+};
+
+struct midi_queue
+{
+	struct midi_queue  *next;
+	u32 qtype;            /* 0 = short message, 1 = long data */
+	u32 length;
+	u32 sizeLeft;
+	u8 *midibyte;
+	unsigned long refdata;
+};
+
+struct midi_openinfo
+{
+	u32     cbsize;
+	u32     flags;
+	unsigned long  refdata;
+	u32     streamid;
+};
+
+int emu10k1_midi_callback(unsigned long , unsigned long, unsigned long *);
+
+#endif /* _ICARDMIDI_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/icardwav.h patched/drivers/sound/audigy/icardwav.h
--- old/drivers/sound/audigy/icardwav.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/icardwav.h	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,53 @@
+/*     
+ **********************************************************************
+ *     icardwav.h
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     Date                 Author          Summary of changes 
+ *     ----                 ------          ------------------ 
+ *     October 20, 1999     Bertrand Lee    base code release 
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */
+
+#ifndef _ICARDWAV_H
+#define _ICARDWAV_H
+
+struct wave_format 
+{
+	int id;
+	int samplingrate;
+	u8 bitsperchannel;
+	u8 channels;		/* 1 = Mono, 2 = Stereo, 3, ... = Multichannel */
+	u8 bytesperchannel;
+	u8 bytespervoicesample;
+	u8 bytespersample;
+	int bytespersec;
+	u8 passthrough;
+};
+
+/* emu10k1_wave states */
+#define WAVE_STATE_OPEN		0x01	
+#define WAVE_STATE_STARTED	0x02
+#define WAVE_STATE_CLOSED	0x04
+
+#endif /* _ICARDWAV_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/irqmgr.c patched/drivers/sound/audigy/irqmgr.c
--- old/drivers/sound/audigy/irqmgr.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/irqmgr.c	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,110 @@
+/*
+ **********************************************************************
+ *     irqmgr.c - IRQ manager for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#include "hwaccess.h"
+#include "8010.h"
+#include "cardmi.h"
+#include "cardmo.h"
+#include "irqmgr.h"
+
+/* Interrupt handler */
+
+void emu10k1_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct emu10k1_card *card = (struct emu10k1_card *) dev_id;
+	u32 irqstatus, irqstatus_tmp;
+
+	DPD(4, "emu10k1_interrupt called, irq =  %u\n", irq);
+
+	/*
+	 ** NOTE :
+	 ** We do a 'while loop' here cos on certain machines, with both
+	 ** playback and recording going on at the same time, IRQs will
+	 ** stop coming in after a while. Checking IPND indeed shows that
+	 ** there are interrupts pending but the PIC says no IRQs pending.
+	 ** I suspect that some boards need edge-triggered IRQs but are not
+	 ** getting that condition if we don't completely clear the IPND
+	 ** (make sure no more interrupts are pending).
+	 ** - Eric
+	 */
+
+	while ((irqstatus = inl(card->iobase + IPR))) {
+		DPD(4, "irq status %#x\n", irqstatus);
+
+		irqstatus_tmp = irqstatus;
+
+		if (irqstatus & IRQTYPE_TIMER) {
+			emu10k1_timer_irqhandler(card);
+			irqstatus &= ~IRQTYPE_TIMER;
+		}
+
+		if (irqstatus & IRQTYPE_DSP) {
+			emu10k1_dsp_irqhandler(card);
+			irqstatus &= ~IRQTYPE_DSP;
+		}
+
+		if (irqstatus & IRQTYPE_MPUIN) {
+			emu10k1_mpuin_irqhandler(card);
+			irqstatus &= ~IRQTYPE_MPUIN;
+		}
+
+		if (irqstatus & IRQTYPE_MPUOUT) {
+			emu10k1_mpuout_irqhandler(card);
+			irqstatus &= ~IRQTYPE_MPUOUT;
+		}
+
+		if (irqstatus & IPR_MUTE) {
+			emu10k1_mute_irqhandler(card);
+			irqstatus &=~IPR_MUTE;
+		}
+
+		if (irqstatus & IPR_VOLINCR) {
+			emu10k1_volincr_irqhandler(card);
+			irqstatus &=~IPR_VOLINCR;
+		}
+
+		if (irqstatus & IPR_VOLDECR) {
+			emu10k1_voldecr_irqhandler(card);
+			irqstatus &=~IPR_VOLDECR;
+		}
+
+		if (irqstatus){
+			printk(KERN_ERR "emu10k1: Warning, unhandled interrupt: 0x%08x\n", irqstatus);
+			//make sure any interrupts we don't handle are disabled:
+			emu10k1_irq_disable(card, ~(INTE_MIDIRXENABLE | INTE_MIDITXENABLE | INTE_INTERVALTIMERENB |
+						INTE_VOLDECRENABLE | INTE_VOLINCRENABLE | INTE_MUTEENABLE |
+						INTE_FXDSPENABLE));
+		}
+
+		/* acknowledge interrupt */
+                outl(irqstatus_tmp, card->iobase + IPR);
+	}
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/irqmgr.h patched/drivers/sound/audigy/irqmgr.h
--- old/drivers/sound/audigy/irqmgr.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/irqmgr.h	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,52 @@
+/*
+ **********************************************************************
+ *     irq.h
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#ifndef _IRQ_H
+#define _IRQ_H
+
+/* EMU Irq Types */
+#define IRQTYPE_PCIBUSERROR	IPR_PCIERROR
+#define IRQTYPE_MIXERBUTTON	(IPR_VOLINCR | IPR_VOLDECR | IPR_MUTE)
+#define IRQTYPE_VOICE		(IPR_CHANNELLOOP | IPR_CHANNELNUMBERMASK)
+#define IRQTYPE_RECORD		(IPR_ADCBUFFULL | IPR_ADCBUFHALFFULL | IPR_MICBUFFULL | IPR_MICBUFHALFFULL | IPR_EFXBUFFULL | IPR_EFXBUFHALFFULL)
+#define IRQTYPE_MPUOUT		(IPR_MIDITRANSBUFEMPTY | A_IPR_MIDITRANSBUFEMPTY2) 
+#define IRQTYPE_MPUIN		(IPR_MIDIRECVBUFEMPTY | A_IPR_MIDIRECVBUFEMPTY2)
+#define IRQTYPE_TIMER		IPR_INTERVALTIMER
+#define IRQTYPE_SPDIF		(IPR_GPSPDIFSTATUSCHANGE | IPR_CDROMSTATUSCHANGE)
+#define IRQTYPE_DSP		IPR_FXDSP
+
+void emu10k1_timer_irqhandler(struct emu10k1_card *);
+void emu10k1_dsp_irqhandler(struct emu10k1_card *);
+void emu10k1_mute_irqhandler(struct emu10k1_card *);
+void emu10k1_volincr_irqhandler(struct emu10k1_card *);
+void emu10k1_voldecr_irqhandler(struct emu10k1_card *);
+
+#endif /* _IRQ_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/joystick.c patched/drivers/sound/audigy/joystick.c
--- old/drivers/sound/audigy/joystick.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/joystick.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,214 @@
+/*
+ **********************************************************************
+ *     joystick.c - Creative EMU10K1 Joystick port driver
+ *     Copyright 2000 Rui Sousa.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     April  1, 2000       Rui Sousa       initial version 
+ *     April 28, 2000       Rui Sousa       fixed a kernel oops,
+ *					    make use of kcompat24 for
+ *					    2.2 kernels compatibility.
+ *     May    1, 2000       Rui Sousa       improved kernel compatibility
+ *                                          layer.
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/list.h>
+
+#include <emu_wrapper.h>
+
+#define DRIVER_VERSION "0.3.2"
+
+#ifndef PCI_VENDOR_ID_CREATIVE
+#define PCI_VENDOR_ID_CREATIVE 0x1102
+#endif
+
+#ifndef PCI_DEVICE_ID_CREATIVE_EMU10K1_JOYSTICK
+#define PCI_DEVICE_ID_CREATIVE_EMU10K1_JOYSTICK 0x7002
+#endif
+
+#ifndef PCI_DEVICE_ID_CREATIVE_AUDIGY_JOYSTICK
+#define PCI_DEVICE_ID_CREATIVE_AUDIGY_JOYSTICK 0x7003
+#endif
+
+
+
+/* PCI function 1 registers, address = <val> + PCIBASE1 */
+
+#define JOYSTICK1               0x00            /* Analog joystick port register                */
+#define JOYSTICK2               0x01            /* Analog joystick port register                */
+#define JOYSTICK3               0x02            /* Analog joystick port register                */
+#define JOYSTICK4               0x03            /* Analog joystick port register                */
+#define JOYSTICK5               0x04            /* Analog joystick port register                */
+#define JOYSTICK6               0x05            /* Analog joystick port register                */
+#define JOYSTICK7               0x06            /* Analog joystick port register                */
+#define JOYSTICK8               0x07            /* Analog joystick port register                */
+
+/* When writing, any write causes JOYSTICK_COMPARATOR output enable to be pulsed on write.      */
+/* When reading, use these bitfields: */
+#define JOYSTICK_BUTTONS        0x0f            /* Joystick button data                         */
+#define JOYSTICK_COMPARATOR     0xf0            /* Joystick comparator data                     */
+
+#define NR_DEV 5
+
+static int io[NR_DEV] = { 0, };
+
+enum {
+	EMU10K1_JOYSTICK = 0
+};
+
+static char *card_names[] = {
+	"EMU10K1 Joystick Port"
+};
+
+static struct pci_device_id emu10k1_joy_pci_tbl[] __devinitdata = {
+	{PCI_VENDOR_ID_CREATIVE, PCI_DEVICE_ID_CREATIVE_EMU10K1_JOYSTICK,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, EMU10K1_JOYSTICK},/*Sblive gameport */
+	 { PCI_VENDOR_ID_CREATIVE, PCI_DEVICE_ID_CREATIVE_AUDIGY_JOYSTICK,
+	   PCI_ANY_ID, PCI_ANY_ID, 0, 0, EMU10K1_JOYSTICK}, /* Audigy gameport */
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, emu10k1_joy_pci_tbl);
+
+struct emu10k1_joy_card {
+	struct list_head list;
+
+	struct pci_dev *pci_dev;
+	unsigned long iobase;
+	unsigned long length;
+	u8 addr_changed;
+};
+
+static LIST_HEAD(emu10k1_joy_devs);
+static unsigned int devindex = 0;
+
+/* Driver initialization routine */
+static int __devinit emu10k1_joy_probe(struct pci_dev *pci_dev, const struct pci_device_id *pci_id)
+{
+	struct emu10k1_joy_card *card;
+	u16 model;
+	u8 chiprev;
+
+	if ((card = kmalloc(sizeof(struct emu10k1_joy_card), GFP_KERNEL)) == NULL) {
+		printk(KERN_ERR "emu10k1-joy: out of memory\n");
+		return -ENOMEM;
+	}
+	memset(card, 0, sizeof(struct emu10k1_joy_card));
+
+	if (pci_enable_device(pci_dev)) {
+		printk(KERN_ERR "emu10k1-joy: couldn't enable device\n");
+		kfree(card);
+		return -ENODEV;
+	}
+
+	card->iobase = pci_resource_start(pci_dev, 0); 
+	card->length = pci_resource_len(pci_dev, 0);
+
+	if (compat_request_region(card->iobase, card->length, card_names[pci_id->driver_data])
+	    == NULL) {
+		printk(KERN_ERR "emu10k1-joy: IO space in use\n");
+		kfree(card);
+		return -ENODEV;
+	}
+
+	pci_set_drvdata(pci_dev, card);
+
+	card->pci_dev = pci_dev;
+	card->addr_changed = 0;
+
+	pci_read_config_byte(pci_dev, PCI_REVISION_ID, &chiprev);
+	pci_read_config_word(pci_dev, PCI_SUBSYSTEM_ID, &model);
+
+	printk(KERN_INFO "emu10k1-joy: %s rev %d model 0x%x found, IO at 0x%04lx-0x%04lx\n",
+		card_names[pci_id->driver_data], chiprev, model, card->iobase,
+		card->iobase + card->length - 1);
+
+	if (io[devindex]) {
+		if ((io[devindex] & ~0x18) != 0x200) {
+			printk(KERN_ERR "emu10k1-joy: invalid io value\n");
+			release_region(card->iobase, card->length);
+			kfree(card);
+			return -ENODEV;
+		}
+
+		card->addr_changed = 1;
+		pci_write_config_dword(pci_dev, PCI_BASE_ADDRESS_0, io[devindex]);
+		printk(KERN_INFO "emu10k1-joy: IO ports mirrored at 0x%03x\n", io[devindex]);
+	}
+
+	list_add(&card->list, &emu10k1_joy_devs);
+	devindex++;
+
+	return 0;
+}
+
+static void __devexit emu10k1_joy_remove(struct pci_dev *pci_dev)
+{
+	struct emu10k1_joy_card *card = pci_get_drvdata(pci_dev);
+
+	if(card->addr_changed)
+		pci_write_config_dword(pci_dev, PCI_BASE_ADDRESS_0, card->iobase);
+
+	release_region(card->iobase, card->length);
+
+	list_del(&card->list);
+	kfree(card);
+	pci_set_drvdata(pci_dev, NULL);
+}
+
+MODULE_PARM(io, "1-" __MODULE_STRING(NR_DEV) "i");
+MODULE_PARM_DESC(io, "sets joystick port address");
+MODULE_AUTHOR("Rui Sousa (Email to: emu10k1-devel@lists.sourceforge.net)");
+MODULE_DESCRIPTION("Creative EMU10K1 PCI Joystick Port v" DRIVER_VERSION
+		   "\nCopyright (C) 2000 Rui Sousa");
+
+static struct pci_driver emu10k1_joy_pci_driver = {
+	name:"emu10k1 joystick",
+	id_table:emu10k1_joy_pci_tbl,
+	probe:emu10k1_joy_probe,
+	remove:emu10k1_joy_remove,
+};
+
+static int __init emu10k1_joy_init_module(void)
+{
+	printk(KERN_INFO "Creative EMU10K1 PCI Joystick Port, version " DRIVER_VERSION ", " __TIME__
+	       " " __DATE__ "\n");
+
+	return pci_module_init(&emu10k1_joy_pci_driver);
+}
+
+static void __exit emu10k1_joy_cleanup_module(void)
+{
+	pci_unregister_driver(&emu10k1_joy_pci_driver);
+	return;
+}
+
+module_init(emu10k1_joy_init_module);
+module_exit(emu10k1_joy_cleanup_module);
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/main.c patched/drivers/sound/audigy/main.c
--- old/drivers/sound/audigy/main.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/main.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,1450 @@
+ /*
+ **********************************************************************
+ *     main.c - Creative EMU10K1 audio driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *     November 2, 1999     Alan Cox        cleaned up stuff
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ *
+ *      Supported devices:
+ *      /dev/dsp:        Standard /dev/dsp device, OSS-compatible
+ *      /dev/dsp1:       Routes to rear speakers only	 
+ *      /dev/mixer:      Standard /dev/mixer device, OSS-compatible
+ *      /dev/midi:       Raw MIDI UART device, mostly OSS-compatible
+ *	/dev/sequencer:  Sequencer Interface (requires sound.o)
+ *
+ *      Revision history:
+ *      0.1 beta Initial release
+ *      0.2 Lowered initial mixer vol. Improved on stuttering wave playback. Added MIDI UART support.
+ *      0.3 Fixed mixer routing bug, added APS, joystick support.
+ *      0.4 Added rear-channel, SPDIF support.
+ *	0.5 Source cleanup, SMP fixes, multiopen support, 64 bit arch fixes,
+ *	    moved bh's to tasklets, moved to the new PCI driver initialization style.
+ *	0.6 Make use of pci_alloc_consistent, improve compatibility layer for 2.2 kernels,
+ *	    code reorganization and cleanup.
+ *	0.7 Support for the Emu-APS. Bug fixes for voice cache setup, mmaped sound + poll().
+ *          Support for setting external TRAM size.
+ *      0.8 Make use of the kernel ac97 interface. Support for a dsp patch manager.
+ *      0.9 Re-enables rear speakers volume controls
+ *     0.10 Initializes rear speaker volume.
+ *	    Dynamic patch storage allocation.
+ *	    New private ioctls to change control gpr values.
+ *	    Enable volume control interrupts.
+ *	    By default enable dsp routes to digital out. 
+ *     0.11 Fixed fx / 4 problem.
+ *     0.12 Implemented mmaped for recording.
+ *	    Fixed bug: not unreserving mmaped buffer pages.
+ *	    IRQ handler cleanup.
+ *     0.13 Fixed problem with dsp1
+ *          Simplified dsp patch writing (inside the driver)
+ *	    Fixed several bugs found by the Stanford tools
+ *     0.14 New control gpr to oss mixer mapping feature (Chris Purnell)
+ *          Added AC3 Passthrough Support (Juha Yrjola)
+ *          Added Support for 5.1 cards (digital out and the third analog out)
+ *     0.15 Added Sequencer Support (Daniel Mack)
+ *          Support for multichannel pcm playback (Eduard Hasenleithner)
+ *     0.16 Mixer improvements, added old treble/bass support (Daniel Bertrand)
+ *          Small code format cleanup.
+ *          Deadlock bug fix for emu10k1_volxxx_irqhandler().
+ *     0.17 Fix for mixer SOUND_MIXER_INFO ioctl.
+ *	    Fix for HIGHMEM machines (emu10k1 can only do 31 bit bus master) 
+ *	    midi poll initial implementation.
+ *	    Small mixer fixes/cleanups.
+ *	    Improved support for 5.1 cards.
+ *     0.18 Fix for possible leak in pci_alloc_consistent()
+ *          Cleaned up poll() functions (audio and midi). Don't start input.
+ *	    Restrict DMA pages used to 512Mib range.
+ *	    New AC97_BOOST mixer ioctl.
+ *    0.19a Added Support for Audigy Cards
+ *	    Real fix for kernel with highmem support (cast dma_handle to u32).
+ *	    Fix recording buffering parameters calculation.
+ *	    Use unsigned long for variables in bit ops.
+ *    0.20a Fixed recording startup
+ *	    Fixed timer rate setting (it's a 16-bit register)
+ *********************************************************************/
+
+/* These are only included once per module */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+
+#include "hwaccess.h"
+#include "8010.h"
+#include "efxmgr.h"
+#include "cardwo.h"
+#include "cardwi.h"
+#include "cardmo.h"
+#include "cardmi.h"
+#include "recmgr.h"
+#include "ecard.h"
+
+
+#ifdef EMU10K1_SEQUENCER
+#define MIDI_SYNTH_NAME "EMU10K1 MIDI"
+#define MIDI_SYNTH_CAPS SYNTH_CAP_INPUT
+ 
+#include "../sound_config.h"
+#include "../midi_synth.h"
+
+/* this should be in dev_table.h */
+#define SNDCARD_EMU10K1 46
+#endif
+ 
+/* the emu10k1 should supprt 31 bit bus master */
+#define EMU10K1_DMA_MASK                0x7fffffff	/* DMA buffer mask for pci_alloc_consist */
+
+
+#ifndef PCI_VENDOR_ID_CREATIVE
+#define PCI_VENDOR_ID_CREATIVE 0x1102
+#endif
+
+#ifndef PCI_DEVICE_ID_CREATIVE_EMU10K1
+#define PCI_DEVICE_ID_CREATIVE_EMU10K1 0x0002
+#endif
+#ifndef PCI_DEVICE_ID_CREATIVE_AUDIGY
+#define PCI_DEVICE_ID_CREATIVE_AUDIGY 0x0004
+#endif
+
+#define EMU_APS_SUBID	0x40011102
+ 
+enum {
+	EMU10K1 = 0,
+	AUDIGY,
+};
+
+static char *card_names[] __devinitdata = {
+	"EMU10K1",
+	"Audigy",
+};
+
+static struct pci_device_id emu10k1_pci_tbl[] = {
+	{PCI_VENDOR_ID_CREATIVE, PCI_DEVICE_ID_CREATIVE_EMU10K1,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, EMU10K1},
+	{PCI_VENDOR_ID_CREATIVE, PCI_DEVICE_ID_CREATIVE_AUDIGY,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, AUDIGY},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, emu10k1_pci_tbl);
+
+/* Global var instantiation */
+
+LIST_HEAD(emu10k1_devs);
+
+extern struct file_operations emu10k1_audio_fops;
+extern struct file_operations emu10k1_mixer_fops;
+extern struct file_operations emu10k1_midi_fops;
+
+#ifdef EMU10K1_SEQUENCER
+static struct midi_operations emu10k1_midi_operations;
+#endif
+
+extern void emu10k1_interrupt(int, void *, struct pt_regs *s);
+
+static int __devinit emu10k1_audio_init(struct emu10k1_card *card)
+{
+	card->audio_dev = register_sound_dsp(&emu10k1_audio_fops, -1);
+	if (card->audio_dev < 0) {
+		printk(KERN_ERR "emu10k1: cannot register first audio device!\n");
+		goto err_dev;
+	}
+
+	card->audio_dev1 = register_sound_dsp(&emu10k1_audio_fops, -1);
+	if (card->audio_dev1 < 0) {
+		printk(KERN_ERR "emu10k1: cannot register second audio device!\n");
+		goto err_dev1;
+	}
+
+	/* Assign default playback voice parameters */
+	if (card->is_audigy)
+		card->mchannel_fx = 0;
+	else
+		card->mchannel_fx = 8;
+
+
+	if (card->is_audigy) {
+		/* mono voice */
+		card->waveout.send_dcba[SEND_MONO] = 0xffffffff;
+		card->waveout.send_hgfe[SEND_MONO] = 0x0000ffff;
+	
+		/* stereo voice */
+		/* left */
+		card->waveout.send_dcba[SEND_LEFT] = 0x00ff00ff;
+		card->waveout.send_hgfe[SEND_LEFT] = 0x00007f7f;	
+		/* right */
+		card->waveout.send_dcba[SEND_RIGHT] = 0xff00ff00;
+		card->waveout.send_hgfe[SEND_RIGHT] = 0x00007f7f;
+
+		card->waveout.send_routing[ROUTE_PCM] = 0x03020100; // Regular pcm
+		card->waveout.send_routing2[ROUTE_PCM] = 0x07060504;
+
+		card->waveout.send_routing[ROUTE_PT] = 0x3f3f3d3c; // Passthrough
+		card->waveout.send_routing2[ROUTE_PT] = 0x3f3f3f3f;
+		
+		card->waveout.send_routing[ROUTE_PCM1] = 0x03020100; // Spare
+		card->waveout.send_routing2[ROUTE_PCM1] = 0x07060404;
+		
+	} else {
+		/* mono voice */
+		card->waveout.send_dcba[SEND_MONO] = 0x0000ffff;
+	
+		/* stereo voice */
+		/* left */
+		card->waveout.send_dcba[SEND_LEFT] = 0x000000ff;
+		/* right */
+		card->waveout.send_dcba[SEND_RIGHT] = 0x0000ff00;
+
+		card->waveout.send_routing[ROUTE_PCM] = 0x3210; // pcm
+		card->waveout.send_routing[ROUTE_PT] = 0x3210; // passthrough
+		card->waveout.send_routing[ROUTE_PCM1] = 0x7654; // /dev/dsp1
+	}
+
+	/* Assign default recording parameters */
+	/* FIXME */
+	if (card->is_aps)
+		card->wavein.recsrc = WAVERECORD_FX;
+	else
+		card->wavein.recsrc = WAVERECORD_AC97;
+
+	card->wavein.fxwc = 0x0003;
+
+	return 0;
+
+err_dev1:
+	unregister_sound_dsp(card->audio_dev);
+err_dev:
+	return -ENODEV;
+}
+
+static void __devinit emu10k1_audio_cleanup(struct emu10k1_card *card)
+{
+	unregister_sound_dsp(card->audio_dev1);
+	unregister_sound_dsp(card->audio_dev);
+}
+
+int emu10k1_info_proc (char *page, char **start, off_t off,
+		    int count, int *eof, void *data)
+{
+	struct emu10k1_card *card = data;
+	int len = 0;
+	
+	if (card == NULL)
+		return -ENODEV;
+
+	len += sprintf (page + len, "Driver Version : %s\n", DRIVER_VERSION);
+	len += sprintf (page + len, "Card type      : %s\n", card->is_aps ? "Aps" : (card->is_audigy ? "Audigy" : "Emu10k1"));
+	len += sprintf (page + len, "Revision       : %d\n", card->chiprev);
+	len += sprintf (page + len, "Model          : %#06x\n", card->model);
+	len += sprintf (page + len, "IO             : %#06lx-%#06lx\n", card->iobase, card->iobase + card->length - 1);
+	len += sprintf (page + len, "IRQ            : %d\n\n", card->irq);
+	
+	len += sprintf (page + len, "Registered /dev Entries:\n");
+	len += sprintf (page + len, "/dev/dsp%d\n", card->audio_dev / 16);
+	len += sprintf (page + len, "/dev/dsp%d\n", card->audio_dev1 / 16);
+	len += sprintf (page + len, "/dev/mixer%d\n", card->ac97.dev_mixer / 16);
+	len += sprintf (page + len, "/dev/midi%d\n", card->midi_dev / 16);
+
+#ifdef EMU10K1_SEQUENCER
+	len += sprintf (page + len, "/dev/sequencer\n");
+#endif
+
+	return len;
+}
+
+static int __devinit emu10k1_proc_init(struct emu10k1_card *card)
+{
+	char s[32];
+
+	if (!proc_mkdir ("driver/emu10k1", 0)) {
+		printk(KERN_ERR "emu10k1: unable to create proc directory driver/emu10k1\n");
+		goto err_out;
+	}
+
+	sprintf(s, "driver/emu10k1/%s", card->pci_dev->slot_name);
+	if (!proc_mkdir (s, 0)) {
+		printk(KERN_ERR "emu10k1: unable to create proc directory %s\n", s);
+		goto err_emu10k1_proc;
+	}
+
+	sprintf(s, "driver/emu10k1/%s/info", card->pci_dev->slot_name);
+	if (!create_proc_read_entry (s, 0, 0, emu10k1_info_proc, card)) {
+		printk(KERN_ERR "emu10k1: unable to create proc entry %s\n", s);
+		goto err_dev_proc;
+	}
+
+	return 0;
+
+ err_dev_proc:
+	sprintf(s, "driver/emu10k1/%s", card->pci_dev->slot_name);
+	remove_proc_entry(s, NULL);
+
+ err_emu10k1_proc:
+	remove_proc_entry("driver/emu10k1", NULL);
+
+ err_out:
+	return -EIO;
+}
+
+static void __devinit emu10k1_proc_cleanup(struct emu10k1_card *card)
+{
+	char s[32];
+
+	sprintf(s, "driver/emu10k1/%s/info", card->pci_dev->slot_name);
+	remove_proc_entry(s, NULL);
+
+	sprintf(s, "driver/emu10k1/%s", card->pci_dev->slot_name);
+	remove_proc_entry(s, NULL);
+		
+	remove_proc_entry("driver/emu10k1", NULL);
+}
+
+static int __devinit emu10k1_mixer_init(struct emu10k1_card *card)
+{
+	char s[32];
+
+	struct ac97_codec *codec = &card->ac97;
+	card->ac97.dev_mixer = register_sound_mixer(&emu10k1_mixer_fops, -1);
+	if (card->ac97.dev_mixer < 0) {
+		printk(KERN_ERR "emu10k1: cannot register mixer device\n");
+		return -EIO;
+        }
+
+	card->ac97.private_data = card;
+
+	if (!card->is_aps) {
+		card->ac97.id = 0;
+		card->ac97.codec_read = emu10k1_ac97_read;
+        	card->ac97.codec_write = emu10k1_ac97_write;
+
+		if (ac97_probe_codec (&card->ac97) == 0) {
+			printk(KERN_ERR "emu10k1: unable to probe AC97 codec\n");
+			goto err_out;
+		}
+		/* 5.1: Enable the additional AC97 Slots and unmute extra channels on AC97 codec */
+		if (codec->codec_read(codec, AC97_EXTENDED_ID) & 0x0080){
+			printk(KERN_INFO "emu10k1: SBLive! 5.1 card detected\n"); 
+			sblive_writeptr(card, AC97SLOT, 0, AC97SLOT_CNTR | AC97SLOT_LFE);
+			codec->codec_write(codec, AC97_SURROUND_MASTER, 0x0);
+		}
+
+		// Force 5bit:		    
+		//card->ac97.bit_resolution=5;
+
+		sprintf(s, "driver/emu10k1/%s/ac97", card->pci_dev->slot_name);
+		if (!create_proc_read_entry (s, 0, 0, ac97_read_proc, &card->ac97)) {
+			printk(KERN_ERR "emu10k1: unable to create proc entry %s\n", s);
+			goto err_out;
+		}
+
+		/* these will store the original values and never be modified */
+		card->ac97_supported_mixers = card->ac97.supported_mixers;
+		card->ac97_stereo_mixers = card->ac97.stereo_mixers;
+	}
+
+	return 0;
+
+ err_out:
+	unregister_sound_mixer (card->ac97.dev_mixer);
+	return -EIO;
+}
+
+static void __devinit emu10k1_mixer_cleanup(struct emu10k1_card *card)
+{
+	char s[32];
+
+	if (!card->is_aps) {
+		sprintf(s, "driver/emu10k1/%s/ac97", card->pci_dev->slot_name);
+		remove_proc_entry(s, NULL);
+	}
+
+	unregister_sound_mixer (card->ac97.dev_mixer);
+}
+
+static int __devinit emu10k1_midi_init(struct emu10k1_card *card)
+{
+	int ret;
+
+	card->midi_dev = register_sound_midi(&emu10k1_midi_fops, -1);
+	if (card->midi_dev < 0) {
+                printk(KERN_ERR "emu10k1: cannot register midi device!\n");
+		return -ENODEV;
+        }
+
+
+	card->mpuout = kmalloc(sizeof(struct emu10k1_mpuout), GFP_KERNEL);
+	if (card->mpuout == NULL) {
+		printk(KERN_WARNING "emu10k1: Unable to allocate emu10k1_mpuout: out of memory\n");
+		ret = -ENOMEM;
+		goto err_out1;
+	}
+
+	memset(card->mpuout, 0, sizeof(struct emu10k1_mpuout));
+
+	card->mpuout->intr = 1;
+	card->mpuout->status = FLAGS_AVAILABLE;
+	card->mpuout->state = CARDMIDIOUT_STATE_DEFAULT;
+
+	tasklet_init(&card->mpuout->tasklet, emu10k1_mpuout_bh, (unsigned long) card);
+
+	spin_lock_init(&card->mpuout->lock);
+
+	card->mpuin = kmalloc(sizeof(struct emu10k1_mpuin), GFP_KERNEL);
+	if (card->mpuin == NULL) {
+		printk(KERN_WARNING "emu10k1: Unable to allocate emu10k1_mpuin: out of memory\n");
+		ret = -ENOMEM;
+                goto err_out2;
+	}
+
+	memset(card->mpuin, 0, sizeof(struct emu10k1_mpuin));
+
+	card->mpuin->status = FLAGS_AVAILABLE;
+
+	tasklet_init(&card->mpuin->tasklet, emu10k1_mpuin_bh, (unsigned long) card->mpuin);
+
+	spin_lock_init(&card->mpuin->lock);
+
+	/* Reset the MPU port */
+	if (emu10k1_mpu_reset(card) < 0) {
+		ERROR();
+		ret = -EIO;
+		goto err_out3;
+	}
+
+#ifdef EMU10K1_SEQUENCER
+	card->seq_dev = sound_alloc_mididev();
+	if (card->seq_dev == -1)
+			printk(KERN_WARNING "emu10k1: unable to register sequencer device!");
+	else {
+			std_midi_synth.midi_dev = card->seq_dev;
+			midi_devs[card->seq_dev] = 
+					(struct midi_operations *)
+					kmalloc(sizeof(struct midi_operations), GFP_KERNEL);
+			
+			if (midi_devs[card->seq_dev] == NULL) {
+				printk(KERN_ERR "emu10k1: unable to allocate memory!");
+				sound_unload_mididev(card->seq_dev);
+				card->seq_dev = -1;
+				return 0;
+			} else {
+				memcpy((char *)midi_devs[card->seq_dev], 
+					(char *)&emu10k1_midi_operations, 
+					sizeof(struct midi_operations));
+				midi_devs[card->seq_dev]->devc = card;
+				sequencer_init();
+			}
+	}
+	card->seq_mididev = 0;
+#endif
+	return 0;
+
+err_out3:
+	kfree(card->mpuin);
+err_out2:
+	kfree(card->mpuout);
+err_out1:
+	unregister_sound_midi(card->midi_dev);
+	return ret;
+}
+
+static void __devinit emu10k1_midi_cleanup(struct emu10k1_card *card)
+{
+	tasklet_kill(&card->mpuout->tasklet);
+	kfree(card->mpuout);
+
+	tasklet_kill(&card->mpuin->tasklet);
+	kfree(card->mpuin);
+
+#ifdef EMU10K1_SEQUENCER
+	if (card->seq_dev > -1) {
+		kfree(midi_devs[card->seq_dev]);
+		midi_devs[card->seq_dev] = NULL;
+		sound_unload_mididev(card->seq_dev);
+		card->seq_dev = -1;
+	}
+#endif
+
+	unregister_sound_midi(card->midi_dev);
+}
+
+static void __devinit voice_init(struct emu10k1_card *card)
+{
+	int i;
+
+	for (i = 0; i < NUM_G; i++)
+		card->voicetable[i] = VOICE_USAGE_FREE;
+}
+
+static void __devinit timer_init(struct emu10k1_card *card)
+{
+	INIT_LIST_HEAD(&card->timers);
+	card->timer_delay = TIMER_STOPPED;
+	card->timer_lock = SPIN_LOCK_UNLOCKED;
+}
+
+static void __devinit addxmgr_init(struct emu10k1_card *card)
+{
+	u32 count;
+
+	for (count = 0; count < MAXPAGES; count++)
+		card->emupagetable[count] = 0;
+
+	/* Mark first page as used */
+	/* This page is reserved by the driver */
+	card->emupagetable[0] = 0x8001;
+	card->emupagetable[1] = MAXPAGES - 1;
+}
+
+static void __devinit fx_cleanup(struct patch_manager *mgr)
+{
+	int i;
+	for(i = 0; i < mgr->current_pages; i++)
+		free_page((unsigned long) mgr->patch[i]);
+}
+
+static int __devinit fx_init(struct emu10k1_card *card)
+{
+	struct patch_manager *mgr = &card->mgr;
+	struct dsp_patch *patch;
+	struct dsp_rpatch *rpatch;
+	s32 left, right;
+	int i;
+	u32 pc = 0;
+	u32 patch_n=0;
+	struct emu_efx_info_t emu_efx_info[2]=
+		{{ 20, 10, 0x400, 0x100, 0x20 },
+		 { 24, 12, 0x600, 0x400, 0x60 },
+		}; 
+			
+
+	for (i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
+		mgr->ctrl_gpr[i][0] = -1;
+		mgr->ctrl_gpr[i][1] = -1;
+	}
+
+
+	if (card->is_audigy)
+		mgr->current_pages = (2 + PATCHES_PER_PAGE - 1) / PATCHES_PER_PAGE;
+	else
+		/* !! The number below must equal the number of patches, currently 11 !! */
+		mgr->current_pages = (11 + PATCHES_PER_PAGE - 1) / PATCHES_PER_PAGE;
+	
+	for (i = 0; i < mgr->current_pages; i++) {
+		mgr->patch[i] = (void *)__get_free_page(GFP_KERNEL);
+		if (mgr->patch[i] == NULL) {
+			mgr->current_pages = i;
+			fx_cleanup(mgr);
+			return -ENOMEM;
+		}
+		memset(mgr->patch[i], 0, PAGE_SIZE);
+	}
+
+	if (card->is_audigy) {
+		for (i = 0; i < 1024; i++)
+			OP(0xf, 0x0c0, 0x0c0, 0x0cf, 0x0c0);
+
+		for (i = 0; i < 512 ; i++)
+			sblive_writeptr(card, A_GPR_BASE+i,0,0);
+
+		pc=0;
+
+		//Pcm input volume
+		OP(0, 0x402, 0x0c0, 0x406, 0x000);
+		OP(0, 0x403, 0x0c0, 0x407, 0x001);
+
+		//CD-Digital input Volume
+		OP(0, 0x404, 0x0c0, 0x40d, 0x42);
+		OP(0, 0x405, 0x0c0, 0x40f, 0x43);
+
+		// CD + PCM 
+		OP(6, 0x400, 0x0c0, 0x402, 0x404);
+		OP(6, 0x401, 0x0c0, 0x403, 0x405);
+		
+		// Front Output + Master Volume
+		OP(0, 0x68, 0x0c0, 0x408, 0x400);
+		OP(0, 0x69, 0x0c0, 0x409, 0x401);
+
+		// Add-in analog inputs for other speakers
+		OP(6, 0x400, 0x40, 0x400, 0xc0);
+		OP(6, 0x401, 0x41, 0x401, 0xc0);
+
+		// Digital Front + Master Volume
+		OP(0, 0x60, 0x0c0, 0x408, 0x400);
+		OP(0, 0x61, 0x0c0, 0x409, 0x401);
+
+		// Rear Output + Rear Volume
+		OP(0, 0x06e, 0x0c0, 0x419, 0x400);
+		OP(0, 0x06f, 0x0c0, 0x41a, 0x401);		
+
+		// Digital Rear Output + Rear Volume
+		OP(0, 0x066, 0x0c0, 0x419, 0x400);
+		OP(0, 0x067, 0x0c0, 0x41a, 0x401);		
+
+		// Audigy Drive, Headphone out
+		OP(6, 0x64, 0x0c0, 0x0c0, 0x400);
+		OP(6, 0x65, 0x0c0, 0x0c0, 0x401);
+
+		// ac97 Recording
+		OP(6, 0x76, 0x0c0, 0x0c0, 0x40);
+		OP(6, 0x77, 0x0c0, 0x0c0, 0x41);
+		
+		// Center = sub = Left/2 + Right/2
+		OP(0xe, 0x400, 0x401, 0xcd, 0x400);
+
+		// center/sub  Volume (master)
+		OP(0, 0x06a, 0x0c0, 0x408, 0x400);
+		OP(0, 0x06b, 0x0c0, 0x409, 0x400);
+
+		// Digital center/sub  Volume (master)
+		OP(0, 0x062, 0x0c0, 0x408, 0x400);
+		OP(0, 0x063, 0x0c0, 0x409, 0x400);
+
+		ROUTING_PATCH_START(rpatch, "Routing");
+		ROUTING_PATCH_END(rpatch);
+
+		/* delimiter patch */
+		patch = PATCH(mgr, patch_n);
+		patch->code_size = 0;
+
+	
+		sblive_writeptr(card, 0x53, 0, 0);
+	} else {
+		for (i = 0; i < 512 ; i++)
+			OP(6, 0x40, 0x40, 0x40, 0x40);
+
+		for (i = 0; i < 256; i++)
+			sblive_writeptr_tag(card, 0,
+					    FXGPREGBASE + i, 0,
+					    TANKMEMADDRREGBASE + i, 0,
+					    TAGLIST_END);
+
+		
+		pc = 0;
+
+		//first free GPR = 0x11b
+	
+		
+		/* FX volume correction and Volume control*/
+		INPUT_PATCH_START(patch, "Pcm L vol", 0x0, 0);
+		GET_OUTPUT_GPR(patch, 0x100, 0x0);
+		GET_CONTROL_GPR(patch, 0x106, "Vol", 0, 0x7fffffff);
+		GET_DYNAMIC_GPR(patch, 0x112);
+
+		OP(4, 0x112, 0x40, PCM_IN_L, 0x44); //*4	
+		OP(0, 0x100, 0x040, 0x112, 0x106);  //*vol	
+		INPUT_PATCH_END(patch);
+
+
+		INPUT_PATCH_START(patch, "Pcm R vol", 0x1, 0);
+		GET_OUTPUT_GPR(patch, 0x101, 0x1);
+		GET_CONTROL_GPR(patch, 0x107, "Vol", 0, 0x7fffffff);
+		GET_DYNAMIC_GPR(patch, 0x112);
+
+		OP(4, 0x112, 0x40, PCM_IN_R, 0x44); 
+		OP(0, 0x101, 0x040, 0x112, 0x107);
+
+		INPUT_PATCH_END(patch);
+
+
+		// CD-Digital In Volume control	
+		INPUT_PATCH_START(patch, "CD-Digital Vol L", 0x12, 0);
+		GET_OUTPUT_GPR(patch, 0x10c, 0x12);
+		GET_CONTROL_GPR(patch, 0x10d, "Vol", 0, 0x7fffffff);
+
+		OP(0, 0x10c, 0x040, SPDIF_CD_L, 0x10d);
+		INPUT_PATCH_END(patch);
+
+		INPUT_PATCH_START(patch, "CD-Digital Vol R", 0x13, 0);
+		GET_OUTPUT_GPR(patch, 0x10e, 0x13);
+		GET_CONTROL_GPR(patch, 0x10f, "Vol", 0, 0x7fffffff);
+
+		OP(0, 0x10e, 0x040, SPDIF_CD_R, 0x10f);
+		INPUT_PATCH_END(patch);
+
+		//Volume Correction for Multi-channel Inputs	
+		INPUT_PATCH_START(patch, "Multi-Channel Gain", 0x08, 0);
+		patch->input=patch->output=0x3F00;
+
+		GET_OUTPUT_GPR(patch, 0x113, MULTI_FRONT_L);
+		GET_OUTPUT_GPR(patch, 0x114, MULTI_FRONT_R);
+		GET_OUTPUT_GPR(patch, 0x115, MULTI_REAR_L);
+		GET_OUTPUT_GPR(patch, 0x116, MULTI_REAR_R);
+		GET_OUTPUT_GPR(patch, 0x117, MULTI_CENTER);
+		GET_OUTPUT_GPR(patch, 0x118, MULTI_LFE);
+
+		OP(4, 0x113, 0x40, MULTI_FRONT_L, 0x44);
+		OP(4, 0x114, 0x40, MULTI_FRONT_R, 0x44);
+		OP(4, 0x115, 0x40, MULTI_REAR_L, 0x44);
+		OP(4, 0x116, 0x40, MULTI_REAR_R, 0x44);
+		OP(4, 0x117, 0x40, MULTI_CENTER, 0x44);
+		OP(4, 0x118, 0x40, MULTI_LFE, 0x44);
+	
+		INPUT_PATCH_END(patch);
+
+
+		//Routing patch start	
+		ROUTING_PATCH_START(rpatch, "Routing");
+		GET_INPUT_GPR(rpatch, 0x100, 0x0);
+		GET_INPUT_GPR(rpatch, 0x101, 0x1);
+		GET_INPUT_GPR(rpatch, 0x10c, 0x12);
+		GET_INPUT_GPR(rpatch, 0x10e, 0x13);
+		GET_INPUT_GPR(rpatch, 0x113, MULTI_FRONT_L);
+		GET_INPUT_GPR(rpatch, 0x114, MULTI_FRONT_R);
+		GET_INPUT_GPR(rpatch, 0x115, MULTI_REAR_L);
+		GET_INPUT_GPR(rpatch, 0x116, MULTI_REAR_R);
+		GET_INPUT_GPR(rpatch, 0x117, MULTI_CENTER);
+		GET_INPUT_GPR(rpatch, 0x118, MULTI_LFE);
+
+		GET_DYNAMIC_GPR(rpatch, 0x102);
+		GET_DYNAMIC_GPR(rpatch, 0x103);
+
+		GET_OUTPUT_GPR(rpatch, 0x104, 0x8);
+		GET_OUTPUT_GPR(rpatch, 0x105, 0x9);
+		GET_OUTPUT_GPR(rpatch, 0x10a, 0x2);
+		GET_OUTPUT_GPR(rpatch, 0x10b, 0x3);
+		
+		
+		/* input buffer */
+		OP(6, 0x102, AC97_IN_L, 0x40, 0x40);
+		OP(6, 0x103, AC97_IN_R, 0x40, 0x40);
+
+
+		/* Digital In + PCM + MULTI_FRONT-> AC97 out (front speakers)*/
+		OP(6, AC97_FRONT_L, 0x100, 0x10c, 0x113);
+
+		CONNECT(MULTI_FRONT_L, AC97_FRONT_L);
+		CONNECT(PCM_IN_L, AC97_FRONT_L);
+		CONNECT(SPDIF_CD_L, AC97_FRONT_L);
+
+		OP(6, AC97_FRONT_R, 0x101, 0x10e, 0x114);
+
+		CONNECT(MULTI_FRONT_R, AC97_FRONT_R);
+		CONNECT(PCM_IN_R, AC97_FRONT_R);
+		CONNECT(SPDIF_CD_R, AC97_FRONT_R);
+
+		/* Digital In + PCM + AC97 In + PCM1 + MULTI_REAR --> Rear Channel */ 
+		OP(6, 0x104, PCM1_IN_L, 0x100, 0x115);
+		OP(6, 0x104, 0x104, 0x10c, 0x102);
+
+		CONNECT(MULTI_REAR_L, ANALOG_REAR_L);
+		CONNECT(AC97_IN_L, ANALOG_REAR_L);
+		CONNECT(PCM_IN_L, ANALOG_REAR_L);
+		CONNECT(SPDIF_CD_L, ANALOG_REAR_L);
+		CONNECT(PCM1_IN_L, ANALOG_REAR_L);
+
+		OP(6, 0x105, PCM1_IN_R, 0x101, 0x116);
+		OP(6, 0x105, 0x105, 0x10e, 0x103);
+
+		CONNECT(MULTI_REAR_R, ANALOG_REAR_R);
+		CONNECT(AC97_IN_R, ANALOG_REAR_R);
+		CONNECT(PCM_IN_R, ANALOG_REAR_R);
+		CONNECT(SPDIF_CD_R, ANALOG_REAR_R);
+		CONNECT(PCM1_IN_R, ANALOG_REAR_R);
+
+		/* Digital In + PCM + AC97 In + MULTI_FRONT --> Digital out */
+		OP(6, 0x10b, 0x100, 0x102, 0x10c);
+		OP(6, 0x10b, 0x10b, 0x113, 0x40);
+
+		CONNECT(MULTI_FRONT_L, DIGITAL_OUT_L);
+		CONNECT(PCM_IN_L, DIGITAL_OUT_L);
+		CONNECT(AC97_IN_L, DIGITAL_OUT_L);
+		CONNECT(SPDIF_CD_L, DIGITAL_OUT_L);
+
+		OP(6, 0x10a, 0x101, 0x103, 0x10e);
+		OP(6, 0x10b, 0x10b, 0x114, 0x40);
+
+		CONNECT(MULTI_FRONT_R, DIGITAL_OUT_R);
+		CONNECT(PCM_IN_R, DIGITAL_OUT_R);
+		CONNECT(AC97_IN_R, DIGITAL_OUT_R);
+		CONNECT(SPDIF_CD_R, DIGITAL_OUT_R);
+
+		/* AC97 In --> ADC Recording Buffer */
+		OP(6, ADC_REC_L, 0x102, 0x40, 0x40);
+
+		CONNECT(AC97_IN_L, ADC_REC_L);
+
+		OP(6, ADC_REC_R, 0x103, 0x40, 0x40);
+
+		CONNECT(AC97_IN_R, ADC_REC_R);
+
+
+		/* fx12:Analog-Center */
+		OP(6, ANALOG_CENTER, 0x117, 0x40, 0x40);
+		CONNECT(MULTI_CENTER, ANALOG_CENTER);
+
+		/* fx11:Analog-LFE */
+		OP(6, ANALOG_LFE, 0x118, 0x40, 0x40);
+		CONNECT(MULTI_LFE, ANALOG_LFE);
+
+		/* fx12:Digital-Center */
+		OP(6, DIGITAL_CENTER, 0x117, 0x40, 0x40);
+		CONNECT(MULTI_CENTER, DIGITAL_CENTER);
+		
+		/* fx11:Analog-LFE */
+		OP(6, DIGITAL_LFE, 0x118, 0x40, 0x40);
+		CONNECT(MULTI_LFE, DIGITAL_LFE);
+	
+		ROUTING_PATCH_END(rpatch);
+
+
+		// Rear volume control	
+		OUTPUT_PATCH_START(patch, "Vol Rear L", 0x8, 0);
+		GET_INPUT_GPR(patch, 0x104, 0x8);
+		GET_CONTROL_GPR(patch, 0x119, "Vol", 0, 0x7fffffff);
+
+		OP(0, ANALOG_REAR_L, 0x040, 0x104, 0x119);
+		OUTPUT_PATCH_END(patch);
+
+		OUTPUT_PATCH_START(patch, "Vol Rear R", 0x9, 0);
+		GET_INPUT_GPR(patch, 0x105, 0x9);
+		GET_CONTROL_GPR(patch, 0x11a, "Vol", 0, 0x7fffffff);
+
+		OP(0, ANALOG_REAR_R, 0x040, 0x105, 0x11a);
+		OUTPUT_PATCH_END(patch);
+
+
+		//Master volume control on front-digital	
+		OUTPUT_PATCH_START(patch, "Vol Master L", 0x2, 1);
+		GET_INPUT_GPR(patch, 0x10a, 0x2);
+		GET_CONTROL_GPR(patch, 0x108, "Vol", 0, 0x7fffffff);
+
+		OP(0, DIGITAL_OUT_L, 0x040, 0x10a, 0x108);
+		OUTPUT_PATCH_END(patch);
+
+
+		OUTPUT_PATCH_START(patch, "Vol Master R", 0x3, 1);
+		GET_INPUT_GPR(patch, 0x10b, 0x3);
+		GET_CONTROL_GPR(patch, 0x109, "Vol", 0, 0x7fffffff);
+
+		OP(0, DIGITAL_OUT_R, 0x040, 0x10b, 0x109);
+		OUTPUT_PATCH_END(patch);
+
+
+		/* delimiter patch */
+		patch = PATCH(mgr, patch_n);
+		patch->code_size = 0;
+
+	
+		sblive_writeptr(card, DBG, 0, 0);
+	}
+
+	mgr->lock = SPIN_LOCK_UNLOCKED;
+
+	// Set up Volume controls, try to keep this the same for both Audigy and Live
+
+	//Master volume
+	mgr->ctrl_gpr[SOUND_MIXER_VOLUME][0] = 8;
+	mgr->ctrl_gpr[SOUND_MIXER_VOLUME][1] = 9;
+
+	left = card->ac97.mixer_state[SOUND_MIXER_VOLUME] & 0xff;
+	right = (card->ac97.mixer_state[SOUND_MIXER_VOLUME] >> 8) & 0xff;
+
+	emu10k1_set_volume_gpr(card, 8, left, 1 << card->ac97.bit_resolution);
+	emu10k1_set_volume_gpr(card, 9, right, 1 << card->ac97.bit_resolution);
+
+	//Rear volume
+	mgr->ctrl_gpr[ SOUND_MIXER_OGAIN ][0] = 0x19;
+	mgr->ctrl_gpr[ SOUND_MIXER_OGAIN ][1] = 0x1a;
+
+	left = right = 67;
+	card->ac97.mixer_state[SOUND_MIXER_OGAIN] = (right << 8) | left;
+
+	card->ac97.supported_mixers |= SOUND_MASK_OGAIN;
+	card->ac97.stereo_mixers |= SOUND_MASK_OGAIN;
+
+	emu10k1_set_volume_gpr(card, 0x19, left, VOL_5BIT);
+	emu10k1_set_volume_gpr(card, 0x1a, right, VOL_5BIT);
+
+	//PCM Volume
+	mgr->ctrl_gpr[SOUND_MIXER_PCM][0] = 6;
+	mgr->ctrl_gpr[SOUND_MIXER_PCM][1] = 7;
+
+	left = card->ac97.mixer_state[SOUND_MIXER_PCM] & 0xff;
+	right = (card->ac97.mixer_state[SOUND_MIXER_PCM] >> 8) & 0xff;
+
+	emu10k1_set_volume_gpr(card, 6, left, VOL_5BIT);
+	emu10k1_set_volume_gpr(card, 7, right, VOL_5BIT);
+
+	//CD-Digital Volume
+	mgr->ctrl_gpr[SOUND_MIXER_DIGITAL1][0] = 0xd;
+	mgr->ctrl_gpr[SOUND_MIXER_DIGITAL1][1] = 0xf;
+
+	left = right = 67;
+	card->ac97.mixer_state[SOUND_MIXER_DIGITAL1] = (right << 8) | left; 
+
+	card->ac97.supported_mixers |= SOUND_MASK_DIGITAL1;
+	card->ac97.stereo_mixers |= SOUND_MASK_DIGITAL1;
+
+	emu10k1_set_volume_gpr(card, 0xd, left, VOL_5BIT);
+	emu10k1_set_volume_gpr(card, 0xf, right, VOL_5BIT);
+
+
+	//hard wire the ac97's pcm, pcm volume is done above using dsp code.
+	if (card->is_audigy)
+		//for Audigy, we mute it and use the philips 6 channel DAC instead
+		emu10k1_ac97_write(&card->ac97, 0x18, 0x8000);
+	else
+		//For the Live we hardwire it to full volume
+		emu10k1_ac97_write(&card->ac97, 0x18, 0x0);
+
+	//remove it from the ac97_codec's control
+	card->ac97_supported_mixers &= ~SOUND_MASK_PCM;
+	card->ac97_stereo_mixers &= ~SOUND_MASK_PCM;
+
+	//set Igain to 0dB by default, maybe consider hardwiring it here.
+	emu10k1_ac97_write(&card->ac97, AC97_RECORD_GAIN, 0x0000);
+	card->ac97.mixer_state[SOUND_MIXER_IGAIN] = 0x101; 
+
+	return 0;
+}
+
+static int __devinit hw_init(struct emu10k1_card *card)
+{
+	int nCh;
+	u32 pagecount; /* tmp */
+	int ret;
+
+	/* Disable audio and lock cache */
+	emu10k1_writefn0(card, HCFG, HCFG_LOCKSOUNDCACHE | HCFG_LOCKTANKCACHE_MASK | HCFG_MUTEBUTTONENABLE);
+
+	/* Reset recording buffers */
+	sblive_writeptr_tag(card, 0,
+			    MICBS, ADCBS_BUFSIZE_NONE,
+			    MICBA, 0,
+			    FXBS, ADCBS_BUFSIZE_NONE,
+			    FXBA, 0,
+			    ADCBS, ADCBS_BUFSIZE_NONE,
+			    ADCBA, 0,
+			    TAGLIST_END);
+
+	/* Disable channel interrupt */
+	emu10k1_writefn0(card, INTE, 0);
+
+	sblive_writeptr_tag(card, 0,
+			    CLIEL, 0,
+			    CLIEH, 0,
+			    SOLEL, 0,
+			    SOLEH, 0,
+			    TAGLIST_END);
+
+	if (card->is_audigy) {
+		sblive_writeptr_tag(card,0,
+				    0x5e,0xf00,
+				    0x5f,0x3,
+				    TAGLIST_END);
+	}
+
+	/* Init envelope engine */
+	for (nCh = 0; nCh < NUM_G; nCh++) {
+		sblive_writeptr_tag(card, nCh,
+				    DCYSUSV, 0,
+				    IP, 0,
+				    VTFT, 0xffff,
+				    CVCF, 0xffff,
+				    PTRX, 0,
+				    //CPF, 0,
+				    CCR, 0,
+
+				    PSST, 0,
+				    DSL, 0x10,
+				    CCCA, 0,
+				    Z1, 0,
+				    Z2, 0,
+				    FXRT, 0xd01c0000,
+
+				    ATKHLDM, 0,
+				    DCYSUSM, 0,
+				    IFATN, 0xffff,
+				    PEFE, 0,
+				    FMMOD, 0,
+				    TREMFRQ, 24,	/* 1 Hz */
+				    FM2FRQ2, 24,	/* 1 Hz */
+				    TEMPENV, 0,
+
+				    /*** These are last so OFF prevents writing ***/
+				    LFOVAL2, 0,
+				    LFOVAL1, 0,
+				    ATKHLDV, 0,
+				    ENVVOL, 0,
+				    ENVVAL, 0,
+                                    TAGLIST_END);
+
+		sblive_writeptr(card, CPF, nCh, 0);
+		/*
+		  Audigy FXRT initialization
+		  reversed eng'd, may not be accurate.
+		 */
+		if (card->is_audigy) {
+			sblive_writeptr_tag(card,nCh,
+					    0x4c,0x0,
+					    0x4d,0x0,
+					    0x4e,0x0,
+					    0x4f,0x0,
+					    A_FXRT1, 0x3f3f3f3f,
+					    A_FXRT2, 0x3f3f3f3f,
+					    A_SENDAMOUNTS, 0,
+					    TAGLIST_END);
+		}
+	}
+	
+
+	/*
+	 ** Init to 0x02109204 :
+	 ** Clock accuracy    = 0     (1000ppm)
+	 ** Sample Rate       = 2     (48kHz)
+	 ** Audio Channel     = 1     (Left of 2)
+	 ** Source Number     = 0     (Unspecified)
+	 ** Generation Status = 1     (Original for Cat Code 12)
+	 ** Cat Code          = 12    (Digital Signal Mixer)
+	 ** Mode              = 0     (Mode 0)
+	 ** Emphasis          = 0     (None)
+	 ** CP                = 1     (Copyright unasserted)
+	 ** AN                = 0     (Digital audio)
+	 ** P                 = 0     (Consumer)
+	 */
+
+	sblive_writeptr_tag(card, 0,
+
+			    /* SPDIF0 */
+			    SPCS0, (SPCS_CLKACCY_1000PPM | 0x002000000 |
+				    SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC | SPCS_GENERATIONSTATUS | 0x00001200 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT),
+
+			    /* SPDIF1 */
+			    SPCS1, (SPCS_CLKACCY_1000PPM | 0x002000000 |
+				    SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC | SPCS_GENERATIONSTATUS | 0x00001200 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT),
+
+			    /* SPDIF2 & SPDIF3 */
+			    SPCS2, (SPCS_CLKACCY_1000PPM | 0x002000000 |
+				    SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC | SPCS_GENERATIONSTATUS | 0x00001200 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT),
+
+			    TAGLIST_END);
+
+	if (card->is_audigy && (card->chiprev == 4)) {
+		/* Hacks for Alice3 to work independent of haP16V driver */
+		u32 tmp;
+
+		//Setup SRCMulti_I2S SamplingRate
+		tmp = sblive_readptr(card, A_SPDIF_SAMPLERATE, 0);
+		tmp &= 0xfffff1ff;
+		tmp |= (0x2<<9);
+		sblive_writeptr(card, A_SPDIF_SAMPLERATE, 0, tmp);
+
+		/* Setup SRCSel (Enable Spdif,I2S SRCMulti) */
+		emu10k1_writefn0(card, 0x20, 0x600000);
+		emu10k1_writefn0(card, 0x24, 0x14);
+
+		/* Setup SRCMulti Input Audio Enable */
+		emu10k1_writefn0(card, 0x20, 0x6E0000);
+		emu10k1_writefn0(card, 0x24, 0xFF00FF00);
+	}
+
+	ret = fx_init(card);		/* initialize effects engine */
+	if (ret < 0)
+		return ret;
+
+	card->tankmem.size = 0;
+
+	card->virtualpagetable.size = MAXPAGES * sizeof(u32);
+
+	card->virtualpagetable.addr = pci_alloc_consistent(card->pci_dev, card->virtualpagetable.size, &card->virtualpagetable.dma_handle);
+	if (card->virtualpagetable.addr == NULL) {
+		ERROR();
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	card->silentpage.size = EMUPAGESIZE;
+
+	card->silentpage.addr = pci_alloc_consistent(card->pci_dev, card->silentpage.size, &card->silentpage.dma_handle);
+	if (card->silentpage.addr == NULL) {
+		ERROR();
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	for (pagecount = 0; pagecount < MAXPAGES; pagecount++)
+		((u32 *) card->virtualpagetable.addr)[pagecount] = cpu_to_le32(((u32) card->silentpage.dma_handle * 2) | 
+pagecount);
+
+	/* Init page table & tank memory base register */
+	sblive_writeptr_tag(card, 0,
+			    PTB, (u32) card->virtualpagetable.dma_handle,
+			    TCB, 0,
+			    TCBS, 0,
+			    TAGLIST_END);
+
+	for (nCh = 0; nCh < NUM_G; nCh++) {
+		sblive_writeptr_tag(card, nCh,
+				    MAPA, MAP_PTI_MASK | ((u32) card->silentpage.dma_handle * 2),
+				    MAPB, MAP_PTI_MASK | ((u32) card->silentpage.dma_handle * 2),
+				    TAGLIST_END);
+	}
+
+	/* Hokay, now enable the AUD bit */
+	/* Enable Audio = 1 */
+	/* Mute Disable Audio = 0 */
+	/* Lock Tank Memory = 1 */
+	/* Lock Sound Memory = 0 */
+	/* Auto Mute = 1 */
+	if (card->is_audigy) {
+		if (card->chiprev == 4)
+			emu10k1_writefn0(card, HCFG, HCFG_AUDIOENABLE  | HCFG_AC3ENABLE_CDSPDIF | HCFG_AC3ENABLE_GPSPDIF | HCFG_AUTOMUTE | HCFG_JOYENABLE);
+		else
+		emu10k1_writefn0(card, HCFG, HCFG_AUDIOENABLE  | HCFG_AUTOMUTE | HCFG_JOYENABLE);
+	} else {
+		if (card->model == 0x20 || card->model == 0xc400 ||
+		 (card->model == 0x21 && card->chiprev < 6))
+	        emu10k1_writefn0(card, HCFG, HCFG_AUDIOENABLE  | HCFG_LOCKTANKCACHE_MASK | HCFG_AUTOMUTE);
+	else
+		emu10k1_writefn0(card, HCFG, HCFG_AUDIOENABLE  | HCFG_LOCKTANKCACHE_MASK | HCFG_AUTOMUTE | HCFG_JOYENABLE);
+	}
+	/* Enable Vol_Ctrl irqs */
+	emu10k1_irq_enable(card, INTE_VOLINCRENABLE | INTE_VOLDECRENABLE | INTE_MUTEENABLE | INTE_FXDSPENABLE);
+
+	if (card->is_audigy && (card->chiprev == 4)) {
+		/* Unmute Analog now.  Set GPO6 to 1 for Apollo.
+		 * This has to be done after init ALice3 I2SOut beyond 48KHz.
+		 * So, sequence is important. */
+		u32 tmp = emu10k1_readfn0(card, A_IOCFG);
+		tmp |= 0x0040;
+		emu10k1_writefn0(card, A_IOCFG, tmp);
+	}
+	
+	/* FIXME: TOSLink detection */
+	card->has_toslink = 0;
+
+	/* Initialize digital passthrough variables */
+	card->pt.pos_gpr = card->pt.intr_gpr = card->pt.enable_gpr = -1;
+	card->pt.selected = 0;
+	card->pt.state = PT_STATE_INACTIVE;
+	card->pt.spcs_to_use = 0x01;
+	card->pt.patch_name = "AC3pass";
+	card->pt.intr_gpr_name = "count";
+	card->pt.enable_gpr_name = "enable";
+	card->pt.pos_gpr_name = "ptr";
+	spin_lock_init(&card->pt.lock);
+	init_waitqueue_head(&card->pt.wait);
+
+/*	tmp = sblive_readfn0(card, HCFG);
+	if (tmp & (HCFG_GPINPUT0 | HCFG_GPINPUT1)) {
+		sblive_writefn0(card, HCFG, tmp | 0x800);
+
+		udelay(512);
+
+		if (tmp != (sblive_readfn0(card, HCFG) & ~0x800)) {
+			card->has_toslink = 1;
+			sblive_writefn0(card, HCFG, tmp);
+		}
+	}
+*/
+	return 0;
+
+  err1:
+	pci_free_consistent(card->pci_dev, card->virtualpagetable.size, card->virtualpagetable.addr, card->virtualpagetable.dma_handle);
+  err0:
+	fx_cleanup(&card->mgr);
+
+	return ret;
+}
+
+static int __devinit emu10k1_init(struct emu10k1_card *card)
+{
+	/* Init Card */
+	if (hw_init(card) < 0)
+		return -1;
+
+	voice_init(card);
+	timer_init(card);
+	addxmgr_init(card);
+
+	DPD(2, "  hw control register -> %#x\n", emu10k1_readfn0(card, HCFG));
+
+	return 0;
+}
+
+static void __devinit emu10k1_cleanup(struct emu10k1_card *card)
+{
+	int ch;
+
+	emu10k1_writefn0(card, INTE, 0);
+
+	/** Shutdown the chip **/
+	for (ch = 0; ch < NUM_G; ch++)
+		sblive_writeptr(card, DCYSUSV, ch, 0);
+
+	for (ch = 0; ch < NUM_G; ch++) {
+		sblive_writeptr_tag(card, ch,
+				    VTFT, 0,
+				    CVCF, 0,
+				    PTRX, 0,
+				    //CPF, 0,
+				    TAGLIST_END);
+		sblive_writeptr(card, CPF, ch, 0);
+	}
+
+	/* Disable audio and lock cache */
+	emu10k1_writefn0(card, HCFG, HCFG_LOCKSOUNDCACHE | HCFG_LOCKTANKCACHE_MASK | HCFG_MUTEBUTTONENABLE);
+
+	sblive_writeptr_tag(card, 0,
+                            PTB, 0,
+
+			    /* Reset recording buffers */
+			    MICBS, ADCBS_BUFSIZE_NONE,
+			    MICBA, 0,
+			    FXBS, ADCBS_BUFSIZE_NONE,
+			    FXBA, 0,
+			    FXWC, 0,
+			    ADCBS, ADCBS_BUFSIZE_NONE,
+			    ADCBA, 0,
+			    TCBS, 0,
+			    TCB, 0,
+			    DBG, 0x8000,
+
+			    /* Disable channel interrupt */
+			    CLIEL, 0,
+			    CLIEH, 0,
+			    SOLEL, 0,
+			    SOLEH, 0,
+			    TAGLIST_END);
+
+	if (card->is_audigy)
+		sblive_writeptr(card, 0, A_DBG,  A_DBG_SINGLE_STEP);
+
+
+	pci_free_consistent(card->pci_dev, card->virtualpagetable.size, card->virtualpagetable.addr, card->virtualpagetable.dma_handle);
+	pci_free_consistent(card->pci_dev, card->silentpage.size, card->silentpage.addr, card->silentpage.dma_handle);
+	
+	if(card->tankmem.size != 0)
+		pci_free_consistent(card->pci_dev, card->tankmem.size, card->tankmem.addr, card->tankmem.dma_handle);
+
+	/* release patch storage memory */
+	fx_cleanup(&card->mgr);
+}
+
+/* Driver initialization routine */
+static int __devinit emu10k1_probe(struct pci_dev *pci_dev, const struct pci_device_id *pci_id)
+{
+	struct emu10k1_card *card;
+	u32 subsysvid;
+	int ret;
+
+	if (pci_set_dma_mask(pci_dev, EMU10K1_DMA_MASK)) {
+		printk(KERN_ERR "emu10k1: architecture does not support 31bit PCI busmaster DMA\n");
+		return -ENODEV;
+	}
+
+	if (pci_enable_device(pci_dev))
+		return -EIO;
+
+	pci_set_master(pci_dev);
+
+	if ((card = kmalloc(sizeof(struct emu10k1_card), GFP_KERNEL)) == NULL) {
+                printk(KERN_ERR "emu10k1: out of memory\n");
+                return -ENOMEM;
+        }
+        memset(card, 0, sizeof(struct emu10k1_card));
+
+	card->iobase = pci_resource_start(pci_dev, 0);
+	card->length = pci_resource_len(pci_dev, 0); 
+
+	if (request_region(card->iobase, card->length, card_names[pci_id->driver_data]) == NULL) {
+		printk(KERN_ERR "emu10k1: IO space in use\n");
+		ret = -EBUSY;
+		goto err_region;
+	}
+
+	pci_set_drvdata(pci_dev, card);
+
+	card->irq = pci_dev->irq;
+	card->pci_dev = pci_dev;
+
+	/* Reserve IRQ Line */
+	if (request_irq(card->irq, emu10k1_interrupt, SA_SHIRQ, card_names[pci_id->driver_data], card)) {
+		printk(KERN_ERR "emu10k1: IRQ in use\n");
+		ret = -EBUSY;
+		goto err_irq;
+	}
+
+	pci_read_config_byte(pci_dev, PCI_REVISION_ID, &card->chiprev);
+	pci_read_config_word(pci_dev, PCI_SUBSYSTEM_ID, &card->model);
+
+	printk(KERN_INFO "emu10k1: %s rev %d model 0x%04x found, IO at 0x%04lx-0x%04lx, IRQ %d\n",
+		card_names[pci_id->driver_data], card->chiprev, card->model, card->iobase,
+		card->iobase + card->length - 1, card->irq);
+
+	if (pci_id->device == PCI_DEVICE_ID_CREATIVE_AUDIGY)
+		card->is_audigy = 1;
+
+	pci_read_config_dword(pci_dev, PCI_SUBSYSTEM_VENDOR_ID, &subsysvid);
+	card->is_aps = (subsysvid == EMU_APS_SUBID);
+
+	spin_lock_init(&card->lock);
+	init_MUTEX(&card->open_sem);
+	card->open_mode = 0;
+	init_waitqueue_head(&card->open_wait);
+
+	ret = emu10k1_audio_init(card);
+	if(ret < 0) {
+                printk(KERN_ERR "emu10k1: cannot initialize audio devices\n");
+                goto err_audio;
+        }
+
+	ret = emu10k1_proc_init(card);
+	if(ret < 0) {
+		printk(KERN_ERR "emu10k1: cannot initialize proc directory\n");
+                goto err_proc;
+	}
+
+	ret = emu10k1_mixer_init(card);
+	if(ret < 0) {
+		printk(KERN_ERR "emu10k1: cannot initialize AC97 codec\n");
+                goto err_mixer;
+	}
+
+	ret = emu10k1_midi_init(card);
+	if (ret < 0) {
+		printk(KERN_ERR "emu10k1: cannot register midi device\n");
+		goto err_midi;
+	}
+
+	ret = emu10k1_init(card);
+	if (ret < 0) {
+		printk(KERN_ERR "emu10k1: cannot initialize device\n");
+		goto err_emu10k1_init;
+	}
+
+	if (card->is_aps)
+		emu10k1_ecard_init(card);
+
+	list_add(&card->list, &emu10k1_devs);
+
+	return 0;
+
+err_emu10k1_init:
+	emu10k1_midi_cleanup(card);
+
+err_midi:
+	emu10k1_mixer_cleanup(card);
+
+err_mixer:
+	emu10k1_proc_cleanup(card);
+
+err_proc:
+	emu10k1_audio_cleanup(card);
+
+err_audio:
+	free_irq(card->irq, card);
+
+err_irq:
+	release_region(card->iobase, card->length);
+	pci_set_drvdata(pci_dev, NULL);
+
+err_region:
+	kfree(card);
+
+	return ret;
+}
+
+	
+static void __devexit emu10k1_remove(struct pci_dev *pci_dev)
+{
+	struct emu10k1_card *card = pci_get_drvdata(pci_dev);
+
+	list_del(&card->list);
+
+	emu10k1_cleanup(card);
+	emu10k1_midi_cleanup(card);
+	emu10k1_mixer_cleanup(card);
+	emu10k1_proc_cleanup(card);
+	emu10k1_audio_cleanup(card);	
+	free_irq(card->irq, card);
+	release_region(card->iobase, card->length);
+	kfree(card);
+	pci_set_drvdata(pci_dev, NULL);
+}
+
+MODULE_AUTHOR("Bertrand Lee, Cai Ying. (Email to: emu10k1-devel@lists.sourceforge.net)");
+MODULE_DESCRIPTION("Creative EMU10K1 PCI Audio Driver v" DRIVER_VERSION "\nCopyright (C) 1999 Creative Technology Ltd.");
+MODULE_LICENSE("GPL");
+
+static struct pci_driver emu10k1_pci_driver = {
+	name:		"emu10k1",
+	id_table:	emu10k1_pci_tbl,
+	probe:		emu10k1_probe,
+	remove:		__devexit_p(emu10k1_remove),
+};
+
+static int __init emu10k1_init_module(void)
+{
+	printk(KERN_INFO "Creative EMU10K1 PCI Audio Driver, version " DRIVER_VERSION ", " __TIME__ " " __DATE__ "\n");
+
+	return pci_module_init(&emu10k1_pci_driver);
+}
+
+static void __exit emu10k1_cleanup_module(void)
+{
+	pci_unregister_driver(&emu10k1_pci_driver);
+
+	return;
+}
+
+module_init(emu10k1_init_module);
+module_exit(emu10k1_cleanup_module);
+
+#ifdef EMU10K1_SEQUENCER
+
+/* in midi.c */
+extern int emu10k1_seq_midi_open(int dev, int mode, 
+				void (*input)(int dev, unsigned char midi_byte),
+				void (*output)(int dev));
+extern void emu10k1_seq_midi_close(int dev);
+extern int emu10k1_seq_midi_out(int dev, unsigned char midi_byte);
+extern int emu10k1_seq_midi_start_read(int dev);
+extern int emu10k1_seq_midi_end_read(int dev);
+extern void emu10k1_seq_midi_kick(int dev);
+extern int emu10k1_seq_midi_buffer_status(int dev);
+
+static struct midi_operations emu10k1_midi_operations =
+{
+	THIS_MODULE,
+	{"EMU10K1 MIDI", 0, 0, SNDCARD_EMU10K1},
+	&std_midi_synth,
+	{0},
+	emu10k1_seq_midi_open,
+	emu10k1_seq_midi_close,
+	NULL,
+	emu10k1_seq_midi_out,
+	emu10k1_seq_midi_start_read,
+	emu10k1_seq_midi_end_read,
+	emu10k1_seq_midi_kick,
+	NULL,
+	emu10k1_seq_midi_buffer_status,
+	NULL
+};
+
+#endif
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/Makefile patched/drivers/sound/audigy/Makefile
--- old/drivers/sound/audigy/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/Makefile	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,24 @@
+# Makefile for Creative Labs EMU10K1 
+#
+# 12 Apr 2000 Rui Sousa
+
+O_TARGET := audigy.o
+
+obj-y := audio.o cardmi.o cardmo.o cardwi.o cardwo.o efxmgr.o emuadxmg.o \
+	hwaccess.o irqmgr.o main.o midi.o mixer.o recmgr.o timer.o voicemgr.o \
+	ecard.o passthrough.o
+
+obj-m := $(O_TARGET)
+
+ifdef DEBUG
+    EXTRA_CFLAGS += -DEMU10K1_DEBUG
+endif
+
+ifdef CONFIG_MIDI_EMU10K1
+    EXTRA_CFLAGS += -DEMU10K1_SEQUENCER
+endif
+
+include $(TOPDIR)/Rules.make
+
+clean:
+	rm -f core *.o *.a *.s
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/midi.c patched/drivers/sound/audigy/midi.c
--- old/drivers/sound/audigy/midi.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/midi.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,622 @@
+/*
+ **********************************************************************
+ *     midi.c - /dev/midi interface for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <asm/uaccess.h>
+
+#include "hwaccess.h"
+#include "cardmo.h"
+#include "cardmi.h"
+#include "midi.h"
+
+#ifdef EMU10K1_SEQUENCER
+#include "../sound_config.h"
+#endif
+
+static spinlock_t midi_spinlock __attribute((unused)) = SPIN_LOCK_UNLOCKED;
+
+static void init_midi_hdr(struct midi_hdr *midihdr)
+{
+	midihdr->bufferlength = MIDIIN_BUFLEN;
+	midihdr->bytesrecorded = 0;
+	midihdr->flags = 0;
+}
+
+static int midiin_add_buffer(struct emu10k1_mididevice *midi_dev, struct midi_hdr **midihdrptr)
+{
+	struct midi_hdr *midihdr;
+
+	if ((midihdr = (struct midi_hdr *) kmalloc(sizeof(struct midi_hdr), GFP_KERNEL)) == NULL) {
+		ERROR();
+		return -EINVAL;
+	}
+
+	init_midi_hdr(midihdr);
+
+	if ((midihdr->data = (u8 *) kmalloc(MIDIIN_BUFLEN, GFP_KERNEL)) == NULL) {
+		ERROR();
+		kfree(midihdr);
+		return -1;
+	}
+
+	if (emu10k1_mpuin_add_buffer(midi_dev->card->mpuin, midihdr) < 0) {
+		ERROR();
+		kfree(midihdr->data);
+		kfree(midihdr);
+		return -1;
+	}
+
+	*midihdrptr = midihdr;
+	list_add_tail(&midihdr->list, &midi_dev->mid_hdrs);
+
+	return 0;
+}
+
+static int emu10k1_midi_open(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(inode->i_rdev);
+	struct emu10k1_card *card = NULL;
+	struct emu10k1_mididevice *midi_dev;
+	struct list_head *entry;
+
+	DPF(2, "emu10k1_midi_open()\n");
+
+	/* Check for correct device to open */
+	list_for_each(entry, &emu10k1_devs) {
+		card = list_entry(entry, struct emu10k1_card, list);
+
+		if (card->midi_dev == minor)
+			goto match;
+	}
+
+	return -ENODEV;
+
+match:
+#ifdef EMU10K1_SEQUENCER
+	if (card->seq_mididev)	/* card is opened by sequencer */
+		return -EBUSY;
+#endif
+	
+	/* Wait for device to become free */
+	down(&card->open_sem);
+	while (card->open_mode & (file->f_mode << FMODE_MIDI_SHIFT)) {
+		if (file->f_flags & O_NONBLOCK) {
+			up(&card->open_sem);
+			return -EBUSY;
+		}
+
+		up(&card->open_sem);
+		interruptible_sleep_on(&card->open_wait);
+
+		if (signal_pending(current)) {
+			return -ERESTARTSYS;
+		}
+
+		down(&card->open_sem);
+	}
+
+	if ((midi_dev = (struct emu10k1_mididevice *) kmalloc(sizeof(*midi_dev), GFP_KERNEL)) == NULL)
+		return -EINVAL;
+
+	midi_dev->card = card;
+	midi_dev->mistate = MIDIIN_STATE_STOPPED;
+	init_waitqueue_head(&midi_dev->oWait);
+	init_waitqueue_head(&midi_dev->iWait);
+	midi_dev->ird = 0;
+	midi_dev->iwr = 0;
+	midi_dev->icnt = 0;
+	INIT_LIST_HEAD(&midi_dev->mid_hdrs);
+
+	if (file->f_mode & FMODE_READ) {
+		struct midi_openinfo dsCardMidiOpenInfo;
+		struct midi_hdr *midihdr1;
+		struct midi_hdr *midihdr2;
+
+		dsCardMidiOpenInfo.refdata = (unsigned long) midi_dev;
+
+		if (emu10k1_mpuin_open(card, &dsCardMidiOpenInfo) < 0) {
+			ERROR();
+			kfree(midi_dev);
+			return -ENODEV;
+		}
+
+		/* Add two buffers to receive sysex buffer */
+		if (midiin_add_buffer(midi_dev, &midihdr1) < 0) {
+			kfree(midi_dev);
+			return -ENODEV;
+		}
+
+		if (midiin_add_buffer(midi_dev, &midihdr2) < 0) {
+			list_del(&midihdr1->list);
+			kfree(midihdr1->data);
+			kfree(midihdr1);
+			kfree(midi_dev);
+			return -ENODEV;
+		}
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		struct midi_openinfo dsCardMidiOpenInfo;
+
+		dsCardMidiOpenInfo.refdata = (unsigned long) midi_dev;
+
+		if (emu10k1_mpuout_open(card, &dsCardMidiOpenInfo) < 0) {
+			ERROR();
+			kfree(midi_dev);
+			return -ENODEV;
+		}
+	}
+
+	file->private_data = (void *) midi_dev;
+
+	card->open_mode |= (file->f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ | FMODE_MIDI_WRITE);
+
+	up(&card->open_sem);
+
+	return 0;
+}
+
+static int emu10k1_midi_release(struct inode *inode, struct file *file)
+{
+	struct emu10k1_mididevice *midi_dev = (struct emu10k1_mididevice *) file->private_data;
+	struct emu10k1_card *card;
+
+	lock_kernel();
+
+	card = midi_dev->card;
+	DPF(2, "emu10k1_midi_release()\n");
+
+	if (file->f_mode & FMODE_WRITE) {
+		if (!(file->f_flags & O_NONBLOCK)) {
+
+			while (!signal_pending(current) && (card->mpuout->firstmidiq != NULL)) {
+				DPF(4, "Cannot close - buffers not empty\n");
+
+				interruptible_sleep_on(&midi_dev->oWait);
+
+			}
+		}
+
+		emu10k1_mpuout_close(card);
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		struct midi_hdr *midihdr;
+
+		if (midi_dev->mistate == MIDIIN_STATE_STARTED) {
+			emu10k1_mpuin_stop(card);
+			midi_dev->mistate = MIDIIN_STATE_STOPPED;
+		}
+
+		emu10k1_mpuin_reset(card);
+		emu10k1_mpuin_close(card);
+
+		while (!list_empty(&midi_dev->mid_hdrs)) {
+			midihdr = list_entry(midi_dev->mid_hdrs.next, struct midi_hdr, list);
+
+			list_del(midi_dev->mid_hdrs.next);
+			kfree(midihdr->data);
+			kfree(midihdr);
+		}
+	}
+
+	kfree(midi_dev);
+
+	down(&card->open_sem);
+	card->open_mode &= ~((file->f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ | FMODE_MIDI_WRITE));
+	up(&card->open_sem);
+	wake_up_interruptible(&card->open_wait);
+
+	unlock_kernel();
+
+	return 0;
+}
+
+static ssize_t emu10k1_midi_read(struct file *file, char *buffer, size_t count, loff_t * pos)
+{
+	struct emu10k1_mididevice *midi_dev = (struct emu10k1_mididevice *) file->private_data;
+	ssize_t ret = 0;
+	u16 cnt;
+	unsigned long flags;
+
+	DPD(4, "emu10k1_midi_read(), count %#x\n", (u32) count);
+
+	if (pos != &file->f_pos)
+		return -ESPIPE;
+
+	if (!access_ok(VERIFY_WRITE, buffer, count))
+		return -EFAULT;
+
+	if (midi_dev->mistate == MIDIIN_STATE_STOPPED) {
+		if (emu10k1_mpuin_start(midi_dev->card) < 0) {
+			ERROR();
+			return -EINVAL;
+		}
+
+		midi_dev->mistate = MIDIIN_STATE_STARTED;
+	}
+
+	while (count > 0) {
+		cnt = MIDIIN_BUFLEN - midi_dev->ird;
+
+		spin_lock_irqsave(&midi_spinlock, flags);
+
+		if (midi_dev->icnt < cnt)
+			cnt = midi_dev->icnt;
+
+		spin_unlock_irqrestore(&midi_spinlock, flags);
+
+		if (cnt > count)
+			cnt = count;
+
+		if (cnt <= 0) {
+			if (file->f_flags & O_NONBLOCK)
+				return ret ? ret : -EAGAIN;
+			DPF(2, " Go to sleep...\n");
+
+			interruptible_sleep_on(&midi_dev->iWait);
+
+			if (signal_pending(current))
+				return ret ? ret : -ERESTARTSYS;
+
+			continue;
+		}
+
+		if (copy_to_user(buffer, midi_dev->iBuf + midi_dev->ird, cnt)) {
+			ERROR();
+			return ret ? ret : -EFAULT;
+		}
+
+		midi_dev->ird += cnt;
+		midi_dev->ird %= MIDIIN_BUFLEN;
+
+		spin_lock_irqsave(&midi_spinlock, flags);
+
+		midi_dev->icnt -= cnt;
+
+		spin_unlock_irqrestore(&midi_spinlock, flags);
+
+		count -= cnt;
+		buffer += cnt;
+		ret += cnt;
+
+		if (midi_dev->icnt == 0)
+			break;
+	}
+
+	return ret;
+}
+
+static ssize_t emu10k1_midi_write(struct file *file, const char *buffer, size_t count, loff_t * pos)
+{
+	struct emu10k1_mididevice *midi_dev = (struct emu10k1_mididevice *) file->private_data;
+	struct midi_hdr *midihdr;
+	ssize_t ret = 0;
+	unsigned long flags;
+
+	DPD(4, "emu10k1_midi_write(), count=%#x\n", (u32) count);
+
+	if (pos != &file->f_pos)
+		return -ESPIPE;
+
+	if (!access_ok(VERIFY_READ, buffer, count))
+		return -EFAULT;
+
+	if ((midihdr = (struct midi_hdr *) kmalloc(sizeof(struct midi_hdr), GFP_KERNEL)) == NULL)
+		return -EINVAL;
+
+	midihdr->bufferlength = count;
+	midihdr->bytesrecorded = 0;
+	midihdr->flags = 0;
+
+	if ((midihdr->data = (u8 *) kmalloc(count, GFP_KERNEL)) == NULL) {
+		ERROR();
+		kfree(midihdr);
+		return -EINVAL;
+	}
+
+	if (copy_from_user(midihdr->data, buffer, count)) {
+		kfree(midihdr->data);
+		kfree(midihdr);
+		return ret ? ret : -EFAULT;
+	}
+
+	spin_lock_irqsave(&midi_spinlock, flags);
+
+	if (emu10k1_mpuout_add_buffer(midi_dev->card, midihdr) < 0) {
+		ERROR();
+		kfree(midihdr->data);
+		kfree(midihdr);
+		spin_unlock_irqrestore(&midi_spinlock, flags);
+		return -EINVAL;
+	}
+
+	spin_unlock_irqrestore(&midi_spinlock, flags);
+
+	return count;
+}
+
+static unsigned int emu10k1_midi_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct emu10k1_mididevice *midi_dev = (struct emu10k1_mididevice *) file->private_data;
+	unsigned long flags;
+	unsigned int mask = 0;
+
+	DPF(4, "emu10k1_midi_poll() called\n");
+
+	if (file->f_mode & FMODE_WRITE)
+		poll_wait(file, &midi_dev->oWait, wait);
+
+	if (file->f_mode & FMODE_READ)
+		poll_wait(file, &midi_dev->iWait, wait);
+
+	spin_lock_irqsave(&midi_spinlock, flags);
+
+	if (file->f_mode & FMODE_WRITE)
+		mask |= POLLOUT | POLLWRNORM;
+
+	if (file->f_mode & FMODE_READ) {
+		if (midi_dev->mistate == MIDIIN_STATE_STARTED)
+			if (midi_dev->icnt > 0)
+				mask |= POLLIN | POLLRDNORM;
+	}
+
+	spin_unlock_irqrestore(&midi_spinlock, flags);
+
+	return mask;
+}
+
+int emu10k1_midi_callback(unsigned long msg, unsigned long refdata, unsigned long *pmsg)
+{
+	struct emu10k1_mididevice *midi_dev = (struct emu10k1_mididevice *) refdata;
+	struct midi_hdr *midihdr = NULL;
+	unsigned long flags;
+	int i;
+
+	DPF(4, "emu10k1_midi_callback()\n");
+
+	spin_lock_irqsave(&midi_spinlock, flags);
+
+	switch (msg) {
+	case ICARDMIDI_OUTLONGDATA:
+		midihdr = (struct midi_hdr *) pmsg[2];
+
+		kfree(midihdr->data);
+		kfree(midihdr);
+		wake_up_interruptible(&midi_dev->oWait);
+
+		break;
+
+	case ICARDMIDI_INLONGDATA:
+		midihdr = (struct midi_hdr *) pmsg[2];
+
+		for (i = 0; i < midihdr->bytesrecorded; i++) {
+			midi_dev->iBuf[midi_dev->iwr++] = midihdr->data[i];
+			midi_dev->iwr %= MIDIIN_BUFLEN;
+		}
+
+		midi_dev->icnt += midihdr->bytesrecorded;
+
+		if (midi_dev->mistate == MIDIIN_STATE_STARTED) {
+			init_midi_hdr(midihdr);
+			emu10k1_mpuin_add_buffer(midi_dev->card->mpuin, midihdr);
+			wake_up_interruptible(&midi_dev->iWait);
+		}
+		break;
+
+	case ICARDMIDI_INDATA:
+		{
+			u8 *pBuf = (u8 *) & pmsg[1];
+			u16 bytesvalid = pmsg[2];
+
+			for (i = 0; i < bytesvalid; i++) {
+				midi_dev->iBuf[midi_dev->iwr++] = pBuf[i];
+				midi_dev->iwr %= MIDIIN_BUFLEN;
+			}
+
+			midi_dev->icnt += bytesvalid;
+		}
+
+		wake_up_interruptible(&midi_dev->iWait);
+		break;
+
+	default:		/* Unknown message */
+		spin_unlock_irqrestore(&midi_spinlock, flags);
+		return -1;
+	}
+
+	spin_unlock_irqrestore(&midi_spinlock, flags);
+
+	return 0;
+}
+
+/* MIDI file operations */
+struct file_operations emu10k1_midi_fops = {
+	owner:		THIS_MODULE,
+	read:		emu10k1_midi_read,
+	write:		emu10k1_midi_write,
+	poll:		emu10k1_midi_poll,
+	open:		emu10k1_midi_open,
+	release:	emu10k1_midi_release,
+};
+
+
+#ifdef EMU10K1_SEQUENCER
+
+/* functions used for sequencer access */
+
+int emu10k1_seq_midi_open(int dev, int mode,
+				void (*input) (int dev, unsigned char data),
+				void (*output) (int dev))
+{
+	struct emu10k1_card *card;
+	struct midi_openinfo dsCardMidiOpenInfo;
+	struct emu10k1_mididevice *midi_dev;
+
+	if (midi_devs[dev] == NULL || midi_devs[dev]->devc == NULL)
+		return -EINVAL;
+
+	card = midi_devs[dev]->devc;
+
+	if (card->open_mode)		/* card is opened native */
+		return -EBUSY;
+			
+	DPF(2, "emu10k1_seq_midi_open()\n");
+	
+	if ((midi_dev = (struct emu10k1_mididevice *) kmalloc(sizeof(*midi_dev), GFP_KERNEL)) == NULL)
+		return -EINVAL;
+
+	midi_dev->card = card;
+	midi_dev->mistate = MIDIIN_STATE_STOPPED;
+	init_waitqueue_head(&midi_dev->oWait);
+	init_waitqueue_head(&midi_dev->iWait);
+	midi_dev->ird = 0;
+	midi_dev->iwr = 0;
+	midi_dev->icnt = 0;
+	INIT_LIST_HEAD(&midi_dev->mid_hdrs);
+
+	dsCardMidiOpenInfo.refdata = (unsigned long) midi_dev;
+
+	if (emu10k1_mpuout_open(card, &dsCardMidiOpenInfo) < 0) {
+		ERROR();
+		return -ENODEV;
+	}
+
+	card->seq_mididev = midi_dev;
+		
+	return 0;
+}
+
+void emu10k1_seq_midi_close(int dev)
+{
+	struct emu10k1_card *card;
+
+	DPF(2, "emu10k1_seq_midi_close()\n");
+	if (midi_devs[dev] == NULL || midi_devs[dev]->devc == NULL)
+		return;
+
+	card = midi_devs[dev]->devc;
+	emu10k1_mpuout_close(card);
+
+	if (card->seq_mididev) {
+		kfree(card->seq_mididev);
+		card->seq_mididev = 0;
+	}
+}
+
+int emu10k1_seq_midi_out(int dev, unsigned char midi_byte)
+{
+	struct emu10k1_card *card;
+	struct midi_hdr *midihdr;
+	unsigned long flags;
+
+	if (midi_devs[dev] == NULL || midi_devs[dev]->devc == NULL)
+		return -EINVAL;
+
+	card = midi_devs[dev]->devc;
+
+	if ((midihdr = (struct midi_hdr *) kmalloc(sizeof(struct midi_hdr), GFP_KERNEL)) == NULL)
+		return -EINVAL;
+
+	midihdr->bufferlength = 1;
+	midihdr->bytesrecorded = 0;
+	midihdr->flags = 0;
+
+	if ((midihdr->data = (u8 *) kmalloc(1, GFP_KERNEL)) == NULL) {
+		ERROR();
+		kfree(midihdr);
+		return -EINVAL;
+	}
+
+	*(midihdr->data) = midi_byte;
+	
+	spin_lock_irqsave(&midi_spinlock, flags);
+
+	if (emu10k1_mpuout_add_buffer(card, midihdr) < 0) {
+		ERROR();
+		kfree(midihdr->data);
+		kfree(midihdr);
+		spin_unlock_irqrestore(&midi_spinlock, flags);
+		return -EINVAL;
+	}
+
+	spin_unlock_irqrestore(&midi_spinlock, flags);
+
+	return 1;
+}
+
+int emu10k1_seq_midi_start_read(int dev)
+{
+	return 0;
+}
+
+int emu10k1_seq_midi_end_read(int dev)
+{
+	return 0;
+}
+
+void emu10k1_seq_midi_kick(int dev)
+{
+}
+
+int emu10k1_seq_midi_buffer_status(int dev)
+{
+	int count;
+	struct midi_queue *queue;
+	struct emu10k1_card *card;
+
+	if (midi_devs[dev] == NULL || midi_devs[dev]->devc == NULL)
+		return -EINVAL;
+
+	count = 0;
+
+	card = midi_devs[dev]->devc;
+	queue = card->mpuout->firstmidiq;
+
+	while (queue != NULL) {
+		count++;
+		if (queue == card->mpuout->lastmidiq)
+			break;
+
+		queue = queue->next;
+	}
+
+	return count;
+}
+
+#endif
+
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/midi.h patched/drivers/sound/audigy/midi.h
--- old/drivers/sound/audigy/midi.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/midi.h	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,78 @@
+/*     
+ **********************************************************************
+ *     midi.h
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     Date                 Author          Summary of changes 
+ *     ----                 ------          ------------------ 
+ *     October 20, 1999     Bertrand Lee    base code release 
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */ 
+
+#ifndef _MIDI_H
+#define _MIDI_H
+
+#define FMODE_MIDI_SHIFT 3
+#define FMODE_MIDI_READ  (FMODE_READ << FMODE_MIDI_SHIFT)
+#define FMODE_MIDI_WRITE (FMODE_WRITE << FMODE_MIDI_SHIFT)
+
+#define MIDIIN_STATE_STARTED 0x00000001
+#define MIDIIN_STATE_STOPPED 0x00000002
+
+#define MIDIIN_BUFLEN 1024
+
+struct emu10k1_mididevice
+{
+	struct emu10k1_card *card;
+	u32 mistate;
+	wait_queue_head_t oWait;
+	wait_queue_head_t iWait;
+	s8 iBuf[MIDIIN_BUFLEN];
+	u16 ird, iwr, icnt;
+	struct list_head mid_hdrs;
+};
+
+/* uncomment next line to use midi port on Audigy drive */
+//#define USE_AUDIGY_DRIVE_MIDI
+
+#ifdef USE_AUDIGY_DRIVE_MIDI
+#define A_MUDATA	A_MUDATA2
+#define A_MUCMD		A_MUCMD2
+#define A_MUSTAT	A_MUCMD2
+#define A_IPR_MIDITRANSBUFEMPTY	A_IPR_MIDITRANSBUFEMPTY2
+#define A_IPR_MIDIRECVBUFEMPTY	A_IPR_MIDIRECVBUFEMPTY2
+#define A_INTE_MIDITXENABLE	A_INTE_MIDITXENABLE2
+#define A_INTE_MIDIRXENABLE	A_INTE_MIDIRXENABLE2
+#else
+#define A_MUDATA	A_MUDATA1
+#define A_MUCMD		A_MUCMD1
+#define A_MUSTAT	A_MUCMD1
+#define A_IPR_MIDITRANSBUFEMPTY	A_IPR_MIDITRANSBUFEMPTY1
+#define A_IPR_MIDIRECVBUFEMPTY	A_IPR_MIDIRECVBUFEMPTY1
+#define A_INTE_MIDITXENABLE	A_INTE_MIDITXENABLE1
+#define A_INTE_MIDIRXENABLE	A_INTE_MIDIRXENABLE1
+#endif
+
+
+#endif /* _MIDI_H */
+
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/mixer.c patched/drivers/sound/audigy/mixer.c
--- old/drivers/sound/audigy/mixer.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/mixer.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,699 @@
+/*
+ **********************************************************************
+ *     mixer.c - /dev/mixer interface for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *     November 2, 1999     Alan Cox        cleaned up stuff
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#define __NO_VERSION__		/* Kernel version only defined once */
+#include <linux/module.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+
+#include "hwaccess.h"
+#include "8010.h"
+#include "recmgr.h"
+
+
+static const u32 bass_table[41][5] = {
+	{ 0x3e4f844f, 0x84ed4cc3, 0x3cc69927, 0x7b03553a, 0xc4da8486 },
+	{ 0x3e69a17a, 0x84c280fb, 0x3cd77cd4, 0x7b2f2a6f, 0xc4b08d1d },
+	{ 0x3e82ff42, 0x849991d5, 0x3ce7466b, 0x7b5917c6, 0xc48863ee },
+	{ 0x3e9bab3c, 0x847267f0, 0x3cf5ffe8, 0x7b813560, 0xc461f22c },
+	{ 0x3eb3b275, 0x844ced29, 0x3d03b295, 0x7ba79a1c, 0xc43d223b },
+	{ 0x3ecb2174, 0x84290c8b, 0x3d106714, 0x7bcc5ba3, 0xc419dfa5 },
+	{ 0x3ee2044b, 0x8406b244, 0x3d1c2561, 0x7bef8e77, 0xc3f8170f },
+	{ 0x3ef86698, 0x83e5cb96, 0x3d26f4d8, 0x7c114600, 0xc3d7b625 },
+	{ 0x3f0e5390, 0x83c646c9, 0x3d30dc39, 0x7c319498, 0xc3b8ab97 },
+	{ 0x3f23d60b, 0x83a81321, 0x3d39e1af, 0x7c508b9c, 0xc39ae704 },
+	{ 0x3f38f884, 0x838b20d2, 0x3d420ad2, 0x7c6e3b75, 0xc37e58f1 },
+	{ 0x3f4dc52c, 0x836f60ef, 0x3d495cab, 0x7c8ab3a6, 0xc362f2be },
+	{ 0x3f6245e8, 0x8354c565, 0x3d4fdbb8, 0x7ca602d6, 0xc348a69b },
+	{ 0x3f76845f, 0x833b40ec, 0x3d558bf0, 0x7cc036df, 0xc32f677c },
+	{ 0x3f8a8a03, 0x8322c6fb, 0x3d5a70c4, 0x7cd95cd7, 0xc317290b },
+	{ 0x3f9e6014, 0x830b4bc3, 0x3d5e8d25, 0x7cf1811a, 0xc2ffdfa5 },
+	{ 0x3fb20fae, 0x82f4c420, 0x3d61e37f, 0x7d08af56, 0xc2e9804a },
+	{ 0x3fc5a1cc, 0x82df2592, 0x3d6475c3, 0x7d1ef294, 0xc2d40096 },
+	{ 0x3fd91f55, 0x82ca6632, 0x3d664564, 0x7d345541, 0xc2bf56b9 },
+	{ 0x3fec9120, 0x82b67cac, 0x3d675356, 0x7d48e138, 0xc2ab796e },
+	{ 0x40000000, 0x82a36037, 0x3d67a012, 0x7d5c9fc9, 0xc2985fee },
+	{ 0x401374c7, 0x8291088a, 0x3d672b93, 0x7d6f99c3, 0xc28601f2 },
+	{ 0x4026f857, 0x827f6dd7, 0x3d65f559, 0x7d81d77c, 0xc27457a3 },
+	{ 0x403a939f, 0x826e88c5, 0x3d63fc63, 0x7d9360d4, 0xc2635996 },
+	{ 0x404e4faf, 0x825e5266, 0x3d613f32, 0x7da43d42, 0xc25300c6 },
+	{ 0x406235ba, 0x824ec434, 0x3d5dbbc3, 0x7db473d7, 0xc243468e },
+	{ 0x40764f1f, 0x823fd80c, 0x3d596f8f, 0x7dc40b44, 0xc23424a2 },
+	{ 0x408aa576, 0x82318824, 0x3d545787, 0x7dd309e2, 0xc2259509 },
+	{ 0x409f4296, 0x8223cf0b, 0x3d4e7012, 0x7de175b5, 0xc2179218 },
+	{ 0x40b430a0, 0x8216a7a1, 0x3d47b505, 0x7def5475, 0xc20a1670 },
+	{ 0x40c97a0a, 0x820a0d12, 0x3d4021a1, 0x7dfcab8d, 0xc1fd1cf5 },
+	{ 0x40df29a6, 0x81fdfad6, 0x3d37b08d, 0x7e098028, 0xc1f0a0ca },
+	{ 0x40f54ab1, 0x81f26ca9, 0x3d2e5bd1, 0x7e15d72b, 0xc1e49d52 },
+	{ 0x410be8da, 0x81e75e89, 0x3d241cce, 0x7e21b544, 0xc1d90e24 },
+	{ 0x41231051, 0x81dcccb3, 0x3d18ec37, 0x7e2d1ee6, 0xc1cdef10 },
+	{ 0x413acdd0, 0x81d2b39e, 0x3d0cc20a, 0x7e38184e, 0xc1c33c13 },
+	{ 0x41532ea7, 0x81c90ffb, 0x3cff9585, 0x7e42a58b, 0xc1b8f15a },
+	{ 0x416c40cd, 0x81bfdeb2, 0x3cf15d21, 0x7e4cca7c, 0xc1af0b3f },
+	{ 0x418612ea, 0x81b71cdc, 0x3ce20e85, 0x7e568ad3, 0xc1a58640 },
+	{ 0x41a0b465, 0x81aec7c5, 0x3cd19e7c, 0x7e5fea1e, 0xc19c5f03 },
+	{ 0x41bc3573, 0x81a6dcea, 0x3cc000e9, 0x7e68ebc2, 0xc1939250 }
+};
+
+static const u32 treble_table[41][5] = {
+	{ 0x0125cba9, 0xfed5debd, 0x00599b6c, 0x0d2506da, 0xfa85b354 },
+	{ 0x0142f67e, 0xfeb03163, 0x0066cd0f, 0x0d14c69d, 0xfa914473 },
+	{ 0x016328bd, 0xfe860158, 0x0075b7f2, 0x0d03eb27, 0xfa9d32d2 },
+	{ 0x0186b438, 0xfe56c982, 0x00869234, 0x0cf27048, 0xfaa97fca },
+	{ 0x01adf358, 0xfe21f5fe, 0x00999842, 0x0ce051c2, 0xfab62ca5 },
+	{ 0x01d949fa, 0xfde6e287, 0x00af0d8d, 0x0ccd8b4a, 0xfac33aa7 },
+	{ 0x02092669, 0xfda4d8bf, 0x00c73d4c, 0x0cba1884, 0xfad0ab07 },
+	{ 0x023e0268, 0xfd5b0e4a, 0x00e27b54, 0x0ca5f509, 0xfade7ef2 },
+	{ 0x0278645c, 0xfd08a2b0, 0x01012509, 0x0c911c63, 0xfaecb788 },
+	{ 0x02b8e091, 0xfcac9d1a, 0x0123a262, 0x0c7b8a14, 0xfafb55df },
+	{ 0x03001a9a, 0xfc45e9ce, 0x014a6709, 0x0c65398f, 0xfb0a5aff },
+	{ 0x034ec6d7, 0xfbd3576b, 0x0175f397, 0x0c4e2643, 0xfb19c7e4 },
+	{ 0x03a5ac15, 0xfb5393ee, 0x01a6d6ed, 0x0c364b94, 0xfb299d7c },
+	{ 0x0405a562, 0xfac52968, 0x01ddafae, 0x0c1da4e2, 0xfb39dca5 },
+	{ 0x046fa3fe, 0xfa267a66, 0x021b2ddd, 0x0c042d8d, 0xfb4a8631 },
+	{ 0x04e4b17f, 0xf975be0f, 0x0260149f, 0x0be9e0f2, 0xfb5b9ae0 },
+	{ 0x0565f220, 0xf8b0fbe5, 0x02ad3c29, 0x0bceba73, 0xfb6d1b60 },
+	{ 0x05f4a745, 0xf7d60722, 0x030393d4, 0x0bb2b578, 0xfb7f084d },
+	{ 0x06923236, 0xf6e279bd, 0x03642465, 0x0b95cd75, 0xfb916233 },
+	{ 0x07401713, 0xf5d3aef9, 0x03d01283, 0x0b77fded, 0xfba42984 },
+	{ 0x08000000, 0xf4a6bd88, 0x0448a161, 0x0b594278, 0xfbb75e9f },
+	{ 0x08d3c097, 0xf3587131, 0x04cf35a4, 0x0b3996c9, 0xfbcb01cb },
+	{ 0x09bd59a2, 0xf1e543f9, 0x05655880, 0x0b18f6b2, 0xfbdf1333 },
+	{ 0x0abefd0f, 0xf04956ca, 0x060cbb12, 0x0af75e2c, 0xfbf392e8 },
+	{ 0x0bdb123e, 0xee806984, 0x06c739fe, 0x0ad4c962, 0xfc0880dd },
+	{ 0x0d143a94, 0xec85d287, 0x0796e150, 0x0ab134b0, 0xfc1ddce5 },
+	{ 0x0e6d5664, 0xea547598, 0x087df0a0, 0x0a8c9cb6, 0xfc33a6ad },
+	{ 0x0fe98a2a, 0xe7e6ba35, 0x097edf83, 0x0a66fe5b, 0xfc49ddc2 },
+	{ 0x118c4421, 0xe536813a, 0x0a9c6248, 0x0a4056d7, 0xfc608185 },
+	{ 0x1359422e, 0xe23d19eb, 0x0bd96efb, 0x0a18a3bf, 0xfc77912c },
+	{ 0x1554982b, 0xdef33645, 0x0d3942bd, 0x09efe312, 0xfc8f0bc1 },
+	{ 0x1782b68a, 0xdb50deb1, 0x0ebf676d, 0x09c6133f, 0xfca6f019 },
+	{ 0x19e8715d, 0xd74d64fd, 0x106fb999, 0x099b3337, 0xfcbf3cd6 },
+	{ 0x1c8b07b8, 0xd2df56ab, 0x124e6ec8, 0x096f4274, 0xfcd7f060 },
+	{ 0x1f702b6d, 0xcdfc6e92, 0x14601c10, 0x0942410b, 0xfcf108e5 },
+	{ 0x229e0933, 0xc89985cd, 0x16a9bcfa, 0x09142fb5, 0xfd0a8451 },
+	{ 0x261b5118, 0xc2aa8409, 0x1930bab6, 0x08e50fdc, 0xfd24604d },
+	{ 0x29ef3f5d, 0xbc224f28, 0x1bfaf396, 0x08b4e3aa, 0xfd3e9a3b },
+	{ 0x2e21a59b, 0xb4f2ba46, 0x1f0ec2d6, 0x0883ae15, 0xfd592f33 },
+	{ 0x32baf44b, 0xad0c7429, 0x227308a3, 0x085172eb, 0xfd741bfd },
+	{ 0x37c4448b, 0xa45ef51d, 0x262f3267, 0x081e36dc, 0xfd8f5d14 }
+};
+
+
+static void set_bass(struct emu10k1_card *card, int l, int r)
+{
+	int i;
+
+	l = (l * 40 + 50) / 100;
+	r = (r * 40 + 50) / 100;
+
+	for (i = 0; i < 5; i++)
+		sblive_writeptr(card, (card->is_audigy ? A_GPR_BASE : GPR_BASE) + card->mgr.ctrl_gpr[SOUND_MIXER_BASS][0] + i, 0, bass_table[l][i]);
+}
+
+static void set_treble(struct emu10k1_card *card, int l, int r)
+{
+	int i;
+
+	l = (l * 40 + 50) / 100;
+	r = (r * 40 + 50) / 100;
+
+	for (i = 0; i < 5; i++)
+		sblive_writeptr(card, (card->is_audigy ? A_GPR_BASE : GPR_BASE) + card->mgr.ctrl_gpr[SOUND_MIXER_TREBLE][0] + i , 0, treble_table[l][i]);
+}
+
+const char volume_params[SOUND_MIXER_NRDEVICES]= {
+/* Used by the ac97 driver */
+	[SOUND_MIXER_VOLUME]	=	VOL_6BIT,
+	[SOUND_MIXER_BASS]	=	VOL_4BIT,
+	[SOUND_MIXER_TREBLE]	=	VOL_4BIT,
+	[SOUND_MIXER_PCM]	=	VOL_5BIT,
+	[SOUND_MIXER_SPEAKER]	=	VOL_4BIT,
+	[SOUND_MIXER_LINE]	=	VOL_5BIT,
+	[SOUND_MIXER_MIC]	=	VOL_5BIT,
+	[SOUND_MIXER_CD]	=	VOL_5BIT,
+	[SOUND_MIXER_ALTPCM]	=	VOL_6BIT,
+	[SOUND_MIXER_IGAIN]	=	VOL_4BIT,
+	[SOUND_MIXER_LINE1]	=	VOL_5BIT,
+	[SOUND_MIXER_PHONEIN]	= 	VOL_5BIT,
+	[SOUND_MIXER_PHONEOUT]	= 	VOL_6BIT,
+	[SOUND_MIXER_VIDEO]	=	VOL_5BIT,
+/* Not used by the ac97 driver */
+	[SOUND_MIXER_SYNTH]	=	VOL_5BIT,
+	[SOUND_MIXER_IMIX]	=	VOL_5BIT,
+	[SOUND_MIXER_RECLEV]	=	VOL_5BIT,
+	[SOUND_MIXER_OGAIN]	=	VOL_5BIT,
+	[SOUND_MIXER_LINE2]	=	VOL_5BIT,
+	[SOUND_MIXER_LINE3]	=	VOL_5BIT,
+	[SOUND_MIXER_DIGITAL1]	=	VOL_5BIT,
+	[SOUND_MIXER_DIGITAL2]	=	VOL_5BIT,
+	[SOUND_MIXER_DIGITAL3]	=	VOL_5BIT,
+	[SOUND_MIXER_RADIO]	=	VOL_5BIT,
+	[SOUND_MIXER_MONITOR]	=	VOL_5BIT
+};
+
+/* Mixer file operations */
+static int emu10k1_private_mixer(struct emu10k1_card *card, unsigned int cmd, unsigned long arg)
+{
+	struct mixer_private_ioctl *ctl;
+	struct dsp_patch *patch;
+	u32 size, page;
+	int addr, size_reg, i, ret;
+	unsigned int id, ch;
+
+	switch (cmd) {
+
+	case SOUND_MIXER_PRIVATE3:
+
+		ctl = (struct mixer_private_ioctl *) kmalloc(sizeof(struct mixer_private_ioctl), GFP_KERNEL);
+		if (ctl == NULL)
+			return -ENOMEM;
+
+		if (copy_from_user(ctl, (void *) arg, sizeof(struct mixer_private_ioctl))) {
+			kfree(ctl);
+			return -EFAULT;
+		}
+
+		ret = 0;
+		switch (ctl->cmd) {
+#ifdef DBGEMU
+		case CMD_WRITEFN0:
+				
+			emu10k1_writefn0_2(card, ctl->val[0], ctl->val[1], ctl->val[2]);
+			break;
+#endif
+		case CMD_WRITEPTR:
+#ifdef DBGEMU
+			if (ctl->val[1] >= 0x40 || ctl->val[0] >= 0x1000) {
+#else
+			if (ctl->val[1] >= 0x40 || ctl->val[0] >= 0x1000 || ((ctl->val[0] < 0x100 ) &&
+		    //Any register allowed raw access goes here:
+				     (ctl->val[0] != A_SPDIF_SAMPLERATE) && (ctl->val[0] != A_DBG)
+			)
+				) {
+#endif
+				ret = -EINVAL;
+				break;
+			}
+			sblive_writeptr(card, ctl->val[0], ctl->val[1], ctl->val[2]);
+			break;
+
+		case CMD_READFN0:
+			ctl->val[2] = emu10k1_readfn0(card, ctl->val[0]);
+
+			if (copy_to_user((void *) arg, ctl, sizeof(struct mixer_private_ioctl)))
+				ret = -EFAULT;
+
+			break;
+
+		case CMD_READPTR:
+			if (ctl->val[1] >= 0x40 || (ctl->val[0] & 0x7ff) > 0xff) {
+				ret = -EINVAL;
+				break;
+			}
+
+			if ((ctl->val[0] & 0x7ff) > 0x3f)
+				ctl->val[1] = 0x00;
+
+			ctl->val[2] = sblive_readptr(card, ctl->val[0], ctl->val[1]);
+
+			if (copy_to_user((void *) arg, ctl, sizeof(struct mixer_private_ioctl)))
+				ret = -EFAULT;
+
+			break;
+
+		case CMD_SETRECSRC:
+			switch (ctl->val[0]) {
+			case WAVERECORD_AC97:
+				if (card->is_aps) {
+					ret = -EINVAL;
+					break;
+				}
+
+				card->wavein.recsrc = WAVERECORD_AC97;
+				break;
+
+			case WAVERECORD_MIC:
+				card->wavein.recsrc = WAVERECORD_MIC;
+				break;
+
+			case WAVERECORD_FX:
+				card->wavein.recsrc = WAVERECORD_FX;
+				card->wavein.fxwc = ctl->val[1] & 0xffff;
+
+				if (!card->wavein.fxwc)
+					ret = -EINVAL;
+
+				break;
+
+			default:
+				ret = -EINVAL;
+				break;
+			}
+			break;
+
+		case CMD_GETRECSRC:
+			ctl->val[0] = card->wavein.recsrc;
+			ctl->val[1] = card->wavein.fxwc;
+
+			if (copy_to_user((void *) arg, ctl, sizeof(struct mixer_private_ioctl)))
+				ret = -EFAULT;
+
+			break;
+
+		case CMD_GETVOICEPARAM:
+			ctl->val[0] = card->waveout.send_routing[0];
+			ctl->val[1] = card->waveout.send_dcba[0];
+
+			ctl->val[2] = card->waveout.send_routing[1];
+			ctl->val[3] = card->waveout.send_dcba[1];
+
+			ctl->val[4] = card->waveout.send_routing[2];
+			ctl->val[5] = card->waveout.send_dcba[2];
+
+			if (copy_to_user((void *) arg, ctl, sizeof(struct mixer_private_ioctl)))
+				ret = -EFAULT;
+
+			break;
+
+		case CMD_SETVOICEPARAM:
+			card->waveout.send_routing[0] = ctl->val[0];
+			card->waveout.send_dcba[0] = ctl->val[1];
+
+			card->waveout.send_routing[1] = ctl->val[2];
+			card->waveout.send_dcba[1] = ctl->val[3];
+
+			card->waveout.send_routing[2] = ctl->val[4];
+			card->waveout.send_dcba[2] = ctl->val[5];
+
+			break;
+		
+		case CMD_SETMCH_FX:
+			card->mchannel_fx = ctl->val[0] & 0x000f;
+			break;
+		
+		case CMD_GETPATCH:
+			if (ctl->val[0] == 0) {
+				if (copy_to_user((void *) arg, &card->mgr.rpatch, sizeof(struct dsp_rpatch)))
+                                	ret = -EFAULT;
+			} else {
+				if ((ctl->val[0] - 1) / PATCHES_PER_PAGE >= card->mgr.current_pages) {
+					ret = -EINVAL;
+					break;
+				}
+
+				if (copy_to_user((void *) arg, PATCH(&card->mgr, ctl->val[0] - 1), sizeof(struct dsp_patch)))
+					ret = -EFAULT;
+			}
+
+			break;
+
+		case CMD_GETGPR:
+			id = ctl->val[0];
+
+			if (id > NUM_GPRS) {
+				ret = -EINVAL;
+				break;
+			}
+
+			if (copy_to_user((void *) arg, &card->mgr.gpr[id], sizeof(struct dsp_gpr)))
+				ret = -EFAULT;
+
+			break;
+
+		case CMD_GETCTLGPR:
+			addr = emu10k1_find_control_gpr(&card->mgr, (char *) ctl->val, &((char *) ctl->val)[PATCH_NAME_SIZE]);
+			ctl->val[0] = sblive_readptr(card, addr, 0);
+
+			if (copy_to_user((void *) arg, ctl, sizeof(struct mixer_private_ioctl)))
+				ret = -EFAULT;
+
+			break;
+
+		case CMD_SETPATCH:
+			if (ctl->val[0] == 0)
+				memcpy(&card->mgr.rpatch, &ctl->val[1], sizeof(struct dsp_rpatch));
+			else {
+				page = (ctl->val[0] - 1) / PATCHES_PER_PAGE;
+				if (page > MAX_PATCHES_PAGES) {
+					ret = -EINVAL;
+					break;
+				}
+
+				if (page >= card->mgr.current_pages) {
+					for (i = card->mgr.current_pages; i < page + 1; i++) {
+				                card->mgr.patch[i] = (void *)__get_free_page(GFP_KERNEL);
+						if(card->mgr.patch[i] == NULL) {
+							card->mgr.current_pages = i;
+							ret = -ENOMEM;
+							break;
+						}
+						memset(card->mgr.patch[i], 0, PAGE_SIZE);
+					}
+					card->mgr.current_pages = page + 1;
+				}
+
+				patch = PATCH(&card->mgr, ctl->val[0] - 1);
+
+				memcpy(patch, &ctl->val[1], sizeof(struct dsp_patch));
+
+				if (patch->code_size == 0) {
+					for(i = page + 1; i < card->mgr.current_pages; i++)
+                                                free_page((unsigned long) card->mgr.patch[i]);
+
+					card->mgr.current_pages = page + 1;
+				}
+			}
+
+			break;
+
+		case CMD_SETGPR:
+			if (ctl->val[0] > NUM_GPRS) {
+				ret = -EINVAL;
+				break;
+			}
+
+			memcpy(&card->mgr.gpr[ctl->val[0]], &ctl->val[1], sizeof(struct dsp_gpr));
+			break;
+
+		case CMD_SETCTLGPR:
+			addr = emu10k1_find_control_gpr(&card->mgr, (char *) ctl->val, (char *) ctl->val + PATCH_NAME_SIZE);
+			emu10k1_set_control_gpr(card, addr, *((s32 *)((char *) ctl->val + 2 * PATCH_NAME_SIZE)), 0);
+
+			break;
+
+		case CMD_SETGPOUT:
+			if ( ((ctl->val[0] > 2) && (!card->is_audigy))
+			     || (ctl->val[0] > 15) || ctl->val[1] > 1) {
+				ret= -EINVAL;
+				break;
+			}
+
+			if (card->is_audigy)
+				emu10k1_writefn0(card, (1 << 24) | ((ctl->val[0]) << 16) | A_IOCFG, ctl->val[1]);
+			else
+				emu10k1_writefn0(card, (1 << 24) | (((ctl->val[0]) + 10) << 16) | HCFG, ctl->val[1]);
+			break;
+
+		case CMD_GETGPR2OSS:
+			id = ctl->val[0];
+			ch = ctl->val[1];
+
+			if (id >= SOUND_MIXER_NRDEVICES || ch >= 2) {
+				ret = -EINVAL;
+				break;
+			}
+
+			ctl->val[2] = card->mgr.ctrl_gpr[id][ch];
+
+			if (copy_to_user((void *) arg, ctl, sizeof(struct mixer_private_ioctl)))
+				ret = -EFAULT;
+
+			break;
+
+		case CMD_SETGPR2OSS:
+			id = ctl->val[0];
+			/* 0 == left, 1 == right */
+			ch = ctl->val[1];
+			addr = ctl->val[2];
+
+			if (id >= SOUND_MIXER_NRDEVICES || ch >= 2) {
+				ret = -EINVAL;
+				break;
+			}
+
+			card->mgr.ctrl_gpr[id][ch] = addr;
+
+			if (card->is_aps)
+				break;
+
+			if (addr >= 0) {
+				unsigned int state = card->ac97.mixer_state[id];
+
+				if (ch == 1) {
+					state >>= 8;
+					card->ac97.stereo_mixers |= (1 << id);
+				}
+
+				card->ac97.supported_mixers |= (1 << id);
+
+				if (id == SOUND_MIXER_TREBLE) {
+					set_treble(card, card->ac97.mixer_state[id] & 0xff, (card->ac97.mixer_state[id] >> 8) & 0xff);
+				} else if (id == SOUND_MIXER_BASS) {
+					set_bass(card, card->ac97.mixer_state[id] & 0xff, (card->ac97.mixer_state[id] >> 8) & 0xff);
+				} else
+					emu10k1_set_volume_gpr(card, addr, state & 0xff,
+							       volume_params[id]);
+			} else {
+				card->ac97.stereo_mixers &= ~(1 << id);
+				card->ac97.stereo_mixers |= card->ac97_stereo_mixers;
+
+				if (ch == 0) {
+					card->ac97.supported_mixers &= ~(1 << id);
+					card->ac97.supported_mixers |= card->ac97_supported_mixers;
+				}
+			}
+			break;
+
+		case CMD_SETPASSTHROUGH:
+			card->pt.selected = ctl->val[0] ? 1 : 0;
+
+			if (card->pt.state != PT_STATE_INACTIVE)
+				break;
+
+			card->pt.spcs_to_use = ctl->val[0] & 0x07;
+
+			break;
+	
+		case CMD_PRIVATE3_VERSION:
+			ctl->val[0] = PRIVATE3_VERSION;	//private3 version
+			ctl->val[1] = MAJOR_VER;	//major driver version
+			ctl->val[2] = MINOR_VER;	//minor driver version
+			ctl->val[3] = card->is_audigy;	//1=card is audigy
+
+			if (card->is_audigy)
+				ctl->val[4]=emu10k1_readfn0(card, 0x18);
+
+			if (copy_to_user((void *) arg, ctl, sizeof(struct mixer_private_ioctl)))
+				ret = -EFAULT;
+			break;
+
+		case CMD_AC97_BOOST:
+			if (ctl->val[0])
+				emu10k1_ac97_write(&card->ac97, 0x18, 0x0);	
+			else
+				emu10k1_ac97_write(&card->ac97, 0x18, 0x0808);
+			break;
+
+		default:
+			ret = -EINVAL;
+			break;
+		}
+
+		kfree(ctl);
+		return ret;
+		break;
+
+	case SOUND_MIXER_PRIVATE4:
+
+		if (copy_from_user(&size, (void *) arg, sizeof(size)))
+			return -EFAULT;
+
+		DPD(2, "External tram size %#x\n", size);
+
+		if (size > 0x1fffff)
+			return -EINVAL;
+
+		size_reg = 0;
+
+		if (size != 0) {
+			size = (size - 1) >> 14;
+
+			while (size) {
+				size >>= 1;
+				size_reg++;
+			}
+
+			size = 0x4000 << size_reg;
+		}
+
+		DPD(2, "External tram size %#x %#x\n", size, size_reg);
+
+		if (size != card->tankmem.size) {
+			if (card->tankmem.size > 0) {
+				emu10k1_writefn0(card, HCFG_LOCKTANKCACHE, 1);
+
+				sblive_writeptr_tag(card, 0, TCB, 0, TCBS, 0, TAGLIST_END);
+
+				pci_free_consistent(card->pci_dev, card->tankmem.size, card->tankmem.addr, card->tankmem.dma_handle);
+
+				card->tankmem.size = 0;
+			}
+
+			if (size != 0) {
+				card->tankmem.addr = pci_alloc_consistent(card->pci_dev, size, &card->tankmem.dma_handle);
+				if (card->tankmem.addr == NULL)
+					return -ENOMEM;
+
+				card->tankmem.size = size;
+
+				sblive_writeptr_tag(card, 0, TCB,(u32) card->tankmem.dma_handle, TCBS,(u32) size_reg, 
+TAGLIST_END);
+
+				emu10k1_writefn0(card, HCFG_LOCKTANKCACHE, 0);
+			}
+		}
+		return 0;
+		break;
+
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static int emu10k1_dsp_mixer(struct emu10k1_card *card, unsigned int oss_mixer, unsigned long arg)
+{
+	unsigned int left, right;
+	int val;
+	int scale;
+
+	card->ac97.modcnt++;
+
+	if (get_user(val, (int *)arg))
+		return -EFAULT;
+
+	/* cleanse input a little */
+	right = ((val >> 8)  & 0xff);
+	left = (val  & 0xff);
+
+	if (right > 100) right = 100;
+	if (left > 100) left = 100;
+
+	card->ac97.mixer_state[oss_mixer] = (right << 8) | left;
+	if (oss_mixer == SOUND_MIXER_TREBLE) {
+		set_treble(card, left, right);
+		return 0;
+	} if (oss_mixer == SOUND_MIXER_BASS) {
+		set_bass(card, left, right);
+		return 0;
+	}
+
+	if (oss_mixer == SOUND_MIXER_VOLUME)
+		scale = 1 << card->ac97.bit_resolution;
+	else
+		scale = volume_params[oss_mixer];
+
+	emu10k1_set_volume_gpr(card, card->mgr.ctrl_gpr[oss_mixer][0], left, scale);
+	emu10k1_set_volume_gpr(card, card->mgr.ctrl_gpr[oss_mixer][1], right, scale);
+
+	if (card->ac97_supported_mixers & (1 << oss_mixer))
+		card->ac97.write_mixer(&card->ac97, oss_mixer, left, right);
+
+	return 0;
+}
+
+static int emu10k1_mixer_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	struct emu10k1_card *card = file->private_data;
+	unsigned int oss_mixer = _IOC_NR(cmd);
+	
+	ret = -EINVAL;
+	if (!card->is_aps) {
+		if (cmd == SOUND_MIXER_INFO) {
+			mixer_info info;
+
+			strncpy(info.id, card->ac97.name, sizeof(info.id));
+
+			if (card->is_audigy)
+				strncpy(info.name, "Audigy - Emu10k1", sizeof(info.name));
+			else
+				strncpy(info.name, "Creative SBLive - Emu10k1", sizeof(info.name));
+				
+			info.modify_counter = card->ac97.modcnt;
+
+			if (copy_to_user((void *)arg, &info, sizeof(info)))
+				return -EFAULT;
+
+			return 0;
+		}
+
+		if ((_SIOC_DIR(cmd) == (_SIOC_WRITE|_SIOC_READ)) && oss_mixer <= SOUND_MIXER_NRDEVICES)
+			ret = emu10k1_dsp_mixer(card, oss_mixer, arg);
+		else
+			ret = card->ac97.mixer_ioctl(&card->ac97, cmd, arg);
+	}
+	
+	if (ret < 0)
+		ret = emu10k1_private_mixer(card, cmd, arg);
+
+	return ret;
+}
+
+static int emu10k1_mixer_open(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(inode->i_rdev);
+	struct emu10k1_card *card = NULL;
+	struct list_head *entry;
+
+	DPF(4, "emu10k1_mixer_open()\n");
+
+	list_for_each(entry, &emu10k1_devs) {
+		card = list_entry(entry, struct emu10k1_card, list);
+
+		if (card->ac97.dev_mixer == minor)
+			goto match;
+	}
+
+	return -ENODEV;
+
+      match:
+	file->private_data = card;
+	return 0;
+}
+
+static int emu10k1_mixer_release(struct inode *inode, struct file *file)
+{
+	DPF(4, "emu10k1_mixer_release()\n");
+	return 0;
+}
+
+struct file_operations emu10k1_mixer_fops = {
+	owner:		THIS_MODULE,
+	llseek:		no_llseek,
+	ioctl:		emu10k1_mixer_ioctl,
+	open:		emu10k1_mixer_open,
+	release:	emu10k1_mixer_release,
+};
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/passthrough.c patched/drivers/sound/audigy/passthrough.c
--- old/drivers/sound/audigy/passthrough.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/passthrough.c	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,240 @@
+/*
+ **********************************************************************
+ *     passthrough.c -- Emu10k1 digital passthrough
+ *     Copyright (C) 2001  Juha Yrjl <jyrjola@cc.hut.fi>
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     May 15, 2001	    Juha Yrjl	    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+                       
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/bitops.h>
+#include <asm/io.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/wrapper.h>
+
+#include "hwaccess.h"
+#include "cardwo.h"
+#include "cardwi.h"
+#include "recmgr.h"
+#include "irqmgr.h"
+#include "audio.h"
+#include "8010.h"
+
+static void pt_putsamples(struct pt_data *pt, u16 *ptr, u16 left, u16 right)
+{
+	unsigned int idx;
+
+	ptr[pt->copyptr] = left;
+	idx = pt->copyptr + PT_SAMPLES/2;
+	idx %= PT_SAMPLES;
+	ptr[idx] = right;
+}
+
+static inline int pt_can_write(struct pt_data *pt)
+{
+	return pt->blocks_copied < pt->blocks_played + 8;
+}
+
+static int pt_wait_for_write(struct emu10k1_wavedevice *wavedev, int nonblock)
+{
+	struct emu10k1_card *card = wavedev->card;
+	struct pt_data *pt = &card->pt;
+
+	if (nonblock && !pt_can_write(pt))
+		return -EAGAIN;
+	while (!pt_can_write(pt) && pt->state != PT_STATE_INACTIVE) {
+		interruptible_sleep_on(&pt->wait);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+	}
+	if (pt->state == PT_STATE_INACTIVE)
+		return -EAGAIN;
+	
+	return 0;
+}
+
+static int pt_putblock(struct emu10k1_wavedevice *wave_dev, u16 *block, int nonblock)
+{
+	struct woinst *woinst = wave_dev->woinst;
+	struct emu10k1_card *card = wave_dev->card;
+	struct pt_data *pt = &card->pt;
+	u16 *ptr = (u16 *) card->tankmem.addr;
+	int i = 0, r;
+	unsigned long flags;
+
+	r = pt_wait_for_write(wave_dev, nonblock);
+	if (r < 0)
+		return r;
+	spin_lock_irqsave(&card->pt.lock, flags);
+	while (i < PT_BLOCKSAMPLES) {
+		pt_putsamples(pt, ptr, block[2*i], block[2*i+1]);
+		if (pt->copyptr == 0)
+			pt->copyptr = PT_SAMPLES;
+		pt->copyptr--;
+		i++;
+	}
+	woinst->total_copied += PT_BLOCKSIZE;
+	pt->blocks_copied++;
+	if (pt->blocks_copied >= 4 && pt->state != PT_STATE_PLAYING) {
+		DPF(2, "activating digital pass-through playback\n");
+		sblive_writeptr(card, GPR_BASE + pt->enable_gpr, 0, 1);
+		pt->state = PT_STATE_PLAYING;
+	}
+	spin_unlock_irqrestore(&card->pt.lock, flags);
+	return 0;
+}
+
+int emu10k1_pt_setup(struct emu10k1_wavedevice *wave_dev)
+{
+	u32 bits;
+	struct emu10k1_card *card = wave_dev->card;
+	struct pt_data *pt = &card->pt;
+	int i;
+
+	for (i = 0; i < 3; i++) {
+		pt->old_spcs[i] = sblive_readptr(card, SPCS0 + i, 0);
+		if (pt->spcs_to_use & (1 << i)) {
+			DPD(2, "using S/PDIF port %d\n", i);
+			bits = SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |
+				SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC | SPCS_GENERATIONSTATUS |
+				0x00001200 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT;
+			if (pt->ac3data)
+				bits |= SPCS_NOTAUDIODATA;
+			sblive_writeptr(card, SPCS0 + i, 0, bits);
+		}
+	}
+	return 0;
+}
+
+ssize_t emu10k1_pt_write(struct file *file, const char *buffer, size_t count)
+{
+	struct emu10k1_wavedevice *wave_dev = (struct emu10k1_wavedevice *) file->private_data;
+	struct emu10k1_card *card = wave_dev->card;
+	struct pt_data *pt = &card->pt;
+	int nonblock, i, r, blocks, blocks_copied, bytes_copied = 0;
+
+	DPD(3, "emu10k1_pt_write(): %d bytes\n", count);
+	
+	nonblock = file->f_flags & O_NONBLOCK;
+	
+	if (card->tankmem.size < PT_SAMPLES*2)
+		return -EFAULT;
+	if (pt->state == PT_STATE_INACTIVE) {
+		DPF(2, "bufptr init\n");
+		pt->playptr = PT_SAMPLES-1;
+		pt->copyptr = PT_INITPTR;
+		pt->blocks_played = pt->blocks_copied = 0;
+		memset(card->tankmem.addr, 0, card->tankmem.size);
+		pt->state = PT_STATE_ACTIVATED;
+		pt->buf = kmalloc(PT_BLOCKSIZE, GFP_KERNEL);
+		pt->prepend_size = 0;
+		if (pt->buf == NULL)
+			return -ENOMEM;
+		emu10k1_pt_setup(wave_dev);
+	}
+	if (pt->prepend_size) {
+		int needed = PT_BLOCKSIZE - pt->prepend_size;
+
+		DPD(3, "prepend size %d, prepending %d bytes\n", pt->prepend_size, needed);
+		if (count < needed) {
+			copy_from_user(pt->buf + pt->prepend_size, buffer, count);
+			pt->prepend_size += count;
+			DPD(3, "prepend size now %d\n", pt->prepend_size);
+			return count;
+		}
+		copy_from_user(pt->buf + pt->prepend_size, buffer, needed);
+		r = pt_putblock(wave_dev, (u16 *) pt->buf, nonblock);
+		if (r)
+			return r;
+		bytes_copied += needed;
+		pt->prepend_size = 0;
+	}
+	blocks = (count-bytes_copied)/PT_BLOCKSIZE;
+	blocks_copied = 0;
+	while (blocks > 0) {
+		u16 *bufptr = (u16 *) buffer + (bytes_copied/2);
+		copy_from_user(pt->buf, bufptr, PT_BLOCKSIZE);
+		bufptr = (u16 *) pt->buf;
+		r = pt_putblock(wave_dev, bufptr, nonblock);
+		if (r) {
+			if (bytes_copied)
+				return bytes_copied;
+			else
+				return r;
+		}
+		bytes_copied += PT_BLOCKSIZE;
+		blocks--;
+		blocks_copied++;
+	}
+	i = count - bytes_copied;
+	if (i) {
+		pt->prepend_size = i;
+		copy_from_user(pt->buf, buffer + bytes_copied, i);
+		bytes_copied += i;
+		DPD(3, "filling prepend buffer with %d bytes", i);
+	}
+	return bytes_copied;
+}
+
+void emu10k1_pt_stop(struct emu10k1_card *card)
+{
+	struct pt_data *pt = &card->pt;
+	int i;
+
+	if (pt->state != PT_STATE_INACTIVE) {
+		DPF(2, "digital pass-through stopped\n");
+		sblive_writeptr(card, (card->is_audigy ? A_GPR_BASE : GPR_BASE) + pt->enable_gpr, 0, 0);
+		for (i = 0; i < 3; i++) {
+                        if (pt->spcs_to_use & (1 << i))
+				sblive_writeptr(card, SPCS0 + i, 0, pt->old_spcs[i]);
+		}
+		pt->state = PT_STATE_INACTIVE;
+		if(pt->buf)
+			kfree(pt->buf);
+	}
+}
+
+void emu10k1_pt_waveout_update(struct emu10k1_wavedevice *wave_dev)
+{
+	struct woinst *woinst = wave_dev->woinst;
+	struct pt_data *pt = &wave_dev->card->pt;
+	u32 pos;
+
+	if (pt->state == PT_STATE_PLAYING && pt->pos_gpr >= 0) {
+		pos = sblive_readptr(wave_dev->card, GPR_BASE + pt->pos_gpr, 0);
+		if (pos > PT_BLOCKSAMPLES)
+			pos = PT_BLOCKSAMPLES;
+		pos = 4 * (PT_BLOCKSAMPLES - pos);
+	} else
+		pos = 0;
+	woinst->total_played = pt->blocks_played * woinst->buffer.fragment_size + pos;
+	woinst->buffer.hw_pos = pos;
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/passthrough.h patched/drivers/sound/audigy/passthrough.h
--- old/drivers/sound/audigy/passthrough.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/passthrough.h	2003-07-22 20:13:09.000000000 +0300
@@ -0,0 +1,99 @@
+/*
+ **********************************************************************
+ *     passthrough.h -- Emu10k1 digital passthrough header file
+ *     Copyright (C) 2001  Juha Yrjl <jyrjola@cc.hut.fi>
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     May 15, 2001	    Juha Yrjl     base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#ifndef _PASSTHROUGH_H
+#define _PASSTHROUGH_H
+
+#include "audio.h"
+
+/* number of 16-bit stereo samples in XTRAM buffer */
+#define PT_SAMPLES 0x8000
+#define PT_BLOCKSAMPLES 0x400
+#define PT_BLOCKSIZE (PT_BLOCKSAMPLES*4)
+#define PT_BLOCKSIZE_LOG2 12
+#define PT_BLOCKCOUNT (PT_SAMPLES/PT_BLOCKSAMPLES)
+#define PT_INITPTR (PT_SAMPLES/2-1)
+
+#define PT_STATE_INACTIVE 0
+#define PT_STATE_ACTIVATED 1
+#define PT_STATE_PLAYING 2
+
+/* passthrough struct */
+struct pt_data
+{
+	u8	selected, state, spcs_to_use;
+	int	intr_gpr, enable_gpr, pos_gpr;
+	u32	blocks_played, blocks_copied, old_spcs[3];
+	u32	playptr, copyptr;
+	u32	prepend_size;
+	u8	*buf;
+	u8	ac3data;
+
+	char	*patch_name, *intr_gpr_name, *enable_gpr_name, *pos_gpr_name;
+
+	wait_queue_head_t wait;
+	spinlock_t lock;
+};
+
+/*
+  Passthrough can be done in two methods:
+
+  Method 1 : tram
+     In original emu10k1, we couldn't bypass the sample rate converters. Even at 48kHz
+     (the internal sample rate of the emu10k1) the samples would get messed up.
+     To over come this, samples are copied into the tram and a special dsp patch copies
+     the samples out and generates interrupts when a block has finnished playing.
+
+  Method 2 : Interpolator bypass
+
+     Creative fixed the sample rate convert problem in emu10k1 rev 7 and higher
+     (including the emu10k2 (audigy)). This allows us to use the regular, and much simpler
+     playback method. 
+
+
+  In both methods, dsp code is used to mux audio and passthrough. This ensures that the spdif
+  doesn't receive audio and pasthrough data at the same time. The spdif flag SPCS_NOTAUDIODATA
+  is set to tell 
+
+ */
+
+// emu10k1 revs greater than or equal to 7 can use method2
+
+#define USE_PT_METHOD2  (card->is_audigy)
+#define USE_PT_METHOD1	!USE_PT_METHOD2
+
+ssize_t emu10k1_pt_write(struct file *file, const char *buf, size_t count);
+
+int emu10k1_pt_setup(struct emu10k1_wavedevice *wave_dev);
+void emu10k1_pt_stop(struct emu10k1_card *card);
+void emu10k1_pt_waveout_update(struct emu10k1_wavedevice *wave_dev);
+
+#endif /* _PASSTHROUGH_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/recmgr.c patched/drivers/sound/audigy/recmgr.c
--- old/drivers/sound/audigy/recmgr.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/recmgr.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,147 @@
+/*
+ **********************************************************************
+ *     recmgr.c -- Recording manager for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#include <asm/delay.h>
+#include "8010.h"
+#include "recmgr.h"
+
+void emu10k1_reset_record(struct emu10k1_card *card, struct wavein_buffer *buffer)
+{
+	DPF(2, "emu10k1_reset_record()\n");
+
+	sblive_writeptr(card, buffer->sizereg, 0, ADCBS_BUFSIZE_NONE);
+
+	sblive_writeptr(card, buffer->sizereg, 0, buffer->sizeregval);
+
+	while (sblive_readptr(card, buffer->idxreg, 0))
+		udelay(5);
+}
+
+void emu10k1_start_record(struct emu10k1_card *card, struct wavein_buffer *buffer)
+{
+	DPF(2, "emu10k1_start_record()\n");
+
+	if (buffer->adcctl)
+		sblive_writeptr(card, ADCCR, 0, buffer->adcctl);
+}
+
+void emu10k1_stop_record(struct emu10k1_card *card, struct wavein_buffer *buffer)
+{
+	DPF(2, "emu10k1_stop_record()\n");
+
+	/* Disable record transfer */
+	if (buffer->adcctl)
+		sblive_writeptr(card, ADCCR, 0, 0);
+}
+
+void emu10k1_set_record_src(struct emu10k1_card *card, struct wiinst *wiinst)
+{
+	struct wavein_buffer *buffer = &wiinst->buffer;
+
+	DPF(2, "emu10k1_set_record_src()\n");
+
+	switch (wiinst->recsrc) {
+
+	case WAVERECORD_AC97:
+		DPF(2, "recording source: AC97\n");
+		buffer->sizereg = ADCBS;
+		buffer->addrreg = ADCBA;
+		buffer->idxreg = card->is_audigy ? A_ADCIDX_IDX : ADCIDX_IDX;
+
+		switch (wiinst->format.samplingrate) {
+		case 0xBB80:
+			buffer->adcctl = ADCCR_SAMPLERATE_48;
+			break;
+		case 0xAC44:
+			buffer->adcctl = ADCCR_SAMPLERATE_44;
+			break;
+		case 0x7D00:
+			buffer->adcctl = ADCCR_SAMPLERATE_32;
+			break;
+		case 0x5DC0:
+			buffer->adcctl = ADCCR_SAMPLERATE_24;
+			break;
+		case 0x5622:
+			buffer->adcctl = ADCCR_SAMPLERATE_22;
+			break;
+		case 0x3E80:
+			buffer->adcctl = ADCCR_SAMPLERATE_16;
+			break;
+		// FIXME: audigy supports 12kHz recording
+		/*
+		case ????:
+			buffer->adcctl = A_ADCCR_SAMPLERATE_12;
+			break;
+		*/
+		case 0x2B11:
+			buffer->adcctl = card->is_audigy ? A_ADCCR_SAMPLERATE_11 : ADCCR_SAMPLERATE_11;
+			break;
+		case 0x1F40:
+			buffer->adcctl = card->is_audigy ? A_ADCCR_SAMPLERATE_8 : ADCCR_SAMPLERATE_8;
+			break;
+		default:
+			BUG();
+			break;
+		}
+		
+		buffer->adcctl |= card->is_audigy ? A_ADCCR_LCHANENABLE : ADCCR_LCHANENABLE;
+
+		if (wiinst->format.channels == 2)
+			buffer->adcctl |= card->is_audigy ? A_ADCCR_RCHANENABLE : ADCCR_RCHANENABLE;
+
+		break;
+
+	case WAVERECORD_MIC:
+		DPF(2, "recording source: MIC\n");
+		buffer->sizereg = MICBS;
+		buffer->addrreg = MICBA;
+		buffer->idxreg = MICIDX_IDX;
+		buffer->adcctl = 0;
+		break;
+
+	case WAVERECORD_FX:
+		DPF(2, "recording source: FX\n");
+		buffer->sizereg = FXBS;
+		buffer->addrreg = FXBA;
+		buffer->idxreg = FXIDX_IDX;
+		buffer->adcctl = 0;
+
+		sblive_writeptr(card, FXWC, 0, wiinst->fxwc);
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	DPD(2, "bus addx: %#lx\n", (unsigned long) buffer->dma_handle);
+
+	sblive_writeptr(card, buffer->addrreg, 0, (u32)buffer->dma_handle);
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/recmgr.h patched/drivers/sound/audigy/recmgr.h
--- old/drivers/sound/audigy/recmgr.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/recmgr.h	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,48 @@
+/*     
+ **********************************************************************
+ *     recmgr.h
+ *     Copyright 1999, 2000 Creative Labs, Inc. 
+ * 
+ ********************************************************************** 
+ * 
+ *     Date                 Author          Summary of changes 
+ *     ----                 ------          ------------------ 
+ *     October 20, 1999     Bertrand Lee    base code release 
+ * 
+ ********************************************************************** 
+ * 
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version. 
+ * 
+ *     This program is distributed in the hope that it will be useful, 
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ *     GNU General Public License for more details. 
+ * 
+ *     You should have received a copy of the GNU General Public 
+ *     License along with this program; if not, write to the Free 
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, 
+ *     USA. 
+ * 
+ ********************************************************************** 
+ */
+
+#ifndef _RECORDMGR_H
+#define _RECORDMGR_H
+
+#include "hwaccess.h"
+#include "cardwi.h"
+
+/* Recording resources */
+#define WAVERECORD_AC97		0x01
+#define WAVERECORD_MIC		0x02
+#define WAVERECORD_FX		0x03
+
+void emu10k1_reset_record(struct emu10k1_card *card, struct wavein_buffer *buffer);
+void emu10k1_start_record(struct emu10k1_card *, struct wavein_buffer *);
+void emu10k1_stop_record(struct emu10k1_card *, struct wavein_buffer *);
+void emu10k1_set_record_src(struct emu10k1_card *, struct wiinst *wiinst);
+
+#endif /* _RECORDMGR_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/timer.c patched/drivers/sound/audigy/timer.c
--- old/drivers/sound/audigy/timer.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/timer.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,176 @@
+
+/*
+ **********************************************************************
+ *     timer.c
+ *     Copyright (C) 1999, 2000 Creative Labs, inc.
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+/* 3/6/2000	Improved support for different timer delays  Rui Sousa */
+
+/* 4/3/2000	Implemented timer list using list.h 	     Rui Sousa */
+
+#include "hwaccess.h"
+#include "8010.h"
+#include "irqmgr.h"
+#include "timer.h"
+
+/* Try to schedule only once per fragment */
+
+void emu10k1_timer_irqhandler(struct emu10k1_card *card)
+{
+	struct emu_timer *t;
+	struct list_head *entry;
+
+	spin_lock(&card->timer_lock);
+
+	list_for_each(entry, &card->timers) {
+		t = list_entry(entry, struct emu_timer, list);
+
+		if (t->state & TIMER_STATE_ACTIVE) {
+			t->count++;
+			if (t->count == t->count_max) {
+				t->count = 0;
+				tasklet_hi_schedule(&t->tasklet);
+			}
+		}
+	}
+
+	spin_unlock(&card->timer_lock);
+
+	return;
+}
+
+void emu10k1_timer_install(struct emu10k1_card *card, struct emu_timer *timer, u16 delay)
+{
+	struct emu_timer *t;
+	struct list_head *entry;
+	unsigned long flags;
+
+	if (delay < 5)
+		delay = 5;
+
+	timer->delay = delay;
+	timer->state = TIMER_STATE_INSTALLED;
+
+	spin_lock_irqsave(&card->timer_lock, flags);
+
+	timer->count_max = timer->delay / (card->timer_delay < 1024 ? card->timer_delay : 1024);
+	timer->count = timer->count_max - 1;
+
+	list_add(&timer->list, &card->timers);
+
+	if (card->timer_delay > delay) {
+		if (card->timer_delay == TIMER_STOPPED)
+			emu10k1_irq_enable(card, INTE_INTERVALTIMERENB);
+
+		card->timer_delay = delay;
+		delay = (delay < 1024 ? delay : 1024);
+
+		emu10k1_timer_set(card, delay);
+
+		list_for_each(entry, &card->timers) {
+			t = list_entry(entry, struct emu_timer, list);
+
+			t->count_max = t->delay / delay;
+			/* don't want to think much, just force scheduling 
+			   on the next interrupt */
+			t->count = t->count_max - 1;
+		}
+
+		DPD(2, "timer rate --> %u\n", delay);
+	}
+
+	spin_unlock_irqrestore(&card->timer_lock, flags);
+
+	return;
+}
+
+void emu10k1_timer_uninstall(struct emu10k1_card *card, struct emu_timer *timer)
+{
+	struct emu_timer *t;
+	struct list_head *entry;
+	u16 delay = TIMER_STOPPED;
+	unsigned long flags;
+
+	if (timer->state == TIMER_STATE_UNINSTALLED)
+		return;
+
+	spin_lock_irqsave(&card->timer_lock, flags);
+
+	list_del(&timer->list);
+
+	list_for_each(entry, &card->timers) {
+		t = list_entry(entry, struct emu_timer, list);
+
+		if (t->delay < delay)
+			delay = t->delay;
+	}
+
+	if (card->timer_delay != delay) {
+		card->timer_delay = delay;
+
+		if (delay == TIMER_STOPPED)
+			emu10k1_irq_disable(card, INTE_INTERVALTIMERENB);
+		else {
+			delay = (delay < 1024 ? delay : 1024);
+
+			emu10k1_timer_set(card, delay);
+
+			list_for_each(entry, &card->timers) {
+				t = list_entry(entry, struct emu_timer, list);
+
+				t->count_max = t->delay / delay;
+				t->count = t->count_max - 1;
+			}
+		}
+
+		DPD(2, "timer rate --> %u\n", delay);
+	}
+
+	spin_unlock_irqrestore(&card->timer_lock, flags);
+
+	timer->state = TIMER_STATE_UNINSTALLED;
+
+	return;
+}
+
+void emu10k1_timer_enable(struct emu10k1_card *card, struct emu_timer *timer)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->timer_lock, flags);
+	timer->state |= TIMER_STATE_ACTIVE;
+	spin_unlock_irqrestore(&card->timer_lock, flags);
+
+	return;
+}
+
+void emu10k1_timer_disable(struct emu10k1_card *card, struct emu_timer *timer)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->timer_lock, flags);
+	timer->state &= ~TIMER_STATE_ACTIVE;
+	spin_unlock_irqrestore(&card->timer_lock, flags);
+
+	return;
+}
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/timer.h patched/drivers/sound/audigy/timer.h
--- old/drivers/sound/audigy/timer.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/timer.h	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,54 @@
+/*
+ **********************************************************************
+ *     timer.h
+ *     Copyright (C) 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+
+#ifndef _TIMER_H
+#define _TIMER_H
+
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include "hwaccess.h"
+
+struct emu_timer 
+{
+	struct list_head list;
+	struct tasklet_struct tasklet;
+	u8 state; 
+	u16 count;				/* current number of interrupts */
+	u16 count_max;				/* number of interrupts needed to schedule the bh */
+	u16 delay;                              /* timer delay */
+};
+
+void emu10k1_timer_install(struct emu10k1_card *, struct emu_timer *, u16);
+void emu10k1_timer_uninstall(struct emu10k1_card *, struct emu_timer *);
+void emu10k1_timer_enable(struct emu10k1_card *, struct emu_timer *);
+void emu10k1_timer_disable(struct emu10k1_card *, struct emu_timer *);
+
+#define TIMER_STOPPED 			0xffff 
+#define TIMER_STATE_INSTALLED 		0x01
+#define TIMER_STATE_ACTIVE		0x02
+#define TIMER_STATE_UNINSTALLED 	0x04
+
+#endif /* _TIMER_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/voicemgr.c patched/drivers/sound/audigy/voicemgr.c
--- old/drivers/sound/audigy/voicemgr.c	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/voicemgr.c	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,397 @@
+/*
+ **********************************************************************
+ *     voicemgr.c - Voice manager for emu10k1 driver
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#include "voicemgr.h"
+#include "8010.h"
+
+#define PITCH_48000 0x00004000
+#define PITCH_96000 0x00008000
+#define PITCH_85000 0x00007155
+#define PITCH_80726 0x00006ba2
+#define PITCH_67882 0x00005a82
+#define PITCH_57081 0x00004c1c
+
+u32 emu10k1_select_interprom(struct emu10k1_card *card, struct emu_voice *voice)
+{
+	if(voice->pitch_target==PITCH_48000)
+		return CCCA_INTERPROM_0;
+	else if(voice->pitch_target<PITCH_48000)
+		return CCCA_INTERPROM_1;
+	else  if(voice->pitch_target>=PITCH_96000)
+		return CCCA_INTERPROM_0;
+	else  if(voice->pitch_target>=PITCH_85000)
+		return CCCA_INTERPROM_6;
+	else  if(voice->pitch_target>=PITCH_80726)
+		return CCCA_INTERPROM_5;
+	else  if(voice->pitch_target>=PITCH_67882)
+		return CCCA_INTERPROM_4;
+	else  if(voice->pitch_target>=PITCH_57081)
+		return CCCA_INTERPROM_3;
+	else  
+		return CCCA_INTERPROM_2;
+}
+
+
+/**
+ * emu10k1_voice_alloc_buffer -
+ *
+ * allocates the memory buffer for a voice. Two page tables are kept for each buffer.
+ * One (dma_handle) keeps track of the host memory pages used and the other (virtualpagetable)
+ * is passed to the device so that it can do DMA to host memory.
+ *
+ */
+int emu10k1_voice_alloc_buffer(struct emu10k1_card *card, struct voice_mem *mem, u32 pages)
+{
+	u32 pageindex, pagecount;
+	u32 busaddx;
+	int i;
+
+	DPD(2, "requested pages is: %d\n", pages);
+
+	if ((mem->emupageindex = emu10k1_addxmgr_alloc(pages * PAGE_SIZE, card)) < 0)
+	{
+		DPF(1, "couldn't allocate emu10k1 address space\n");
+		return -1;
+	}
+
+	/* Fill in virtual memory table */
+	for (pagecount = 0; pagecount < pages; pagecount++) {
+		if ((mem->addr[pagecount] = pci_alloc_consistent(card->pci_dev, PAGE_SIZE, &mem->dma_handle[pagecount]))
+			== NULL) {
+			mem->pages = pagecount;
+			DPF(1, "couldn't allocate dma memory\n");
+			return -1;
+		}
+
+		DPD(2, "Virtual Addx: %p\n", mem->addr[pagecount]);
+
+		for (i = 0; i < PAGE_SIZE / EMUPAGESIZE; i++) {
+			busaddx = (u32) mem->dma_handle[pagecount] + i * EMUPAGESIZE;
+
+			DPD(3, "Bus Addx: %#x\n", busaddx);
+
+			pageindex = mem->emupageindex + pagecount * PAGE_SIZE / EMUPAGESIZE + i;
+
+			((u32 *) card->virtualpagetable.addr)[pageindex] = cpu_to_le32((busaddx * 2) | pageindex);
+		}
+	}
+
+	mem->pages = pagecount;
+
+	return 0;
+}
+
+/**
+ * emu10k1_voice_free_buffer -
+ *
+ * frees the memory buffer for a voice.
+ */
+void emu10k1_voice_free_buffer(struct emu10k1_card *card, struct voice_mem *mem)
+{
+	u32 pagecount, pageindex;
+	int i;
+
+	if (mem->emupageindex < 0)
+		return;
+
+	for (pagecount = 0; pagecount < mem->pages; pagecount++) {
+		pci_free_consistent(card->pci_dev, PAGE_SIZE,
+					mem->addr[pagecount],
+					mem->dma_handle[pagecount]);
+
+		for (i = 0; i < PAGE_SIZE / EMUPAGESIZE; i++) {
+			pageindex = mem->emupageindex + pagecount * PAGE_SIZE / EMUPAGESIZE + i;
+			((u32 *) card->virtualpagetable.addr)[pageindex] =
+				cpu_to_le32(((u32) card->silentpage.dma_handle * 2) | pageindex);
+		}
+	}
+
+	emu10k1_addxmgr_free(card, mem->emupageindex);
+	mem->emupageindex = -1;
+}
+
+int emu10k1_voice_alloc(struct emu10k1_card *card, struct emu_voice *voice)
+{
+	u8 *voicetable = card->voicetable;
+	int i;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_voice_alloc()\n");
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	if (voice->flags & VOICE_FLAGS_STEREO) {
+		for (i = 0; i < NUM_G; i += 2)
+			if ((voicetable[i] == VOICE_USAGE_FREE) && (voicetable[i + 1] == VOICE_USAGE_FREE)) {
+				voicetable[i] = voice->usage;
+				voicetable[i + 1] = voice->usage;
+				break;
+			}
+	} else {
+		for (i = 0; i < NUM_G; i++)
+			if (voicetable[i] == VOICE_USAGE_FREE) {
+				voicetable[i] = voice->usage;
+				break;
+			}
+	}
+
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	if (i >= NUM_G)
+		return -1;
+
+	voice->card = card;
+	voice->num = i;
+
+	for (i = 0; i < (voice->flags & VOICE_FLAGS_STEREO ? 2 : 1); i++) {
+		DPD(2, " voice allocated -> %d\n", voice->num + i);
+
+		sblive_writeptr_tag(card, voice->num + i, IFATN, 0xffff,
+							DCYSUSV, 0,
+							VTFT, 0x0000ffff,
+							PTRX, 0,
+							TAGLIST_END);
+	}
+
+	return 0;
+}
+
+void emu10k1_voice_free(struct emu_voice *voice)
+{
+	struct emu10k1_card *card = voice->card;
+	int i;
+	unsigned long flags;
+
+	DPF(2, "emu10k1_voice_free()\n");
+
+	if (voice->usage == VOICE_USAGE_FREE)
+		return;
+
+	for (i = 0; i < (voice->flags & VOICE_FLAGS_STEREO ? 2 : 1); i++) {
+		DPD(2, " voice released -> %d\n", voice->num + i);
+
+		sblive_writeptr_tag(card, voice->num + i, DCYSUSV, 0, 
+							VTFT, 0x0000ffff,
+							PTRX_PITCHTARGET, 0,
+							CVCF, 0x0000ffff,
+							//CPF, 0,
+							TAGLIST_END);
+		
+		sblive_writeptr(card, CPF, voice->num + i, 0);
+	}
+
+	voice->usage = VOICE_USAGE_FREE;
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	card->voicetable[voice->num] = VOICE_USAGE_FREE;
+
+	if (voice->flags & VOICE_FLAGS_STEREO)
+		card->voicetable[voice->num + 1] = VOICE_USAGE_FREE;
+
+	spin_unlock_irqrestore(&card->lock, flags);
+}
+
+void emu10k1_voice_playback_setup(struct emu_voice *voice)
+{
+	struct emu10k1_card *card = voice->card;
+	u32 start;
+	int i;
+
+	DPF(2, "emu10k1_voice_playback_setup()\n");
+
+	if (voice->flags & VOICE_FLAGS_STEREO) {
+		/* Set stereo bit */
+		start = 28;
+		sblive_writeptr(card, CPF, voice->num, CPF_STEREO_MASK);
+		sblive_writeptr(card, CPF, voice->num + 1, CPF_STEREO_MASK);
+	} else {
+		start = 30;
+		sblive_writeptr(card, CPF, voice->num, 0);
+	}
+
+	if(!(voice->flags & VOICE_FLAGS_16BIT))
+		start *= 2;
+
+	voice->start += start;
+
+	for (i = 0; i < (voice->flags & VOICE_FLAGS_STEREO ? 2 : 1); i++) {
+		if (card->is_audigy) {
+			sblive_writeptr(card, A_FXRT1, voice->num + i, voice->params[i].send_routing);
+			sblive_writeptr(card, A_FXRT2, voice->num + i, voice->params[i].send_routing2);
+			sblive_writeptr(card,  A_SENDAMOUNTS, voice->num + i, voice->params[i].send_hgfe);
+		} else {
+			sblive_writeptr(card, FXRT, voice->num + i, voice->params[i].send_routing << 16);
+		}
+
+		/* Stop CA */
+		/* Assumption that PT is already 0 so no harm overwriting */
+		sblive_writeptr(card, PTRX, voice->num + i, ((voice->params[i].send_dcba & 0xff) << 8)
+				| ((voice->params[i].send_dcba & 0xff00) >> 8));
+
+		sblive_writeptr_tag(card, voice->num + i,
+				/* CSL, ST, CA */
+				    DSL, voice->endloop | (voice->params[i].send_dcba & 0xff000000),
+				    PSST, voice->startloop | ((voice->params[i].send_dcba & 0x00ff0000) << 8),
+				    CCCA, (voice->start) |  emu10k1_select_interprom(card,voice) |
+				        ((voice->flags & VOICE_FLAGS_16BIT) ? 0 : CCCA_8BITSELECT),
+				    /* Clear filter delay memory */
+				    Z1, 0,
+				    Z2, 0,
+				    /* Invalidate maps */
+				    MAPA, MAP_PTI_MASK | ((u32) card->silentpage.dma_handle * 2),
+				    MAPB, MAP_PTI_MASK | ((u32) card->silentpage.dma_handle * 2),
+				/* modulation envelope */
+				    CVCF, 0x0000ffff,
+				    VTFT, 0x0000ffff,
+				    ATKHLDM, 0,
+				    DCYSUSM, 0x007f,
+				    LFOVAL1, 0x8000,
+				    LFOVAL2, 0x8000,
+				    FMMOD, 0,
+				    TREMFRQ, 0,
+				    FM2FRQ2, 0,
+				    ENVVAL, 0x8000,
+				/* volume envelope */
+				    ATKHLDV, 0x7f7f,
+				    ENVVOL, 0x8000,
+				/* filter envelope */
+				    PEFE_FILTERAMOUNT, 0x7f,
+				/* pitch envelope */
+				    PEFE_PITCHAMOUNT, 0, TAGLIST_END);
+
+		voice->params[i].fc_target = 0xffff;
+	}
+}
+
+void emu10k1_voices_start(struct emu_voice *first_voice, unsigned int num_voices, int set)
+{
+	struct emu10k1_card *card = first_voice->card;
+	struct emu_voice *voice;
+	unsigned int voicenum;
+	int j;
+
+	DPF(2, "emu10k1_voices_start()\n");
+
+	for (voicenum = 0; voicenum < num_voices; voicenum++)
+	{
+		voice = first_voice + voicenum;
+
+		if (!set) {
+			u32 cra, ccis, cs, sample;
+			if (voice->flags & VOICE_FLAGS_STEREO) {
+				cra = 64;
+				ccis = 28;
+				cs = 4;
+			} else {
+				cra = 64;
+				ccis = 30;
+				cs = 2;
+			}
+
+			if(voice->flags & VOICE_FLAGS_16BIT) {
+				sample = 0x00000000;
+			} else {
+				sample = 0x80808080;		
+				ccis *= 2;
+			}
+
+			for(j = 0; j < cs; j++)
+	        	        sblive_writeptr(card, CD0 + j, voice->num, sample);
+
+			/* Reset cache */
+			sblive_writeptr(card, CCR_CACHEINVALIDSIZE, voice->num, 0);
+			if (voice->flags & VOICE_FLAGS_STEREO)
+				sblive_writeptr(card, CCR_CACHEINVALIDSIZE, voice->num + 1, 0);
+
+			sblive_writeptr(card, CCR_READADDRESS, voice->num, cra);
+
+			if (voice->flags & VOICE_FLAGS_STEREO)
+				sblive_writeptr(card, CCR_READADDRESS, voice->num + 1, cra);
+
+			/* Fill cache */
+			sblive_writeptr(card, CCR_CACHEINVALIDSIZE, voice->num, ccis);
+		}
+
+		for (j = 0; j < (voice->flags & VOICE_FLAGS_STEREO ? 2 : 1); j++) {
+			sblive_writeptr_tag(card, voice->num + j,
+				    IFATN, (voice->params[j].initial_fc << 8) | voice->params[j].initial_attn,
+				    VTFT, (voice->params[j].volume_target << 16) | voice->params[j].fc_target,
+				    CVCF, (voice->params[j].volume_target << 16) | voice->params[j].fc_target,
+				    DCYSUSV, (voice->params[j].byampl_env_sustain << 8) | voice->params[j].byampl_env_decay,
+				    TAGLIST_END);
+	
+			emu10k1_clear_stop_on_loop(card, voice->num + j);
+		}
+	}
+
+
+        for (voicenum = 0; voicenum < num_voices; voicenum++)
+	{
+		voice = first_voice + voicenum;
+
+		for (j = 0; j < (voice->flags & VOICE_FLAGS_STEREO ? 2 : 1); j++) {
+			sblive_writeptr(card, PTRX_PITCHTARGET, voice->num + j, voice->pitch_target);
+
+			if (j == 0)
+				sblive_writeptr(card, CPF_CURRENTPITCH, voice->num, voice->pitch_target);
+
+			sblive_writeptr(card, IP, voice->num + j, voice->initial_pitch);
+		}
+	}
+}
+
+void emu10k1_voices_stop(struct emu_voice *first_voice, int num_voices)
+{
+	struct emu10k1_card *card = first_voice->card;
+	struct emu_voice *voice;
+	unsigned int voice_num;
+	int j;
+
+	DPF(2, "emu10k1_voice_stop()\n");
+
+        for (voice_num = 0; voice_num < num_voices; voice_num++)
+	{
+		voice = first_voice + voice_num;
+
+		for (j = 0; j < (voice->flags & VOICE_FLAGS_STEREO ? 2 : 1); j++) {
+			sblive_writeptr_tag(card, voice->num + j,
+						PTRX_PITCHTARGET, 0,
+						CPF_CURRENTPITCH, 0,
+						IFATN, 0xffff,
+						VTFT, 0x0000ffff,
+						CVCF, 0x0000ffff,
+						IP, 0,
+						TAGLIST_END);
+		}
+	}
+}
+
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/voicemgr.h patched/drivers/sound/audigy/voicemgr.h
--- old/drivers/sound/audigy/voicemgr.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/voicemgr.h	2003-07-22 21:52:40.000000000 +0300
@@ -0,0 +1,103 @@
+/*
+ **********************************************************************
+ *     sblive_voice.h -- EMU Voice Resource Manager header file
+ *     Copyright 1999, 2000 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date                 Author          Summary of changes
+ *     ----                 ------          ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ **********************************************************************
+ */
+
+#ifndef _VOICEMGR_H
+#define _VOICEMGR_H
+
+#include "hwaccess.h"
+
+/* struct emu_voice.usage flags */
+#define VOICE_USAGE_FREE		0x01
+#define VOICE_USAGE_MIDI		0x02
+#define VOICE_USAGE_PLAYBACK		0x04
+
+/* struct emu_voice.flags flags */
+#define VOICE_FLAGS_STEREO		0x02
+#define VOICE_FLAGS_16BIT		0x04
+
+struct voice_param
+{
+	/* FX bus amount send */
+
+	u32 send_routing;
+	// audigy only:
+	u32 send_routing2;
+
+	u32 send_dcba;
+	// audigy only:
+	u32 send_hgfe;
+
+
+	u32 initial_fc;
+	u32 fc_target;
+
+	u32 initial_attn;
+	u32 volume_target;
+
+	u32 byampl_env_sustain;
+	u32 byampl_env_decay;
+};
+
+struct voice_mem {
+	int emupageindex;
+	void *addr[BUFMAXPAGES];
+	dma_addr_t dma_handle[BUFMAXPAGES];
+	u32 pages;
+};
+
+struct emu_voice
+{
+	struct emu10k1_card *card;
+	u8 usage;		/* Free, MIDI, playback */
+	u8 num;			/* Voice ID */
+	u8 flags;		/* Stereo/mono, 8/16 bit */
+
+	u32 startloop;
+	u32 endloop;
+	u32 start;
+
+	u32 initial_pitch;
+	u32 pitch_target;
+
+	struct voice_param params[2];
+
+	struct voice_mem mem;
+};
+
+int emu10k1_voice_alloc_buffer(struct emu10k1_card *, struct voice_mem *, u32);
+void emu10k1_voice_free_buffer(struct emu10k1_card *, struct voice_mem *);
+int emu10k1_voice_alloc(struct emu10k1_card *, struct emu_voice *);
+void emu10k1_voice_free(struct emu_voice *);
+void emu10k1_voice_playback_setup(struct emu_voice *);
+void emu10k1_voices_start(struct emu_voice *, unsigned int, int);
+void emu10k1_voices_stop(struct emu_voice *, int);
+
+#endif /* _VOICEMGR_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/audigy/8010.h patched/drivers/sound/audigy/8010.h
--- old/drivers/sound/audigy/8010.h	1970-01-01 02:00:00.000000000 +0200
+++ patched/drivers/sound/audigy/8010.h	2003-08-02 15:38:58.000000000 +0300
@@ -0,0 +1,737 @@
+/*
+ **********************************************************************
+ *     8010.h
+ *     Copyright 1999-2001 Creative Labs, Inc.
+ *
+ **********************************************************************
+ *
+ *     Date		    Author	    Summary of changes
+ *     ----		    ------	    ------------------
+ *     October 20, 1999     Bertrand Lee    base code release
+ *     November 2, 1999     Alan Cox	    Cleaned of 8bit chars, DOS
+ *					    line endings
+ *     December 8, 1999     Jon Taylor	    Added lots of new register info
+ *     May 16, 2001         Daniel Bertrand Added unofficial DBG register info
+ *     Oct-Nov 2001         D.B.            Added unofficial Audigy registers 
+ *
+ **********************************************************************
+ *
+ *     This program is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of
+ *     the License, or (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this program; if not, write to the Free
+ *     Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
+ *     USA.
+ *
+ *
+ **********************************************************************
+ */
+
+
+#ifndef _8010_H
+#define _8010_H
+
+#include <linux/types.h>
+
+// Driver version:
+#define MAJOR_VER 0
+#define MINOR_VER 20
+#define DRIVER_VERSION "0.20a"
+
+
+// Audigy specify registers are prefixed with 'A_'
+
+/************************************************************************************************/
+/* PCI function 0 registers, address = <val> + PCIBASE0						*/
+/************************************************************************************************/
+
+#define PTR			0x00		/* Indexed register set pointer register	*/
+						/* NOTE: The CHANNELNUM and ADDRESS words can	*/
+						/* be modified independently of each other.	*/
+#define PTR_CHANNELNUM_MASK	0x0000003f	/* For each per-channel register, indicates the	*/
+						/* channel number of the register to be		*/
+						/* accessed.  For non per-channel registers the	*/
+						/* value should be set to zero.			*/
+#define PTR_ADDRESS_MASK	0x07ff0000	/* Register index				*/
+
+#define DATA			0x04		/* Indexed register set data register		*/
+
+#define IPR			0x08		/* Global interrupt pending register		*/
+						/* Clear pending interrupts by writing a 1 to	*/
+						/* the relevant bits and zero to the other bits	*/
+
+/* The next two interrupts are for the midi port on the Audigy Drive (A_MPU1)			*/
+#define A_IPR_MIDITRANSBUFEMPTY2	0x10000000	/* MIDI UART transmit buffer empty		*/
+#define A_IPR_MIDIRECVBUFEMPTY2	0x08000000	/* MIDI UART receive buffer empty		*/
+
+#define IPR_SAMPLERATETRACKER	0x01000000	/* Sample rate tracker lock status change	*/
+#define IPR_FXDSP		0x00800000	/* Enable FX DSP interrupts			*/
+#define IPR_FORCEINT		0x00400000	/* Force Sound Blaster interrupt		*/
+#define IPR_PCIERROR		0x00200000	/* PCI bus error				*/
+#define IPR_VOLINCR		0x00100000	/* Volume increment button pressed		*/
+#define IPR_VOLDECR		0x00080000	/* Volume decrement button pressed		*/
+#define IPR_MUTE		0x00040000	/* Mute button pressed				*/
+#define IPR_MICBUFFULL		0x00020000	/* Microphone buffer full			*/
+#define IPR_MICBUFHALFFULL	0x00010000	/* Microphone buffer half full			*/
+#define IPR_ADCBUFFULL		0x00008000	/* ADC buffer full				*/
+#define IPR_ADCBUFHALFFULL	0x00004000	/* ADC buffer half full				*/
+#define IPR_EFXBUFFULL		0x00002000	/* Effects buffer full				*/
+#define IPR_EFXBUFHALFFULL	0x00001000	/* Effects buffer half full			*/
+#define IPR_GPSPDIFSTATUSCHANGE	0x00000800	/* GPSPDIF channel status change		*/
+#define IPR_CDROMSTATUSCHANGE	0x00000400	/* CD-ROM channel status change			*/
+#define IPR_INTERVALTIMER	0x00000200	/* Interval timer terminal count		*/
+#define IPR_MIDITRANSBUFEMPTY	0x00000100	/* MIDI UART transmit buffer empty		*/
+#define IPR_MIDIRECVBUFEMPTY	0x00000080	/* MIDI UART receive buffer empty		*/
+#define IPR_CHANNELLOOP		0x00000040	/* One or more channel loop interrupts pending	*/
+#define IPR_CHANNELNUMBERMASK	0x0000003f	/* When IPR_CHANNELLOOP is set, indicates the	*/
+						/* Highest set channel in CLIPL or CLIPH.  When	*/
+						/* IP is written with CL set, the bit in CLIPL	*/
+						/* or CLIPH corresponding to the CIN value 	*/
+						/* written will be cleared.			*/
+#define A_IPR_MIDITRANSBUFEMPTY1	IPR_MIDITRANSBUFEMPTY	/* MIDI UART transmit buffer empty		*/
+#define A_IPR_MIDIRECVBUFEMPTY1	IPR_MIDIRECVBUFEMPTY	/* MIDI UART receive buffer empty		*/
+
+
+
+#define INTE			0x0c		/* Interrupt enable register			*/
+#define INTE_VIRTUALSB_MASK	0xc0000000	/* Virtual Soundblaster I/O port capture	*/
+#define INTE_VIRTUALSB_220	0x00000000	/* Capture at I/O base address 0x220-0x22f	*/
+#define INTE_VIRTUALSB_240	0x40000000	/* Capture at I/O base address 0x240		*/
+#define INTE_VIRTUALSB_260	0x80000000	/* Capture at I/O base address 0x260		*/
+#define INTE_VIRTUALSB_280	0xc0000000	/* Capture at I/O base address 0x280		*/
+#define INTE_VIRTUALMPU_MASK	0x30000000	/* Virtual MPU I/O port capture			*/
+#define INTE_VIRTUALMPU_300	0x00000000	/* Capture at I/O base address 0x300-0x301	*/
+#define INTE_VIRTUALMPU_310	0x10000000	/* Capture at I/O base address 0x310		*/
+#define INTE_VIRTUALMPU_320	0x20000000	/* Capture at I/O base address 0x320		*/
+#define INTE_VIRTUALMPU_330	0x30000000	/* Capture at I/O base address 0x330		*/
+#define INTE_MASTERDMAENABLE	0x08000000	/* Master DMA emulation at 0x000-0x00f		*/
+#define INTE_SLAVEDMAENABLE	0x04000000	/* Slave DMA emulation at 0x0c0-0x0df		*/
+#define INTE_MASTERPICENABLE	0x02000000	/* Master PIC emulation at 0x020-0x021		*/
+#define INTE_SLAVEPICENABLE	0x01000000	/* Slave PIC emulation at 0x0a0-0x0a1		*/
+#define INTE_VSBENABLE		0x00800000	/* Enable virtual Soundblaster			*/
+#define INTE_ADLIBENABLE	0x00400000	/* Enable AdLib emulation at 0x388-0x38b	*/
+#define INTE_MPUENABLE		0x00200000	/* Enable virtual MPU				*/
+#define INTE_FORCEINT		0x00100000	/* Continuously assert INTAN			*/
+
+#define INTE_MRHANDENABLE	0x00080000	/* Enable the "Mr. Hand" logic			*/
+						/* NOTE: There is no reason to use this under	*/
+						/* Linux, and it will cause odd hardware 	*/
+						/* behavior and possibly random segfaults and	*/
+						/* lockups if enabled.				*/
+
+/* The next two interrupts are for the midi port on the Audigy Drive (A_MPU1)			*/
+#define A_INTE_MIDITXENABLE2	0x00020000	/* Enable MIDI transmit-buffer-empty interrupts	*/
+#define A_INTE_MIDIRXENABLE2	0x00010000	/* Enable MIDI receive-buffer-empty interrupts	*/
+
+
+#define INTE_SAMPLERATETRACKER	0x00002000	/* Enable sample rate tracker interrupts	*/
+						/* NOTE: This bit must always be enabled       	*/
+#define INTE_FXDSPENABLE	0x00001000	/* Enable FX DSP interrupts			*/
+#define INTE_PCIERRORENABLE	0x00000800	/* Enable PCI bus error interrupts		*/
+#define INTE_VOLINCRENABLE	0x00000400	/* Enable volume increment button interrupts	*/
+#define INTE_VOLDECRENABLE	0x00000200	/* Enable volume decrement button interrupts	*/
+#define INTE_MUTEENABLE		0x00000100	/* Enable mute button interrupts		*/
+#define INTE_MICBUFENABLE	0x00000080	/* Enable microphone buffer interrupts		*/
+#define INTE_ADCBUFENABLE	0x00000040	/* Enable ADC buffer interrupts			*/
+#define INTE_EFXBUFENABLE	0x00000020	/* Enable Effects buffer interrupts		*/
+#define INTE_GPSPDIFENABLE	0x00000010	/* Enable GPSPDIF status interrupts		*/
+#define INTE_CDSPDIFENABLE	0x00000008	/* Enable CDSPDIF status interrupts		*/
+#define INTE_INTERVALTIMERENB	0x00000004	/* Enable interval timer interrupts		*/
+#define INTE_MIDITXENABLE	0x00000002	/* Enable MIDI transmit-buffer-empty interrupts	*/
+#define INTE_MIDIRXENABLE	0x00000001	/* Enable MIDI receive-buffer-empty interrupts	*/
+
+/* The next two interrupts are for the midi port on the Audigy (A_MPU2)	*/
+#define A_INTE_MIDITXENABLE1  	INTE_MIDITXENABLE
+#define A_INTE_MIDIRXENABLE1	INTE_MIDIRXENABLE
+
+#define WC			0x10		/* Wall Clock register				*/
+#define WC_SAMPLECOUNTER_MASK	0x03FFFFC0	/* Sample periods elapsed since reset		*/
+#define WC_SAMPLECOUNTER	0x14060010
+#define WC_CURRENTCHANNEL	0x0000003F	/* Channel [0..63] currently being serviced	*/
+						/* NOTE: Each channel takes 1/64th of a sample	*/
+						/* period to be serviced.			*/
+
+#define HCFG			0x14		/* Hardware config register			*/
+						/* NOTE: There is no reason to use the legacy	*/
+						/* SoundBlaster emulation stuff described below	*/
+						/* under Linux, and all kinds of weird hardware	*/
+						/* behavior can result if you try.  Don't.	*/
+#define HCFG_LEGACYFUNC_MASK	0xe0000000	/* Legacy function number 			*/
+#define HCFG_LEGACYFUNC_MPU	0x00000000	/* Legacy MPU	 				*/
+#define HCFG_LEGACYFUNC_SB	0x40000000	/* Legacy SB					*/
+#define HCFG_LEGACYFUNC_AD	0x60000000	/* Legacy AD					*/
+#define HCFG_LEGACYFUNC_MPIC	0x80000000	/* Legacy MPIC					*/
+#define HCFG_LEGACYFUNC_MDMA	0xa0000000	/* Legacy MDMA					*/
+#define HCFG_LEGACYFUNC_SPCI	0xc0000000	/* Legacy SPCI					*/
+#define HCFG_LEGACYFUNC_SDMA	0xe0000000	/* Legacy SDMA					*/
+#define HCFG_IOCAPTUREADDR	0x1f000000	/* The 4 LSBs of the captured I/O address.	*/
+#define HCFG_LEGACYWRITE	0x00800000	/* 1 = write, 0 = read 				*/
+#define HCFG_LEGACYWORD		0x00400000	/* 1 = word, 0 = byte 				*/
+#define HCFG_LEGACYINT		0x00200000	/* 1 = legacy event captured. Write 1 to clear.	*/
+						/* NOTE: The rest of the bits in this register	*/
+						/* _are_ relevant under Linux.			*/
+#define HCFG_CODECFORMAT_MASK	0x00070000	/* CODEC format					*/
+#define HCFG_CODECFORMAT_AC97	0x00000000	/* AC97 CODEC format -- Primary Output		*/
+#define HCFG_CODECFORMAT_I2S	0x00010000	/* I2S CODEC format -- Secondary (Rear) Output	*/
+#define HCFG_GPINPUT0		0x00004000	/* External pin112				*/
+#define HCFG_GPINPUT1		0x00002000	/* External pin110				*/
+
+#define HCFG_GPOUTPUT_MASK	0x00001c00	/* External pins which may be controlled	*/
+#define HCFG_GPOUT0		0x00001000	/* set to enable digital out on 5.1 cards	*/
+
+#define HCFG_JOYENABLE      	0x00000200	/* Internal joystick enable    			*/
+#define HCFG_PHASETRACKENABLE	0x00000100	/* Phase tracking enable			*/
+						/* 1 = Force all 3 async digital inputs to use	*/
+						/* the same async sample rate tracker (ZVIDEO)	*/
+#define HCFG_AC3ENABLE_MASK	0x0x0000e0	/* AC3 async input control - Not implemented	*/
+#define HCFG_AC3ENABLE_ZVIDEO	0x00000080	/* Channels 0 and 1 replace ZVIDEO		*/
+#define HCFG_AC3ENABLE_CDSPDIF	0x00000040	/* Channels 0 and 1 replace CDSPDIF		*/
+#define HCFG_AC3ENABLE_GPSPDIF  0x00000020      /* Channels 0 and 1 replace GPSPDIF             */
+#define HCFG_AUTOMUTE		0x00000010	/* When set, the async sample rate convertors	*/
+						/* will automatically mute their output when	*/
+						/* they are not rate-locked to the external	*/
+						/* async audio source  				*/
+#define HCFG_LOCKSOUNDCACHE	0x00000008	/* 1 = Cancel bustmaster accesses to soundcache */
+						/* NOTE: This should generally never be used.  	*/
+#define HCFG_LOCKTANKCACHE_MASK	0x00000004	/* 1 = Cancel bustmaster accesses to tankcache	*/
+						/* NOTE: This should generally never be used.  	*/
+#define HCFG_LOCKTANKCACHE	0x01020014
+#define HCFG_MUTEBUTTONENABLE	0x00000002	/* 1 = Master mute button sets AUDIOENABLE = 0.	*/
+						/* NOTE: This is a 'cheap' way to implement a	*/
+						/* master mute function on the mute button, and	*/
+						/* in general should not be used unless a more	*/
+						/* sophisticated master mute function has not	*/
+						/* been written.       				*/
+#define HCFG_AUDIOENABLE	0x00000001	/* 0 = CODECs transmit zero-valued samples	*/
+						/* Should be set to 1 when the EMU10K1 is	*/
+						/* completely initialized.			*/
+
+//For Audigy, MPU port move to 0x70-0x74 ptr register
+
+#define MUDATA			0x18		/* MPU401 data register (8 bits)       		*/
+
+#define MUCMD			0x19		/* MPU401 command register (8 bits)    		*/
+#define MUCMD_RESET		0xff		/* RESET command				*/
+#define MUCMD_ENTERUARTMODE	0x3f		/* Enter_UART_mode command			*/
+						/* NOTE: All other commands are ignored		*/
+
+#define MUSTAT			MUCMD		/* MPU401 status register (8 bits)     		*/
+#define MUSTAT_IRDYN		0x80		/* 0 = MIDI data or command ACK			*/
+#define MUSTAT_ORDYN		0x40		/* 0 = MUDATA can accept a command or data	*/
+
+#define A_IOCFG			0x18		/* GPIO on Audigy card (16bits)			*/
+#define A_GPINPUT_MASK		0xff00
+#define A_GPOUTPUT_MASK		0x00ff
+
+#define TIMER			0x1a		/* Timer terminal count register (16-bit)	*/
+						/* NOTE: After the rate is changed, a maximum	*/
+						/* of 1024 sample periods should be allowed	*/
+						/* before the new rate is guaranteed accurate.	*/
+#define TIMER_RATE_MASK		0x03ff		/* Timer interrupt rate in sample periods	*/
+						/* 0 == 1024 periods, [1..4] are not useful	*/
+
+#define AC97DATA		0x1c		/* AC97 register set data register (16 bit)	*/
+
+#define AC97ADDRESS		0x1e		/* AC97 register set address register (8 bit)	*/
+#define AC97ADDRESS_READY	0x80		/* Read-only bit, reflects CODEC READY signal	*/
+#define AC97ADDRESS_ADDRESS	0x7f		/* Address of indexed AC97 register		*/
+
+/********************************************************************************************************/
+/* Emu10k1 pointer-offset register set, accessed through the PTR and DATA registers			*/
+/********************************************************************************************************/
+
+#define CPF			0x00		/* Current pitch and fraction register			*/
+#define CPF_CURRENTPITCH_MASK	0xffff0000	/* Current pitch (linear, 0x4000 == unity pitch shift) 	*/
+#define CPF_CURRENTPITCH	0x10100000
+#define CPF_STEREO_MASK		0x00008000	/* 1 = Even channel interleave, odd channel locked	*/
+#define CPF_STOP_MASK		0x00004000	/* 1 = Current pitch forced to 0			*/
+#define CPF_FRACADDRESS_MASK	0x00003fff	/* Linear fractional address of the current channel	*/
+
+#define PTRX			0x01		/* Pitch target and send A/B amounts register		*/
+#define PTRX_PITCHTARGET_MASK	0xffff0000	/* Pitch target of specified channel			*/
+#define PTRX_PITCHTARGET	0x10100001
+#define PTRX_FXSENDAMOUNT_A_MASK 0x0000ff00	/* Linear level of channel output sent to FX send bus A	*/
+#define PTRX_FXSENDAMOUNT_A	0x08080001
+#define PTRX_FXSENDAMOUNT_B_MASK 0x000000ff	/* Linear level of channel output sent to FX send bus B	*/
+#define PTRX_FXSENDAMOUNT_B	0x08000001
+
+#define CVCF			0x02		/* Current volume and filter cutoff register		*/
+#define CVCF_CURRENTVOL_MASK	0xffff0000	/* Current linear volume of specified channel		*/
+#define CVCF_CURRENTVOL		0x10100002
+#define CVCF_CURRENTFILTER_MASK	0x0000ffff	/* Current filter cutoff frequency of specified channel	*/
+#define CVCF_CURRENTFILTER	0x10000002
+
+#define VTFT			0x03		/* Volume target and filter cutoff target register	*/
+#define VTFT_VOLUMETARGET_MASK	0xffff0000	/* Volume target of specified channel			*/
+#define VTFT_FILTERTARGET_MASK	0x0000ffff	/* Filter cutoff target of specified channel		*/
+
+#define Z1			0x05		/* Filter delay memory 1 register			*/
+
+#define Z2			0x04		/* Filter delay memory 2 register			*/
+
+#define PSST			0x06		/* Send C amount and loop start address register	*/
+#define PSST_FXSENDAMOUNT_C_MASK 0xff000000	/* Linear level of channel output sent to FX send bus C	*/
+
+#define PSST_FXSENDAMOUNT_C	0x08180006
+
+#define PSST_LOOPSTARTADDR_MASK	0x00ffffff	/* Loop start address of the specified channel		*/
+#define PSST_LOOPSTARTADDR	0x18000006
+
+#define DSL			0x07		/* Send D amount and loop start address register	*/
+#define DSL_FXSENDAMOUNT_D_MASK	0xff000000	/* Linear level of channel output sent to FX send bus D	*/
+
+#define DSL_FXSENDAMOUNT_D	0x08180007
+
+#define DSL_LOOPENDADDR_MASK	0x00ffffff	/* Loop end address of the specified channel		*/
+#define DSL_LOOPENDADDR		0x18000007
+
+#define CCCA			0x08		/* Filter Q, interp. ROM, byte size, cur. addr register */
+#define CCCA_RESONANCE		0xf0000000	/* Lowpass filter resonance (Q) height			*/
+#define CCCA_INTERPROMMASK	0x0e000000	/* Selects passband of interpolation ROM		*/
+						/* 1 == full band, 7 == lowpass				*/
+						/* ROM 0 is used when pitch shifting downward or less	*/
+						/* then 3 semitones upward.  Increasingly higher ROM	*/
+						/* numbers are used, typically in steps of 3 semitones,	*/
+						/* as upward pitch shifting is performed.		*/
+#define CCCA_INTERPROM_0	0x00000000	/* Select interpolation ROM 0				*/
+#define CCCA_INTERPROM_1	0x02000000	/* Select interpolation ROM 1				*/
+#define CCCA_INTERPROM_2	0x04000000	/* Select interpolation ROM 2				*/
+#define CCCA_INTERPROM_3	0x06000000	/* Select interpolation ROM 3				*/
+#define CCCA_INTERPROM_4	0x08000000	/* Select interpolation ROM 4				*/
+#define CCCA_INTERPROM_5	0x0a000000	/* Select interpolation ROM 5				*/
+#define CCCA_INTERPROM_6	0x0c000000	/* Select interpolation ROM 6				*/
+#define CCCA_INTERPROM_7	0x0e000000	/* Select interpolation ROM 7				*/
+#define CCCA_8BITSELECT		0x01000000	/* 1 = Sound memory for this channel uses 8-bit samples	*/
+#define CCCA_CURRADDR_MASK	0x00ffffff	/* Current address of the selected channel		*/
+#define CCCA_CURRADDR		0x18000008
+
+#define CCR			0x09		/* Cache control register				*/
+#define CCR_CACHEINVALIDSIZE	0x07190009
+#define CCR_CACHEINVALIDSIZE_MASK	0xfe000000	/* Number of invalid samples cache for this channel    	*/
+#define CCR_CACHELOOPFLAG	0x01000000	/* 1 = Cache has a loop service pending			*/
+#define CCR_INTERLEAVEDSAMPLES	0x00800000	/* 1 = A cache service will fetch interleaved samples	*/
+#define CCR_WORDSIZEDSAMPLES	0x00400000	/* 1 = A cache service will fetch word sized samples	*/
+#define CCR_READADDRESS		0x06100009
+#define CCR_READADDRESS_MASK	0x003f0000	/* Location of cache just beyond current cache service	*/
+#define CCR_LOOPINVALSIZE	0x0000fe00	/* Number of invalid samples in cache prior to loop	*/
+						/* NOTE: This is valid only if CACHELOOPFLAG is set	*/
+#define CCR_LOOPFLAG		0x00000100	/* Set for a single sample period when a loop occurs	*/
+#define CCR_CACHELOOPADDRHI	0x000000ff	/* DSL_LOOPSTARTADDR's hi byte if CACHELOOPFLAG is set	*/
+
+#define CLP			0x0a		/* Cache loop register (valid if CCR_CACHELOOPFLAG = 1) */
+						/* NOTE: This register is normally not used		*/
+#define CLP_CACHELOOPADDR	0x0000ffff	/* Cache loop address (DSL_LOOPSTARTADDR [0..15])	*/
+
+#define FXRT			0x0b		/* Effects send routing register			*/
+						/* NOTE: It is illegal to assign the same routing to	*/
+						/* two effects sends.					*/
+#define FXRT_CHANNELA		0x000f0000	/* Effects send bus number for channel's effects send A	*/
+#define FXRT_CHANNELB		0x00f00000	/* Effects send bus number for channel's effects send B	*/
+#define FXRT_CHANNELC		0x0f000000	/* Effects send bus number for channel's effects send C	*/
+#define FXRT_CHANNELD		0xf0000000	/* Effects send bus number for channel's effects send D	*/
+
+#define MAPA			0x0c		/* Cache map A						*/
+
+#define MAPB			0x0d		/* Cache map B						*/
+
+#define MAP_PTE_MASK		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/
+#define MAP_PTI_MASK		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/
+
+#define ENVVOL			0x10		/* Volume envelope register				*/
+#define ENVVOL_MASK		0x0000ffff	/* Current value of volume envelope state variable	*/  
+						/* 0x8000-n == 666*n usec delay	       			*/
+
+#define ATKHLDV 		0x11		/* Volume envelope hold and attack register		*/
+#define ATKHLDV_PHASE0		0x00008000	/* 0 = Begin attack phase				*/
+#define ATKHLDV_HOLDTIME_MASK	0x00007f00	/* Envelope hold time (127-n == n*88.2msec)		*/
+#define ATKHLDV_ATTACKTIME_MASK	0x0000007f	/* Envelope attack time, log encoded			*/
+						/* 0 = infinite, 1 = 10.9msec, ... 0x7f = 5.5msec	*/
+
+#define DCYSUSV 		0x12		/* Volume envelope sustain and decay register		*/
+#define DCYSUSV_PHASE1_MASK	0x00008000	/* 0 = Begin attack phase, 1 = begin release phase	*/
+#define DCYSUSV_SUSTAINLEVEL_MASK 0x00007f00	/* 127 = full, 0 = off, 0.75dB increments		*/
+#define DCYSUSV_CHANNELENABLE_MASK 0x00000080	/* 1 = Inhibit envelope engine from writing values in	*/
+						/* this channel and from writing to pitch, filter and	*/
+						/* volume targets.					*/
+#define DCYSUSV_DECAYTIME_MASK	0x0000007f	/* Volume envelope decay time, log encoded     		*/
+						/* 0 = 43.7msec, 1 = 21.8msec, 0x7f = 22msec		*/
+
+#define LFOVAL1 		0x13		/* Modulation LFO value					*/
+#define LFOVAL_MASK		0x0000ffff	/* Current value of modulation LFO state variable	*/
+						/* 0x8000-n == 666*n usec delay				*/
+
+#define ENVVAL			0x14		/* Modulation envelope register				*/
+#define ENVVAL_MASK		0x0000ffff	/* Current value of modulation envelope state variable 	*/
+						/* 0x8000-n == 666*n usec delay				*/
+
+#define ATKHLDM			0x15		/* Modulation envelope hold and attack register		*/
+#define ATKHLDM_PHASE0		0x00008000	/* 0 = Begin attack phase				*/
+#define ATKHLDM_HOLDTIME	0x00007f00	/* Envelope hold time (127-n == n*42msec)		*/
+#define ATKHLDM_ATTACKTIME	0x0000007f	/* Envelope attack time, log encoded			*/
+						/* 0 = infinite, 1 = 11msec, ... 0x7f = 5.5msec		*/
+
+#define DCYSUSM			0x16		/* Modulation envelope decay and sustain register	*/
+#define DCYSUSM_PHASE1_MASK	0x00008000	/* 0 = Begin attack phase, 1 = begin release phase	*/
+#define DCYSUSM_SUSTAINLEVEL_MASK 0x00007f00	/* 127 = full, 0 = off, 0.75dB increments		*/
+#define DCYSUSM_DECAYTIME_MASK	0x0000007f	/* Envelope decay time, log encoded			*/
+						/* 0 = 43.7msec, 1 = 21.8msec, 0x7f = 22msec		*/
+
+#define LFOVAL2 		0x17		/* Vibrato LFO register					*/
+#define LFOVAL2_MASK		0x0000ffff	/* Current value of vibrato LFO state variable 		*/
+						/* 0x8000-n == 666*n usec delay				*/
+
+#define IP			0x18		/* Initial pitch register				*/
+#define IP_MASK			0x0000ffff	/* Exponential initial pitch shift			*/
+						/* 4 bits of octave, 12 bits of fractional octave	*/
+#define IP_UNITY		0x0000e000	/* Unity pitch shift					*/
+
+#define IFATN			0x19		/* Initial filter cutoff and attenuation register	*/
+#define IFATN_FILTERCUTOFF_MASK	0x0000ff00	/* Initial filter cutoff frequency in exponential units	*/
+						/* 6 most significant bits are semitones		*/
+						/* 2 least significant bits are fractions		*/
+#define IFATN_FILTERCUTOFF	0x08080019
+#define IFATN_ATTENUATION_MASK	0x000000ff	/* Initial attenuation in 0.375dB steps			*/
+#define IFATN_ATTENUATION	0x08000019
+
+
+#define PEFE			0x1a		/* Pitch envelope and filter envelope amount register	*/
+#define PEFE_PITCHAMOUNT_MASK	0x0000ff00	/* Pitch envlope amount					*/
+						/* Signed 2's complement, +/- one octave peak extremes	*/
+#define PEFE_PITCHAMOUNT	0x0808001a
+#define PEFE_FILTERAMOUNT_MASK	0x000000ff	/* Filter envlope amount				*/
+						/* Signed 2's complement, +/- six octaves peak extremes */
+#define PEFE_FILTERAMOUNT	0x0800001a
+#define FMMOD			0x1b		/* Vibrato/filter modulation from LFO register		*/
+#define FMMOD_MODVIBRATO	0x0000ff00	/* Vibrato LFO modulation depth				*/
+						/* Signed 2's complement, +/- one octave extremes	*/
+#define FMMOD_MOFILTER		0x000000ff	/* Filter LFO modulation depth				*/
+						/* Signed 2's complement, +/- three octave extremes	*/
+
+
+#define TREMFRQ 		0x1c		/* Tremolo amount and modulation LFO frequency register	*/
+#define TREMFRQ_DEPTH		0x0000ff00	/* Tremolo depth					*/
+						/* Signed 2's complement, with +/- 12dB extremes	*/
+#define TREMFRQ_FREQUENCY	0x000000ff	/* Tremolo LFO frequency				*/
+						/* ??Hz steps, maximum of ?? Hz.			*/
+
+#define FM2FRQ2 		0x1d		/* Vibrato amount and vibrato LFO frequency register	*/
+#define FM2FRQ2_DEPTH		0x0000ff00	/* Vibrato LFO vibrato depth				*/
+						/* Signed 2's complement, +/- one octave extremes	*/
+#define FM2FRQ2_FREQUENCY	0x000000ff	/* Vibrato LFO frequency				*/
+						/* 0.039Hz steps, maximum of 9.85 Hz.			*/
+
+#define TEMPENV 		0x1e		/* Tempory envelope register				*/
+#define TEMPENV_MASK		0x0000ffff	/* 16-bit value						*/
+						/* NOTE: All channels contain internal variables; do	*/
+						/* not write to these locations.			*/
+
+#define CD0			0x20		/* Cache data 0 register				*/
+#define CD1			0x21		/* Cache data 1 register				*/
+#define CD2			0x22		/* Cache data 2 register				*/
+#define CD3			0x23		/* Cache data 3 register				*/
+#define CD4			0x24		/* Cache data 4 register				*/
+#define CD5			0x25		/* Cache data 5 register				*/
+#define CD6			0x26		/* Cache data 6 register				*/
+#define CD7			0x27		/* Cache data 7 register				*/
+#define CD8			0x28		/* Cache data 8 register				*/
+#define CD9			0x29		/* Cache data 9 register				*/
+#define CDA			0x2a		/* Cache data A register				*/
+#define CDB			0x2b		/* Cache data B register				*/
+#define CDC			0x2c		/* Cache data C register				*/
+#define CDD			0x2d		/* Cache data D register				*/
+#define CDE			0x2e		/* Cache data E register				*/
+#define CDF			0x2f		/* Cache data F register				*/
+
+#define PTB			0x40		/* Page table base register				*/
+#define PTB_MASK		0xfffff000	/* Physical address of the page table in host memory	*/
+
+#define TCB			0x41		/* Tank cache base register    				*/
+#define TCB_MASK		0xfffff000	/* Physical address of the bottom of host based TRAM	*/
+
+#define ADCCR			0x42		/* ADC sample rate/stereo control register		*/
+#define ADCCR_RCHANENABLE	0x00000010	/* Enables right channel for writing to the host       	*/
+#define ADCCR_LCHANENABLE	0x00000008	/* Enables left channel for writing to the host		*/
+						/* NOTE: To guarantee phase coherency, both channels	*/
+						/* must be disabled prior to enabling both channels.	*/
+#define A_ADCCR_RCHANENABLE	0x00000020
+#define A_ADCCR_LCHANENABLE	0x00000010
+
+#define A_ADCCR_SAMPLERATE_MASK 0x0000000F      /* Audigy sample rate convertor output rate		*/
+#define ADCCR_SAMPLERATE_MASK	0x00000007	/* Sample rate convertor output rate			*/
+
+#define ADCCR_SAMPLERATE_48	0x00000000	/* 48kHz sample rate					*/
+#define ADCCR_SAMPLERATE_44	0x00000001	/* 44.1kHz sample rate					*/
+#define ADCCR_SAMPLERATE_32	0x00000002	/* 32kHz sample rate					*/
+#define ADCCR_SAMPLERATE_24	0x00000003	/* 24kHz sample rate					*/
+#define ADCCR_SAMPLERATE_22	0x00000004	/* 22.05kHz sample rate					*/
+#define ADCCR_SAMPLERATE_16	0x00000005	/* 16kHz sample rate					*/
+#define ADCCR_SAMPLERATE_11	0x00000006	/* 11.025kHz sample rate				*/
+#define ADCCR_SAMPLERATE_8	0x00000007	/* 8kHz sample rate					*/
+
+#define A_ADCCR_SAMPLERATE_12	0x00000006	/* 12kHz sample rate					*/
+#define A_ADCCR_SAMPLERATE_11	0x00000007	/* 11.025kHz sample rate				*/
+#define A_ADCCR_SAMPLERATE_8	0x00000008	/* 8kHz sample rate					*/
+
+#define FXWC			0x43		/* FX output write channels register			*/
+						/* When set, each bit enables the writing of the	*/
+						/* corresponding FX output channel (internal registers  */
+						/* 0x20-0x3f) into host memory. This mode of recording	*/
+						/* is 16bit, 48KHz only. All 32	channels can be enabled */
+						/* simultaneously.					*/
+#define TCBS			0x44		/* Tank cache buffer size register			*/
+#define TCBS_MASK		0x00000007	/* Tank cache buffer size field				*/
+#define TCBS_BUFFSIZE_16K	0x00000000
+#define TCBS_BUFFSIZE_32K	0x00000001
+#define TCBS_BUFFSIZE_64K	0x00000002
+#define TCBS_BUFFSIZE_128K	0x00000003
+#define TCBS_BUFFSIZE_256K	0x00000004
+#define TCBS_BUFFSIZE_512K	0x00000005
+#define TCBS_BUFFSIZE_1024K	0x00000006
+#define TCBS_BUFFSIZE_2048K	0x00000007
+
+#define MICBA			0x45		/* AC97 microphone buffer address register		*/
+#define MICBA_MASK		0xfffff000	/* 20 bit base address					*/
+
+#define ADCBA			0x46		/* ADC buffer address register				*/
+#define ADCBA_MASK		0xfffff000	/* 20 bit base address					*/
+
+#define FXBA			0x47		/* FX Buffer Address */
+#define FXBA_MASK		0xfffff000	/* 20 bit base address					*/
+
+#define MICBS			0x49		/* Microphone buffer size register			*/
+
+#define ADCBS			0x4a		/* ADC buffer size register				*/
+
+#define FXBS			0x4b		/* FX buffer size register				*/
+
+/* The following mask values define the size of the ADC, MIX and FX buffers in bytes */
+#define ADCBS_BUFSIZE_NONE	0x00000000
+#define ADCBS_BUFSIZE_384	0x00000001
+#define ADCBS_BUFSIZE_448	0x00000002
+#define ADCBS_BUFSIZE_512	0x00000003
+#define ADCBS_BUFSIZE_640	0x00000004
+#define ADCBS_BUFSIZE_768	0x00000005
+#define ADCBS_BUFSIZE_896	0x00000006
+#define ADCBS_BUFSIZE_1024	0x00000007
+#define ADCBS_BUFSIZE_1280	0x00000008
+#define ADCBS_BUFSIZE_1536	0x00000009
+#define ADCBS_BUFSIZE_1792	0x0000000a
+#define ADCBS_BUFSIZE_2048	0x0000000b
+#define ADCBS_BUFSIZE_2560	0x0000000c
+#define ADCBS_BUFSIZE_3072	0x0000000d
+#define ADCBS_BUFSIZE_3584	0x0000000e
+#define ADCBS_BUFSIZE_4096	0x0000000f
+#define ADCBS_BUFSIZE_5120	0x00000010
+#define ADCBS_BUFSIZE_6144	0x00000011
+#define ADCBS_BUFSIZE_7168	0x00000012
+#define ADCBS_BUFSIZE_8192	0x00000013
+#define ADCBS_BUFSIZE_10240	0x00000014
+#define ADCBS_BUFSIZE_12288	0x00000015
+#define ADCBS_BUFSIZE_14366	0x00000016
+#define ADCBS_BUFSIZE_16384	0x00000017
+#define ADCBS_BUFSIZE_20480	0x00000018
+#define ADCBS_BUFSIZE_24576	0x00000019
+#define ADCBS_BUFSIZE_28672	0x0000001a
+#define ADCBS_BUFSIZE_32768	0x0000001b
+#define ADCBS_BUFSIZE_40960	0x0000001c
+#define ADCBS_BUFSIZE_49152	0x0000001d
+#define ADCBS_BUFSIZE_57344	0x0000001e
+#define ADCBS_BUFSIZE_65536	0x0000001f
+
+
+#define CDCS			0x50		/* CD-ROM digital channel status register	*/
+
+#define GPSCS			0x51		/* General Purpose SPDIF channel status register*/
+
+#define DBG			0x52		/* DO NOT PROGRAM THIS REGISTER!!! MAY DESTROY CHIP */
+
+/* definitions for debug register - taken from the alsa drivers */
+#define DBG_ZC                  0x80000000      /* zero tram counter */
+#define DBG_SATURATION_OCCURED  0x02000000      /* saturation control */
+#define DBG_SATURATION_ADDR     0x01ff0000      /* saturation address */
+#define DBG_SINGLE_STEP         0x00008000      /* single step mode */
+#define DBG_STEP                0x00004000      /* start single step */
+#define DBG_CONDITION_CODE      0x00003e00      /* condition code */
+#define DBG_SINGLE_STEP_ADDR    0x000001ff      /* single step address */
+
+
+#define REG53			0x53		/* DO NOT PROGRAM THIS REGISTER!!! MAY DESTROY CHIP */
+
+#define A_DBG			 0x53
+#define A_DBG_SINGLE_STEP	 0x00020000	/* Set to zero to start dsp */
+#define A_DBG_ZC		 0x40000000	/* zero tram counter */
+#define A_DBG_STEP_ADDR		 0x000003ff
+#define A_DBG_SATURATION_OCCURED 0x20000000
+#define A_DBG_SATURATION_ADDR	 0x0ffc0000
+
+#define SPCS0			0x54		/* SPDIF output Channel Status 0 register	*/
+
+#define SPCS1			0x55		/* SPDIF output Channel Status 1 register	*/
+
+#define SPCS2			0x56		/* SPDIF output Channel Status 2 register	*/
+
+#define SPCS_CLKACCYMASK	0x30000000	/* Clock accuracy				*/
+#define SPCS_CLKACCY_1000PPM	0x00000000	/* 1000 parts per million			*/
+#define SPCS_CLKACCY_50PPM	0x10000000	/* 50 parts per million				*/
+#define SPCS_CLKACCY_VARIABLE	0x20000000	/* Variable accuracy				*/
+#define SPCS_SAMPLERATEMASK	0x0f000000	/* Sample rate					*/
+#define SPCS_SAMPLERATE_44	0x00000000	/* 44.1kHz sample rate				*/
+#define SPCS_SAMPLERATE_48	0x02000000	/* 48kHz sample rate				*/
+#define SPCS_SAMPLERATE_32	0x03000000	/* 32kHz sample rate				*/
+#define SPCS_CHANNELNUMMASK	0x00f00000	/* Channel number				*/
+#define SPCS_CHANNELNUM_UNSPEC	0x00000000	/* Unspecified channel number			*/
+#define SPCS_CHANNELNUM_LEFT	0x00100000	/* Left channel					*/
+#define SPCS_CHANNELNUM_RIGHT	0x00200000	/* Right channel				*/
+#define SPCS_SOURCENUMMASK	0x000f0000	/* Source number				*/
+#define SPCS_SOURCENUM_UNSPEC	0x00000000	/* Unspecified source number			*/
+#define SPCS_GENERATIONSTATUS	0x00008000	/* Originality flag (see IEC-958 spec)		*/
+#define SPCS_CATEGORYCODEMASK	0x00007f00	/* Category code (see IEC-958 spec)		*/
+#define SPCS_MODEMASK		0x000000c0	/* Mode (see IEC-958 spec)			*/
+#define SPCS_EMPHASISMASK	0x00000038	/* Emphasis					*/
+#define SPCS_EMPHASIS_NONE	0x00000000	/* No emphasis					*/
+#define SPCS_EMPHASIS_50_15	0x00000008	/* 50/15 usec 2 channel				*/
+#define SPCS_COPYRIGHT		0x00000004	/* Copyright asserted flag -- do not modify	*/
+#define SPCS_NOTAUDIODATA	0x00000002	/* 0 = Digital audio, 1 = not audio		*/
+#define SPCS_PROFESSIONAL	0x00000001	/* 0 = Consumer (IEC-958), 1 = pro (AES3-1992)	*/
+
+/* The 32-bit CLIx and SOLx registers all have one bit per channel control/status      		*/
+#define CLIEL			0x58		/* Channel loop interrupt enable low register	*/
+
+#define CLIEH			0x59		/* Channel loop interrupt enable high register	*/
+
+#define CLIPL			0x5a		/* Channel loop interrupt pending low register	*/
+
+#define CLIPH			0x5b		/* Channel loop interrupt pending high register	*/
+
+#define SOLEL			0x5c		/* Stop on loop enable low register		*/
+
+#define SOLEH			0x5d		/* Stop on loop enable high register		*/
+
+#define SPBYPASS		0x5e		/* SPDIF BYPASS mode register			*/
+#define SPBYPASS_ENABLE		0x00000001	/* Enable SPDIF bypass mode			*/
+
+#define AC97SLOT		0x5f		/* additional AC97 slots enable bits */
+#define AC97SLOT_CNTR		0x10		/* Center enable */
+#define AC97SLOT_LFE		0x20		/* LFE enable */
+
+#define CDSRCS			0x60		/* CD-ROM Sample Rate Converter status register	*/
+
+#define GPSRCS			0x61		/* General Purpose SPDIF sample rate cvt status */
+
+#define ZVSRCS			0x62		/* ZVideo sample rate converter status		*/
+						/* NOTE: This one has no SPDIFLOCKED field	*/
+						/* Assumes sample lock				*/
+
+/* These three bitfields apply to CDSRCS, GPSRCS, and (except as noted) ZVSRCS.			*/
+#define SRCS_SPDIFLOCKED	0x02000000	/* SPDIF stream locked				*/
+#define SRCS_RATELOCKED		0x01000000	/* Sample rate locked				*/
+#define SRCS_ESTSAMPLERATE	0x0007ffff	/* Do not modify this field.			*/
+
+
+/* Note that these values can vary +/- by a small amount                                        */
+#define SRCS_SPDIFRATE_44	0x0003acd9
+#define SRCS_SPDIFRATE_48	0x00040000
+#define SRCS_SPDIFRATE_96	0x00080000
+
+#define MICIDX                  0x63            /* Microphone recording buffer index register   */
+#define MICIDX_MASK             0x0000ffff      /* 16-bit value                                 */
+#define MICIDX_IDX		0x10000063
+
+#define A_ADCIDX		0x63
+#define A_ADCIDX_IDX		0x10000063
+
+#define ADCIDX			0x64		/* ADC recording buffer index register		*/
+#define ADCIDX_MASK		0x0000ffff	/* 16 bit index field				*/
+#define ADCIDX_IDX		0x10000064
+
+#define FXIDX			0x65		/* FX recording buffer index register		*/
+#define FXIDX_MASK		0x0000ffff	/* 16-bit value					*/
+#define FXIDX_IDX		0x10000065
+
+/* This is the MPU port on the card (via the game port)						*/
+#define A_MUDATA1		0x70
+#define A_MUCMD1		0x71
+#define A_MUSTAT1		A_MUCMD1
+
+/* This is the MPU port on the Audigy Drive 							*/
+#define A_MUDATA2		0x72
+#define A_MUCMD2		0x73
+#define A_MUSTAT2		A_MUCMD2	
+
+/* The next two are the Audigy equivalent of FXWC						*/
+/* the Audigy can record any output (16bit, 48kHz, up to 64 channel simultaneously) 		*/
+/* Each bit selects a channel for recording */
+#define A_FXWC1			0x74            /* Selects 0x7f-0x60 for FX recording           */
+#define A_FXWC2			0x75		/* Selects 0x9f-0x80 for FX recording           */
+
+#define A_SPDIF_SAMPLERATE	0x76		/* Set the sample rate of SPDIF output		*/
+#define A_SPDIF_48000		0x00000080
+#define A_SPDIF_44100		0x00000000
+#define A_SPDIF_96000		0x00000040
+
+#define A_FXRT2			0x7c
+#define A_FXRT_CHANNELE		0x0000003f	/* Effects send bus number for channel's effects send E	*/
+#define A_FXRT_CHANNELF		0x00003f00	/* Effects send bus number for channel's effects send F	*/
+#define A_FXRT_CHANNELG		0x003f0000	/* Effects send bus number for channel's effects send G	*/
+#define A_FXRT_CHANNELH		0x3f000000	/* Effects send bus number for channel's effects send H	*/
+
+#define A_SENDAMOUNTS		0x7d
+#define A_FXSENDAMOUNT_E_MASK	0xff000000
+#define A_FXSENDAMOUNT_F_MASK	0x00ff0000
+#define A_FXSENDAMOUNT_G_MASK	0x0000ff00
+#define A_FXSENDAMOUNT_H_MASK	0x000000ff
+
+/* The send amounts for this one are the same as used with the emu10k1 */
+#define A_FXRT1			0x7e
+#define A_FXRT_CHANNELA		0x0000003f
+#define A_FXRT_CHANNELB		0x00003f00
+#define A_FXRT_CHANNELC		0x003f0000
+#define A_FXRT_CHANNELD		0x3f000000
+
+
+/* Each FX general purpose register is 32 bits in length, all bits are used			*/
+#define FXGPREGBASE		0x100		/* FX general purpose registers base       	*/
+#define A_FXGPREGBASE		0x400		/* Audigy GPRs, 0x400 to 0x5ff			*/
+/* Tank audio data is logarithmically compressed down to 16 bits before writing to TRAM and is	*/
+/* decompressed back to 20 bits on a read.  There are a total of 160 locations, the last 32	*/
+/* locations are for external TRAM. 								*/
+#define TANKMEMDATAREGBASE	0x200		/* Tank memory data registers base     		*/
+#define TANKMEMDATAREG_MASK	0x000fffff	/* 20 bit tank audio data field			*/
+
+/* Combined address field and memory opcode or flag field.  160 locations, last 32 are external	*/
+#define TANKMEMADDRREGBASE	0x300		/* Tank memory address registers base		*/
+#define TANKMEMADDRREG_ADDR_MASK 0x000fffff	/* 20 bit tank address field			*/
+#define TANKMEMADDRREG_CLEAR	0x00800000	/* Clear tank memory				*/
+#define TANKMEMADDRREG_ALIGN	0x00400000	/* Align read or write relative to tank access	*/
+#define TANKMEMADDRREG_WRITE	0x00200000	/* Write to tank memory				*/
+#define TANKMEMADDRREG_READ	0x00100000	/* Read from tank memory			*/
+
+#define MICROCODEBASE		0x400		/* Microcode data base address			*/
+
+/* Each DSP microcode instruction is mapped into 2 doublewords 					*/
+/* NOTE: When writing, always write the LO doubleword first.  Reads can be in either order.	*/
+#define LOWORD_OPX_MASK		0x000ffc00	/* Instruction operand X			*/
+#define LOWORD_OPY_MASK		0x000003ff	/* Instruction operand Y			*/
+#define HIWORD_OPCODE_MASK	0x00f00000	/* Instruction opcode				*/
+#define HIWORD_RESULT_MASK	0x000ffc00	/* Instruction result				*/
+#define HIWORD_OPA_MASK		0x000003ff	/* Instruction operand A			*/
+
+
+/* Audigy Soundcard have a different instruction format */
+#define AUDIGY_CODEBASE		0x600
+#define A_LOWORD_OPY_MASK	0x000007ff		
+#define A_LOWORD_OPX_MASK	0x007ff000
+#define A_HIWORD_OPCODE_MASK	0x0f000000
+#define A_HIWORD_RESULT_MASK	0x007ff000
+#define A_HIWORD_OPA_MASK	0x000007ff
+
+
+#endif /* _8010_H */
diff -Nurp -X /Data/dontdiff old/drivers/sound/Config.in patched/drivers/sound/Config.in
--- old/drivers/sound/Config.in	2003-08-02 15:39:26.000000000 +0300
+++ patched/drivers/sound/Config.in	2003-07-22 20:13:20.000000000 +0300
@@ -33,6 +33,7 @@ if [ "$CONFIG_SOUND_CMPCI" = "y" -o "$CO
 fi
 dep_tristate '  Creative SBLive! (EMU10K1)' CONFIG_SOUND_EMU10K1 $CONFIG_SOUND $CONFIG_PCI
 dep_mbool    '    Creative SBLive! MIDI' CONFIG_MIDI_EMU10K1 $CONFIG_SOUND_EMU10K1 $CONFIG_EXPERIMENTAL
+dep_tristate '  Creative SBLive! Audigy ' CONFIG_SOUND_AUDIGY $CONFIG_SOUND $CONFIG_PCI
 dep_tristate '  Crystal SoundFusion (CS4280/461x)' CONFIG_SOUND_FUSION $CONFIG_SOUND $CONFIG_PCI
 dep_tristate '  Crystal Sound CS4281' CONFIG_SOUND_CS4281 $CONFIG_SOUND $CONFIG_PCI
 if [ "$CONFIG_SIBYTE_SB1250" = "y" -a "$CONFIG_REMOTE_DEBUG" != "y" ]; then
diff -Nurp -X /Data/dontdiff old/drivers/sound/Makefile patched/drivers/sound/Makefile
--- old/drivers/sound/Makefile	2003-08-02 15:39:26.000000000 +0300
+++ patched/drivers/sound/Makefile	2003-07-22 20:13:09.000000000 +0300
@@ -77,6 +77,7 @@ obj-$(CONFIG_SOUND_FORTE)	+= forte.o ac9
 obj-$(CONFIG_SOUND_TRIDENT)	+= trident.o ac97_codec.o
 obj-$(CONFIG_SOUND_HARMONY)	+= harmony.o
 obj-$(CONFIG_SOUND_EMU10K1)	+= ac97_codec.o
+obj-$(CONFIG_SOUND_AUDIGY)	+= ac97_codec.o
 obj-$(CONFIG_SOUND_BCM_CS4297A)	+= swarm_cs4297a.o
 obj-$(CONFIG_SOUND_RME96XX)     += rme96xx.o
 obj-$(CONFIG_SOUND_BT878)	+= btaudio.o
@@ -87,12 +88,17 @@ ifeq ($(CONFIG_MIDI_EMU10K1),y)
 endif
 
 subdir-$(CONFIG_SOUND_EMU10K1) += emu10k1
+subdir-$(CONFIG_SOUND_AUDIGY) += audigy
 subdir-$(CONFIG_SOUND_CS4281) += cs4281
 
 ifeq ($(CONFIG_SOUND_EMU10K1),y)
   obj-y += emu10k1/emu10k1.o
 endif
 
+ifeq ($(CONFIG_SOUND_AUDIGY),y)
+  obj-y += audigy/audigy.o
+endif
+
 ifeq ($(CONFIG_SOUND_CS4281),y)
   obj-y += cs4281/cs4281.o
 endif
