diff -Naurb linux-2.4.21/3rdparty/lirc/Config.in linux-2.4.21-lirc_saa7134/3rdparty/lirc/Config.in
--- linux-2.4.21/3rdparty/lirc/Config.in	2002-11-07 18:45:02.000000000 +0100
+++ linux-2.4.21-lirc_saa7134/3rdparty/lirc/Config.in	2003-07-03 22:14:33.000000000 +0200
@@ -15,6 +15,7 @@
 	dep_tristate '  LIRC serial' CONFIG_LIRC_SERIAL $CONFIG_SERIAL
 	dep_tristate '  LIRC sir' CONFIG_LIRC_SIRCD $CONFIG_PARPORT
 	dep_tristate '  LIRC bt829' CONFIG_LIRC_BT829 $CONFIG_VIDEO_DEV
+	dep_tristate '  LIRC saa7134' CONFIG_LIRC_SAA7134 $CONFIG_SAA713X $CONFIG_VIDEO_DEV
 
 fi
 
diff -Naurb linux-2.4.21/3rdparty/lirc/lircd.conf.RM-050 linux-2.4.21-lirc_saa7134/3rdparty/lirc/lircd.conf.RM-050
--- linux-2.4.21/3rdparty/lirc/lircd.conf.RM-050	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.21-lirc_saa7134/3rdparty/lirc/lircd.conf.RM-050	2003-06-10 12:09:59.000000000 +0200
@@ -0,0 +1,63 @@
+
+# Please make this file available to others
+# by sending it to <lirc@bartelmus.de>
+#
+# this config file was automatically generated
+# using lirc-0.6.6(fly98) on Fri May  9 15:53:33 2003
+#
+# contributed by  David Atkinson
+#
+# brand: Lifeview (comes with LifeView FlyVideo 2000/3000 TV cards)
+# model no. of remote control: RM-050
+# devices being controlled by this remote:
+#   FlyVideo 2000
+#   FlyVideo 3000
+#
+# This remote appears to be somewhat compatible with those that come with
+# FlyVideo II/98 TV cards
+
+begin remote
+
+  name  RM-050
+  bits           16
+  eps            30
+  aeps          100
+
+  one             0     0
+  zero            0     0
+  pre_data_bits   26
+  pre_data        0x1A1F2F
+  gap             207740
+  toggle_bit      0
+
+
+      begin codes
+          POWER                    0x00000000000000FF
+          AIRCATV                  0x000000000000708F
+          VIDEO                    0x0000000000008877
+          AUDIO                    0x000000000000A857
+          AVSOURCE                 0x00000000000018E7
+          FULLSCREEN               0x00000000000040BF
+          STEREO                   0x00000000000058A7
+          MUTE                     0x000000000000D827
+          VOL_UP                   0x00000000000028D7
+          VOL_DOWN                 0x000000000000E817
+          CH_UP                    0x00000000000048B7
+          CH_DOWN                  0x000000000000C837
+          1                        0x000000000000C03F
+          2                        0x00000000000020DF
+          3                        0x000000000000A05F
+          4                        0x000000000000E01F
+          5                        0x00000000000010EF
+          6                        0x000000000000906F
+          7                        0x000000000000D02F
+          8                        0x00000000000030CF
+          9                        0x000000000000B04F
+          RECALL                   0x000000000000609F
+          0                        0x000000000000F00F
+          ENTER                    0x00000000000008F7
+      end codes
+
+end remote
+
+
diff -Naurb linux-2.4.21/3rdparty/lirc/lirc_dev.c linux-2.4.21-lirc_saa7134/3rdparty/lirc/lirc_dev.c
--- linux-2.4.21/3rdparty/lirc/lirc_dev.c	2003-07-04 10:54:41.000000000 +0200
+++ linux-2.4.21-lirc_saa7134/3rdparty/lirc/lirc_dev.c	2003-07-03 22:08:28.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * LIRC base driver
  * 
- * (L) by Artur Lipowski <alipowski@kki.net.pl>
+ * (L) by Artur Lipowski <alipowski@interia.pl>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -17,7 +17,7 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * $Id: lirc_dev.c,v 1.18 2001/12/12 20:26:01 ranty Exp $
+ * $Id: lirc_dev.c,v 1.22 2002/11/09 22:13:15 lirc Exp $
  *
  */
 
@@ -30,10 +30,10 @@
 #define LIRC_HAVE_DEVFS
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 4)
-#error "********************************************************"
-#error " Sorry, this driver needs kernel version 2.2.4 or higher"
-#error "********************************************************"
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
+#error "**********************************************************"
+#error " Sorry, this driver needs kernel version 2.2.18 or higher "
+#error "**********************************************************"
 #endif
 
 #include <linux/config.h>
@@ -87,6 +87,7 @@
 
 	int tpid;
 	struct semaphore *t_notify;
+	struct semaphore *t_notify2;
 	int shutdown;
 	long jiffies_to_wait;
 
@@ -118,6 +119,7 @@
 
 	ir->tpid = -1;
 	ir->t_notify = NULL;
+	ir->t_notify2 = NULL;
 	ir->shutdown = 0;
 	ir->jiffies_to_wait = 0;
 
@@ -202,7 +204,7 @@
 			} else {
 				interruptible_sleep_on(ir->p.get_queue(ir->p.data));
 			}
-			if (signal_pending(current)) {
+			if (ir->shutdown) {
 				break;
 			}
 			if (!add_to_buf(ir)) {
@@ -213,7 +215,11 @@
 			current->state = TASK_INTERRUPTIBLE;
 			schedule_timeout(HZ/2);
 		}
-	} while (!ir->shutdown && !signal_pending(current));
+	} while (!ir->shutdown);
+	
+	if (ir->t_notify2 != NULL) {
+		down(ir->t_notify2);
+	}
 	
 	ir->tpid = -1;
 	if (ir->t_notify != NULL) {
@@ -258,18 +264,26 @@
 		return -EBADRQC;
 	}
 
+	printk("lirc_dev: lirc_register_plugin:"
+	       "sample_rate: %d\n",p->sample_rate);
 	if (p->sample_rate) {
 		if (2 > p->sample_rate || 50 < p->sample_rate) {
 			printk("lirc_dev: lirc_register_plugin:"
 			       "sample_rate must be beetween 2 and 50!\n");
 			return -EBADRQC;
 		}
-	} else {
+	} else if (!p->fops) {
 		if (!p->get_queue) {
 			printk("lirc_dev: lirc_register_plugin:"
 			       "get_queue cannot be NULL!\n");
 			return -EBADRQC;
 		}
+	} else {
+		if (!p->fops->read || !p->fops->poll || !p->fops->ioctl) {
+			printk("lirc_dev: lirc_register_plugin:"
+			       "neither read, poll nor ioctl can be NULL!\n");
+			return -EBADRQC;
+		}
 	}
 
 	down_interruptible(&plugin_lock);
@@ -325,6 +339,7 @@
 					  &fops, NULL);
 #endif
 
+	if(p->sample_rate || p->get_queue) {
 	/* try to fire up polling thread */
 	ir->t_notify = &tn;
 	ir->tpid = kernel_thread(lirc_thread, (void*)ir, 0);
@@ -332,11 +347,13 @@
 		IRUNLOCK;
 		up(&plugin_lock);
 		printk("lirc_dev: lirc_register_plugin:"
-		       "cannot run poll thread for minor = %d\n", p->minor);
+			       "cannot run poll thread for minor = %d\n",
+			       p->minor);
 		return -ECHILD;
 	}
 	down(&tn);
 	ir->t_notify = NULL;
+	}
 	up(&plugin_lock);
 
 	MOD_INC_USE_COUNT;
@@ -354,6 +371,7 @@
 {
 	struct irctl *ir;
 	DECLARE_MUTEX_LOCKED(tn);
+	DECLARE_MUTEX_LOCKED(tn2);
 
 	if (minor < 0 || minor >= MAX_IRCTL_DEVICES) {
 		printk("lirc_dev: lirc_unregister_plugin:"
@@ -383,9 +401,23 @@
 	/* end up polling thread */
 	if (ir->tpid >= 0) {
 		ir->t_notify = &tn;
+		ir->t_notify2 = &tn2;
 		ir->shutdown = 1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		{
+			struct task_struct *p;
+			
+			p = find_task_by_pid(ir->tpid);
+			wake_up_process(p);
+		}
+#else
+		/* 2.2.x does not export wake_up_process() */
+		wake_up_interruptible(ir->p.get_queue(ir->p.data));
+#endif
+		up(&tn2);
 		down(&tn);
 		ir->t_notify = NULL;
+		ir->t_notify2 = NULL;
 	}
 
 	dprintk("lirc_dev: plugin %s unregistered from minor number = %d\n",
@@ -421,6 +453,10 @@
 
 	dprintk(LOGHEAD "open called\n", ir->p.name, ir->p.minor);
 
+	/* if the plugin has an open function use it instead */
+	if(ir->p.fops && ir->p.fops->open)
+		return ir->p.fops->open(inode, file);
+
 	down_interruptible(&plugin_lock);
 
 	if (ir->p.minor == NOPLUG) {
@@ -462,6 +498,10 @@
 
 	dprintk(LOGHEAD "close called\n", ir->p.name, ir->p.minor);
  
+	/* if the plugin has a close function use it instead */
+	if(ir->p.fops && ir->p.fops->release)
+		return ir->p.fops->release(inode, file);
+
 	down_interruptible(&plugin_lock);
 
 	--ir->open;
@@ -481,6 +521,10 @@
 
 	dprintk(LOGHEAD "poll called\n", ir->p.name, ir->p.minor);
 
+	/* if the plugin has a poll function use it instead */
+	if(ir->p.fops && ir->p.fops->poll)
+		return ir->p.fops->poll(file, wait);
+
 	if (!ir->in_buf) {
 		poll_wait(file, &ir->wait_poll, wait);
 	}
@@ -505,6 +549,10 @@
 	dprintk(LOGHEAD "poll called (%u)\n",
 		ir->p.name, ir->p.minor, cmd);
 
+	/* if the plugin has a ioctl function use it instead */
+	if(ir->p.fops && ir->p.fops->ioctl)
+		return ir->p.fops->ioctl(inode, file, cmd, arg);
+
 	if (ir->p.minor == NOPLUG) {
 		dprintk(LOGHEAD "ioctl result = -ENODEV\n",
 			ir->p.name, ir->p.minor);
@@ -555,6 +603,10 @@
 
 	dprintk(LOGHEAD "read called\n", ir->p.name, ir->p.minor);
 
+	/* if the plugin has a specific read function use it instead */
+	if(ir->p.fops && ir->p.fops->read)
+		return ir->p.fops->read(file, buffer, length, ppos);
+
 	if (ir->bytes_in_key != length) {
 		dprintk(LOGHEAD "read result = -EIO\n",
 			ir->p.name, ir->p.minor);
@@ -611,9 +663,24 @@
 	return ret ? -EFAULT : length;
 }
 
+static ssize_t irctl_write(struct file *file, const char *buffer,
+			   size_t length, loff_t * ppos)
+{
+	struct irctl *ir = &irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+
+	dprintk(LOGHEAD "read called\n", ir->p.name, ir->p.minor);
+
+	/* if the plugin has a specific read function use it instead */
+	if(ir->p.fops && ir->p.fops->write)
+		return ir->p.fops->write(file, buffer, length, ppos);
+
+	return -EINVAL;
+}
+
 
 static struct file_operations fops = {
 	read:    irctl_read, 
+	write:   irctl_write,
 	poll:    irctl_poll,
 	ioctl:   irctl_ioctl,
 	open:    irctl_open,
diff -Naurb linux-2.4.21/3rdparty/lirc/lirc_dev.h linux-2.4.21-lirc_saa7134/3rdparty/lirc/lirc_dev.h
--- linux-2.4.21/3rdparty/lirc/lirc_dev.h	2002-11-07 18:40:25.000000000 +0100
+++ linux-2.4.21-lirc_saa7134/3rdparty/lirc/lirc_dev.h	2003-07-03 22:08:28.000000000 +0200
@@ -1,21 +1,16 @@
 /*
  * LIRC base driver
  * 
- * (L) by Artur Lipowski <alipowski@kki.net.pl>
+ * (L) by Artur Lipowski <alipowski@interia.pl>
  *        This code is licensed under GNU GPL
  *
- * $Id: lirc_dev.h,v 1.3 2000/12/03 18:02:55 columbus Exp $
+ * $Id: lirc_dev.h,v 1.7 2002/11/19 20:22:06 ranty Exp $
  *
  */
 
 #ifndef _LINUX_LIRC_DEV_H
 #define _LINUX_LIRC_DEV_H
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
-/* comes with bttv */
-#include "../drivers/char/kcompat24.h"
-#endif
-
 #define MAX_IRCTL_DEVICES 2
 #define BUFLEN            16
 
@@ -25,11 +20,14 @@
      int minor;
      int code_length;
      int sample_rate;
+     unsigned long features;
      void* data;
      int (*get_key) (void* data, unsigned char* key, int key_no);
      wait_queue_head_t* (*get_queue) (void* data);
-     void (*set_use_inc) (void* data);
+     int (*set_use_inc) (void* data);
      void (*set_use_dec) (void* data);
+     int (*ioctl) (struct inode *,struct file *,unsigned int, unsigned long);
+     struct file_operations *fops;
 };
 /* name:
  * this string will be used for logs
@@ -72,6 +70,9 @@
  *
  * set_use_dec:
  * set_use_dec will be called after device is closed
+ *
+ * fops:
+ * file_operations for drivers which don't fit the current plugin model.
  */
 
 
diff -Naurb linux-2.4.21/3rdparty/lirc/lirc_saa7134.c linux-2.4.21-lirc_saa7134/3rdparty/lirc/lirc_saa7134.c
--- linux-2.4.21/3rdparty/lirc/lirc_saa7134.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.21-lirc_saa7134/3rdparty/lirc/lirc_saa7134.c	2003-07-03 22:13:28.000000000 +0200
@@ -0,0 +1,414 @@
+/*
+ * Remote control driver for saa7134 based TV-cards
+ * Key codes are obtained from the GPIO port
+ *
+ * By David Atkinson <px-gpio'AT'psykax.com>
+ *
+ * Heavily based on lirc_gpio.c (lirc driver for bttv-based tv cards)
+ * (L) by Artur Lipowski <alipowski@interia.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 4)
+#error "*******************************************************"
+#error "Sorry, this driver needs kernel version 2.2.4 or higher"
+#error "*******************************************************"
+#endif
+
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/sched.h>
+#include <linux/wrapper.h>
+#include <linux/errno.h>
+
+#include "../../drivers/media/video/saa7134.h"
+#include "lirc_dev.h"
+
+/*
+#if SAA7134_VERSION_CODE < KERNEL_VERSION(0,2,7)
+#error "*******************************************************"
+#error " Sorry, this driver needs saa7134 version 0.2.7 or     "
+#error " higher.                                               "
+#error "*******************************************************"
+#endif
+*/
+
+static int debug = 0;
+static int card = 0;
+static int minor = -1;
+static int board_id = SAA7134_BOARD_UNKNOWN;
+static unsigned long gpio_mask = 0;
+static unsigned long gpio_lock_mask = 0;
+static unsigned long gpio_xor_mask = 0;
+static unsigned int soft_gap = 0;
+static unsigned char sample_rate = 10;
+
+MODULE_PARM(debug,"i");
+MODULE_PARM(card,"i");
+MODULE_PARM(minor,"i");
+MODULE_PARM(gpio_mask,"l");
+MODULE_PARM(gpio_lock_mask,"l");
+MODULE_PARM(gpio_xor_mask,"l");
+MODULE_PARM(soft_gap,"i");
+MODULE_PARM(sample_rate,"b");
+MODULE_PARM(board_id,"i");
+
+#undef dprintk
+#define dprintk  if (debug) printk
+
+struct rcv_info {
+	int board_id;
+	unsigned long gpio_mask;
+	unsigned long gpio_lock_mask;
+	unsigned long gpio_xor_mask;
+	unsigned int soft_gap;
+	unsigned char sample_rate;
+	unsigned char code_length;
+};
+
+
+/* This can fix problems where holding a button down causes it to act as
+   seperate keypresses. sample_rate should be set to between 1x and 2x the
+   actual updating rate of the GPIO register. */
+#define POLLING_GLITCH_FIX 0
+
+static struct rcv_info rcv_infos[] = {
+	/* Code length for fly2k/3k a guess based on fly98 */
+	{ SAA7134_BOARD_FLYVIDEO2000,   0xEC00000, 0x0040000, 0x0040000, 0, 0, 42 },
+	{ SAA7134_BOARD_FLYVIDEO3000,   0xEC00000, 0x0040000, 0x0040000, 0, 0, 42 },
+	/* Cinergy 400 has some other input on pin 18 */
+	{ SAA7134_BOARD_CINERGY400,          0x3F, 0x0010000, 0x0010000, 0, 10,  0 }
+};
+
+static unsigned char code_length = 0;
+static unsigned char code_bytes = 1;
+
+#define MAX_BYTES 8
+
+#define SUCCESS 0
+#define LOGHEAD "lirc_saa7134 (%d): "
+
+/* how many bits GPIO value can be shifted right before processing
+ * it is computed from the value of gpio_mask_parameter
+ */
+static unsigned char gpio_pre_shift = 0;
+
+static inline int reverse(int data, int bits)
+{
+	int i;
+	int c;
+
+	for (c=0,i=0; i<bits; i++) {
+		c |= (((data & (1<<i)) ? 1:0)) << (bits-1-i);
+	}
+
+	return c;
+}
+
+static int build_key(unsigned long gpio_val, unsigned char codes[MAX_BYTES])
+{
+	unsigned long mask = gpio_mask;
+	unsigned char shift = 0;
+
+	dprintk(LOGHEAD "gpio_val is %lx\n",card,(unsigned long) gpio_val);
+
+	gpio_val ^= gpio_xor_mask;
+
+	if (gpio_lock_mask && (gpio_val & gpio_lock_mask)) {
+		return -EBUSY;
+	}
+
+	/* extract bits from "raw" GPIO value using gpio_mask */
+	codes[0] = 0;
+	gpio_val >>= gpio_pre_shift;
+	while (mask) {
+		if (mask & 1u) {
+			codes[0] |= ((gpio_val & 1u) << shift);
+			shift++;
+		}
+		mask >>= 1;
+		gpio_val >>= 1;
+	}
+
+	dprintk(LOGHEAD "extracted code is %lx\n",card,(unsigned long) codes[0]);
+
+	switch (board_id)
+	{
+	case SAA7134_BOARD_FLYVIDEO2000:
+	case SAA7134_BOARD_FLYVIDEO3000:
+		codes[0]=reverse(codes[0],5);
+		/* a guess based on fly98 - needs confirming */
+		codes[4]=codes[0]<<3;
+		codes[5]=((~codes[4])&0xff);
+		codes[0]=0x00;
+		codes[1]=0x1A;
+		codes[2]=0x1F;
+		codes[3]=0x2F;
+		break;
+	default:
+		break;
+	}
+
+	return SUCCESS;
+}
+
+static int get_key(void* data, unsigned char *key, int key_no)
+{
+	static unsigned long next_time = 0;
+	static unsigned char codes[MAX_BYTES];
+	unsigned long code = 0;
+	unsigned char cur_codes[MAX_BYTES];
+
+	if (key_no > 0)	{
+		if (code_bytes < 2 || key_no >= code_bytes) {
+			dprintk(LOGHEAD "something wrong in get_key\n",card);
+			return -EBADRQC;
+		}
+		*key = codes[key_no];
+		return SUCCESS;
+	}
+
+	if (saa7134_read_gpio(card, &code)) {
+		dprintk(LOGHEAD "cannot read GPIO\n",card);
+		return -EIO;
+	}
+
+	if (build_key(code, cur_codes)) {
+		return -EFAULT;
+	}
+
+	if (soft_gap) {
+		if (!memcmp(codes, cur_codes, code_bytes) &&
+		    jiffies < next_time) {
+			return -EAGAIN;
+		}
+		next_time = jiffies + soft_gap;
+	}
+
+#if POLLING_GLITCH_FIX
+	/* Allow for the occasional missing code */
+	if(memcmp(codes, cur_codes, code_bytes)) {
+		memcpy(codes, cur_codes, code_bytes);
+	}
+#else
+	memcpy(codes, cur_codes, code_bytes);
+#endif
+
+	*key = codes[0];
+
+	return SUCCESS;
+}
+
+static int set_use_inc(void* data)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static void set_use_dec(void* data)
+{
+	MOD_DEC_USE_COUNT;
+}
+
+static wait_queue_head_t* get_queue(void* data)
+{
+	return saa7134_get_gpio_queue(card);
+}
+
+static struct lirc_plugin plugin = {
+	name: "lirc_saa7134",
+	get_key: get_key,
+	get_queue: get_queue,
+	set_use_inc: set_use_inc,
+	set_use_dec: set_use_dec
+};
+
+/*
+ *
+ */
+int gpio_remote_init(void)
+{
+	int ret;
+	unsigned int mask;
+
+	/* "normalize" gpio_mask
+	 * this means shift it right until first bit is set
+	 */
+	while (!(gpio_mask & 1u)) {
+		gpio_pre_shift++;
+		gpio_mask >>= 1;
+	}
+
+	if (code_length) {
+		plugin.code_length = code_length;
+	} else {
+		/* calculate scan code length in bits if needed */
+		plugin.code_length = 1;
+		mask = gpio_mask >> 1;
+		while (mask) {
+			if (mask & 1u) {
+				plugin.code_length++;
+			}
+			mask >>= 1;
+		}
+	}
+
+	code_bytes = (plugin.code_length/8) + (plugin.code_length%8 ? 1 : 0);
+	if (MAX_BYTES < code_bytes) {
+		printk (LOGHEAD "scan code too long (%d bytes)\n",
+			minor, code_bytes);
+		return -EBADRQC;
+	}
+
+	/* translate ms to jiffies */
+	soft_gap = (soft_gap*HZ) / 1000;
+
+	plugin.minor = minor;
+	plugin.sample_rate = sample_rate;
+
+	ret = lirc_register_plugin(&plugin);
+
+	if (0 > ret) {
+		printk (LOGHEAD "device registration failed with %d\n",
+			minor, ret);
+		return ret;
+	}
+
+	minor = ret;
+	printk(LOGHEAD "driver registered\n", minor);
+
+	return SUCCESS;
+}
+
+EXPORT_NO_SYMBOLS;
+
+/* Dont try to use it as a static version !  */
+
+#ifdef MODULE
+MODULE_DESCRIPTION("Driver module for remote control (data from saa7134 GPIO port)");
+MODULE_AUTHOR("Artur Lipowski");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+
+/*
+ *
+ */
+int init_module(void)
+{
+	int reserved, rcv_index;
+
+	if (MAX_IRCTL_DEVICES < minor) {
+		printk("lirc_saa7134: parameter minor (%d) must be less than %d!\n",
+		       minor, MAX_IRCTL_DEVICES-1);
+		return -EBADRQC;
+	}
+
+	request_module("saa7134");
+
+	/* if gpio_mask not zero then use module parameters
+	 * instead of autodetecting TV card
+	 */
+	if(gpio_mask) {
+		if (sample_rate!=0 && (2 > sample_rate || 50 < sample_rate)) {
+			printk(LOGHEAD "parameter sample_rate "
+			       "must be beetween 2 and 50!\n", minor);
+			return -EBADRQC;
+		}
+
+		if (sample_rate!=0 && soft_gap &&
+		    ((2000/sample_rate) > soft_gap || 1000 < soft_gap)) {
+			printk(LOGHEAD "parameter soft_gap "
+			       "must be beetween %d and 1000!\n",
+			       minor, 2000/sample_rate);
+			return -EBADRQC;
+		}
+	} else {
+		if(saa7134_get_cardinfo(card,&board_id,&reserved)==-1) {
+			printk(LOGHEAD "could not get TV card information\n", minor);
+		}
+
+		printk(LOGHEAD "card saa7134[%u] type %u\n",minor,card,board_id);
+
+		if (board_id == SAA7134_BOARD_UNKNOWN) {
+			printk(LOGHEAD "cannot detect TV card %d\n",
+				minor,card);
+			return -EBADRQC;
+		}
+
+		for (rcv_index = 0;
+		     rcv_index < sizeof(rcv_infos)/sizeof(struct rcv_info);
+		     rcv_index++) {
+			if (rcv_infos[rcv_index].board_id == board_id) {
+				gpio_mask = rcv_infos[rcv_index].gpio_mask;
+				gpio_lock_mask = rcv_infos[rcv_index].gpio_lock_mask;
+				gpio_xor_mask = rcv_infos[rcv_index].gpio_xor_mask;
+				soft_gap = rcv_infos[rcv_index].soft_gap;
+				sample_rate = rcv_infos[rcv_index].sample_rate;
+				code_length = rcv_infos[rcv_index].code_length;
+				break;
+			}
+		}
+		if (rcv_index == sizeof(rcv_infos)/sizeof(struct rcv_info)) {
+			printk(LOGHEAD "TV board type %u not supported!\n", minor, board_id);
+			return -EBADRQC;
+		}
+	}
+
+	request_module("lirc_dev");
+
+	return gpio_remote_init();
+}
+
+/*
+ *
+ */
+void cleanup_module(void)
+{
+	int ret;
+
+	ret = lirc_unregister_plugin(minor);
+
+	if (0 > ret) {
+		printk(LOGHEAD "error in lirc_unregister_minor: %d\n"
+		       "Trying again...\n",
+		       minor, ret);
+
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(HZ);
+
+		ret = lirc_unregister_plugin(minor);
+
+		if (0 > ret) {
+			printk(LOGHEAD "error in lirc_unregister_minor: %d!!!\n",
+			       minor, ret);
+			return;
+		}
+	}
+
+	dprintk(LOGHEAD "module successfully unloaded\n", minor);
+}
+#endif
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -Naurb linux-2.4.21/3rdparty/lirc/Makefile linux-2.4.21-lirc_saa7134/3rdparty/lirc/Makefile
--- linux-2.4.21/3rdparty/lirc/Makefile	2002-11-14 20:22:33.000000000 +0100
+++ linux-2.4.21-lirc_saa7134/3rdparty/lirc/Makefile	2003-07-03 22:15:21.000000000 +0200
@@ -13,6 +13,7 @@
 obj-$(CONFIG_LIRC_SERIAL)	+= lirc_serial.o
 obj-$(CONFIG_LIRC_SIR)	+= lirc_sir.o
 obj-$(CONFIG_LIRC_BT829)	+= lirc_bt829.o
+obj-$(CONFIG_LIRC_SAA7134)	+= lirc_saa7134.o
 
 include $(TOPDIR)/Rules.make
 
