--- cdrtools-2.01/cdrecord/drv_mmc.c.dvd	2003-05-12 01:17:00.000000000 +0200
+++ cdrtools-2.01/cdrecord/drv_mmc.c	2003-06-23 18:35:12.000000000 +0200
@@ -84,8 +84,11 @@
 EXPORT	char	*hasdrvopt		__PR((char *optstr, char *optname));
 LOCAL	cdr_t	*identify_mmc		__PR((SCSI *scgp, cdr_t *, struct scsi_inquiry *));
 LOCAL	int	attach_mmc		__PR((SCSI *scgp, cdr_t *));
+LOCAL   int     attach_mdvd             __PR((SCSI *scgp, cdr_t *));
 EXPORT	int	check_writemodes_mmc	__PR((SCSI *scgp, cdr_t *dp));
+EXPORT  int     check_writemodes_mdvd   __PR((SCSI *scgp, cdr_t *dp));
 LOCAL	int	deflt_writemodes_mmc	__PR((SCSI *scgp, BOOL reset_dummy));
+LOCAL   int     deflt_writemodes_mdvd   __PR((SCSI *scgp, BOOL reset_dummy));
 LOCAL	int	get_diskinfo		__PR((SCSI *scgp, struct disk_info *dip));
 LOCAL	void	di_to_dstat		__PR((struct disk_info *dip, dstat_t *dsp));
 LOCAL	int	get_atip		__PR((SCSI *scgp, struct atipinfo *atp));
@@ -94,18 +97,26 @@
 #endif
 LOCAL	int	init_mmc		__PR((SCSI *scgp, cdr_t *dp));
 LOCAL	int	getdisktype_mmc		__PR((SCSI *scgp, cdr_t *dp));
+LOCAL   int     getdisktype_mdvd        __PR((SCSI *scgp, cdr_t *dp));
 LOCAL	int	speed_select_mmc	__PR((SCSI *scgp, cdr_t *dp, int *speedp));
+LOCAL   int     speed_select_mdvd       __PR((SCSI *scgp, cdr_t *dp, int *speedp));
 LOCAL	int	mmc_set_speed		__PR((SCSI *scgp, int readspeed, int writespeed, int rotctl));
 LOCAL	int	next_wr_addr_mmc	__PR((SCSI *scgp, track_t *trackp, long *ap));
+LOCAL   int     next_wr_addr_mdvd       __PR((SCSI *scgp, track_t *trackp, long *ap));
 LOCAL	int	write_leadin_mmc	__PR((SCSI *scgp, cdr_t *dp, track_t *trackp));
 LOCAL	int	open_track_mmc		__PR((SCSI *scgp, cdr_t *dp, track_t *trackp));
+LOCAL   int     open_track_mdvd         __PR((SCSI *scgp, cdr_t *dp, track_t *trackp));
 LOCAL	int	close_track_mmc		__PR((SCSI *scgp, cdr_t *dp, track_t *trackp));
+LOCAL   int     close_track_mdvd        __PR((SCSI *scgp, cdr_t *dp, track_t *trackp)); 
 LOCAL	int	open_session_mmc	__PR((SCSI *scgp, cdr_t *dp, track_t *trackp));
+LOCAL   int     open_session_mdvd       __PR((SCSI *scgp, cdr_t *dp, track_t *trackp));
 LOCAL	int	waitfix_mmc		__PR((SCSI *scgp, int secs));
 LOCAL	int	fixate_mmc		__PR((SCSI *scgp, cdr_t *dp, track_t *trackp));
+LOCAL   int     fixate_mdvd             __PR((SCSI *scgp, cdr_t *dp, track_t *trackp));
 LOCAL	int	blank_mmc		__PR((SCSI *scgp, cdr_t *dp, long addr, int blanktype));
 LOCAL	int	send_opc_mmc		__PR((SCSI *scgp, caddr_t, int cnt, int doopc));
 LOCAL	int	opt1_mmc		__PR((SCSI *scgp, cdr_t *dp));
+LOCAL	int	opt1_mdvd		__PR((SCSI *scgp, cdr_t *dp));
 LOCAL	int	opt2_mmc		__PR((SCSI *scgp, cdr_t *dp));
 LOCAL	int	scsi_sony_write		__PR((SCSI *scgp, caddr_t bp, long sectaddr, long size, int blocks, BOOL islast));
 LOCAL	int	gen_cue_mmc		__PR((track_t *trackp, void *vcuep, BOOL needgap));
@@ -197,6 +208,46 @@
 	opt2_mmc,
 };
 
+cdr_t   cdr_mdvd = {
+         0, 0,
+         CDR_SWABAUDIO,
+ 	 370,370,
+         "mmc_mdvd",
+         "generic SCSI-3/mmc DVD-R(W) driver",
+         0,
+ 	 (dstat_t *)0,
+         identify_mmc,
+         attach_mdvd,
+	 init_mmc,
+         getdisktype_mdvd,
+         scsi_load,
+         scsi_unload,
+         read_buff_cap,
+         cmd_dummy,                              /* recovery_needed      */
+         (int(*)__PR((SCSI *, int)))cmd_dummy,   /* recover              */
+         speed_select_mdvd,
+         select_secsize,
+         next_wr_addr_mdvd,
+         (int(*)__PR((SCSI *, Ulong)))cmd_ill,   /* reserve_track        */
+         scsi_cdr_write,
+         (int(*)__PR((SCSI *scgp, int, track_t *)))cmd_dummy, /* gen_cue */
+	 (int(*)__PR((SCSI *scgp, cdr_t *, track_t *)))cmd_dummy, /* send_cue */
+ 	 write_leadin_mmc,
+         open_track_mdvd,
+         close_track_mdvd,
+         open_session_mdvd,
+         cmd_dummy,
+	 cmd_dummy,					/* abort	*/
+         read_session_offset,
+         fixate_mdvd,
+ 	 stats_mmc,
+         blank_mmc,
+	 format_dummy,
+         send_opc_mmc,
+ 	 opt1_mdvd,
+ 	 opt2_mmc,
+};
+
 /*
  * Sony MMC CD-writer
  */
@@ -651,10 +702,9 @@
 #endif
 	}
 	if (is_dvd) {
-		errmsgno(EX_BAD,
-		"Found DVD media but DVD-R/DVD-RW support code is missing.\n");
-		errmsgno(EX_BAD,
-		"If you need DVD-R/DVD-RW support, ask the Author for cdrecord-ProDVD.\n");
+	        errmsgno(EX_BAD, 
+                "Found DVD media: using cdr_mdvd.\n");  
+                dp = &cdr_mdvd; 
 	}
 	return (dp);
 }
@@ -668,6 +718,9 @@
 	struct	cd_mode_page_2A *mp;
 	struct	ricoh_mode_page_30 *rp = NULL;
 
+	Uchar fd[0x100]; 
+	get_configuration(scgp, fd, 0x100, 0x21, 0); 
+
 	allow_atapi(scgp, TRUE);/* Try to switch to 10 byte mode cmds */
 
 	scgp->silent++;
@@ -844,6 +897,42 @@
 	return (0);
 }
 
+LOCAL int
+attach_mdvd(scgp, dp)
+        SCSI    *scgp;
+        cdr_t                   *dp;
+{
+        struct  cd_mode_page_2A *mp;
+	
+
+        allow_atapi(scgp, TRUE);/* Try to switch to 10 byte mode cmds */
+
+        scgp->silent++;
+        mp = mmc_cap(scgp, NULL);/* Get MMC capabilities in allocated mp */
+        scgp->silent--;
+        if (mp == NULL)
+                return (-1);    /* Pre SCSI-3/mmc drive         */
+
+        dp->cdr_cdcap = mp;     /* Store MMC cap pointer        */
+
+        if (mp->loading_type == LT_TRAY)
+                dp->cdr_flags |= CDR_TRAYLOAD;
+        else if (mp->loading_type == LT_CADDY)
+                dp->cdr_flags |= CDR_CADDYLOAD;
+
+        if (mp->BUF != 0)
+                dp->cdr_flags |= CDR_BURNFREE;
+
+        check_writemodes_mdvd(scgp, dp);
+
+        if (driveropts != NULL) {
+                if (strcmp(driveropts, "help") == 0) {
+                        mmc_opthelp(dp, 0);
+                }
+        }
+
+        return (0);
+}
 
 EXPORT int
 check_writemodes_mmc(scgp, dp)
@@ -995,6 +1084,77 @@
 }
 
 LOCAL int
+check_writemodes_mdvd(scgp, dp)
+	SCSI	*scgp;
+	cdr_t	*dp;
+{
+	Uchar	mode[0x100];
+	int	len;
+	struct	cd_mode_page_05 *mp;
+
+	if (xdebug)
+		printf("Checking possible write modes: ");
+
+	deflt_writemodes_mdvd(scgp, FALSE);
+
+	fillbytes((caddr_t)mode, sizeof(mode), '\0');
+
+	scgp->silent++;
+	if (!get_mode_params(scgp, 0x05, "CD write parameter",
+			mode, (Uchar *)0, (Uchar *)0, (Uchar *)0, &len)) {
+		scgp->silent--;
+		return (-1);
+	}
+	if (len == 0) {
+		scgp->silent--;
+		return (-1);
+	}
+
+	mp = (struct cd_mode_page_05 *)
+		(mode + sizeof(struct scsi_mode_header) +
+		((struct scsi_mode_header *)mode)->blockdesc_len);
+
+	mp->test_write = 0;
+
+	/*We only check for PACKET and SAO since these are the only supported modes for DVD */
+	/*XXX these checks are irrelevant because they are not medium sensitive. ie the device returns 
+	  error only when it does not support a given mode for ALL mediums. It should check using 
+	  GET CONFIGURATION command.*/
+
+	mp->write_type = WT_PACKET;
+	mp->fp = 0;
+	i_to_4_byte(mp->packet_size, 0);
+
+	if (set_mode_params(scgp, "CD write parameter", mode, len, 0, -1)) {
+		dp->cdr_flags |= CDR_PACKET;
+		if (xdebug)
+		  printf("PACKET ");
+	} else
+	  dp->cdr_flags &= ~CDR_PACKET;
+	mp->fp = 0;
+	i_to_4_byte(mp->packet_size, 0);
+	mp->track_mode = TM_DATA; 
+
+
+	mp->write_type = WT_SAO;
+
+	if (set_mode_params(scgp, "CD write parameter", mode, len, 0, -1)) {
+		dp->cdr_flags |= CDR_SAO;
+		if (xdebug)
+			printf("SAO ");
+	} else
+		dp->cdr_flags &= ~CDR_SAO;
+
+
+	if (xdebug)
+		printf("\n");
+
+	deflt_writemodes_mdvd(scgp, TRUE);
+	scgp->silent--;
+	return (0);
+}
+
+LOCAL int
 deflt_writemodes_mmc(scgp, reset_dummy)
 	SCSI	*scgp;
 	BOOL	reset_dummy;
@@ -1068,6 +1228,61 @@
 	return (0);
 }
 
+LOCAL int
+deflt_writemodes_mdvd(scgp, reset_dummy)
+	SCSI	*scgp;
+	BOOL	reset_dummy;
+{
+	Uchar	mode[0x100];
+	int	len;
+	struct	cd_mode_page_05 *mp;
+
+	fillbytes((caddr_t)mode, sizeof(mode), '\0');
+
+	scgp->silent++;
+	if (!get_mode_params(scgp, 0x05, "DVD write parameter",
+			mode, (Uchar *)0, (Uchar *)0, (Uchar *)0, &len)) {
+		scgp->silent--;
+		return (-1);
+	}
+	if (len == 0) {
+		scgp->silent--;
+		return (-1);
+	}
+
+	mp = (struct cd_mode_page_05 *)
+		(mode + sizeof(struct scsi_mode_header) +
+		((struct scsi_mode_header *)mode)->blockdesc_len);
+
+	mp->test_write = 0;
+	/*
+	 * This is the only place where we reset mp->test_write (-dummy)
+	 */
+	if (reset_dummy)
+		mp->test_write = 0;
+
+
+	/*
+	 * Set default values:
+	 * Write type = 02 (session at once)
+	 *
+	 * XXX Note:	the same code appears in check_writemodes_mmc() and
+	 * XXX		in speed_select_mmc().
+	 */
+	mp->write_type = WT_SAO;
+	mp->track_mode = TM_DATA; 
+	mp->dbtype = DB_ROM_MODE1;
+	mp->session_format = SES_DA_ROM;
+
+
+	if (set_mode_params(scgp, "DVD write parameter", mode, len, 0, -1) < 0) {
+		scgp->silent--;
+		return (-1);
+	}
+	scgp->silent--;
+	return (0);
+}
+
 #ifdef	PRINT_ATIP
 LOCAL	void	print_di		__PR((struct disk_info *dip));
 LOCAL	void	atip_printspeed		__PR((char *fmt, int speedindex, char speedtab[]));
@@ -1137,6 +1352,9 @@
 
 	if (dsp->ds_last_leadout == 0 && dsp->ds_maxblocks >= 0)
 		dsp->ds_last_leadout = dsp->ds_maxblocks;
+	dsp->ds_trfirst=dip->first_track; 
+	dsp->ds_trlast=dip->last_track_ls;
+	dsp->ds_trfirst_ls=dip->first_track_ls;
 }
 
 LOCAL int
@@ -1247,6 +1465,30 @@
 }
 
 LOCAL int
+getdisktype_mdvd(scgp, dp)
+	SCSI	*scgp;
+	cdr_t	*dp;
+{
+       int ret;
+       dstat_t	*dsp = dp->cdr_dstat;
+
+       struct track_info track_info;
+       if(getdisktype_mmc(scgp, dp)<0)
+	 return -1;
+
+       /* read rzone info to get the space left on disk */
+       /*ds_trlast is the last rzone on disk, can be invisible */
+       if(read_rzone_info(scgp, (caddr_t)&track_info, sizeof(track_info))>=0)
+	  dsp->ds_maxblocks=a_to_u_4_byte(track_info.free_blocks)+a_to_4_byte(track_info.next_writable_addr);
+       
+       dsp->ds_disktype&= ~DT_CD;
+       dsp->ds_disktype|= DT_DVD;
+	
+       return (ret);
+  
+}
+
+LOCAL int
 getdisktype_mmc(scgp, dp)
 	SCSI	*scgp;
 	cdr_t	*dp;
@@ -1750,6 +1992,26 @@
 }
 
 LOCAL int
+speed_select_mdvd(scgp, dp, speedp)
+	SCSI	*scgp;
+	cdr_t   *dp;
+	int	*speedp;
+{
+  int retcode;
+  /* For the moment we just divide the CD speed by 7*/
+
+  if(speedp!=NULL)
+     (*speedp)=(*speedp)*8;
+  
+  retcode=speed_select_mmc(scgp,dp,speedp);
+
+  if(speedp!=NULL)
+     (*speedp)=(*speedp)/7;
+   return retcode;
+ 
+}
+
+LOCAL int
 next_wr_addr_mmc(scgp, trackp, ap)
 	SCSI	*scgp;
 	track_t	*trackp;
@@ -1886,6 +2148,48 @@
 };
 
 LOCAL int
+next_wr_addr_mdvd(scgp, trackp, ap)
+	SCSI	*scgp;
+	track_t	*trackp;
+	long	*ap;
+{
+	int     track;
+	struct	track_info	track_info;
+	long	next_addr;
+	int	result = -1;
+	struct  disk_info disk_info;
+	if (trackp){
+	    track = trackp->trackno;
+	}
+
+	if (trackp != 0 && track > 0 && is_packet(trackp)) {
+		scgp->silent++;
+		result = read_rzone_info(scgp, (caddr_t)&track_info, sizeof(track_info));
+		scgp->silent--;
+		if (scsi_in_progress(scgp)){
+		  return -1;
+		}
+		
+	}
+
+	if (result < 0) {
+	  /* Get the last rzone*/
+	        if(read_disk_info(scgp,(caddr_t)&disk_info,8)<0)
+		  return (-1);
+	     
+		if (read_rzone_info(scgp, (caddr_t)&track_info, sizeof(track_info)) < 0)
+		return (-1);
+	}
+	if (scgp->verbose)
+		scg_prbytes("track info:", (Uchar *)&track_info,
+				sizeof(track_info)-scg_getresid(scgp));
+	next_addr = a_to_4_byte(track_info.next_writable_addr);
+	if (ap)
+		*ap = next_addr;
+	return (0);
+}
+
+LOCAL int
 open_track_mmc(scgp, dp, trackp)
 	SCSI	*scgp;
 	cdr_t	*dp;
@@ -1966,6 +2270,45 @@
 }
 
 LOCAL int
+open_track_mdvd(scgp, dp, trackp)
+	SCSI	*scgp;
+	cdr_t	*dp;
+	track_t *trackp;
+{
+	Uchar	mode[0x100];
+	int	len;
+	struct	cd_mode_page_05 *mp;
+
+	if (is_packet(trackp)) {
+	       fillbytes((caddr_t)mode, sizeof(mode), '\0');
+	  
+	       if (!get_mode_params(scgp, 0x05, "DVD write parameter",
+			mode, (Uchar *)0, (Uchar *)0, (Uchar *)0, &len))
+	              return (-1);
+	       if (len == 0)
+		      return (-1);
+
+	        mp = (struct cd_mode_page_05 *)
+	              (mode + sizeof(struct scsi_mode_header) +
+		      ((struct scsi_mode_header *)mode)->blockdesc_len);
+
+		mp->write_type = WT_PACKET;
+		mp->LS_V = 1;
+		/*For now we set the link size to 0x10(32k) because Pioneer-A03 only support this */
+		mp->link_size=0x10;
+		mp->fp = 1;
+		i_to_4_byte(mp->packet_size, trackp->pktsize);
+	} else {
+	     return 0;
+	}
+ 
+	if (!set_mode_params(scgp, "CD write parameter", mode, len, 0, trackp->secsize))
+		return (-1);
+
+	return (0);
+}
+
+LOCAL int
 close_track_mmc(scgp, dp, trackp)
 	SCSI	*scgp;
 	cdr_t	*dp;
@@ -1991,6 +2334,30 @@
 	return (0);
 }
 
+LOCAL int
+close_track_mdvd(scgp, dp, trackp)
+	SCSI	*scgp;
+	cdr_t	*dp;
+	track_t	*trackp;
+{
+	int	ret;
+	if (!is_packet(trackp))
+	     return (0);
+
+	if (scsi_flush_cache(scgp, (dp->cdr_cmdflags&F_IMMED) != 0) < 0) {
+		printf("Trouble flushing the cache\n");
+		return -1;
+	}
+	wait_unit_ready(scgp, 300);		/* XXX Wait for ATAPI */
+	if (is_packet(trackp) && !is_noclose(trackp)) {
+			/* close the incomplete track */
+		ret = scsi_close_tr_session(scgp, 1, 0xFF, (dp->cdr_cmdflags&F_IMMED) != 0);
+		wait_unit_ready(scgp, 300);	/* XXX Wait for ATAPI */
+		return (ret);
+	}
+	return (0);
+}
+
 int	toc2sess[] = {
 	SES_DA_ROM,	/* CD-DA		 */
 	SES_DA_ROM,	/* CD-ROM		 */
@@ -2074,6 +2441,80 @@
 }
 
 LOCAL int
+open_session_mdvd(scgp, dp, trackp)
+	SCSI	*scgp;
+	cdr_t	*dp;
+	track_t	*trackp;
+{
+	Uchar	mode[0x100];
+	int	tracks = trackp->tracks;
+
+	int	len;
+	struct	cd_mode_page_05 *mp;
+	Ulong totalsize;
+	int i;
+	struct	track_info	track_info;
+
+	fillbytes((caddr_t)mode, sizeof(mode), '\0');
+
+	if (!get_mode_params(scgp, 0x05, "DVD write parameter",
+			mode, (Uchar *)0, (Uchar *)0, (Uchar *)0, &len))
+		return (-1);
+	if (len == 0)
+		return (-1);
+
+	mp = (struct cd_mode_page_05 *)
+		(mode + sizeof(struct scsi_mode_header) +
+		((struct scsi_mode_header *)mode)->blockdesc_len);
+	if(is_packet(trackp)){
+	  mp->write_type=WT_PACKET;
+	  mp->multi_session = (track_base(trackp)->tracktype & TOCF_MULTI) ? MS_MULTI : MS_NONE;
+	  mp->fp=0;
+	  mp->BUFE=1;
+	  mp->track_mode=1;
+	}else{
+	  mp->write_type = WT_SAO; 
+	}
+
+	
+	if (lverbose && dp->cdr_cdcap->BUF != 0)
+		printf("BURN-Free is %s.\n", mp->BUFE?"ON":"OFF");
+	if (driveropts != NULL) {
+		if ((strcmp(driveropts, "burnproof") == 0 ||
+		    strcmp(driveropts, "burnfree") == 0) && dp->cdr_cdcap->BUF != 0) {
+			errmsgno(EX_BAD, "Turning BURN-Free on\n");
+			mp->BUFE = 1;
+		} else if ((strcmp(driveropts, "noburnproof") == 0 ||
+			   strcmp(driveropts, "noburnfree") == 0)) {
+			errmsgno(EX_BAD, "Turning BURN-Free off\n");
+			mp->BUFE = 0;
+		} else if (strcmp(driveropts, "help") == 0) {
+			mmc_opthelp(dp, 0);
+		} else {
+			errmsgno(EX_BAD, "Bad driver opts '%s'.\n", driveropts);
+			mmc_opthelp(dp, EX_BAD);
+		}
+	}
+
+
+	if (!set_mode_params(scgp, "DVD write parameter", mode, len, 0, -1))
+		return (-1);
+
+		
+	totalsize=0;
+	for(i=1;i<=tracks;i++) {
+	  totalsize+=trackp[i].tracksecs;
+	}
+       
+	if(!is_packet(trackp)){
+	  /* in DAO mode we need to reserve space for the track*/
+	  if(reserve_track(scgp, totalsize)<0)
+	    return (-1);
+	  }
+	return (0);
+}
+
+LOCAL int
 waitfix_mmc(scgp, secs)
 	SCSI	*scgp;
 	int	secs;
@@ -2203,6 +2644,25 @@
 	return (ret);
 }
 
+LOCAL int
+fixate_mdvd(scgp, dp, trackp)
+	SCSI	*scgp;
+	cdr_t   *dp;
+	track_t	*trackp;
+{
+      /*set a really BIG timeout and call fixate_mmc
+	 The BIG timeout is needed in case there was a very short rzone to write at the 
+	 beginning of the disk, because lead-out needs to be at some distance.
+      */
+      scg_settimeout(scgp, 1000);
+      if(is_packet(trackp)){
+	  scsi_close_tr_session(scgp, 2, 0, FALSE);
+      }
+      fixate_mmc(scgp, dp, trackp);
+      scg_settimeout(scgp, 200);
+      
+}
+
 char	*blank_types[] = {
 	"entire disk",
 	"PMA, TOC, pregap",
@@ -2430,6 +2890,42 @@
 }
 
 LOCAL int
+opt1_mdvd(scgp, dp)
+	SCSI	*scgp;
+	cdr_t	*dp;
+{
+	int	oflags = dp->cdr_dstat->ds_cdrflags;
+
+	if ((dp->cdr_dstat->ds_cdrflags & RF_AUDIOMASTER) != 0) {
+		printf("Turning Audio Master Q. R. on\n");
+		if (set_audiomaster_yamaha(scgp, dp, TRUE) < 0)
+			return (-1);
+		if (!debug && lverbose <= 1)
+			dp->cdr_dstat->ds_cdrflags &= ~RF_PRATIP;
+		if (getdisktype_mdvd(scgp, dp) < 0) {
+			dp->cdr_dstat->ds_cdrflags = oflags;
+			return (-1);
+		}
+		dp->cdr_dstat->ds_cdrflags = oflags;
+		if (oflags & RF_PRATIP) {
+			msf_t   msf;
+			lba_to_msf(dp->cdr_dstat->ds_first_leadin, &msf);
+			printf("New start of lead in: %ld (%02d:%02d/%02d)\n",
+				(long)dp->cdr_dstat->ds_first_leadin,
+		                msf.msf_min,
+        		        msf.msf_sec,
+                		msf.msf_frame);
+			lba_to_msf(dp->cdr_dstat->ds_maxblocks, &msf);
+			printf("New start of lead out: %ld (%02d:%02d/%02d)\n",
+				(long)dp->cdr_dstat->ds_maxblocks,
+		                msf.msf_min,
+        		        msf.msf_sec,
+                		msf.msf_frame);
+		}
+	}
+	return (0);
+}
+LOCAL int
 scsi_sony_write(scgp, bp, sectaddr, size, blocks, islast)
 	SCSI	*scgp;
 	caddr_t	bp;		/* address of buffer */
--- cdrtools-2.01/cdrecord/cdrecord.c.dvd	2003-06-21 21:16:57.000000000 +0200
+++ cdrtools-2.01/cdrecord/cdrecord.c	2003-06-23 18:37:52.000000000 +0200
@@ -206,7 +206,7 @@
 LOCAL	BOOL	checkdsize	__PR((SCSI *scgp, cdr_t *dp,
 					long tsize, int flags));
 LOCAL	void	raise_fdlim	__PR((void));
-LOCAL	void	gargs		__PR((int, char **, int *, track_t *, char **,
+LOCAL	int	gargs		__PR((int, char **, int *, track_t *, char **,
 					int *, cdr_t **,
 					int *, long *, int *));
 LOCAL	void	set_trsizes	__PR((cdr_t *, int, track_t *));
@@ -261,6 +261,7 @@
 	SCSI	*scgp = NULL;
 	char	errstr[80];
 	BOOL	gracedone = FALSE;
+	int     ispacket;
 
 #ifdef __EMX__
 	/* This gives wildcard expansion with Non-Posix shells with EMX */
@@ -273,7 +274,7 @@
 		track[i].track = track[i].trackno = i;
 	track[0].tracktype = TOC_MASK;
 	raise_fdlim();
-	gargs(ac, av, &tracks, track, &dev, &timeout, &dp, &speed, &flags,
+	ispacket = gargs(ac, av, &tracks, track, &dev, &timeout, &dp, &speed, &flags,
 							&blanktype);
 	if ((track[0].tracktype & TOC_MASK) == TOC_MASK)
 		comerrno(EX_BAD, "Internal error: Bad TOC type.\n");
@@ -327,11 +328,15 @@
 #	define	PRODVD_TITLE	""
 #	define	CLONE_TITLE	""
 	if ((flags & F_MSINFO) == 0 || lverbose || flags & F_VERSION) {
-		printf("Cdrecord%s%s %s (%s-%s-%s) Copyright (C) 1995-2003 Jörg Schilling\n",
+		printf("Cdrecord%s%s %s-dvd (%s-%s-%s) Copyright (C) 1995-2003 Jörg Schilling\n",
 								PRODVD_TITLE,
 								CLONE_TITLE,
 								cdr_version,
 								HOST_CPU, HOST_VENDOR, HOST_OS);
+		 printf("Note: This version is an unofficial (modified) version with DVD support\n");
+                 printf("Note: and therefore may have bugs that are not present in the original.\n");
+                 printf("Note: Please send bug reports or support requests to <warly@mandrakesoft.com>.\n");           
+                 printf("Note: The author of cdrecord is not to be bothered with problems in this version.\n");
 
 #ifdef	SOURCE_MODIFIED
 #define	INSERT_YOUR_EMAIL_ADDRESS_HERE
@@ -553,6 +558,19 @@
 	} else if (!is_unknown_dev(scgp) && dp != get_cdrcmds(scgp)) {
 		errmsgno(EX_BAD, "WARNING: Trying to use other driver on known device.\n");
 	}
+        if (ispacket) {
+	    BOOL	is_cdwr = FALSE;
+	    BOOL	is_dvdwr = FALSE;
+	    is_mmc(scgp, &is_cdwr, &is_dvdwr);
+	    if (is_dvdwr) {
+		track[0].flags |= TI_PACKET; 
+		/*XXX put here to only affect DVD writing, should be in gargs.
+		 * however if set in args for all mode, packet writing is then
+		 * broken for all disc as cdrecord assume that PACKET imply TAO which  
+		 * is not true at all???? */ 
+		track[0].flags &= ~TI_TAO;
+	    }
+	}
 
 	if (!is_cddrive(scgp))
 		comerrno(EX_BAD, "Sorry, no CD/DVD-Drive found on this target.\n");
@@ -594,12 +612,12 @@
 		if (!is_mmc(scgp, &is_cdwr, &is_dvdwr))
 			is_cdwr = TRUE;			/* If it is not MMC, it must be a CD writer */
 
-		if (is_dvdwr && !set_cdrcmds("mmc_dvd", (cdr_t **)NULL)) {
+		if (is_dvdwr && !set_cdrcmds("mmc_mdvd", (cdr_t **)NULL)) {
 			errmsgno(EX_BAD,
 			"This version of cdrecord does not include DVD-R/DVD-RW support code.\n");
 			errmsgno(EX_BAD,
 			"If you need DVD-R/DVD-RW support, ask the Author for cdrecord-ProDVD.\n");
-		}
+		} 
 		/*
 		 * Only exit if this is not the ProDVD test binary.
 		 */
@@ -1110,6 +1128,14 @@
 		trackno = 0;
 	}
 	scgp->silent--;
+	
+	/* If it is DVD, the information in TOC is fabricated :)
+	 The real information is from read disk info command*/
+	if((dp->cdr_dstat->ds_disktype&DT_DVD) && (dp->cdr_dstat->ds_trlast>0)){
+	    trackno=dp->cdr_dstat->ds_trlast-1;
+	    printf("trackno=%d\n",trackno);
+	}
+
 	if ((tracks + trackno) > MAX_TRACK) {
 		/*
 		 * XXX How many tracks are allowed on a DVD?
@@ -2831,10 +2857,13 @@
 		/*
 		 * dsp->ds_maxblocks == 0 (disk capacity is unknown).
 		 */
-		if (endsec >= (405000-300)) {			/*<90 min disk*/
-			errmsgno(EX_BAD,
-				"Data will not fit on any disk.\n");
-			goto toolarge;
+	        if (endsec >= (2300000)) {
+		        errmsgno(EX_BAD,
+			"ERROR: Could not manage to find medium size, and more than 4.3 GB of data.\n");
+  		        goto toolarge;  
+	        } else if (endsec >= (405000-300)) {            /*<90 min disk or DVD*/
+		        errmsgno(EX_BAD,
+			"WARNING: Could not manage to find medium size, and more than 90 mins of data.\n");
 		} else if (endsec >= (333000-150)) {		/* 74 min disk*/
 			errmsgno(EX_BAD,
 			"WARNING: Data may not fit on standard 74min disk.\n");
@@ -2910,7 +2939,7 @@
 char	*opts =
 "help,version,checkdrive,prcap,inq,scanbus,reset,abort,overburn,ignsize,useinfo,dev*,timeout#,driver*,driveropts*,setdropts,tsize&,padsize&,pregap&,defpregap&,speed#,load,lock,eject,dummy,msinfo,toc,atip,multi,fix,nofix,waiti,immed,debug#,d+,kdebug#,kd#,verbose+,v+,Verbose+,V+,x+,xd#,silent,s,audio,data,mode2,xa,xa1,xa2,xamix,cdi,isosize,nopreemp,preemp,nocopy,copy,nopad,pad,swab,fs&,blank&,format,pktsize#,packet,noclose,force,dao,raw,raw96r,raw96p,raw16,clone,scms,isrc*,mcn*,index*,cuefile*,textfile*,text,shorttrack,noshorttrack,gracetime#,minbuf#";
 
-LOCAL void
+LOCAL int
 gargs(ac, av, tracksp, trackp, devp, timeoutp, dpp, speedp, flagsp, blankp)
 	int	ac;
 	char	**av;
@@ -3538,14 +3567,14 @@
 	    ((strncmp(*devp, "HELP", 4) == 0) ||
 	    (strncmp(*devp, "help", 4) == 0))) {
 		*flagsp |= F_CHECKDRIVE; /* Set this for not calling mlockall() */
-		return;
+		return ispacket;
 	}
 	if (*flagsp & (F_LOAD|F_DLCK|F_SETDROPTS|F_MSINFO|F_TOC|F_PRATIP|F_FIX|F_VERSION|F_CHECKDRIVE|F_PRCAP|F_INQUIRY|F_SCANBUS|F_RESET|F_ABORT)) {
 		if (tracks != 0) {
 			errmsgno(EX_BAD, "No tracks allowed with this option\n");
 			susage(EX_BAD);
 		}
-		return;
+		return ispacket;
 	}
 	*tracksp = tracks;
 	if (*flagsp & F_SAO) {
@@ -3569,12 +3598,13 @@
 			susage(EX_BAD);
 		}
 		cuefilename = cuefile;
-		return;
+		return ispacket;
 	}
 	if (tracks == 0 && (*flagsp & (F_LOAD|F_DLCK|F_EJECT|F_BLANK|F_FORMAT)) == 0) {
 		errmsgno(EX_BAD, "No tracks specified. Need at least one.\n");
 		susage(EX_BAD);
 	}
+	return ispacket;
 }
 
 LOCAL void
--- cdrtools-2.01/cdrecord/cdr_drv.c.dvd	2003-04-17 22:13:07.000000000 +0200
+++ cdrtools-2.01/cdrecord/cdr_drv.c	2003-06-23 18:35:12.000000000 +0200
@@ -42,6 +42,7 @@
 extern	cdr_t	cdr_oldcd;
 extern	cdr_t	cdr_cd;
 extern	cdr_t	cdr_mmc;
+extern  cdr_t   cdr_mdvd;
 extern	cdr_t	cdr_mmc_sony;
 extern	cdr_t	cdr_cd_dvd;
 extern	cdr_t	cdr_philips_cdd521O;
@@ -80,6 +81,7 @@
 cdr_t	*drivers[] = {
 	&cdr_cd_dvd,
 	&cdr_mmc,
+        &cdr_mdvd,
 	&cdr_mmc_sony,
 	&cdr_cd,
 	&cdr_oldcd,
--- cdrtools-2.01/cdrecord/scsi_cdr.c.dvd	2003-04-23 22:20:28.000000000 +0200
+++ cdrtools-2.01/cdrecord/scsi_cdr.c	2003-06-23 18:35:12.000000000 +0200
@@ -998,6 +998,32 @@
 	return (0);
 }
 
+
+EXPORT int
+reserve_track(scgp, size)
+	SCSI	*scgp;
+	Ulong	size;
+
+{
+	register struct	scg_cmd	*scmd = scgp->scmd;
+
+	fillbytes((caddr_t)scmd, sizeof(*scmd), '\0');
+	scmd->flags = SCG_DISRE_ENA;
+	scmd->cdb_len = SC_G1_CDBLEN;
+	scmd->sense_len = CCS_SENSE_LEN;
+	scmd->cdb.g1_cdb.cmd = 0x53;
+	scmd->cdb.g1_cdb.lun = scg_lun(scgp);
+	i_to_4_byte(&scmd->cdb.g1_cdb.addr[3], size);
+
+	scgp->cmdname = "reserve track";
+
+	if (scg_cmd(scgp) < 0) 
+		return (-1);
+
+	return (0);
+
+}
+
 EXPORT int
 read_rzone_info(scgp, bp, cnt)
 	SCSI	*scgp;
--- cdrtools-2.01/cdrecord/cdrecord.h.dvd	2003-05-11 23:25:29.000000000 +0200
+++ cdrtools-2.01/cdrecord/cdrecord.h	2003-06-23 18:35:12.000000000 +0200
@@ -566,6 +566,12 @@
 #define	DSF_NEED_FORMAT	0x0800	/* Disk needs to be formatted		*/
 
 /*
+ * Definitions for disktype flags
+ */
+#define DT_CD           0x001  /*is a CD                                */
+#define DT_DVD          0x002  /*is a DVD                               */
+
+/*
  * Definitions for disk_status disk type
  * used in "ds_type".
  */
