Index: glibc/Makefile
===================================================================
RCS file: /data/cvs/heapguard/glibc/Makefile,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- glibc/Makefile	10 Jun 2003 23:58:19 -0000	1.1.1.1
+++ glibc/Makefile	23 Oct 2003 19:17:50 -0000	1.2
@@ -114,6 +114,7 @@
 	rm -f $(symbolic-link-list)
 
 install:
+	$(install-heapprotect-script)
 	-test ! -x $(common-objpfx)elf/ldconfig || LC_ALL=C LANGUAGE=C \
 	  $(common-objpfx)elf/ldconfig $(addprefix -r ,$(install_root)) \
 				       $(slibdir) $(libdir)
Index: glibc/Makerules
===================================================================
RCS file: /data/cvs/heapguard/glibc/Makerules,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -r1.1.1.1 -r1.3
--- glibc/Makerules	10 Jun 2003 23:58:19 -0000	1.1.1.1
+++ glibc/Makerules	24 Nov 2003 01:58:53 -0000	1.3
@@ -922,6 +922,20 @@
 endef
 endif
 
+define set-heap-protected-library-path
+sed 's,@HGLIB\@,$(inst_slibdir)/heapprotect/libc.so$(libc.so-version),' <heapprotect.in >$(objdir)/heapprotect
+endef
+
+ifeq (yes,$(enable-heap-protection))
+define install-heapprotect-script
+$(set-heap-protected-library-path)
+$(INSTALL_PROGRAM) $(objdir)/heapprotect $(inst_bindir)/heapprotect
+endef
+else
+define install-heapprotect-script
+endef
+endif
+
 ifdef libc.so-version
 # For a library specified to be version N, install three files:
 # libc.so	->	libc.so.N	(e.g. libc.so.6)
@@ -932,7 +946,14 @@
 	$(make-shlib-link)
 $(inst_slibdir)/libc-$(version).so: $(common-objpfx)libc.so $(+force)
 	$(do-install-program)
-install: $(inst_slibdir)/libc.so$(libc.so-version)
+
+$(inst_slibdir)/heapprotect/libc.so$(libc.so-version): $(inst_slibdir)/heapprotect/libc-$(version).so $(+force)
+	$(make-shlib-link)
+$(inst_slibdir)/heapprotect/libc-$(version).so: $(common-objpfx)libc.so $(+force)
+	$(do-install-program)
+
+install: $(inst_slibdir)/heapprotect/libc.so$(libc.so-version) \
+	$(inst_slibdir)/libc.so$(libc.so-version)
 
 # This fragment of linker script gives the OUTPUT_FORMAT statement
 # for the configuration we are building.  We put this statement into
Index: glibc/config.make.in
===================================================================
RCS file: /data/cvs/heapguard/glibc/config.make.in,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -r1.1.1.1 -r1.3
--- glibc/config.make.in	10 Jun 2003 23:58:19 -0000	1.1.1.1
+++ glibc/config.make.in	24 Nov 2003 01:58:53 -0000	1.3
@@ -113,4 +113,7 @@
 # Additional libraries.
 LIBGD = @LIBGD@
 
+# Heap protection
+enable-heap-protection = @enable_heap_protection@
+
 # More variables may be inserted below by configure.
--- glibc/configure.heapprotect	2003-07-07 09:14:50.000000000 -0600
+++ glibc/configure	2004-02-05 12:52:45.000000000 -0700
@@ -25,7 +25,7 @@
 fi
 
 # Support unset when possible.
-if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+if (as_foo=foo; unset as_foo) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
@@ -41,7 +41,7 @@
 # NLS nuisances.
 for as_var in LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE LC_NUMERIC LC_MESSAGES LC_TIME
 do
-  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
     $as_unset $as_var
@@ -309,7 +309,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS with_fp with_cvs enable_check_abi oldest_abi subdirs force_install all_warnings build build_cpu build_vendor build_os host host_cpu host_vendor host_os base_machine sysnames INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA LN_S CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC OBJEXT BUILD_CC cross_compiling CPP CXX CXXFLAGS ac_ct_CXX AR OBJDUMP RANLIB ac_ct_RANLIB MIG AS LD PWD_P MAKE MSGFMT MAKEINFO SED AUTOCONF CCVERSION SYSINCLUDES libc_cv_gcc_static_libgcc BASH libc_cv_have_bash2 KSH libc_cv_have_ksh AWK PERL INSTALL_INFO OLD_DEBIAN_INSTALL_INFO BISON VERSIONING libc_cv_asm_protected_directive libc_cv_initfinit_array libc_cv_z_nodelete libc_cv_z_nodlopen libc_cv_z_initfirst libc_cv_Bgroup ASFLAGS_config libc_cv_z_combreloc libc_cv_have_initfini libc_cv_cpp_asm_debuginfo no_whole_archive exceptions LIBGD EGREP sizeof_long_double libc_cv_gcc_unwind_find_fde uname_sysname uname_release uname_version old_glibc_headers libc_cv_slibdir libc_cv_localedir libc_cv_sysconfdir libc_cv_rootsbindir libc_cv_forced_unwind use_ldconfig ldd_rewrite_script gnu_ld gnu_as elf xcoff static shared pic_default profile omitfp bounded static_nss nopic_initfini DEFINES linux_doors mach_interface_list VERSION RELEASE LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS with_fp with_cvs enable_check_abi oldest_abi subdirs force_install all_warnings build build_cpu build_vendor build_os host host_cpu host_vendor host_os base_machine sysnames INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA LN_S CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC OBJEXT BUILD_CC cross_compiling CPP CXX CXXFLAGS ac_ct_CXX AR OBJDUMP RANLIB ac_ct_RANLIB MIG AS LD PWD_P MAKE MSGFMT MAKEINFO SED AUTOCONF CCVERSION SYSINCLUDES libc_cv_gcc_static_libgcc BASH libc_cv_have_bash2 KSH libc_cv_have_ksh AWK PERL INSTALL_INFO OLD_DEBIAN_INSTALL_INFO BISON VERSIONING libc_cv_asm_protected_directive libc_cv_initfinit_array libc_cv_z_nodelete libc_cv_z_nodlopen libc_cv_z_initfirst libc_cv_Bgroup ASFLAGS_config libc_cv_z_combreloc libc_cv_have_initfini libc_cv_cpp_asm_debuginfo no_whole_archive exceptions LIBGD EGREP sizeof_long_double libc_cv_gcc_unwind_find_fde uname_sysname uname_release uname_version old_glibc_headers libc_cv_slibdir libc_cv_localedir libc_cv_sysconfdir libc_cv_rootsbindir libc_cv_forced_unwind use_ldconfig ldd_rewrite_script gnu_ld gnu_as elf xcoff static shared pic_default profile omitfp bounded static_nss nopic_initfini enable_heap_protection DEFINES linux_doors mach_interface_list VERSION RELEASE LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -668,7 +668,7 @@
 
 # Be sure to have absolute paths.
 for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
-              localstatedir libdir includedir oldincludedir infodir mandir
+	      localstatedir libdir includedir oldincludedir infodir mandir
 do
   eval ac_val=$`echo $ac_var`
   case $ac_val in
@@ -708,10 +708,10 @@
   # Try the directory containing this script, then its parent.
   ac_confdir=`(dirname "$0") 2>/dev/null ||
 $as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$0" : 'X\(//\)[^/]' \| \
-         X"$0" : 'X\(//\)$' \| \
-         X"$0" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$0" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -811,9 +811,9 @@
   cat <<_ACEOF
 Installation directories:
   --prefix=PREFIX         install architecture-independent files in PREFIX
-                          [$ac_default_prefix]
+			  [$ac_default_prefix]
   --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-                          [PREFIX]
+			  [PREFIX]
 
 By default, \`make install' will install all the files in
 \`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
@@ -879,6 +879,8 @@
   --enable-kernel=VERSION compile for compatibility with kernel not older than
                           VERSION
   --enable-all-warnings   enable all useful warnings gcc can issue
+  --enable-heap-protection
+                          Enable runtime heap overflow protection
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -962,7 +964,7 @@
       echo
       $SHELL $ac_srcdir/configure  --help=recursive
     elif test -f $ac_srcdir/configure.ac ||
-           test -f $ac_srcdir/configure.in; then
+	   test -f $ac_srcdir/configure.in; then
       echo
       $ac_configure --help
     else
@@ -1084,12 +1086,12 @@
     case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
     *ac_space=\ *)
       sed -n \
-        "s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
-    	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
       ;;
     *)
       sed -n \
-        "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
       ;;
     esac;
 }
@@ -1118,7 +1120,7 @@
       for ac_var in $ac_subst_files
       do
 	eval ac_val=$`echo $ac_var`
-        echo "$ac_var='"'"'$ac_val'"'"'"
+	echo "$ac_var='"'"'$ac_val'"'"'"
       done | sort
       echo
     fi
@@ -1217,7 +1219,7 @@
 # value.
 ac_cache_corrupted=false
 for ac_var in `(set) 2>&1 |
-               sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
   eval ac_old_set=\$ac_cv_env_${ac_var}_set
   eval ac_new_set=\$ac_env_${ac_var}_set
   eval ac_old_val="\$ac_cv_env_${ac_var}_value"
@@ -1234,13 +1236,13 @@
     ,);;
     *)
       if test "x$ac_old_val" != "x$ac_new_val"; then
-        { echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
 echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-        { echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
 echo "$as_me:   former value:  $ac_old_val" >&2;}
-        { echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
 echo "$as_me:   current value: $ac_new_val" >&2;}
-        ac_cache_corrupted=:
+	ac_cache_corrupted=:
       fi;;
   esac
   # Pass precious variables to config.status.
@@ -2101,6 +2103,7 @@
 # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
 # AFS /usr/afsws/bin/install, which mishandles nonexistent args
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
 # ./install, which can be erroneously created by make from ./install.sh.
 echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
 echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
@@ -2117,6 +2120,7 @@
 case $as_dir/ in
   ./ | .// | /cC/* | \
   /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
   /usr/ucb/* ) ;;
   *)
     # OSF1 and SCO ODT 3.0 have their own names for install.
@@ -2124,20 +2128,20 @@
     # by default.
     for ac_prog in ginstall scoinst install; do
       for ac_exec_ext in '' $ac_executable_extensions; do
-        if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
-          if test $ac_prog = install &&
-            grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-            # AIX install.  It has an incompatible calling convention.
-            :
-          elif test $ac_prog = install &&
-            grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-            # program-specific install script used by HP pwplus--don't use.
-            :
-          else
-            ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
-            break 3
-          fi
-        fi
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
       done
     done
     ;;
@@ -2776,8 +2780,7 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   for ac_declaration in \
-   ''\
-   '#include <stdlib.h>' \
+   '' \
    'extern "C" void std::exit (int) throw (); using std::exit;' \
    'extern "C" void std::exit (int); using std::exit;' \
    'extern "C" void exit (int) throw ();' \
@@ -2834,7 +2837,7 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3248,7 +3251,7 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3352,7 +3355,7 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3383,7 +3386,7 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4564,7 +4567,7 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5761,7 +5764,7 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6453,7 +6456,7 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6573,7 +6576,7 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6881,6 +6884,25 @@
 
 
 
+# Check whether --enable-heap-protection or --disable-heap-protection was given.
+if test "${enable_heap_protection+set}" = set; then
+  enableval="$enable_heap_protection"
+
+fi;
+
+echo "$as_me:$LINENO: checking if heap protection should be enabled" >&5
+echo $ECHO_N "checking if heap protection should be enabled... $ECHO_C" >&6
+if test "$enable_heap_protection" = "yes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define __HEAP_PROTECTION 1
+_ACEOF
+
+  DEFINES="$DEFINES -D__HEAP_PROTECTION"
+fi
+echo "$as_me:$LINENO: result: $enable_heap_protection" >&5
+echo "${ECHO_T}$enable_heap_protection" >&6
+
+
 
 
 case "$add_ons" in
@@ -6934,13 +6956,13 @@
       # `set' does not quote correctly, so add quotes (double-quote
       # substitution turns \\\\ into \\, and sed turns \\ into \).
       sed -n \
-        "s/'/'\\\\''/g;
-    	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
       ;;
     *)
       # `set' quotes correctly as required by POSIX, so do not add quotes.
       sed -n \
-        "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
       ;;
     esac;
 } |
@@ -6970,13 +6992,13 @@
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[ 	]*VPATH[ 	]*=/{
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
 s/:*\$(srcdir):*/:/;
 s/:*\${srcdir}:*/:/;
 s/:*@srcdir@:*/:/;
-s/^\([^=]*=[ 	]*\):*/\1/;
+s/^\([^=]*=[	 ]*\):*/\1/;
 s/:*$//;
-s/^[^=]*=[ 	]*$//;
+s/^[^=]*=[	 ]*$//;
 }'
 fi
 
@@ -6987,7 +7009,7 @@
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_i=`echo "$ac_i" |
-         sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
   # 2. Add them.
   ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
   ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
@@ -7031,7 +7053,7 @@
 fi
 
 # Support unset when possible.
-if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+if (as_foo=foo; unset as_foo) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
@@ -7047,7 +7069,7 @@
 # NLS nuisances.
 for as_var in LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE LC_NUMERIC LC_MESSAGES LC_TIME
 do
-  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
     $as_unset $as_var
@@ -7305,9 +7327,9 @@
   -d, --debug      don't remove temporary files
       --recheck    update $as_me by reconfiguring in the same conditions
   --file=FILE[:TEMPLATE]
-                   instantiate the configuration file FILE
+		   instantiate the configuration file FILE
   --header=FILE[:TEMPLATE]
-                   instantiate the configuration header FILE
+		   instantiate the configuration header FILE
 
 Configuration files:
 $config_files
@@ -7606,6 +7628,7 @@
 s,@bounded@,$bounded,;t t
 s,@static_nss@,$static_nss,;t t
 s,@nopic_initfini@,$nopic_initfini,;t t
+s,@enable_heap_protection@,$enable_heap_protection,;t t
 s,@DEFINES@,$DEFINES,;t t
 s,@linux_doors@,$linux_doors,;t t
 s,@mach_interface_list@,$mach_interface_list,;t t
@@ -7642,9 +7665,9 @@
       (echo ':t
   /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
       if test -z "$ac_sed_cmds"; then
-  	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
       else
-  	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
       fi
       ac_sed_frag=`expr $ac_sed_frag + 1`
       ac_beg=$ac_end
@@ -7662,21 +7685,21 @@
   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
   case $ac_file in
   - | *:- | *:-:* ) # input from stdin
-        cat >$tmp/stdin
-        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   * )   ac_file_in=$ac_file.in ;;
   esac
 
   # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
   ac_dir=`(dirname "$ac_file") 2>/dev/null ||
 $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$ac_file" : 'X\(//\)[^/]' \| \
-         X"$ac_file" : 'X\(//\)$' \| \
-         X"$ac_file" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -7692,10 +7715,10 @@
       as_dirs="$as_dir $as_dirs"
       as_dir=`(dirname "$as_dir") 2>/dev/null ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$as_dir" : 'X\(//\)[^/]' \| \
-         X"$as_dir" : 'X\(//\)$' \| \
-         X"$as_dir" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -7760,7 +7783,7 @@
     configure_input="$ac_file.  "
   fi
   configure_input=$configure_input"Generated from `echo $ac_file_in |
-                                     sed 's,.*/,,'` by configure."
+				     sed 's,.*/,,'` by configure."
 
   # First look for the input files in the build tree, otherwise in the
   # src tree.
@@ -7769,24 +7792,24 @@
       case $f in
       -) echo $tmp/stdin ;;
       [\\/$]*)
-         # Absolute (can't be DOS-style, as IFS=:)
-         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         echo $f;;
+	 echo "$f";;
       *) # Relative
-         if test -f "$f"; then
-           # Build tree
-           echo $f
-         elif test -f "$srcdir/$f"; then
-           # Source tree
-           echo $srcdir/$f
-         else
-           # /dev/null tree
-           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         fi;;
+	 fi;;
       esac
     done` || { (exit 1); exit 1; }
 _ACEOF
@@ -7828,12 +7851,12 @@
 # NAME is the cpp macro being defined and VALUE is the value it is being given.
 #
 # ac_d sets the value in "#define NAME VALUE" lines.
-ac_dA='s,^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
-ac_dB='[ 	].*$,\1#\2'
+ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
+ac_dB='[	 ].*$,\1#\2'
 ac_dC=' '
 ac_dD=',;t'
 # ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
-ac_uA='s,^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
 ac_uB='$,\1#\2define\3'
 ac_uC=' '
 ac_uD=',;t'
@@ -7842,11 +7865,11 @@
   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
   case $ac_file in
   - | *:- | *:-:* ) # input from stdin
-        cat >$tmp/stdin
-        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   * )   ac_file_in=$ac_file.in ;;
   esac
 
@@ -7860,28 +7883,29 @@
       case $f in
       -) echo $tmp/stdin ;;
       [\\/$]*)
-         # Absolute (can't be DOS-style, as IFS=:)
-         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         echo $f;;
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
       *) # Relative
-         if test -f "$f"; then
-           # Build tree
-           echo $f
-         elif test -f "$srcdir/$f"; then
-           # Source tree
-           echo $srcdir/$f
-         else
-           # /dev/null tree
-           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         fi;;
+	 fi;;
       esac
     done` || { (exit 1); exit 1; }
   # Remove the trailing spaces.
-  sed 's/[ 	]*$//' $ac_file_inputs >$tmp/in
+  sed 's/[	 ]*$//' $ac_file_inputs >$tmp/in
 
 _ACEOF
 
@@ -7904,9 +7928,9 @@
 s,[\\$`],\\&,g
 t clear
 : clear
-s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	(][^ 	(]*\)\(([^)]*)\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*\)\(([^)]*)\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
 t end
-s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	][^ 	]*\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
 : end
 _ACEOF
 # If some macros were called several times there might be several times
@@ -7920,13 +7944,13 @@
 # example, in the case of _POSIX_SOURCE, which is predefined and required
 # on some systems where configure will not decide to define it.
 cat >>conftest.undefs <<\_ACEOF
-s,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
 _ACEOF
 
 # Break up conftest.defines because some shells have a limit on the size
 # of here documents, and old seds have small limits too (100 cmds).
 echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
-echo '  if grep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  if grep "^[	 ]*#[	 ]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
 echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
 echo '  :' >>$CONFIG_STATUS
 rm -f conftest.tail
@@ -7935,7 +7959,7 @@
   # Write a limited-size here document to $tmp/defines.sed.
   echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
   # Speed up: don't consider the non `#define' lines.
-  echo '/^[ 	]*#[ 	]*define/!b' >>$CONFIG_STATUS
+  echo '/^[	 ]*#[	 ]*define/!b' >>$CONFIG_STATUS
   # Work around the forget-to-reset-the-flag bug.
   echo 't clr' >>$CONFIG_STATUS
   echo ': clr' >>$CONFIG_STATUS
@@ -7962,7 +7986,7 @@
   # Write a limited-size here document to $tmp/undefs.sed.
   echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
   # Speed up: don't consider the non `#undef'
-  echo '/^[ 	]*#[ 	]*undef/!b' >>$CONFIG_STATUS
+  echo '/^[	 ]*#[	 ]*undef/!b' >>$CONFIG_STATUS
   # Work around the forget-to-reset-the-flag bug.
   echo 't clr' >>$CONFIG_STATUS
   echo ': clr' >>$CONFIG_STATUS
@@ -7996,10 +8020,10 @@
     else
       ac_dir=`(dirname "$ac_file") 2>/dev/null ||
 $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$ac_file" : 'X\(//\)[^/]' \| \
-         X"$ac_file" : 'X\(//\)$' \| \
-         X"$ac_file" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -8015,10 +8039,10 @@
       as_dirs="$as_dir $as_dirs"
       as_dir=`(dirname "$as_dir") 2>/dev/null ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$as_dir" : 'X\(//\)[^/]' \| \
-         X"$as_dir" : 'X\(//\)$' \| \
-         X"$as_dir" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -8050,10 +8074,10 @@
   ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
   ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
 $as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$ac_dest" : 'X\(//\)[^/]' \| \
-         X"$ac_dest" : 'X\(//\)$' \| \
-         X"$ac_dest" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$ac_dest" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -8188,10 +8212,10 @@
       as_dirs="$as_dir $as_dirs"
       as_dir=`(dirname "$as_dir") 2>/dev/null ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-         X"$as_dir" : 'X\(//\)[^/]' \| \
-         X"$as_dir" : 'X\(//\)$' \| \
-         X"$as_dir" : 'X\(/\)' \| \
-         .     : '\(.\)' 2>/dev/null ||
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
@@ -8258,15 +8282,15 @@
       case $cache_file in
       [\\/]* | ?:[\\/]* ) ac_sub_cache_file=$cache_file ;;
       *) # Relative path.
-        ac_sub_cache_file=$ac_top_builddir$cache_file ;;
+	ac_sub_cache_file=$ac_top_builddir$cache_file ;;
       esac
 
       { echo "$as_me:$LINENO: running $ac_sub_configure $ac_sub_configure_args --cache-file=$ac_sub_cache_file --srcdir=$ac_srcdir" >&5
 echo "$as_me: running $ac_sub_configure $ac_sub_configure_args --cache-file=$ac_sub_cache_file --srcdir=$ac_srcdir" >&6;}
       # The eval makes quoting arguments work.
       eval $ac_sub_configure $ac_sub_configure_args \
-           --cache-file=$ac_sub_cache_file --srcdir=$ac_srcdir ||
-        { { echo "$as_me:$LINENO: error: $ac_sub_configure failed for $ac_dir" >&5
+	   --cache-file=$ac_sub_cache_file --srcdir=$ac_srcdir ||
+	{ { echo "$as_me:$LINENO: error: $ac_sub_configure failed for $ac_dir" >&5
 echo "$as_me: error: $ac_sub_configure failed for $ac_dir" >&2;}
    { (exit 1); exit 1; }; }
     fi
Index: glibc/configure.in
===================================================================
RCS file: /data/cvs/heapguard/glibc/configure.in,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -r1.1.1.1 -r1.3
--- glibc/configure.in	10 Jun 2003 23:58:19 -0000	1.1.1.1
+++ glibc/configure.in	24 Nov 2003 01:58:53 -0000	1.3
@@ -1882,6 +1882,18 @@
 AC_SUBST(static_nss)
 AC_SUBST(nopic_initfini)
 
+dnl Heap protection configuration checks
+AC_ARG_ENABLE([heap-protection],
+  AC_HELP_STRING([--enable-heap-protection], [Enable runtime heap overflow protection]))
+
+AC_MSG_CHECKING([if heap protection should be enabled])
+if test "$enable_heap_protection" = "yes"; then
+  AC_DEFINE([__HEAP_PROTECTION])
+  DEFINES="$DEFINES -D__HEAP_PROTECTION"
+fi
+AC_MSG_RESULT([$enable_heap_protection])
+AC_SUBST([enable_heap_protection])
+
 AC_SUBST(DEFINES)
 
 case "$add_ons" in
Index: glibc/heapprotect.in
===================================================================
RCS file: glibc/heapprotect.in
diff -N glibc/heapprotect.in
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ glibc/heapprotect.in	23 Oct 2003 19:17:50 -0000	1.1
@@ -0,0 +1,20 @@
+#! /bin/bash
+#: Heap protection preload script
+
+#
+# Settings
+#
+
+# Location of patched library
+HGLIB=@HGLIB@
+
+# Check for library existence
+if [ ! -f $HGLIB ]; then
+  echo "ERROR: Unable to find heap-protected C library! ($HGLIB)"
+  exit 1
+fi
+
+echo ">>> Executing: LD_PRELOAD=\"$HGLIB $LD_PRELOAD\" $@" >&2
+LD_PRELOAD="$HGLIB $LD_PRELOAD"
+exec "$@"
+
Index: glibc/malloc/hooks.c
===================================================================
RCS file: /data/cvs/heapguard/glibc/malloc/hooks.c,v
retrieving revision 1.1.1.1
retrieving revision 1.5
diff -u -r1.1.1.1 -r1.5
--- glibc/malloc/hooks.c	10 Jun 2003 23:58:29 -0000	1.1.1.1
+++ glibc/malloc/hooks.c	3 Dec 2003 01:46:07 -0000	1.5
@@ -20,10 +20,21 @@
 
 /* $Id: hooks.c,v 1.11 2003/01/27 18:32:36 drepper Exp $ */
 
+#include <limits.h>
+#include <sys/mman.h>
+
 #ifndef DEFAULT_CHECK_ACTION
 #define DEFAULT_CHECK_ACTION 1
 #endif
 
+#ifdef __HEAP_PROTECTION
+#ifndef PAGESIZE
+#define PAGESIZE 4096
+#endif
+static char __attribute__((aligned(PAGESIZE))) __heap_magic_pad[PAGESIZE];
+static int *__heap_magic = (int) &__heap_magic_pad;
+#endif
+
 /* What to do if the standard debugging hooks are in place and a
    corrupt pointer is detected: do nothing (0), print an error message
    (1), or call abort() (2). */
@@ -39,7 +50,43 @@
      size_t sz; const __malloc_ptr_t caller;
 #endif
 {
+#ifdef __HEAP_PROTECTION
+  unsigned int seed = 0;
+  unsigned char buf[sizeof(unsigned int)];
+  int fd;
+
+  /* Try to get some real randomness into the seed */
+#ifdef __HEAP_PROTECTION_DEBUG
+  fprintf(stderr, "glibc: seed contents = %#x\n", *((unsigned int *) buf));
+#endif /* __HEAP_PROTECTION_DEBUG */
+  if ((fd = open("/dev/urandom", O_RDONLY)) >= 0) {
+    if (read(fd, buf, sizeof(buf)) < sizeof(buf)) {
+      fprintf(stderr, "glibc: failed to seed heap magic with randomness\n");
+    } else {
+      seed = *((unsigned int *) buf);
+#ifdef __HEAP_PROTECTION_DEBUG
+      fprintf(stderr, "glibc: seeded heap magic with %#x\n", seed);
+#endif /* __HEAP_PROTECTION_DEBUG */
+    }
+    close(fd);
+  }
+
+  if (!seed)
+    seed = time(NULL);
+
+#ifdef __HEAP_PROTECTION_DEBUG
+  *__heap_magic = 0xcafebabe;
+  fprintf(stderr, "glibc: initialized __heap_magic to %#x\n", *__heap_magic);
+#else /* !__HEAP_PROTECTION_DEBUG */
+  srandom(seed);
+  *__heap_magic = random();
+#endif /* __HEAP_PROTECTION_DEBUG */
+  if (mprotect(__heap_magic, sizeof(*__heap_magic), PROT_READ))
+    fprintf(stderr, "glibc: WARNING: unable to protect heap magic!\n");
+#endif /* __HEAP_PROTECTION */
+
   __malloc_hook = NULL;
+
   ptmalloc_init();
   return public_mALLOc(sz);
 }
Index: glibc/malloc/malloc.c
===================================================================
RCS file: /data/cvs/heapguard/glibc/malloc/malloc.c,v
retrieving revision 1.1.1.1
retrieving revision 1.5
diff -u -r1.1.1.1 -r1.5
--- glibc/malloc/malloc.c	10 Jun 2003 23:58:29 -0000	1.1.1.1
+++ glibc/malloc/malloc.c	3 Dec 2003 01:46:07 -0000	1.5
@@ -221,6 +221,11 @@
     There are several other #defined constants and macros that you
     probably don't want to touch unless you are extending or adapting malloc.  */
 
+#undef __HEAP_PROTECTION_DEBUG
+#ifdef __HEAP_PROTECTION_DEBUG
+#define MALLOC_DEBUG 1
+#endif
+
 /*
   __STD_C should be nonzero if using ANSI-standard C compiler, a C++
   compiler, or a C compiler sufficiently close to ANSI to get away
@@ -251,6 +256,7 @@
 #if __STD_C
 #include <stddef.h>   /* for size_t */
 #include <stdlib.h>   /* for getenv(), abort() */
+#include <syslog.h>
 #else
 #include <sys/types.h>
 #endif
@@ -361,8 +367,12 @@
 
 
 #ifndef MALLOC_ALIGNMENT
+#ifdef __HEAP_PROTECTION
+#define MALLOC_ALIGNMENT       (4 * SIZE_SZ)
+#else
 #define MALLOC_ALIGNMENT       (2 * SIZE_SZ)
 #endif
+#endif
 
 /* The corresponding bit mask value */
 #define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)
@@ -1655,7 +1665,12 @@
   fields at known offsets from a given base. See explanation below.
 */
 
-struct malloc_chunk {
+struct malloc_chunk
+{
+#ifdef __HEAP_PROTECTION
+  INTERNAL_SIZE_T      magic;      /* Magic fencepost */
+  INTERNAL_SIZE_T      debug;      /* Freed, inuse flags */
+#endif
 
   INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
   INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */
@@ -1758,8 +1773,13 @@
 
 /* conversion from malloc headers to user pointers, and back */
 
+#ifdef __HEAP_PROTECTION
+#define chunk2mem(p)   ((Void_t*)((char*)(p) + 4*SIZE_SZ))
+#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 4*SIZE_SZ))
+#else
 #define chunk2mem(p)   ((Void_t*)((char*)(p) + 2*SIZE_SZ))
 #define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))
+#endif
 
 /* The smallest possible chunk */
 #define MIN_CHUNK_SIZE        (sizeof(struct malloc_chunk))
@@ -1786,10 +1806,17 @@
 
 /* pad request bytes into a usable size -- internal version */
 
+#ifdef __HEAP_PROTECTION
+#define request2size(req) \
+  (((req) + 4*SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE) ? \
+    MINSIZE : \
+    ((req) + 4*SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)
+#else
 #define request2size(req)                                         \
   (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
    MINSIZE :                                                      \
    ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)
+#endif
 
 /*  Same, except also perform argument check */
 
@@ -1804,7 +1831,6 @@
   --------------- Physical chunk operations ---------------
 */
 
-
 /* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
 #define PREV_INUSE 0x1
 
@@ -1856,8 +1882,15 @@
 ((((mchunkptr)(((char*)(p))+((p)->size & ~SIZE_BITS)))->size) & PREV_INUSE)
 
 /* set/clear chunk as being inuse without otherwise disturbing */
+#ifdef __HEAP_PROTECTION_DEBUG
 #define set_inuse(p)\
+fprintf(stderr, "glibc: setting prev inuse bit for %p at " __FILE__ \
+  ":%d\n", p, __LINE__); \
 ((mchunkptr)(((char*)(p)) + ((p)->size & ~SIZE_BITS)))->size |= PREV_INUSE
+#else
+#define set_inuse(p) \
+  ((mchunkptr)(((char*)(p)) + ((p)->size & ~SIZE_BITS)))->size |= PREV_INUSE
+#endif
 
 #define clear_inuse(p)\
 ((mchunkptr)(((char*)(p)) + ((p)->size & ~SIZE_BITS)))->size &= ~(PREV_INUSE)
@@ -1867,8 +1900,15 @@
 #define inuse_bit_at_offset(p, s)\
  (((mchunkptr)(((char*)(p)) + (s)))->size & PREV_INUSE)
 
+#ifdef __HEAP_PROTECTION_DEBUG
 #define set_inuse_bit_at_offset(p, s)\
+fprintf(stderr, "glibc: setting prev inuse bit for %p at " __FILE__ \
+  ":%d\n", p + p->size, __LINE__); \
  (((mchunkptr)(((char*)(p)) + (s)))->size |= PREV_INUSE)
+#else
+#define set_inuse_bit_at_offset(p, s) \
+  (((mchunkptr)(((char*)(p)) + (s)))->size |= PREV_INUSE)
+#endif
 
 #define clear_inuse_bit_at_offset(p, s)\
  (((mchunkptr)(((char*)(p)) + (s)))->size &= ~(PREV_INUSE))
@@ -1878,7 +1918,15 @@
 #define set_head_size(p, s)  ((p)->size = (((p)->size & SIZE_BITS) | (s)))
 
 /* Set size/use field */
-#define set_head(p, s)       ((p)->size = (s))
+#ifdef __HEAP_PROTECTION_DEBUG
+#define set_head(p, s) \
+  fprintf(stderr, "glibc: setting size %d for %p at " __FILE__ \
+    ":%d\n", s, p, __LINE__); \
+  ((p)->size = (s))
+#else
+#define set_head(p, s) \
+  ((p)->size = (s))
+#endif
 
 /* Set size at footer (only when chunk is not in use) */
 #define set_foot(p, s)       (((mchunkptr)((char*)(p) + (s)))->prev_size = (s))
@@ -1938,7 +1986,11 @@
 typedef struct malloc_chunk* mbinptr;
 
 /* addressing -- note that bin_at(0) does not exist */
+#ifdef __HEAP_PROTECTION
+#define bin_at(m, i) ((mbinptr)((char*)&((m)->bins[(i)<<1]) - (SIZE_SZ<<2)))
+#else
 #define bin_at(m, i) ((mbinptr)((char*)&((m)->bins[(i)<<1]) - (SIZE_SZ<<1)))
+#endif
 
 /* analog of ++bin */
 #define next_bin(b)  ((mbinptr)((char*)(b) + (sizeof(mchunkptr)<<1)))
@@ -2224,6 +2276,150 @@
 
 static struct malloc_par mp_;
 
+/* determine whether a "chunk" is actually a bin */
+#ifdef __HEAP_PROTECTION
+static inline int
+is_bin(mstate av, mchunkptr p)
+{
+  return (p >= (mchunkptr) av->bins &&
+    p < (mchunkptr) (av->bins + sizeof(av->bins))) ||
+    (p >= (mchunkptr) av->fastbins &&
+    p < (mchunkptr) (av->fastbins + sizeof(av->fastbins)));
+}
+#else
+#define is_bin(av, p) 1
+#endif
+
+#ifdef __HEAP_PROTECTION
+extern int *__heap_magic;
+
+#define chunk_magic_inuse(p) \
+  (((int) p) ^ *__heap_magic ^ (p)->size)
+
+#define chunk_magic_freed(p) \
+  (((int) p) ^ *__heap_magic ^ (p)->size ^ ((int) (p)->fd) ^ (((int) (p)->bk) << 16))
+
+#ifdef __HEAP_PROTECTION_DEBUG
+#define debug_set_chunk_magic_inuse(av, p) \
+  fprintf(stderr, "glibc: setting inuse chunk magic for %p at " __FILE__ ":%d\n", \
+    p, __LINE__); \
+  (p)->debug = __LINE__ & 0xffff; \
+  (p)->debug |= 0xf00f << 16;
+#else
+#define debug_set_chunk_magic_inuse(av, p)
+#endif
+
+#define set_chunk_magic_inuse(av, p) \
+  debug_set_chunk_magic_inuse(av, p); \
+  (p)->magic = chunk_magic_inuse(p);
+
+#ifdef __HEAP_PROTECTION_DEBUG
+#define debug_set_chunk_magic_freed(av, p) \
+  fprintf(stderr, "glibc: setting freed chunk magic for %p at " __FILE__ ":%d\n", \
+    p, __LINE__); \
+  (p)->debug = __LINE__ & 0xffff; \
+  (p)->debug |= 0x00ff << 16;
+#else
+#define debug_set_chunk_magic_freed(av, p)
+#endif
+
+#define set_chunk_magic_freed(av, p) \
+  debug_set_chunk_magic_freed(av, p); \
+  (p)->magic = chunk_magic_freed(p);
+
+#ifdef __HEAP_PROTECTION_DEBUG
+#define debug_set_chunk_magic(av, p) \
+  if (is_bin(av, p)) { \
+    fprintf(stderr, "glibc: Attempted to set magic on bin %p @ " \
+      __FILE__ ":%d\n", p, __LINE__); \
+    abort(); \
+  }
+#else
+#define debug_set_chunk_magic(av, p)
+#endif
+
+#define set_chunk_magic(av, p) \
+  if (p < (av)->top && (((char *) p) + chunksize(p)) > (char *) (av)->top) { \
+    fprintf(stderr, "glibc: p + chunksize(p) = %p + %d = %p > av->top = %p\n", \
+      p, chunksize(p), ((char *) p) + chunksize(p), (av)->top); \
+    abort(); \
+  } \
+  debug_set_chunk_magic(av, p); \
+  if (p >= av->top || !inuse(p)) { \
+    set_chunk_magic_freed(av, p); \
+  } else { \
+    set_chunk_magic_inuse(av, p); \
+  }
+
+#ifdef __HEAP_PROTECTION_DEBUG
+#define debug_chunk_magic_error(p, calc) \
+  fprintf(stderr, "glibc: Debug: %#x, set at " __FILE__ ":%d\n", \
+    (p)->debug >> 16, (p)->debug & 0xffff);
+#else
+#define debug_chunk_magic_error(p, calc)
+#endif
+
+#define chunk_magic_error(p, calc) \
+  openlog("glibc", LOG_CONS | LOG_PERROR | LOG_PID, LOG_USER); \
+  syslog(LOG_ALERT, "WARNING: Heap overflow detected at " __FILE__ ":%d" \
+    ", aborting (mem: %p, calc: %#x, stored: %#x)\n", __LINE__, \
+    p, calc, (p)->magic); \
+  debug_chunk_magic_error(p, calc); \
+  abort();
+
+#ifdef __HEAP_PROTECTION_DEBUG
+#define debug_check_chunk_magic_inuse(p) \
+  if (((p)->debug >> 16) != 0xf00f) { \
+    fprintf(stderr, "glibc: Inuse chunk set as freed chunk at " __FILE__ \
+      ":%d (%#x)\n", (p)->debug & 0xffff, (p)->debug >> 16); \
+  }
+#else
+#define debug_check_chunk_magic_inuse(p)
+#endif
+
+#define check_chunk_magic_inuse(p) \
+  debug_check_chunk_magic_inuse(p); \
+  if ((p)->magic != chunk_magic_inuse(p)) { \
+    chunk_magic_error(p, chunk_magic_inuse(p)); \
+  }
+
+#ifdef __HEAP_PROTECTION_DEBUG
+#define debug_check_chunk_magic_freed(p) \
+  if (((p)->debug >> 16) != 0xf00f) { \
+    fprintf(stderr, "glibc: Freed chunk set as inuse chunk at " __FILE__ \
+      ":%d (%#x)\n", (p)->debug & 0xffff, (p)->debug >> 16); \
+  }
+#else
+#define debug_check_chunk_magic_freed(p)
+#endif
+
+#define check_chunk_magic_freed(p) \
+  debug_check_chunk_magic_freed(p); \
+  if ((p)->magic != chunk_magic_freed(p)) { \
+    chunk_magic_error(p, chunk_magic_freed(p)); \
+  }
+
+#define check_chunk_magic(av, p) \
+  if (((char *) p) + chunksize(p) > (char *) av->top) { \
+    fprintf(stderr, "glibc: p + chunksize(p) = %p + %d = %p > av->top = %p\n", \
+      p, chunksize(p), ((char *) p) + chunksize(p), av->top); \
+    abort(); \
+  } \
+  if (inuse(p) && (p)->magic != chunk_magic_inuse(p)) { \
+    chunk_magic_error(p, chunk_magic_inuse(p)); \
+  } else if (!inuse(p) && (p)->magic != chunk_magic_freed(p)) { \
+    chunk_magic_error(p, chunk_magic_freed(p)); \
+  }
+
+#else /* ! __HEAP_PROTECTION */
+#define set_chunk_magic_inuse(av, p)
+#define set_chunk_magic_freed(av, p)
+#define set_chunk_magic(av, p)
+#define check_chunk_magic_inuse(p)
+#define check_chunk_magic_freed(p)
+#define check_chunk_magic(av, p)
+#endif
+
 /*
   Initialize a malloc_state struct.
 
@@ -2405,6 +2601,13 @@
   INTERNAL_SIZE_T sz = p->size & ~(PREV_INUSE|NON_MAIN_ARENA);
   mchunkptr next = chunk_at_offset(p, sz);
 
+#ifdef __HEAP_PROTECTION
+  if (p->magic != chunk_magic_freed(p)) {
+    fprintf(stderr, "glibc: Free chunk with incorrect magic\n");
+    chunk_magic_error(p, chunk_magic_freed(p));
+  }
+#endif
+
   do_check_chunk(av, p);
 
   /* Chunk must claim to be free ... */
@@ -2442,6 +2645,13 @@
 {
   mchunkptr next;
 
+#ifdef __HEAP_PROTECTION
+  if (p->magic != chunk_magic_inuse(p)) {
+    fprintf(stderr, "glibc: Inuse chunk with incorrect magic\n");
+    chunk_magic_error(p, chunk_magic_inuse(p));
+  }
+#endif
+
   do_check_chunk(av, p);
 
   if (chunk_is_mmapped(p))
@@ -2706,6 +2916,9 @@
 
   size_t          pagemask  = mp_.pagesize - 1;
 
+#ifdef __HEAP_PROTECTION_DEBUG
+  fprintf(stderr, "glibc: executing sysmalloc()\n");
+#endif
 
 #if HAVE_MMAP
 
@@ -2769,8 +2982,8 @@
           mp_.max_total_mem = sum;
 #endif
 
+        set_chunk_magic_inuse(av, p);
         check_chunk(av, p);
-
         return chunk2mem(p);
       }
     }
@@ -2819,6 +3032,7 @@
 #endif
       set_head(old_top, (((char *)old_heap + old_heap->size) - (char *)old_top)
 	       | PREV_INUSE);
+      set_chunk_magic_freed(av, old_top);
     }
     else if ((heap = new_heap(nb + (MINSIZE + sizeof(*heap)), mp_.top_pad))) {
       /* Use a newly allocated heap.  */
@@ -2833,6 +3047,7 @@
       /* Set up the new top.  */
       top(av) = chunk_at_offset(heap, sizeof(*heap));
       set_head(top(av), (heap->size - sizeof(*heap)) | PREV_INUSE);
+      set_chunk_magic_freed(av, top(av));
 
       /* Setup fencepost and free the old top chunk. */
       /* The fencepost takes at least MINSIZE bytes, because it might
@@ -2841,14 +3056,18 @@
       old_size -= MINSIZE;
       set_head(chunk_at_offset(old_top, old_size + 2*SIZE_SZ), 0|PREV_INUSE);
       if (old_size >= MINSIZE) {
-	set_head(chunk_at_offset(old_top, old_size), (2*SIZE_SZ)|PREV_INUSE);
-	set_foot(chunk_at_offset(old_top, old_size), (2*SIZE_SZ));
-	set_head(old_top, old_size|PREV_INUSE|NON_MAIN_ARENA);
-	_int_free(av, chunk2mem(old_top));
+        set_head(chunk_at_offset(old_top, old_size), (2*SIZE_SZ)|PREV_INUSE);
+        set_foot(chunk_at_offset(old_top, old_size), (2*SIZE_SZ));
+        set_head(old_top, old_size|PREV_INUSE|NON_MAIN_ARENA);
+        set_chunk_magic_inuse(av, old_top);
+        _int_free(av, chunk2mem(old_top));
       } else {
-	set_head(old_top, (old_size + 2*SIZE_SZ)|PREV_INUSE);
-	set_foot(old_top, (old_size + 2*SIZE_SZ));
+        set_head(old_top, (old_size + 2*SIZE_SZ)|PREV_INUSE);
+        set_foot(old_top, (old_size + 2*SIZE_SZ));
+        set_chunk_magic_inuse(av, old_top);
       }
+      set_chunk_magic_freed(av, chunk_at_offset(old_top, old_size));
+      set_chunk_magic_freed(av, chunk_at_offset(old_top, old_size + 2 * SIZE_SZ));
     }
 
   } else { /* av == main_arena */
@@ -2941,8 +3160,10 @@
       If MORECORE extends previous space, we can likewise extend top size.
     */
 
-    if (brk == old_end && snd_brk == (char*)(MORECORE_FAILURE))
+    if (brk == old_end && snd_brk == (char*)(MORECORE_FAILURE)) {
       set_head(old_top, (size + old_size) | PREV_INUSE);
+      set_chunk_magic_freed(av, old_top);
+    }
 
     else if (contiguous(av) && old_size && brk < old_end) {
       /* Oops!  Someone else killed our space..  Can't touch anything.  */
@@ -2971,7 +3192,7 @@
     else {
       /* Count foreign sbrk as system_mem.  */
       if (old_size)
-	av->system_mem += brk - old_end;
+        av->system_mem += brk - old_end;
       front_misalign = 0;
       end_misalign = 0;
       correction = 0;
@@ -3045,6 +3266,7 @@
       if (snd_brk != (char*)(MORECORE_FAILURE)) {
         av->top = (mchunkptr)aligned_brk;
         set_head(av->top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
+        set_chunk_magic_freed(av, av->top);
         av->system_mem += correction;
 
         /*
@@ -3077,6 +3299,8 @@
           chunk_at_offset(old_top, old_size + 2*SIZE_SZ)->size =
             (2*SIZE_SZ)|PREV_INUSE;
 
+          set_chunk_magic_inuse(av, old_top);
+
           /* If possible, release the rest. */
           if (old_size >= MINSIZE) {
             _int_free(av, chunk2mem(old_top));
@@ -3112,6 +3336,8 @@
     av->top = remainder;
     set_head(p, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0));
     set_head(remainder, remainder_size | PREV_INUSE);
+    set_chunk_magic_inuse(av, p);
+    set_chunk_magic_freed(av, remainder);
     check_malloced_chunk(av, p, nb);
     return chunk2mem(p);
   }
@@ -3144,6 +3370,10 @@
   char* new_brk;         /* address returned by post-check sbrk call */
   size_t pagesz;
 
+#ifdef __HEAP_PROTECTION_DEBUG
+  fprintf(stderr, "glibc: executing systrim()\n");
+#endif
+
   pagesz = mp_.pagesize;
   top_size = chunksize(av->top);
 
@@ -3172,7 +3402,7 @@
       MORECORE(-extra);
       /* Call the `morecore' hook if necessary.  */
       if (__after_morecore_hook)
-	(*__after_morecore_hook) ();
+        (*__after_morecore_hook) ();
       new_brk = (char*)(MORECORE(0));
 
       if (new_brk != (char*)MORECORE_FAILURE) {
@@ -3182,6 +3412,7 @@
           /* Success. Adjust top. */
           av->system_mem -= released;
           set_head(av->top, (top_size - released) | PREV_INUSE);
+          set_chunk_magic_freed(av, av->top);
           check_malloc_state(av);
           return 1;
         }
@@ -3312,6 +3543,7 @@
     (void)mutex_unlock(&ar_ptr->mutex);
   assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||
 	 ar_ptr == arena_for_chunk(mem2chunk(victim)));
+
   return victim;
 }
 
@@ -3342,6 +3574,7 @@
 #endif
 
   ar_ptr = arena_for_chunk(p);
+
 #if THREAD_STATS
   if(!mutex_trylock(&ar_ptr->mutex))
     ++(ar_ptr->stat_lock_direct);
@@ -3609,12 +3842,20 @@
      contents have an odd number of INTERNAL_SIZE_T-sized words;
      minimally 3.  */
   d = (INTERNAL_SIZE_T*)mem;
+#ifdef __HEAP_PROTECTION
+  clearsize = csz - 4 * SIZE_SZ;
+#else
   clearsize = csz - SIZE_SZ;
+#endif
   nclears = clearsize / sizeof(INTERNAL_SIZE_T);
   assert(nclears >= 3);
 
-  if (nclears > 9)
+#ifdef __HEAP_PROTECTION
+  MALLOC_ZERO(d, clearsize);
+#else /* !__HEAP_PROTECTION */
+  if (nclears > 9) {
     MALLOC_ZERO(d, clearsize);
+  }
 
   else {
     *(d+0) = 0;
@@ -3624,15 +3865,16 @@
       *(d+3) = 0;
       *(d+4) = 0;
       if (nclears > 6) {
-	*(d+5) = 0;
-	*(d+6) = 0;
-	if (nclears > 8) {
-	  *(d+7) = 0;
-	  *(d+8) = 0;
-	}
+        *(d+5) = 0;
+        *(d+6) = 0;
+        if (nclears > 8) {
+          *(d+7) = 0;
+          *(d+8) = 0;
+        }
       }
     }
   }
+#endif /* __HEAP_PROTECTION */
 
   return mem;
 }
@@ -3756,6 +3998,8 @@
     aligned.
   */
 
+  check_malloc_state(av);
+
   checked_request2size(bytes, nb);
 
   /*
@@ -3768,6 +4012,7 @@
     fb = &(av->fastbins[(fastbin_index(nb))]);
     if ( (victim = *fb) != 0) {
       *fb = victim->fd;
+      set_chunk_magic_inuse(av, victim);
       check_remalloced_chunk(av, victim, nb);
       return chunk2mem(victim);
     }
@@ -3793,9 +4038,14 @@
         set_inuse_bit_at_offset(victim, nb);
         bin->bk = bck;
         bck->fd = bin;
+        if (!is_bin(av, bck)) {
+          set_chunk_magic(av, bck);
+        }
 
         if (av != &main_arena)
-	  victim->size |= NON_MAIN_ARENA;
+          victim->size |= NON_MAIN_ARENA;
+        set_chunk_magic_inuse(av, victim);
+        set_chunk_magic(av, chunk_at_offset(victim, nb));
         check_malloced_chunk(av, victim, nb);
         return chunk2mem(victim);
       }
@@ -3835,6 +4085,9 @@
   for(;;) {
 
     while ( (victim = unsorted_chunks(av)->bk) != unsorted_chunks(av)) {
+      /* Perform check of the victim here to prevent size field exploits */
+      check_chunk_magic_freed(victim);
+
       bck = victim->bk;
       size = chunksize(victim);
 
@@ -3859,10 +4112,12 @@
         remainder->bk = remainder->fd = unsorted_chunks(av);
 
         set_head(victim, nb | PREV_INUSE |
-		 (av != &main_arena ? NON_MAIN_ARENA : 0));
+          (av != &main_arena ? NON_MAIN_ARENA : 0));
         set_head(remainder, remainder_size | PREV_INUSE);
         set_foot(remainder, remainder_size);
 
+        set_chunk_magic_inuse(av, victim);
+        set_chunk_magic_freed(av, remainder);
         check_malloced_chunk(av, victim, nb);
         return chunk2mem(victim);
       }
@@ -3870,13 +4125,18 @@
       /* remove from unsorted list */
       unsorted_chunks(av)->bk = bck;
       bck->fd = unsorted_chunks(av);
+      if (!is_bin(av, bck)) {
+        set_chunk_magic(av, bck);
+      }
 
       /* Take now instead of binning if exact fit */
 
       if (size == nb) {
         set_inuse_bit_at_offset(victim, size);
-	if (av != &main_arena)
-	  victim->size |= NON_MAIN_ARENA;
+        if (av != &main_arena)
+          victim->size |= NON_MAIN_ARENA;
+        set_chunk_magic_inuse(av, victim);
+        set_chunk_magic(av, chunk_at_offset(victim, size));
         check_malloced_chunk(av, victim, nb);
         return chunk2mem(victim);
       }
@@ -3895,20 +4155,20 @@
 
         /* maintain large bins in sorted order */
         if (fwd != bck) {
-	  /* Or with inuse bit to speed comparisons */
+          /* Or with inuse bit to speed comparisons */
           size |= PREV_INUSE;
           /* if smaller than smallest, bypass loop below */
-	  assert((bck->bk->size & NON_MAIN_ARENA) == 0);
+          assert((bck->bk->size & NON_MAIN_ARENA) == 0);
           if ((unsigned long)(size) <= (unsigned long)(bck->bk->size)) {
             fwd = bck;
             bck = bck->bk;
           }
           else {
-	    assert((fwd->size & NON_MAIN_ARENA) == 0);
+            assert((fwd->size & NON_MAIN_ARENA) == 0);
             while ((unsigned long)(size) < (unsigned long)(fwd->size)) {
               fwd = fwd->fd;
-	      assert((fwd->size & NON_MAIN_ARENA) == 0);
-	    }
+              assert((fwd->size & NON_MAIN_ARENA) == 0);
+            }
             bck = fwd->bk;
           }
         }
@@ -3919,6 +4179,14 @@
       victim->fd = fwd;
       fwd->bk = victim;
       bck->fd = victim;
+
+      set_chunk_magic(av, victim);
+      if (!is_bin(av, bck)) {
+        set_chunk_magic(av, bck);
+      }
+      if (!is_bin(av, fwd)) {
+        set_chunk_magic(av, fwd);
+      }
     }
 
     /*
@@ -3940,13 +4208,22 @@
           victim = victim->bk;
 
         remainder_size = size - nb;
+        check_chunk_magic_freed(victim);
         unlink(victim, bck, fwd);
+        if (!is_bin(av, bck)) {
+          set_chunk_magic(av, bck);
+        }
+        if (!is_bin(av, fwd)) {
+          set_chunk_magic(av, fwd);
+        }
 
         /* Exhaust */
         if (remainder_size < MINSIZE)  {
           set_inuse_bit_at_offset(victim, size);
-	  if (av != &main_arena)
-	    victim->size |= NON_MAIN_ARENA;
+          if (av != &main_arena)
+            victim->size |= NON_MAIN_ARENA;
+          set_chunk_magic_inuse(av, victim);
+          set_chunk_magic(av, chunk_at_offset(victim, size));
           check_malloced_chunk(av, victim, nb);
           return chunk2mem(victim);
         }
@@ -3956,9 +4233,11 @@
           unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
           remainder->bk = remainder->fd = unsorted_chunks(av);
           set_head(victim, nb | PREV_INUSE |
-		   (av != &main_arena ? NON_MAIN_ARENA : 0));
+            (av != &main_arena ? NON_MAIN_ARENA : 0));
           set_head(remainder, remainder_size | PREV_INUSE);
           set_foot(remainder, remainder_size);
+          set_chunk_magic_inuse(av, victim);
+          set_chunk_magic_freed(av, remainder);
           check_malloced_chunk(av, victim, nb);
           return chunk2mem(victim);
         }
@@ -4021,15 +4300,21 @@
         remainder_size = size - nb;
 
         /* unlink */
+        check_chunk_magic_freed(victim);
         bck = victim->bk;
         bin->bk = bck;
         bck->fd = bin;
+        if (!is_bin(av, bck)) {
+          set_chunk_magic(av, bck);
+        }
 
         /* Exhaust */
         if (remainder_size < MINSIZE) {
           set_inuse_bit_at_offset(victim, size);
-	  if (av != &main_arena)
-	    victim->size |= NON_MAIN_ARENA;
+          if (av != &main_arena)
+            victim->size |= NON_MAIN_ARENA;
+          set_chunk_magic_inuse(av, victim);
+          set_chunk_magic(av, chunk_at_offset(victim, size));
           check_malloced_chunk(av, victim, nb);
           return chunk2mem(victim);
         }
@@ -4045,9 +4330,11 @@
             av->last_remainder = remainder;
 
           set_head(victim, nb | PREV_INUSE |
-		   (av != &main_arena ? NON_MAIN_ARENA : 0));
+            (av != &main_arena ? NON_MAIN_ARENA : 0));
           set_head(remainder, remainder_size | PREV_INUSE);
           set_foot(remainder, remainder_size);
+          set_chunk_magic_inuse(av, victim);
+          set_chunk_magic_freed(av, remainder);
           check_malloced_chunk(av, victim, nb);
           return chunk2mem(victim);
         }
@@ -4080,7 +4367,8 @@
       set_head(victim, nb | PREV_INUSE |
 	       (av != &main_arena ? NON_MAIN_ARENA : 0));
       set_head(remainder, remainder_size | PREV_INUSE);
-
+      set_chunk_magic_inuse(av, victim);
+      set_chunk_magic_freed(av, remainder);
       check_malloced_chunk(av, victim, nb);
       return chunk2mem(victim);
     }
@@ -4100,8 +4388,10 @@
     /*
        Otherwise, relay to handle system-dependent cases
     */
-    else
-      return sYSMALLOc(nb, av);
+    else {
+      victim = sYSMALLOc(nb, av);
+      return victim;
+    }
   }
 }
 
@@ -4125,9 +4415,13 @@
 
   /* free(0) has no effect */
   if (mem != 0) {
+    check_malloc_state(av);
+
     p = mem2chunk(mem);
     size = chunksize(p);
 
+    check_chunk_magic_inuse(p);
+
     check_inuse_chunk(av, p);
 
     /*
@@ -4150,6 +4444,8 @@
       fb = &(av->fastbins[fastbin_index(size)]);
       p->fd = *fb;
       *fb = p;
+
+      set_chunk_magic_inuse(av, p);
     }
 
     /*
@@ -4166,19 +4462,41 @@
         prevsize = p->prev_size;
         size += prevsize;
         p = chunk_at_offset(p, -((long) prevsize));
+        check_chunk_magic(av, p);
         unlink(p, bck, fwd);
+        if (!is_bin(av, bck)) {
+          set_chunk_magic(av, bck);
+        }
+        if (!is_bin(av, fwd)) {
+          set_chunk_magic(av, fwd);
+        }
       }
 
       if (nextchunk != av->top) {
+        /*
+         * Perform check here, because a overwritten size field may
+         * result in an exploitation opportunity before the unlink...
+         */
+        check_chunk_magic(av, nextchunk);
+
         /* get and clear inuse bit */
         nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
 
         /* consolidate forward */
         if (!nextinuse) {
+          /* checked above */
           unlink(nextchunk, bck, fwd);
+          if (!is_bin(av, bck)) {
+            set_chunk_magic(av, bck);
+          }
+          if (!is_bin(av, fwd)) {
+            set_chunk_magic(av, fwd);
+          }
           size += nextsize;
-        } else
-	  clear_inuse_bit_at_offset(nextchunk, 0);
+        } else {
+          clear_inuse_bit_at_offset(nextchunk, 0);
+          set_chunk_magic_inuse(av, nextchunk);
+        }
 
         /*
           Place the chunk in unsorted chunk list. Chunks are
@@ -4193,10 +4511,17 @@
         bck->fd = p;
         fwd->bk = p;
 
+        if (!is_bin(av, fwd)) {
+          set_chunk_magic(av, fwd);
+        }
+
         set_head(p, size | PREV_INUSE);
         set_foot(p, size);
 
+        set_chunk_magic_freed(av, p);
         check_free_chunk(av, p);
+
+        check_malloc_state(av);
       }
 
       /*
@@ -4208,6 +4533,7 @@
         size += nextsize;
         set_head(p, size | PREV_INUSE);
         av->top = p;
+        set_chunk_magic_freed(av, p);
         check_chunk(av, p);
       }
 
@@ -4228,20 +4554,19 @@
         if (have_fastchunks(av))
           malloc_consolidate(av);
 
-	if (av == &main_arena) {
+        if (av == &main_arena) {
 #ifndef MORECORE_CANNOT_TRIM
-	  if ((unsigned long)(chunksize(av->top)) >=
-	      (unsigned long)(mp_.trim_threshold))
-	    sYSTRIm(mp_.top_pad, av);
+          if ((unsigned long)(chunksize(av->top)) >= (unsigned long)(mp_.trim_threshold))
+            sYSTRIm(mp_.top_pad, av);
 #endif
-	} else {
-	  /* Always try heap_trim(), even if the top chunk is not
+        } else {
+          /* Always try heap_trim(), even if the top chunk is not
              large, because the corresponding heap might go away.  */
-	  heap_info *heap = heap_for_ptr(top(av));
+          heap_info *heap = heap_for_ptr(top(av));
 
-	  assert(heap->ar_ptr == av);
-	  heap_trim(heap, mp_.top_pad);
-	}
+          assert(heap->ar_ptr == av);
+          heap_trim(heap, mp_.top_pad);
+        }
       }
 
     }
@@ -4308,6 +4633,10 @@
     yet been initialized, in which case do so below
   */
 
+#ifdef __HEAP_PROTECTION_DEBUG
+  fprintf(stderr, "glibc: performing malloc consolidation\n");
+#endif
+
   if (av->max_fast != 0) {
     clear_fastchunks(av);
 
@@ -4328,7 +4657,9 @@
         *fb = 0;
 
         do {
+          /* Fastbin chunks are marked as in-use... */
           check_inuse_chunk(av, p);
+
           nextp = p->fd;
 
           /* Slightly streamlined version of consolidation code in free() */
@@ -4340,17 +4671,33 @@
             prevsize = p->prev_size;
             size += prevsize;
             p = chunk_at_offset(p, -((long) prevsize));
+            check_chunk_magic_freed(p);
             unlink(p, bck, fwd);
+            if (!is_bin(av, bck)) {
+              set_chunk_magic(av, bck);
+            }
+            if (!is_bin(av, fwd)) {
+              set_chunk_magic(av, fwd);
+            }
           }
 
           if (nextchunk != av->top) {
+            check_chunk_magic(av, nextchunk);
             nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
 
             if (!nextinuse) {
               size += nextsize;
               unlink(nextchunk, bck, fwd);
-            } else
-	      clear_inuse_bit_at_offset(nextchunk, 0);
+              if (!is_bin(av, bck)) {
+                set_chunk_magic(av, bck);
+              }
+              if (!is_bin(av, fwd)) {
+                set_chunk_magic(av, fwd);
+              }
+            } else {
+              clear_inuse_bit_at_offset(nextchunk, 0);
+              set_chunk_magic_inuse(av, nextchunk);
+            }
 
             first_unsorted = unsorted_bin->fd;
             unsorted_bin->fd = p;
@@ -4360,12 +4707,17 @@
             p->bk = unsorted_bin;
             p->fd = first_unsorted;
             set_foot(p, size);
+            set_chunk_magic(av, p);
+            if (!is_bin(av, first_unsorted)) {
+              set_chunk_magic_freed(av, first_unsorted);
+            }
           }
 
           else {
             size += nextsize;
             set_head(p, size | PREV_INUSE);
             av->top = p;
+            set_chunk_magic_freed(av, p);
           }
 
         } while ( (p = nextp) != 0);
@@ -4408,7 +4760,6 @@
   INTERNAL_SIZE_T* s;               /* copy source */
   INTERNAL_SIZE_T* d;               /* copy destination */
 
-
 #if REALLOC_ZERO_BYTES_FREES
   if (bytes == 0) {
     _int_free(av, oldmem);
@@ -4444,7 +4795,8 @@
         set_head_size(oldp, nb | (av != &main_arena ? NON_MAIN_ARENA : 0));
         av->top = chunk_at_offset(oldp, nb);
         set_head(av->top, (newsize - nb) | PREV_INUSE);
-	check_inuse_chunk(av, oldp);
+        set_chunk_magic_inuse(av, oldp);
+        set_chunk_magic_freed(av, av->top);
         return chunk2mem(oldp);
       }
 
@@ -4454,7 +4806,14 @@
                (unsigned long)(newsize = oldsize + chunksize(next)) >=
                (unsigned long)(nb)) {
         newp = oldp;
+        check_chunk_magic(av, next);
         unlink(next, bck, fwd);
+        if (!is_bin(av, bck)) {
+          set_chunk_magic(av, bck);
+        }
+        if (!is_bin(av, fwd)) {
+          set_chunk_magic(av, fwd);
+        }
       }
 
       /* allocate, copy, free */
@@ -4486,6 +4845,9 @@
           ncopies = copysize / sizeof(INTERNAL_SIZE_T);
           assert(ncopies >= 3);
 
+#ifdef __HEAP_PROTECTION
+          MALLOC_COPY(d, s, copysize);
+#else /* !__HEAP_PROTECTION */
           if (ncopies > 9)
             MALLOC_COPY(d, s, copysize);
 
@@ -4506,6 +4868,7 @@
               }
             }
           }
+#endif /* __HEAP_PROTECTION */
 
           _int_free(av, oldmem);
           check_inuse_chunk(av, newp);
@@ -4523,6 +4886,8 @@
     if (remainder_size < MINSIZE) { /* not enough extra to split off */
       set_head_size(newp, newsize | (av != &main_arena ? NON_MAIN_ARENA : 0));
       set_inuse_bit_at_offset(newp, newsize);
+      set_chunk_magic_inuse(av, newp);
+      set_chunk_magic(av, chunk_at_offset(newp, newsize));
     }
     else { /* split remainder */
       remainder = chunk_at_offset(newp, nb);
@@ -4531,6 +4896,9 @@
 	       (av != &main_arena ? NON_MAIN_ARENA : 0));
       /* Mark remainder as inuse so free() won't complain */
       set_inuse_bit_at_offset(remainder, remainder_size);
+      set_chunk_magic_inuse(av, newp);
+      set_chunk_magic_inuse(av, remainder);
+      set_chunk_magic(av, chunk_at_offset(remainder, remainder_size));
       _int_free(av, chunk2mem(remainder));
     }
 
@@ -4684,6 +5052,9 @@
 	     (av != &main_arena ? NON_MAIN_ARENA : 0));
     set_inuse_bit_at_offset(newp, newsize);
     set_head_size(p, leadsize | (av != &main_arena ? NON_MAIN_ARENA : 0));
+    set_chunk_magic_inuse(av, p);
+    set_chunk_magic_inuse(av, newp);
+    set_chunk_magic(av, chunk_at_offset(newp, newsize));
     _int_free(av, chunk2mem(p));
     p = newp;
 
@@ -4700,10 +5071,12 @@
       set_head(remainder, remainder_size | PREV_INUSE |
 	       (av != &main_arena ? NON_MAIN_ARENA : 0));
       set_head_size(p, nb);
+      set_chunk_magic_inuse(av, remainder);
       _int_free(av, chunk2mem(remainder));
     }
   }
 
+  set_chunk_magic_inuse(av, p);
   check_inuse_chunk(av, p);
   return chunk2mem(p);
 }
@@ -4897,6 +5270,7 @@
     marray = (Void_t**) (chunk2mem(array_chunk));
     set_head(array_chunk, (remainder_size - contents_size) | size_flags);
     remainder_size = contents_size;
+    set_chunk_magic_inuse(av, array_chunk);
   }
 
   /* split out elements */
@@ -4909,10 +5283,12 @@
         size = request2size(sizes[i]);
       remainder_size -= size;
       set_head(p, size | size_flags);
+      set_chunk_magic_inuse(av, p);
       p = chunk_at_offset(p, size);
     }
     else { /* the final element absorbs any overallocation slop */
       set_head(p, remainder_size | size_flags);
+      set_chunk_magic_inuse(av, p);
       break;
     }
   }
Index: glibc/stdlib/tst-random.c
===================================================================
RCS file: /data/cvs/heapguard/glibc/stdlib/tst-random.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- glibc/stdlib/tst-random.c	10 Jun 2003 23:58:31 -0000	1.1.1.1
+++ glibc/stdlib/tst-random.c	3 Dec 2003 01:46:06 -0000	1.2
@@ -55,6 +55,11 @@
   int s;			/* sequence index */
   int i;			/* element index */
 
+#ifdef __HEAP_PROTECTION
+  /* Get initial heap protection srandom() call out of the way */
+  free(malloc(1024));
+#endif
+
   printf ("Begining random package test using %d sequences of length %d.\n",
 	  nseq, nrnd);
 
