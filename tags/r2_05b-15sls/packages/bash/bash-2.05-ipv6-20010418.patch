diff -urN bash-2.05.org/config.h.in bash-2.05/config.h.in
--- bash-2.05.org/config.h.in	Wed Apr 18 23:07:48 2001
+++ bash-2.05/config.h.in	Wed Apr 18 23:38:04 2001
@@ -402,6 +402,9 @@
 /* Define if you have the dup2 function.  */
 #undef HAVE_DUP2
 
+/* Define if you have the getaddrinfo function. */
+#undef HAVE_GETADDRINFO
+
 /* Define if you have the getcwd function.  */
 #undef HAVE_GETCWD
 
diff -urN bash-2.05.org/configure.in bash-2.05/configure.in
--- bash-2.05.org/configure.in	Wed Apr 18 23:07:48 2001
+++ bash-2.05/configure.in	Wed Apr 18 23:38:04 2001
@@ -478,7 +478,7 @@
 		setlinebuf setlocale strchr strerror strtod strtol \
 		strtoul tcgetattr uname sysconf ulimit times tzset \
 		siginterrupt memmove ttyname gethostbyname getservbyname \
-		inet_aton strpbrk setvbuf pathconf)
+		inet_aton strpbrk setvbuf pathconf getaddrinfo)
 
 dnl checks for locale functions
 AC_CHECK_HEADERS(libintl.h)
diff -urN bash-2.05.org/lib/sh/netopen.c bash-2.05/lib/sh/netopen.c
--- bash-2.05.org/lib/sh/netopen.c	Wed Apr 18 23:07:47 2001
+++ bash-2.05/lib/sh/netopen.c	Wed Apr 18 23:39:17 2001
@@ -54,6 +54,8 @@
 extern int errno;
 #endif
 
+#ifndef HAVE_GETADDRINFO
+
 #if !defined (HAVE_INET_ATON)
 extern int inet_aton ();
 #endif
@@ -93,6 +95,7 @@
   return 0;
   
 }
+#endif
 
 /* Return 1 if SERV is a valid port number and stuff the converted value into
    PP in network byte order. */   
@@ -137,10 +140,59 @@
      char *host, *serv;
      int typ;
 {
+  int s;
+#ifdef HAVE_GETADDRINFO
+  struct addrinfo hints, *res, *res0;
+  int gerr;
+
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = AF_UNSPEC;
+  hints.ai_socktype = (typ == 't') ? SOCK_STREAM : SOCK_DGRAM;
+  gerr = getaddrinfo(host, serv, &hints, &res0);
+  if (gerr) {
+      switch (gerr) {
+	  case EAI_SERVICE:
+	      internal_error("%s: invalid service", serv);
+	      break;
+	  default:
+	      internal_error ("%s: host unknown", host);
+	      break;
+      }
+      return (-1);
+  }
+
+  for (res = res0; res; res = res->ai_next) {
+      s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+      if (s < 0) {
+	  if (res->ai_next)
+	      continue;
+	  else {
+	      sys_error ("socket");
+	      freeaddrinfo(res0);
+	      return (-1);
+	  }
+      }
+      if (connect (s, res->ai_addr, res->ai_addrlen) < 0) {
+	  if (res->ai_next) {
+	      close(s);
+	      continue;
+	  } else {
+	      sys_error("connect");
+	      close(s);
+	      freeaddrinfo(res0);
+	      return (-1);
+	  }
+      }
+      break;
+  }
+  freeaddrinfo(res0);
+  
+#else
+  
   struct in_addr ina;
   struct sockaddr_in sin;
   unsigned short p;
-  int s, e;
+  int e;
   char **cp;
 
   if (_getaddr(host, &ina) == 0)
@@ -177,6 +229,7 @@
       errno = e;
       return (-1);
     }
+#endif
 
   return(s);
 }
