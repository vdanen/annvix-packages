diff -ruN bash-2.05.orig/lib/readline/bind.c bash-2.05/lib/readline/bind.c
--- bash-2.05.orig/lib/readline/bind.c	Tue Mar  6 00:10:07 2001
+++ bash-2.05/lib/readline/bind.c	Wed Jun 20 16:04:41 2001
@@ -1257,6 +1257,9 @@
 #if defined (VISIBLE_STATS)
   { "visible-stats",		&rl_visible_stats,		0 },
 #endif /* VISIBLE_STATS */
+#if defined (HANDLE_MULTIBYTE)
+  { "byte-oriented",            &rl_byte_oriented,              0},
+#endif /* HANDLE_MULTIBYTE  */
   { (char *)NULL, (int *)NULL }
 };
 
diff -ruN bash-2.05.orig/lib/readline/complete.c bash-2.05/lib/readline/complete.c
--- bash-2.05.orig/lib/readline/complete.c	Wed Feb 14 21:47:18 2001
+++ bash-2.05/lib/readline/complete.c	Wed Jun 20 16:04:41 2001
@@ -584,7 +584,11 @@
       /* We didn't find an unclosed quoted substring upon which to do
          completion, so use the word break characters to find the
          substring on which to complete. */
+#if defined (HANDLE_MULTIBYTE)
+      while (rl_point = _rl_find_previous_char_started_byte (rl_line_buffer,rl_point))
+#else
       while (--rl_point)
+#endif /* HANDLE_MULTIBYTE */
 	{
 	  scan = rl_line_buffer[rl_point];
 
@@ -756,6 +760,10 @@
 {
   register int i, c1, c2, si;
   int low;		/* Count of max-matched characters. */
+#if defined (HANDLE_MULTIBYTE)
+  mbstate_t ps1;
+  mbstate_t ps2;
+#endif  
 
   /* If only one match, just use that.  Otherwise, compare each
      member of the list with the next, finding out where they
@@ -769,12 +777,37 @@
 
   for (i = 1, low = 100000; i < matches; i++)
     {
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+          memset(&ps1,0,sizeof(mbstate_t));
+          memset(&ps2,0,sizeof(mbstate_t));
+        }
+#endif
       if (_rl_completion_case_fold)
 	{
 	  for (si = 0;
 	       (c1 = _rl_to_lower(match_list[i][si])) &&
 	       (c2 = _rl_to_lower(match_list[i + 1][si]));
 	       si++)
+#if defined (HANDLE_MULTIBYTE)
+	    if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	      {
+		int v;
+                wchar_t wc1;
+                wchar_t wc2;
+                v = mbrtowc(&wc1,match_list[i]+si,strlen(match_list[i]+si),&ps1);
+                mbrtowc(&wc2,match_list[i+1]+si,strlen(match_list[i+1]+si),&ps2);
+
+                wc1 = towlower(wc1);
+                wc2 = towlower(wc2);
+                if ( wc1 != wc2 )
+		  break;
+		else if (v > 1)
+		  si += v-1;
+	      }
+	    else
+#endif /* HANDLE_MULTIBYTE */
 	    if (c1 != c2)
 	      break;
 	}
@@ -784,6 +817,18 @@
 	       (c1 = match_list[i][si]) &&
 	       (c2 = match_list[i + 1][si]);
 	       si++)
+#if defined (HANDLE_MULTIBYTE)
+	    if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	      {
+		int v;
+                mbstate_t ps_back = ps1;
+		if (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))
+		  break;
+		else if ((v = _rl_get_char_len (&match_list[i][si],&ps_back)) > 1)
+		  si += v-1;
+	      }
+	    else
+#endif /* HANDLE_MULTIBYTE */
 	    if (c1 != c2)
 	      break;
 	}
diff -ruN bash-2.05.orig/lib/readline/display.c bash-2.05/lib/readline/display.c
--- bash-2.05.orig/lib/readline/display.c	Sat Feb  3 03:25:10 2001
+++ bash-2.05/lib/readline/display.c	Wed Mar  6 20:09:52 2002
@@ -65,8 +65,16 @@
 static void update_line __P((char *, char *, int, int, int, int));
 static void space_to_eol __P((int));
 static void delete_chars __P((int));
+#if defined (HANDLE_MULTIBYTE)
+static void insert_some_chars __P((char *, int, int));
+#else
 static void insert_some_chars __P((char *, int));
+#endif
 static void cr __P((void));
+#if defined (HANDLE_MULTIBYTE)
+static int _rl_col_width __P((const char *, int, int));
+static int *_rl_wrapped_line;
+#endif
 
 static int *inv_lbreaks, *vis_lbreaks;
 static int inv_lbsize, vis_lbsize;
@@ -359,6 +367,9 @@
       inv_lbsize = vis_lbsize = 256;
       inv_lbreaks = (int *)xmalloc (inv_lbsize * sizeof (int));
       vis_lbreaks = (int *)xmalloc (vis_lbsize * sizeof (int));
+#if defined (HANDLE_MULTIBYTE)
+      _rl_wrapped_line = (int *)xmalloc (vis_lbsize * sizeof (int));
+#endif      
       inv_lbreaks[0] = vis_lbreaks[0] = 0;
     }
 }
@@ -372,6 +383,13 @@
   int c_pos, inv_botlin, lb_botlin, lb_linenum;
   int newlines, lpos, temp;
   char *prompt_this_line;
+#if defined(HANDLE_MULTIBYTE)
+  wchar_t wc;
+  size_t wc_bytes;
+  int wc_width;
+  mbstate_t ps;
+  int _rl_wrapped_multicolumn = 0;
+#endif  
 
   if (!readline_echoing_p)
     return;
@@ -473,6 +491,24 @@
 	  } \
       } while (0)
 	  
+#if defined (HANDLE_MULTIBYTE)
+#define CHECK_LPOS() \
+      do { \
+	lpos++; \
+	if (lpos >= _rl_screenwidth) \
+	  { \
+	    if (newlines >= (inv_lbsize - 2)) \
+	      { \
+		inv_lbsize *= 2; \
+		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
+		_rl_wrapped_line = (int *)xrealloc (_rl_wrapped_line, inv_lbsize * sizeof (int)); \
+	      } \
+	    inv_lbreaks[++newlines] = out; \
+            _rl_wrapped_line[newlines] = _rl_wrapped_multicolumn; \
+	    lpos = 0; \
+	  } \
+      } while (0)
+#else  
 #define CHECK_LPOS() \
       do { \
 	lpos++; \
@@ -487,10 +523,14 @@
 	    lpos = 0; \
 	  } \
       } while (0)
+#endif
 
   /* inv_lbreaks[i] is where line i starts in the buffer. */
   inv_lbreaks[newlines = 0] = 0;
   lpos = out - wrap_offset;
+#if defined (HANDLE_MULTIBYTE)
+   memset(_rl_wrapped_line,0,vis_lbsize); 
+#endif                                          
 
   /* prompt_invis_chars_first_line is the number of invisible characters in
      the first physical line of the prompt.
@@ -523,10 +563,48 @@
      It maintains an array of line breaks for display (inv_lbreaks).
      This handles expanding tabs for display and displaying meta characters. */
   lb_linenum = 0;
+#if defined (HANDLE_MULTIBYTE)
+  in = 0;
+  if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+    {
+      memset(&ps,0,sizeof(mbstate_t));
+      wc_bytes = mbrtowc(&wc,rl_line_buffer,rl_end,&ps);
+    }
+  else
+    wc_bytes = 1;
+  while(in<rl_end)
+#else  
   for (in = 0; in < rl_end; in++)
+#endif      
     {
       c = (unsigned char)rl_line_buffer[in];
 
+#if defined (HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+          if( (size_t)(-1) == wc_bytes || (size_t)(-2) == wc_bytes)
+            {
+              /* bytes sequence is invalid or shorted. 
+                 assume that a first byte represent a character */
+              wc_bytes = 1;
+              /* assume that a character occupy a single column */
+              wc_width = 1;
+              memset(&ps,0,sizeof(mbstate_t));
+            }
+          else if ( (size_t)(0) == wc_bytes)
+            /* found '\0' character */
+            break;
+          else
+            {
+              temp = wcwidth(wc);
+              if(temp < 0)
+                wc_width = 1;
+              else
+                wc_width = temp;
+            }
+        }
+#endif
+      
       if (out + 8 >= line_size)		/* XXX - 8 for \t */
 	{
 	  line_size *= 2;
@@ -540,8 +618,11 @@
 	  c_pos = out;
 	  lb_linenum = newlines;
 	}
-
+#if defined (HANDLE_MULTIBYTE)
+      if (META_CHAR (c) && !_rl_output_meta_chars)
+#else      
       if (META_CHAR (c))
+#endif        
 	{
 	  if (_rl_output_meta_chars == 0)
 	    {
@@ -610,9 +691,56 @@
 	}
       else
 	{
+
+#if defined (HANDLE_MULTIBYTE)
+          if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+            {
+              int i;
+              /* reset */
+              _rl_wrapped_multicolumn = 0;
+          
+              if( _rl_screenwidth < lpos + wc_width ) {
+                for(i=lpos;i<_rl_screenwidth;i++)
+                  {
+                    /* This spaces will be removed in update_line() */
+                    line[out++] = ' ';
+                    _rl_wrapped_multicolumn++;
+                    CHECK_LPOS();
+                  }
+              }
+              if (in == rl_point)
+                {
+                  c_pos = out;
+                  lb_linenum = newlines;
+                }
+              for(i=in;i<in+wc_bytes;i++)
+                {
+                  line[out++] = rl_line_buffer[i];
+                }
+              for(i=0;i<wc_width;i++)
+                CHECK_LPOS();
+            }
+          else
+            {
+              line[out++] = c;
+              CHECK_LPOS();
+            }
+#else
 	  line[out++] = c;
 	  CHECK_LPOS();
+#endif          
 	}
+#if defined (HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+          in += wc_bytes;
+          wc_bytes = mbrtowc(&wc,rl_line_buffer+in,rl_end-in,&ps);
+        }
+      else
+        {
+          in++;
+        }
+#endif      
     }
   line[out] = '\0';
   if (c_pos < 0)
@@ -650,7 +778,13 @@
 	     only display a screenful.  We should display the last screen,
 	     not the first.  */
 	  if (out >= _rl_screenchars)
-	    out = _rl_screenchars - 1;
+#if defined (HANDLE_MULTIBYTE)
+            if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+              out = _rl_find_previous_char_started_byte(line,_rl_screenchars);
+            else
+#endif            
+              out = _rl_screenchars - 1;
+
 
 	  /* The first line is at character position 0 in the buffer.  The
 	     second and subsequent lines start at inv_lbreaks[N], offset by
@@ -736,6 +870,11 @@
 		tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif
 	      _rl_output_some_chars (local_prompt, nleft);
+#if defined(HANDLE_MULTIBYTE)
+              if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+                  _rl_last_c_pos = _rl_col_width(local_prompt,0,nleft);
+              else
+#endif              
 	      _rl_last_c_pos = nleft;
 	    }
 
@@ -752,10 +891,21 @@
 	  if (wrap_offset && cursor_linenum == 0 && nleft < _rl_last_c_pos)
 	    {
 	      _rl_backspace (_rl_last_c_pos - nleft);
+#if defined(HANDLE_MULTIBYTE)
+              if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+                  _rl_last_c_pos = _rl_col_width(&visible_line[pos],0,nleft);
+              else
+#endif              
 	      _rl_last_c_pos = nleft;
 	    }
 
+#if defined(HANDLE_MULTIBYTE)
+          if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+                _rl_move_cursor_relative (nleft, &invisible_line[pos]);
+          else 
+#endif          
 	  if (nleft != _rl_last_c_pos)
+            
 	    _rl_move_cursor_relative (nleft, &invisible_line[pos]);
 	}
     }
@@ -900,6 +1050,12 @@
   register char *ofd, *ols, *oe, *nfd, *nls, *ne;
   int temp, lendiff, wsatend, od, nd;
   int current_invis_chars;
+#if defined (HANDLE_MULTIBYTE)
+  int col_lendiff, col_temp;
+  mbstate_t ps_new,ps_old;
+  int new_offset,old_offset;
+  int tmp;
+#endif  
 
   /* If we're at the right edge of a terminal that supports xn, we're
      ready to wrap around, so do so.  This fixes problems with knowing
@@ -910,6 +1066,57 @@
   if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
       && _rl_last_v_pos == current_line - 1)
     {
+#if defined(HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented) {
+        wchar_t wc;
+	mbstate_t ps;
+	int tempwidth;
+	int bytes;
+        size_t ret;
+
+        /*
+          This fixes only doulbe column character, but
+         if wrapped character has more than 3 columns,
+         spaces will be inserted in the string buffer.
+        */
+        if(_rl_wrapped_line[current_line] > 0)
+            _rl_clear_to_eol(_rl_wrapped_line[current_line]);
+
+        memset(&ps,0,sizeof(mbstate_t));
+        ret = mbrtowc (&wc,new,MB_CUR_MAX,&ps);
+	if (ret == (size_t)-1 || ret == (size_t)-2 ) {
+		tempwidth = 1;
+		ret = 1;
+	} else if (ret == 0) {
+		tempwidth = 0;
+	} else {
+		tempwidth = wcwidth (wc);
+	}
+	if (tempwidth > 0) {
+		int count;
+                bytes = ret;
+		for (count = 0; count < bytes; count++) 
+			putc (new[count],rl_outstream);
+		_rl_last_c_pos = tempwidth;
+		_rl_last_v_pos++;
+                memset(&ps,0,sizeof(mbstate_t));
+                ret = mbrtowc (&wc,old,MB_CUR_MAX,&ps);
+                if (ret != 0 && bytes != 0) {
+                  if(ret == (size_t)-1 || ret == (size_t)-2)
+                      memmove(old+bytes,old+1,strlen(old+1));
+                  else
+                      memmove(old+bytes,old+ret,strlen(old+ret));
+                  memcpy(old,new,bytes);
+                  }
+	} else {
+		putc (' ', rl_outstream);
+		_rl_last_c_pos = 1;
+		_rl_last_v_pos++;
+                if (old[0] && new[0])
+                    old[0] = new[0];
+	}
+      } else {	
+#endif			
       if (new[0])
 	putc (new[0], rl_outstream);
       else
@@ -918,9 +1125,31 @@
       _rl_last_v_pos++;
       if (old[0] && new[0])
 	old[0] = new[0];
+#if defined (HANDLE_MULTIBYTE)
+      }
+#endif      
     }
       
   /* Find first difference. */
+#if defined (HANDLE_MULTIBYTE)
+  if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+    {
+      memset(&ps_new,0,sizeof(mbstate_t));
+      memset(&ps_old,0,sizeof(mbstate_t));
+      new_offset = old_offset = 0;
+      for (ofd = old, nfd = new;
+           (ofd - old < omax) &&
+             *ofd && _rl_compare_chars(old,old_offset,&ps_old,
+                                       new,new_offset,&ps_new); )
+        {
+          old_offset = _rl_find_next_char_started_byte(old,old_offset,1);
+          new_offset = _rl_find_next_char_started_byte(new,new_offset,1);
+          ofd = old + old_offset;
+          nfd = new + new_offset;
+        }
+    }
+  else
+#endif 
   for (ofd = old, nfd = new;
        (ofd - old < omax) && *ofd && (*ofd == *nfd);
        ofd++, nfd++)
@@ -937,6 +1166,30 @@
     return;
 
   wsatend = 1;			/* flag for trailing whitespace */
+#if defined (HANDLE_MULTIBYTE)
+  if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+    {
+      ols = old + _rl_find_previous_char_started_byte(old,oe-old);
+      nls = new + _rl_find_previous_char_started_byte(new,ne-new);
+      while ((ols > ofd) && (nls > nfd))
+        {
+          memset(&ps_new,0,sizeof(mbstate_t));
+          memset(&ps_old,0,sizeof(mbstate_t));
+          _rl_adjust_point(old,ols-old,&ps_old);
+          _rl_adjust_point(new,nls-new,&ps_new);
+          if(!_rl_compare_chars(old,ols-old,&ps_old,
+                                new,nls-new,&ps_new))
+            break;
+          
+          if (*ols != ' ')
+            wsatend = 0;
+          ols = old + _rl_find_previous_char_started_byte(old,ols-old);
+          nls = new + _rl_find_previous_char_started_byte(new,nls-new);
+        }
+    }
+  else
+    {
+#endif  
   ols = oe - 1;			/* find last same */
   nls = ne - 1;
   while ((ols > ofd) && (nls > nfd) && (*ols == *nls))
@@ -946,17 +1199,34 @@
       ols--;
       nls--;
     }
+#if defined (HANDLE_MULTIBYTE)
+    }
+#endif  
 
   if (wsatend)
     {
       ols = oe;
       nls = ne;
     }
+#if defined (HANDLE_MULTIBYTE) /* let's for get abount state full encoding */
+  else if(!_rl_compare_chars(ols,0,NULL,nls,0,NULL))
+#else  
   else if (*ols != *nls)
+#endif      
     {
       if (*ols)			/* don't step past the NUL */
+#if defined (HANDLE_MULTIBYTE)
+        if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+          ols = old + _rl_find_next_char_started_byte(old,ols-old,1);
+        else
+#endif 
 	ols++;
       if (*nls)
+#if defined (HANDLE_MULTIBYTE)
+        if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+          nls = new + _rl_find_next_char_started_byte(new,nls-new,1);
+        else
+#endif
 	nls++;
     }
 
@@ -993,6 +1263,11 @@
       tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif
       _rl_output_some_chars (local_prompt, lendiff);
+#if defined (HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+          _rl_last_c_pos = _rl_col_width(local_prompt,0,lendiff);
+      else
+#endif
       _rl_last_c_pos = lendiff;
     }
 
@@ -1000,17 +1275,45 @@
 
   /* if (len (new) > len (old)) */
   lendiff = (nls - nfd) - (ols - ofd);
+#if defined (HANDLE_MULTIBYTE)
+  if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+    col_lendiff = _rl_col_width(new,nfd-new,nls-new) -
+      _rl_col_width(old,ofd-old,ols-old);
+  else
+    col_lendiff = lendiff;
+#endif
 
   /* If we are changing the number of invisible characters in a line, and
      the spot of first difference is before the end of the invisible chars,
      lendiff needs to be adjusted. */
   if (current_line == 0 && !_rl_horizontal_scroll_mode &&
       current_invis_chars != visible_wrap_offset)
+#if defined (HANDLE_MULTIBYTE)
+    if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+      {
+        lendiff += visible_wrap_offset - current_invis_chars;
+        col_lendiff += visible_wrap_offset - current_invis_chars;
+      }
+    else
+      {
+        lendiff += visible_wrap_offset - current_invis_chars;
+        col_lendiff = lendiff;
+      }
+#else    
     lendiff += visible_wrap_offset - current_invis_chars;
+#endif  
 
   /* Insert (diff (len (old), len (new)) ch. */
   temp = ne - nfd;
+#if defined (HANDLE_MULTIBYTE)
+  if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+    col_temp = _rl_col_width(new,nfd-new,ne-new);
+  else
+    col_temp = temp;
+  if(col_lendiff > 0)
+#else  
   if (lendiff > 0)
+#endif    
     {
       /* Non-zero if we're increasing the number of lines. */
       int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
@@ -1018,7 +1321,13 @@
 	 use the terminal's capabilities.  If we're growing the number
 	 of lines, make sure we actually cause the new line to wrap
 	 around on auto-wrapping terminals. */
+#if defined(HANDLE_MULTIBYTE)
+      if (_rl_terminal_can_insert && 
+          ((2 * col_temp) >= col_lendiff || _rl_term_IC) &&
+          (!_rl_term_autowrap || !gl))
+#else
       if (_rl_terminal_can_insert && ((2 * temp) >= lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
+#endif        
 	{
 	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
 	     _rl_horizontal_scroll_mode == 1, inserting the characters with
@@ -1027,8 +1336,13 @@
 	  if (*ols && (!_rl_horizontal_scroll_mode || _rl_last_c_pos > 0 ||
 			lendiff <= prompt_visible_length || !current_invis_chars))
 	    {
+#if defined(HANDLE_MULTIBYTE)
+	      insert_some_chars (nfd, lendiff, col_lendiff);
+	      _rl_last_c_pos += col_lendiff;
+#else
 	      insert_some_chars (nfd, lendiff);
 	      _rl_last_c_pos += lendiff;
+#endif              
 	    }
 	  else if (*ols == 0)
 	    {
@@ -1037,7 +1351,11 @@
 	      /* However, this screws up the rest of this block, which
 		 assumes you've done the insert because you can. */
 	      _rl_output_some_chars (nfd, lendiff);
+#if defined(HANDLE_MULTIBYTE)
+	      _rl_last_c_pos += col_lendiff;
+#else              
 	      _rl_last_c_pos += lendiff;
+#endif              
 	    }
 	  else
 	    {
@@ -1045,7 +1363,11 @@
 		 the end.  We have invisible characters in this line.  This
 		 is a dumb update. */
 	      _rl_output_some_chars (nfd, temp);
+#if defined(HANDLE_MULTIBYTE)
+	      _rl_last_c_pos += col_temp;
+#else              
 	      _rl_last_c_pos += temp;
+#endif              
 	      return;
 	    }
 	  /* Copy (new) chars to screen from first diff to last match. */
@@ -1053,6 +1375,12 @@
 	  if ((temp - lendiff) > 0)
 	    {
 	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
+#if defined(HANDLE_MULTIBYTE)
+              if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+                  _rl_last_c_pos += _rl_col_width(nfd+lendiff,0,temp - lendiff)
+              - col_lendiff;
+              else
+#endif              
 	      _rl_last_c_pos += temp - lendiff;
 	    }
 	}
@@ -1060,29 +1388,51 @@
 	{
 	  /* cannot insert chars, write to EOL */
 	  _rl_output_some_chars (nfd, temp);
+#if defined(HANDLE_MULTIBYTE)
+          _rl_last_c_pos += col_temp;
+#else          
 	  _rl_last_c_pos += temp;
+#endif          
 	}
     }
   else				/* Delete characters from line. */
     {
       /* If possible and inexpensive to use terminal deletion, then do so. */
+#if defined (HANDLE_MULTIBYTE)
+      if (_rl_term_dc && (2 * col_temp) >= -col_lendiff)
+#else      
       if (_rl_term_dc && (2 * temp) >= -lendiff)
+#endif        
 	{
 	  /* If all we're doing is erasing the invisible characters in the
 	     prompt string, don't bother.  It screws up the assumptions
 	     about what's on the screen. */
 	  if (_rl_horizontal_scroll_mode && _rl_last_c_pos == 0 &&
 	      -lendiff == visible_wrap_offset)
+#if defined (HANDLE_MULTIBYTE)
+	    col_lendiff = 0;
+#else      
 	    lendiff = 0;
+#endif        
 
+#if defined (HANDLE_MULTIBYTE)
+	  if (col_lendiff)
+	    delete_chars (-col_lendiff); /* delete (diff) characters */
+#else      
 	  if (lendiff)
 	    delete_chars (-lendiff); /* delete (diff) characters */
+#endif        
 
 	  /* Copy (new) chars to screen from first diff to last match */
 	  temp = nls - nfd;
 	  if (temp > 0)
 	    {
 	      _rl_output_some_chars (nfd, temp);
+#if defined (HANDLE_MULTIBYTE)
+              if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+                  _rl_last_c_pos += _rl_col_width(nfd,0,temp);
+              else
+#endif              
 	      _rl_last_c_pos += temp;
 	    }
 	}
@@ -1092,15 +1442,36 @@
 	  if (temp > 0)
 	    {
 	      _rl_output_some_chars (nfd, temp);
+#if defined(HANDLE_MULTIBYTE)
+	      _rl_last_c_pos += col_temp;
+#else              
 	      _rl_last_c_pos += temp;
+#endif              
 	    }
-	  lendiff = (oe - old) - (ne - new);
+          lendiff = (oe - old) - (ne - new);
+#if defined(HANDLE_MULTIBYTE)
+          if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+            col_lendiff = _rl_col_width(old,0,oe-old) -
+              _rl_col_width(new,0,ne-new) ;
+          else
+            col_lendiff = lendiff;
+          if(col_lendiff)
+#else          
 	  if (lendiff)
+#endif              
 	    {	  
 	      if (_rl_term_autowrap && current_line < inv_botlin)
-		space_to_eol (lendiff);
+#if defined (HANDLE_MULTIBYTE)
+                  space_to_eol (col_lendiff);
+#else              
+                  space_to_eol (lendiff);
+#endif
 	      else
-		_rl_clear_to_eol (lendiff);
+#if defined (HANDLE_MULTIBYTE)
+                  _rl_clear_to_eol (col_lendiff);
+#else              
+                  _rl_clear_to_eol (lendiff);
+#endif
 	    }
 	}
     }
@@ -1146,6 +1517,11 @@
     prompt_last_line = rl_prompt;
 
   l = strlen (prompt_last_line);
+#if defined (HANDLE_MULTIBYTE)
+  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+    _rl_last_c_pos = _rl_col_width(prompt_last_line,0,l);
+  else
+#endif  
   _rl_last_c_pos = l;
 
   /* Dissect prompt_last_line into screen lines. Note that here we have
@@ -1201,7 +1577,11 @@
   register int i;
 
   /* If we don't have to do anything, then return. */
+# if defined (HANDLE_MULTIBYTE)
+  if ((MB_CUR_MAX == 1 || rl_byte_oriented ) && _rl_last_c_pos == new) return;
+#else  
   if (_rl_last_c_pos == new) return;
+#endif
 
   /* It may be faster to output a CR, and then move forwards instead
      of moving backwards. */
@@ -1231,18 +1611,65 @@
 	 data is underneath the cursor. */
 #if defined (HACK_TERMCAP_MOTION)
       if (_rl_term_forward_char)
-	for (i = _rl_last_c_pos; i < new; i++)
-	  tputs (_rl_term_forward_char, 1, _rl_output_character_function);
+# if deinfed (HANDLE_MULTIBYTE)
+        if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+          {
+            int width = _rl_col_width(data,_rl_last_c_pos,new);
+            for(i=0;i<width;i++)
+              tputs (_rl_term_forward_char, 1, _rl_output_character_function);
+          }
+        else
+# endif /* HANDLE_MULTIBYTE */     
+          for (i = _rl_last_c_pos; i < new; i++)
+            tputs (_rl_term_forward_char, 1, _rl_output_character_function);
       else
-	for (i = _rl_last_c_pos; i < new; i++)
-	  putc (data[i], rl_outstream);
+# if defined (HANDLE_MULTIBYTE)
+        if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+          {
+            tputs (_rl_term_cr, 1, _rl_output_character_function);
+            for (i = 0; i < new; i++)
+              putc (data[i], rl_outstream);
+          }
+        else
+# endif /* HANDLE_MULTIBYTE */
+          for (i = _rl_last_c_pos; i < new; i++)
+            putc (data[i], rl_outstream);
 #else
-      for (i = _rl_last_c_pos; i < new; i++)
-	putc (data[i], rl_outstream);
+# if defined (HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+          tputs (_rl_term_cr, 1, _rl_output_character_function);
+          for (i = 0; i < new; i++)
+            putc (data[i], rl_outstream);
+        }
+      else
+# endif /* HANDLE_MULTIBYTE */
+        for (i = _rl_last_c_pos; i < new; i++)
+          putc (data[i], rl_outstream);
 #endif /* HACK_TERMCAP_MOTION */
     }
+#if defined (HANDLE_MULTIBYTE)
+  else if (_rl_last_c_pos >= new)
+#else  
   else if (_rl_last_c_pos > new)
+#endif    
+#if defined (HANDLE_MULTIBYTE)
+    if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+      {
+        tputs (_rl_term_cr, 1, _rl_output_character_function);
+        for (i = 0; i < new; i++)
+          putc (data[i], rl_outstream);
+      }
+    else
+#endif    
     _rl_backspace (_rl_last_c_pos - new);
+#if defined (HANDLE_MULTIBYTE)
+    if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+      {
+        _rl_last_c_pos = _rl_col_width(data,0,new);
+      }
+    else
+#endif  
   _rl_last_c_pos = new;
 }
 
@@ -1510,15 +1937,26 @@
 
 /* Insert COUNT characters from STRING to the output stream. */
 static void
+#if defined (HANDLE_MULTIBYTE)
+insert_some_chars (string, count, col)
+#else
 insert_some_chars (string, count)
+#endif
      char *string;
      int count;
+#if defined (HANDLE_MULTIBYTE)
+     int col;
+#endif     
 {
   /* If IC is defined, then we do not have to "enter" insert mode. */
   if (_rl_term_IC)
     {
       char *buffer;
+#if defined (HANDLE_MULTIBYTE)
+      buffer = tgoto (_rl_term_IC, 0, col);
+#else      
       buffer = tgoto (_rl_term_IC, 0, count);
+#endif      
       tputs (buffer, 1, _rl_output_character_function);
       _rl_output_some_chars (string, count);
     }
@@ -1534,7 +1972,11 @@
 	 use that first to open up the space. */
       if (_rl_term_ic && *_rl_term_ic)
 	{
+#if defined (HANDLE_MULTIBYTE)
+	  for (i = col; i--; )
+#else          
 	  for (i = count; i--; )
+#endif              
 	    tputs (_rl_term_ic, 1, _rl_output_character_function);
 	}
 
@@ -1738,3 +2180,90 @@
 
   return ret;
 }
+#if defined(HANDLE_MULTIBYTE)
+/* This calculate a number of columns of specified string between
+   "start" and "end".  In case of that the string could be statefull
+   encoding, we have to scan from beginning of the string.*/
+static int
+_rl_col_width(str,start,end)
+     const char *str;
+     int start,end;
+{
+  wchar_t wc;
+  mbstate_t ps = {0};
+  int tmp;
+  int point = 0;
+  int width, max;
+
+  if(end <= start)
+    return 0;
+
+  max = end;
+  
+  while(point < start)
+    {
+      tmp = mbrlen(str+point,max,&ps);
+      if((size_t)(tmp) == -1 || (size_t)(tmp) == -2)
+        {
+          /* in this case, bytes are invalid or shorted to compose
+             multibyte char, so assume that the first byte represents
+             a single character anyway. */
+          point++;
+          max--;
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else if( tmp == 0)
+        /* found '\0' char */
+        break;
+      else
+        {
+          point += tmp;
+          max -= tmp;
+        }
+    }
+
+  /* if start is not pointed character started byte, then
+     the point will be larger than start.  In case of this,
+     assume that byte diff of point - start is columns */
+  width = point - start;
+
+  while(point < end)
+    {
+      tmp = mbrtowc(&wc, str+point,max,&ps);
+      if((size_t)(tmp) == -1 || (size_t)(tmp) == -2)
+        {
+          /* in this case, bytes are invalid or shorted to compose
+             multibyte char, so assume that the first byte represents
+             a single character anyway. */
+          point++;
+          max--;
+          /* and assume that the byte occupy a column.*/
+          width++; 
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else if( tmp == 0)
+        /* found '\0' char */
+        break;
+      else
+        {
+          point += tmp;
+          max -= tmp;
+          tmp = wcwidth(wc);
+          if( tmp < 0)
+            /* is this happen? but in case of this,
+               assume that this character occupy a single column */
+            width++;
+          else
+            width+=tmp;
+        }
+    }
+
+  width += (point - end);
+
+  return width;
+}
+#endif
diff -ruN bash-2.05.orig/lib/readline/emacs_keymap.c bash-2.05/lib/readline/emacs_keymap.c
--- bash-2.05.orig/lib/readline/emacs_keymap.c	Tue Oct 31 02:01:50 2000
+++ bash-2.05/lib/readline/emacs_keymap.c	Wed Jun 20 16:04:41 2001
@@ -26,6 +26,10 @@
 
 #include "readline.h"
 
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
 /* An array of function pointers, one for each possible key.
    If the type byte is ISKMAP, then the pointer is the address of
    a keymap. */
@@ -35,11 +39,19 @@
   /* Control keys. */
   { ISFUNC, rl_set_mark },			/* Control-@ */
   { ISFUNC, rl_beg_of_line },			/* Control-a */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_backward_char },                 /* Control-b */
+#else  
   { ISFUNC, rl_backward },			/* Control-b */
+#endif  
   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
   { ISFUNC, rl_delete },			/* Control-d */
   { ISFUNC, rl_end_of_line },			/* Control-e */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_forward_char },                  /* Control-f */
+#else
   { ISFUNC, rl_forward },			/* Control-f */
+#endif  
   { ISFUNC, rl_abort },				/* Control-g */
   { ISFUNC, rl_rubout },			/* Control-h */
   { ISFUNC, rl_complete },			/* Control-i */
diff -ruN bash-2.05.orig/lib/readline/funmap.c bash-2.05/lib/readline/funmap.c
--- bash-2.05.orig/lib/readline/funmap.c	Thu Nov  9 02:38:13 2000
+++ bash-2.05/lib/readline/funmap.c	Wed Jun 20 16:04:41 2001
@@ -60,7 +60,12 @@
   { "abort", rl_abort },
   { "accept-line", rl_newline },
   { "arrow-key-prefix", rl_arrow_keys },
+#if defined(HANDLE_MULTIBYTE)
+  { "backward-byte", rl_backward },
+  { "backward-char", rl_backward_char },
+#else  
   { "backward-char", rl_backward },
+#endif  
   { "backward-delete-char", rl_rubout },
   { "backward-kill-line", rl_backward_kill_line },
   { "backward-kill-word", rl_backward_kill_word },
@@ -91,7 +96,12 @@
   { "end-of-line", rl_end_of_line },
   { "exchange-point-and-mark", rl_exchange_point_and_mark },
   { "forward-backward-delete-char", rl_rubout_or_delete },
+#if defined(HANDLE_MULTIBYTE)
+  { "forward-byte", rl_forward },
+  { "forward-char", rl_forward_char },
+#else  
   { "forward-char", rl_forward },
+#endif  
   { "forward-search-history", rl_forward_search_history },
   { "forward-word", rl_forward_word },
   { "history-search-backward", rl_history_search_backward },
diff -ruN bash-2.05.orig/lib/readline/histexpand.c bash-2.05/lib/readline/histexpand.c
--- bash-2.05.orig/lib/readline/histexpand.c	Wed Mar  7 04:09:25 2001
+++ bash-2.05/lib/readline/histexpand.c	Wed Jun 20 16:04:41 2001
@@ -52,6 +52,9 @@
 
 #include "rlshell.h"
 #include "xmalloc.h"
+#if defined (HANDLE_MULTIBYTE)
+ extern int rl_byte_oriented;
+#endif
 
 #define HISTORY_WORD_DELIMITERS		" \t\n;&()|<>"
 #define HISTORY_QUOTE_CHARACTERS	"\"'`"
@@ -204,6 +207,21 @@
 
   /* Only a closing `?' or a newline delimit a substring search string. */
   for (local_index = i; c = string[i]; i++)
+#if defined (HANDLE_MULTIBYTE)
+    if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+      {
+	int v;
+        mbstate_t ps;
+        memset(&ps,0,sizeof(mbstate_t));
+        _rl_adjust_point(string,i,&ps);
+	if ((v = _rl_get_char_len (&string[i],&ps)) > 1)
+	  {
+	    i += v-1;
+	    continue;
+	  }
+      }
+    else
+#endif /* HANDLE_MULTIBYTE */
     if ((!substring_okay && (whitespace (c) || c == ':' ||
 	(history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
 	string[i] == delimiting_quote)) ||
@@ -406,10 +424,29 @@
 {
   register int si, i, j, k;
   char *s = (char *) NULL;
+#if defined (HANDLE_MULTIBYTE)
+  mbstate_t ps;
+#endif  
 
   i = *iptr;
 
+#if defined (HANDLE_MULTIBYTE)
+  memset(&ps,0,sizeof(mbstate_t));
+  _rl_adjust_point(str,i,&ps);
+#endif  
+  
   for (si = i; str[si] && str[si] != delimiter; si++)
+#if defined (HANDLE_MULTIBYTE)
+    if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+      {
+	int v;
+	if ((v = _rl_get_char_len (&str[si],&ps)) > 1)
+	  si += v-1;
+	else if (str[si] == '\\' && str[si + 1] == delimiter)
+	  si++;
+      }
+    else
+#endif /* HANDLE_MULTIBYTE */
     if (str[si] == '\\' && str[si + 1] == delimiter)
       si++;
 
@@ -484,6 +521,10 @@
   int substitute_globally, want_quotes, print_only;
   char *event, *temp, *result, *tstr, *t, c, *word_spec;
   int result_len;
+#if defined (HANDLE_MULTIBYTE)
+  mbstate_t ps;
+  memset(&ps,0,sizeof(mbstate_t));
+#endif  
 
   result = xmalloc (result_len = 128);
 
@@ -514,6 +555,15 @@
 	 quote, then this expansion takes place inside of the
 	 quoted string.  If we have to search for some text ("!foo"),
 	 allow the delimiter to end the search string. */
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+	  int c = string[_rl_find_previous_char_started_byte (string, i)];
+	  if (i - 1 && (c == '\'' || c == '"'))
+	    quoted_search_delimiter = c;
+        }
+      else
+#endif /* HANDLE_MULTIBYTE */
       if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
 	quoted_search_delimiter = string[i - 1];
       event = get_history_event (string, &i, quoted_search_delimiter);
@@ -634,6 +684,17 @@
 	    if (c == 's')
 	      {
 		if (i + 2 < (int)strlen (string))
+#if defined (HANDLE_MULTIBYTE)
+		  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+		    {
+                      _rl_adjust_point(&string,i+2,&ps);
+		      if (_rl_get_char_len (&string[i + 2],&ps) > 1)
+			delimiter = 0;
+		      else
+			delimiter = string[i + 2];
+		    }
+		  else
+#endif /* HANDLE_MULTIBYTE */
 		  delimiter = string[i + 2];
 		else
 		  break;	/* no search delimiter */
@@ -819,6 +880,10 @@
   int result_len;
   char *result;
 
+#if defined (HANDLE_MULTIBYTE)
+  char mb[MB_LEN_MAX];
+#endif /* HANDLE_MULTIBYTE */
+
   /* Used when adding the string. */
   char *temp;
 
@@ -861,6 +926,10 @@
     }
   else
     {
+#if defined (HANDLE_MULTIBYTE)
+      mbstate_t ps;
+      memset(&ps,0,sizeof(mbstate_t));
+#endif /* HANDLE_MULTIBYTE */
       string = hstring;
       /* If not quick substitution, still maybe have to do expansion. */
 
@@ -868,6 +937,17 @@
 	 is NOT an expansion. */
       for (i = 0; string[i]; i++)
 	{
+#if defined (HANDLE_MULTIBYTE)
+	  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	    {
+	      int v;
+	      if ((v = _rl_get_char_len (&string[i],&ps)) > 1)
+		{
+		  i += v-1;
+		  continue;
+		}
+	    }
+#endif /* HANDLE_MULTIBYTE */
 	  cc = string[i + 1];
 	  /* The history_comment_char, if set, appearing that the beginning
 	     of a word signifies that the rest of the line should not have
@@ -931,6 +1011,31 @@
 	  ADD_CHAR (tchar);
 	  continue;
 	}
+
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+	  int k, c;
+          mbstate_t ps;
+
+	  c = tchar;
+	  memset (mb, 0, sizeof (mb));
+	  for (k = 0; k < MB_LEN_MAX; k++)
+            {
+	      mb[k] = (char)c;
+              memset (&ps,0,sizeof(mbstate_t));
+	      if (_rl_get_char_len (mb,&ps) == -2)
+		  c = string[++i];
+	      else
+		break;
+            }
+	  if (strlen (mb) > 1)
+	    {
+	      ADD_STRING (mb);
+	      break;
+	    }
+        }
+#endif /* HANDLE_MULTIBYTE */
 
       if (tchar == history_expansion_char)
 	tchar = -3;
diff -ruN bash-2.05.orig/lib/readline/isearch.c bash-2.05/lib/readline/isearch.c
--- bash-2.05.orig/lib/readline/isearch.c	Wed Feb 14 21:37:01 2001
+++ bash-2.05/lib/readline/isearch.c	Wed Jun 20 16:04:41 2001
@@ -163,6 +163,9 @@
   register int i;
   int orig_point, orig_line, last_found_line;
   int c, found, failed, sline_len;
+#if defined (HANDLE_MULTIBYTE)
+  char mb[MB_LEN_MAX];
+#endif /* HANDLE_MULTIBYTE */
 
   /* The line currently being searched. */
   char *sline;
@@ -241,6 +244,27 @@
       RL_SETSTATE(RL_STATE_MOREINPUT);
       c = rl_read_key ();
       RL_UNSETSTATE(RL_STATE_MOREINPUT);
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+        int j;
+          mbstate_t ps;
+          memset (mb, 0, sizeof (mb));
+        for (j = 0; j < MB_LEN_MAX; j++)
+            {
+            mb[j] = (char)c;
+              memset (&ps,0,sizeof(mbstate_t));
+            if (_rl_get_char_len (mb,&ps) == -2)
+              {
+                RL_SETSTATE(RL_STATE_MOREINPUT);
+                c = rl_read_key ();
+                RL_UNSETSTATE(RL_STATE_MOREINPUT);
+              }
+            else
+              break;
+            }
+        }
+#endif /* HANDLE_MULTIBYTE */
 
       if (_rl_keymap[c].type == ISFUNC)
 	{
@@ -276,6 +300,17 @@
 	  break;
 	}
 
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	{
+	  if (c >= 0 && strlen (mb)==1 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT) && c != CTRL ('G'))
+	    {
+	      rl_execute_next (c);
+	      break;
+	    }
+	}
+      else
+#endif /* HANDLE_MULTIBYTE */
       if (c >= 0 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT) && c != CTRL ('G'))
 	{
 	  /* This sets rl_pending_input to c; it will be picked up the next
@@ -337,6 +372,15 @@
 	      search_string_size += 128;
 	      search_string = xrealloc (search_string, search_string_size);
 	    }
+#if defined (HANDLE_MULTIBYTE)
+	  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	    {
+	      int j;
+	      for (j=0; j<strlen (mb); j++)
+		search_string[search_string_index++] = mb[j];
+	    }
+	  else 
+#endif /* HANDLE_MULTIBYTE */
 	  search_string[search_string_index++] = c;
 	  search_string[search_string_index] = '\0';
 	  break;
diff -ruN bash-2.05.orig/lib/readline/readline.c bash-2.05/lib/readline/readline.c
--- bash-2.05.orig/lib/readline/readline.c	Tue Apr  3 04:56:20 2001
+++ bash-2.05/lib/readline/readline.c	Mon Mar 11 11:23:47 2002
@@ -84,6 +84,11 @@
 
 static void readline_default_bindings __P((void));
 
+#ifdef HANDLE_MULTIBYTE
+static int _rl_is_mbchar_matched __P((char *,int,int,char *,int));
+int rl_byte_oriented = 0;
+#endif      
+
 /* **************************************************************** */
 /*								    */
 /*			Line editing input utility		    */
@@ -776,8 +781,21 @@
   if (!f || f == rl_do_lowercase_version)
     {
        _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
+#if defined(HANDLE_MULTIBYTE)
+       if(MB_CUR_MAX == 1 || rl_byte_oriented)
+         {
+           _rl_bind_if_unbound ("\033[0B", rl_backward);
+           _rl_bind_if_unbound ("\033[0C", rl_forward);
+         }
+       else
+         {
+           _rl_bind_if_unbound ("\033[0B", rl_backward_char);
+           _rl_bind_if_unbound ("\033[0C", rl_forward_char);
+         }
+#else       
        _rl_bind_if_unbound ("\033[0B", rl_backward);
        _rl_bind_if_unbound ("\033[0C", rl_forward);
+#endif       
        _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
     }
 #endif
@@ -787,8 +805,21 @@
     {
       _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
       _rl_bind_if_unbound ("\033[B", rl_get_next_history);
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX == 1 || rl_byte_oriented)
+        {
+          _rl_bind_if_unbound ("\033[C", rl_forward);
+          _rl_bind_if_unbound ("\033[D", rl_backward);
+        }
+      else
+        {
+          _rl_bind_if_unbound ("\033[C", rl_forward_char);
+          _rl_bind_if_unbound ("\033[D", rl_backward_char);
+        }
+#else      
       _rl_bind_if_unbound ("\033[C", rl_forward);
       _rl_bind_if_unbound ("\033[D", rl_backward);
+#endif
     }
 
   f = rl_function_of_keyseq ("\033OA", _rl_keymap, (int *)NULL);
@@ -796,8 +827,21 @@
     {
       _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
       _rl_bind_if_unbound ("\033OB", rl_get_next_history);
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX == 1 || rl_byte_oriented)
+        {
+          _rl_bind_if_unbound ("\033OC", rl_forward);
+          _rl_bind_if_unbound ("\033OD", rl_backward);
+        }
+      else
+        {
+          _rl_bind_if_unbound ("\033OC", rl_forward_char);
+          _rl_bind_if_unbound ("\033OD", rl_backward_char);
+        }
+#else      
       _rl_bind_if_unbound ("\033OC", rl_forward);
       _rl_bind_if_unbound ("\033OD", rl_backward);
+#endif      
     }
 }
 
@@ -1091,8 +1135,80 @@
    I.e., you will have to update the data base for rl_redisplay, and you
    might as well let rl_redisplay do that job. */
 
+#if defined(HANDLE_MULTIBYTE)
 /* Move forward COUNT characters. */
 int
+rl_forward_char (count, key)
+     int count, key;
+{
+  if (MB_CUR_MAX == 1 || rl_byte_oriented)
+    return rl_forward(count,key);
+  
+  if (count < 0)
+      rl_backward_char (-count, key);
+  else if (count > 0)
+    {
+      int point = _rl_find_next_non_zero_width_char_started_byte(the_line,
+                                                                 rl_point,
+                                                                 count);
+
+#if defined (VI_MODE)
+      if(rl_end <= point && (rl_editing_mode == vi_mode))
+        point = _rl_find_previous_non_zero_width_char_started_byte(the_line,rl_end);
+#endif
+
+      if(rl_point == point)
+        rl_ding();
+      
+      rl_point = point;
+
+      if (rl_end < 0)
+        rl_end = 0;
+      
+    }
+  return 0;
+}
+
+/* Move backward COUNT characters. */
+int
+rl_backward_char (count, key)
+     int count, key;
+{
+  if (MB_CUR_MAX == 1 || rl_byte_oriented)
+    return rl_backward(count,key);
+
+  if (count < 0)
+    rl_forward_char (-count, key);
+  else if (count > 0)
+    {
+      if (rl_point < count)
+	{
+	  rl_point = 0;
+	  rl_ding ();
+	}
+      else
+        {
+          int point = rl_point;
+          while(count > 0 && point > 0)
+            {
+              point = _rl_find_previous_non_zero_width_char_started_byte(the_line,point);
+              count--;
+            }
+          if(0 < count)
+            {
+              rl_point = 0;
+              rl_ding();
+            }
+          else
+            rl_point = point;
+        }
+    }
+  return 0;
+}
+#endif
+
+/* Move forward COUNT bytes. */
+int
 rl_forward (count, key)
      int count, key;
 {
@@ -1122,7 +1238,7 @@
   return 0;
 }
 
-/* Move backward COUNT characters. */
+/* Move backward COUNT bytes. */
 int
 rl_backward (count, key)
      int count, key;
@@ -1309,11 +1425,21 @@
       break;
 
     case 'C':
-      rl_forward (count, ch);
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        rl_forward_char (count, ch);
+      else
+#endif      
+        rl_forward (count, ch);
       break;
 
     case 'D':
-      rl_backward (count, ch);
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        rl_backward_char (count, ch);
+      else
+#endif
+        rl_backward (count, ch);
       break;
 
     default:
@@ -1329,6 +1455,12 @@
 /*								    */
 /* **************************************************************** */
 
+#ifdef HANDLE_MULTIBYTE
+static char pending_bytes[MB_LEN_MAX];
+static int pending_bytes_length = 0;
+static mbstate_t ps = {0};
+#endif
+
 /* Insert the character C at the current location, moving point forward. */
 int
 rl_insert (count, c)
@@ -1336,29 +1468,131 @@
 {
   register int i;
   char *string;
-
+#ifdef HANDLE_MULTIBYTE
+  char incoming[MB_LEN_MAX + 1];
+  int incoming_length = 0;
+  mbstate_t ps_back;
+  static int stored_count = 0;
+#endif
+  
   if (count <= 0)
     return 0;
 
+#ifdef HANDLE_MULTIBYTE
+  if(MB_CUR_MAX == 1 || rl_byte_oriented)
+    {
+      incoming[0] = c;
+      incoming[1] = '\0';
+      incoming_length = 1;
+    }
+  else
+    {
+      wchar_t wc;
+      size_t ret;
+
+      if(stored_count <= 0)
+        stored_count = count;
+      else
+        count = stored_count;
+
+      ps_back = ps;
+      pending_bytes[pending_bytes_length++] = c;
+      ret = mbrtowc(&wc,pending_bytes,pending_bytes_length,&ps);
+
+      if( (size_t)(-2) == ret )
+        {
+          /* bytes are too short to compose character.
+             try to wait for a next byte */
+          /* restore the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          ps = ps_back;
+          return 1;
+        }
+      else if( (size_t)(-1) == ret )
+        {
+        /* invalid byte order for the current locale.
+           treat first byte as single character */
+          incoming[0] = pending_bytes[0];
+          incoming[1] = '\0';
+          incoming_length = 1;
+          pending_bytes_length--;
+          memmove(pending_bytes,pending_bytes+1,pending_bytes_length);
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else if ( (size_t)(0) == ret)
+        {
+          /* found '\0' character */
+          incoming[0] = '\0';
+          incoming_length = 0;
+          pending_bytes_length--;
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else
+        {
+          /* succeeded to compose multibyte char */
+          memcpy(incoming,pending_bytes,pending_bytes_length);
+          incoming[pending_bytes_length] = '\0';
+          incoming_length = pending_bytes_length;
+          pending_bytes_length = 0;
+        }
+        
+    }
+#endif /* HANDLE_MULTIBYTE */
   /* If we can optimize, then do it.  But don't let people crash
      readline because of extra large arguments. */
   if (count > 1 && count <= 1024)
     {
+#ifdef HANDLE_MULTIBYTE
+      string = xmalloc(1 + count*incoming_length);
+
+      i=0;
+      while(i < count*incoming_length)
+        {
+          strncpy(string+i,incoming,incoming_length);
+          i+=incoming_length;
+        }
+      incoming_length = 0;
+      stored_count = 0;
+#else      
       string = xmalloc (1 + count);
 
       for (i = 0; i < count; i++)
 	string[i] = c;
-
+#endif
       string[i] = '\0';
       rl_insert_text (string);
       free (string);
-
       return 0;
     }
 
   if (count > 1024)
     {
       int decreaser;
+#ifdef HANDLE_MULTIBYTE
+      string = xmalloc(1 + 1024*incoming_length);
+
+      i=0;
+      while(i < 1024*incoming_length)
+        {
+          strncpy(string+i,incoming,incoming_length);
+          i+=incoming_length;
+        }
+
+      while (count)
+	{
+	  decreaser = (count > 1024 ? 1024 : count);
+	  string[decreaser*incoming_length] = '\0';
+	  rl_insert_text (string);
+	  count -= decreaser;
+	}
+      free(string);
+      incoming_length = 0;
+      stored_count = 0;
+#else      
       char str[1024+1];
 
       for (i = 0; i < 1024; i++)
@@ -1371,25 +1605,37 @@
 	  rl_insert_text (str);
 	  count -= decreaser;
 	}
-
+#endif      
       return 0;
     }
 
-  /* We are inserting a single character.
-     If there is pending input, then make a string of all of the
-     pending characters that are bound to rl_insert, and insert
-     them all. */
-  if (_rl_any_typein ())
-    _rl_insert_typein (c);
+#ifdef HANDLE_MULTIBYTE
+  if(MB_CUR_MAX == 1 || rl_byte_oriented)
+    {
+#endif
+      /* We are inserting a single character.
+         If there is pending input, then make a string of all of the
+         pending characters that are bound to rl_insert, and insert
+         them all. */
+      if (_rl_any_typein ())
+        _rl_insert_typein (c);
+      else
+        {
+          /* Inserting a single character. */
+          char str[2];
+          
+          str[1] = '\0';
+          str[0] = c;
+          rl_insert_text (str);
+        }
+#ifdef HANDLE_MULTIBYTE      
+    }
   else
     {
-      /* Inserting a single character. */
-      char str[2];
-
-      str[1] = '\0';
-      str[0] = c;
-      rl_insert_text (str);
+      rl_insert_text(incoming);
+      stored_count = 0;
     }
+#endif  
   return 0;
 }
 
@@ -1482,14 +1728,43 @@
   if (count > 1 || rl_explicit_arg)
     {
       int orig_point = rl_point;
-      rl_backward (count, key);
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        rl_backward_char (count, key);
+      else
+#endif
+        rl_backward (count, key);
       rl_kill_text (orig_point, rl_point);
     }
   else
     {
-      int c = the_line[--rl_point];
-      rl_delete_text (rl_point, rl_point + 1);
+#if defined(HANDLE_MULTIBYTE)
+      int c;
+      if(MB_CUR_MAX == 1 || rl_byte_oriented)
+        {
+          c = the_line[--rl_point];
+#else
+          int c = the_line[--rl_point];
+#endif   
+          rl_delete_text (rl_point, rl_point + 1);
+#if defined(HANDLE_MULTIBYTE)
+        }
+      else
+        {
+          int orig_point = rl_point;
+          rl_point = _rl_find_previous_non_zero_width_char_started_byte(the_line,
+                                                                  rl_point);
+          c = the_line[rl_point];
+          rl_delete_text(rl_point,orig_point);
+        }
+#endif   
 
+#if defined(HANDLE_MULTIBYTE)
+          /* I18N codes have column adjustment in display.c.
+             So I believe that this special hack for the end of line
+             is not needed.*/
+      if(MB_CUR_MAX == 1 || rl_byte_oriented)
+#endif   
       if (rl_point == rl_end && isprint (c) && _rl_last_c_pos)
 	{
 	  int l;
@@ -1518,13 +1793,26 @@
   if (count > 1 || rl_explicit_arg)
     {
       int orig_point = rl_point;
-      rl_forward (count, key);
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        rl_forward_char (count,key);
+      else
+#endif 
+        rl_forward (count, key);
       rl_kill_text (orig_point, rl_point);
       rl_point = orig_point;
       return 0;
     }
   else
-    return (rl_delete_text (rl_point, rl_point + 1));
+#if defined(HANDLE_MULTIBYTE)
+    if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+      return (rl_delete_text (rl_point,
+                _rl_find_next_non_zero_width_char_started_byte(the_line,
+                                                         rl_point,1)));
+    else
+#endif 
+      return (rl_delete_text (rl_point, rl_point + 1));
+
 }
 
 /* Delete the character under the cursor, unless the insertion
@@ -1751,7 +2039,14 @@
 rl_transpose_chars (count, key)
      int count, key;
 {
+#ifdef HANDLE_MULTIBYTE
+  char *dummy;
+  int i;
+  int prev_point;
+  int char_length;
+#else  
   char dummy[2];
+#endif  
 
   if (!count)
     return 0;
@@ -1766,20 +2061,65 @@
 
   if (rl_point == rl_end)
     {
+#ifdef HANDLE_MULTIBYTE      
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        rl_point = _rl_find_previous_non_zero_width_char_started_byte(the_line,
+                                                                rl_point);
+      else
+#endif        
       --rl_point;
       count = 1;
     }
+#ifdef HANDLE_MULTIBYTE      
+  if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+    {
+      prev_point = rl_point;
+      rl_point = _rl_find_previous_non_zero_width_char_started_byte(the_line,
+                                                              rl_point);
+    }
+  else
+#endif        
   rl_point--;
 
+#ifdef HANDLE_MULTIBYTE
+  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+     {
+     char_length = prev_point - rl_point;
+     dummy = xmalloc(char_length + 1);
+     for(i=0;i<char_length;i++)
+       {
+         dummy[i] = the_line[rl_point+i];
+       }
+     dummy[i] = '\0';
+   } else {
+     char_length = 1;
+     dummy = xmalloc(2);
+     dummy[0] = the_line[rl_point];
+     dummy[1] = '\0';
+   }  
+#else  
   dummy[0] = the_line[rl_point];
   dummy[1] = '\0';
+#endif  
 
+#ifdef HANDLE_MULTIBYTE
+  rl_delete_text (rl_point, rl_point + char_length);
+#else  
   rl_delete_text (rl_point, rl_point + 1);
+#endif  
 
+#ifdef HANDLE_MULTIBYTE
+  if (MB_CUR_MAX > 1 && !rl_byte_oriented) { 
+     rl_point = _rl_find_next_non_zero_width_char_started_byte(the_line,rl_point,count);
+  } else {
+     rl_point += count;
+  }
+#else  
   rl_point += count;
+#endif  
   _rl_fix_point (0);
   rl_insert_text (dummy);
-
+  free(dummy);
   rl_end_undo_group ();
   return 0;
 }
@@ -1791,10 +2131,20 @@
 /* **************************************************************** */
 
 int
+#ifdef HANDLE_MULTIBYTE
+_rl_char_search_internal (count, dir, smbchar,len)
+     int count, dir;
+     char *smbchar;
+     int len;
+#else
 _rl_char_search_internal (count, dir, schar)
      int count, dir, schar;
+#endif
 {
   int pos, inc;
+#ifdef HANDLE_MULTIBYTE
+  int prepos;
+#endif
 
   pos = rl_point;
   inc = (dir < 0) ? -1 : 1;
@@ -1806,20 +2156,46 @@
 	  return -1;
 	}
 
+#ifdef HANDLE_MULTIBYTE
+      pos = (inc > 0) ?
+        _rl_find_next_char_started_byte(rl_line_buffer,pos,1) :
+        _rl_find_previous_char_started_byte(rl_line_buffer,pos) ;
+#else      
       pos += inc;
+#endif      
       do
 	{
+#ifdef HANDLE_MULTIBYTE          
+	  if (_rl_is_mbchar_matched(rl_line_buffer,pos,rl_end,smbchar,len))
+#else            
 	  if (rl_line_buffer[pos] == schar)
+#endif            
 	    {
 	      count--;
 	      if (dir < 0)
+#ifdef HANDLE_MULTIBYTE
+	        rl_point = (dir == BTO) ? _rl_find_next_char_started_byte(rl_line_buffer,pos,1) : pos;
+#else                
 	        rl_point = (dir == BTO) ? pos + 1 : pos;
+#endif              
 	      else
+#ifdef HANDLE_MULTIBYTE
+		rl_point = (dir == FTO) ? _rl_find_previous_char_started_byte(rl_line_buffer,pos) : pos;
+#else                
 		rl_point = (dir == FTO) ? pos - 1 : pos;
+#endif              
 	      break;
 	    }
+#ifdef HANDLE_MULTIBYTE
+          prepos = pos;
 	}
+      while ((dir < 0) ?
+             (pos=_rl_find_previous_char_started_byte(rl_line_buffer,pos)) != prepos :
+             (pos=_rl_find_next_char_started_byte(rl_line_buffer,pos,1)) != prepos );
+#else
+        }
       while ((dir < 0) ? pos-- : ++pos < rl_end);
+#endif      
     }
   return (0);
 }
@@ -1831,16 +2207,33 @@
 _rl_char_search (count, fdir, bdir)
      int count, fdir, bdir;
 {
+#ifdef HANDLE_MULTIBYTE
+  char mbchar[MB_LEN_MAX];
+  int mb_len;
+#else
   int c;
+#endif
 
+#ifdef HANDLE_MULTIBYTE
+  mb_len = _rl_read_mbchar(mbchar,MB_LEN_MAX);
+#else
   RL_SETSTATE(RL_STATE_MOREINPUT);
   c = rl_read_key ();
   RL_UNSETSTATE(RL_STATE_MOREINPUT);
+#endif
 
   if (count < 0)
+#ifdef HANDLE_MULTIBYTE
+    return (_rl_char_search_internal (-count, bdir, mbchar,mb_len));
+#else     
     return (_rl_char_search_internal (-count, bdir, c));
+#endif    
   else
+#ifdef HANDLE_MULTIBYTE
+    return (_rl_char_search_internal (count, fdir, mbchar,mb_len));
+#else  
     return (_rl_char_search_internal (count, fdir, c));
+#endif
 }
 
 int
@@ -2157,3 +2550,24 @@
   _rl_keymap = emacs_standard_keymap;
   return 0;
 }
+
+#ifdef HANDLE_MULTIBYTE
+static int
+_rl_is_mbchar_matched(string,seed,end,mbchar,length)
+     char *string;
+     int seed,end;
+     char *mbchar;
+     int length;
+{
+  int i;
+  if( (end - seed) < length )
+    return 0;
+
+  for(i=0;i<length;i++)
+    {
+      if(string[seed+i] != mbchar[i])
+        return 0;
+    }
+  return 1;
+}
+#endif
diff -ruN bash-2.05.orig/lib/readline/readline.h bash-2.05/lib/readline/readline.h
--- bash-2.05.orig/lib/readline/readline.h	Thu Feb 15 06:27:54 2001
+++ bash-2.05/lib/readline/readline.h	Mon Apr 16 14:45:41 2001
@@ -86,6 +86,8 @@
 extern int rl_refresh_line __P((int, int));
 extern int rl_clear_screen __P((int, int));
 extern int rl_arrow_keys __P((int, int));
+extern int rl_forward_char __P((int, int));
+extern int rl_backward_char __P((int, int));
 
 /* Bindable commands for inserting and deleting text. */
 extern int rl_insert __P((int, int));
diff -ruN bash-2.05.orig/lib/readline/rlprivate.h bash-2.05/lib/readline/rlprivate.h
--- bash-2.05.orig/lib/readline/rlprivate.h	Wed Feb 14 21:43:14 2001
+++ bash-2.05/lib/readline/rlprivate.h	Mon Mar 11 11:23:47 2002
@@ -55,6 +55,9 @@
 extern int rl_visible_prompt_length;
 extern int readline_echoing_p;
 extern int rl_key_sequence_length;
+#if defined (HANDLE_MULTIBYTE)
+extern int rl_byte_oriented;
+#endif /* HANDLE_MULTIBYTE */
 
 /* display.c */
 extern int rl_display_fixed;
@@ -88,6 +91,18 @@
 
 /* util.c */
 extern char *_rl_savestring __P((const char *));
+#if defined (HANDLE_MULTIBYTE)
+extern int _rl_find_next_char_started_byte __P((char *,int, int));
+extern int _rl_find_next_non_zero_width_char_started_byte __P((char *,int, int));
+extern int _rl_find_previous_char_started_byte __P((char *, int));
+extern int _rl_find_previous_non_zero_width_char_started_byte __P((char *, int));
+extern int _rl_adjust_point __P((const char *, int, mbstate_t *));
+extern int _rl_get_char_len __P((const char *,mbstate_t *));
+extern int _rl_compare_chars __P((const char *,int,mbstate_t *,
+                                  const char *,int,mbstate_t *));
+extern int _rl_read_mbchar __P((char *,int));
+
+#endif
 
 /*************************************************************************
  *									 *
@@ -158,7 +173,11 @@
 extern int _rl_init_argument __P((void));
 extern void _rl_fix_point __P((int));
 extern void _rl_replace_text __P((const char *, int, int));
+#ifdef HANDLE_MULTIBYTE
+extern int _rl_char_search_internal __P((int, int, char *,int));
+#else
 extern int _rl_char_search_internal __P((int, int, int));
+#endif
 extern int _rl_set_mark_at_pos __P((int));
 extern int _rl_free_saved_history_line __P((void));
 
diff -ruN bash-2.05.orig/lib/readline/search.c bash-2.05/lib/readline/search.c
--- bash-2.05.orig/lib/readline/search.c	Fri Nov  3 03:13:25 2000
+++ bash-2.05/lib/readline/search.c	Wed Jun 20 16:04:41 2001
@@ -177,6 +177,9 @@
 {
   int saved_point, c;
   char *p;
+#if defined (HANDLE_MULTIBYTE)
+  char mb[MB_LEN_MAX];
+#endif /* HANDLE_MULTIBYTE */
 
   rl_maybe_save_line ();
   saved_point = rl_point;
@@ -198,6 +201,28 @@
       RL_SETSTATE(RL_STATE_MOREINPUT);
       c = rl_read_key ();
       RL_UNSETSTATE(RL_STATE_MOREINPUT);
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+        int j;
+          mbstate_t ps;
+        memset (mb, 0, sizeof (mb));
+        for (j = 0; j < MB_LEN_MAX; j++)
+            {
+            mb[j] = (char)c;
+              memset (&ps,0,sizeof(mbstate_t));
+            if (_rl_get_char_len (mb,&ps) == -2)
+              {
+                /* Read again for multibyte character */
+                RL_SETSTATE(RL_STATE_MOREINPUT);
+                c = rl_read_key ();
+                RL_UNSETSTATE(RL_STATE_MOREINPUT);
+              }
+            else
+              break;
+            }
+        }
+#endif /* HANDLE_MULTIBYTE */
 
       if (c == 0)
 	break;
@@ -239,6 +264,12 @@
 	  SEARCH_RETURN;
 
 	default:
+#if defined (HANDLE_MULTIBYTE)
+	  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+	      /* Use rl_insert_text() instead of rl_insert() */
+	      rl_insert_text (mb);
+	  else 
+#endif /* HANDLE_MULTIBYTE */
 	  rl_insert (1, c);
 	  break;
 	}
diff -ruN bash-2.05.orig/lib/readline/util.c bash-2.05/lib/readline/util.c
--- bash-2.05.orig/lib/readline/util.c	Wed Feb 14 21:43:19 2001
+++ bash-2.05/lib/readline/util.c	Mon Mar 11 11:23:47 2002
@@ -232,6 +232,10 @@
      const char *string1, *string2;
 {
   register const char *scan;
+#if defined (HANDLE_MULTIBYTE)
+  mbstate_t ps;
+  memset(&ps,0,sizeof(mbstate_t));
+#endif /* HANDLE_MULTIBYTE */
 
   for (; *string1; string1++)
     {
@@ -240,6 +244,16 @@
 	  if (*string1 == *scan)
 	    return ((char *)string1);
 	}
+#if defined (HANDLE_MULTIBYTE)
+      if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+          int i, v;
+
+          if ((v = _rl_get_char_len (string1,&ps)) > 1)
+            for (i = 1; i < v; i++)
+              string1++;
+        }
+#endif /* HANDLE_MULTIBYTE */
     }
   return ((char *)NULL);
 }
@@ -368,3 +382,294 @@
 {
   return (strcpy (xmalloc (1 + (int)strlen (s)), (s)));
 }
+
+#if defined(HANDLE_MULTIBYTE)
+static int
+_rl_find_next_char_started_byte_internal(string, seed, count, find_non_zero)
+     char *string;
+     int seed, count, find_non_zero;
+{
+  size_t tmp = 0;
+  mbstate_t ps;
+  int point = 0;
+  wchar_t wc;
+
+  memset(&ps,0,sizeof(mbstate_t));
+  if (seed < 0)
+    seed = 0;
+  if (count <= 0)
+    return seed;
+
+  point = seed + _rl_adjust_point(string,seed,&ps);
+  /* if this is true, means that seed was not pointed character
+     started byte.  So correct the point and consume count */
+  if(seed < point)
+    count --;
+  
+  while(0 < count)
+    {
+      tmp = mbrtowc (&wc,string+point,strlen(string+point),&ps);
+      if((size_t)(tmp) == -1 || (size_t)(tmp) == -2)
+        {
+          /* invalid bytes. asume a byte represents a character */
+          point++;
+          count--;
+          /* reset states. */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else if( tmp == (size_t)0)
+        /* found '\0' char */
+        break;
+      else
+        {
+          /* valid bytes */
+          point += tmp;
+          if(find_non_zero)
+            {
+              if (wcwidth(wc) == 0)
+                continue;
+              else
+                count--;
+            }
+          else
+            count--;
+        }
+    }
+
+  if(find_non_zero)
+    {
+      tmp = mbrtowc (&wc,string+point,strlen(string+point),&ps);
+      while(wcwidth(wc) == 0)
+        {
+          point+=tmp;
+          tmp = mbrtowc (&wc,string+point,strlen(string+point),&ps);
+          if(tmp == (size_t)(0) || tmp == (size_t)(-1) || tmp == (size_t)(-2))
+            {
+              break;
+            }
+        }
+    }
+    return point;
+}
+
+/* find next `count' characters started byte point of the specified seed. */
+int
+_rl_find_next_char_started_byte(string, seed, count)
+     char *string;
+     int seed, count;
+{
+  return _rl_find_next_char_started_byte_internal(string,seed,count,0);
+}
+
+/* find next `count' non zero characters started
+   byte point of the specified seed. */
+int
+_rl_find_next_non_zero_width_char_started_byte(string,seed,count)
+     char *string;
+     int seed, count;
+{
+  return _rl_find_next_char_started_byte_internal(string,seed,count,1);
+}
+
+static int
+_rl_find_previous_char_started_byte_internal(string,seed,find_non_zero)
+     char *string;
+     int seed,find_non_zero;
+{
+  mbstate_t ps;
+  int prev = 0;
+  int point = 0;
+  int length = 0;
+  size_t tmp;
+  wchar_t wc;
+
+  memset(&ps,0,sizeof(mbstate_t));
+  length = strlen(string) ;
+  
+  if(seed < 0)
+    return 0;
+  else if(length < seed)
+    return length;
+
+  while(point < seed)
+    {
+      tmp = mbrtowc(&wc, string+point,length-point,&ps);
+      if((size_t)(tmp) == -1 || (size_t)(tmp) == -2)
+        {
+          /* in this case, bytes are invalid or shorted to compose
+             multibyte char, so assume that the first byte represents
+             a single character anyway. */
+          tmp = 1;
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(&ps,0,sizeof(mbstate_t));
+        }
+      else if (tmp == 0)
+        /* found '\0' char.  Is this happen?*/
+        break;
+      else
+        {
+          if(find_non_zero)
+            {
+              if(wcwidth(wc) != 0)
+                prev = point;
+            }
+          else
+            prev = point;  
+        }
+
+      point += tmp;
+    }
+  
+  return prev;
+}
+
+/* find previous character started byte point of the specified seed.
+   finded point will be "point <= seed */
+int
+_rl_find_previous_char_started_byte(string,seed)
+     char *string;
+     int seed;
+{
+  return _rl_find_previous_char_started_byte_internal(string,seed,0);
+}
+/* find previous non zero character started byte point of the specified seed.
+   finded point will be "point <= seed */
+int
+_rl_find_previous_non_zero_width_char_started_byte(string,seed)
+     char *string;
+     int seed;
+{
+  return _rl_find_previous_char_started_byte_internal(string,seed,1);
+}
+
+/* return the number of bytes parsed from the multibyte sequence starting
+   at src, if a non-L'\0' wide character was recognized. It returns 0, 
+   if a L'\0' wide character was recognized. It  returns (size_t)(-1), 
+   if an invalid multibyte sequence was encountered. It returns (size_t)(-2) 
+   if it couldn't parse a complete  multibyte character.  */
+int
+_rl_get_char_len (src,ps)
+     const char *src;
+     mbstate_t *ps;
+{
+  size_t tmp;
+
+  tmp = mbrlen((const char*) src, (size_t) strlen(src), ps);
+  if(tmp == (size_t)(-2) )
+    {
+      /* shorted to compose multibyte char */
+      if(ps)
+        memset (ps, 0, sizeof(mbstate_t));
+      return -2;
+    }
+  else if (tmp == (size_t)(-1))
+    {
+      /* invalid to compose multibyte char */
+      /* initialize the conversion state */
+      if(ps)
+        memset (ps, 0, sizeof(mbstate_t));
+      return -1;
+    }
+  else if (tmp == (size_t)(0))
+    return 0;
+  else
+    return (int)tmp;
+}
+/* compare the specified two characters. If their two characters matched,
+   return 1. Otherwise return 0. */
+int
+_rl_compare_chars (buf1, pos1, ps1, buf2, pos2, ps2)
+     const char *buf1, *buf2;
+     mbstate_t *ps1, *ps2;
+     int pos1, pos2;
+{
+  int i, w1, w2;
+
+  if ((w1 = _rl_get_char_len (&buf1[pos1],ps1)) <= 0 || 
+	(w2 = _rl_get_char_len (&buf2[pos2],ps2)) <= 0 ||
+	(w1 != w2) ||
+	(buf1[pos1] != buf2[pos2]))
+    return 0;
+
+  for (i = 1; i < w1; i++)
+    if (buf1[pos1+i] != buf2[pos2+i])
+      return 0;
+
+  return 1;
+}
+/* adjust pointed byte and find mbstate of the point of string.
+   adjusted point will be point <= adjusted_point, and returns
+   differences of the byte(adjusted_point - point).
+   if point is invalied (point < 0 || more than string length),
+   it returns -1 */
+int
+_rl_adjust_point(string, point, ps)
+     const char *string;
+     int point;
+     mbstate_t *ps;
+{
+  size_t tmp = 0;
+  int length;
+  int pos = 0;
+
+  length = strlen(string);
+  if (point < 0)
+    return -1;
+  if (length < point)
+    return -1;
+  
+  while(pos < point)
+    {
+      tmp = mbrlen(string+pos,length-pos,ps);
+      if((size_t)(tmp) == -1 || (size_t)(tmp) == -2)
+        {
+          /* in this case, bytes are invalid or shorted to compose
+             multibyte char, so assume that the first byte represents
+             a single character anyway. */
+          pos++;
+          /* clear the state of the byte sequence, because
+             in this case effect of mbstate is undefined  */
+          memset(ps,0,sizeof(mbstate_t));
+        }
+      else
+        pos += tmp;
+    }
+
+  return (pos - point);
+}
+
+/* read multibyte char */
+int
+_rl_read_mbchar(mbchar,size)
+     char *mbchar;
+     int size;
+{
+  int mb_len = 0;
+  size_t mbchar_bytes_length;
+  wchar_t wc;
+  mbstate_t ps, ps_back;
+
+  memset(&ps,0,sizeof(mbstate_t));
+  memset(&ps_back,0,sizeof(mbstate_t));
+  
+  while(mb_len < size) {
+    RL_SETSTATE(RL_STATE_MOREINPUT);
+    mbchar[mb_len++] = rl_read_key();
+    RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
+    mbchar_bytes_length=mbrtowc(&wc,mbchar,mb_len,&ps);
+    if (mbchar_bytes_length == (size_t)(-1)) {
+      /* invalid byte sequence for the current locale */
+      break;
+    } else if (mbchar_bytes_length == (size_t)(-2)) {
+      /* shorted bytes */
+      ps = ps_back;
+      continue;
+    } else if (mbchar_bytes_length > (size_t)(0)){
+      break;
+    }
+  }
+  return mb_len;
+}
+#endif
diff -ruN bash-2.05.orig/lib/readline/vi_keymap.c bash-2.05/lib/readline/vi_keymap.c
--- bash-2.05.orig/lib/readline/vi_keymap.c	Tue Oct 31 01:55:52 2000
+++ bash-2.05/lib/readline/vi_keymap.c	Wed Jun 20 16:04:41 2001
@@ -26,6 +26,10 @@
 
 #include "readline.h"
 
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
 #if 0
 extern KEYMAP_ENTRY_ARRAY vi_escape_keymap;
 #endif
@@ -41,7 +45,11 @@
   { ISFUNC, rl_emacs_editing_mode },		/* Control-e */
   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
   { ISFUNC, rl_abort },				/* Control-g */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_backward_char },                 /* Control-h */
+#else
   { ISFUNC, rl_backward },			/* Control-h */
+#endif
   { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
   { ISFUNC, rl_newline },			/* Control-j */
   { ISFUNC, rl_kill_line },			/* Control-k */
@@ -150,11 +158,19 @@
   { ISFUNC, rl_vi_end_word },			/* e */
   { ISFUNC, rl_vi_char_search },		/* f */
   { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_backward_char },                 /* h */
+#else  
   { ISFUNC, rl_backward },			/* h */
+#endif  
   { ISFUNC, rl_vi_insertion_mode },		/* i */
   { ISFUNC, rl_get_next_history },		/* j */
   { ISFUNC, rl_get_previous_history },		/* k */
+#if defined(HANDLE_MULTIBYTE)
+  { ISFUNC, rl_forward_char },                  /* l */
+#else  
   { ISFUNC, rl_forward },			/* l */
+#endif  
   { ISFUNC, rl_vi_set_mark },			/* m */
   { ISFUNC, rl_vi_search_again },		/* n */
   { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
diff -ruN bash-2.05.orig/lib/readline/vi_mode.c bash-2.05/lib/readline/vi_mode.c
--- bash-2.05.orig/lib/readline/vi_mode.c	Thu Nov  9 01:47:02 2000
+++ bash-2.05/lib/readline/vi_mode.c	Wed Jun 20 16:04:41 2001
@@ -101,7 +101,11 @@
 static int _rl_vi_last_repeat = 1;
 static int _rl_vi_last_arg_sign = 1;
 static int _rl_vi_last_motion;
-static int _rl_vi_last_search_char;
+#ifdef HANDLE_MULTIBYTE
+ static char _rl_vi_last_search_mbchar[MB_LEN_MAX];
+#else
+ static int _rl_vi_last_search_char;
+#endif
 static int _rl_vi_last_replacement;
 
 static int _rl_vi_last_key_before_insert;
@@ -557,7 +561,21 @@
      int count, key;
 {
   if (rl_point < rl_end)
+#if defined(HANDLE_MULTIBYTE)
+    {
+      if(MB_CUR_MAX == 1 || rl_byte_oriented)
+        rl_point++;
+      else
+        {
+          int point = rl_point;
+          rl_forward_char(1,key);
+          if(point == rl_point)
+            rl_point = rl_end;
+        }
+    }
+#else      
     rl_point++;
+#endif  
   rl_vi_insertion_mode (1, key);
   return (0);
 }
@@ -650,7 +668,11 @@
      int count, key;
 {
   if (rl_point > 0)
+#if defined(HANDLE_MULTIBYTE)
+    rl_backward_char(1,key);
+#else    
     rl_backward (1, key);
+#endif  
 
   _rl_keymap = vi_movement_keymap;
   _rl_vi_done_inserting ();
@@ -677,6 +699,46 @@
   if (rl_point >= rl_end)
     return (0);
 
+#if defined (HANDLE_MULTIBYTE)
+  if (MB_CUR_MAX > 1 && !rl_byte_oriented)
+    {
+      wchar_t wc;
+      char mb[MB_LEN_MAX];
+      mbstate_t ps;
+
+      memset(&ps,0,sizeof(mbstate_t));
+      if( _rl_adjust_point(rl_line_buffer,rl_point,&ps) > 0)
+        count--;
+      while (count-- && rl_point < rl_end)
+        {
+          mbrtowc(&wc,rl_line_buffer+rl_point,rl_end-rl_point,&ps);
+          if (iswupper(wc))
+            wc = towlower(wc);
+          else if (iswlower(wc))
+            wc = towupper(wc);
+          else
+            {
+              /* Just skip over characters neither upper nor lower case. */
+              rl_forward_char (1, c);
+              continue;
+            }
+          
+          /* Vi is kind of strange here. */
+          if (wc)
+            {
+              wctomb(mb,wc);
+              rl_begin_undo_group ();
+              rl_delete (1, c);
+              rl_insert_text (mb);
+              rl_end_undo_group ();
+              rl_vi_check ();
+            }
+          else
+            rl_forward_char (1, c);
+        }
+    }
+  else
+#endif  
   while (count-- && rl_point < rl_end)
     {
       if (_rl_uppercase_p (rl_line_buffer[rl_point]))
@@ -710,10 +772,19 @@
      int count, key;
 {
   if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))
+#if defined(HANDLE_MULTIBYTE)
+    rl_point = _rl_find_next_non_zero_width_char_started_byte(rl_line_buffer,
+                                                              rl_point,1);
+#else
     rl_point++;
+#endif    
 
   rl_yank (1, key);
+#if defined(HANDLE_MULTIBYTE)
+  rl_backward_char (1, key);
+#else  
   rl_backward (1, key);
+#endif  
   return (0);
 }
 
@@ -721,7 +792,12 @@
 rl_vi_check ()
 {
   if (rl_point && rl_point == rl_end)
-    rl_point--;
+#if defined(HANDLE_MULTIBYTE)
+    if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+      rl_point = _rl_find_previous_non_zero_width_char_started_byte(rl_line_buffer,rl_point);
+    else
+#endif      
+      rl_point--;
   return (0);
 }
 
@@ -1000,8 +1076,14 @@
       rl_ding ();
       return -1;
     }
+#if defined(HANDLE_MULTIBYTE)
+  if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+    end = _rl_find_next_non_zero_width_char_started_byte(rl_line_buffer,
+                                                         rl_point,count);
+  else
+#endif
+    end = rl_point + count;
 
-  end = rl_point + count;
 
   if (end >= rl_end)
     end = rl_end;
@@ -1009,7 +1091,12 @@
   rl_kill_text (rl_point, end);
   
   if (rl_point > 0 && rl_point == rl_end)
-    rl_backward (1, key);
+#if defined(HANDLE_MULTIBYTE)
+    if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+      rl_backward_char (1, key);
+    else
+#endif    
+      rl_backward (1, key);
   return (0);
 }
 
@@ -1034,7 +1121,12 @@
 rl_vi_char_search (count, key)
      int count, key;
 {
+#ifdef HANDLE_MULTIBYTE
+  static char *target;
+  static int mb_len;
+#else  
   static char target;
+#endif  
   static int orig_dir, dir;
 
   if (key == ';' || key == ',')
@@ -1042,12 +1134,21 @@
   else
     {
       if (vi_redoing)
+#ifdef HANDLE_MULTIBYTE
+	target = _rl_vi_last_search_mbchar;
+#else        
 	target = _rl_vi_last_search_char;
+#endif      
       else
 	{
+#ifdef HANDLE_MULTIBYTE
+          mb_len = _rl_read_mbchar(_rl_vi_last_search_mbchar,MB_LEN_MAX);
+          target = _rl_vi_last_search_mbchar;
+#else          
 	  RL_SETSTATE(RL_STATE_MOREINPUT);
 	  _rl_vi_last_search_char = target = rl_read_key ();
 	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+#endif          
 	}
 
       switch (key)
@@ -1070,7 +1171,11 @@
         }
     }
 
+#ifdef HANDLE_MULTIBYTE
+  return (_rl_char_search_internal (count, dir, target,mb_len));
+#else  
   return (_rl_char_search_internal (count, dir, target));
+#endif  
 }
 
 /* Match brackets */
@@ -1083,9 +1188,23 @@
   pos = rl_point;
   if ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
     {
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        {
+          int pre;
+          while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 )
+            {
+              pre = rl_point;
+              rl_forward_char (1, key);
+              if (pre == rl_point)
+                break;
+            }
+        }
+      else
+#endif          
       while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
 	     rl_point < rl_end - 1)
-	rl_forward (1, key);
+          rl_forward (1, key);
 
       if (brack <= 0)
 	{
@@ -1099,9 +1218,25 @@
 
   if (brack < 0)
     {
+#if defined(HANDLE_MULTIBYTE)
+      int tmp;
+#endif      
       while (count)
 	{
+#if defined(HANDLE_MULTIBYTE)
+          tmp = pos;
+          if(MB_CUR_MAX == 1 || rl_byte_oriented)
+            pos--;
+          else
+            {
+              pos = _rl_find_previous_char_started_byte(rl_line_buffer,pos);
+              if (tmp == pos) /* pos was already 0.*/
+                pos--; 
+            }
+          if ( pos >= 0 )
+#else          
 	  if (--pos >= 0)
+#endif              
 	    {
 	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
 	      if (b == -brack)
@@ -1120,7 +1255,15 @@
     {			/* brack > 0 */
       while (count)
 	{
+#if defined(HANDLE_MULTIBYTE)
+          if (MB_CUR_MAX == 1 || rl_byte_oriented)
+            pos++;
+          else
+            pos = _rl_find_next_char_started_byte(rl_line_buffer,pos,1);
+          if ( pos < rl_end)
+#else          
 	  if (++pos < rl_end)
+#endif            
 	    {
 	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
 	      if (b == -brack)
@@ -1178,9 +1321,25 @@
       rl_begin_undo_group ();
 
       rl_delete (1, c);
-      rl_insert (1, c);
+#if defined(HANDLE_MULTIBYTE)
+      if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+        while(rl_insert(1,c))
+          {
+            RL_SETSTATE(RL_STATE_MOREINPUT);
+            c = rl_read_key();
+            RL_UNSETSTATE(RL_STATE_MOREINPUT);
+          }
+      else
+#else      
+        rl_insert (1, c);
+#endif      
       if (count == 0)
-	rl_backward (1, c);
+#if defined(HANDLE_MULTIBYTE)
+        if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+          rl_backward_char(1,c);
+        else
+#endif        
+          rl_backward (1, c);
 
       rl_end_undo_group ();
     }
@@ -1273,7 +1432,12 @@
 	vi_replace_count--;
 
       if (rl_point == s)
-	rl_backward (1, key);
+#if defined(HANDLE_MULTIBYTE)
+        if(MB_CUR_MAX > 1 && !rl_byte_oriented)
+          rl_backward_char (1,key);
+        else
+#endif          
+          rl_backward (1, key);
     }
 
   if (vi_replace_count == 0 && _rl_vi_doing_insert)
@@ -1396,5 +1560,4 @@
   rl_point = vi_mark_chars[ch];
   return 0;
 }
-
 #endif /* VI_MODE */
