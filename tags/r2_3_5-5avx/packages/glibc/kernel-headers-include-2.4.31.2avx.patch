--- kernel-headers/asm-alpha/bitops.h.kheaders	2001-10-12 18:35:54.000000000 -0400
+++ kernel-headers/asm-alpha/bitops.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,7 +1,6 @@
 #ifndef _ALPHA_BITOPS_H
 #define _ALPHA_BITOPS_H
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 
 /*
@@ -114,9 +113,7 @@ test_and_set_bit(unsigned long nr, volat
 	"	stl_c %0,%1\n"
 	"	beq %0,3f\n"
 	"2:\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"3:	br 1b\n"
 	".previous"
@@ -155,9 +152,7 @@ test_and_clear_bit(unsigned long nr, vol
 	"	stl_c %0,%1\n"
 	"	beq %0,3f\n"
 	"2:\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"3:	br 1b\n"
 	".previous"
@@ -208,9 +203,7 @@ test_and_change_bit(unsigned long nr, vo
 	"	xor %0,%3,%0\n"
 	"	stl_c %0,%1\n"
 	"	beq %0,3f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"3:	br 1b\n"
 	".previous"
--- kernel-headers/asm-alpha/cache.h.kheaders	2001-10-04 21:47:08.000000000 -0400
+++ kernel-headers/asm-alpha/cache.h	2002-12-17 05:22:41.000000000 -0500
@@ -4,6 +4,8 @@
 #ifndef __ARCH_ALPHA_CACHE_H
 #define __ARCH_ALPHA_CACHE_H
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>
 
 /* Bytes per L1 (data) cache line. */
@@ -22,3 +24,5 @@
 #define SMP_CACHE_BYTES    L1_CACHE_BYTES
 
 #endif
+
+#endif
--- kernel-headers/asm-alpha/param.h.kheaders	2000-11-08 02:37:31.000000000 -0500
+++ kernel-headers/asm-alpha/param.h	2002-12-17 05:22:41.000000000 -0500
@@ -5,14 +5,8 @@
    hardware ignores reprogramming.  We also need userland buy-in to the 
    change in HZ, since this is visible in the wait4 resources etc.  */
 
-#include <linux/config.h>
-
 #ifndef HZ
-# ifndef CONFIG_ALPHA_RAWHIDE
-#  define HZ	1024
-# else
-#  define HZ	1200
-# endif
+# define HZ 1024
 #endif
 
 #define EXEC_PAGESIZE	8192
@@ -27,8 +21,4 @@
 
 #define MAXHOSTNAMELEN	64	/* max length of hostname */
 
-#ifdef __KERNEL__
-# define CLOCKS_PER_SEC	HZ	/* frequency at which times() counts */
-#endif
-
 #endif /* _ASM_ALPHA_PARAM_H */
--- kernel-headers/asm-alpha/system.h.kheaders	2001-10-04 21:47:08.000000000 -0400
+++ kernel-headers/asm-alpha/system.h	2002-12-17 05:23:58.000000000 -0500
@@ -1,7 +1,6 @@
 #ifndef __ALPHA_SYSTEM_H
 #define __ALPHA_SYSTEM_H
 
-#include <linux/config.h>
 #include <asm/pal.h>
 #include <asm/page.h>
 
@@ -20,11 +19,7 @@
 /* Remove when official MILO sources have ELF support: */
 #define BOOT_SIZE	(16*1024)
 
-#ifdef CONFIG_ALPHA_LEGACY_START_ADDRESS
 #define KERNEL_START_PHYS	0x300000 /* Old bootloaders hardcoded this.  */
-#else
-#define KERNEL_START_PHYS	0x1000000 /* required: Wildfire/Titan/Marvel */
-#endif
 
 #define KERNEL_START	(PAGE_OFFSET+KERNEL_START_PHYS)
 #define SWAPPER_PGD	KERNEL_START
@@ -151,15 +147,9 @@ __asm__ __volatile__("mb": : :"memory")
 #define wmb() \
 __asm__ __volatile__("wmb": : :"memory")
 
-#ifdef CONFIG_SMP
 #define smp_mb()	mb()
 #define smp_rmb()	rmb()
 #define smp_wmb()	wmb()
-#else
-#define smp_mb()	barrier()
-#define smp_rmb()	barrier()
-#define smp_wmb()	barrier()
-#endif
 
 #define set_mb(var, value) \
 do { var = value; mb(); } while (0)
@@ -316,8 +306,6 @@ extern int __min_ipl;
 #define local_irq_disable()		__cli()
 #define local_irq_enable()		__sti()
 
-#ifdef CONFIG_SMP
-
 extern int global_irq_holder;
 
 #define save_and_cli(flags)     (save_flags(flags), cli())
@@ -332,16 +320,6 @@ extern void __global_restore_flags(unsig
 #define save_flags(flags)	((flags) = __global_save_flags())
 #define restore_flags(flags)    __global_restore_flags(flags)
 
-#else /* CONFIG_SMP */
-
-#define cli()			__cli()
-#define sti()			__sti()
-#define save_flags(flags)	__save_flags(flags)
-#define save_and_cli(flags)	__save_and_cli(flags)
-#define restore_flags(flags)	__restore_flags(flags)
-
-#endif /* CONFIG_SMP */
-
 /*
  * TB routines..
  */
@@ -379,9 +357,7 @@ __xchg_u32(volatile int *m, unsigned lon
 	"	bis $31,%3,%1\n"
 	"	stl_c %1,%2\n"
 	"	beq %1,2f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"2:	br 1b\n"
 	".previous"
@@ -401,9 +377,7 @@ __xchg_u64(volatile long *m, unsigned lo
 	"	bis $31,%3,%1\n"
 	"	stq_c %1,%2\n"
 	"	beq %1,2f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"2:	br 1b\n"
 	".previous"
@@ -464,9 +438,7 @@ __cmpxchg_u32(volatile int *m, int old, 
 	"	mov %4,%1\n"
 	"	stl_c %1,%2\n"
 	"	beq %1,3f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	"2:\n"
 	".subsection 2\n"
 	"3:	br 1b\n"
@@ -489,9 +461,7 @@ __cmpxchg_u64(volatile long *m, unsigned
 	"	mov %4,%1\n"
 	"	stq_c %1,%2\n"
 	"	beq %1,3f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	"2:\n"
 	".subsection 2\n"
 	"3:	br 1b\n"
--- kernel-headers/asm-i386/mtrr.h.kheaders	2002-12-17 05:09:36.000000000 -0500
+++ kernel-headers/asm-i386/mtrr.h	2002-12-17 05:22:41.000000000 -0500
@@ -23,7 +23,6 @@
 #ifndef _LINUX_MTRR_H
 #define _LINUX_MTRR_H
 
-#include <linux/config.h>
 #include <linux/ioctl.h>
 
 #define	MTRR_IOCTL_BASE	'M'
--- kernel-headers/asm-i386/byteorder.h.kheaders	2001-11-22 14:46:18.000000000 -0500
+++ kernel-headers/asm-i386/byteorder.h	2002-12-17 05:22:41.000000000 -0500
@@ -5,22 +5,9 @@
 
 #ifdef __GNUC__
 
-/* For avoiding bswap on i386 */
-#ifdef __KERNEL__
-#include <linux/config.h>
-#endif
-
 static __inline__ __const__ __u32 ___arch__swab32(__u32 x)
 {
-#ifdef CONFIG_X86_BSWAP
 	__asm__("bswap %0" : "=r" (x) : "0" (x));
-#else
-	__asm__("xchgb %b0,%h0\n\t"	/* swap lower bytes	*/
-		"rorl $16,%0\n\t"	/* swap words		*/
-		"xchgb %b0,%h0"		/* swap higher bytes	*/
-		:"=q" (x)
-		: "0" (x));
-#endif
 	return x;
 }
 
--- kernel-headers/asm-i386/cache.h.kheaders	2001-11-22 14:46:18.000000000 -0500
+++ kernel-headers/asm-i386/cache.h	2002-12-17 05:22:41.000000000 -0500
@@ -4,6 +4,8 @@
 #ifndef __ARCH_I386_CACHE_H
 #define __ARCH_I386_CACHE_H
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>
 
 /* L1 cache line size */
@@ -11,3 +13,5 @@
 #define L1_CACHE_BYTES	(1 << L1_CACHE_SHIFT)
 
 #endif
+
+#endif
--- kernel-headers/asm-i386/processor.h.kheaders	2002-12-17 05:10:14.000000000 -0500
+++ kernel-headers/asm-i386/processor.h	2002-12-17 05:22:41.000000000 -0500
@@ -15,7 +15,6 @@
 #include <asm/sigcontext.h>
 #include <asm/cpufeature.h>
 #include <linux/cache.h>
-#include <linux/config.h>
 #include <linux/threads.h>
 
 /*
@@ -73,13 +72,8 @@ struct cpuinfo_x86 {
 extern struct cpuinfo_x86 boot_cpu_data;
 extern struct tss_struct init_tss[NR_CPUS];
 
-#ifdef CONFIG_SMP
 extern struct cpuinfo_x86 cpu_data[];
 #define current_cpu_data cpu_data[smp_processor_id()]
-#else
-#define cpu_data (&boot_cpu_data)
-#define current_cpu_data boot_cpu_data
-#endif
 
 #define cpu_has_pge	(test_bit(X86_FEATURE_PGE,  boot_cpu_data.x86_capability))
 #define cpu_has_pse	(test_bit(X86_FEATURE_PSE,  boot_cpu_data.x86_capability))
@@ -253,11 +247,7 @@ static inline void clear_in_cr4 (unsigne
 /*
  * Bus types (default is ISA, but people can check others with these..)
  */
-#ifdef CONFIG_EISA
 extern int EISA_bus;
-#else
-#define EISA_bus (0)
-#endif
 extern int MCA_bus;
 
 /* from system description table in BIOS.  Mostly for MCA use, but
--- kernel-headers/asm-i386/atomic.h.kheaders	2001-11-22 14:46:18.000000000 -0500
+++ kernel-headers/asm-i386/atomic.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,18 +1,12 @@
 #ifndef __ARCH_I386_ATOMIC__
 #define __ARCH_I386_ATOMIC__
 
-#include <linux/config.h>
-
 /*
  * Atomic operations that C can't guarantee us.  Useful for
  * resource counting etc..
  */
 
-#ifdef CONFIG_SMP
 #define LOCK "lock ; "
-#else
-#define LOCK ""
-#endif
 
 /*
  * Make sure gcc doesn't try to be clever and move things around
--- kernel-headers/asm-i386/bitops.h.kheaders	2002-12-17 05:09:36.000000000 -0500
+++ kernel-headers/asm-i386/bitops.h	2002-12-17 05:22:41.000000000 -0500
@@ -5,8 +5,6 @@
  * Copyright 1992, Linus Torvalds.
  */
 
-#include <linux/config.h>
-
 /*
  * These have to be done with inline assembly: that way the bit-setting
  * is guaranteed to be atomic. All bit operations return 0 if the bit
@@ -15,11 +13,7 @@
  * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
  */
 
-#ifdef CONFIG_SMP
 #define LOCK_PREFIX "lock ; "
-#else
-#define LOCK_PREFIX ""
-#endif
 
 #define ADDR (*(volatile long *) addr)
 
--- kernel-headers/asm-i386/system.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-i386/system.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,7 +1,6 @@
 #ifndef __ASM_SYSTEM_H
 #define __ASM_SYSTEM_H
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <asm/segment.h>
--- kernel-headers/asm-i386/timex.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-i386/timex.h	2002-12-17 05:22:41.000000000 -0500
@@ -6,7 +6,6 @@
 #ifndef _ASMi386_TIMEX_H
 #define _ASMi386_TIMEX_H
 
-#include <linux/config.h>
 #include <asm/msr.h>
 
 #ifdef CONFIG_MELAN
@@ -40,14 +39,10 @@ extern cycles_t cacheflush_time;
 
 static inline cycles_t get_cycles (void)
 {
-#ifndef CONFIG_X86_TSC
-	return 0;
-#else
 	unsigned long long ret;
 
 	rdtscll(ret);
 	return ret;
-#endif
 }
 
 extern unsigned long cpu_khz;
--- kernel-headers/asm-i386/uaccess.h.kheaders	2001-11-22 14:46:20.000000000 -0500
+++ kernel-headers/asm-i386/uaccess.h	2002-12-17 05:22:41.000000000 -0500
@@ -4,7 +4,6 @@
 /*
  * User space memory access functions
  */
-#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/prefetch.h>
 #include <asm/page.h>
--- kernel-headers/asm-ia64/atomic.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-ia64/atomic.h	2002-12-17 05:22:41.000000000 -0500
@@ -22,6 +22,8 @@
  */
 typedef struct { volatile __s32 counter; } atomic_t;
 
+#ifdef __KERNEL__
+
 #define ATOMIC_INIT(i)		((atomic_t) { (i) })
 
 #define atomic_read(v)		((v)->counter)
@@ -91,6 +93,8 @@ atomic_add_negative (int i, atomic_t *v)
 #define atomic_inc(v)			atomic_add(1, (v))
 #define atomic_dec(v)			atomic_sub(1, (v))
 
+#endif /* __KERNEL__ */
+
 /* Atomic operations are already serializing */
 #define smp_mb__before_atomic_dec()	barrier()
 #define smp_mb__after_atomic_dec()	barrier()
--- kernel-headers/asm-ia64/cache.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-ia64/cache.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,6 +1,8 @@
 #ifndef _ASM_IA64_CACHE_H
 #define _ASM_IA64_CACHE_H
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>
 
 /*
@@ -25,4 +27,6 @@
 # define SMP_CACHE_BYTES	(1 << 3)
 #endif
 
+#endif
+
 #endif /* _ASM_IA64_CACHE_H */
--- kernel-headers/asm-ia64/page.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-ia64/page.h	2002-12-17 05:22:41.000000000 -0500
@@ -7,26 +7,9 @@
  * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
-#include <linux/config.h>
-
 #include <asm/types.h>
 
-/*
- * PAGE_SHIFT determines the actual kernel page size.
- */
-#if defined(CONFIG_IA64_PAGE_SIZE_4KB)
-# define PAGE_SHIFT	12
-#elif defined(CONFIG_IA64_PAGE_SIZE_8KB)
-# define PAGE_SHIFT	13
-#elif defined(CONFIG_IA64_PAGE_SIZE_16KB)
-# define PAGE_SHIFT	14
-#elif defined(CONFIG_IA64_PAGE_SIZE_64KB)
-# define PAGE_SHIFT	16
-#else
-# error Unsupported page size!
-#endif
-
-#define PAGE_SIZE		(__IA64_UL_CONST(1) << PAGE_SHIFT)
+#define PAGE_SIZE               getpagesize()
 #define PAGE_MASK		(~(PAGE_SIZE - 1))
 #define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
 
--- kernel-headers/asm-ia64/param.h.kheaders	2004-04-14 09:05:40.000000000 -0400
+++ kernel-headers/asm-ia64/param.h	2005-09-05 12:08:12.000000000 -0400
@@ -22,25 +22,6 @@
 
 #define MAXHOSTNAMELEN	64	/* max length of hostname */
 
-#ifdef __KERNEL__
-# include <linux/config.h>	/* mustn't include <linux/config.h> outside of #ifdef __KERNEL__ */
-# ifdef CONFIG_IA64_HP_SIM
-  /*
-   * Yeah, simulating stuff is slow, so let us catch some breath between
-   * timer interrupts...
-   */
-#  define HZ	  32
-# else
-#  define HZ	1024
-# endif
-# define USER_HZ	HZ
-# define CLOCKS_PER_SEC	HZ	/* frequency at which times() counts */
-#else
-   /*
-    * Technically, this is wrong, but some old apps still refer to it.  The proper way to
-    * get the HZ value is via sysconf(_SC_CLK_TCK).
-    */
 # define HZ 1024
-#endif
 
 #endif /* _ASM_IA64_PARAM_H */
--- kernel-headers/asm-ia64/ptrace.h.kheaders	2002-08-02 20:39:45.000000000 -0400
+++ kernel-headers/asm-ia64/ptrace.h	2002-12-17 05:22:41.000000000 -0500
@@ -48,30 +48,9 @@
  * This is because ar.ec is saved as part of ar.pfs.
  */
 
-#include <linux/config.h>
-
 #include <asm/fpu.h>
 #include <asm/offsets.h>
 
-/*
- * Base-2 logarithm of number of pages to allocate per task structure
- * (including register backing store and memory stack):
- */
-#if defined(CONFIG_IA64_PAGE_SIZE_4KB)
-# define IA64_TASK_STRUCT_LOG_NUM_PAGES		3
-#elif defined(CONFIG_IA64_PAGE_SIZE_8KB)
-# define IA64_TASK_STRUCT_LOG_NUM_PAGES		2
-#elif defined(CONFIG_IA64_PAGE_SIZE_16KB)
-# define IA64_TASK_STRUCT_LOG_NUM_PAGES		1
-#else
-# define IA64_TASK_STRUCT_LOG_NUM_PAGES		0
-#endif
-
-#define IA64_RBS_OFFSET			((IA64_TASK_SIZE + 15) & ~15)
-#define IA64_STK_OFFSET			((1 << IA64_TASK_STRUCT_LOG_NUM_PAGES)*PAGE_SIZE)
-
-#define INIT_TASK_SIZE			IA64_STK_OFFSET
-
 #ifndef __ASSEMBLY__
 
 #include <asm/current.h>
--- kernel-headers/asm-ia64/string.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-ia64/string.h	2002-12-17 05:25:14.000000000 -0500
@@ -9,6 +9,8 @@
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>	/* remove this once we remove the A-step workaround... */
 
 #define __HAVE_ARCH_STRLEN	1 /* see arch/ia64/lib/strlen.S */
@@ -20,4 +22,6 @@ extern __kernel_size_t strlen (const cha
 extern void *memcpy (void *, const void *, __kernel_size_t);
 extern void *memset (void *, int, __kernel_size_t);
 
+#endif
+
 #endif /* _ASM_IA64_STRING_H */
--- kernel-headers/asm-ia64/system.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-ia64/system.h	2002-12-17 05:25:48.000000000 -0500
@@ -12,7 +12,6 @@
  * Copyright (C) 1999 Asit Mallick <asit.k.mallick@intel.com>
  * Copyright (C) 1999 Don Dugger <don.dugger@intel.com>
  */
-#include <linux/config.h>
 
 #include <asm/kregs.h>
 #include <asm/page.h>
@@ -54,6 +53,20 @@ extern struct ia64_boot_param {
 	__u64 initrd_size;
 } *ia64_boot_param;
 
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+
+#if defined(CONFIG_ITANIUM_ASTEP_SPECIFIC) \
+    || defined(CONFIG_ITANIUM_B0_SPECIFIC) || defined(CONFIG_ITANIUM_B1_SPECIFIC)
+  /* Workaround for Errata 97.  */
+# define IA64_SEMFIX_INSN	mf;
+# define IA64_SEMFIX	"mf;"
+#else
+# define IA64_SEMFIX_INSN
+# define IA64_SEMFIX	""
+#endif
+
 static inline void
 ia64_insn_group_barrier (void)
 {
@@ -213,8 +226,6 @@ do {										\
 # define restore_flags(flags)	__restore_flags(flags)
 #endif /* !CONFIG_SMP */
 
-#ifdef __KERNEL__
-
 #define prepare_to_switch()    local_irq_disable()
 
 #ifdef CONFIG_IA32_SUPPORT
--- kernel-headers/asm-ppc/bitops.h.kheaders	2001-06-11 22:15:27.000000000 -0400
+++ kernel-headers/asm-ppc/bitops.h	2002-12-17 05:22:41.000000000 -0500
@@ -2,11 +2,9 @@
  * bitops.h: Bit string operations on the ppc
  */
 
-#ifdef __KERNEL__
 #ifndef _PPC_BITOPS_H
 #define _PPC_BITOPS_H
 
-#include <linux/config.h>
 #include <asm/byteorder.h>
 #include <asm/atomic.h>
 
@@ -14,13 +12,8 @@
  * The test_and_*_bit operations are taken to imply a memory barrier
  * on SMP systems.
  */
-#ifdef CONFIG_SMP
 #define SMP_WMB		"eieio\n"
 #define SMP_MB		"\nsync"
-#else
-#define SMP_WMB
-#define SMP_MB
-#endif /* CONFIG_SMP */
 
 /*
  * These used to be if'd out here because using : "cc" as a constraint
@@ -237,6 +230,8 @@
 	return __ilog2(x & -x);
 }
 
+#ifdef __KERNEL__
+
 /*
  * ffs: find first bit set. This is defined the same way as
  * the libc and compiler builtin ffs routines, therefore
@@ -256,6 +251,10 @@
 #define hweight16(x) generic_hweight16(x)
 #define hweight8(x) generic_hweight8(x)
 
+#endif /* __KERNEL__ */
+
+#ifdef __KERNEL__
+
 /*
  * This implementation of find_{first,next}_zero_bit was stolen from
  * Linus' asm-alpha/bitops.h.
@@ -365,5 +364,6 @@
 #define minix_test_bit(nr,addr) ext2_test_bit(nr,addr)
 #define minix_find_first_zero_bit(addr,size) ext2_find_first_zero_bit(addr,size)
 
-#endif /* _PPC_BITOPS_H */
 #endif /* __KERNEL__ */
+
+#endif /* _PPC_BITOPS_H */
--- kernel-headers/asm-ppc/io.h.kheaders	2001-11-02 20:43:54.000000000 -0500
+++ kernel-headers/asm-ppc/io.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,8 +1,6 @@
-#ifdef __KERNEL__
 #ifndef _PPC_IO_H
 #define _PPC_IO_H
 
-#include <linux/config.h>
 #include <linux/mm.h>
 #include <linux/types.h>
 #include <asm/mmu.h>
@@ -441,4 +439,3 @@
 
 #endif /* CONFIG_NOT_COHERENT_CACHE */
 #endif /* _PPC_IO_H */
-#endif /* __KERNEL__ */
--- kernel-headers/asm-s390/bitops.h.kheaders	2002-08-02 20:39:45.000000000 -0400
+++ kernel-headers/asm-s390/bitops.h	2002-12-17 05:22:41.000000000 -0500
@@ -12,7 +12,6 @@
  *    Copyright (C) 1992, Linus Torvalds
  *
  */
-#include <linux/config.h>
 
 /*
  * bit 0 is the LSB of *addr; bit 31 is the MSB of *addr;
@@ -48,7 +47,6 @@ extern const char _oi_bitmap[];
 extern const char _ni_bitmap[];
 extern const char _zb_findmap[];
 
-#ifdef CONFIG_SMP
 /*
  * SMP save set_bit routine based on compare and swap (CS)
  */
@@ -239,7 +237,6 @@ static __inline__ int test_and_change_bi
              : "cc", "memory" );
         return nr != 0;
 }
-#endif /* CONFIG_SMP */
 
 /*
  * fast, non-SMP set_bit routine
@@ -553,22 +550,12 @@ static __inline__ int test_and_change_bi
 }
 #define __test_and_change_bit(X,Y)	test_and_change_bit_simple(X,Y)
 
-#ifdef CONFIG_SMP
 #define set_bit             set_bit_cs
 #define clear_bit           clear_bit_cs
 #define change_bit          change_bit_cs
 #define test_and_set_bit    test_and_set_bit_cs
 #define test_and_clear_bit  test_and_clear_bit_cs
 #define test_and_change_bit test_and_change_bit_cs
-#else
-#define set_bit             set_bit_simple
-#define clear_bit           clear_bit_simple
-#define change_bit          change_bit_simple
-#define test_and_set_bit    test_and_set_bit_simple
-#define test_and_clear_bit  test_and_clear_bit_simple
-#define test_and_change_bit test_and_change_bit_simple
-#endif
-
 
 /*
  * This routine doesn't need to be atomic.
--- kernel-headers/asm-s390/ptrace.h.kheaders	2002-08-02 20:39:45.000000000 -0400
+++ kernel-headers/asm-s390/ptrace.h	2002-12-17 05:22:41.000000000 -0500
@@ -106,7 +106,6 @@
 #define STACK_FRAME_OVERHEAD	96	/* size of minimum stack frame */
 
 #ifndef __ASSEMBLY__
-#include <linux/config.h>
 #include <linux/stddef.h>
 #include <linux/types.h>
 
--- kernel-headers/asm-s390/system.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-s390/system.h	2002-12-17 05:26:27.000000000 -0500
@@ -11,9 +11,9 @@
 #ifndef __ASM_SYSTEM_H
 #define __ASM_SYSTEM_H
 
-#include <linux/config.h>
 #include <asm/types.h>
 #ifdef __KERNEL__
+#include <linux/config.h>
 #include <asm/lowcore.h>
 #endif
 #include <linux/kernel.h>
@@ -212,8 +212,6 @@ static inline unsigned long __xchg(unsig
 #define local_irq_disable()	__cli()
 #define local_irq_enable()	__sti()
 
-#ifdef CONFIG_SMP
-
 extern void __global_cli(void);
 extern void __global_sti(void);
 
@@ -235,21 +233,6 @@
 #define ctl_set_bit(cr, bit) smp_ctl_set_bit(cr, bit)
 #define ctl_clear_bit(cr, bit) smp_ctl_clear_bit(cr, bit)
 
-#else
-
-#define cli() __cli()
-#define sti() __sti()
-#define save_flags(x) __save_flags(x)
-#define restore_flags(x) __restore_flags(x)
-#define save_and_cli(x) __save_and_cli(x)
-#define save_and_sti(x) __save_and_sti(x)
-
-#define ctl_set_bit(cr, bit) __ctl_set_bit(cr, bit)
-#define ctl_clear_bit(cr, bit) __ctl_clear_bit(cr, bit)
-
-
-#endif
-
 #ifdef __KERNEL__
 extern struct task_struct *resume(void *, void *);
 
--- kernel-headers/asm-sparc/atomic.h.kheaders	2001-10-30 18:08:11.000000000 -0500
+++ kernel-headers/asm-sparc/atomic.h	2002-12-17 05:22:41.000000000 -0500
@@ -7,18 +7,10 @@
 #ifndef __ARCH_SPARC_ATOMIC__
 #define __ARCH_SPARC_ATOMIC__
 
-#include <linux/config.h>
-
 typedef struct { volatile int counter; } atomic_t;
 
 #ifdef __KERNEL__
-#ifndef CONFIG_SMP
-
-#define ATOMIC_INIT(i)  { (i) }
-#define atomic_read(v)          ((v)->counter)
-#define atomic_set(v, i)        (((v)->counter) = i)
 
-#else
 /* We do the bulk of the actual work out of line in two common
  * routines in assembler, see arch/sparc/lib/atomic.S for the
  * "fun" details.
@@ -46,7 +38,6 @@ static __inline__ int atomic_read(atomic
 }
 
 #define atomic_set(v, i)	(((v)->counter) = ((i) << 8))
-#endif
 
 static __inline__ int __atomic_add(int i, atomic_t *v)
 {
--- kernel-headers/asm-sparc/elf.h.kheaders	2000-07-11 22:02:37.000000000 -0400
+++ kernel-headers/asm-sparc/elf.h	2002-12-17 05:22:41.000000000 -0500
@@ -6,7 +6,6 @@
  * ELF register definitions..
  */
 
-#include <linux/config.h>
 #include <asm/ptrace.h>
 #include <asm/mbus.h>
 
--- kernel-headers/asm-sparc/io.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-sparc/io.h	2002-12-17 05:27:19.000000000 -0500
@@ -4,225 +4,6 @@
 #ifndef __SPARC_IO_H
 #define __SPARC_IO_H
 
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/ioport.h>  /* struct resource */
-
-#include <asm/page.h>      /* IO address mapping routines need this */
-#include <asm/system.h>
-
-#define virt_to_bus virt_to_phys
-#define bus_to_virt phys_to_virt
-#define page_to_phys(page)     ((((page) - mem_map) << PAGE_SHIFT)+phys_base)
-
-static __inline__ u32 flip_dword (u32 d)
-{
-	return ((d&0xff)<<24) | (((d>>8)&0xff)<<16) | (((d>>16)&0xff)<<8)| ((d>>24)&0xff);
-}
-
-static __inline__ u16 flip_word (u16 d)
-{
-	return ((d&0xff) << 8) | ((d>>8)&0xff);
-}
-
-/*
- * Memory mapped I/O to PCI
- */
-static __inline__ u8 readb(unsigned long addr)
-{
-	return *(volatile u8 *)addr;
-}
-
-static __inline__ u16 readw(unsigned long addr)
-{
-	return flip_word(*(volatile u16 *)addr);
-}
-
-static __inline__ u32 readl(unsigned long addr)
-{
-	return flip_dword(*(volatile u32 *)addr);
-}
-
-static __inline__ void writeb(u8 b, unsigned long addr)
-{
-	*(volatile u8 *)addr = b;
-}
-
-static __inline__ void writew(u16 b, unsigned long addr)
-{
-	*(volatile u16 *)addr = flip_word(b);
-}
-
-static __inline__ void writel(u32 b, unsigned long addr)
-{
-	*(volatile u32 *)addr = flip_dword(b);
-}
-
-/* Now the 'raw' versions. */
-static __inline__ u8 __raw_readb(unsigned long addr)
-{
-	return *(volatile u8 *)addr;
-}
-
-static __inline__ u16 __raw_readw(unsigned long addr)
-{
-	return *(volatile u16 *)addr;
-}
-
-static __inline__ u32 __raw_readl(unsigned long addr)
-{
-	return *(volatile u32 *)addr;
-}
-
-static __inline__ void __raw_writeb(u8 b, unsigned long addr)
-{
-	*(volatile u8 *)addr = b;
-}
-
-static __inline__ void __raw_writew(u16 b, unsigned long addr)
-{
-	*(volatile u16 *)addr = b;
-}
-
-static __inline__ void __raw_writel(u32 b, unsigned long addr)
-{
-	*(volatile u32 *)addr = b;
-}
-
-/*
- * I/O space operations
- *
- * Arrangement on a Sun is somewhat complicated.
- *
- * First of all, we want to use standard Linux drivers
- * for keyboard, PC serial, etc. These drivers think
- * they access I/O space and use inb/outb.
- * On the other hand, EBus bridge accepts PCI *memory*
- * cycles and converts them into ISA *I/O* cycles.
- * Ergo, we want inb & outb to generate PCI memory cycles.
- *
- * If we want to issue PCI *I/O* cycles, we do this
- * with a low 64K fixed window in PCIC. This window gets
- * mapped somewhere into virtual kernel space and we
- * can use inb/outb again.
- */
-#define inb_local(addr)		readb(addr)
-#define inb(addr)		readb(addr)
-#define inw(addr)		readw(addr)
-#define inl(addr)		readl(addr)
-#define inb_p(addr)		readb(addr)
-
-#define outb_local(b, addr)	writeb(b, addr)
-#define outb(b, addr)		writeb(b, addr)
-#define outw(b, addr)		writew(b, addr)
-#define outl(b, addr)		writel(b, addr)
-#define outb_p(b, addr)		writeb(b, addr)
-
-extern void outsb(unsigned long addr, const void *src, unsigned long cnt);
-extern void outsw(unsigned long addr, const void *src, unsigned long cnt);
-extern void outsl(unsigned long addr, const void *src, unsigned long cnt);
-extern void insb(unsigned long addr, void *dst, unsigned long count);
-extern void insw(unsigned long addr, void *dst, unsigned long count);
-extern void insl(unsigned long addr, void *dst, unsigned long count);
-
-#define IO_SPACE_LIMIT 0xffffffff
-
-/*
- * SBus accessors.
- *
- * SBus has only one, memory mapped, I/O space.
- * We do not need to flip bytes for SBus of course.
- */
-static __inline__ u8 _sbus_readb(unsigned long addr)
-{
-	return *(volatile u8 *)addr;
-}
-
-static __inline__ u16 _sbus_readw(unsigned long addr)
-{
-	return *(volatile u16 *)addr;
-}
-
-static __inline__ u32 _sbus_readl(unsigned long addr)
-{
-	return *(volatile u32 *)addr;
-}
-
-static __inline__ void _sbus_writeb(u8 b, unsigned long addr)
-{
-	*(volatile u8 *)addr = b;
-}
-
-static __inline__ void _sbus_writew(u16 b, unsigned long addr)
-{
-	*(volatile u16 *)addr = b;
-}
-
-static __inline__ void _sbus_writel(u32 b, unsigned long addr)
-{
-	*(volatile u32 *)addr = b;
-}
-
-/*
- * The only reason for #define's is to hide casts to unsigned long.
- * XXX Rewrite drivers without structures for registers.
- */
-#define sbus_readb(a)		_sbus_readb((unsigned long)(a))
-#define sbus_readw(a)		_sbus_readw((unsigned long)(a))
-#define sbus_readl(a)		_sbus_readl((unsigned long)(a))
-#define sbus_writeb(v, a)	_sbus_writeb(v, (unsigned long)(a))
-#define sbus_writew(v, a)	_sbus_writew(v, (unsigned long)(a))
-#define sbus_writel(v, a)	_sbus_writel(v, (unsigned long)(a))
-
-static inline void *sbus_memset_io(void *__dst, int c, __kernel_size_t n)
-{
-	unsigned long dst = (unsigned long)__dst;
-
-	while(n--) {
-		sbus_writeb(c, dst);
-		dst++;
-	}
-	return (void *) dst;
-}
-
-#ifdef __KERNEL__
-
-/*
- * Bus number may be embedded in the higher bits of the physical address.
- * This is why we have no bus number argument to ioremap().
- */
-extern void *ioremap(unsigned long offset, unsigned long size);
-#define ioremap_nocache(X,Y)	ioremap((X),(Y))
-extern void iounmap(void *addr);
-
-/* P3: talk davem into dropping "name" argument in favor of res->name */
-/*
- * Bus number may be in res->flags... somewhere.
- */
-extern unsigned long sbus_ioremap(struct resource *res, unsigned long offset,
-    unsigned long size, char *name);
-/* XXX Partial deallocations? I think not! */
-extern void sbus_iounmap(unsigned long vaddr, unsigned long size);
-
-
-#define virt_to_phys(x) __pa((unsigned long)(x))
-#define phys_to_virt(x) __va((unsigned long)(x))
-
-/*
- * At the moment, we do not use CMOS_READ anywhere outside of rtc.c,
- * so rtc_port is static in it. This should not change unless a new
- * hardware pops up.
- */
-#define RTC_PORT(x)   (rtc_port + (x))
-#define RTC_ALWAYS_BCD  0
-
-/* Nothing to do */
-/* P3: Only IDE DMA may need these. */
-
-#define dma_cache_inv(_start,_size)		do { } while (0)
-#define dma_cache_wback(_start,_size)		do { } while (0)
-#define dma_cache_wback_inv(_start,_size)	do { } while (0)
-
-#endif
+#error Never include asm/io.h ! This is kernel only.
 
 #endif /* !(__SPARC_IO_H) */
--- kernel-headers/asm-sparc/page.h.kheaders	2002-08-02 20:39:45.000000000 -0400
+++ kernel-headers/asm-sparc/page.h	2002-12-17 05:22:41.000000000 -0500
@@ -8,12 +8,8 @@
 #ifndef _SPARC_PAGE_H
 #define _SPARC_PAGE_H
 
-#include <linux/config.h>
-#ifdef CONFIG_SUN4
-#define PAGE_SHIFT   13
-#else
 #define PAGE_SHIFT   12
-#endif
+
 #ifndef __ASSEMBLY__
 /* I have my suspicions... -DaveM */
 #define PAGE_SIZE    (1UL << PAGE_SHIFT)
@@ -22,166 +18,4 @@
 #endif
 #define PAGE_MASK    (~(PAGE_SIZE-1))
 
-#ifdef __KERNEL__
-
-#include <asm/head.h>       /* for KERNBASE */
-#include <asm/btfixup.h>
-
-/* This is always 2048*sizeof(long), doesn't change with PAGE_SIZE */
-#define TASK_UNION_SIZE		8192
-
-#ifndef __ASSEMBLY__
-
-/*
- * XXX I am hitting compiler bugs with __builtin_trap. This has
- * hit me before and rusty was blaming his netfilter bugs on
- * this so lets disable it. - Anton
- */
-#if 0
-/* We need the mb()'s so we don't trigger a compiler bug - Anton */
-#define BUG() do { \
-	mb(); \
-	__builtin_trap(); \
-	mb(); \
-} while(0)
-#else
-#define BUG() do { \
-	printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); *(int *)0=0; \
-} while (0)
-#endif
-
-#define PAGE_BUG(page)	BUG()
-
-#define clear_page(page)	 memset((void *)(page), 0, PAGE_SIZE)
-#define copy_page(to,from) 	memcpy((void *)(to), (void *)(from), PAGE_SIZE)
-#define clear_user_page(page, vaddr)	clear_page(page)
-#define copy_user_page(to, from, vaddr)	copy_page(to, from)
-
-/* The following structure is used to hold the physical
- * memory configuration of the machine.  This is filled in
- * probe_memory() and is later used by mem_init() to set up
- * mem_map[].  We statically allocate SPARC_PHYS_BANKS of
- * these structs, this is arbitrary.  The entry after the
- * last valid one has num_bytes==0.
- */
-
-struct sparc_phys_banks {
-  unsigned long base_addr;
-  unsigned long num_bytes;
-};
-
-#define SPARC_PHYS_BANKS 32
-
-extern struct sparc_phys_banks sp_banks[SPARC_PHYS_BANKS];
-
-/* Cache alias structure.  Entry is valid if context != -1. */
-struct cache_palias {
-	unsigned long vaddr;
-	int context;
-};
-
-extern struct cache_palias *sparc_aliases;
-
-/* passing structs on the Sparc slow us down tremendously... */
-
-/* #define STRICT_MM_TYPECHECKS */
-
-#ifdef STRICT_MM_TYPECHECKS
-/*
- * These are used to make use of C type-checking..
- */
-typedef struct { unsigned long pte; } pte_t;
-typedef struct { unsigned long iopte; } iopte_t;
-typedef struct { unsigned long pmd; } pmd_t;
-typedef struct { unsigned long pgd; } pgd_t;
-typedef struct { unsigned long ctxd; } ctxd_t;
-typedef struct { unsigned long pgprot; } pgprot_t;
-typedef struct { unsigned long iopgprot; } iopgprot_t;
-
-#define pte_val(x)	((x).pte)
-#define iopte_val(x)	((x).iopte)
-#define pmd_val(x)      ((x).pmd)
-#define pgd_val(x)	((x).pgd)
-#define ctxd_val(x)	((x).ctxd)
-#define pgprot_val(x)	((x).pgprot)
-#define iopgprot_val(x)	((x).iopgprot)
-
-#define __pte(x)	((pte_t) { (x) } )
-#define __iopte(x)	((iopte_t) { (x) } )
-#define __pmd(x)        ((pmd_t) { (x) } )
-#define __pgd(x)	((pgd_t) { (x) } )
-#define __ctxd(x)	((ctxd_t) { (x) } )
-#define __pgprot(x)	((pgprot_t) { (x) } )
-#define __iopgprot(x)	((iopgprot_t) { (x) } )
-
-#else
-/*
- * .. while these make it easier on the compiler
- */
-typedef unsigned long pte_t;
-typedef unsigned long iopte_t;
-typedef unsigned long pmd_t;
-typedef unsigned long pgd_t;
-typedef unsigned long ctxd_t;
-typedef unsigned long pgprot_t;
-typedef unsigned long iopgprot_t;
-
-#define pte_val(x)	(x)
-#define iopte_val(x)	(x)
-#define pmd_val(x)      (x)
-#define pgd_val(x)	(x)
-#define ctxd_val(x)	(x)
-#define pgprot_val(x)	(x)
-#define iopgprot_val(x)	(x)
-
-#define __pte(x)	(x)
-#define __iopte(x)	(x)
-#define __pmd(x)        (x)
-#define __pgd(x)	(x)
-#define __ctxd(x)	(x)
-#define __pgprot(x)	(x)
-#define __iopgprot(x)	(x)
-
-#endif
-
-extern unsigned long sparc_unmapped_base;
-
-BTFIXUPDEF_SETHI(sparc_unmapped_base)
-
-#define TASK_UNMAPPED_BASE	BTFIXUP_SETHI(sparc_unmapped_base)
-
-/* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
-{
-	int order;
-
-	size = (size-1) >> (PAGE_SHIFT-1);
-	order = -1;
-	do {
-		size >>= 1;
-		order++;
-	} while (size);
-	return order;
-}
-
-#else /* !(__ASSEMBLY__) */
-
-#define __pgprot(x)	(x)
-
-#endif /* !(__ASSEMBLY__) */
-
-/* to align the pointer to the (next) page boundary */
-#define PAGE_ALIGN(addr)  (((addr)+PAGE_SIZE-1)&PAGE_MASK)
-
-#define PAGE_OFFSET	0xf0000000
-#define __pa(x)                 ((unsigned long)(x) - PAGE_OFFSET)
-#define __va(x)                 ((void *)((unsigned long) (x) + PAGE_OFFSET))
-#define virt_to_page(kaddr)	(mem_map + (__pa(kaddr) >> PAGE_SHIFT))
-#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
-
-#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
-				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
-
-#endif /* __KERNEL__ */
-
 #endif /* _SPARC_PAGE_H */
--- kernel-headers/asm-sparc/pgtable.h.kheaders	2002-08-02 20:39:45.000000000 -0400
+++ kernel-headers/asm-sparc/pgtable.h	2002-12-17 05:22:41.000000000 -0500
@@ -9,7 +9,6 @@
  *  Copyright (C) 1998 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
  */
 
-#include <linux/config.h>
 #include <linux/spinlock.h>
 #include <asm/asi.h>
 #ifdef CONFIG_SUN4
--- kernel-headers/asm-sparc/ptrace.h.kheaders	1997-03-17 17:54:31.000000000 -0500
+++ kernel-headers/asm-sparc/ptrace.h	2002-12-17 05:22:41.000000000 -0500
@@ -60,12 +60,6 @@ struct sparc_stackf {
 #define STACKFRAME_SZ sizeof(struct sparc_stackf)
 #define REGWIN_SZ     sizeof(struct reg_window)
 
-#ifdef __KERNEL__
-#define user_mode(regs) (!((regs)->psr & PSR_PS))
-#define instruction_pointer(regs) ((regs)->pc)
-extern void show_regs(struct pt_regs *);
-#endif
-
 #else /* __ASSEMBLY__ */
 /* For assembly code. */
 #define TRACEREG_SZ       0x50
@@ -73,8 +67,6 @@ extern void show_regs(struct pt_regs *);
 #define REGWIN_SZ         0x40
 #endif
 
-#include <asm/asm_offsets.h>
-
 /* These are for pt_regs. */
 #define PT_PSR    0x0
 #define PT_PC     0x4
--- kernel-headers/asm-sparc/system.h.kheaders	2001-10-30 18:08:11.000000000 -0500
+++ kernel-headers/asm-sparc/system.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,6 +1,4 @@
 /* $Id: system.h,v 1.86 2001/10/30 04:57:10 davem Exp $ */
-#include <linux/config.h>
-
 #ifndef __SPARC_SYSTEM_H
 #define __SPARC_SYSTEM_H
 
--- kernel-headers/asm-sparc64/io.h.kheaders	2002-02-25 14:38:13.000000000 -0500
+++ kernel-headers/asm-sparc64/io.h	2002-12-17 05:22:41.000000000 -0500
@@ -2,438 +2,6 @@
 #ifndef __SPARC64_IO_H
 #define __SPARC64_IO_H
 
-#include <linux/kernel.h>
-#include <linux/types.h>
-
-#include <asm/page.h>      /* IO address mapping routines need this */
-#include <asm/system.h>
-#include <asm/asi.h>
-
-/* PC crapola... */
-#define __SLOW_DOWN_IO	do { } while (0)
-#define SLOW_DOWN_IO	do { } while (0)
-
-extern unsigned long virt_to_bus_not_defined_use_pci_map(volatile void *addr);
-#define virt_to_bus virt_to_bus_not_defined_use_pci_map
-extern unsigned long bus_to_virt_not_defined_use_pci_map(volatile void *addr);
-#define bus_to_virt bus_to_virt_not_defined_use_pci_map
-
-extern unsigned long phys_base;
-#define page_to_phys(page)	((((page) - mem_map) << PAGE_SHIFT)+phys_base)
-
-/* Different PCI controllers we support have their PCI MEM space
- * mapped to an either 2GB (Psycho) or 4GB (Sabre) aligned area,
- * so need to chop off the top 33 or 32 bits.
- */
-extern unsigned long pci_memspace_mask;
-
-#define bus_dvma_to_mem(__vaddr) ((__vaddr) & pci_memspace_mask)
-
-static __inline__ u8 inb(unsigned long addr)
-{
-	u8 ret;
-
-	__asm__ __volatile__("lduba\t[%1] %2, %0\t/* pci_inb */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ u16 inw(unsigned long addr)
-{
-	u16 ret;
-
-	__asm__ __volatile__("lduha\t[%1] %2, %0\t/* pci_inw */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ u32 inl(unsigned long addr)
-{
-	u32 ret;
-
-	__asm__ __volatile__("lduwa\t[%1] %2, %0\t/* pci_inl */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ void outb(u8 b, unsigned long addr)
-{
-	__asm__ __volatile__("stba\t%r0, [%1] %2\t/* pci_outb */"
-			     : /* no outputs */
-			     : "Jr" (b), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static __inline__ void outw(u16 w, unsigned long addr)
-{
-	__asm__ __volatile__("stha\t%r0, [%1] %2\t/* pci_outw */"
-			     : /* no outputs */
-			     : "Jr" (w), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static __inline__ void outl(u32 l, unsigned long addr)
-{
-	__asm__ __volatile__("stwa\t%r0, [%1] %2\t/* pci_outl */"
-			     : /* no outputs */
-			     : "Jr" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-#define inb_p inb
-#define outb_p outb
-#define inw_p inw
-#define outw_p outw
-#define inl_p inl
-#define outl_p outl
-
-extern void outsb(unsigned long addr, const void *src, unsigned long count);
-extern void outsw(unsigned long addr, const void *src, unsigned long count);
-extern void outsl(unsigned long addr, const void *src, unsigned long count);
-extern void insb(unsigned long addr, void *dst, unsigned long count);
-extern void insw(unsigned long addr, void *dst, unsigned long count);
-extern void insl(unsigned long addr, void *dst, unsigned long count);
-
-/* Memory functions, same as I/O accesses on Ultra. */
-static __inline__ u8 _readb(unsigned long addr)
-{
-	u8 ret;
-
-	__asm__ __volatile__("lduba\t[%1] %2, %0\t/* pci_readb */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ u16 _readw(unsigned long addr)
-{
-	u16 ret;
-
-	__asm__ __volatile__("lduha\t[%1] %2, %0\t/* pci_readw */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ u32 _readl(unsigned long addr)
-{
-	u32 ret;
-
-	__asm__ __volatile__("lduwa\t[%1] %2, %0\t/* pci_readl */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ u64 _readq(unsigned long addr)
-{
-	u64 ret;
-
-	__asm__ __volatile__("ldxa\t[%1] %2, %0\t/* pci_readq */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ void _writeb(u8 b, unsigned long addr)
-{
-	__asm__ __volatile__("stba\t%r0, [%1] %2\t/* pci_writeb */"
-			     : /* no outputs */
-			     : "Jr" (b), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static __inline__ void _writew(u16 w, unsigned long addr)
-{
-	__asm__ __volatile__("stha\t%r0, [%1] %2\t/* pci_writew */"
-			     : /* no outputs */
-			     : "Jr" (w), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static __inline__ void _writel(u32 l, unsigned long addr)
-{
-	__asm__ __volatile__("stwa\t%r0, [%1] %2\t/* pci_writel */"
-			     : /* no outputs */
-			     : "Jr" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static __inline__ void _writeq(u64 q, unsigned long addr)
-{
-	__asm__ __volatile__("stxa\t%r0, [%1] %2\t/* pci_writeq */"
-			     : /* no outputs */
-			     : "Jr" (q), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-#define readb(__addr)		(_readb((unsigned long)(__addr)))
-#define readw(__addr)		(_readw((unsigned long)(__addr)))
-#define readl(__addr)		(_readl((unsigned long)(__addr)))
-#define readq(__addr)		(_readq((unsigned long)(__addr)))
-#define writeb(__b, __addr)	(_writeb((u8)(__b), (unsigned long)(__addr)))
-#define writew(__w, __addr)	(_writew((u16)(__w), (unsigned long)(__addr)))
-#define writel(__l, __addr)	(_writel((u32)(__l), (unsigned long)(__addr)))
-#define writeq(__q, __addr)	(_writeq((u64)(__q), (unsigned long)(__addr)))
-
-/* Now versions without byte-swapping. */
-static __inline__ u8 _raw_readb(unsigned long addr)
-{
-	u8 ret;
-
-	__asm__ __volatile__("lduba\t[%1] %2, %0\t/* pci_raw_readb */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ u16 _raw_readw(unsigned long addr)
-{
-	u16 ret;
-
-	__asm__ __volatile__("lduha\t[%1] %2, %0\t/* pci_raw_readw */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ u32 _raw_readl(unsigned long addr)
-{
-	u32 ret;
-
-	__asm__ __volatile__("lduwa\t[%1] %2, %0\t/* pci_raw_readl */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ u64 _raw_readq(unsigned long addr)
-{
-	u64 ret;
-
-	__asm__ __volatile__("ldxa\t[%1] %2, %0\t/* pci_raw_readq */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ void _raw_writeb(u8 b, unsigned long addr)
-{
-	__asm__ __volatile__("stba\t%r0, [%1] %2\t/* pci_raw_writeb */"
-			     : /* no outputs */
-			     : "Jr" (b), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static __inline__ void _raw_writew(u16 w, unsigned long addr)
-{
-	__asm__ __volatile__("stha\t%r0, [%1] %2\t/* pci_raw_writew */"
-			     : /* no outputs */
-			     : "Jr" (w), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static __inline__ void _raw_writel(u32 l, unsigned long addr)
-{
-	__asm__ __volatile__("stwa\t%r0, [%1] %2\t/* pci_raw_writel */"
-			     : /* no outputs */
-			     : "Jr" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static __inline__ void _raw_writeq(u64 q, unsigned long addr)
-{
-	__asm__ __volatile__("stxa\t%r0, [%1] %2\t/* pci_raw_writeq */"
-			     : /* no outputs */
-			     : "Jr" (q), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-#define __raw_readb(__addr)		(_raw_readb((unsigned long)(__addr)))
-#define __raw_readw(__addr)		(_raw_readw((unsigned long)(__addr)))
-#define __raw_readl(__addr)		(_raw_readl((unsigned long)(__addr)))
-#define __raw_readq(__addr)		(_raw_readq((unsigned long)(__addr)))
-#define __raw_writeb(__b, __addr)	(_raw_writeb((u8)(__b), (unsigned long)(__addr)))
-#define __raw_writew(__w, __addr)	(_raw_writew((u16)(__w), (unsigned long)(__addr)))
-#define __raw_writel(__l, __addr)	(_raw_writel((u32)(__l), (unsigned long)(__addr)))
-#define __raw_writeq(__q, __addr)	(_raw_writeq((u64)(__q), (unsigned long)(__addr)))
-
-/* Valid I/O Space regions are anywhere, because each PCI bus supported
- * can live in an arbitrary area of the physical address range.
- */
-#define IO_SPACE_LIMIT 0xffffffffffffffffUL
-
-/* Now, SBUS variants, only difference from PCI is that we do
- * not use little-endian ASIs.
- */
-static __inline__ u8 _sbus_readb(unsigned long addr)
-{
-	u8 ret;
-
-	__asm__ __volatile__("lduba\t[%1] %2, %0\t/* sbus_readb */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ u16 _sbus_readw(unsigned long addr)
-{
-	u16 ret;
-
-	__asm__ __volatile__("lduha\t[%1] %2, %0\t/* sbus_readw */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ u32 _sbus_readl(unsigned long addr)
-{
-	u32 ret;
-
-	__asm__ __volatile__("lduwa\t[%1] %2, %0\t/* sbus_readl */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ void _sbus_writeb(u8 b, unsigned long addr)
-{
-	__asm__ __volatile__("stba\t%r0, [%1] %2\t/* sbus_writeb */"
-			     : /* no outputs */
-			     : "Jr" (b), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static __inline__ void _sbus_writew(u16 w, unsigned long addr)
-{
-	__asm__ __volatile__("stha\t%r0, [%1] %2\t/* sbus_writew */"
-			     : /* no outputs */
-			     : "Jr" (w), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static __inline__ void _sbus_writel(u32 l, unsigned long addr)
-{
-	__asm__ __volatile__("stwa\t%r0, [%1] %2\t/* sbus_writel */"
-			     : /* no outputs */
-			     : "Jr" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-#define sbus_readb(__addr)		(_sbus_readb((unsigned long)(__addr)))
-#define sbus_readw(__addr)		(_sbus_readw((unsigned long)(__addr)))
-#define sbus_readl(__addr)		(_sbus_readl((unsigned long)(__addr)))
-#define sbus_writeb(__b, __addr)	(_sbus_writeb((__b), (unsigned long)(__addr)))
-#define sbus_writew(__w, __addr)	(_sbus_writew((__w), (unsigned long)(__addr)))
-#define sbus_writel(__l, __addr)	(_sbus_writel((__l), (unsigned long)(__addr)))
-
-static inline void *_sbus_memset_io(unsigned long dst, int c, __kernel_size_t n)
-{
-	while(n--) {
-		sbus_writeb(c, dst);
-		dst++;
-	}
-	return (void *) dst;
-}
-
-#define sbus_memset_io(d,c,sz)	\
-	_sbus_memset_io((unsigned long)d,(int)c,(__kernel_size_t)sz)
-
-static inline void *
-_memset_io(void *dst, int c, __kernel_size_t n)
-{
-	char *d = dst;
-
-	while (n--) {
-		writeb(c, d);
-		d++;
-	}
-
-	return dst;
-}
-
-#define memset_io(d,c,sz)	\
-	_memset_io((void *)d,(int)c,(__kernel_size_t)sz)
-
-static inline void *
-_memcpy_fromio(void *dst, unsigned long src, __kernel_size_t n)
-{
-	char *d = dst;
-
-	while (n--) {
-		char tmp = readb(src);
-		*d++ = tmp;
-		src++;
-	}
-
-	return dst;
-}
-
-#define memcpy_fromio(d,s,sz)	\
-	_memcpy_fromio((void *)d,(unsigned long)s,(__kernel_size_t)sz)
-
-static inline void *
-_memcpy_toio(unsigned long dst, const void *src, __kernel_size_t n)
-{
-	const char *s = src;
-	unsigned long d = dst;
-
-	while (n--) {
-		char tmp = *s++;
-		writeb(tmp, d);
-		d++;
-	}
-	return (void *)dst;
-}
-
-#define memcpy_toio(d,s,sz)	\
-	_memcpy_toio((unsigned long)d,(const void *)s,(__kernel_size_t)sz)
-
-static inline int check_signature(unsigned long io_addr,
-				  const unsigned char *signature,
-				  int length)
-{
-	int retval = 0;
-	do {
-		if (readb(io_addr++) != *signature++)
-			goto out;
-	} while (--length);
-	retval = 1;
-out:
-	return retval;
-}
-
-#ifdef __KERNEL__
-
-/* On sparc64 we have the whole physical IO address space accessible
- * using physically addressed loads and stores, so this does nothing.
- */
-#define ioremap(__offset, __size)	((void *)(__offset))
-#define ioremap_nocache(X,Y)		ioremap((X),(Y))
-#define iounmap(__addr)			do { (void)(__addr); } while(0)
-
-/* Similarly for SBUS. */
-#define sbus_ioremap(__res, __offset, __size, __name) \
-({	unsigned long __ret; \
-	__ret  = (__res)->start + (((__res)->flags & 0x1ffUL) << 32UL); \
-	__ret += (unsigned long) (__offset); \
-	if (! request_region((__ret), (__size), (__name))) \
-		__ret = 0UL; \
-	__ret; \
-})
-
-#define sbus_iounmap(__addr, __size)	\
-	release_region((__addr), (__size))
-
-/* Nothing to do */
-
-#define dma_cache_inv(_start,_size)		do { } while (0)
-#define dma_cache_wback(_start,_size)		do { } while (0)
-#define dma_cache_wback_inv(_start,_size)	do { } while (0)
-
-#endif
+#error Never include asm/io.h ! This is kernel only !
 
 #endif /* !(__SPARC64_IO_H) */
--- kernel-headers/asm-sparc64/ptrace.h.kheaders	1998-01-12 18:15:58.000000000 -0500
+++ kernel-headers/asm-sparc64/ptrace.h	2002-12-17 05:22:41.000000000 -0500
@@ -93,16 +93,6 @@
 #define TRACEREG32_SZ	sizeof(struct pt_regs32)
 #define STACKFRAME32_SZ	sizeof(struct sparc_stackf32)
 
-#ifdef __KERNEL__
-#define user_mode(regs) (!((regs)->tstate & TSTATE_PRIV))
-#define instruction_pointer(regs) ((regs)->tpc)
-extern void show_regs(struct pt_regs *);
-#define force_successful_syscall_return() \
-do { \
-	current->thread.flags |= SPARC_FLAG_SYS_SUCCESS; \
-} while (0)
-#endif
-
 #else /* __ASSEMBLY__ */
 /* For assembly code. */
 #define TRACEREG_SZ		0xa0
@@ -111,11 +101,6 @@
 #define TRACEREG32_SZ		0x50
 #define STACKFRAME32_SZ		0x60
 
-#include <asm/asm_offsets.h>
-#endif
-
-#ifdef __KERNEL__
-#define STACK_BIAS		2047
 #endif
 
 /* These are for pt_regs. */
--- kernel-headers/asm-sparc64/system.h.kheaders	2005-04-03 21:42:20.000000000 -0400
+++ kernel-headers/asm-sparc64/system.h	2005-09-05 12:09:46.000000000 -0400
@@ -2,10 +2,8 @@
 #ifndef __SPARC64_SYSTEM_H
 #define __SPARC64_SYSTEM_H
 
-#include <linux/config.h>
 #include <asm/ptrace.h>
 #include <asm/processor.h>
-#include <asm/asm_offsets.h>
 #include <asm/visasm.h>
 
 #ifndef __ASSEMBLY__
@@ -81,14 +79,6 @@
 #define local_irq_set(flags)		__save_and_sti(flags)
 #define local_irq_restore(flags)	__restore_flags(flags)
 
-#ifndef CONFIG_SMP
-#define cli() __cli()
-#define sti() __sti()
-#define save_flags(x) __save_flags(x)
-#define restore_flags(x) __restore_flags(x)
-#define save_and_cli(x) __save_and_cli(x)
-#else
-
 #ifndef __ASSEMBLY__
 extern void __global_cli(void);
 extern void __global_sti(void);
@@ -102,8 +92,6 @@
 #define restore_flags(flags)	__global_restore_flags(flags)
 #define save_and_cli(flags)	do { save_flags(flags); cli(); } while(0)
 
-#endif
-
 #define nop() 		__asm__ __volatile__ ("nop")
 
 #define membar(type)	__asm__ __volatile__ ("membar " type : : : "memory")
@@ -116,15 +104,9 @@
 #define set_wmb(__var, __value) \
 	do { __var = __value; membar("#StoreStore"); } while(0)
 
-#ifdef CONFIG_SMP
 #define smp_mb()	mb()
 #define smp_rmb()	rmb()
 #define smp_wmb()	wmb()
-#else
-#define smp_mb()	__asm__ __volatile__("":::"memory")
-#define smp_rmb()	__asm__ __volatile__("":::"memory")
-#define smp_wmb()	__asm__ __volatile__("":::"memory")
-#endif
 
 #define flushi(addr)	__asm__ __volatile__ ("flush %0" : : "r" (addr) : "memory")
 
--- kernel-headers/asm-sparc64/ttable.h.kheaders	2001-12-21 12:42:03.000000000 -0500
+++ kernel-headers/asm-sparc64/ttable.h	2002-12-17 05:22:41.000000000 -0500
@@ -2,8 +2,6 @@
 #ifndef _SPARC64_TTABLE_H
 #define _SPARC64_TTABLE_H
 
-#include <linux/config.h>
-#include <asm/asm_offsets.h>
 #include <asm/utrap.h>
 
 #define BOOT_KERNEL b sparc64_boot; nop; nop; nop; nop; nop; nop; nop;
@@ -114,20 +112,10 @@
 	ba,pt	%xcc, utrap_ill;					\
 	 mov	lvl, %o1;
 
-#ifdef CONFIG_SUNOS_EMUL
-#define SUNOS_SYSCALL_TRAP SYSCALL_TRAP(linux_sparc_syscall32, sunos_sys_table)
-#else
-#define SUNOS_SYSCALL_TRAP TRAP(sunos_syscall)
-#endif
 #define	LINUX_32BIT_SYSCALL_TRAP SYSCALL_TRAP(linux_sparc_syscall32, sys_call_table32)
 #define LINUX_64BIT_SYSCALL_TRAP SYSCALL_TRAP(linux_sparc_syscall, sys_call_table64)
 #define GETCC_TRAP TRAP(getcc)
 #define SETCC_TRAP TRAP(setcc)
-#ifdef CONFIG_SOLARIS_EMUL
-#define SOLARIS_SYSCALL_TRAP TRAP(solaris_sparc_syscall)
-#else
-#define SOLARIS_SYSCALL_TRAP TRAP(solaris_syscall)
-#endif
 /* FIXME: Write these actually */	
 #define NETBSD_SYSCALL_TRAP TRAP(netbsd_syscall)
 #define BREAKPOINT_TRAP TRAP(breakpoint_trap)
--- kernel-headers/asm-x86_64/mtrr.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-x86_64/mtrr.h	2002-12-17 05:22:41.000000000 -0500
@@ -23,8 +23,10 @@
 #ifndef _LINUX_MTRR_H
 #define _LINUX_MTRR_H
 
+#ifdef __KERNEL__
 #include <linux/config.h>
 #include <linux/ioctl.h>
+#endif
 
 #define	MTRR_IOCTL_BASE	'M'
 
--- kernel-headers/asm-x86_64/cache.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-x86_64/cache.h	2002-12-17 05:22:41.000000000 -0500
@@ -4,10 +4,14 @@
 #ifndef __ARCH_X8664_CACHE_H
 #define __ARCH_X8664_CACHE_H
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>
 
 /* L1 cache line size */
 #define L1_CACHE_SHIFT	(CONFIG_X86_L1_CACHE_SHIFT)
 #define L1_CACHE_BYTES	(1 << L1_CACHE_SHIFT)
 
+#endif /* __KERNEL__ */
+
 #endif
--- kernel-headers/asm-x86_64/posix_types.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/asm-x86_64/posix_types.h	2002-12-17 05:22:41.000000000 -0500
@@ -40,7 +40,7 @@ typedef __kernel_gid_t __kernel_old_gid_
 typedef __kernel_uid_t __kernel_uid32_t;
 typedef __kernel_gid_t __kernel_gid32_t;
 
-#ifdef __KERNEL__
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
 
 #undef __FD_SET
 static __inline__ void __FD_SET(unsigned long fd, __kernel_fd_set *fdsetp)
--- kernel-headers/linux/genhd.h.kheaders	2002-11-28 18:53:15.000000000 -0500
+++ kernel-headers/linux/genhd.h	2002-12-17 05:22:41.000000000 -0500
@@ -9,7 +9,6 @@
  *		<drew@colorado.edu>
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/major.h>
 
@@ -115,8 +114,6 @@ extern int walk_gendisk(int (*walk)(stru
 
 #endif  /*  __KERNEL__  */
 
-#ifdef CONFIG_SOLARIS_X86_PARTITION
-
 #define SOLARIS_X86_NUMSLICE	8
 #define SOLARIS_X86_VTOC_SANE	(0x600DDEEEUL)
 
@@ -141,9 +138,6 @@ struct solaris_x86_vtoc {
 	char	v_asciilabel[128];	/* for compatibility */
 };
 
-#endif /* CONFIG_SOLARIS_X86_PARTITION */
-
-#ifdef CONFIG_BSD_DISKLABEL
 /*
  * BSD disklabel support by Yossi Gottlieb <yogo@math.tau.ac.il>
  * updated by Marc Espie <Marc.Espie@openbsd.org>
@@ -198,9 +192,6 @@ struct bsd_disklabel {
 	} d_partitions[BSD_MAXPARTITIONS];	/* actually may be more */
 };
 
-#endif	/* CONFIG_BSD_DISKLABEL */
-
-#ifdef CONFIG_UNIXWARE_DISKLABEL
 /*
  * Unixware slices support by Andrzej Krzysztofowicz <ankry@mif.pg.gda.pl>
  * and Krzysztof G. Baranowski <kgb@knm.org.pl>
@@ -252,7 +243,6 @@ struct unixware_disklabel {
 
 };  /* 408 */
 
-#endif /* CONFIG_UNIXWARE_DISKLABEL */
 
 #ifdef CONFIG_MINIX_SUBPARTITION
 #   define MINIX_NR_SUBPARTITIONS  4
--- kernel-headers/linux/timer.h.kheaders	2001-11-22 14:46:19.000000000 -0500
+++ kernel-headers/linux/timer.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,7 +1,6 @@
 #ifndef _LINUX_TIMER_H
 #define _LINUX_TIMER_H
 
-#include <linux/config.h>
 #include <linux/list.h>
 
 /*
@@ -23,13 +22,8 @@ struct timer_list {
 extern void add_timer(struct timer_list * timer);
 extern int del_timer(struct timer_list * timer);
 
-#ifdef CONFIG_SMP
-extern int del_timer_sync(struct timer_list * timer);
-extern void sync_timers(void);
-#else
 #define del_timer_sync(t)	del_timer(t)
 #define sync_timers()		do { } while (0)
-#endif
 
 /*
  * mod_timer is a more efficient way to update the expire field of an
--- kernel-headers/linux/net.h.kheaders	2001-11-22 14:46:19.000000000 -0500
+++ kernel-headers/linux/net.h	2002-12-17 05:22:41.000000000 -0500
@@ -18,7 +18,6 @@
 #ifndef _LINUX_NET_H
 #define _LINUX_NET_H
 
-#include <linux/config.h>
 #include <linux/socket.h>
 #include <linux/wait.h>
 
@@ -144,11 +143,6 @@ extern int	net_ratelimit(void);
 extern unsigned long net_random(void);
 extern void net_srandom(unsigned long);
 
-#ifndef CONFIG_SMP
-#define SOCKOPS_WRAPPED(name) name
-#define SOCKOPS_WRAP(name, fam)
-#else
-
 #define SOCKOPS_WRAPPED(name) __unlocked_##name
 
 #define SOCKCALL_WRAP(name, call, parms, args)		\
@@ -221,8 +215,6 @@ static struct proto_ops name##_ops = {		
 	recvmsg:	__lock_##name##_recvmsg,	\
 	mmap:		__lock_##name##_mmap,		\
 };
-#endif
-
 
 #endif /* __KERNEL__ */
 #endif	/* _LINUX_NET_H */
--- kernel-headers/linux/sched.h.kheaders	2002-12-17 05:10:15.000000000 -0500
+++ kernel-headers/linux/sched.h	2002-12-17 05:22:41.000000000 -0500
@@ -5,7 +5,6 @@
 
 extern unsigned long event;
 
-#include <linux/config.h>
 #include <linux/binfmts.h>
 #include <linux/threads.h>
 #include <linux/kernel.h>
--- kernel-headers/linux/config.h.kheaders	1998-01-05 04:41:01.000000000 -0500
+++ kernel-headers/linux/config.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,6 +0,0 @@
-#ifndef _LINUX_CONFIG_H
-#define _LINUX_CONFIG_H
-
-#include <linux/autoconf.h>
-
-#endif
--- kernel-headers/linux/smp.h.kheaders	2001-11-22 14:46:19.000000000 -0500
+++ kernel-headers/linux/smp.h	2005-09-05 11:45:48.000000000 -0400
@@ -6,10 +6,6 @@
  *		Alan Cox. <alan@redhat.com>
  */
 
-#include <linux/config.h>
-
-#ifdef CONFIG_SMP
-
 #include <linux/kernel.h>
 #include <asm/smp.h>
 
@@ -71,21 +67,4 @@
 #define MSG_RESCHEDULE		0x0003	/* Reschedule request from master CPU*/
 #define MSG_CALL_FUNCTION       0x0004  /* Call function on all other CPUs */
 
-#else
-
-/*
- *	These macros fold the SMP functionality into a single CPU system
- */
- 
-#define smp_num_cpus				1
-#define smp_processor_id()			0
-#define hard_smp_processor_id()			0
-#define smp_threads_ready			1
-#define kernel_lock()
-#define cpu_logical_map(cpu)			0
-#define cpu_number_map(cpu)			0
-#define smp_call_function(func,info,retry,wait)	({ 0; })
-#define cpu_online_map				1
-
-#endif
 #endif
--- kernel-headers/linux/types.h.kheaders	2002-08-02 20:39:46.000000000 -0400
+++ kernel-headers/linux/types.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,17 +1,6 @@
 #ifndef _LINUX_TYPES_H
 #define _LINUX_TYPES_H
 
-#ifdef	__KERNEL__
-#include <linux/config.h>
-
-#define BITS_TO_LONGS(bits) \
-	(((bits)+BITS_PER_LONG-1)/BITS_PER_LONG)
-#define DECLARE_BITMAP(name,bits) \
-	unsigned long name[BITS_TO_LONGS(bits)]
-#define CLEAR_BITMAP(name,bits) \
-	memset(name, 0, BITS_TO_LONGS(bits)*sizeof(unsigned long))
-#endif
-
 #include <linux/posix_types.h>
 #include <asm/types.h>
 
@@ -28,25 +17,8 @@ typedef __kernel_daddr_t	daddr_t;
 typedef __kernel_key_t		key_t;
 typedef __kernel_suseconds_t	suseconds_t;
 
-#ifdef __KERNEL__
-typedef __kernel_uid32_t	uid_t;
-typedef __kernel_gid32_t	gid_t;
-typedef __kernel_uid16_t        uid16_t;
-typedef __kernel_gid16_t        gid16_t;
-
-#ifdef CONFIG_UID16
-/* This is defined by include/asm-{arch}/posix_types.h */
-typedef __kernel_old_uid_t	old_uid_t;
-typedef __kernel_old_gid_t	old_gid_t;
-#endif /* CONFIG_UID16 */
-
-/* libc5 includes this file to define uid_t, thus uid_t can never change
- * when it is included by non-kernel code
- */
-#else
 typedef __kernel_uid_t		uid_t;
 typedef __kernel_gid_t		gid_t;
-#endif /* __KERNEL__ */
 
 #if defined(__GNUC__)
 typedef __kernel_loff_t		loff_t;
--- kernel-headers/linux/fs.h.kheaders	2002-12-17 05:10:15.000000000 -0500
+++ kernel-headers/linux/fs.h	2002-12-17 05:22:41.000000000 -0500
@@ -6,7 +6,6 @@
  * structures etc.
  */
 
-#include <linux/config.h>
 #include <linux/linkage.h>
 #include <linux/limits.h>
 #include <linux/wait.h>
@@ -1573,9 +1572,7 @@ extern char root_device_name[];
 
 extern void show_buffers(void);
 
-#ifdef CONFIG_BLK_DEV_INITRD
 extern unsigned int real_root_dev;
-#endif
 
 extern ssize_t char_read(struct file *, char *, size_t, loff_t *);
 extern ssize_t block_read(struct file *, char *, size_t, loff_t *);
--- kernel-headers/linux/linkage.h.kheaders	2000-12-11 15:49:54.000000000 -0500
+++ kernel-headers/linux/linkage.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,8 +1,6 @@
 #ifndef _LINUX_LINKAGE_H
 #define _LINUX_LINKAGE_H
 
-#include <linux/config.h>
-
 #ifdef __cplusplus
 #define CPP_ASMLINKAGE extern "C"
 #else
--- kernel-headers/linux/module.h.kheaders	2004-08-07 19:26:06.000000000 -0400
+++ kernel-headers/linux/module.h	2005-09-05 11:42:22.000000000 -0400
@@ -7,7 +7,6 @@
 #ifndef _LINUX_MODULE_H
 #define _LINUX_MODULE_H
 
-#include <linux/config.h>
 #include <linux/compiler.h>
 #include <linux/spinlock.h>
 #include <linux/list.h>
--- kernel-headers/linux/nfs_fs.h.kheaders	2004-04-14 09:05:40.000000000 -0400
+++ kernel-headers/linux/nfs_fs.h	2005-09-05 11:38:56.000000000 -0400
@@ -9,7 +9,6 @@
 #ifndef _LINUX_NFS_FS_H
 #define _LINUX_NFS_FS_H
 
-#include <linux/config.h>
 #include <linux/in.h>
 #include <linux/mm.h>
 #include <linux/pagemap.h>
@@ -214,12 +213,10 @@
 extern int  nfs_flush_list(struct list_head *, int, int);
 extern int  nfs_scan_lru_dirty(struct nfs_server *, struct list_head *);
 extern int  nfs_scan_lru_dirty_timeout(struct nfs_server *, struct list_head *);
-#ifdef CONFIG_NFS_V3
 extern int  nfs_commit_file(struct inode *, int);
 extern int  nfs_commit_list(struct list_head *, int);
 extern int  nfs_scan_lru_commit(struct nfs_server *, struct list_head *);
 extern int  nfs_scan_lru_commit_timeout(struct nfs_server *, struct list_head *);
-#endif
 
 static inline int
 nfs_have_read(struct inode *inode)
--- kernel-headers/linux/threads.h.kheaders	2002-02-25 14:38:13.000000000 -0500
+++ kernel-headers/linux/threads.h	2002-12-17 05:22:41.000000000 -0500
@@ -1,18 +1,12 @@
 #ifndef _LINUX_THREADS_H
 #define _LINUX_THREADS_H
 
-#include <linux/config.h>
-
 /*
  * The default limit for the nr of threads is now in
  * /proc/sys/kernel/threads-max.
  */
  
-#ifdef CONFIG_SMP
-#define NR_CPUS	CONFIG_NR_CPUS
-#else
-#define NR_CPUS	1
-#endif
+#define NR_CPUS	sizeof(long)
 
 #define MIN_THREADS_LEFT_FOR_ROOT 4
 
