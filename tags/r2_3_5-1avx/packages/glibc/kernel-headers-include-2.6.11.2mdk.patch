--- kernel-headers/asm-alpha/bitops.h.kheaders	2005-03-02 02:38:09.000000000 -0500
+++ kernel-headers/asm-alpha/bitops.h	2005-03-10 10:59:52.555991723 -0500
@@ -1,7 +1,6 @@
 #ifndef _ALPHA_BITOPS_H
 #define _ALPHA_BITOPS_H
 
-#include <linux/config.h>
 #include <asm/compiler.h>
 
 /*
@@ -125,9 +124,7 @@ test_and_set_bit(unsigned long nr, volat
 	"	stl_c %0,%1\n"
 	"	beq %0,3f\n"
 	"2:\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"3:	br 1b\n"
 	".previous"
@@ -166,9 +163,7 @@ test_and_clear_bit(unsigned long nr, vol
 	"	stl_c %0,%1\n"
 	"	beq %0,3f\n"
 	"2:\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"3:	br 1b\n"
 	".previous"
@@ -205,9 +200,7 @@ test_and_change_bit(unsigned long nr, vo
 	"	xor %0,%3,%0\n"
 	"	stl_c %0,%1\n"
 	"	beq %0,3f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"3:	br 1b\n"
 	".previous"
--- kernel-headers/asm-alpha/cache.h.kheaders	2005-03-02 02:38:07.000000000 -0500
+++ kernel-headers/asm-alpha/cache.h	2005-03-10 10:59:52.556991924 -0500
@@ -4,6 +4,8 @@
 #ifndef __ARCH_ALPHA_CACHE_H
 #define __ARCH_ALPHA_CACHE_H
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>
 
 /* Bytes per L1 (data) cache line. */
@@ -23,3 +25,5 @@
 #define L1_CACHE_SHIFT_MAX L1_CACHE_SHIFT
 
 #endif
+
+#endif
--- kernel-headers/asm-alpha/param.h.kheaders	2005-03-02 02:38:08.000000000 -0500
+++ kernel-headers/asm-alpha/param.h	2005-03-10 10:59:52.556991924 -0500
@@ -5,14 +5,8 @@
    hardware ignores reprogramming.  We also need userland buy-in to the 
    change in HZ, since this is visible in the wait4 resources etc.  */
 
-#include <linux/config.h>
-
 #ifndef HZ
-# ifndef CONFIG_ALPHA_RAWHIDE
-#  define HZ	1024
-# else
-#  define HZ	1200
-# endif
+# define HZ 1024
 #endif
 
 #define USER_HZ		HZ
@@ -25,8 +19,4 @@
 
 #define MAXHOSTNAMELEN	64	/* max length of hostname */
 
-#ifdef __KERNEL__
-# define CLOCKS_PER_SEC	HZ	/* frequency at which times() counts */
-#endif
-
 #endif /* _ASM_ALPHA_PARAM_H */
--- kernel-headers/asm-alpha/system.h.kheaders	2005-03-02 02:38:10.000000000 -0500
+++ kernel-headers/asm-alpha/system.h	2005-03-10 10:59:52.557992126 -0500
@@ -1,7 +1,6 @@
 #ifndef __ALPHA_SYSTEM_H
 #define __ALPHA_SYSTEM_H
 
-#include <linux/config.h>
 #include <asm/pal.h>
 #include <asm/page.h>
 
@@ -20,11 +19,7 @@
 /* Remove when official MILO sources have ELF support: */
 #define BOOT_SIZE	(16*1024)
 
-#ifdef CONFIG_ALPHA_LEGACY_START_ADDRESS
 #define KERNEL_START_PHYS	0x300000 /* Old bootloaders hardcoded this.  */
-#else
-#define KERNEL_START_PHYS	0x1000000 /* required: Wildfire/Titan/Marvel */
-#endif
 
 #define KERNEL_START	(PAGE_OFFSET+KERNEL_START_PHYS)
 #define SWAPPER_PGD	KERNEL_START
@@ -151,17 +146,10 @@ __asm__ __volatile__("wmb": : :"memory")
 #define read_barrier_depends() \
 __asm__ __volatile__("mb": : :"memory")
 
-#ifdef CONFIG_SMP
 #define smp_mb()	mb()
 #define smp_rmb()	rmb()
 #define smp_wmb()	wmb()
 #define smp_read_barrier_depends()	read_barrier_depends()
-#else
-#define smp_mb()	barrier()
-#define smp_rmb()	barrier()
-#define smp_wmb()	barrier()
-#define smp_read_barrier_depends()	barrier()
-#endif
 
 #define set_mb(var, value) \
 do { var = value; mb(); } while (0)
@@ -357,9 +345,7 @@ __xchg_u8(volatile char *m, unsigned lon
 	"	or	%1,%2,%2\n"
 	"	stq_c	%2,0(%3)\n"
 	"	beq	%2,2f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"2:	br	1b\n"
 	".previous"
@@ -383,9 +369,7 @@ __xchg_u16(volatile short *m, unsigned l
 	"	or	%1,%2,%2\n"
 	"	stq_c	%2,0(%3)\n"
 	"	beq	%2,2f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"2:	br	1b\n"
 	".previous"
@@ -405,9 +389,7 @@ __xchg_u32(volatile int *m, unsigned lon
 	"	bis $31,%3,%1\n"
 	"	stl_c %1,%2\n"
 	"	beq %1,2f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"2:	br 1b\n"
 	".previous"
@@ -427,9 +409,7 @@ __xchg_u64(volatile long *m, unsigned lo
 	"	bis $31,%3,%1\n"
 	"	stq_c %1,%2\n"
 	"	beq %1,2f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	".subsection 2\n"
 	"2:	br 1b\n"
 	".previous"
@@ -498,9 +478,7 @@ __cmpxchg_u8(volatile char *m, long old,
 	"	or	%1,%2,%2\n"
 	"	stq_c	%2,0(%4)\n"
 	"	beq	%2,3f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	"2:\n"
 	".subsection 2\n"
 	"3:	br	1b\n"
@@ -527,9 +505,7 @@ __cmpxchg_u16(volatile short *m, long ol
 	"	or	%1,%2,%2\n"
 	"	stq_c	%2,0(%4)\n"
 	"	beq	%2,3f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	"2:\n"
 	".subsection 2\n"
 	"3:	br	1b\n"
@@ -552,9 +528,7 @@ __cmpxchg_u32(volatile int *m, int old, 
 	"	mov %4,%1\n"
 	"	stl_c %1,%2\n"
 	"	beq %1,3f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	"2:\n"
 	".subsection 2\n"
 	"3:	br 1b\n"
@@ -577,9 +551,7 @@ __cmpxchg_u64(volatile long *m, unsigned
 	"	mov %4,%1\n"
 	"	stq_c %1,%2\n"
 	"	beq %1,3f\n"
-#ifdef CONFIG_SMP
 	"	mb\n"
-#endif
 	"2:\n"
 	".subsection 2\n"
 	"3:	br 1b\n"
--- kernel-headers/asm-arm/system.h.kheaders	2005-03-02 02:37:48.000000000 -0500
+++ kernel-headers/asm-arm/system.h	2005-03-10 10:59:52.557992126 -0500
@@ -3,8 +3,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/config.h>
-
 #define CPU_ARCH_UNKNOWN	0
 #define CPU_ARCH_ARMv3		1
 #define CPU_ARCH_ARMv4		2
--- kernel-headers/asm-i386/mtrr.h.kheaders	2005-03-02 02:38:08.000000000 -0500
+++ kernel-headers/asm-i386/mtrr.h	2005-03-10 10:59:52.558992328 -0500
@@ -23,7 +23,6 @@
 #ifndef _LINUX_MTRR_H
 #define _LINUX_MTRR_H
 
-#include <linux/config.h>
 #include <linux/ioctl.h>
 
 #define	MTRR_IOCTL_BASE	'M'
--- kernel-headers/asm-i386/byteorder.h.kheaders	2005-03-02 02:38:12.000000000 -0500
+++ kernel-headers/asm-i386/byteorder.h	2005-03-10 10:59:52.558992328 -0500
@@ -6,22 +6,9 @@
 
 #ifdef __GNUC__
 
-/* For avoiding bswap on i386 */
-#ifdef __KERNEL__
-#include <linux/config.h>
-#endif
-
 static __inline__ __attribute_const__ __u32 ___arch__swab32(__u32 x)
 {
-#ifdef CONFIG_X86_BSWAP
 	__asm__("bswap %0" : "=r" (x) : "0" (x));
-#else
-	__asm__("xchgb %b0,%h0\n\t"	/* swap lower bytes	*/
-		"rorl $16,%0\n\t"	/* swap words		*/
-		"xchgb %b0,%h0"		/* swap higher bytes	*/
-		:"=q" (x)
-		: "0" (x));
-#endif
 	return x;
 }
 
@@ -33,13 +20,13 @@ static __inline__ __attribute_const__ __
 	} v;
 	v.u = val;
 #ifdef CONFIG_X86_BSWAP
-	asm("bswapl %0 ; bswapl %1 ; xchgl %0,%1" 
+	__asm__("bswapl %0 ; bswapl %1 ; xchgl %0,%1" 
 	    : "=r" (v.s.a), "=r" (v.s.b) 
 	    : "0" (v.s.a), "1" (v.s.b)); 
 #else
    v.s.a = ___arch__swab32(v.s.a); 
 	v.s.b = ___arch__swab32(v.s.b); 
-	asm("xchgl %0,%1" : "=r" (v.s.a), "=r" (v.s.b) : "0" (v.s.a), "1" (v.s.b));
+	__asm__("xchgl %0,%1" : "=r" (v.s.a), "=r" (v.s.b) : "0" (v.s.a), "1" (v.s.b));
 #endif
 	return v.u;	
 } 
--- kernel-headers/asm-i386/cache.h.kheaders	2005-03-02 02:37:47.000000000 -0500
+++ kernel-headers/asm-i386/cache.h	2005-03-10 10:59:52.558992328 -0500
@@ -4,6 +4,8 @@
 #ifndef __ARCH_I386_CACHE_H
 #define __ARCH_I386_CACHE_H
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>
 
 /* L1 cache line size */
@@ -13,3 +15,5 @@
 #define L1_CACHE_SHIFT_MAX 7	/* largest L1 which this arch supports */
 
 #endif
+
+#endif
--- kernel-headers/asm-i386/processor.h.kheaders	2005-03-02 02:37:47.000000000 -0500
+++ kernel-headers/asm-i386/processor.h	2005-03-10 11:00:36.221800055 -0500
@@ -7,6 +7,8 @@
 #ifndef __ASM_I386_PROCESSOR_H
 #define __ASM_I386_PROCESSOR_H
 
+#ifdef __KERNEL__
+
 #include <asm/vm86.h>
 #include <asm/math_emu.h>
 #include <asm/segment.h>
@@ -17,7 +19,6 @@
 #include <asm/msr.h>
 #include <asm/system.h>
 #include <linux/cache.h>
-#include <linux/config.h>
 #include <linux/threads.h>
 #include <asm/percpu.h>
 
@@ -66,7 +67,7 @@ struct cpuinfo_x86 {
 	int	coma_bug;
 	unsigned long loops_per_jiffy;
 	unsigned char x86_num_cores;
-} __attribute__((__aligned__(SMP_CACHE_BYTES)));
+};
 
 #define X86_VENDOR_INTEL 0
 #define X86_VENDOR_CYRIX 1
@@ -89,13 +90,8 @@ extern struct cpuinfo_x86 new_cpu_data;
 extern struct tss_struct doublefault_tss;
 DECLARE_PER_CPU(struct tss_struct, init_tss);
 
-#ifdef CONFIG_SMP
 extern struct cpuinfo_x86 cpu_data[];
 #define current_cpu_data cpu_data[smp_processor_id()]
-#else
-#define cpu_data (&boot_cpu_data)
-#define current_cpu_data boot_cpu_data
-#endif
 
 extern	int phys_proc_id[NR_CPUS];
 extern char ignore_fpu_irq;
@@ -668,4 +664,6 @@ extern void select_idle_routine(const st
 
 extern unsigned long boot_option_idle_override;
 
+#endif /* __KERNEL__ */
+
 #endif /* __ASM_I386_PROCESSOR_H */
--- kernel-headers/asm-i386/ipc.h.kheaders	2005-03-02 02:38:25.000000000 -0500
+++ kernel-headers/asm-i386/ipc.h	2005-03-10 10:59:52.559992530 -0500
@@ -1,6 +1,8 @@
 #ifndef __i386_IPC_H__
 #define __i386_IPC_H__
 
+#include <linux/compiler.h>
+
 /* 
  * These are used to wrap system calls on x86.
  *
--- kernel-headers/asm-i386/atomic.h.kheaders	2005-03-02 02:37:51.000000000 -0500
+++ kernel-headers/asm-i386/atomic.h	2005-03-10 10:59:52.560992731 -0500
@@ -1,7 +1,6 @@
 #ifndef __ARCH_I386_ATOMIC__
 #define __ARCH_I386_ATOMIC__
 
-#include <linux/config.h>
 #include <linux/compiler.h>
 #include <asm/processor.h>
 
@@ -10,11 +9,7 @@
  * resource counting etc..
  */
 
-#ifdef CONFIG_SMP
 #define LOCK "lock ; "
-#else
-#define LOCK ""
-#endif
 
 /*
  * Make sure gcc doesn't try to be clever and move things around
--- kernel-headers/asm-i386/system.h.kheaders	2005-03-02 02:37:30.000000000 -0500
+++ kernel-headers/asm-i386/system.h	2005-03-10 10:59:52.560992731 -0500
@@ -1,7 +1,6 @@
 #ifndef __ASM_SYSTEM_H
 #define __ASM_SYSTEM_H
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <asm/segment.h>
 #include <asm/cpufeature.h>
--- kernel-headers/asm-i386/timex.h.kheaders	2005-03-10 10:15:45.000000000 -0500
+++ kernel-headers/asm-i386/timex.h	2005-03-10 10:59:52.560992731 -0500
@@ -6,7 +6,6 @@
 #ifndef _ASMi386_TIMEX_H
 #define _ASMi386_TIMEX_H
 
-#include <linux/config.h>
 #include <asm/processor.h>
 
 #ifdef CONFIG_X86_ELAN
@@ -36,6 +35,7 @@ typedef unsigned long long cycles_t;
 
 extern cycles_t cacheflush_time;
 
+#ifdef __KERNEL__
 static inline cycles_t get_cycles (void)
 {
 	unsigned long long ret=0;
@@ -50,6 +50,7 @@ static inline cycles_t get_cycles (void)
 #endif
 	return ret;
 }
+#endif
 
 extern unsigned long cpu_khz;
 
--- kernel-headers/asm-i386/uaccess.h.kheaders	2005-03-02 02:37:49.000000000 -0500
+++ kernel-headers/asm-i386/uaccess.h	2005-03-10 10:59:52.561992933 -0500
@@ -4,7 +4,6 @@
 /*
  * User space memory access functions
  */
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/thread_info.h>
 #include <linux/prefetch.h>
--- kernel-headers/asm-i386/module.h.kheaders	2005-03-02 02:37:48.000000000 -0500
+++ kernel-headers/asm-i386/module.h	2005-03-10 10:59:52.561992933 -0500
@@ -10,6 +10,8 @@ struct mod_arch_specific
 #define Elf_Sym Elf32_Sym
 #define Elf_Ehdr Elf32_Ehdr
 
+#ifdef __KERNEL__
+
 #ifdef CONFIG_M386
 #define MODULE_PROC_FAMILY "386 "
 #elif defined CONFIG_M486
@@ -70,4 +72,6 @@ struct mod_arch_specific
 
 #define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_REGPARM MODULE_STACKSIZE
 
+#endif /* __KERNEL__ */
+
 #endif /* _ASM_I386_MODULE_H */
--- kernel-headers/asm-ia64/atomic.h.kheaders	2005-03-02 02:37:49.000000000 -0500
+++ kernel-headers/asm-ia64/atomic.h	2005-03-10 10:59:52.562993135 -0500
@@ -23,6 +23,8 @@
 typedef struct { volatile __s32 counter; } atomic_t;
 typedef struct { volatile __s64 counter; } atomic64_t;
 
+#ifdef __KERNEL__
+
 #define ATOMIC_INIT(i)		((atomic_t) { (i) })
 #define ATOMIC64_INIT(i)	((atomic64_t) { (i) })
 
@@ -174,6 +176,8 @@ atomic64_add_negative (__s64 i, atomic64
 #define atomic64_inc(v)			atomic64_add(1, (v))
 #define atomic64_dec(v)			atomic64_sub(1, (v))
 
+#endif /* __KERNEL__ */
+
 /* Atomic operations are already serializing */
 #define smp_mb__before_atomic_dec()	barrier()
 #define smp_mb__after_atomic_dec()	barrier()
--- kernel-headers/asm-ia64/cache.h.kheaders	2005-03-02 02:38:09.000000000 -0500
+++ kernel-headers/asm-ia64/cache.h	2005-03-10 10:59:52.562993135 -0500
@@ -1,6 +1,8 @@
 #ifndef _ASM_IA64_CACHE_H
 #define _ASM_IA64_CACHE_H
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>
 
 /*
@@ -27,4 +29,6 @@
 # define SMP_CACHE_BYTES	(1 << 3)
 #endif
 
+#endif
+
 #endif /* _ASM_IA64_CACHE_H */
--- kernel-headers/asm-ia64/page.h.kheaders	2005-03-10 10:15:44.000000000 -0500
+++ kernel-headers/asm-ia64/page.h	2005-03-10 10:59:52.562993135 -0500
@@ -7,27 +7,10 @@
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
-#include <linux/config.h>
-
 #include <asm/intrinsics.h>
 #include <asm/types.h>
 
-/*
- * PAGE_SHIFT determines the actual kernel page size.
- */
-#if defined(CONFIG_IA64_PAGE_SIZE_4KB)
-# define PAGE_SHIFT	12
-#elif defined(CONFIG_IA64_PAGE_SIZE_8KB)
-# define PAGE_SHIFT	13
-#elif defined(CONFIG_IA64_PAGE_SIZE_16KB)
-# define PAGE_SHIFT	14
-#elif defined(CONFIG_IA64_PAGE_SIZE_64KB)
-# define PAGE_SHIFT	16
-#else
-# error Unsupported page size!
-#endif
-
-#define PAGE_SIZE		(__IA64_UL_CONST(1) << PAGE_SHIFT)
+#define PAGE_SIZE		getpagesize()
 #define PAGE_MASK		(~(PAGE_SIZE - 1))
 #define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
 
--- kernel-headers/asm-ia64/ptrace.h.kheaders	2005-03-02 02:38:38.000000000 -0500
+++ kernel-headers/asm-ia64/ptrace.h	2005-03-10 10:59:52.563993337 -0500
@@ -54,30 +54,9 @@
  * This is because ar.ec is saved as part of ar.pfs.
  */
 
-#include <linux/config.h>
-
 #include <asm/fpu.h>
 #include <asm/offsets.h>
 
-/*
- * Base-2 logarithm of number of pages to allocate per task structure
- * (including register backing store and memory stack):
- */
-#if defined(CONFIG_IA64_PAGE_SIZE_4KB)
-# define KERNEL_STACK_SIZE_ORDER		3
-#elif defined(CONFIG_IA64_PAGE_SIZE_8KB)
-# define KERNEL_STACK_SIZE_ORDER		2
-#elif defined(CONFIG_IA64_PAGE_SIZE_16KB)
-# define KERNEL_STACK_SIZE_ORDER		1
-#else
-# define KERNEL_STACK_SIZE_ORDER		0
-#endif
-
-#define IA64_RBS_OFFSET			((IA64_TASK_SIZE + IA64_THREAD_INFO_SIZE + 15) & ~15)
-#define IA64_STK_OFFSET			((1 << KERNEL_STACK_SIZE_ORDER)*PAGE_SIZE)
-
-#define KERNEL_STACK_SIZE		IA64_STK_OFFSET
-
 #ifndef __ASSEMBLY__
 
 #include <asm/current.h>
--- kernel-headers/asm-ia64/string.h.kheaders	2005-03-02 02:38:25.000000000 -0500
+++ kernel-headers/asm-ia64/string.h	2005-03-10 10:59:52.563993337 -0500
@@ -9,6 +9,8 @@
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>	/* remove this once we remove the A-step workaround... */
 
 #define __HAVE_ARCH_STRLEN	1 /* see arch/ia64/lib/strlen.S */
@@ -19,4 +21,6 @@ extern __kernel_size_t strlen (const cha
 extern void *memcpy (void *, const void *, __kernel_size_t);
 extern void *memset (void *, int, __kernel_size_t);
 
+#endif
+
 #endif /* _ASM_IA64_STRING_H */
--- kernel-headers/asm-ia64/system.h.kheaders	2005-03-02 02:38:07.000000000 -0500
+++ kernel-headers/asm-ia64/system.h	2005-03-10 10:59:52.563993337 -0500
@@ -12,7 +12,6 @@
  * Copyright (C) 1999 Asit Mallick <asit.k.mallick@intel.com>
  * Copyright (C) 1999 Don Dugger <don.dugger@intel.com>
  */
-#include <linux/config.h>
 
 #include <asm/kregs.h>
 #include <asm/page.h>
--- kernel-headers/asm-ia64/bitops.h.kheaders	2005-03-02 02:38:38.000000000 -0500
+++ kernel-headers/asm-ia64/bitops.h	2005-03-10 10:59:52.564993539 -0500
@@ -14,6 +14,11 @@
 #include <asm/bitops.h>
 #include <asm/intrinsics.h>
 
+#ifndef CMPXCHG_BUGCHECK_DECL
+# define CMPXCHG_BUGCHECK_DECL
+# define CMPXCHG_BUGCHECK(v)
+#endif
+
 /**
  * set_bit - Atomically set a bit in memory
  * @nr: the bit to set
@@ -34,11 +39,11 @@
 static __inline__ void
 set_bit (int nr, volatile void *addr)
 {
-	__u32 bit, old, new;
-	volatile __u32 *m;
+	u_int32_t bit, old, new;
+	volatile u_int32_t *m;
 	CMPXCHG_BUGCHECK_DECL
 
-	m = (volatile __u32 *) addr + (nr >> 5);
+	m = (volatile u_int32_t *) addr + (nr >> 5);
 	bit = 1 << (nr & 31);
 	do {
 		CMPXCHG_BUGCHECK(m);
@@ -59,7 +64,7 @@ set_bit (int nr, volatile void *addr)
 static __inline__ void
 __set_bit (int nr, volatile void *addr)
 {
-	*((__u32 *) addr + (nr >> 5)) |= (1 << (nr & 31));
+	*((u_int32_t *) addr + (nr >> 5)) |= (1 << (nr & 31));
 }
 
 /*
@@ -81,11 +86,11 @@ __set_bit (int nr, volatile void *addr)
 static __inline__ void
 clear_bit (int nr, volatile void *addr)
 {
-	__u32 mask, old, new;
-	volatile __u32 *m;
+	u_int32_t mask, old, new;
+	volatile u_int32_t *m;
 	CMPXCHG_BUGCHECK_DECL
 
-	m = (volatile __u32 *) addr + (nr >> 5);
+	m = (volatile u_int32_t *) addr + (nr >> 5);
 	mask = ~(1 << (nr & 31));
 	do {
 		CMPXCHG_BUGCHECK(m);
@@ -100,8 +105,8 @@ clear_bit (int nr, volatile void *addr)
 static __inline__ void
 __clear_bit (int nr, volatile void *addr)
 {
-	volatile __u32 *p = (__u32 *) addr + (nr >> 5);
-	__u32 m = 1 << (nr & 31);
+	volatile u_int32_t *p = (u_int32_t *) addr + (nr >> 5);
+	u_int32_t m = 1 << (nr & 31);
 	*p &= ~m;
 }
 
@@ -117,11 +122,11 @@ __clear_bit (int nr, volatile void *addr
 static __inline__ void
 change_bit (int nr, volatile void *addr)
 {
-	__u32 bit, old, new;
-	volatile __u32 *m;
+	u_int32_t bit, old, new;
+	volatile u_int32_t *m;
 	CMPXCHG_BUGCHECK_DECL
 
-	m = (volatile __u32 *) addr + (nr >> 5);
+	m = (volatile u_int32_t *) addr + (nr >> 5);
 	bit = (1 << (nr & 31));
 	do {
 		CMPXCHG_BUGCHECK(m);
@@ -142,7 +147,7 @@ change_bit (int nr, volatile void *addr)
 static __inline__ void
 __change_bit (int nr, volatile void *addr)
 {
-	*((__u32 *) addr + (nr >> 5)) ^= (1 << (nr & 31));
+	*((u_int32_t *) addr + (nr >> 5)) ^= (1 << (nr & 31));
 }
 
 /**
@@ -156,11 +161,11 @@ __change_bit (int nr, volatile void *add
 static __inline__ int
 test_and_set_bit (int nr, volatile void *addr)
 {
-	__u32 bit, old, new;
-	volatile __u32 *m;
+	u_int32_t bit, old, new;
+	volatile u_int32_t *m;
 	CMPXCHG_BUGCHECK_DECL
 
-	m = (volatile __u32 *) addr + (nr >> 5);
+	m = (volatile u_int32_t *) addr + (nr >> 5);
 	bit = 1 << (nr & 31);
 	do {
 		CMPXCHG_BUGCHECK(m);
@@ -182,8 +187,8 @@ test_and_set_bit (int nr, volatile void 
 static __inline__ int
 __test_and_set_bit (int nr, volatile void *addr)
 {
-	__u32 *p = (__u32 *) addr + (nr >> 5);
-	__u32 m = 1 << (nr & 31);
+	u_int32_t *p = (u_int32_t *) addr + (nr >> 5);
+	u_int32_t m = 1 << (nr & 31);
 	int oldbitset = (*p & m) != 0;
 
 	*p |= m;
@@ -201,11 +206,11 @@ __test_and_set_bit (int nr, volatile voi
 static __inline__ int
 test_and_clear_bit (int nr, volatile void *addr)
 {
-	__u32 mask, old, new;
-	volatile __u32 *m;
+	u_int32_t mask, old, new;
+	volatile u_int32_t *m;
 	CMPXCHG_BUGCHECK_DECL
 
-	m = (volatile __u32 *) addr + (nr >> 5);
+	m = (volatile u_int32_t *) addr + (nr >> 5);
 	mask = ~(1 << (nr & 31));
 	do {
 		CMPXCHG_BUGCHECK(m);
@@ -227,8 +232,8 @@ test_and_clear_bit (int nr, volatile voi
 static __inline__ int
 __test_and_clear_bit(int nr, volatile void * addr)
 {
-	__u32 *p = (__u32 *) addr + (nr >> 5);
-	__u32 m = 1 << (nr & 31);
+	u_int32_t *p = (u_int32_t *) addr + (nr >> 5);
+	u_int32_t m = 1 << (nr & 31);
 	int oldbitset = *p & m;
 
 	*p &= ~m;
@@ -246,11 +251,11 @@ __test_and_clear_bit(int nr, volatile vo
 static __inline__ int
 test_and_change_bit (int nr, volatile void *addr)
 {
-	__u32 bit, old, new;
-	volatile __u32 *m;
+	u_int32_t bit, old, new;
+	volatile u_int32_t *m;
 	CMPXCHG_BUGCHECK_DECL
 
-	m = (volatile __u32 *) addr + (nr >> 5);
+	m = (volatile u_int32_t *) addr + (nr >> 5);
 	bit = (1 << (nr & 31));
 	do {
 		CMPXCHG_BUGCHECK(m);
@@ -266,8 +271,8 @@ test_and_change_bit (int nr, volatile vo
 static __inline__ int
 __test_and_change_bit (int nr, void *addr)
 {
-	__u32 old, bit = (1 << (nr & 31));
-	__u32 *m = (__u32 *) addr + (nr >> 5);
+	u_int32_t old, bit = (1 << (nr & 31));
+	u_int32_t *m = (u_int32_t *) addr + (nr >> 5);
 
 	old = *m;
 	*m = old ^ bit;
@@ -277,7 +282,7 @@ __test_and_change_bit (int nr, void *add
 static __inline__ int
 test_bit (int nr, const volatile void *addr)
 {
-	return 1 & (((const volatile __u32 *) addr)[nr >> 5] >> (nr & 31));
+	return 1 & (((const volatile u_int32_t *) addr)[nr >> 5] >> (nr & 31));
 }
 
 /**
--- kernel-headers/asm-ia64/intrinsics.h.kheaders	2005-03-02 02:38:10.000000000 -0500
+++ kernel-headers/asm-ia64/intrinsics.h	2005-03-10 10:59:52.564993539 -0500
@@ -44,7 +44,7 @@ extern unsigned long __bad_increment_for
 
 #define ia64_fetchadd(i,v,sem)								\
 ({											\
-	__u64 _tmp;									\
+	u_int64_t _tmp;									\
 	volatile __typeof__(*(v)) *_v = (v);						\
 	/* Can't use a switch () here: gcc isn't always smart enough for that... */	\
 	if ((i) == -16)									\
@@ -82,19 +82,19 @@ extern void ia64_xchg_called_with_bad_po
 									\
 	switch (size) {							\
 	      case 1:							\
-		__xchg_result = ia64_xchg1((__u8 *)ptr, x);		\
+		__xchg_result = ia64_xchg1((u_int8_t *)ptr, x);		\
 		break;							\
 									\
 	      case 2:							\
-		__xchg_result = ia64_xchg2((__u16 *)ptr, x);		\
+		__xchg_result = ia64_xchg2((u_int16_t *)ptr, x);		\
 		break;							\
 									\
 	      case 4:							\
-		__xchg_result = ia64_xchg4((__u32 *)ptr, x);		\
+		__xchg_result = ia64_xchg4((u_int32_t *)ptr, x);		\
 		break;							\
 									\
 	      case 8:							\
-		__xchg_result = ia64_xchg8((__u64 *)ptr, x);		\
+		__xchg_result = ia64_xchg8((u_int64_t *)ptr, x);		\
 		break;							\
 	      default:							\
 		ia64_xchg_called_with_bad_pointer();			\
@@ -121,30 +121,30 @@ extern long ia64_cmpxchg_called_with_bad
 
 #define ia64_cmpxchg(sem,ptr,old,new,size)						\
 ({											\
-	__u64 _o_, _r_;									\
+	u_int64_t _o_, _r_;									\
 											\
 	switch (size) {									\
-	      case 1: _o_ = (__u8 ) (long) (old); break;				\
-	      case 2: _o_ = (__u16) (long) (old); break;				\
-	      case 4: _o_ = (__u32) (long) (old); break;				\
-	      case 8: _o_ = (__u64) (long) (old); break;				\
+	      case 1: _o_ = (u_int8_t ) (long) (old); break;				\
+	      case 2: _o_ = (u_int16_t) (long) (old); break;				\
+	      case 4: _o_ = (u_int32_t) (long) (old); break;				\
+	      case 8: _o_ = (u_int64_t) (long) (old); break;				\
 	      default: break;								\
 	}										\
 	switch (size) {									\
 	      case 1:									\
-	      	_r_ = ia64_cmpxchg1_##sem((__u8 *) ptr, new, _o_);			\
+	      	_r_ = ia64_cmpxchg1_##sem((u_int8_t *) ptr, new, _o_);			\
 		break;									\
 											\
 	      case 2:									\
-	       _r_ = ia64_cmpxchg2_##sem((__u16 *) ptr, new, _o_);			\
+	       _r_ = ia64_cmpxchg2_##sem((u_int16_t *) ptr, new, _o_);			\
 		break;									\
 											\
 	      case 4:									\
-	      	_r_ = ia64_cmpxchg4_##sem((__u32 *) ptr, new, _o_);			\
+	      	_r_ = ia64_cmpxchg4_##sem((u_int32_t *) ptr, new, _o_);			\
 		break;									\
 											\
 	      case 8:									\
-		_r_ = ia64_cmpxchg8_##sem((__u64 *) ptr, new, _o_);			\
+		_r_ = ia64_cmpxchg8_##sem((u_int64_t *) ptr, new, _o_);			\
 		break;									\
 											\
 	      default:									\
--- kernel-headers/asm-ia64/pal.h.kheaders	2005-03-02 02:38:13.000000000 -0500
+++ kernel-headers/asm-ia64/pal.h	2005-03-10 10:59:52.565993740 -0500
@@ -75,7 +75,7 @@
 #define PAL_CACHE_WRITE		260	/* write tag & data of cacheline for diagnostic testing */
 #define PAL_VM_TR_READ		261	/* read contents of translation register */
 
-#ifndef __ASSEMBLY__
+#if defined(__KERNEL__) &&  !defined(__ASSEMBLY__)
 
 #include <linux/types.h>
 #include <asm/fpu.h>
--- kernel-headers/asm-ia64/processor.h.kheaders	2005-03-02 02:37:58.000000000 -0500
+++ kernel-headers/asm-ia64/processor.h	2005-03-10 10:59:52.566993942 -0500
@@ -23,6 +23,9 @@
 /* Our arch specific arch_init_sched_domain is in arch/ia64/kernel/domain.c */
 #define ARCH_HAS_SCHED_DOMAIN
 
+#define asm __asm__
+#define volatile __volatile__
+
 #define IA64_NUM_DBG_REGS	8
 /*
  * Limits for PMC and PMD are set to less than maximum architected values
--- kernel-headers/asm-mips/string.h.kheaders	2005-03-02 02:37:30.000000000 -0500
+++ kernel-headers/asm-mips/string.h	2005-03-10 10:59:52.566993942 -0500
@@ -10,8 +10,6 @@
 #ifndef _ASM_STRING_H
 #define _ASM_STRING_H
 
-#include <linux/config.h>
-
 /*
  * Most of the inline functions are rather naive implementations so I just
  * didn't bother updating them for 64-bit ...
--- kernel-headers/asm-ppc/bitops.h.kheaders	2005-03-02 02:38:09.000000000 -0500
+++ kernel-headers/asm-ppc/bitops.h	2005-03-10 10:59:52.566993942 -0500
@@ -2,11 +2,9 @@
  * bitops.h: Bit string operations on the ppc
  */
 
-#ifdef __KERNEL__
 #ifndef _PPC_BITOPS_H
 #define _PPC_BITOPS_H
 
-#include <linux/config.h>
 #include <linux/compiler.h>
 #include <asm/byteorder.h>
 #include <asm/atomic.h>
@@ -15,13 +13,14 @@
  * The test_and_*_bit operations are taken to imply a memory barrier
  * on SMP systems.
  */
-#ifdef CONFIG_SMP
 #define SMP_WMB		"eieio\n"
 #define SMP_MB		"\nsync"
-#else
-#define SMP_WMB
-#define SMP_MB
-#endif /* CONFIG_SMP */
+
+/* Erratum #77 on the 405 means we need a sync or dcbt before every stwcx.
+ */
+#ifndef PPC405_ERR77
+#define PPC405_ERR77(ra,rb)		"dcbt " #ra "," #rb ";"
+#endif
 
 static __inline__ void set_bit(int nr, volatile unsigned long * addr)
 {
@@ -225,7 +224,7 @@ static __inline__ int __ilog2(unsigned l
 {
 	int lz;
 
-	asm ("cntlzw %0,%1" : "=r" (lz) : "r" (x));
+	__asm__ ("cntlzw %0,%1" : "=r" (lz) : "r" (x));
 	return 31 - lz;
 }
 
@@ -259,7 +258,7 @@ static __inline__ int fls(unsigned int x
 {
 	int lz;
 
-	asm ("cntlzw %0,%1" : "=r" (lz) : "r" (x));
+	__asm__ ("cntlzw %0,%1" : "=r" (lz) : "r" (x));
 	return 32 - lz;
 }
 
@@ -457,4 +456,3 @@ found_middle:
 #define minix_find_first_zero_bit(addr,size) ext2_find_first_zero_bit(addr,size)
 
 #endif /* _PPC_BITOPS_H */
-#endif /* __KERNEL__ */
--- kernel-headers/asm-ppc/byteorder.h.kheaders	2005-03-02 02:38:08.000000000 -0500
+++ kernel-headers/asm-ppc/byteorder.h	2005-03-10 10:59:59.922477701 -0500
@@ -64,10 +64,8 @@ static __inline__ __attribute_const__ __
 
 #endif /* __KERNEL__ */
 
-#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
 #  define __BYTEORDER_HAS_U64__
 #  define __SWAB_64_THRU_32__
-#endif
 
 #endif /* __GNUC__ */
 
--- kernel-headers/asm-s390/bitops.h.kheaders	2005-03-02 02:38:34.000000000 -0500
+++ kernel-headers/asm-s390/bitops.h	2005-03-10 10:59:52.567994144 -0500
@@ -12,7 +12,6 @@
  *    Copyright (C) 1992, Linus Torvalds
  *
  */
-#include <linux/config.h>
 #include <linux/compiler.h>
 
 /*
@@ -59,9 +58,6 @@
 #define ALIGN_CS 0
 #else
 #define ALIGN_CS 1
-#ifndef CONFIG_SMP
-#error "bitops won't work without CONFIG_SMP"
-#endif
 #endif
 
 /* bitmap tables from arch/S390/kernel/bitmap.S */
@@ -113,7 +109,6 @@ extern const char _sb_findmap[];
 #define __BITOPS_WORDS(bits) (((bits)+__BITOPS_WORDSIZE-1)/__BITOPS_WORDSIZE)
 #define __BITOPS_BARRIER() __asm__ __volatile__ ( "" : : : "memory" )
 
-#ifdef CONFIG_SMP
 /*
  * SMP safe set_bit routine based on compare and swap (CS)
  */
@@ -242,7 +237,8 @@ test_and_change_bit_cs(unsigned long nr,
 	__BITOPS_BARRIER();
 	return (old & mask) != 0;
 }
-#endif /* CONFIG_SMP */
+
+#ifdef __KERNEL__
 
 /*
  * fast, non-SMP set_bit routine
@@ -485,22 +481,14 @@ test_and_change_bit_simple(unsigned long
 }
 #define __test_and_change_bit(X,Y)	test_and_change_bit_simple(X,Y)
 
-#ifdef CONFIG_SMP
+#endif /* __KERNEL__ */
+
 #define set_bit             set_bit_cs
 #define clear_bit           clear_bit_cs
 #define change_bit          change_bit_cs
 #define test_and_set_bit    test_and_set_bit_cs
 #define test_and_clear_bit  test_and_clear_bit_cs
 #define test_and_change_bit test_and_change_bit_cs
-#else
-#define set_bit             set_bit_simple
-#define clear_bit           clear_bit_simple
-#define change_bit          change_bit_simple
-#define test_and_set_bit    test_and_set_bit_simple
-#define test_and_clear_bit  test_and_clear_bit_simple
-#define test_and_change_bit test_and_change_bit_simple
-#endif
-
 
 /*
  * This routine doesn't need to be atomic.
--- kernel-headers/asm-s390/ptrace.h.kheaders	2005-03-02 02:38:13.000000000 -0500
+++ kernel-headers/asm-s390/ptrace.h	2005-03-10 10:59:52.568994346 -0500
@@ -181,7 +181,6 @@
 #define PTRACE_OLDSETOPTIONS         21
 
 #ifndef __ASSEMBLY__
-#include <linux/config.h>
 #include <linux/stddef.h>
 #include <linux/types.h>
 #include <asm/setup.h>
--- kernel-headers/asm-s390/system.h.kheaders	2005-03-02 02:38:33.000000000 -0500
+++ kernel-headers/asm-s390/system.h	2005-03-10 10:59:52.568994346 -0500
@@ -11,7 +11,9 @@
 #ifndef __ASM_SYSTEM_H
 #define __ASM_SYSTEM_H
 
+#ifdef __KERNEL__
 #include <linux/config.h>
+#endif
 #include <linux/kernel.h>
 #include <asm/types.h>
 #include <asm/ptrace.h>
@@ -443,20 +445,11 @@ __cmpxchg(volatile void *ptr, unsigned l
 /* For spinlocks etc */
 #define local_irq_save(x)	((x) = local_irq_disable())
 
-#ifdef CONFIG_SMP
-
 extern void smp_ctl_set_bit(int cr, int bit);
 extern void smp_ctl_clear_bit(int cr, int bit);
 #define ctl_set_bit(cr, bit) smp_ctl_set_bit(cr, bit)
 #define ctl_clear_bit(cr, bit) smp_ctl_clear_bit(cr, bit)
 
-#else
-
-#define ctl_set_bit(cr, bit) __ctl_set_bit(cr, bit)
-#define ctl_clear_bit(cr, bit) __ctl_clear_bit(cr, bit)
-
-#endif /* CONFIG_SMP */
-
 extern void (*_machine_restart)(char *command);
 extern void (*_machine_halt)(void);
 extern void (*_machine_power_off)(void);
--- kernel-headers/asm-sparc/atomic.h.kheaders	2005-03-02 02:38:38.000000000 -0500
+++ kernel-headers/asm-sparc/atomic.h	2005-03-10 10:59:52.569994547 -0500
@@ -10,8 +10,6 @@
 #ifndef __ARCH_SPARC_ATOMIC__
 #define __ARCH_SPARC_ATOMIC__
 
-#include <linux/config.h>
-
 typedef struct { volatile int counter; } atomic_t;
 
 #ifdef __KERNEL__
@@ -53,13 +51,6 @@ extern void atomic_set(atomic_t *, int);
  */
 typedef struct { volatile int counter; } atomic24_t;
 
-#ifndef CONFIG_SMP
-
-#define ATOMIC24_INIT(i)  { (i) }
-#define atomic24_read(v)          ((v)->counter)
-#define atomic24_set(v, i)        (((v)->counter) = i)
-
-#else
 /* We do the bulk of the actual work out of line in two common
  * routines in assembler, see arch/sparc/lib/atomic.S for the
  * "fun" details.
@@ -87,7 +78,6 @@ static inline int atomic24_read(const at
 }
 
 #define atomic24_set(v, i)	(((v)->counter) = ((i) << 8))
-#endif
 
 static inline int __atomic24_add(int i, atomic24_t *v)
 {
--- kernel-headers/asm-sparc/elf.h.kheaders	2005-03-02 02:38:18.000000000 -0500
+++ kernel-headers/asm-sparc/elf.h	2005-03-10 10:59:52.569994547 -0500
@@ -6,7 +6,6 @@
  * ELF register definitions..
  */
 
-#include <linux/config.h>
 #include <asm/ptrace.h>
 
 #ifdef __KERNEL__
--- kernel-headers/asm-sparc/io.h.kheaders	2005-03-02 02:37:48.000000000 -0500
+++ kernel-headers/asm-sparc/io.h	2005-03-10 11:01:00.995797503 -0500
@@ -4,274 +4,6 @@
 #ifndef __SPARC_IO_H
 #define __SPARC_IO_H
 
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/ioport.h>  /* struct resource */
-
-#include <asm/page.h>      /* IO address mapping routines need this */
-#include <asm/system.h>
-
-#define page_to_phys(page)	(((page) - mem_map) << PAGE_SHIFT)
-
-static inline u32 flip_dword (u32 l)
-{
-	return ((l&0xff)<<24) | (((l>>8)&0xff)<<16) | (((l>>16)&0xff)<<8)| ((l>>24)&0xff);
-}
-
-static inline u16 flip_word (u16 w)
-{
-	return ((w&0xff) << 8) | ((w>>8)&0xff);
-}
-
-#define mmiowb()
-
-/*
- * Memory mapped I/O to PCI
- */
-
-static inline u8 __raw_readb(const volatile void __iomem *addr)
-{
-	return *(__force volatile u8 *)addr;
-}
-
-static inline u16 __raw_readw(const volatile void __iomem *addr)
-{
-	return *(__force volatile u16 *)addr;
-}
-
-static inline u32 __raw_readl(const volatile void __iomem *addr)
-{
-	return *(__force volatile u32 *)addr;
-}
-
-static inline void __raw_writeb(u8 b, volatile void __iomem *addr)
-{
-	*(__force volatile u8 *)addr = b;
-}
-
-static inline void __raw_writew(u16 w, volatile void __iomem *addr)
-{
-	*(__force volatile u16 *)addr = w;
-}
-
-static inline void __raw_writel(u32 l, volatile void __iomem *addr)
-{
-	*(__force volatile u32 *)addr = l;
-}
-
-static inline u8 __readb(const volatile void __iomem *addr)
-{
-	return *(__force volatile u8 *)addr;
-}
-
-static inline u16 __readw(const volatile void __iomem *addr)
-{
-	return flip_word(*(__force volatile u16 *)addr);
-}
-
-static inline u32 __readl(const volatile void __iomem *addr)
-{
-	return flip_dword(*(__force volatile u32 *)addr);
-}
-
-static inline void __writeb(u8 b, volatile void __iomem *addr)
-{
-	*(__force volatile u8 *)addr = b;
-}
-
-static inline void __writew(u16 w, volatile void __iomem *addr)
-{
-	*(__force volatile u16 *)addr = flip_word(w);
-}
-
-static inline void __writel(u32 l, volatile void __iomem *addr)
-{
-	*(__force volatile u32 *)addr = flip_dword(l);
-}
-
-#define readb(__addr)		__readb(__addr)
-#define readw(__addr)		__readw(__addr)
-#define readl(__addr)		__readl(__addr)
-#define readb_relaxed(__addr)	readb(__addr)
-#define readw_relaxed(__addr)	readw(__addr)
-#define readl_relaxed(__addr)	readl(__addr)
-
-#define writeb(__b, __addr)	__writeb((__b),(__addr))
-#define writew(__w, __addr)	__writew((__w),(__addr))
-#define writel(__l, __addr)	__writel((__l),(__addr))
-
-/*
- * I/O space operations
- *
- * Arrangement on a Sun is somewhat complicated.
- *
- * First of all, we want to use standard Linux drivers
- * for keyboard, PC serial, etc. These drivers think
- * they access I/O space and use inb/outb.
- * On the other hand, EBus bridge accepts PCI *memory*
- * cycles and converts them into ISA *I/O* cycles.
- * Ergo, we want inb & outb to generate PCI memory cycles.
- *
- * If we want to issue PCI *I/O* cycles, we do this
- * with a low 64K fixed window in PCIC. This window gets
- * mapped somewhere into virtual kernel space and we
- * can use inb/outb again.
- */
-#define inb_local(__addr)	__readb((void __iomem *)(unsigned long)(__addr))
-#define inb(__addr)		__readb((void __iomem *)(unsigned long)(__addr))
-#define inw(__addr)		__readw((void __iomem *)(unsigned long)(__addr))
-#define inl(__addr)		__readl((void __iomem *)(unsigned long)(__addr))
-
-#define outb_local(__b, __addr)	__writeb(__b, (void __iomem *)(unsigned long)(__addr))
-#define outb(__b, __addr)	__writeb(__b, (void __iomem *)(unsigned long)(__addr))
-#define outw(__w, __addr)	__writew(__w, (void __iomem *)(unsigned long)(__addr))
-#define outl(__l, __addr)	__writel(__l, (void __iomem *)(unsigned long)(__addr))
-
-#define inb_p(__addr)		inb(__addr)
-#define outb_p(__b, __addr)	outb(__b, __addr)
-#define inw_p(__addr)		inw(__addr)
-#define outw_p(__w, __addr)	outw(__w, __addr)
-#define inl_p(__addr)		inl(__addr)
-#define outl_p(__l, __addr)	outl(__l, __addr)
-
-void outsb(unsigned long addr, const void *src, unsigned long cnt);
-void outsw(unsigned long addr, const void *src, unsigned long cnt);
-void outsl(unsigned long addr, const void *src, unsigned long cnt);
-void insb(unsigned long addr, void *dst, unsigned long count);
-void insw(unsigned long addr, void *dst, unsigned long count);
-void insl(unsigned long addr, void *dst, unsigned long count);
-
-#define IO_SPACE_LIMIT 0xffffffff
-
-/*
- * SBus accessors.
- *
- * SBus has only one, memory mapped, I/O space.
- * We do not need to flip bytes for SBus of course.
- */
-static inline u8 _sbus_readb(const volatile void __iomem *addr)
-{
-	return *(__force volatile u8 *)addr;
-}
-
-static inline u16 _sbus_readw(const volatile void __iomem *addr)
-{
-	return *(__force volatile u16 *)addr;
-}
-
-static inline u32 _sbus_readl(const volatile void __iomem *addr)
-{
-	return *(__force volatile u32 *)addr;
-}
-
-static inline void _sbus_writeb(u8 b, volatile void __iomem *addr)
-{
-	*(__force volatile u8 *)addr = b;
-}
-
-static inline void _sbus_writew(u16 w, volatile void __iomem *addr)
-{
-	*(__force volatile u16 *)addr = w;
-}
-
-static inline void _sbus_writel(u32 l, volatile void __iomem *addr)
-{
-	*(__force volatile u32 *)addr = l;
-}
-
-/*
- * The only reason for #define's is to hide casts to unsigned long.
- */
-#define sbus_readb(__addr)		_sbus_readb(__addr)
-#define sbus_readw(__addr)		_sbus_readw(__addr)
-#define sbus_readl(__addr)		_sbus_readl(__addr)
-#define sbus_writeb(__b, __addr)	_sbus_writeb(__b, __addr)
-#define sbus_writew(__w, __addr)	_sbus_writew(__w, __addr)
-#define sbus_writel(__l, __addr)	_sbus_writel(__l, __addr)
-
-static inline void sbus_memset_io(volatile void __iomem *__dst, int c, __kernel_size_t n)
-{
-	while(n--) {
-		sbus_writeb(c, __dst);
-		__dst++;
-	}
-}
-
-static inline void
-_memset_io(volatile void __iomem *dst, int c, __kernel_size_t n)
-{
-	volatile void __iomem *d = dst;
-
-	while (n--) {
-		writeb(c, d);
-		d++;
-	}
-}
-
-#define memset_io(d,c,sz)	_memset_io(d,c,sz)
-
-static inline void
-_memcpy_fromio(void *dst, const volatile void __iomem *src, __kernel_size_t n)
-{
-	char *d = dst;
-
-	while (n--) {
-		char tmp = readb(src);
-		*d++ = tmp;
-		src++;
-	}
-}
-
-#define memcpy_fromio(d,s,sz)	_memcpy_fromio(d,s,sz)
-
-static inline void 
-_memcpy_toio(volatile void __iomem *dst, const void *src, __kernel_size_t n)
-{
-	const char *s = src;
-	volatile void __iomem *d = dst;
-
-	while (n--) {
-		char tmp = *s++;
-		writeb(tmp, d);
-		d++;
-	}
-}
-
-#define memcpy_toio(d,s,sz)	_memcpy_toio(d,s,sz)
-
-#ifdef __KERNEL__
-
-/*
- * Bus number may be embedded in the higher bits of the physical address.
- * This is why we have no bus number argument to ioremap().
- */
-extern void __iomem *ioremap(unsigned long offset, unsigned long size);
-#define ioremap_nocache(X,Y)	ioremap((X),(Y))
-extern void iounmap(volatile void __iomem *addr);
-
-/*
- * Bus number may be in res->flags... somewhere.
- */
-extern void __iomem *sbus_ioremap(struct resource *res, unsigned long offset,
-    unsigned long size, char *name);
-extern void sbus_iounmap(volatile void __iomem *vaddr, unsigned long size);
-
-
-/*
- * At the moment, we do not use CMOS_READ anywhere outside of rtc.c,
- * so rtc_port is static in it. This should not change unless a new
- * hardware pops up.
- */
-#define RTC_PORT(x)   (rtc_port + (x))
-#define RTC_ALWAYS_BCD  0
-
-/* Nothing to do */
-/* P3: Only IDE DMA may need these. XXX Verify that it still does... */
-
-#define dma_cache_inv(_start,_size)		do { } while (0)
-#define dma_cache_wback(_start,_size)		do { } while (0)
-#define dma_cache_wback_inv(_start,_size)	do { } while (0)
-
-#endif
+#error "Never include asm/io.h ! This is kernel only."
 
 #endif /* !(__SPARC_IO_H) */
--- kernel-headers/asm-sparc/page.h.kheaders	2005-03-10 10:15:44.000000000 -0500
+++ kernel-headers/asm-sparc/page.h	2005-03-10 10:59:52.570994749 -0500
@@ -8,12 +8,8 @@
 #ifndef _SPARC_PAGE_H
 #define _SPARC_PAGE_H
 
-#include <linux/config.h>
-#ifdef CONFIG_SUN4
-#define PAGE_SHIFT   13
-#else
 #define PAGE_SHIFT   12
-#endif
+
 #ifndef __ASSEMBLY__
 /* I have my suspicions... -DaveM */
 #define PAGE_SIZE    (1UL << PAGE_SHIFT)
--- kernel-headers/asm-sparc/pgtable.h.kheaders	2005-03-02 02:38:10.000000000 -0500
+++ kernel-headers/asm-sparc/pgtable.h	2005-03-10 10:59:52.570994749 -0500
@@ -11,7 +11,6 @@
 
 #include <asm-generic/4level-fixup.h>
 
-#include <linux/config.h>
 #include <linux/spinlock.h>
 #include <linux/swap.h>
 #include <asm/types.h>
--- kernel-headers/asm-sparc/system.h.kheaders	2005-03-02 02:38:13.000000000 -0500
+++ kernel-headers/asm-sparc/system.h	2005-03-10 10:59:52.571994951 -0500
@@ -1,6 +1,4 @@
 /* $Id: system.h,v 1.86 2001/10/30 04:57:10 davem Exp $ */
-#include <linux/config.h>
-
 #ifndef __SPARC_SYSTEM_H
 #define __SPARC_SYSTEM_H
 
--- kernel-headers/asm-sparc64/io.h.kheaders	2005-03-02 02:38:25.000000000 -0500
+++ kernel-headers/asm-sparc64/io.h	2005-03-10 11:01:27.617167606 -0500
@@ -2,489 +2,6 @@
 #ifndef __SPARC64_IO_H
 #define __SPARC64_IO_H
 
-#include <linux/kernel.h>
-#include <linux/compiler.h>
-#include <linux/types.h>
-
-#include <asm/page.h>      /* IO address mapping routines need this */
-#include <asm/system.h>
-#include <asm/asi.h>
-
-/* PC crapola... */
-#define __SLOW_DOWN_IO	do { } while (0)
-#define SLOW_DOWN_IO	do { } while (0)
-
-extern unsigned long virt_to_bus_not_defined_use_pci_map(volatile void *addr);
-#define virt_to_bus virt_to_bus_not_defined_use_pci_map
-extern unsigned long bus_to_virt_not_defined_use_pci_map(volatile void *addr);
-#define bus_to_virt bus_to_virt_not_defined_use_pci_map
-
-/* BIO layer definitions. */
-extern unsigned long kern_base, kern_size;
-#define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
-#define BIO_VMERGE_BOUNDARY	8192
-
-/* Different PCI controllers we support have their PCI MEM space
- * mapped to an either 2GB (Psycho) or 4GB (Sabre) aligned area,
- * so need to chop off the top 33 or 32 bits.
- */
-extern unsigned long pci_memspace_mask;
-
-#define bus_dvma_to_mem(__vaddr) ((__vaddr) & pci_memspace_mask)
-
-static __inline__ u8 _inb(unsigned long addr)
-{
-	u8 ret;
-
-	__asm__ __volatile__("lduba\t[%1] %2, %0\t/* pci_inb */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ u16 _inw(unsigned long addr)
-{
-	u16 ret;
-
-	__asm__ __volatile__("lduha\t[%1] %2, %0\t/* pci_inw */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ u32 _inl(unsigned long addr)
-{
-	u32 ret;
-
-	__asm__ __volatile__("lduwa\t[%1] %2, %0\t/* pci_inl */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static __inline__ void _outb(u8 b, unsigned long addr)
-{
-	__asm__ __volatile__("stba\t%r0, [%1] %2\t/* pci_outb */"
-			     : /* no outputs */
-			     : "Jr" (b), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static __inline__ void _outw(u16 w, unsigned long addr)
-{
-	__asm__ __volatile__("stha\t%r0, [%1] %2\t/* pci_outw */"
-			     : /* no outputs */
-			     : "Jr" (w), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static __inline__ void _outl(u32 l, unsigned long addr)
-{
-	__asm__ __volatile__("stwa\t%r0, [%1] %2\t/* pci_outl */"
-			     : /* no outputs */
-			     : "Jr" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-#define inb(__addr)		(_inb((unsigned long)(__addr)))
-#define inw(__addr)		(_inw((unsigned long)(__addr)))
-#define inl(__addr)		(_inl((unsigned long)(__addr)))
-#define outb(__b, __addr)	(_outb((u8)(__b), (unsigned long)(__addr)))
-#define outw(__w, __addr)	(_outw((u16)(__w), (unsigned long)(__addr)))
-#define outl(__l, __addr)	(_outl((u32)(__l), (unsigned long)(__addr)))
-
-#define inb_p(__addr) 		inb(__addr)
-#define outb_p(__b, __addr)	outb(__b, __addr)
-#define inw_p(__addr)		inw(__addr)
-#define outw_p(__w, __addr)	outw(__w, __addr)
-#define inl_p(__addr)		inl(__addr)
-#define outl_p(__l, __addr)	outl(__l, __addr)
-
-extern void outsb(void __iomem *addr, const void *src, unsigned long count);
-extern void outsw(void __iomem *addr, const void *src, unsigned long count);
-extern void outsl(void __iomem *addr, const void *src, unsigned long count);
-extern void insb(void __iomem *addr, void *dst, unsigned long count);
-extern void insw(void __iomem *addr, void *dst, unsigned long count);
-extern void insl(void __iomem *addr, void *dst, unsigned long count);
-#define ioread8_rep(a,d,c)	insb(a,d,c)
-#define ioread16_rep(a,d,c)	insw(a,d,c)
-#define ioread32_rep(a,d,c)	insl(a,d,c)
-#define iowrite8_rep(a,s,c)	outsb(a,s,c)
-#define iowrite16_rep(a,s,c)	outsw(a,s,c)
-#define iowrite32_rep(a,s,c)	outsl(a,s,c)
-
-/* Memory functions, same as I/O accesses on Ultra. */
-static inline u8 _readb(const volatile void __iomem *addr)
-{	u8 ret;
-
-	__asm__ __volatile__("lduba\t[%1] %2, %0\t/* pci_readb */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-	return ret;
-}
-
-static inline u16 _readw(const volatile void __iomem *addr)
-{	u16 ret;
-
-	__asm__ __volatile__("lduha\t[%1] %2, %0\t/* pci_readw */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static inline u32 _readl(const volatile void __iomem *addr)
-{	u32 ret;
-
-	__asm__ __volatile__("lduwa\t[%1] %2, %0\t/* pci_readl */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static inline u64 _readq(const volatile void __iomem *addr)
-{	u64 ret;
-
-	__asm__ __volatile__("ldxa\t[%1] %2, %0\t/* pci_readq */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-
-	return ret;
-}
-
-static inline void _writeb(u8 b, volatile void __iomem *addr)
-{
-	__asm__ __volatile__("stba\t%r0, [%1] %2\t/* pci_writeb */"
-			     : /* no outputs */
-			     : "Jr" (b), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static inline void _writew(u16 w, volatile void __iomem *addr)
-{
-	__asm__ __volatile__("stha\t%r0, [%1] %2\t/* pci_writew */"
-			     : /* no outputs */
-			     : "Jr" (w), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static inline void _writel(u32 l, volatile void __iomem *addr)
-{
-	__asm__ __volatile__("stwa\t%r0, [%1] %2\t/* pci_writel */"
-			     : /* no outputs */
-			     : "Jr" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-static inline void _writeq(u64 q, volatile void __iomem *addr)
-{
-	__asm__ __volatile__("stxa\t%r0, [%1] %2\t/* pci_writeq */"
-			     : /* no outputs */
-			     : "Jr" (q), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E_L));
-}
-
-#define readb(__addr)		_readb(__addr)
-#define readw(__addr)		_readw(__addr)
-#define readl(__addr)		_readl(__addr)
-#define readq(__addr)		_readq(__addr)
-#define readb_relaxed(__addr)	_readb(__addr)
-#define readw_relaxed(__addr)	_readw(__addr)
-#define readl_relaxed(__addr)	_readl(__addr)
-#define readq_relaxed(__addr)	_readq(__addr)
-#define writeb(__b, __addr)	_writeb(__b, __addr)
-#define writew(__w, __addr)	_writew(__w, __addr)
-#define writel(__l, __addr)	_writel(__l, __addr)
-#define writeq(__q, __addr)	_writeq(__q, __addr)
-
-/* Now versions without byte-swapping. */
-static __inline__ u8 _raw_readb(unsigned long addr)
-{
-	u8 ret;
-
-	__asm__ __volatile__("lduba\t[%1] %2, %0\t/* pci_raw_readb */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ u16 _raw_readw(unsigned long addr)
-{
-	u16 ret;
-
-	__asm__ __volatile__("lduha\t[%1] %2, %0\t/* pci_raw_readw */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ u32 _raw_readl(unsigned long addr)
-{
-	u32 ret;
-
-	__asm__ __volatile__("lduwa\t[%1] %2, %0\t/* pci_raw_readl */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ u64 _raw_readq(unsigned long addr)
-{
-	u64 ret;
-
-	__asm__ __volatile__("ldxa\t[%1] %2, %0\t/* pci_raw_readq */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static __inline__ void _raw_writeb(u8 b, unsigned long addr)
-{
-	__asm__ __volatile__("stba\t%r0, [%1] %2\t/* pci_raw_writeb */"
-			     : /* no outputs */
-			     : "Jr" (b), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static __inline__ void _raw_writew(u16 w, unsigned long addr)
-{
-	__asm__ __volatile__("stha\t%r0, [%1] %2\t/* pci_raw_writew */"
-			     : /* no outputs */
-			     : "Jr" (w), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static __inline__ void _raw_writel(u32 l, unsigned long addr)
-{
-	__asm__ __volatile__("stwa\t%r0, [%1] %2\t/* pci_raw_writel */"
-			     : /* no outputs */
-			     : "Jr" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static __inline__ void _raw_writeq(u64 q, unsigned long addr)
-{
-	__asm__ __volatile__("stxa\t%r0, [%1] %2\t/* pci_raw_writeq */"
-			     : /* no outputs */
-			     : "Jr" (q), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-#define __raw_readb(__addr)		(_raw_readb((unsigned long)(__addr)))
-#define __raw_readw(__addr)		(_raw_readw((unsigned long)(__addr)))
-#define __raw_readl(__addr)		(_raw_readl((unsigned long)(__addr)))
-#define __raw_readq(__addr)		(_raw_readq((unsigned long)(__addr)))
-#define __raw_writeb(__b, __addr)	(_raw_writeb((u8)(__b), (unsigned long)(__addr)))
-#define __raw_writew(__w, __addr)	(_raw_writew((u16)(__w), (unsigned long)(__addr)))
-#define __raw_writel(__l, __addr)	(_raw_writel((u32)(__l), (unsigned long)(__addr)))
-#define __raw_writeq(__q, __addr)	(_raw_writeq((u64)(__q), (unsigned long)(__addr)))
-
-/* Valid I/O Space regions are anywhere, because each PCI bus supported
- * can live in an arbitrary area of the physical address range.
- */
-#define IO_SPACE_LIMIT 0xffffffffffffffffUL
-
-/* Now, SBUS variants, only difference from PCI is that we do
- * not use little-endian ASIs.
- */
-static inline u8 _sbus_readb(const volatile void __iomem *addr)
-{
-	u8 ret;
-
-	__asm__ __volatile__("lduba\t[%1] %2, %0\t/* sbus_readb */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static inline u16 _sbus_readw(const volatile void __iomem *addr)
-{
-	u16 ret;
-
-	__asm__ __volatile__("lduha\t[%1] %2, %0\t/* sbus_readw */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static inline u32 _sbus_readl(const volatile void __iomem *addr)
-{
-	u32 ret;
-
-	__asm__ __volatile__("lduwa\t[%1] %2, %0\t/* sbus_readl */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static inline u64 _sbus_readq(const volatile void __iomem *addr)
-{
-	u64 ret;
-
-	__asm__ __volatile__("ldxa\t[%1] %2, %0\t/* sbus_readq */"
-			     : "=r" (ret)
-			     : "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-
-	return ret;
-}
-
-static inline void _sbus_writeb(u8 b, volatile void __iomem *addr)
-{
-	__asm__ __volatile__("stba\t%r0, [%1] %2\t/* sbus_writeb */"
-			     : /* no outputs */
-			     : "Jr" (b), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static inline void _sbus_writew(u16 w, volatile void __iomem *addr)
-{
-	__asm__ __volatile__("stha\t%r0, [%1] %2\t/* sbus_writew */"
-			     : /* no outputs */
-			     : "Jr" (w), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static inline void _sbus_writel(u32 l, volatile void __iomem *addr)
-{
-	__asm__ __volatile__("stwa\t%r0, [%1] %2\t/* sbus_writel */"
-			     : /* no outputs */
-			     : "Jr" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-static inline void _sbus_writeq(u64 l, volatile void __iomem *addr)
-{
-	__asm__ __volatile__("stxa\t%r0, [%1] %2\t/* sbus_writeq */"
-			     : /* no outputs */
-			     : "Jr" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
-}
-
-#define sbus_readb(__addr)		_sbus_readb(__addr)
-#define sbus_readw(__addr)		_sbus_readw(__addr)
-#define sbus_readl(__addr)		_sbus_readl(__addr)
-#define sbus_readq(__addr)		_sbus_readq(__addr)
-#define sbus_writeb(__b, __addr)	_sbus_writeb(__b, __addr)
-#define sbus_writew(__w, __addr)	_sbus_writew(__w, __addr)
-#define sbus_writel(__l, __addr)	_sbus_writel(__l, __addr)
-#define sbus_writeq(__l, __addr)	_sbus_writeq(__l, __addr)
-
-static inline void _sbus_memset_io(volatile void __iomem *dst, int c, __kernel_size_t n)
-{
-	while(n--) {
-		sbus_writeb(c, dst);
-		dst++;
-	}
-}
-
-#define sbus_memset_io(d,c,sz)	_sbus_memset_io(d,c,sz)
-
-static inline void
-_memset_io(volatile void __iomem *dst, int c, __kernel_size_t n)
-{
-	volatile void __iomem *d = dst;
-
-	while (n--) {
-		writeb(c, d);
-		d++;
-	}
-}
-
-#define memset_io(d,c,sz)	_memset_io(d,c,sz)
-
-static inline void
-_memcpy_fromio(void *dst, const volatile void __iomem *src, __kernel_size_t n)
-{
-	char *d = dst;
-
-	while (n--) {
-		char tmp = readb(src);
-		*d++ = tmp;
-		src++;
-	}
-}
-
-#define memcpy_fromio(d,s,sz)	_memcpy_fromio(d,s,sz)
-
-static inline void 
-_memcpy_toio(volatile void __iomem *dst, const void *src, __kernel_size_t n)
-{
-	const char *s = src;
-	volatile void __iomem *d = dst;
-
-	while (n--) {
-		char tmp = *s++;
-		writeb(tmp, d);
-		d++;
-	}
-}
-
-#define memcpy_toio(d,s,sz)	_memcpy_toio(d,s,sz)
-
-static inline int check_signature(void __iomem *io_addr,
-				  const unsigned char *signature,
-				  int length)
-{
-	int retval = 0;
-	do {
-		if (readb(io_addr) != *signature++)
-			goto out;
-		io_addr++;
-	} while (--length);
-	retval = 1;
-out:
-	return retval;
-}
-
-#define mmiowb()
-
-#ifdef __KERNEL__
-
-/* On sparc64 we have the whole physical IO address space accessible
- * using physically addressed loads and stores, so this does nothing.
- */
-static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
-{
-	return (void __iomem *)offset;
-}
-
-#define ioremap_nocache(X,Y)		ioremap((X),(Y))
-
-static inline void iounmap(volatile void __iomem *addr)
-{
-}
-
-#define ioread8(X)			readb(X)
-#define ioread16(X)			readw(X)
-#define ioread32(X)			readl(X)
-#define iowrite8(val,X)			writeb(val,X)
-#define iowrite16(val,X)		writew(val,X)
-#define iowrite32(val,X)		writel(val,X)
-
-/* Create a virtual mapping cookie for an IO port range */
-extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
-extern void ioport_unmap(void __iomem *);
-
-/* Create a virtual mapping cookie for a PCI BAR (memory or IO) */
-struct pci_dev;
-extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
-extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
-
-/* Similarly for SBUS. */
-#define sbus_ioremap(__res, __offset, __size, __name) \
-({	unsigned long __ret; \
-	__ret  = (__res)->start + (((__res)->flags & 0x1ffUL) << 32UL); \
-	__ret += (unsigned long) (__offset); \
-	if (! request_region((__ret), (__size), (__name))) \
-		__ret = 0UL; \
-	(void __iomem *) __ret; \
-})
-
-#define sbus_iounmap(__addr, __size)	\
-	release_region((unsigned long)(__addr), (__size))
-
-/* Nothing to do */
-
-#define dma_cache_inv(_start,_size)		do { } while (0)
-#define dma_cache_wback(_start,_size)		do { } while (0)
-#define dma_cache_wback_inv(_start,_size)	do { } while (0)
-
-#endif
+#error "Never include asm/io.h ! This is kernel only."
 
 #endif /* !(__SPARC64_IO_H) */
--- kernel-headers/asm-sparc64/system.h.kheaders	2005-03-02 02:37:30.000000000 -0500
+++ kernel-headers/asm-sparc64/system.h	2005-03-10 11:01:52.004086972 -0500
@@ -2,7 +2,6 @@
 #ifndef __SPARC64_SYSTEM_H
 #define __SPARC64_SYSTEM_H
 
-#include <linux/config.h>
 #include <asm/ptrace.h>
 #include <asm/processor.h>
 #include <asm/visasm.h>
@@ -89,17 +88,10 @@ enum sparc_cpu {
 #define set_wmb(__var, __value) \
 	do { __var = __value; membar("#StoreStore"); } while(0)
 
-#ifdef CONFIG_SMP
 #define smp_mb()	mb()
 #define smp_rmb()	rmb()
 #define smp_wmb()	wmb()
 #define smp_read_barrier_depends()	read_barrier_depends()
-#else
-#define smp_mb()	__asm__ __volatile__("":::"memory")
-#define smp_rmb()	__asm__ __volatile__("":::"memory")
-#define smp_wmb()	__asm__ __volatile__("":::"memory")
-#define smp_read_barrier_depends()	do { } while(0)
-#endif
 
 #define flushi(addr)	__asm__ __volatile__ ("flush %0" : : "r" (addr) : "memory")
 
--- kernel-headers/asm-sparc64/ttable.h.kheaders	2005-03-02 02:37:47.000000000 -0500
+++ kernel-headers/asm-sparc64/ttable.h	2005-03-10 10:59:52.573995354 -0500
@@ -2,7 +2,6 @@
 #ifndef _SPARC64_TTABLE_H
 #define _SPARC64_TTABLE_H
 
-#include <linux/config.h>
 #include <asm/utrap.h>
 
 #ifdef __ASSEMBLY__
@@ -118,11 +117,6 @@
 	ba,pt	%xcc, utrap_ill;			\
 	 mov	lvl, %o1;
 
-#ifdef CONFIG_SUNOS_EMUL
-#define SUNOS_SYSCALL_TRAP SYSCALL_TRAP(linux_sparc_syscall32, sunos_sys_table)
-#else
-#define SUNOS_SYSCALL_TRAP TRAP(sunos_syscall)
-#endif
 #ifdef CONFIG_COMPAT
 #define	LINUX_32BIT_SYSCALL_TRAP SYSCALL_TRAP(linux_sparc_syscall32, sys_call_table32)
 #else
@@ -131,11 +125,6 @@
 #define LINUX_64BIT_SYSCALL_TRAP SYSCALL_TRAP(linux_sparc_syscall, sys_call_table64)
 #define GETCC_TRAP TRAP(getcc)
 #define SETCC_TRAP TRAP(setcc)
-#ifdef CONFIG_SOLARIS_EMUL
-#define SOLARIS_SYSCALL_TRAP TRAP(solaris_sparc_syscall)
-#else
-#define SOLARIS_SYSCALL_TRAP TRAP(solaris_syscall)
-#endif
 /* FIXME: Write these actually */	
 #define NETBSD_SYSCALL_TRAP TRAP(netbsd_syscall)
 #define BREAKPOINT_TRAP TRAP(breakpoint_trap)
--- kernel-headers/asm-x86_64/mtrr.h.kheaders	2005-03-02 02:37:49.000000000 -0500
+++ kernel-headers/asm-x86_64/mtrr.h	2005-03-10 10:59:52.573995354 -0500
@@ -23,8 +23,10 @@
 #ifndef _LINUX_MTRR_H
 #define _LINUX_MTRR_H
 
+#ifdef __KERNEL__
 #include <linux/config.h>
 #include <linux/ioctl.h>
+#endif
 
 #define	MTRR_IOCTL_BASE	'M'
 
--- kernel-headers/asm-x86_64/cache.h.kheaders	2005-03-02 02:38:25.000000000 -0500
+++ kernel-headers/asm-x86_64/cache.h	2005-03-10 10:59:52.573995354 -0500
@@ -4,6 +4,8 @@
 #ifndef __ARCH_X8664_CACHE_H
 #define __ARCH_X8664_CACHE_H
 
+#ifdef __KERNEL__
+
 #include <linux/config.h>
 
 /* L1 cache line size */
@@ -11,4 +13,6 @@
 #define L1_CACHE_BYTES	(1 << L1_CACHE_SHIFT)
 #define L1_CACHE_SHIFT_MAX 6	/* largest L1 which this arch supports */
 
+#endif /* __KERNEL__ */
+
 #endif
--- kernel-headers/asm-x86_64/posix_types.h.kheaders	2005-03-02 02:38:33.000000000 -0500
+++ kernel-headers/asm-x86_64/posix_types.h	2005-03-10 10:59:52.574995556 -0500
@@ -43,7 +43,7 @@ typedef __kernel_gid_t __kernel_gid32_t;
 
 typedef unsigned long	__kernel_old_dev_t;
 
-#ifdef __KERNEL__
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
 
 #undef __FD_SET
 static __inline__ void __FD_SET(unsigned long fd, __kernel_fd_set *fdsetp)
--- kernel-headers/asm-x86_64/processor.h.kheaders	2005-03-02 02:38:32.000000000 -0500
+++ kernel-headers/asm-x86_64/processor.h	2005-03-10 10:59:52.574995556 -0500
@@ -66,7 +66,7 @@ struct cpuinfo_x86 {
         __u32   x86_power; 	
 	__u32   x86_cpuid_level;	/* Max CPUID function supported */
 	unsigned long loops_per_jiffy;
-} ____cacheline_aligned;
+};
 
 #define X86_VENDOR_INTEL 0
 #define X86_VENDOR_CYRIX 1
--- kernel-headers/asm-x86_64/types.h.kheaders	2005-03-02 02:38:25.000000000 -0500
+++ kernel-headers/asm-x86_64/types.h	2005-03-10 10:59:59.921477500 -0500
@@ -19,8 +19,8 @@ typedef unsigned short __u16;
 typedef __signed__ int __s32;
 typedef unsigned int __u32;
 
-typedef __signed__ long long __s64;
-typedef unsigned long long  __u64;
+typedef __signed__ long __s64;
+typedef unsigned long  __u64;
 
 #endif /* __ASSEMBLY__ */
 
--- kernel-headers/linux/genhd.h.kheaders	2005-03-10 10:15:44.000000000 -0500
+++ kernel-headers/linux/genhd.h	2005-03-10 10:59:52.575995758 -0500
@@ -9,7 +9,6 @@
  *		<drew@colorado.edu>
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/major.h>
 #include <linux/device.h>
@@ -255,8 +254,6 @@ static inline void set_capacity(struct g
 
 #endif  /*  __KERNEL__  */
 
-#ifdef CONFIG_SOLARIS_X86_PARTITION
-
 #define SOLARIS_X86_NUMSLICE	8
 #define SOLARIS_X86_VTOC_SANE	(0x600DDEEEUL)
 
@@ -281,9 +278,6 @@ struct solaris_x86_vtoc {
 	char	v_asciilabel[128];	/* for compatibility */
 };
 
-#endif /* CONFIG_SOLARIS_X86_PARTITION */
-
-#ifdef CONFIG_BSD_DISKLABEL
 /*
  * BSD disklabel support by Yossi Gottlieb <yogo@math.tau.ac.il>
  * updated by Marc Espie <Marc.Espie@openbsd.org>
@@ -338,9 +332,6 @@ struct bsd_disklabel {
 	} d_partitions[BSD_MAXPARTITIONS];	/* actually may be more */
 };
 
-#endif	/* CONFIG_BSD_DISKLABEL */
-
-#ifdef CONFIG_UNIXWARE_DISKLABEL
 /*
  * Unixware slices support by Andrzej Krzysztofowicz <ankry@mif.pg.gda.pl>
  * and Krzysztof G. Baranowski <kgb@knm.org.pl>
@@ -392,7 +383,6 @@ struct unixware_disklabel {
 
 };  /* 408 */
 
-#endif /* CONFIG_UNIXWARE_DISKLABEL */
 
 #ifdef CONFIG_MINIX_SUBPARTITION
 #   define MINIX_NR_SUBPARTITIONS  4
--- kernel-headers/linux/timer.h.kheaders	2005-03-02 02:38:13.000000000 -0500
+++ kernel-headers/linux/timer.h	2005-03-10 10:59:52.575995758 -0500
@@ -1,7 +1,6 @@
 #ifndef _LINUX_TIMER_H
 #define _LINUX_TIMER_H
 
-#include <linux/config.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/stddef.h>
@@ -87,13 +86,8 @@ static inline void add_timer(struct time
 	__mod_timer(timer, timer->expires);
 }
 
-#ifdef CONFIG_SMP
-  extern int del_timer_sync(struct timer_list *timer);
-  extern int del_singleshot_timer_sync(struct timer_list *timer);
-#else
 # define del_timer_sync(t) del_timer(t)
 # define del_singleshot_timer_sync(t) del_timer(t)
-#endif
 
 extern void init_timers(void);
 extern void run_local_timers(void);
--- kernel-headers/linux/compiler.h.kheaders	2005-03-02 02:38:12.000000000 -0500
+++ kernel-headers/linux/compiler.h	2005-03-10 10:59:52.576995960 -0500
@@ -3,7 +3,7 @@
 
 #ifndef __ASSEMBLY__
 
-#ifdef __CHECKER__
+#if defined(__KERNEL__) && defined(__CHECKER__)
 # define __user		__attribute__((noderef, address_space(1)))
 # define __kernel	/* default address space */
 # define __safe		__attribute__((safe))
--- kernel-headers/linux/compiler-gcc+.h.kheaders	2005-03-02 02:38:32.000000000 -0500
+++ kernel-headers/linux/compiler-gcc+.h	2005-03-10 10:59:52.576995960 -0500
@@ -6,9 +6,12 @@
  */
 #include <linux/compiler-gcc.h>
 
+#ifndef __KERNEL__
 #define inline			inline		__attribute__((always_inline))
 #define __inline__		__inline__	__attribute__((always_inline))
 #define __inline		__inline	__attribute__((always_inline))
+#endif
+
 #define __deprecated		__attribute__((deprecated))
 #define __attribute_used__	__attribute__((__used__))
 #define __attribute_pure__	__attribute__((pure))
--- kernel-headers/linux/compiler-gcc3.h.kheaders	2005-03-02 02:37:30.000000000 -0500
+++ kernel-headers/linux/compiler-gcc3.h	2005-03-10 10:59:52.576995960 -0500
@@ -3,7 +3,7 @@
 /* These definitions are for GCC v3.x.  */
 #include <linux/compiler-gcc.h>
 
-#if __GNUC_MINOR__ >= 1
+#if __GNUC_MINOR__ >= 1 && defined __KERNEL__
 # define inline		inline		__attribute__((always_inline))
 # define __inline__	__inline__	__attribute__((always_inline))
 # define __inline	__inline	__attribute__((always_inline))
--- kernel-headers/linux/crc-ccitt.h.kheaders	2005-03-02 02:38:07.000000000 -0500
+++ kernel-headers/linux/crc-ccitt.h	2005-03-10 10:59:52.577996161 -0500
@@ -4,11 +4,11 @@
 
 #include <linux/types.h>
 
-extern u16 const crc_ccitt_table[256];
+extern __u16 const crc_ccitt_table[256];
 
-extern u16 crc_ccitt(u16 crc, const u8 *buffer, size_t len);
+extern __u16 crc_ccitt(__u16 crc, const __u8 *buffer, size_t len);
 
-static inline u16 crc_ccitt_byte(u16 crc, const u8 c)
+static inline __u16 crc_ccitt_byte(__u16 crc, const __u8 c)
 {
 	return (crc >> 8) ^ crc_ccitt_table[(crc ^ c) & 0xff];
 }
--- kernel-headers/linux/net.h.kheaders	2005-03-10 10:15:44.000000000 -0500
+++ kernel-headers/linux/net.h	2005-03-10 10:59:52.577996161 -0500
@@ -18,7 +18,6 @@
 #ifndef _LINUX_NET_H
 #define _LINUX_NET_H
 
-#include <linux/config.h>
 #include <linux/wait.h>
 #include <linux/stringify.h>
 #include <asm/socket.h>
@@ -201,11 +200,6 @@ extern int   	     kernel_recvmsg(struct
 				    struct kvec *vec, size_t num,
 				    size_t len, int flags);
 
-#ifndef CONFIG_SMP
-#define SOCKOPS_WRAPPED(name) name
-#define SOCKOPS_WRAP(name, fam)
-#else
-
 #define SOCKOPS_WRAPPED(name) __unlocked_##name
 
 #define SOCKCALL_WRAP(name, call, parms, args)		\
@@ -278,7 +272,6 @@ static struct proto_ops name##_ops = {		
 	.recvmsg	= __lock_##name##_recvmsg,	\
 	.mmap		= __lock_##name##_mmap,		\
 };
-#endif
 
 #define MODULE_ALIAS_NETPROTO(proto) \
 	MODULE_ALIAS("net-pf-" __stringify(proto))
--- kernel-headers/linux/sched.h.kheaders	2005-03-10 10:15:49.000000000 -0500
+++ kernel-headers/linux/sched.h	2005-03-10 10:59:52.578996363 -0500
@@ -3,7 +3,6 @@
 
 #include <asm/param.h>	/* for HZ */
 
-#include <linux/config.h>
 #include <linux/capability.h>
 #include <linux/threads.h>
 #include <linux/kernel.h>
--- kernel-headers/linux/capi.h.kheaders	2005-03-02 02:38:10.000000000 -0500
+++ kernel-headers/linux/capi.h	2005-03-10 10:59:52.579996565 -0500
@@ -14,6 +14,7 @@
 
 #include <asm/types.h>
 #include <linux/ioctl.h>
+#include <linux/compiler.h>
 #ifndef __KERNEL__
 #include <linux/kernelcapi.h>
 #endif
--- kernel-headers/linux/config.h.kheaders	2005-03-10 10:15:44.000000000 -0500
+++ kernel-headers/linux/config.h	2005-03-10 10:59:52.579996565 -0500
@@ -1,9 +0,0 @@
-#ifndef _LINUX_CONFIG_H
-#define _LINUX_CONFIG_H
-
-#include <linux/autoconf.h>
-#ifdef CONFIG_X86
-#include <asm/kgdb.h>
-#endif
-
-#endif
--- kernel-headers/linux/types.h.kheaders	2005-03-02 02:38:25.000000000 -0500
+++ kernel-headers/linux/types.h	2005-03-10 10:59:58.245139346 -0500
@@ -1,15 +1,7 @@
 #ifndef _LINUX_TYPES_H
 #define _LINUX_TYPES_H
 
-#ifdef	__KERNEL__
-#include <linux/config.h>
-
-#define BITS_TO_LONGS(bits) \
-	(((bits)+BITS_PER_LONG-1)/BITS_PER_LONG)
-#define DECLARE_BITMAP(name,bits) \
-	unsigned long name[BITS_TO_LONGS(bits)]
-#endif
-
+#include <linux/compiler.h>
 #include <linux/posix_types.h>
 #include <asm/types.h>
 
@@ -31,25 +23,8 @@ typedef __kernel_timer_t	timer_t;
 typedef __kernel_clockid_t	clockid_t;
 typedef __kernel_mqd_t		mqd_t;
 
-#ifdef __KERNEL__
-typedef __kernel_uid32_t	uid_t;
-typedef __kernel_gid32_t	gid_t;
-typedef __kernel_uid16_t        uid16_t;
-typedef __kernel_gid16_t        gid16_t;
-
-#ifdef CONFIG_UID16
-/* This is defined by include/asm-{arch}/posix_types.h */
-typedef __kernel_old_uid_t	old_uid_t;
-typedef __kernel_old_gid_t	old_gid_t;
-#endif /* CONFIG_UID16 */
-
-/* libc5 includes this file to define uid_t, thus uid_t can never change
- * when it is included by non-kernel code
- */
-#else
 typedef __kernel_uid_t		uid_t;
 typedef __kernel_gid_t		gid_t;
-#endif /* __KERNEL__ */
 
 #if defined(__GNUC__) && !defined(__STRICT_ANSI__)
 typedef __kernel_loff_t		loff_t;
@@ -132,16 +107,17 @@ typedef		__s64		int64_t;
 typedef unsigned long sector_t;
 #endif
 
+#endif /* __KERNEL_STRICT_NAMES */
+
 /*
  * The type of an index into the pagecache.  Use a #define so asm/types.h
  * can override it.
+ * XXX: temporary solution
  */
 #ifndef pgoff_t
 #define pgoff_t unsigned long
 #endif
 
-#endif /* __KERNEL_STRICT_NAMES */
-
 /*
  * Below are truly Linux-specific types that should never collide with
  * any application/library that wants linux/types.h.
@@ -162,11 +138,13 @@ typedef __u64 __bitwise __le64;
 typedef __u64 __bitwise __be64;
 #endif
 
+#ifdef __KERNEL__
 struct ustat {
 	__kernel_daddr_t	f_tfree;
 	__kernel_ino_t		f_tinode;
 	char			f_fname[6];
 	char			f_fpack[6];
 };
+#endif
 
 #endif /* _LINUX_TYPES_H */
--- kernel-headers/linux/module.h.kheaders	2005-03-02 02:38:17.000000000 -0500
+++ kernel-headers/linux/module.h	2005-03-10 10:59:59.911475482 -0500
@@ -6,7 +6,6 @@
  * Rewritten by Richard Henderson <rth@tamu.edu> Dec 1996
  * Rewritten again by Rusty Russell, 2002
  */
-#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
 #include <linux/list.h>
--- kernel-headers/linux/nfs_fs.h.kheaders	2005-03-02 02:38:00.000000000 -0500
+++ kernel-headers/linux/nfs_fs.h	2005-03-10 10:59:59.912475684 -0500
@@ -9,7 +9,6 @@
 #ifndef _LINUX_NFS_FS_H
 #define _LINUX_NFS_FS_H
 
-#include <linux/config.h>
 #include <linux/in.h>
 #include <linux/mm.h>
 #include <linux/pagemap.h>
--- kernel-headers/linux/ixjuser.h.kheaders	2005-03-02 02:38:37.000000000 -0500
+++ kernel-headers/linux/ixjuser.h	2005-03-10 10:59:59.913475885 -0500
@@ -44,6 +44,7 @@
 
 static char ixjuser_h_rcsid[] = "$Id: ixjuser.h,v 4.1 2001/08/05 00:17:37 craigs Exp $";
 
+#include <linux/compiler.h>
 #include <linux/telephony.h>
 
 
--- kernel-headers/linux/in.h.kheaders	2005-03-02 02:38:33.000000000 -0500
+++ kernel-headers/linux/in.h	2005-03-10 10:59:59.913475885 -0500
@@ -51,7 +51,7 @@ enum {
 
 /* Internet address. */
 struct in_addr {
-	__u32	s_addr;
+	u_int32_t	s_addr;
 };
 
 #define IP_TOS		1
@@ -121,42 +121,42 @@ struct ip_mreqn
 };
 
 struct ip_mreq_source {
-	__u32		imr_multiaddr;
-	__u32		imr_interface;
-	__u32		imr_sourceaddr;
+	u_int32_t		imr_multiaddr;
+	u_int32_t		imr_interface;
+	u_int32_t		imr_sourceaddr;
 };
 
 struct ip_msfilter {
-	__u32		imsf_multiaddr;
-	__u32		imsf_interface;
-	__u32		imsf_fmode;
-	__u32		imsf_numsrc;
-	__u32		imsf_slist[1];
+	u_int32_t		imsf_multiaddr;
+	u_int32_t		imsf_interface;
+	u_int32_t		imsf_fmode;
+	u_int32_t		imsf_numsrc;
+	u_int32_t		imsf_slist[1];
 };
 
 #define IP_MSFILTER_SIZE(numsrc) \
-	(sizeof(struct ip_msfilter) - sizeof(__u32) \
-	+ (numsrc) * sizeof(__u32))
+	(sizeof(struct ip_msfilter) - sizeof(u_int32_t) \
+	+ (numsrc) * sizeof(u_int32_t))
 
 struct group_req
 {
-	__u32				 gr_interface;	/* interface index */
+	u_int32_t				 gr_interface;	/* interface index */
 	struct __kernel_sockaddr_storage gr_group;	/* group address */
 };
 
 struct group_source_req
 {
-	__u32				 gsr_interface;	/* interface index */
+	u_int32_t				 gsr_interface;	/* interface index */
 	struct __kernel_sockaddr_storage gsr_group;	/* group address */
 	struct __kernel_sockaddr_storage gsr_source;	/* source address */
 };
 
 struct group_filter
 {
-	__u32				 gf_interface;	/* interface index */
+	u_int32_t				 gf_interface;	/* interface index */
 	struct __kernel_sockaddr_storage gf_group;	/* multicast address */
-	__u32				 gf_fmode;	/* filter mode */
-	__u32				 gf_numsrc;	/* number of sources */
+	u_int32_t				 gf_fmode;	/* filter mode */
+	u_int32_t				 gf_numsrc;	/* number of sources */
 	struct __kernel_sockaddr_storage gf_slist[1];	/* interface index */
 };
 
--- kernel-headers/linux/threads.h.kheaders	2005-03-02 02:37:42.000000000 -0500
+++ kernel-headers/linux/threads.h	2005-03-10 10:59:59.914476087 -0500
@@ -1,8 +1,6 @@
 #ifndef _LINUX_THREADS_H
 #define _LINUX_THREADS_H
 
-#include <linux/config.h>
-
 /*
  * The default limit for the nr of threads is now in
  * /proc/sys/kernel/threads-max.
@@ -14,11 +12,7 @@
  * bitmasks used on that platform, i.e. 32 or 64.  Setting this smaller
  * saves quite a bit of memory.
  */
-#ifdef CONFIG_SMP
-#define NR_CPUS		CONFIG_NR_CPUS
-#else
-#define NR_CPUS		1
-#endif
+#define NR_CPUS		sizeof(long)
 
 #define MIN_THREADS_LEFT_FOR_ROOT 4
 
--- kernel-headers/linux/ext2_fs_sb.h.kheaders	2005-03-02 02:38:25.000000000 -0500
+++ kernel-headers/linux/ext2_fs_sb.h	2005-03-10 10:59:59.914476087 -0500
@@ -46,9 +46,9 @@ struct ext2_sb_info {
 	int s_inode_size;
 	int s_first_ino;
 	spinlock_t s_next_gen_lock;
-	u32 s_next_generation;
+	u_int32_t s_next_generation;
 	unsigned long s_dir_count;
-	u8 *s_debts;
+	u_int8_t *s_debts;
 	struct percpu_counter s_freeblocks_counter;
 	struct percpu_counter s_freeinodes_counter;
 	struct percpu_counter s_dirs_counter;
--- kernel-headers/linux/mod_devicetable.h.kheaders	2005-03-02 02:38:33.000000000 -0500
+++ kernel-headers/linux/mod_devicetable.h	2005-03-10 10:59:59.915476289 -0500
@@ -9,15 +9,17 @@
 
 #ifdef __KERNEL__
 #include <linux/types.h>
-typedef unsigned long kernel_ulong_t;
+#else
+#include <stdint.h>
 #endif
+typedef unsigned long kernel_ulong_t;
 
 #define PCI_ANY_ID (~0)
 
 struct pci_device_id {
-	__u32 vendor, device;		/* Vendor and device ID or PCI_ANY_ID*/
-	__u32 subvendor, subdevice;	/* Subsystem ID's or PCI_ANY_ID */
-	__u32 class, class_mask;	/* (class,subclass,prog-if) triplet */
+	uint32_t vendor, device;		/* Vendor and device ID or PCI_ANY_ID*/
+	uint32_t subvendor, subdevice;	/* Subsystem ID's or PCI_ANY_ID */
+	uint32_t class, class_mask;	/* (class,subclass,prog-if) triplet */
 	kernel_ulong_t driver_data;	/* Data private to the driver */
 };
 
@@ -28,11 +30,11 @@ struct pci_device_id {
 #define IEEE1394_MATCH_VERSION		0x0008
 
 struct ieee1394_device_id {
-	__u32 match_flags;
-	__u32 vendor_id;
-	__u32 model_id;
-	__u32 specifier_id;
-	__u32 version;
+	uint32_t match_flags;
+	uint32_t vendor_id;
+	uint32_t model_id;
+	uint32_t specifier_id;
+	uint32_t version;
 	kernel_ulong_t driver_data;
 };
 
@@ -96,23 +98,23 @@ struct ieee1394_device_id {
  */
 struct usb_device_id {
 	/* which fields to match against? */
-	__u16		match_flags;
+	uint16_t		match_flags;
 
 	/* Used for product specific matches; range is inclusive */
-	__u16		idVendor;
-	__u16		idProduct;
-	__u16		bcdDevice_lo;
-	__u16		bcdDevice_hi;
+	uint16_t		idVendor;
+	uint16_t		idProduct;
+	uint16_t		bcdDevice_lo;
+	uint16_t		bcdDevice_hi;
 
 	/* Used for device class matches */
-	__u8		bDeviceClass;
-	__u8		bDeviceSubClass;
-	__u8		bDeviceProtocol;
+	uint8_t		bDeviceClass;
+	uint8_t		bDeviceSubClass;
+	uint8_t		bDeviceProtocol;
 
 	/* Used for interface class matches */
-	__u8		bInterfaceClass;
-	__u8		bInterfaceSubClass;
-	__u8		bInterfaceProtocol;
+	uint8_t		bInterfaceClass;
+	uint8_t		bInterfaceSubClass;
+	uint8_t		bInterfaceProtocol;
 
 	/* not matched against */
 	kernel_ulong_t	driver_info;
@@ -132,12 +134,12 @@ struct usb_device_id {
 
 /* s390 CCW devices */
 struct ccw_device_id {
-	__u16	match_flags;	/* which fields to match against */
+	uint16_t	match_flags;	/* which fields to match against */
 
-	__u16	cu_type;	/* control unit type     */
-	__u16	dev_type;	/* device type           */
-	__u8	cu_model;	/* control unit model    */
-	__u8	dev_model;	/* device model          */
+	uint16_t	cu_type;	/* control unit type     */
+	uint16_t	dev_type;	/* device type           */
+	uint8_t	cu_model;	/* control unit model    */
+	uint8_t	dev_model;	/* device model          */
 
 	kernel_ulong_t driver_info;
 };
@@ -152,15 +154,15 @@ struct ccw_device_id {
 #define PNP_MAX_DEVICES	8
 
 struct pnp_device_id {
-	__u8 id[PNP_ID_LEN];
+	uint8_t id[PNP_ID_LEN];
 	kernel_ulong_t driver_data;
 };
 
 struct pnp_card_device_id {
-	__u8 id[PNP_ID_LEN];
+	uint8_t id[PNP_ID_LEN];
 	kernel_ulong_t driver_data;
 	struct {
-		__u8 id[PNP_ID_LEN];
+		uint8_t id[PNP_ID_LEN];
 	} devs[PNP_MAX_DEVICES];
 };
 
--- kernel-headers/linux/pci.h.kheaders	2005-03-02 02:38:08.000000000 -0500
+++ kernel-headers/linux/pci.h	2005-03-10 10:59:59.915476289 -0500
@@ -17,7 +17,9 @@
 #ifndef LINUX_PCI_H
 #define LINUX_PCI_H
 
+#ifdef __KERNEL__
 #include <linux/mod_devicetable.h>
+#endif
 
 /*
  * Under PCI, each device has 256 bytes of configuration address space,
--- kernel-headers/linux/serio.h.kheaders	2005-03-02 02:38:10.000000000 -0500
+++ kernel-headers/linux/serio.h	2005-03-10 10:59:59.916476491 -0500
@@ -9,13 +9,11 @@
  * the Free Software Foundation.
  */
 
-#include <linux/ioctl.h>
-#include <linux/interrupt.h>
-
 #define SPIOCSTYPE	_IOW('q', 0x01, unsigned long)
 
 #ifdef __KERNEL__
-
+#include <linux/ioctl.h>
+#include <linux/interrupt.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/device.h>
--- kernel-headers/linux/sysctl.h.kheaders	2005-03-10 10:15:44.000000000 -0500
+++ kernel-headers/linux/sysctl.h	2005-03-10 10:59:59.917476692 -0500
@@ -18,6 +18,7 @@
 #ifndef _LINUX_SYSCTL_H
 #define _LINUX_SYSCTL_H
 
+#include <linux/compiler.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/list.h>
--- kernel-headers/linux/usbdevice_fs.h.kheaders	2005-03-02 02:37:50.000000000 -0500
+++ kernel-headers/linux/usbdevice_fs.h	2005-03-10 10:59:59.917476692 -0500
@@ -32,6 +32,7 @@
 #define _LINUX_USBDEVICE_FS_H
 
 #include <linux/types.h>
+#include <linux/compiler.h>
 
 /* --------------------------------------------------------------------- */
 
--- kernel-headers/linux/percpu_counter.h.kheaders	2005-03-02 02:38:10.000000000 -0500
+++ kernel-headers/linux/percpu_counter.h	2005-03-10 10:59:59.917476692 -0500
@@ -6,9 +6,7 @@
  * WARNING: these things are HUGE.  4 kbytes per counter on 32-way P4.
  */
 
-#include <linux/config.h>
 #include <linux/spinlock.h>
-#include <linux/smp.h>
 #include <linux/threads.h>
 #include <linux/percpu.h>
 
--- kernel-headers/linux/spinlock.h.kheaders	2005-03-10 10:15:44.000000000 -0500
+++ kernel-headers/linux/spinlock.h	2005-03-10 10:59:59.918476894 -0500
@@ -1,6 +1,8 @@
 #ifndef __LINUX_SPINLOCK_H
 #define __LINUX_SPINLOCK_H
 
+#ifdef __KERNEL__
+
 /*
  * include/linux/spinlock.h - generic locking declarations
  */
@@ -615,4 +617,10 @@ static inline int bit_spin_is_locked(int
  */
 #define spin_can_lock(lock)		(!spin_is_locked(lock))
 
+#else
+
+typedef struct { } spinlock_t;
+
+#endif /* __KERNEL__ */
+
 #endif /* __LINUX_SPINLOCK_H */
--- kernel-headers/linux/bitmap.h.kheaders	2005-03-02 02:38:33.000000000 -0500
+++ kernel-headers/linux/bitmap.h	2005-03-10 10:59:59.919477096 -0500
@@ -1,6 +1,7 @@
 #ifndef __LINUX_BITMAP_H
 #define __LINUX_BITMAP_H
 
+#ifdef __KERNEL__
 #ifndef __ASSEMBLY__
 
 #include <linux/types.h>
@@ -251,5 +252,6 @@ static inline void bitmap_shift_left(uns
 }
 
 #endif /* __ASSEMBLY__ */
+#endif /* __KERNEL__ */
 
 #endif /* __LINUX_BITMAP_H */
--- kernel-headers/linux/mman.h.kheaders	2005-03-02 02:37:48.000000000 -0500
+++ kernel-headers/linux/mman.h	2005-03-10 10:59:59.919477096 -0500
@@ -1,6 +1,9 @@
 #ifndef _LINUX_MMAN_H
 #define _LINUX_MMAN_H
 
+#ifndef __KERNEL__
+#include <asm/mman.h>
+#else
 #include <linux/config.h>
 #include <linux/mm.h>
 
@@ -64,4 +67,5 @@ calc_vm_flag_bits(unsigned long flags)
 	       _calc_vm_trans(flags, MAP_LOCKED,     VM_LOCKED    );
 }
 
+#endif /* __KERNEL__ */
 #endif /* _LINUX_MMAN_H */
--- kernel-headers/linux/blkpg.h.kheaders	2005-03-02 02:38:08.000000000 -0500
+++ kernel-headers/linux/blkpg.h	2005-03-10 10:59:59.920477298 -0500
@@ -24,6 +24,7 @@
  *
  * For today, only the partition stuff - aeb, 990515
  */
+#include <linux/compiler.h>
 #include <linux/ioctl.h>
 
 #define BLKPG      _IO(0x12,105)
--- kernel-headers/linux/cyclades.h.kheaders	2005-03-02 02:38:33.000000000 -0500
+++ kernel-headers/linux/cyclades.h	2005-03-10 10:59:59.920477298 -0500
@@ -67,6 +67,8 @@
 #ifndef _LINUX_CYCLADES_H
 #define _LINUX_CYCLADES_H
 
+#include <linux/compiler.h>
+
 struct cyclades_monitor {
         unsigned long           int_count;
         unsigned long           char_count;
--- kernel-headers/linux/usb_ch9.h.kheaders	2005-03-02 02:38:08.000000000 -0500
+++ kernel-headers/linux/usb_ch9.h	2005-03-10 10:59:59.921477500 -0500
@@ -16,7 +16,7 @@
 #ifndef __LINUX_USB_CH9_H
 #define __LINUX_USB_CH9_H
 
-#include <asm/types.h>		/* __u8 etc */
+#include <linux/types.h>		/* __u8 etc */
 
 /*-------------------------------------------------------------------------*/
 
--- kernel-headers/linux/if_fddi.h.kheaders	2005-03-02 02:38:09.000000000 -0500
+++ kernel-headers/linux/if_fddi.h	2005-03-10 10:59:59.922477701 -0500
@@ -24,6 +24,8 @@
 #ifndef _LINUX_IF_FDDI_H
 #define _LINUX_IF_FDDI_H
 
+#include <linux/netdevice.h>
+
 /*
  *  Define max and min legal sizes.  The frame sizes do not include
  *  4 byte FCS/CRC (frame check sequence).
--- kernel-headers/linux/fs.h.kheaders	2005-03-10 10:15:45.000000000 -0500
+++ kernel-headers/linux/fs.h	2005-03-10 11:03:31.937245640 -0500
@@ -6,7 +6,6 @@
  * structures etc.
  */
 
-#include <linux/config.h>
 #include <linux/limits.h>
 #include <linux/ioctl.h>
 
--- kernel-headers/linux/smp.h.kheaders	2005-03-02 02:38:10.000000000 -0500
+++ kernel-headers/linux/smp.h	2005-03-10 11:02:46.599099961 -0500
@@ -6,12 +6,8 @@
  *		Alan Cox. <alan@redhat.com>
  */
 
-#include <linux/config.h>
-
 extern void cpu_idle(void);
 
-#ifdef CONFIG_SMP
-
 #include <linux/preempt.h>
 #include <linux/kernel.h>
 #include <linux/compiler.h>
@@ -92,25 +88,6 @@ extern int smp_threads_ready;
  */
 void smp_prepare_boot_cpu(void);
 
-#else /* !SMP */
-
-/*
- *	These macros fold the SMP functionality into a single CPU system
- */
-
-#if !defined(__smp_processor_id) || !defined(CONFIG_PREEMPT)
-# define smp_processor_id()			0
-#endif
-#define hard_smp_processor_id()			0
-#define smp_threads_ready			1
-#define smp_call_function(func,info,retry,wait)	({ 0; })
-#define on_each_cpu(func,info,retry,wait)	({ func(info); 0; })
-static inline void smp_send_reschedule(int cpu) { }
-#define num_booting_cpus()			1
-#define smp_prepare_boot_cpu()			do {} while (0)
-
-#endif /* !SMP */
-
 /*
  * DEBUG_PREEMPT support: check whether smp_processor_id() is being
  * used in a preemption-safe way.
