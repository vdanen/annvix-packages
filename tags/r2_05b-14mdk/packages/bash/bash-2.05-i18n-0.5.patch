diff -ruN bash-2.05.orig/Makefile.in bash-2.05/Makefile.in
--- bash-2.05.orig/Makefile.in	Wed Apr  4 04:03:24 2001
+++ bash-2.05/Makefile.in	Mon Apr 16 20:50:58 2001
@@ -253,8 +253,11 @@
 GLOB_DEP = $(GLOB_LIBRARY)
 
 GLOB_SOURCE = $(GLOB_LIBSRC)/glob.c $(GLOB_LIBSRC)/fnmatch.c \
-	      $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h
-GLOB_OBJ    = $(GLOB_LIBDIR)/glob.o $(GLOB_LIBDIR)/fnmatch.o
+	      $(GLOB_LIBSRC)/xmbsrtowcs.c \
+	      $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h \
+	      $(GLOB_LIBSRC)/xmbsrtowcs.h  
+GLOB_OBJ    = $(GLOB_LIBDIR)/glob.o $(GLOB_LIBDIR)/fnmatch.o \
+	      $(GLOB_LIBSRC)/xmbsrtowcs.o  
 
 # The source, object and documentation for the GNU Tilde library.
 TILDE_LIBSRC = $(LIBSRC)/tilde
@@ -325,11 +328,11 @@
 	   input.c bashhist.c array.c sig.c pathexp.c \
 	   unwind_prot.c siglist.c bashline.c bracecomp.c error.c \
 	   list.c stringlib.c locale.c findcmd.c redir.c \
-	   pcomplete.c pcomplib.c syntax.c xmalloc.c
+	   pcomplete.c pcomplib.c syntax.c xmalloc.c xstrchr.c
 
 HSOURCES = shell.h flags.h trap.h hashcmd.h hashlib.h jobs.h builtins.h \
 	   general.h variables.h config.h $(ALLOC_HEADERS) alias.h \
-	   quit.h unwind_prot.h syntax.h \
+	   quit.h unwind_prot.h syntax.h xstrchr.h \
 	   command.h input.h error.h bashansi.h dispose_cmd.h make_cmd.h \
 	   subst.h externs.h siglist.h bashhist.h bashline.h bashtypes.h \
 	   array.h sig.h mailcheck.h bashintl.h bashjmp.h ${GRAM_H} \
@@ -351,7 +354,7 @@
 	   trap.o input.o unwind_prot.o pathexp.o sig.o test.o version.o \
 	   alias.o array.o braces.o bracecomp.o bashhist.o bashline.o \
 	   siglist.o list.o stringlib.o locale.o findcmd.o redir.o \
-	   pcomplete.o pcomplib.o syntax.o xmalloc.o
+	   pcomplete.o pcomplib.o syntax.o xmalloc.o xstrchr.o
 
 # Where the source code of the shell builtins resides.
 BUILTIN_SRCDIR=$(srcdir)/builtins
@@ -742,7 +745,7 @@
 eval.o: input.h execute_cmd.h
 execute_cmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
 execute_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-execute_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
+execute_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 execute_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 execute_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 execute_cmd.o: ${BASHINCDIR}/memalloc.h ${GRAM_H} flags.h builtins.h jobs.h quit.h siglist.h
@@ -766,7 +769,7 @@
 flags.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 general.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
 general.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-general.o: general.h bashtypes.h variables.h array.h hashlib.h
+general.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 general.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 general.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 general.o: ${BASHINCDIR}/maxpath.h ${BASHINCDIR}/posixtime.h
@@ -827,7 +830,7 @@
 redir.o: flags.h execute_cmd.h redir.h input.h
 shell.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
 shell.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-shell.o: general.h bashtypes.h variables.h array.h hashlib.h
+shell.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 shell.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 shell.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 shell.o: flags.h trap.h mailcheck.h builtins.h $(DEFSRC)/common.h
@@ -847,7 +850,7 @@
 stringlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 subst.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/posixstat.h
 subst.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-subst.o: general.h bashtypes.h variables.h array.h hashlib.h
+subst.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 subst.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 subst.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 subst.o: flags.h jobs.h siglist.h execute_cmd.h ${BASHINCDIR}/filecntl.h trap.h pathexp.h
@@ -855,7 +858,7 @@
 subst.o: bashline.h bashhist.h ${GLOB_LIBSRC}/fnmatch.h
 test.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
 test.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-test.o: general.h bashtypes.h variables.h array.h hashlib.h
+test.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 test.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 test.o: make_cmd.h subst.h sig.h pathnames.h externs.h test.h
 test.o: ${DEFSRC}/common.h
@@ -869,7 +872,7 @@
 unwind_prot.o: general.h unwind_prot.h quit.h sig.h
 variables.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
 variables.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-variables.o: general.h bashtypes.h variables.h array.h hashlib.h
+variables.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 variables.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 variables.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 variables.o: flags.h execute_cmd.h mailcheck.h input.h $(DEFSRC)/common.h
@@ -877,6 +880,7 @@
 variables.o: pcomplete.h
 version.o: version.h .build
 xmalloc.o: config.h bashtypes.h ${BASHINCDIR}/ansi_stdlib.h error.h
+xstrchr.o: config.h xstrchr.h
 
 # job control
 
@@ -933,7 +937,7 @@
 bashhist.o: $(GLOB_LIBSRC)/fnmatch.h
 bashline.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
 bashline.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-bashline.o: general.h bashtypes.h variables.h array.h hashlib.h
+bashline.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 bashline.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 bashline.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 bashline.o: builtins.h bashhist.h bashline.h execute_cmd.h findcmd.h pathexp.h
diff -ruN bash-2.05.orig/alias.c bash-2.05/alias.c
--- bash-2.05.orig/alias.c	Thu Aug  5 20:17:24 1999
+++ bash-2.05/alias.c	Mon Apr 16 20:50:58 2001
@@ -36,6 +36,7 @@
 #include "general.h"
 #include "externs.h"
 #include "alias.h"
+#include "xstrchr.h"
 
 #if defined (PROGRAMMABLE_COMPLETION)
 #  include "pcomplete.h"
@@ -513,7 +514,7 @@
       /* If there is a backslash-escaped character quoted in TOKEN,
 	 then we don't do alias expansion.  This should check for all
 	 other quoting characters, too. */
-      if (strchr (token, '\\'))
+      if (xstrchr ((const char *)token, '\\'))
 	expand_this_token = 0;
 
       /* If we should be expanding here, if we are expanding all words, or if
diff -ruN bash-2.05.orig/bashline.c bash-2.05/bashline.c
--- bash-2.05.orig/bashline.c	Wed Mar  7 03:36:07 2001
+++ bash-2.05/bashline.c	Mon Apr 16 20:50:58 2001
@@ -42,6 +42,7 @@
 #include <readline/rlconf.h>
 #include <readline/readline.h>
 #include <readline/history.h>
+#include "xstrchr.h"
 
 #include <glob/glob.h>
 
@@ -920,7 +921,7 @@
 
   /* If the word starts in `~', and there is no slash in the word, then
      try completing this word as a username. */
-  if (!matches && *text == '~' && !strchr (text, '/'))
+  if (!matches && *text == '~' && !xstrchr ((const char *)text, '/'))
     matches = rl_completion_matches (text, rl_username_completion_function);
 
   /* Another one.  Why not?  If the word starts in '@', then look through
@@ -1835,13 +1836,13 @@
   local_dirname = *dirname;
 
 #if 0
-  should_expand_dirname = strchr (local_dirname, '$') || strchr (local_dirname, '`');
+  should_expand_dirname = xstrchr ((const char *)local_dirname, '$') || xstrchr ((const char *)local_dirname, '`');
 #else
-  if (strchr (local_dirname, '$'))
+  if (xstrchr ((const char *)local_dirname, '$'))
     should_expand_dirname = 1;
   else
     {
-      t = strchr (local_dirname, '`');
+      t = xstrchr ((const char *)local_dirname, '`');
       if (t && unclosed_pair (local_dirname, strlen (local_dirname), "`") == 0)
 	should_expand_dirname = 1;
     }
@@ -2269,7 +2270,7 @@
 	}
       /* OK, we have an unquoted character.  Check its presence in
 	 rl_completer_word_break_characters. */
-      if (strchr (rl_completer_word_break_characters, *s))
+      if (xstrchr ((const char *)rl_completer_word_break_characters, *s))
 	*r++ = '\\';
       *r++ = *s;
     }
@@ -2311,7 +2312,7 @@
      the word being completed contains newlines, since those are not
      quoted correctly using backslashes (a backslash-newline pair is
      special to the shell parser). */
-  if (*qcp == '\0' && cs == COMPLETE_BSQUOTE && strchr (mtext, '\n'))
+  if (*qcp == '\0' && cs == COMPLETE_BSQUOTE && xstrchr ((const char *)mtext, '\n'))
     cs = COMPLETE_SQUOTE;
   else if (*qcp == '"')
     cs = COMPLETE_DQUOTE;
@@ -2319,11 +2320,11 @@
     cs = COMPLETE_SQUOTE;
 #if defined (BANG_HISTORY)
   else if (*qcp == '\0' && history_expansion && cs == COMPLETE_DQUOTE &&
-	   history_expansion_inhibited == 0 && strchr (mtext, '!'))
+	   history_expansion_inhibited == 0 && xstrchr ((const char *)mtext, '!'))
     cs = COMPLETE_BSQUOTE;
 
   if (*qcp == '"' && history_expansion && cs == COMPLETE_DQUOTE &&
-	history_expansion_inhibited == 0 && strchr (mtext, '!'))
+	history_expansion_inhibited == 0 && xstrchr ((const char *)mtext, '!'))
     {
       cs = COMPLETE_BSQUOTE;
       *qcp = '\0';
diff -ruN bash-2.05.orig/braces.c bash-2.05/braces.c
--- bash-2.05.orig/braces.c	Thu Feb 15 06:51:23 2001
+++ bash-2.05/braces.c	Wed Jun 20 16:04:41 2001
@@ -44,6 +44,56 @@
 extern char *extract_command_subst ();
 #endif
 
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+/* Declare mbstate_t state, and creat in initial state. */
+#if HANDLE_MULTIBYTE
+# define DECLARE_STATE                                                  \
+  mbstate_t state;                                                      \
+  memset (&state, '\0', sizeof(mbstate_t))
+#else
+# define DECLARE_STATE
+#endif
+
+/* Initialize state. */
+#if HANDLE_MULTIBYTE
+# define INITIALIZE_STATE memset (&state, '\0', sizeof(mbstate_t))
+#else
+# define INITIALIZE_STATE
+#endif
+
+/* Skip one character, that character is unibyte or multibyte. */
+#if HANDLE_MULTIBYTE
+# define SKIP_ONE_CHARACTER(_string, _i)                                \
+   do                                                                   \
+    {                                                                   \
+      if(MB_CUR_MAX > 1)                                                \
+	{                                                               \
+	  mbstate_t state_bak;                                          \
+	  size_t mblength;                                              \
+									\
+	  state_bak = state;                                            \
+	  mblength = mbrlen(_string + _i, strlen(_string + _i), &state);  \
+									\
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)         \
+	    {                                                           \
+	      state = state_bak;                                        \
+	      _i++;                                                     \
+	    }                                                           \
+	  else                                                          \
+	      _i += mblength;                                           \
+	}                                                               \
+      else                                                              \
+	_i++;                                                           \
+    } while(0)
+#else
+# define SKIP_ONE_CHARACTER(_string, _i) _i++
+#endif
+
 /* Basic idea:
 
    Segregate the text into 3 sections: preamble (stuff before an open brace),
@@ -69,6 +119,8 @@
   char **tack, **result;
   int i, j, c;
 
+  DECLARE_STATE;
+
   /* Find the text of the preamble. */
   i = 0;
   c = brace_gobbler (text, &i, '{');
@@ -96,11 +148,13 @@
 #if defined (NOTDEF)
       /* Well, if we found an unquoted BRACE_ARG_SEPARATOR between START
 	 and I, then this should be an error.  Otherwise, it isn't. */
-      for (j = start; j < i; j++)
+      j = start;
+      while (j < i)
 	{
 	  if (text[j] == '\\')
 	    {
 	      j++;
+	      SKIP_ONE_CHARACTER(text, j);
 	      continue;
 	    }
 
@@ -110,6 +164,7 @@
 	      report_error ("missing `}'");
 	      throw_to_top_level ();
 	    }
+	  SKIP_ONE_CHARACTER(text, j);
 	}
 #endif
       free (preamble);		/* Same as result[0]; see initialization. */
@@ -126,17 +181,22 @@
 #endif
 
 #if defined (SHELL)
+  INITIALIZE_STATE;
+
   /* If the amble does not contain an unquoted BRACE_ARG_SEPARATOR, then
      just return without doing any expansion.  */
-  for (j = 0; amble[j]; j++)
+  j = 0;
+  while (amble[j])
     {
       if (amble[j] == '\\')
 	{
 	  j++;
+	  SKIP_ONE_CHARACTER(text, j);
 	  continue;
 	}
       if (amble[j] == brace_arg_separator)
 	break;
+      SKIP_ONE_CHARACTER(text, j);
     }
 
   if (!amble[j])
@@ -174,9 +234,12 @@
   char *tem;
   int start, i, c;
 
+  DECLARE_STATE;
+
   result = (char **)NULL;
 
-  for (start = 0, i = 0, c = 1; c; start = ++i)
+  start = 0;  i = 0;  c = 1;
+  while (c)
     {
       c = brace_gobbler (text, &i, brace_arg_separator);
 #if defined (SHELL)
@@ -206,6 +269,8 @@
 	  free (partial);
 	}
       free (tem);
+      SKIP_ONE_CHARACTER(text, i);
+      start = i;
     }
   return (result);
 }
@@ -226,13 +291,17 @@
   char *t;
 #endif
 
+  DECLARE_STATE;
+
   level = quoted = pass_next = 0;
 
-  for (i = *indx; c = text[i]; i++)
+  i = *indx;
+  while (c = text[i])
     {
       if (pass_next)
 	{
 	  pass_next = 0;
+	  SKIP_ONE_CHARACTER(text, i);
 	  continue;
 	}
 
@@ -241,6 +310,7 @@
       if (c == '\\' && (quoted == 0 || quoted == '"' || quoted == '`'))
 	{
 	  pass_next = 1;
+	  i++;
 	  continue;
 	}
 
@@ -248,12 +318,14 @@
 	{
 	  if (c == quoted)
 	    quoted = 0;
+	  SKIP_ONE_CHARACTER(text, i);
 	  continue;
 	}
 
       if (c == '"' || c == '\'' || c == '`')
 	{
 	  quoted = c;
+	  i++;
 	  continue;
 	}
 
@@ -265,6 +337,7 @@
 	  t = extract_command_subst (text, &si);
 	  i = si;
 	  free (t);
+	  i++;
 	  continue;
 	}
 #endif
@@ -277,7 +350,10 @@
 	  if (c == '{' &&
 	      ((!i || brace_whitespace (text[i - 1])) &&
 	       (brace_whitespace (text[i + 1]) || text[i + 1] == '}')))
-	    continue;
+	    {
+	      i++;
+	      continue;
+	    }
 #if defined (SHELL)
 	  /* If this is being compiled as part of bash, ignore the `{'
 	     in a `${}' construct */
@@ -290,6 +366,8 @@
 	level++;
       else if (c == '}' && level)
 	level--;
+
+      SKIP_ONE_CHARACTER(text, i);
     }
 
   *indx = i;
diff -ruN bash-2.05.orig/config-bot.h bash-2.05/config-bot.h
--- bash-2.05.orig/config-bot.h	Thu Feb  8 03:27:59 2001
+++ bash-2.05/config-bot.h	Wed Jun 20 16:04:41 2001
@@ -78,3 +78,42 @@
 #  undef PPROMPT
 #  define PPROMPT "$ "
 #endif
+
+
+/************************************************************
+ cheking multibyte capability for I18N code
+ ************************************************************/
+/* For platform which support the ISO C amendement 1 functionality we
+   support user defined character classes.  */
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined (HAVE_MBSRTOWCS) /* system is supposed to support XPG5 */
+#  define HANDLE_MULTIBYTE      1
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define wcsrtombs(dest, src, len, ps) (wcsrtombs) (dest, src, len, 0)
+# define mbsrtowcs(dest, src, len, ps) (mbsrtowcs) (dest, src, len, 0)
+# define wcrtomb(s, wc, ps) (wcrtomb) (s, wc, 0)
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+# define mbrlen(s, n, ps) (mbrlen) (s ,n, 0)
+# define mbstate_t int
+#endif
+
+/* fix some for system defining MB_LEN_MAX as 1 */
+#ifdef HANDLE_MULTIBYTE
+# include <limits.h>
+# if defined(MB_LEN_MAX) && (MB_LEN_MAX < 16)
+#  undef MB_LEN_MAX
+#  define MB_LEN_MAX 16
+# elif !defined(MB_LEN_MAX)
+#  define MB_LEN_MAX 16
+# endif
+#endif
+/************************************************************
+ end of cheking multibyte capability for I18N code
+ ************************************************************/
diff -ruN bash-2.05.orig/config.h.in bash-2.05/config.h.in
--- bash-2.05.orig/config.h.in	Mon Oct  2 22:44:22 2000
+++ bash-2.05/config.h.in	Wed Jun 20 16:04:41 2001
@@ -697,6 +697,12 @@
 
 #undef GETCWD_BROKEN
 
+/* checking multibyte handling capability */
+#undef HAVE_WCTYPE_H
+#undef HAVE_WCHAR_H
+#undef HAVE_MBSRTOWCS
+#undef HAVE_MBSTATE_T
+
 #include "config-bot.h"
 
 #endif /* _CONFIG_H_ */
diff -ruN bash-2.05.orig/configure bash-2.05/configure
--- bash-2.05.orig/configure	Wed Jan 24 02:57:28 2001
+++ bash-2.05/configure	Wed Jun 20 16:04:41 2001
@@ -1185,7 +1185,7 @@
 
 
 BASHVERS=2.05
-BASHPATCH=0
+BASHPATCH=1
 
 echo "Beginning configuration for bash-$BASHVERS for ${host_cpu}-${host_vendor}-${host_os}"
 
@@ -3242,9 +3242,170 @@
 done
 
 
+for ac_hdr in wctype.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:3250: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3255 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:3260: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_hdr in wchar.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:3290: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3295 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:3300: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+echo $ac_n "checking for mbsrtowcs""... $ac_c" 1>&6
+echo "configure:3327: checking for mbsrtowcs" >&5
+if eval "test \"`echo '$''{'ac_cv_func_mbsrtowcs'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3332 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char mbsrtowcs(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char mbsrtowcs();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_mbsrtowcs) || defined (__stub___mbsrtowcs)
+choke me
+#else
+mbsrtowcs();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:3355: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_mbsrtowcs=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_mbsrtowcs=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'mbsrtowcs`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  cat >> confdefs.h <<\EOF
+#define HAVE_MBSRTOWCS 1
+EOF
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3381 "configure"
+#include "confdefs.h"
+
+#include <wchar.h>
+
+int
+main ()
+{
+  mbstate_t ps;
+  return 0;
+}
+EOF
+if { (eval echo configure:3393: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  cat >> confdefs.h <<\EOF
+#define HAVE_MBSTATE_T 1
+EOF
+
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+fi
+rm -fr conftest*
+fi
+
+
 if test "$ac_cv_func_bindtextdomain" = "no"; then
     echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
-echo "configure:3248: checking for bindtextdomain in -lintl" >&5
+echo "configure:3409: checking for bindtextdomain in -lintl" >&5
 ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3252,7 +3413,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lintl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3256 "configure"
+#line 3417 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3263,7 +3424,7 @@
 bindtextdomain()
 ; return 0; }
 EOF
-if { (eval echo configure:3267: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3428: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3294,12 +3455,12 @@
 	for ac_func in gettext textdomain bindtextdomain
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3298: checking for $ac_func" >&5
+echo "configure:3459: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3303 "configure"
+#line 3464 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3322,7 +3483,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:3326: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3487: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -3351,7 +3512,7 @@
 
 if test "$opt_static_link" != yes; then
 echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:3355: checking for dlopen in -ldl" >&5
+echo "configure:3516: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3359,7 +3520,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3363 "configure"
+#line 3524 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3370,7 +3531,7 @@
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:3374: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3535: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3400,12 +3561,12 @@
 for ac_func in dlopen dlclose dlsym
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3404: checking for $ac_func" >&5
+echo "configure:3565: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3409 "configure"
+#line 3570 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3428,7 +3589,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:3432: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3593: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -3455,12 +3616,12 @@
 fi
 
 echo $ac_n "checking for sys_siglist declaration in signal.h or unistd.h""... $ac_c" 1>&6
-echo "configure:3459: checking for sys_siglist declaration in signal.h or unistd.h" >&5
+echo "configure:3620: checking for sys_siglist declaration in signal.h or unistd.h" >&5
 if eval "test \"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3464 "configure"
+#line 3625 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -3472,7 +3633,7 @@
 char *msg = *(sys_siglist + 1);
 ; return 0; }
 EOF
-if { (eval echo configure:3476: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3637: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_decl_sys_siglist=yes
 else
@@ -3498,12 +3659,12 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:3502: checking for $ac_hdr that defines DIR" >&5
+echo "configure:3663: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3507 "configure"
+#line 3668 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
@@ -3511,7 +3672,7 @@
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:3515: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3676: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
@@ -3536,7 +3697,7 @@
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:3540: checking for opendir in -ldir" >&5
+echo "configure:3701: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3544,7 +3705,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3548 "configure"
+#line 3709 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3555,7 +3716,7 @@
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:3559: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3720: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3577,7 +3738,7 @@
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:3581: checking for opendir in -lx" >&5
+echo "configure:3742: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3585,7 +3746,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3589 "configure"
+#line 3750 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3596,7 +3757,7 @@
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:3600: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3761: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3619,12 +3780,12 @@
 fi
 
 echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
-echo "configure:3623: checking whether time.h and sys/time.h may both be included" >&5
+echo "configure:3784: checking whether time.h and sys/time.h may both be included" >&5
 if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3628 "configure"
+#line 3789 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/time.h>
@@ -3633,7 +3794,7 @@
 struct tm *tp;
 ; return 0; }
 EOF
-if { (eval echo configure:3637: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3798: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_time=yes
 else
@@ -3660,17 +3821,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3664: checking for $ac_hdr" >&5
+echo "configure:3825: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3669 "configure"
+#line 3830 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3674: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3835: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3702,17 +3863,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3706: checking for $ac_hdr" >&5
+echo "configure:3867: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3711 "configure"
+#line 3872 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3716: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3877: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3742,17 +3903,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3746: checking for $ac_hdr" >&5
+echo "configure:3907: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3751 "configure"
+#line 3912 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3756: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3917: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3782,12 +3943,12 @@
 if test "$ac_cv_func_inet_aton" != 'yes'; then
 
 echo $ac_n "checking for inet_aton""... $ac_c" 1>&6
-echo "configure:3786: checking for inet_aton" >&5
+echo "configure:3947: checking for inet_aton" >&5
 if eval "test \"`echo '$''{'bash_cv_func_inet_aton'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3791 "configure"
+#line 3952 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -3798,7 +3959,7 @@
  inet_aton("127.0.0.1", &ap); 
 ; return 0; }
 EOF
-if { (eval echo configure:3802: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3963: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_func_inet_aton=yes
 else
@@ -3822,7 +3983,7 @@
 
 case "$host_os" in
 irix4*)	echo $ac_n "checking for getpwent in -lsun""... $ac_c" 1>&6
-echo "configure:3826: checking for getpwent in -lsun" >&5
+echo "configure:3987: checking for getpwent in -lsun" >&5
 ac_lib_var=`echo sun'_'getpwent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3830,7 +3991,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsun  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3834 "configure"
+#line 3995 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3841,7 +4002,7 @@
 getpwent()
 ; return 0; }
 EOF
-if { (eval echo configure:3845: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4006: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3876,14 +4037,14 @@
 _bash_needmsg=
 else
 echo $ac_n "checking for socket library""... $ac_c" 1>&6
-echo "configure:3880: checking for socket library" >&5
+echo "configure:4041: checking for socket library" >&5
 _bash_needmsg=yes
 fi
 if eval "test \"`echo '$''{'bash_cv_have_socklib'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo $ac_n "checking for getpeername in -lsocket""... $ac_c" 1>&6
-echo "configure:3887: checking for getpeername in -lsocket" >&5
+echo "configure:4048: checking for getpeername in -lsocket" >&5
 ac_lib_var=`echo socket'_'getpeername | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3891,7 +4052,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket -lnsl $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3895 "configure"
+#line 4056 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3902,7 +4063,7 @@
 getpeername()
 ; return 0; }
 EOF
-if { (eval echo configure:3906: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4067: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3935,14 +4096,14 @@
     _bash_needmsg=
   else
     echo $ac_n "checking for libnsl""... $ac_c" 1>&6
-echo "configure:3939: checking for libnsl" >&5
+echo "configure:4100: checking for libnsl" >&5
     _bash_needmsg=yes
   fi
   if eval "test \"`echo '$''{'bash_cv_have_libnsl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo $ac_n "checking for t_open in -lnsl""... $ac_c" 1>&6
-echo "configure:3946: checking for t_open in -lnsl" >&5
+echo "configure:4107: checking for t_open in -lnsl" >&5
 ac_lib_var=`echo nsl'_'t_open | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3950,7 +4111,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3954 "configure"
+#line 4115 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3961,7 +4122,7 @@
 t_open()
 ; return 0; }
 EOF
-if { (eval echo configure:3965: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4126: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4009,14 +4170,14 @@
 _bash_needmsg=yes
 else
 echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
-echo "configure:4013: checking for gethostbyname in socket library" >&5
+echo "configure:4174: checking for gethostbyname in socket library" >&5
 _bash_needmsg=
 fi
 if eval "test \"`echo '$''{'bash_cv_have_gethostbyname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4020 "configure"
+#line 4181 "configure"
 #include "confdefs.h"
 #include <netdb.h>
 int main() {
@@ -4025,7 +4186,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:4029: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4190: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_have_gethostbyname=yes
 else
@@ -4040,7 +4201,7 @@
 
 if test "X$_bash_needmsg" = Xyes; then
     echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
-echo "configure:4044: checking for gethostbyname in socket library" >&5
+echo "configure:4205: checking for gethostbyname in socket library" >&5
 fi
 echo "$ac_t""$bash_cv_have_gethostbyname" 1>&6
 if test "$bash_cv_have_gethostbyname" = yes; then
@@ -4053,12 +4214,12 @@
 fi
 
 echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:4057: checking for uid_t in sys/types.h" >&5
+echo "configure:4218: checking for uid_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4062 "configure"
+#line 4223 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 EOF
@@ -4087,7 +4248,7 @@
 fi
 
 echo $ac_n "checking type of array argument to getgroups""... $ac_c" 1>&6
-echo "configure:4091: checking type of array argument to getgroups" >&5
+echo "configure:4252: checking type of array argument to getgroups" >&5
 if eval "test \"`echo '$''{'ac_cv_type_getgroups'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4095,7 +4256,7 @@
   ac_cv_type_getgroups=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 4099 "configure"
+#line 4260 "configure"
 #include "confdefs.h"
 
 /* Thanks to Mike Rendell for this test.  */
@@ -4120,7 +4281,7 @@
 }
 
 EOF
-if { (eval echo configure:4124: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4285: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
     ac_cv_type_getgroups=gid_t
 else
@@ -4134,7 +4295,7 @@
 
 if test $ac_cv_type_getgroups = cross; then
         cat > conftest.$ac_ext <<EOF
-#line 4138 "configure"
+#line 4299 "configure"
 #include "confdefs.h"
 #include <unistd.h>
 EOF
@@ -4158,12 +4319,12 @@
 
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:4162: checking for ANSI C header files" >&5
+echo "configure:4323: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4167 "configure"
+#line 4328 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
@@ -4171,7 +4332,7 @@
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4175: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4336: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4188,7 +4349,7 @@
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 4192 "configure"
+#line 4353 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -4206,7 +4367,7 @@
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 4210 "configure"
+#line 4371 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -4227,7 +4388,7 @@
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 4231 "configure"
+#line 4392 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -4238,7 +4399,7 @@
 exit (0); }
 
 EOF
-if { (eval echo configure:4242: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4403: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -4262,12 +4423,12 @@
 fi
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:4266: checking for off_t" >&5
+echo "configure:4427: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4271 "configure"
+#line 4432 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4295,12 +4456,12 @@
 fi
 
 echo $ac_n "checking for mode_t""... $ac_c" 1>&6
-echo "configure:4299: checking for mode_t" >&5
+echo "configure:4460: checking for mode_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4304 "configure"
+#line 4465 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4328,12 +4489,12 @@
 fi
 
 echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:4332: checking for uid_t in sys/types.h" >&5
+echo "configure:4493: checking for uid_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4337 "configure"
+#line 4498 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 EOF
@@ -4362,12 +4523,12 @@
 fi
 
 echo $ac_n "checking for pid_t""... $ac_c" 1>&6
-echo "configure:4366: checking for pid_t" >&5
+echo "configure:4527: checking for pid_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4371 "configure"
+#line 4532 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4395,12 +4556,12 @@
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:4399: checking for size_t" >&5
+echo "configure:4560: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4404 "configure"
+#line 4565 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4428,12 +4589,12 @@
 fi
 
 echo $ac_n "checking for time_t""... $ac_c" 1>&6
-echo "configure:4432: checking for time_t" >&5
+echo "configure:4593: checking for time_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_time_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4437 "configure"
+#line 4598 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4462,12 +4623,12 @@
 
 
 echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
-echo "configure:4466: checking return type of signal handlers" >&5
+echo "configure:4627: checking return type of signal handlers" >&5
 if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4471 "configure"
+#line 4632 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -4484,7 +4645,7 @@
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:4488: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4649: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_type_signal=void
 else
@@ -4504,7 +4665,7 @@
 
 
 echo $ac_n "checking size of char""... $ac_c" 1>&6
-echo "configure:4508: checking size of char" >&5
+echo "configure:4669: checking size of char" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4512,9 +4673,10 @@
   ac_cv_sizeof_char=1
 else
   cat > conftest.$ac_ext <<EOF
-#line 4516 "configure"
+#line 4677 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4523,7 +4685,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4527: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4689: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_char=`cat conftestval`
 else
@@ -4543,7 +4705,7 @@
 
 
 echo $ac_n "checking size of short""... $ac_c" 1>&6
-echo "configure:4547: checking size of short" >&5
+echo "configure:4709: checking size of short" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4551,9 +4713,10 @@
   ac_cv_sizeof_short=2
 else
   cat > conftest.$ac_ext <<EOF
-#line 4555 "configure"
+#line 4717 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4562,7 +4725,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4566: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4729: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_short=`cat conftestval`
 else
@@ -4582,7 +4745,7 @@
 
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:4586: checking size of int" >&5
+echo "configure:4749: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4590,9 +4753,10 @@
   ac_cv_sizeof_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 4594 "configure"
+#line 4757 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4601,7 +4765,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4605: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4769: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -4621,7 +4785,7 @@
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:4625: checking size of long" >&5
+echo "configure:4789: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4629,9 +4793,10 @@
   ac_cv_sizeof_long=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 4633 "configure"
+#line 4797 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4640,7 +4805,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4644: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4809: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -4660,7 +4825,7 @@
 
 
 echo $ac_n "checking size of char *""... $ac_c" 1>&6
-echo "configure:4664: checking size of char *" >&5
+echo "configure:4829: checking size of char *" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_char_p'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4668,9 +4833,10 @@
   ac_cv_sizeof_char_p=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 4672 "configure"
+#line 4837 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4679,7 +4845,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4683: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4849: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_char_p=`cat conftestval`
 else
@@ -4699,7 +4865,7 @@
 
 
 echo $ac_n "checking size of double""... $ac_c" 1>&6
-echo "configure:4703: checking size of double" >&5
+echo "configure:4869: checking size of double" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_double'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4707,9 +4873,10 @@
   ac_cv_sizeof_double=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 4711 "configure"
+#line 4877 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4718,7 +4885,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4722: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4889: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_double=`cat conftestval`
 else
@@ -4739,12 +4906,12 @@
 
 
 echo $ac_n "checking for u_int""... $ac_c" 1>&6
-echo "configure:4743: checking for u_int" >&5
+echo "configure:4910: checking for u_int" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4748 "configure"
+#line 4915 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4772,12 +4939,12 @@
 fi
 
 echo $ac_n "checking for u_long""... $ac_c" 1>&6
-echo "configure:4776: checking for u_long" >&5
+echo "configure:4943: checking for u_long" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4781 "configure"
+#line 4948 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4808,12 +4975,12 @@
 
 if test "$ac_cv_sizeof_short" = 2; then
   echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
-echo "configure:4812: checking for bits16_t" >&5
+echo "configure:4979: checking for bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4817 "configure"
+#line 4984 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4842,12 +5009,12 @@
 
 elif test "$ac_cv_sizeof_char" = 2; then
   echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
-echo "configure:4846: checking for bits16_t" >&5
+echo "configure:5013: checking for bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4851 "configure"
+#line 5018 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4876,12 +5043,12 @@
 
 else
   echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
-echo "configure:4880: checking for bits16_t" >&5
+echo "configure:5047: checking for bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4885 "configure"
+#line 5052 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4913,12 +5080,12 @@
 
 if test "$ac_cv_sizeof_short" = 2; then
   echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
-echo "configure:4917: checking for u_bits16_t" >&5
+echo "configure:5084: checking for u_bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4922 "configure"
+#line 5089 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4947,12 +5114,12 @@
 
 elif test "$ac_cv_sizeof_char" = 2; then
   echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
-echo "configure:4951: checking for u_bits16_t" >&5
+echo "configure:5118: checking for u_bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4956 "configure"
+#line 5123 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4981,12 +5148,12 @@
 
 else
   echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
-echo "configure:4985: checking for u_bits16_t" >&5
+echo "configure:5152: checking for u_bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4990 "configure"
+#line 5157 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5018,12 +5185,12 @@
 
 if test "$ac_cv_sizeof_int" = 4; then
   echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
-echo "configure:5022: checking for bits32_t" >&5
+echo "configure:5189: checking for bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5027 "configure"
+#line 5194 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5052,12 +5219,12 @@
 
 elif test "$ac_cv_sizeof_long" = 4; then
   echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
-echo "configure:5056: checking for bits32_t" >&5
+echo "configure:5223: checking for bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5061 "configure"
+#line 5228 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5086,12 +5253,12 @@
 
 else
   echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
-echo "configure:5090: checking for bits32_t" >&5
+echo "configure:5257: checking for bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5095 "configure"
+#line 5262 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5123,12 +5290,12 @@
 
 if test "$ac_cv_sizeof_int" = 4; then
   echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
-echo "configure:5127: checking for u_bits32_t" >&5
+echo "configure:5294: checking for u_bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5132 "configure"
+#line 5299 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5157,12 +5324,12 @@
 
 elif test "$ac_cv_sizeof_long" = 4; then
   echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
-echo "configure:5161: checking for u_bits32_t" >&5
+echo "configure:5328: checking for u_bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5166 "configure"
+#line 5333 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5191,12 +5358,12 @@
 
 else
   echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
-echo "configure:5195: checking for u_bits32_t" >&5
+echo "configure:5362: checking for u_bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5200 "configure"
+#line 5367 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5228,12 +5395,12 @@
 
 if test "$ac_sv_sizeof_char_p" = 8; then
   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
-echo "configure:5232: checking for bits64_t" >&5
+echo "configure:5399: checking for bits64_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5237 "configure"
+#line 5404 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5262,12 +5429,12 @@
 
 elif test "$ac_cv_sizeof_double" = 8; then
   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
-echo "configure:5266: checking for bits64_t" >&5
+echo "configure:5433: checking for bits64_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5271 "configure"
+#line 5438 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5296,12 +5463,12 @@
 
 elif test "$ac_cv_sizeof_long" = 8; then
   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
-echo "configure:5300: checking for bits64_t" >&5
+echo "configure:5467: checking for bits64_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5305 "configure"
+#line 5472 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5330,12 +5497,12 @@
 
 else
   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
-echo "configure:5334: checking for bits64_t" >&5
+echo "configure:5501: checking for bits64_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5339 "configure"
+#line 5506 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5368,12 +5535,12 @@
 
 if test "$ac_cv_sizeof_int" = "$ac_cv_sizeof_char_p"; then
   echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
-echo "configure:5372: checking for ptrdiff_t" >&5
+echo "configure:5539: checking for ptrdiff_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5377 "configure"
+#line 5544 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5402,12 +5569,12 @@
 
 elif test "$ac_cv_sizeof_long" = "$ac_cv_sizeof_char_p"; then
   echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
-echo "configure:5406: checking for ptrdiff_t" >&5
+echo "configure:5573: checking for ptrdiff_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5411 "configure"
+#line 5578 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5436,12 +5603,12 @@
 
 else
   echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
-echo "configure:5440: checking for ptrdiff_t" >&5
+echo "configure:5607: checking for ptrdiff_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5445 "configure"
+#line 5612 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5472,12 +5639,12 @@
 
 
 echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&6
-echo "configure:5476: checking whether stat file-mode macros are broken" >&5
+echo "configure:5643: checking whether stat file-mode macros are broken" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stat_broken'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5481 "configure"
+#line 5648 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -5529,14 +5696,14 @@
 
 
 echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
-echo "configure:5533: checking whether byte ordering is bigendian" >&5
+echo "configure:5700: checking whether byte ordering is bigendian" >&5
 if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_bigendian=unknown
 # See if sys/param.h defines the BYTE_ORDER macro.
 cat > conftest.$ac_ext <<EOF
-#line 5540 "configure"
+#line 5707 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -5547,11 +5714,11 @@
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:5551: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5718: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat > conftest.$ac_ext <<EOF
-#line 5555 "configure"
+#line 5722 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -5562,7 +5729,7 @@
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:5566: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5733: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_bigendian=yes
 else
@@ -5582,7 +5749,7 @@
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 5586 "configure"
+#line 5753 "configure"
 #include "confdefs.h"
 main () {
   /* Are we little or big endian?  From Harbison&Steele.  */
@@ -5595,7 +5762,7 @@
   exit (u.c[sizeof (long) - 1] == 1);
 }
 EOF
-if { (eval echo configure:5599: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:5766: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_bigendian=no
 else
@@ -5622,7 +5789,7 @@
 # Pull the hash mark out of the macro call to avoid m4 problems.
 ac_msg="whether #! works in shell scripts"
 echo $ac_n "checking $ac_msg""... $ac_c" 1>&6
-echo "configure:5626: checking $ac_msg" >&5
+echo "configure:5793: checking $ac_msg" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_interpreter'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5649,7 +5816,7 @@
 
 fi
 echo $ac_n "checking for restartable system calls""... $ac_c" 1>&6
-echo "configure:5653: checking for restartable system calls" >&5
+echo "configure:5820: checking for restartable system calls" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_restartable_syscalls'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5657,7 +5824,7 @@
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 5661 "configure"
+#line 5828 "configure"
 #include "confdefs.h"
 /* Exit 0 (true) if wait returns something other than -1,
    i.e. the pid of the child, which means that wait was restarted
@@ -5675,7 +5842,7 @@
 }
 
 EOF
-if { (eval echo configure:5679: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:5846: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sys_restartable_syscalls=yes
 else
@@ -5700,12 +5867,12 @@
 
 if test "$ac_cv_func_lstat" = "no"; then
 echo $ac_n "checking for lstat""... $ac_c" 1>&6
-echo "configure:5704: checking for lstat" >&5
+echo "configure:5871: checking for lstat" >&5
 if eval "test \"`echo '$''{'bash_cv_func_lstat'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5709 "configure"
+#line 5876 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -5715,7 +5882,7 @@
  lstat(".",(struct stat *)0); 
 ; return 0; }
 EOF
-if { (eval echo configure:5719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5886: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_func_lstat=yes
 else
@@ -5738,7 +5905,7 @@
 fi
 
 echo $ac_n "checking if dup2 fails to clear the close-on-exec flag""... $ac_c" 1>&6
-echo "configure:5742: checking if dup2 fails to clear the close-on-exec flag" >&5
+echo "configure:5909: checking if dup2 fails to clear the close-on-exec flag" >&5
 if eval "test \"`echo '$''{'bash_cv_dup2_broken'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5747,7 +5914,7 @@
      bash_cv_dup2_broken=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 5751 "configure"
+#line 5918 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -5767,7 +5934,7 @@
 }
 
 EOF
-if { (eval echo configure:5771: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:5938: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_dup2_broken=yes
 else
@@ -5792,7 +5959,7 @@
 
 
 echo $ac_n "checking whether pgrps need synchronization""... $ac_c" 1>&6
-echo "configure:5796: checking whether pgrps need synchronization" >&5
+echo "configure:5963: checking whether pgrps need synchronization" >&5
 if eval "test \"`echo '$''{'bash_cv_pgrp_pipe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5801,7 +5968,7 @@
     bash_cv_pgrp_pipe=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 5805 "configure"
+#line 5972 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_UNISTD_H
@@ -5853,7 +6020,7 @@
 }
 
 EOF
-if { (eval echo configure:5857: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6024: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_pgrp_pipe=no
 else
@@ -5878,13 +6045,13 @@
 
 
 echo $ac_n "checking for type of signal functions""... $ac_c" 1>&6
-echo "configure:5882: checking for type of signal functions" >&5
+echo "configure:6049: checking for type of signal functions" >&5
 if eval "test \"`echo '$''{'bash_cv_signal_vintage'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 5888 "configure"
+#line 6055 "configure"
 #include "confdefs.h"
 #include <signal.h>
 int main() {
@@ -5897,7 +6064,7 @@
   
 ; return 0; }
 EOF
-if { (eval echo configure:5901: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6068: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_signal_vintage=posix
 else
@@ -5906,7 +6073,7 @@
   rm -rf conftest*
   
     cat > conftest.$ac_ext <<EOF
-#line 5910 "configure"
+#line 6077 "configure"
 #include "confdefs.h"
 #include <signal.h>
 int main() {
@@ -5916,7 +6083,7 @@
     
 ; return 0; }
 EOF
-if { (eval echo configure:5920: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6087: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_signal_vintage=4.2bsd
 else
@@ -5925,7 +6092,7 @@
   rm -rf conftest*
   
       cat > conftest.$ac_ext <<EOF
-#line 5929 "configure"
+#line 6096 "configure"
 #include "confdefs.h"
 
 	#include <signal.h>
@@ -5938,7 +6105,7 @@
         
 ; return 0; }
 EOF
-if { (eval echo configure:5942: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6109: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_signal_vintage=svr3
 else
@@ -5980,7 +6147,7 @@
 if test "$ac_cv_sys_restartable_syscalls" = "no"; then
 
 echo $ac_n "checking whether posix sigaction restarts system calls by default""... $ac_c" 1>&6
-echo "configure:5984: checking whether posix sigaction restarts system calls by default" >&5
+echo "configure:6151: checking whether posix sigaction restarts system calls by default" >&5
 if eval "test \"`echo '$''{'bash_cv_sys_restartable_syscalls'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5988,7 +6155,7 @@
   echo "configure: warning: cannot check restartable syscalls if cross compiling" 1>&2
 else
   cat > conftest.$ac_ext <<EOF
-#line 5992 "configure"
+#line 6159 "configure"
 #include "confdefs.h"
 /* Exit 0 (true) if wait returns something other than -1,
    i.e. the pid of the child, which means that wait was restarted
@@ -6025,7 +6192,7 @@
 }
 
 EOF
-if { (eval echo configure:6029: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6196: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_sys_restartable_syscalls=yes
 else
@@ -6051,12 +6218,12 @@
 fi
 
 echo $ac_n "checking for sys_errlist and sys_nerr""... $ac_c" 1>&6
-echo "configure:6055: checking for sys_errlist and sys_nerr" >&5
+echo "configure:6222: checking for sys_errlist and sys_nerr" >&5
 if eval "test \"`echo '$''{'bash_cv_sys_errlist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6060 "configure"
+#line 6227 "configure"
 #include "confdefs.h"
 #include <errno.h>
 int main() {
@@ -6065,7 +6232,7 @@
  char *msg = sys_errlist[sys_nerr - 1];
 ; return 0; }
 EOF
-if { (eval echo configure:6069: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6236: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_sys_errlist=yes
 else
@@ -6086,7 +6253,7 @@
 
 
 echo $ac_n "checking for sys_siglist in system C library""... $ac_c" 1>&6
-echo "configure:6090: checking for sys_siglist in system C library" >&5
+echo "configure:6257: checking for sys_siglist in system C library" >&5
 if eval "test \"`echo '$''{'bash_cv_sys_siglist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6095,7 +6262,7 @@
 	 bash_cv_sys_siglist=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 6099 "configure"
+#line 6266 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -6112,7 +6279,7 @@
 exit(msg == 0);
 }
 EOF
-if { (eval echo configure:6116: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6283: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_sys_siglist=yes
 else
@@ -6135,12 +6302,12 @@
 fi
 
 echo $ac_n "checking for _sys_siglist in signal.h or unistd.h""... $ac_c" 1>&6
-echo "configure:6139: checking for _sys_siglist in signal.h or unistd.h" >&5
+echo "configure:6306: checking for _sys_siglist in signal.h or unistd.h" >&5
 if eval "test \"`echo '$''{'bash_cv_decl_under_sys_siglist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6144 "configure"
+#line 6311 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -6152,7 +6319,7 @@
  char *msg = _sys_siglist[2]; 
 ; return 0; }
 EOF
-if { (eval echo configure:6156: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6323: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_decl_under_sys_siglist=yes
 else
@@ -6173,7 +6340,7 @@
 
 
 echo $ac_n "checking for _sys_siglist in system C library""... $ac_c" 1>&6
-echo "configure:6177: checking for _sys_siglist in system C library" >&5
+echo "configure:6344: checking for _sys_siglist in system C library" >&5
 if eval "test \"`echo '$''{'bash_cv_under_sys_siglist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6182,7 +6349,7 @@
 	 bash_cv_under_sys_siglist=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 6186 "configure"
+#line 6353 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -6199,7 +6366,7 @@
 exit(msg == 0);
 }
 EOF
-if { (eval echo configure:6203: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6370: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_under_sys_siglist=yes
 else
@@ -6223,12 +6390,12 @@
 
 
 echo $ac_n "checking whether signal handlers are of type void""... $ac_c" 1>&6
-echo "configure:6227: checking whether signal handlers are of type void" >&5
+echo "configure:6394: checking whether signal handlers are of type void" >&5
 if eval "test \"`echo '$''{'bash_cv_void_sighandler'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6232 "configure"
+#line 6399 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -6243,7 +6410,7 @@
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:6247: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6414: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_void_sighandler=yes
 else
@@ -6263,12 +6430,12 @@
 fi
 
 echo $ac_n "checking for clock_t""... $ac_c" 1>&6
-echo "configure:6267: checking for clock_t" >&5
+echo "configure:6434: checking for clock_t" >&5
 if eval "test \"`echo '$''{'bash_cv_type_clock_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6272 "configure"
+#line 6439 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -6299,12 +6466,12 @@
 fi
 
 echo $ac_n "checking for sigset_t""... $ac_c" 1>&6
-echo "configure:6303: checking for sigset_t" >&5
+echo "configure:6470: checking for sigset_t" >&5
 if eval "test \"`echo '$''{'bash_cv_type_sigset_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6308 "configure"
+#line 6475 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -6335,12 +6502,12 @@
 fi
 
 echo $ac_n "checking for quad_t""... $ac_c" 1>&6
-echo "configure:6339: checking for quad_t" >&5
+echo "configure:6506: checking for quad_t" >&5
 if eval "test \"`echo '$''{'bash_cv_type_quad_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6344 "configure"
+#line 6511 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -6376,12 +6543,12 @@
 fi
 
 echo $ac_n "checking for size and type of struct rlimit fields""... $ac_c" 1>&6
-echo "configure:6380: checking for size and type of struct rlimit fields" >&5
+echo "configure:6547: checking for size and type of struct rlimit fields" >&5
 if eval "test \"`echo '$''{'bash_cv_type_rlimit'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6385 "configure"
+#line 6552 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/resource.h>
@@ -6389,7 +6556,7 @@
 rlim_t xxx;
 ; return 0; }
 EOF
-if { (eval echo configure:6393: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6560: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_type_rlimit=rlim_t
 else
@@ -6402,7 +6569,7 @@
          bash_cv_type_rlimit=long
 else
   cat > conftest.$ac_ext <<EOF
-#line 6406 "configure"
+#line 6573 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -6418,7 +6585,7 @@
   exit(1);
 }
 EOF
-if { (eval echo configure:6422: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6589: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_type_rlimit=quad_t
 else
@@ -6450,12 +6617,12 @@
 
 
 echo $ac_n "checking for a c_line member of struct termios""... $ac_c" 1>&6
-echo "configure:6454: checking for a c_line member of struct termios" >&5
+echo "configure:6621: checking for a c_line member of struct termios" >&5
 if eval "test \"`echo '$''{'bash_cv_termios_ldisc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6459 "configure"
+#line 6626 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <termios.h>
@@ -6463,7 +6630,7 @@
 struct termios t; int i; i = t.c_line;
 ; return 0; }
 EOF
-if { (eval echo configure:6467: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6634: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_termios_ldisc=yes
 else
@@ -6483,12 +6650,12 @@
 fi
 
 echo $ac_n "checking for a c_line member of struct termio""... $ac_c" 1>&6
-echo "configure:6487: checking for a c_line member of struct termio" >&5
+echo "configure:6654: checking for a c_line member of struct termio" >&5
 if eval "test \"`echo '$''{'bash_cv_termio_ldisc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6492 "configure"
+#line 6659 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <termio.h>
@@ -6496,7 +6663,7 @@
 struct termio t; int i; i = t.c_line;
 ; return 0; }
 EOF
-if { (eval echo configure:6500: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6667: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_termio_ldisc=yes
 else
@@ -6517,12 +6684,12 @@
 
 
 echo $ac_n "checking if struct dirent has a d_ino member""... $ac_c" 1>&6
-echo "configure:6521: checking if struct dirent has a d_ino member" >&5
+echo "configure:6688: checking if struct dirent has a d_ino member" >&5
 if eval "test \"`echo '$''{'bash_cv_dirent_has_dino'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6526 "configure"
+#line 6693 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -6551,7 +6718,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6555: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6722: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_dirent_has_dino=yes
 else
@@ -6573,12 +6740,12 @@
 
 
 echo $ac_n "checking if struct dirent has a d_fileno member""... $ac_c" 1>&6
-echo "configure:6577: checking if struct dirent has a d_fileno member" >&5
+echo "configure:6744: checking if struct dirent has a d_fileno member" >&5
 if eval "test \"`echo '$''{'bash_cv_dirent_has_d_fileno'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6582 "configure"
+#line 6749 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -6607,7 +6774,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6611: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6778: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_dirent_has_d_fileno=yes
 else
@@ -6628,12 +6795,12 @@
 fi
 
 echo $ac_n "checking for struct winsize in sys/ioctl.h and termios.h""... $ac_c" 1>&6
-echo "configure:6632: checking for struct winsize in sys/ioctl.h and termios.h" >&5
+echo "configure:6799: checking for struct winsize in sys/ioctl.h and termios.h" >&5
 if eval "test \"`echo '$''{'bash_cv_struct_winsize_header'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6637 "configure"
+#line 6804 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -6641,7 +6808,7 @@
 struct winsize x;
 ; return 0; }
 EOF
-if { (eval echo configure:6645: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6812: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_struct_winsize_header=ioctl_h
 else
@@ -6649,7 +6816,7 @@
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 6653 "configure"
+#line 6820 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <termios.h>
@@ -6657,7 +6824,7 @@
 struct winsize x;
 ; return 0; }
 EOF
-if { (eval echo configure:6661: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6828: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_struct_winsize_header=termios_h
 else
@@ -6689,13 +6856,13 @@
 fi
 
 echo $ac_n "checking for struct timeval in sys/time.h and time.h""... $ac_c" 1>&6
-echo "configure:6693: checking for struct timeval in sys/time.h and time.h" >&5
+echo "configure:6860: checking for struct timeval in sys/time.h and time.h" >&5
 if eval "test \"`echo '$''{'bash_cv_struct_timeval'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 cat > conftest.$ac_ext <<EOF
-#line 6699 "configure"
+#line 6866 "configure"
 #include "confdefs.h"
 #include <sys/time.h>
 EOF
@@ -6706,7 +6873,7 @@
 else
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 6710 "configure"
+#line 6877 "configure"
 #include "confdefs.h"
 #include <time.h>
 EOF
@@ -6736,12 +6903,12 @@
 
 
 echo $ac_n "checking for the existence of strsignal""... $ac_c" 1>&6
-echo "configure:6740: checking for the existence of strsignal" >&5
+echo "configure:6907: checking for the existence of strsignal" >&5
 if eval "test \"`echo '$''{'bash_cv_have_strsignal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6745 "configure"
+#line 6912 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -6749,7 +6916,7 @@
 char *s = (char *)strsignal(2);
 ; return 0; }
 EOF
-if { (eval echo configure:6753: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6920: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_have_strsignal=yes
 else
@@ -6770,7 +6937,7 @@
 fi
 
 echo $ac_n "checking if opendir() opens non-directories""... $ac_c" 1>&6
-echo "configure:6774: checking if opendir() opens non-directories" >&5
+echo "configure:6941: checking if opendir() opens non-directories" >&5
 if eval "test \"`echo '$''{'bash_cv_opendir_not_robust'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6780,7 +6947,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 6784 "configure"
+#line 6951 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -6822,7 +6989,7 @@
 exit (dir == 0);
 }
 EOF
-if { (eval echo configure:6826: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6993: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_opendir_not_robust=yes
 else
@@ -6845,7 +7012,7 @@
 fi
 
 echo $ac_n "checking for declaration of printf in <stdio.h>""... $ac_c" 1>&6
-echo "configure:6849: checking for declaration of printf in <stdio.h>" >&5
+echo "configure:7016: checking for declaration of printf in <stdio.h>" >&5
 if eval "test \"`echo '$''{'bash_cv_printf_declared'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6855,7 +7022,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 6859 "configure"
+#line 7026 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -6872,7 +7039,7 @@
 }
 
 EOF
-if { (eval echo configure:6876: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7043: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_printf_declared=yes
 else
@@ -6895,7 +7062,7 @@
 fi
 
 echo $ac_n "checking whether ulimit can substitute for getdtablesize""... $ac_c" 1>&6
-echo "configure:6899: checking whether ulimit can substitute for getdtablesize" >&5
+echo "configure:7066: checking whether ulimit can substitute for getdtablesize" >&5
 if eval "test \"`echo '$''{'bash_cv_ulimit_maxfds'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6905,7 +7072,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 6909 "configure"
+#line 7076 "configure"
 #include "confdefs.h"
 
 main()
@@ -6915,7 +7082,7 @@
 }
 
 EOF
-if { (eval echo configure:6919: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7086: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_ulimit_maxfds=yes
 else
@@ -6938,7 +7105,7 @@
 fi
 
 echo $ac_n "checking to see if getenv can be redefined""... $ac_c" 1>&6
-echo "configure:6942: checking to see if getenv can be redefined" >&5
+echo "configure:7109: checking to see if getenv can be redefined" >&5
 if eval "test \"`echo '$''{'bash_cv_getenv_redef'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6948,7 +7115,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 6952 "configure"
+#line 7119 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_UNISTD_H
@@ -6983,7 +7150,7 @@
 }
 
 EOF
-if { (eval echo configure:6987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7154: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_getenv_redef=yes
 else
@@ -7006,7 +7173,7 @@
 fi
 
 echo $ac_n "checking if getcwd() calls popen()""... $ac_c" 1>&6
-echo "configure:7010: checking if getcwd() calls popen()" >&5
+echo "configure:7177: checking if getcwd() calls popen()" >&5
 if eval "test \"`echo '$''{'bash_cv_getcwd_calls_popen'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7016,7 +7183,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7020 "configure"
+#line 7187 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -7071,7 +7238,7 @@
 }
 
 EOF
-if { (eval echo configure:7075: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7242: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_getcwd_calls_popen=no
 else
@@ -7094,12 +7261,12 @@
 fi
 
 echo $ac_n "checking for declaration of sbrk in <unistd.h>""... $ac_c" 1>&6
-echo "configure:7098: checking for declaration of sbrk in <unistd.h>" >&5
+echo "configure:7265: checking for declaration of sbrk in <unistd.h>" >&5
 if eval "test \"`echo '$''{'bash_cv_sbrk_declared'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7103 "configure"
+#line 7270 "configure"
 #include "confdefs.h"
 #include <unistd.h>
 EOF
@@ -7125,7 +7292,7 @@
 
 
 echo $ac_n "checking for presence of POSIX-style sigsetjmp/siglongjmp""... $ac_c" 1>&6
-echo "configure:7129: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
+echo "configure:7296: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
 if eval "test \"`echo '$''{'bash_cv_func_sigsetjmp'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7135,7 +7302,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7139 "configure"
+#line 7306 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_UNISTD_H
@@ -7176,7 +7343,7 @@
 #endif
 }
 EOF
-if { (eval echo configure:7180: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7347: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_func_sigsetjmp=present
 else
@@ -7200,7 +7367,7 @@
 
 
 echo $ac_n "checking whether or not strcoll and strcmp differ""... $ac_c" 1>&6
-echo "configure:7204: checking whether or not strcoll and strcmp differ" >&5
+echo "configure:7371: checking whether or not strcoll and strcmp differ" >&5
 if eval "test \"`echo '$''{'bash_cv_func_strcoll_broken'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7210,7 +7377,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7214 "configure"
+#line 7381 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -7249,7 +7416,7 @@
 }
 
 EOF
-if { (eval echo configure:7253: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7420: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_func_strcoll_broken=yes
 else
@@ -7275,7 +7442,7 @@
 
 
 echo $ac_n "checking if signal handlers must be reinstalled when invoked""... $ac_c" 1>&6
-echo "configure:7279: checking if signal handlers must be reinstalled when invoked" >&5
+echo "configure:7446: checking if signal handlers must be reinstalled when invoked" >&5
 if eval "test \"`echo '$''{'bash_cv_must_reinstall_sighandlers'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7285,7 +7452,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7289 "configure"
+#line 7456 "configure"
 #include "confdefs.h"
 
 #include <signal.h>
@@ -7332,7 +7499,7 @@
 }
 
 EOF
-if { (eval echo configure:7336: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7503: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_must_reinstall_sighandlers=no
 else
@@ -7356,7 +7523,7 @@
 
 
 echo $ac_n "checking for presence of necessary job control definitions""... $ac_c" 1>&6
-echo "configure:7360: checking for presence of necessary job control definitions" >&5
+echo "configure:7527: checking for presence of necessary job control definitions" >&5
 if eval "test \"`echo '$''{'bash_cv_job_control_missing'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7366,7 +7533,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7370 "configure"
+#line 7537 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7413,7 +7580,7 @@
 exit(0);
 }
 EOF
-if { (eval echo configure:7417: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7584: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_job_control_missing=present
 else
@@ -7436,7 +7603,7 @@
 fi
 
 echo $ac_n "checking for presence of named pipes""... $ac_c" 1>&6
-echo "configure:7440: checking for presence of named pipes" >&5
+echo "configure:7607: checking for presence of named pipes" >&5
 if eval "test \"`echo '$''{'bash_cv_sys_named_pipes'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7446,7 +7613,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7450 "configure"
+#line 7617 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7487,7 +7654,7 @@
 exit(0);
 }
 EOF
-if { (eval echo configure:7491: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7658: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_sys_named_pipes=present
 else
@@ -7511,12 +7678,12 @@
 
 
 echo $ac_n "checking for TIOCGWINSZ in sys/ioctl.h""... $ac_c" 1>&6
-echo "configure:7515: checking for TIOCGWINSZ in sys/ioctl.h" >&5
+echo "configure:7682: checking for TIOCGWINSZ in sys/ioctl.h" >&5
 if eval "test \"`echo '$''{'bash_cv_tiocgwinsz_in_ioctl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7520 "configure"
+#line 7687 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -7524,7 +7691,7 @@
 int x = TIOCGWINSZ;
 ; return 0; }
 EOF
-if { (eval echo configure:7528: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7695: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_tiocgwinsz_in_ioctl=yes
 else
@@ -7545,12 +7712,12 @@
 fi
 
 echo $ac_n "checking for TIOCSTAT in sys/ioctl.h""... $ac_c" 1>&6
-echo "configure:7549: checking for TIOCSTAT in sys/ioctl.h" >&5
+echo "configure:7716: checking for TIOCSTAT in sys/ioctl.h" >&5
 if eval "test \"`echo '$''{'bash_cv_tiocstat_in_ioctl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7554 "configure"
+#line 7721 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -7558,7 +7725,7 @@
 int x = TIOCSTAT;
 ; return 0; }
 EOF
-if { (eval echo configure:7562: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7729: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_tiocstat_in_ioctl=yes
 else
@@ -7579,12 +7746,12 @@
 fi
 
 echo $ac_n "checking for FIONREAD in sys/ioctl.h""... $ac_c" 1>&6
-echo "configure:7583: checking for FIONREAD in sys/ioctl.h" >&5
+echo "configure:7750: checking for FIONREAD in sys/ioctl.h" >&5
 if eval "test \"`echo '$''{'bash_cv_fionread_in_ioctl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7588 "configure"
+#line 7755 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -7592,7 +7759,7 @@
 int x = FIONREAD;
 ; return 0; }
 EOF
-if { (eval echo configure:7596: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7763: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_fionread_in_ioctl=yes
 else
@@ -7614,19 +7781,19 @@
 
 
 echo $ac_n "checking for speed_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:7618: checking for speed_t in sys/types.h" >&5
+echo "configure:7785: checking for speed_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'bash_cv_speed_t_in_sys_types'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7623 "configure"
+#line 7790 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 int main() {
 speed_t x;
 ; return 0; }
 EOF
-if { (eval echo configure:7630: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7797: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_speed_t_in_sys_types=yes
 else
@@ -7647,12 +7814,12 @@
 fi
 
 echo $ac_n "checking whether getpw functions are declared in pwd.h""... $ac_c" 1>&6
-echo "configure:7651: checking whether getpw functions are declared in pwd.h" >&5
+echo "configure:7818: checking whether getpw functions are declared in pwd.h" >&5
 if eval "test \"`echo '$''{'bash_cv_getpw_declared'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7656 "configure"
+#line 7823 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7683,7 +7850,7 @@
 fi
 
 echo $ac_n "checking for unusable real-time signals due to large values""... $ac_c" 1>&6
-echo "configure:7687: checking for unusable real-time signals due to large values" >&5
+echo "configure:7854: checking for unusable real-time signals due to large values" >&5
 if eval "test \"`echo '$''{'bash_cv_unusable_rtsigs'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7693,7 +7860,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7697 "configure"
+#line 7864 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7715,7 +7882,7 @@
   exit(rtmin < n_sigs);
 }
 EOF
-if { (eval echo configure:7719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7886: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_unusable_rtsigs=yes
 else
@@ -7740,12 +7907,12 @@
 
 case "$host_os" in
 hpux*)	echo $ac_n "checking whether $host_os needs _KERNEL for RLIMIT defines""... $ac_c" 1>&6
-echo "configure:7744: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
+echo "configure:7911: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
 if eval "test \"`echo '$''{'bash_cv_kernel_rlimit'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7749 "configure"
+#line 7916 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7758,7 +7925,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:7762: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7929: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_kernel_rlimit=no
 else
@@ -7766,7 +7933,7 @@
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 7770 "configure"
+#line 7937 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7781,7 +7948,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:7785: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7952: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_kernel_rlimit=yes
 else
@@ -7815,14 +7982,14 @@
 _bash_needmsg=yes
 else
 echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
-echo "configure:7819: checking which library has the termcap functions" >&5
+echo "configure:7986: checking which library has the termcap functions" >&5
 _bash_needmsg=
 fi
 if eval "test \"`echo '$''{'bash_cv_termcap_lib'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
-echo "configure:7826: checking for tgetent in -ltermcap" >&5
+echo "configure:7993: checking for tgetent in -ltermcap" >&5
 ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7830,7 +7997,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ltermcap  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7834 "configure"
+#line 8001 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7841,7 +8008,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:7845: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:8012: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7860,7 +8027,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
-echo "configure:7864: checking for tgetent in -lcurses" >&5
+echo "configure:8031: checking for tgetent in -lcurses" >&5
 ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7868,7 +8035,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7872 "configure"
+#line 8039 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7879,7 +8046,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:7883: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:8050: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7898,7 +8065,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
-echo "configure:7902: checking for tgetent in -lncurses" >&5
+echo "configure:8069: checking for tgetent in -lncurses" >&5
 ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7906,7 +8073,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lncurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7910 "configure"
+#line 8077 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7917,7 +8084,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:7921: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:8088: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7946,7 +8113,7 @@
 
 if test "X$_bash_needmsg" = "Xyes"; then
 echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
-echo "configure:7950: checking which library has the termcap functions" >&5
+echo "configure:8117: checking which library has the termcap functions" >&5
 fi
 echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
 if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
@@ -7969,7 +8136,7 @@
 
 
 echo $ac_n "checking whether /dev/fd is available""... $ac_c" 1>&6
-echo "configure:7973: checking whether /dev/fd is available" >&5
+echo "configure:8140: checking whether /dev/fd is available" >&5
 if eval "test \"`echo '$''{'bash_cv_dev_fd'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -8005,7 +8172,7 @@
 fi
 
 echo $ac_n "checking whether /dev/stdin stdout stderr are available""... $ac_c" 1>&6
-echo "configure:8009: checking whether /dev/stdin stdout stderr are available" >&5
+echo "configure:8176: checking whether /dev/stdin stdout stderr are available" >&5
 if eval "test \"`echo '$''{'bash_cv_dev_stdin'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -8028,7 +8195,7 @@
 fi
 
 echo $ac_n "checking for default mail directory""... $ac_c" 1>&6
-echo "configure:8032: checking for default mail directory" >&5
+echo "configure:8199: checking for default mail directory" >&5
 if eval "test \"`echo '$''{'bash_cv_mail_dir'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -8164,7 +8331,7 @@
 if test "$ac_cv_func_dlopen" = "yes" && test -f ${srcdir}/support/shobj-conf
 then
 	echo $ac_n "checking shared object configuration for loadable builtins""... $ac_c" 1>&6
-echo "configure:8168: checking shared object configuration for loadable builtins" >&5
+echo "configure:8335: checking shared object configuration for loadable builtins" >&5
 	eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c "${host_cpu}" -o "${host_os}" -v "${host_vendor}"`
 	
 	
diff -ruN bash-2.05.orig/configure.in bash-2.05/configure.in
--- bash-2.05.orig/configure.in	Wed Jan 24 02:57:24 2001
+++ bash-2.05/configure.in	Wed Jun 20 16:04:41 2001
@@ -484,6 +484,21 @@
 AC_CHECK_HEADERS(libintl.h)
 AC_CHECK_FUNCS(gettext textdomain bindtextdomain)
 
+dnl checks for multibyte handling capability
+AC_CHECK_HEADERS(wctype.h)
+AC_CHECK_HEADERS(wchar.h)
+AC_CHECK_FUNC(mbsrtowcs,AC_DEFINE(HAVE_MBSRTOWCS),)
+AC_TRY_RUN([
+#include <wchar.h>
+
+int
+main ()
+{
+  mbstate_t ps;
+  return 0;
+}],
+AC_DEFINE(HAVE_MBSTATE_T),)
+
 dnl check for GNU libintl if gettext/textdomain/bindtextdomain
 dnl are not found in libc
 if test "$ac_cv_func_bindtextdomain" = "no"; then
diff -ruN bash-2.05.orig/execute_cmd.c bash-2.05/execute_cmd.c
--- bash-2.05.orig/execute_cmd.c	Fri Mar 23 00:17:23 2001
+++ bash-2.05/execute_cmd.c	Wed Jun 20 16:42:54 2001
@@ -75,6 +75,7 @@
 #include "trap.h"
 #include "pathexp.h"
 #include "hashcmd.h"
+#include "xstrchr.h"
 
 #if defined (COND_COMMAND)
 #  include "test.h"
@@ -864,16 +865,16 @@
 
 /* Interpret the format string FORMAT, interpolating the following escape
    sequences:
-   		%[prec][l][RUS]
+		%[prec][l][RUS]
 
    where the optional `prec' is a precision, meaning the number of
    characters after the decimal point, the optional `l' means to format
    using minutes and seconds (MMmNN[.FF]s), like the `times' builtin',
    and the last character is one of
    
-  		R	number of seconds of `real' time
-  		U	number of seconds of `user' time
-  		S	number of seconds of `system' time
+		R	number of seconds of `real' time
+		U	number of seconds of `user' time
+		S	number of seconds of `system' time
 
    An occurrence of `%%' in the format string is translated to a `%'.  The
    result is printed to FP, a pointer to a FILE.  The other variables are
@@ -3121,7 +3122,7 @@
   pathname = words->word->word;
 
 #if defined (RESTRICTED_SHELL)
-  if (restricted && strchr (pathname, '/'))
+  if (restricted && xstrchr ((const char *)pathname, '/'))
     {
       internal_error ("%s: restricted: cannot specify `/' in command names",
 		    pathname);
@@ -3534,7 +3535,7 @@
 
   fd_table_size = getdtablesize ();
   if (fd_table_size > 256)	/* clamp to a reasonable value */
-  	fd_table_size = 256;
+	fd_table_size = 256;
 
   for (i = 3; i < fd_table_size; i++)
     close (i);
diff -ruN bash-2.05.orig/general.c bash-2.05/general.c
--- bash-2.05.orig/general.c	Thu Mar  1 03:23:24 2001
+++ bash-2.05/general.c	Mon Apr 16 20:50:58 2001
@@ -40,6 +40,7 @@
 #include <tilde/tilde.h>
 
 #include "maxpath.h"
+#include "xstrchr.h"
 
 #if !defined (errno)
 extern int errno;
@@ -458,7 +459,7 @@
 absolute_program (string)
      char *string;
 {
-  return ((char *)strchr (string, '/') != (char *)NULL);
+  return ((char *)xstrchr ((const char *)string, '/') != (char *)NULL);
 }
 
 /* Return the `basename' of the pathname in STRING (the stuff after the
diff -ruN bash-2.05.orig/general.h bash-2.05/general.h
--- bash-2.05.orig/general.h	Thu Feb 15 06:53:05 2001
+++ bash-2.05/general.h	Mon Apr 16 20:50:58 2001
@@ -71,7 +71,7 @@
 #endif
 
 #ifndef member
-#  define member(c, s) ((c) ? ((char *)strchr ((s), (c)) != (char *)NULL) : 0)
+#  define member(c, s) ((c) ? ((char *)xstrchr ((const char *)(s), (c)) != (char *)NULL) : 0)
 #endif
 
 #ifndef whitespace
diff -ruN bash-2.05.orig/lib/glob/Makefile.in bash-2.05/lib/glob/Makefile.in
--- bash-2.05.orig/lib/glob/Makefile.in	Thu Aug  5 23:52:57 1999
+++ bash-2.05/lib/glob/Makefile.in	Mon Apr 16 12:10:15 2001
@@ -62,12 +62,12 @@
 LIBRARY_NAME = libglob.a
 
 # The C code source files for this library.
-CSOURCES = $(srcdir)/glob.c $(srcdir)/fnmatch.c
+CSOURCES = $(srcdir)/glob.c $(srcdir)/fnmatch.c $(srcdir)/xmbsrtowcs.c
 
 # The header files for this library.
 HSOURCES = $(srcdir)/fnmatch.h
 
-OBJECTS = glob.o fnmatch.o
+OBJECTS = glob.o fnmatch.o xmbsrtowcs.o
 
 # The texinfo files which document this library.
 DOCSOURCE = doc/glob.texi
@@ -129,6 +129,10 @@
 glob.o: $(BASHINCDIR)/posixstat.h $(BASHINCDIR)/memalloc.h
 glob.o: fnmatch.h
 
+xmbsrtowcs.o: $(BUILD_DIR)/config.h
+xmbsrtowcs.o: xmbsrtowcs.h
+
 # Rules for deficient makes, like SunOS and Solaris
 fnmatch.o: fnmatch.c
 glob.o: glob.c
+xmbsrtowcs.o: xmbsrtowcs.c
diff -ruN bash-2.05.orig/lib/glob/collsyms.h bash-2.05/lib/glob/collsyms.h
--- bash-2.05.orig/lib/glob/collsyms.h	Thu Aug  5 20:56:04 1999
+++ bash-2.05/lib/glob/collsyms.h	Thu Jan 17 17:29:25 2002
@@ -9,121 +9,120 @@
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any later
    version.
-              
+	      
    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
-                         
+			 
    You should have received a copy of the GNU General Public License along
    with Bash; see the file COPYING.  If not, write to the Free Software
    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 
-#ifndef _COLLSYMS_H_
-#  define _COLLSYSMS_H_
-
 /* The upper-case letters, lower-case letters, and digits are omitted from
    this table.  The digits are not included in the table in the POSIX.2
    spec.  The upper and lower case letters are translated by the code
    in fnmatch.c:collsym(). */
 
-typedef struct _collsym {
-  char *name;
-  char code;
-} COLLSYM;
+typedef struct _COLLSYM {
+  CHAR *name;
+  CHAR code;
+} __COLLSYM;
 
-static COLLSYM posix_collsyms[] =
+static __COLLSYM POSIXCOLL [] =
 {
-  "NUL",	'\0',
-  "SOH",	'\001',
-  "STX",	'\002',
-  "ETX",	'\003',
-  "EOT",	'\004',
-  "ENQ",	'\005',
-  "ACK",	'\006',
+  {L("NUL"),		L('\0')},
+  {L("SOH"),		L('\001')},
+  {L("STX"),		L('\002')},
+  {L("ETX"),		L('\003')},
+  {L("EOT"),		L('\004')},
+  {L("ENQ"),		L('\005')},
+  {L("ACK"),		L('\006')},
 #ifdef __STDC__
-  "alert",	'\a',
+  {L("alert"),		L('\a')},
 #else
-  "alert",	'\007',
+  {L("alert"),		L('\007')},
 #endif
-  "backspace",	'\b',
-  "tab",	'\t',
-  "newline",	'\n',
-  "vertical-tab",	'\v',
-  "form-feed",	'\f',
-  "carriage-return",	'\r',
-  "SO",		'\016',
-  "SI",		'\017',
-  "DLE",	'\020',
-  "DC1",	'\021',
-  "DC2",	'\022',
-  "DC3",	'\023',
-  "DC4",	'\024',
-  "NAK",	'\025',
-  "SYN",	'\026',
-  "ETB",	'\027',
-  "CAN",	'\030',
-  "EM",		'\031',
-  "SUB",	'\032',
-  "ESC",	'\033',
-  "IS4",	'\034',
-  "IS3",	'\035',
-  "IS2",	'\036',
-  "IS1",	'\037',
-  "space",		' ',
-  "exclamation-mark",	'!',
-  "quotation-mark",	'"',
-  "number-sign",	'#',
-  "dollar-sign",	'$',
-  "percent-sign",	'%',
-  "ampersand",		'&',
-  "apostrophe",		'\'',
-  "left-parenthesis",	'(',
-  "right-parenthesis",	')',
-  "asterisk",	'*',
-  "plus-sign",	'+',
-  "comma",	',',
-  "hyphen",	'-',
-  "minus",	'-',		/* extension from POSIX.2 */
-  "dash",	'-',		/* extension from POSIX.2 */
-  "period",	'.',
-  "slash",	'/',
-  "solidus",	'/',		/* extension from POSIX.2 */
-  "zero",	'0',
-  "one",	'1',
-  "two",	'2',
-  "three",	'3',
-  "four",	'4',
-  "five",	'5',
-  "six",	'6',
-  "seven",	'7',
-  "eight",	'8',
-  "nine",	'9',
-  "colon",	':',
-  "semicolon",	';',
-  "less-than-sign",	'<',
-  "equals-sign",	'=',
-  "greater-than-sign",	'>',
-  "question-mark",	'?',
-  "commercial-at",	'@',
+  {L("backspace"),	L('\b')},
+  {L("tab"),		L('\t')},
+  {L("newline"),		L('\n')},
+  {L("vertical-tab"),	L('\v')},
+  {L("form-feed"),	L('\f')},
+  {L("carriage-return"),	L('\r')},
+  {L("SO"),		L('\016')},
+  {L("SI"),		L('\017')},
+  {L("DLE"),		L('\020')},
+  {L("DC1"),		L('\021')},
+  {L("DC2"),		L('\022')},
+  {L("DC3"),		L('\023')},
+  {L("DC4"),		L('\024')},
+  {L("NAK"),		L('\025')},
+  {L("SYN"),		L('\026')},
+  {L("ETB"),		L('\027')},
+  {L("CAN"),		L('\030')},
+  {L("EM"),		L('\031')},
+  {L("SUB"),		L('\032')},
+  {L("ESC"),		L('\033')},
+  {L("IS4"),		L('\034')},
+  {L("IS3"),		L('\035')},
+  {L("IS2"),		L('\036')},
+  {L("IS1"),		L('\037')},
+  {L("space"),		L(' ')},
+  {L("exclamation-mark"),	L('!')},
+  {L("quotation-mark"),	L('"')},
+  {L("number-sign"),	L('#')},
+  {L("dollar-sign"),	L('$')},
+  {L("percent-sign"),	L('%')},
+  {L("ampersand"),	L('&')},
+  {L("apostrophe"),	L('\'')},
+  {L("left-parenthesis"),	L('(')},
+  {L("right-parenthesis"),	L(')')},
+  {L("asterisk"),	L('*')},
+  {L("plus-sign"),	L('+')},
+  {L("comma"),		L(',')},
+  {L("hyphen"),		L('-')},
+  {L("minus"),		L('-')},	/* extension from POSIX.2 */
+  {L("dash"),		L('-')},	/* extension from POSIX.2 */
+  {L("period"),		L('.')},
+  {L("slash"),		L('/')},
+  {L("solidus"),	L('/')},	/* extension from POSIX.2 */
+  {L("zero"),		L('0')},
+  {L("one"),		L('1')},
+  {L("two"),		L('2')},
+  {L("three"),		L('3')},
+  {L("four"),		L('4')},
+  {L("five"),		L('5')},
+  {L("six"),		L('6')},
+  {L("seven"),		L('7')},
+  {L("eight"),		L('8')},
+  {L("nine"),		L('9')},
+  {L("colon"),		L(':')},
+  {L("semicolon"),	L(';')},
+  {L("less-than-sign"),	L('<')},
+  {L("equals-sign"),	L('=')},
+  {L("greater-than-sign"),	L('>')},
+  {L("question-mark"),	L('?')},
+  {L("commercial-at"),	L('@')},
   /* upper-case letters omitted */
-  "left-square-bracket",'[',
-  "backslash",		'\\',
-  "reverse-solidus",	'\\',
-  "right-square-bracket",	']',
-  "circumflex",		'^',
-  "circumflex-accent",	'^',		/* extension from POSIX.2 */
-  "underscore",		'_',
-  "grave-accent",		'`',
+  {L("left-square-bracket")	,L('[')},
+  {L("backslash"),		L('\\')},
+  {L("reverse-solidus"),		L('\\')},
+  {L("right-square-bracket"),	L(']')},
+  {L("circumflex"),		L('^')},
+  {L("circumflex-accent"),	L('^')},	/* extension from POSIX.2 */
+  {L("underscore"),		L('_')},
+  {L("grave-accent"),		L('`')},
   /* lower-case letters omitted */
-  "left-brace",		'{',		/* extension from POSIX.2 */
-  "left-curly-bracket",	'{',
-  "vertical-line",	'|',
-  "right-brace",		'}',	/* extension from POSIX.2 */
-  "right-curly-bracket",	'}',
-  "tilde",		'~',
-  "DEL",	'\177',
-  0,	0,
+  {L("left-brace"),		L('{')},	/* extension from POSIX.2 */
+  {L("left-curly-bracket"),	L('{')},
+  {L("vertical-line"),		L('|')},
+  {L("right-brace"),		L('}')},	/* extension from POSIX.2 */
+  {L("right-curly-bracket"),	L('}')},
+  {L("tilde"),		L('~')},
+  {L("DEL"),		L('\177')},
+  {0,	0}
 };
 
-#endif
+#undef _COLLSYM
+#undef __COLLSYM
+#undef POSIXCOLL
diff -ruN bash-2.05.orig/lib/glob/fnmatch.c bash-2.05/lib/glob/fnmatch.c
--- bash-2.05.orig/lib/glob/fnmatch.c	Sat Mar 17 03:24:27 2001
+++ bash-2.05/lib/glob/fnmatch.c	Thu Jan 17 17:29:25 2002
@@ -1,5 +1,5 @@
 /* fnmatch.c -- ksh-like extended pattern matching for the shell and filename
-		globbing. */
+                globbing. */
 
 /* Copyright (C) 1991, 1997 Free Software Foundation, Inc.
 
@@ -9,12 +9,12 @@
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any later
    version.
-	      
+
    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
-			 
+
    You should have received a copy of the GNU General Public License along
    with Bash; see the file COPYING.  If not, write to the Free Software
    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
@@ -22,64 +22,50 @@
 #include <config.h>
 
 #include <stdio.h>	/* for debugging */
-				
+
 #include "fnmatch.h"
-#include "collsyms.h"
+#include <errno.h>
 #include <ctype.h>
 
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
 #if defined (HAVE_STRING_H)
-#  include <string.h>
+# include <string.h>
 #else
-#  include <strings.h>
+# include <strings.h>
 #endif /* HAVE_STRING_H */
 
-static int gmatch ();
-static char *brackmatch ();
-#ifdef EXTENDED_GLOB
-static int extmatch ();
-static char *patscan ();
-#endif
-  
-#if !defined (isascii)
-#  define isascii(c)	((unsigned int)(c) <= 0177)
-#endif
-
-/* Note that these evaluate C many times.  */
-
-#ifndef isblank
-#  define isblank(c)	((c) == ' ' || (c) == '\t')
-#endif
-
-#ifndef isgraph
-#  define isgraph(c)	((c) != ' ' && isprint((c)))
-#endif
-
-#ifndef isxdigit
-#  define isxdigit(c)	(((c) >= '0' && (c) <= '9') || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+#ifndef errno
+extern int errno;
 #endif
 
-/* The result of FOLD is an `unsigned char' */
-# define FOLD(c) ((flags & FNM_CASEFOLD) && isupper ((unsigned char)c) \
-	? tolower ((unsigned char)c) \
-	: ((unsigned char)c))
+/* For unibyte characters. */
+#define CHAR	unsigned char   
+#define INT	int
+#define L(CS)	CS
+#define INVALID	EOF
 
-#ifndef STREQ
+#undef STREQ
+#undef STREQN
 #define STREQ(a, b) ((a)[0] == (b)[0] && strcmp(a, b) == 0)
 #define STREQN(a, b, n) ((a)[0] == (b)[0] && strncmp(a, b, n) == 0)
-#endif
 
-/* We use strcoll(3) for range comparisons in bracket expressions,
+/* Helper function for range expression.
+   We use strcoll(3) for range comparisons in bracket expressions,
    even though it can have unwanted side effects in locales
    other than POSIX or US.  For instance, in the de locale, [A-Z] matches
    all characters. */
 
 #if defined (HAVE_STRCOLL)
-/* Helper function for collating symbol equivalence. */
 static int rangecmp (c1, c2)
      int c1, c2;
 {
-  static char s1[2] = { ' ', '\0' };
-  static char s2[2] = { ' ', '\0' };
+  unsigned char s1[2] = { ' ', '\0' };
+  unsigned char s2[2] = { ' ', '\0' };
   int ret;
 
   /* Eight bits only.  Period. */
@@ -96,23 +82,26 @@
     return ret;
   return (c1 - c2);
 }
-#else /* !HAVE_STRCOLL */
-#  define rangecmp(c1, c2)	((int)(c1) - (int)(c2))
-#endif /* !HAVE_STRCOLL */
-
-#if defined (HAVE_STRCOLL)
-static int collequiv (c1, c2)
-     int c1, c2;
+#else	/* !HAVE_STRCOLL */
+#  define rangecmp(c1, c2)      ((int)(c1) - (int)(c2))
+#endif  /* !HAVE_STRCOLL */
+
+/* Helper function for equivalence class. (But no API for judging this now.) */
+static int collequiv (c, equiv)
+     int c, equiv;
 {
-  return (rangecmp (c1, c2) == 0);
+  return (c == equiv);
 }
-#else
-#  define collequiv(c1, c2)	((c1) == (c2))
-#endif
+
+/* Helper function for collation symbol. */
+#define _COLLSYM  _collsym
+#define __COLLSYM __collsym
+#define POSIXCOLL posix_collsyms
+#include "collsyms.h"
 
 static int
 collsym (s, len)
-     char *s;
+     unsigned char *s;
      int len;
 {
   register struct _collsym *csp;
@@ -124,699 +113,307 @@
     }
   if (len == 1)
     return s[0];
-  return -1;
+  return INVALID;
 }
 
-int
-fnmatch (pattern, string, flags)
-     char *pattern;
-     char *string;
-     int flags;
-{
-  char *se, *pe;
-
-  if (string == 0 || pattern == 0)
-    return FNM_NOMATCH;
+/* unibyte character classification */
+#if !defined isascii
+# define isascii(c)    ((unsigned int)(c) <= 0177)
+#endif
 
-  se = string + strlen (string);
-  pe = pattern + strlen (pattern);
+#ifndef isblank
+#  define isblank(c)    ((c) == ' ' || (c) == '\t')
+#endif
 
-  return (gmatch (string, se, pattern, pe, flags));
-}
+#ifndef isgraph
+#  define isgraph(c)    ((c) != ' ' && isprint((c)))
+#endif
 
-/* Match STRING against the filename pattern PATTERN, returning zero if
-   it matches, FNM_NOMATCH if not.  */
-static int
-gmatch (string, se, pattern, pe, flags)
-     char *string, *se;
-     char *pattern, *pe;
-     int flags;
-{
-  register char *p, *n;		/* pattern, string */
-  register char c;		/* current pattern character */
-  register char sc;		/* current string character */
-
-  p = pattern;
-  n = string;
-
-  if (string == 0 || pattern == 0)
-    return FNM_NOMATCH;
-
-#if DEBUG_MATCHING
-fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
-fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
+#ifndef isxdigit
+#  define isxdigit(c)   (((c) >= '0' && (c) <= '9') || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
 #endif
 
-  while (p < pe)
-    {
-      c = *p++;
-      c = FOLD (c);
+enum Char_class
+  {
+    CC_NO_CLASS = 0,
+    CC_ASCII, CC_ALNUM, CC_ALPHA, CC_BLANK, CC_CNTRL, CC_DIGIT, CC_GRAPH,
+    CC_LOWER, CC_PRINT, CC_PUNCT, CC_SPACE, CC_UPPER, CC_XDIGIT
+  };
+
+static char const *const char_class_name[] =
+  {
+    "",
+    "ascii", "alnum", "alpha", "blank", "cntrl", "digit", "graph",
+    "lower", "print", "punct", "space", "upper", "xdigit" 
+  };
 
-      sc = n < se ? *n : '\0';
+static int
+is_char_class (c, name)
+     int c;
+     const char *name;
+{
+  enum Char_class char_class = CC_NO_CLASS;
+  int i, result;
 
-#ifdef EXTENDED_GLOB
-      /* extmatch () will handle recursively calling gmatch, so we can
-	 just return what extmatch() returns. */
-      if ((flags & FNM_EXTMATCH) && *p == '(' &&
-	  (c == '+' || c == '*' || c == '?' || c == '@' || c == '!')) /* ) */
-	{
-	  int lflags;
-	  /* If we're not matching the start of the string, we're not
-	     concerned about the special cases for matching `.' */
-	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
-	  return (extmatch (c, n, se, p, pe, lflags));
-	}
-#endif
+  for (i = 1; i < (sizeof(char_class_name) / sizeof (char_class_name[0])); i++)
+    if (strcmp ((const char *)name, char_class_name[i]) == 0)
+      {
+        char_class = (enum Char_class)i;
+	break;
+      }
 
-      switch (c)
-	{
-	case '?':		/* Match single character */
-	  if (sc == '\0')
-	    return FNM_NOMATCH;
-	  else if ((flags & FNM_PATHNAME) && sc == '/')
-	    /* If we are matching a pathname, `?' can never match a `/'. */
-	    return FNM_NOMATCH;
-	  else if ((flags & FNM_PERIOD) && sc == '.' &&
-		   (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
-	    /* `?' cannot match a `.' if it is the first character of the
-	       string or if it is the first character following a slash and
-	       we are matching a pathname. */
-	    return FNM_NOMATCH;
-	  break;
-
-	case '\\':		/* backslash escape removes special meaning */
-	  if (p == pe)
-	    return FNM_NOMATCH;
-
-	  if ((flags & FNM_NOESCAPE) == 0)
-	    {
-	      c = *p++;
-	      /* A trailing `\' cannot match. */
-	      if (p > pe)
-		return FNM_NOMATCH;
-	      c = FOLD (c);
-	    }
-	  if (FOLD (sc) != (unsigned char)c)
-	    return FNM_NOMATCH;
-	  break;
-
-	case '*':		/* Match zero or more characters */
-	  if (p == pe)
-	    return 0;
-	  
-	  if ((flags & FNM_PERIOD) && sc == '.' &&
-	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
-	    /* `*' cannot match a `.' if it is the first character of the
-	       string or if it is the first character following a slash and
-	       we are matching a pathname. */
-	    return FNM_NOMATCH;
-
-	  /* Collapse multiple consecutive, `*' and `?', but make sure that
-	     one character of the string is consumed for each `?'. */
-	  for (c = *p++; (c == '?' || c == '*'); c = *p++)
-	    {
-	      if ((flags & FNM_PATHNAME) && sc == '/')
-		/* A slash does not match a wildcard under FNM_PATHNAME. */
-		return FNM_NOMATCH;
-	      else if (c == '?')
-		{
-		  if (sc == '\0')
-		    return FNM_NOMATCH;
-		  /* One character of the string is consumed in matching
-		     this ? wildcard, so *??? won't match if there are
-		     fewer than three characters. */
-		  n++;
-		  sc = n < se ? *n : '\0';
-		}
-
-#ifdef EXTENDED_GLOB
-	      /* Handle ******(patlist) */
-	      if ((flags & FNM_EXTMATCH) && c == '*' && *p == '(')  /*)*/
-		{
-		  char *newn;
-		  /* We need to check whether or not the extended glob
-		     pattern matches the remainder of the string.
-		     If it does, we match the entire pattern. */
-		  for (newn = n; newn < se; ++newn)
-		    {
-		      if (extmatch (c, newn, se, p, pe, flags) == 0)
-			return (0);
-		    }
-		  /* We didn't match the extended glob pattern, but
-		     that's OK, since we can match 0 or more occurrences.
-		     We need to skip the glob pattern and see if we
-		     match the rest of the string. */
-		  newn = patscan (p + 1, pe, 0);
-		  p = newn;
-		}
-#endif
-	      if (p == pe)
-		break;
-	    }
-
-	  /* If we've hit the end of the pattern and the last character of
-	     the pattern was handled by the loop above, we've succeeded.
-	     Otherwise, we need to match that last character. */
-	  if (p == pe && (c == '?' || c == '*'))
-	    return (0);
-
-	  /* General case, use recursion. */
-	  {
-	    unsigned char c1;
-
-	    c1 = (unsigned char)((flags & FNM_NOESCAPE) == 0 && c == '\\') ? *p : c;
-	    c1 = FOLD (c1);
-	    for (--p; n < se; ++n)
-	      {
-		/* Only call fnmatch if the first character indicates a
-		   possible match.  We can check the first character if
-		   we're not doing an extended glob match. */
-		if ((flags & FNM_EXTMATCH) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
-		  continue;
-
-		/* If we're doing an extended glob match and the pattern is not
-		   one of the extended glob patterns, we can check the first
-		   character. */
-		if ((flags & FNM_EXTMATCH) && p[1] != '(' && /*)*/
-		    strchr ("?*+@!", *p) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
-		  continue;
-
-		/* Otherwise, we just recurse. */
-		if (gmatch (n, se, p, pe, flags & ~FNM_PERIOD) == 0)
-		  return (0);
-	      }
-	    return FNM_NOMATCH;
-	  }
-
-	case '[':
-	  {
-	    if (sc == '\0' || n == se)
-	      return FNM_NOMATCH;
-
-	    /* A character class cannot match a `.' if it is the first
-	       character of the string or if it is the first character
-	       following a slash and we are matching a pathname. */
-	    if ((flags & FNM_PERIOD) && sc == '.' &&
-		(n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
-	      return (FNM_NOMATCH);
-
-	    p = brackmatch (p, sc, flags);
-	    if (p == 0)
-	      return FNM_NOMATCH;
-	  }
-	  break;
-
-	default:
-	  if ((unsigned char)c != FOLD (sc))
-	    return (FNM_NOMATCH);
-	}
+  if (!char_class)
+    return -1;
 
-      ++n;
+  switch (char_class)
+    {
+      case CC_ASCII:
+	result = isascii (c);
+	break;
+      case CC_ALNUM:
+	result = isalnum (c);
+	break;
+      case CC_ALPHA:
+	result = isalpha (c);
+	break;
+      case CC_BLANK:
+	result = isblank (c);
+	break;
+      case CC_CNTRL:
+	result = iscntrl (c);
+	break;
+      case CC_DIGIT:
+	result = isdigit (c);
+	break;
+      case CC_GRAPH:
+	result = isgraph (c);
+	break;
+      case CC_LOWER:
+	result = islower (c);
+	break;
+      case CC_PRINT:
+	result = isprint (c);
+	break;
+      case CC_PUNCT:
+	result = ispunct (c);
+	break;
+      case CC_SPACE:
+	result = isspace (c);
+	break;
+      case CC_UPPER:
+	result = isupper (c);
+	break;
+      case CC_XDIGIT:
+	result = isxdigit (c);
+	break;
+      default:
+	result = -1;
+	break;
     }
+  return result;
+}
 
-  if (n == se)
-    return (0);
+/* Now include "fnmatch_loop.c" for unibyte characters. */
+#define FOLD(c) ((flags & FNM_CASEFOLD) && isupper (c) ? tolower (c) : (c))
+#define FCT			internal_fnmatch
+#define GMATCH			gmatch
+#define COLLSYM			collsym
+#define PARSE_COLLSYM		parse_collsym
+#define BRACKMATCH		brackmatch
+#define PATSCAN			patscan
+#define STRCOMPARE		strcompare
+#define EXTMATCH		extmatch
+#define STRCHR(S, C)		strchr (S, C)
+#define STRCOLL(S1, S2)		strcoll (S1, S2)
+#define STRLEN(S)		strlen(S)
+#define STRCMP(S1, S2)		strcmp(S1, S2)
+#define RANGECMP(C1, C2)	rangecmp(C1, C2)
+#define COLLEQUIV(C1, C2)	collequiv (C1, C2)
+#define CTYPE_T			enum Char_class
+#define IS_CHAR_CLASS(C, S)	is_char_class(C, S)
+#include "fnmatch_loop.c"
+
+/* Compile `fnmatch_loop.c' again for multibyte characters. */
+#if HANDLE_MULTIBYTE
+# include "xmbsrtowcs.h"
+
+# define L(CS)	 L##CS
+# define CHAR	 wchar_t
+# define INT	 wint_t
+# define INVALID WEOF
+
+# undef STREQ
+# undef STREQN
+# define STREQ(s1, s2) ((wcscmp (s1, s2) == 0))
+# define STREQN(a, b, n) ((a)[0] == (b)[0] && wcsncmp(a, b, n) == 0)
+
+/* Helper function for range expression. */
+static int rangecmp_wc (c1, c2)
+     wint_t c1, c2;
+{
+  wchar_t s1[2] = { L' ', L'\0' };
+  wchar_t s2[2] = { L' ', L'\0' };
 
-  if ((flags & FNM_LEADING_DIR) && *n == '/')
-    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
+  if (c1 == c2)
     return 0;
-	  
-  return (FNM_NOMATCH);
-}
 
-/* Parse a bracket expression collating symbol ([.sym.]) starting at P, find
-   the value of the symbol, and move P past the collating symbol expression.
-   The value is returned in *VP, if VP is not null. */
-static char *
-parse_collsym (p, vp)
-     char *p;
-     int *vp;
-{
-  register int pc;
-  int val;
+  s1[0] = c1;
+  s2[0] = c2;
 
-  p++;				/* move past the `.' */
-	  
-  for (pc = 0; p[pc]; pc++)
-    if (p[pc] == '.' && p[pc+1] == ']')
-      break;
-   val = collsym (p, pc);
-   if (vp)
-     *vp = val;
-   return (p + pc + 2);
+  return (wcscoll (s1, s2));
 }
 
-static char *
-brackmatch (p, test, flags)
-     char *p;
-     unsigned char test;
-     int flags;
+/* Helper function for equivalence class. (But no API for judging this now.) */
+static int collequiv_wc (c, equiv)
+     wint_t c, equiv;
 {
-  register char cstart, cend, c;
-  register int not;    /* Nonzero if the sense of the character class is inverted.  */
-  int pc, brcnt;
-  char *savep;
-
-  test = FOLD (test);
-
-  savep = p;
-
-  /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
-     circumflex (`^') in its role in a `nonmatching list'.  A bracket
-     expression starting with an unquoted circumflex character produces
-     unspecified results.  This implementation treats the two identically. */
-  if (not = (*p == '!' || *p == '^'))
-    ++p;
-
-  c = *p++;
-  for (;;)
-    {
-      /* Initialize cstart and cend in case `-' is the last
-	 character of the pattern. */
-      cstart = cend = c;
-
-      /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
-	 the end of the equivalence class, move the pattern pointer past
-	 it, and check for equivalence.  XXX - this handles only
-	 single-character equivalence classes, which is wrong, or at
-	 least incomplete. */
-      if (c == '[' && *p == '=' && p[2] == '=' && p[3] == ']')
-	{
-	  pc = FOLD (p[1]);
-	  p += 4;
-	  if (collequiv (test, pc))
-	    {
-/*[*/	      /* Move past the closing `]', since the first thing we do at
-		 the `matched:' label is back p up one. */
-	      p++;
-	      goto matched;
-	    }
-	  else
-	    {
-	      c = *p++;
-	      if (c == '\0')
-		return ((test == '[') ? savep : (char *)0); /*]*/
-	      c = FOLD (c);
-	      continue;
-	    }
-	}
-
-      /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
-      if (c == '[' && *p == ':')	/*]*/
-	{
-	  pc = 0;	/* make sure invalid char classes don't match. */
-	  if (STREQN (p+1, "alnum:]", 7))
-	    { pc = isalnum (test); p += 8; }
-	  else if (STREQN (p+1, "alpha:]", 7))
-	    { pc = isalpha (test); p += 8; }
-	  else if (STREQN (p+1, "blank:]", 7))
-	    { pc = isblank (test); p += 8; }
-	  else if (STREQN (p+1, "cntrl:]", 7))
-	    { pc = iscntrl (test); p += 8; }
-	  else if (STREQN (p+1, "digit:]", 7))
-	    { pc = isdigit (test); p += 8; }
-	  else if (STREQN (p+1, "graph:]", 7))
-	    { pc = isgraph (test); p += 8; }
-	  else if (STREQN (p+1, "lower:]", 7))
-	    { pc = islower (test); p += 8; }
-	  else if (STREQN (p+1, "print:]", 7))
-	    { pc = isprint (test); p += 8; }
-	  else if (STREQN (p+1, "punct:]", 7))
-	    { pc = ispunct (test); p += 8; }
-	  else if (STREQN (p+1, "space:]", 7))
-	    { pc = isspace (test); p += 8; }
-	  else if (STREQN (p+1, "upper:]", 7))
-	    { pc = isupper (test); p += 8; }
-	  else if (STREQN (p+1, "xdigit:]", 8))
-	    { pc = isxdigit (test); p += 9; }
-	  else if (STREQN (p+1, "ascii:]", 7))
-	    { pc = isascii (test); p += 8; }
-	  if (pc)
-	    {
-/*[*/	      /* Move past the closing `]', since the first thing we do at
-		 the `matched:' label is back p up one. */
-	      p++;
-	      goto matched;
-	    }
-	  else
-	    {
-	      /* continue the loop here, since this expression can't be
-		 the first part of a range expression. */
-	      c = *p++;
-	      if (c == '\0')
-		return ((test == '[') ? savep : (char *)0);
-	      else if (c == ']')
-		break;
-	      c = FOLD (c);
-	      continue;
-	    }
-	}
- 
-      /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
-	 the symbol name, make sure it is terminated by `.]', translate
-	 the name to a character using the external table, and do the
-	 comparison. */
-      if (c == '[' && *p == '.')
-	{
-	  p = parse_collsym (p, &pc);
-	  /* An invalid collating symbol cannot be the first point of a
-	     range.  If it is, we set cstart to one greater than `test',
-	     so any comparisons later will fail. */
-	  cstart = (pc == -1) ? test + 1 : pc;
-	}
-
-      if (!(flags & FNM_NOESCAPE) && c == '\\')
-	{
-	  if (*p == '\0')
-	    return (char *)0;
-	  cstart = cend = *p++;
-	}
-
-      cstart = cend = FOLD (cstart);
-
-      /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
-	 is not preceded by a backslash and is not part of a bracket
-	 expression produces undefined results.'  This implementation
-	 treats the `[' as just a character to be matched if there is
-	 not a closing `]'. */
-      if (c == '\0')
-	return ((test == '[') ? savep : (char *)0);
-
-      c = *p++;
-      c = FOLD (c);
-
-      if ((flags & FNM_PATHNAME) && c == '/')
-	/* [/] can never match when matching a pathname.  */
-	return (char *)0;
-
-      /* This introduces a range, unless the `-' is the last
-	 character of the class.  Find the end of the range
-	 and move past it. */
-      if (c == '-' && *p != ']')
-	{
-	  cend = *p++;
-	  if (!(flags & FNM_NOESCAPE) && cend == '\\')
-	    cend = *p++;
-	  if (cend == '\0')
-	    return (char *)0;
-	  if (cend == '[' && *p == '.')
-	    {
-	      p = parse_collsym (p, &pc);
-	      /* An invalid collating symbol cannot be the second part of a
-		 range expression.  If we get one, we set cend to one fewer
-		 than the test character to make sure the range test fails. */
-	      cend = (pc == -1) ? test - 1 : pc;
-	    }
-	  cend = FOLD (cend);
-
-	  c = *p++;
-
-	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
-	     equal to or higher than the starting range point; otherwise
-	     the expression shall be treated as invalid.''  Note that this
-	     applies to only the range expression; the rest of the bracket
-	     expression is still checked for matches. */
-	  if (rangecmp (cstart, cend) > 0)
-	    {
-	      if (c == ']')
-		break;
-	      c = FOLD (c);
-	      continue;
-	    }
-	}
-
-      if (rangecmp (test, cstart) >= 0 && rangecmp (test, cend) <= 0)
-	goto matched;
+  return (!(c - equiv));
+}
 
-      if (c == ']')
-	break;
-    }
-  /* No match. */
-  return (!not ? (char *)0 : p);
+/* Helper function for collating symbol. */
+# define _COLLSYM  _collwcsym
+# define __COLLSYM __collwcsym
+# define POSIXCOLL posix_collwcsyms
+# include "collsyms.h"
+static wint_t
+collwcsym (s, len)
+     wchar_t *s;
+     int len;
+{
+  struct _collwcsym *csp;
 
-matched:
-  /* Skip the rest of the [...] that already matched.  */
-#if 0
-  brcnt = (c != ']') + (c == '[' && (*p == '=' || *p == ':' || *p == '.'));
-#else
-  c = *--p;
-  brcnt = 1;
-#endif
-  while (brcnt > 0)
+  for (csp = posix_collwcsyms; csp->name; csp++)
     {
-      /* A `[' without a matching `]' is just another character to match. */
-      if (c == '\0')
-	return ((test == '[') ? savep : (char *)0);
-
-      c = *p++;
-      if (c == '[' && (*p == '=' || *p == ':' || *p == '.'))
-	brcnt++;
-      else if (c == ']')
-	brcnt--;
-      else if (!(flags & FNM_NOESCAPE) && c == '\\')
-	{
-	  if (*p == '\0')
-	    return (char *)0;
-	  /* XXX 1003.2d11 is unclear if this is right. */
-	  ++p;
-	}
+      if (STREQN(csp->name, s, len) && csp->name[len] == L'\0')
+	return (csp->code);
     }
-  return (not ? (char *)0 : p);
+  if (len == 1)
+    return s[0];
+  return INVALID;
 }
 
-#if defined (EXTENDED_GLOB)
-/* ksh-like extended pattern matching:
-
-	[?*+@!](pat-list)
-
-   where pat-list is a list of one or patterns separated by `|'.  Operation
-   is as follows:
-
-	?(patlist)	match zero or one of the given patterns
-	*(patlist)	match zero or more of the given patterns
-	+(patlist)	match one or more of the given patterns
-	@(patlist)	match exactly one of the given patterns
-	!(patlist)	match anything except one of the given patterns
-*/
-
-/* Scan a pattern starting at STRING and ending at END, keeping track of
-   embedded () and [].  If DELIM is 0, we scan until a matching `)'
-   because we're scanning a `patlist'.  Otherwise, we scan until we see
-   DELIM.  In all cases, we never scan past END.  The return value is the
-   first character after the matching DELIM. */
-static char *
-patscan (string, end, delim)
-     char *string, *end;
-     int delim;
+/* wide character classification. */
+static int
+is_wchar_class (wc, name)
+wint_t wc;
+wchar_t *name;
 {
-  int pnest, bnest, cchar;
-  char *s, c, *bfirst;
+  char *mbs;
+  mbstate_t state;
+  size_t mbslength;
+  wctype_t desc;
+
+  /* [[:ascii:] is bash ordinary character class. */
+  if (wctype("ascii") == (wctype_t)0)
+    if (wcscmp(name, L"ascii") == 0)
+      {
+	int c;
+	
+	if ((c = wctob (wc)) == EOF)
+	  return 0;
+        else
+          return(c <= 0x7F);
+      }
 
-  pnest = bnest = cchar = 0;
-  bfirst = 0;
-  for (s = string; c = *s; s++)
+  memset (&state, '\0', sizeof (mbstate_t));
+  mbs = (char *) malloc (wcslen(name) * MB_CUR_MAX + 1);
+
+  mbslength = wcsrtombs(mbs, (const wchar_t **)&name,
+			 (wcslen(name) * MB_CUR_MAX + 1), &state);
+  
+  if (mbslength == (size_t)-1 || mbslength == (size_t)-2)
     {
-      if (s >= end)
-	return (s);
-      switch (c)
-	{
-	case '\0':
-	  return ((char *)0);
-
-	/* `[' is not special inside a bracket expression, but it may
-	   introduce one of the special POSIX bracket expressions
-	   ([.SYM.], [=c=], [: ... :]) that needs special handling. */
-	case '[':
-	  if (bnest == 0)
-	    {
-	      bfirst = s + 1;
-	      if (*bfirst == '!' || *bfirst == '^')
-		bfirst++;
-	      bnest++;
-	    }
-	  else if (s[1] == ':' || s[1] == '.' || s[1] == '=')
-	    cchar = s[1];
-	  break;
-
-	/* `]' is not special if it's the first char (after a leading `!'
-	   or `^') in a bracket expression or if it's part of one of the
-	   special POSIX bracket expressions ([.SYM.], [=c=], [: ... :]) */
-	case ']':
-	  if (bnest)
-	    {
-	      if (cchar && s[-1] == cchar)
-		cchar = 0;
-	      else if (s != bfirst)
-		{
-		  bnest--;
-		  bfirst = 0;
-		}
-	    }
-	  break;
-
-	case '(':
-	  if (bnest == 0)
-	    pnest++;
-	  break;
-
-	case ')':
-#if 0
-	  if (bnest == 0)
-	    pnest--;
-	  if (pnest <= 0)
-	    return ++s;
-#else
-	  if (bnest == 0 && pnest-- <= 0)
-	    return ++s;
-#endif
-	  break;
+      free (mbs);
+      return -1;
+    }
 
-	case '|':
-	  if (bnest == 0 && pnest == 0 && delim == '|')
-	    return ++s;
-	  break;
-	}
+  desc = wctype(mbs);
+  if (desc == (wctype_t)0)
+    {
+      free (mbs);
+      return -1;
     }
 
-  return (char *)0;
+  free (mbs);
+  return (iswctype(wc, desc));
 }
 
-/* Return 0 if dequoted pattern matches S in the current locale. */
-static int
-strcompare (p, pe, s, se)
-     char *p, *pe, *s, *se;
-{
-  int ret;
-  char c1, c2;
 
-  c1 = *pe;
-  c2 = *se;
+/* Now include "fnmatch_loop.c" for multibyte characters. */
+# define FOLD(c) ((flags & FNM_CASEFOLD) && iswupper (c) ? towlower (c) : (c))
+# define FCT			internal_fnwmatch
+# define GMATCH			gmatch_wc
+# define COLLSYM		collwcsym
+# define PARSE_COLLSYM		parse_collwcsym
+# define BRACKMATCH		brackmatch_wc
+# define PATSCAN		patscan_wc
+# define STRCOMPARE		wcscompare
+# define EXTMATCH		extmatch_wc
+# define STRCHR(S, C)		wcschr (S, C)
+# define STRCOLL(S1, S2) 	wcscoll (S1, S2)
+# define STRLEN(S)		wcslen(S)
+# define STRCMP(S1, S2)		wcscmp(S1, S2)
+# define RANGECMP(c1, c2)	rangecmp_wc(c1, c2)
+# define COLLEQUIV(c1, c2)	collequiv_wc (c1, c2)
+# define IS_CHAR_CLASS(C, S)	is_wchar_class(C, S)
 
-  *pe = *se = '\0';
-#if defined (HAVE_STRCOLL)
-  ret = strcoll (p, s);
-#else
-  ret = strcmp (p, s);
+# include "fnmatch_loop.c"
 #endif
 
-  *pe = c1;
-  *se = c2;
-
-  return (ret == 0 ? ret : FNM_NOMATCH);
-}
-
-/* Match a ksh extended pattern specifier.  Return FNM_NOMATCH on failure or
-   0 on success.  This is handed the entire rest of the pattern and string
-   the first time an extended pattern specifier is encountered, so it calls
-   gmatch recursively. */
-static int
-extmatch (xc, s, se, p, pe, flags)
-     int xc;		/* select which operation */
-     char *s, *se;
-     char *p, *pe;
+int
+fnmatch (pattern, string, flags)
+     char *pattern;
+     char *string;
      int flags;
 {
-  char *prest;			/* pointer to rest of pattern */
-  char *psub;			/* pointer to sub-pattern */
-  char *pnext;			/* pointer to next sub-pattern */
-  char *srest;			/* pointer to rest of string */
-  int m1, m2;
-
-#if DEBUG_MATCHING
-fprintf(stderr, "extmatch: xc = %c\n", xc);
-fprintf(stderr, "extmatch: s = %s; se = %s\n", s, se);
-fprintf(stderr, "extmatch: p = %s; pe = %s\n", p, pe);
-#endif
+#if HANDLE_MULTIBYTE
+  int ret;
+  size_t wcs_len, wcs_max;
+  mbstate_t state;
+  char *ps;
+  wchar_t *wpattern;
+  wchar_t *wstring;
+
+  if (MB_CUR_MAX == 1)
+    /* This is an optimization for 8-bit character set.  */
+    return internal_fnmatch (pattern, string, flags);
+
+  ps = pattern;
+  wcs_max = strlen (pattern) + 1;
+  memset (&state, '\0', sizeof (mbstate_t));
+  wpattern = malloc (wcs_max * sizeof (wchar_t));
+  wcs_len = xmbsrtowcs (wpattern, (const char **)&ps, wcs_max, &state);
 
-  prest = patscan (p + (*p == '('), pe, 0); /* ) */
-  if (prest == 0)
-    /* If PREST is 0, we failed to scan a valid pattern.  In this
-       case, we just want to compare the two as strings. */
-    return (strcompare (p - 1, pe, s, se));
+  if (wcs_len == (size_t)-1)
+    {
+      /* Invalide sequence, just try as is */
+      free (wpattern);
+      return internal_fnmatch (pattern, string, flags);
+    }
 
-  switch (xc)
+  ps = string;
+  wcs_max = strlen (string) + 1;
+  memset (&state, '\0', sizeof (mbstate_t));
+  wstring = malloc (wcs_max * sizeof (wchar_t));
+  wcs_len = xmbsrtowcs (wstring, (const char **)&ps, wcs_max, &state);
+  if (wcs_len == (size_t)-1)
     {
-    case '+':			/* match one or more occurrences */
-    case '*':			/* match zero or more occurrences */
-      /* If we can get away with no matches, don't even bother.  Just
-	 call gmatch on the rest of the pattern and return success if
-	 it succeeds. */
-      if (xc == '*' && (gmatch (s, se, prest, pe, flags) == 0))
-	return 0;
-
-      /* OK, we have to do this the hard way.  First, we make sure one of
-	 the subpatterns matches, then we try to match the rest of the
-	 string. */
-      for (psub = p + 1; ; psub = pnext)
-	{
-	  pnext = patscan (psub, pe, '|');
-	  for (srest = s; srest <= se; srest++)
-	    {
-	      /* Match this substring (S -> SREST) against this
-		 subpattern (psub -> pnext - 1) */
-	      m1 = gmatch (s, srest, psub, pnext - 1, flags) == 0;
-	      /* OK, we matched a subpattern, so make sure the rest of the
-		 string matches the rest of the pattern.  Also handle
-		 multiple matches of the pattern. */
-	      if (m1)
-		m2 = (gmatch (srest, se, prest, pe, flags) == 0) ||
-		      (s != srest && gmatch (srest, se, p - 1, pe, flags) == 0);
-	      if (m1 && m2)
-		return (0);
-	    }
-	  if (pnext == prest)
-	    break;
-	}
-      return (FNM_NOMATCH);
-
-    case '?':		/* match zero or one of the patterns */
-    case '@':		/* match exactly one of the patterns */
-      /* If we can get away with no matches, don't even bother.  Just
-	 call gmatch on the rest of the pattern and return success if
-	 it succeeds. */
-      if (xc == '?' && (gmatch (s, se, prest, pe, flags) == 0))
-	return 0;
-
-      /* OK, we have to do this the hard way.  First, we see if one of
-	 the subpatterns matches, then, if it does, we try to match the
-	 rest of the string. */
-      for (psub = p + 1; ; psub = pnext)
-	{
-	  pnext = patscan (psub, pe, '|');
-	  srest = (prest == pe) ? se : s;
-	  for ( ; srest <= se; srest++)
-	    {
-	      if (gmatch (s, srest, psub, pnext - 1, flags) == 0 &&
-		  gmatch (srest, se, prest, pe, flags) == 0)
-		return (0);
-	    }
-	  if (pnext == prest)
-	    break;
-	}
-      return (FNM_NOMATCH);
-
-    case '!':		/* match anything *except* one of the patterns */
-      for (srest = s; srest <= se; srest++)
-	{
-	  m1 = 0;
-	  for (psub = p + 1; ; psub = pnext)
-	    {
-	      pnext = patscan (psub, pe, '|');
-	      /* If one of the patterns matches, just bail immediately. */
-	      if (m1 = (gmatch (s, srest, psub, pnext - 1, flags) == 0))
-		break;
-	      if (pnext == prest)
-		break;
-	    }
-	  if (m1 == 0 && gmatch (srest, se, prest, pe, flags) == 0)
-	    return (0);
-	}
-      return (FNM_NOMATCH);
+      /* Invalide sequence, just try as is  */
+      free (wpattern);
+      free (wstring);
+      return internal_fnmatch (pattern, string, flags);
     }
 
-  return (FNM_NOMATCH);
+  ret = internal_fnwmatch (wpattern, wstring, flags);
+
+  free (wpattern);
+  free (wstring);
+  
+  return (ret);
+#else
+  return internal_fnmatch (pattern, string, flags);
+#endif
 }
-#endif /* EXTENDED_GLOB */
 
 #ifdef TEST
 main (c, v)
diff -ruN bash-2.05.orig/lib/glob/fnmatch.h bash-2.05/lib/glob/fnmatch.h
--- bash-2.05.orig/lib/glob/fnmatch.h	Thu Aug  5 20:56:38 1999
+++ bash-2.05/lib/glob/fnmatch.h	Wed Jun 20 14:46:03 2001
@@ -23,26 +23,27 @@
 
 /* We #undef these before defining them because some losing systems
    (HP-UX A.08.07 for example) define these in <unistd.h>.  */
-#undef  FNM_PATHNAME
-#undef  FNM_NOESCAPE
-#undef  FNM_PERIOD
+#undef	FNM_PATHNAME
+#undef	FNM_NOESCAPE
+#undef	FNM_PERIOD
 
 /* Bits set in the FLAGS argument to `fnmatch'.  */
 /* standard flags */
 #define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
 #define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
 #define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
+#define FNM_FILE_NAME	 FNM_PATHNAME	/* Preferred GNU name.  */
 
 /* extended flags */
-#define FNM_LEADING_DIR	(1 << 3) /* Ignore `/...' after a match. */
-#define FNM_CASEFOLD	(1 << 4) /* Compare without regard to case. */
-#define FNM_EXTMATCH	(1 << 5) /* Use ksh-like extended matching. */
+#define FNM_LEADING_DIR (1 << 3)	/* Ignore `/...' after a match.  */
+#define FNM_CASEFOLD	(1 << 4)	/* Compare without regard to case.  */
+#define FNM_EXTMATCH    (1 << 5) /* Use ksh-like extended matching. */
 
 /* Value returned by `fnmatch' if STRING does not match PATTERN.  */
 #define	FNM_NOMATCH	1
 
-/* Match STRING against the filename pattern PATTERN,
+/* Match NAME against the filename pattern PATTERN,
    returning zero if it matches, FNM_NOMATCH if not.  */
-extern int fnmatch __P((char *, char *, int));
+extern int fnmatch __P ((char *__pattern, char *__name, int __flags));
 
-#endif /* _FNMATCH_H */
+#endif /* fnmatch.h */
diff -ruN bash-2.05.orig/lib/glob/fnmatch_loop.c bash-2.05/lib/glob/fnmatch_loop.c
--- bash-2.05.orig/lib/glob/fnmatch_loop.c	Thu Jan  1 09:00:00 1970
+++ bash-2.05/lib/glob/fnmatch_loop.c	Thu Jun 21 20:11:22 2001
@@ -0,0 +1,724 @@
+static int FCT (CHAR *pattern, CHAR *string, int flags);
+static int GMATCH(CHAR *string, CHAR *se, CHAR *pattern, CHAR *pe, int flags);
+static CHAR *PARSE_COLLSYM (CHAR *p, INT *vp);
+static CHAR *BRACKMATCH (CHAR *p, INT test, int flags);
+static int EXTMATCH (INT xc, CHAR *s, CHAR *se, CHAR *p, CHAR *pe, int flags);
+static CHAR *PATSCAN (CHAR *string, CHAR *end, INT delim);
+
+static int
+FCT (pattern, string, flags)
+     CHAR *pattern;
+     CHAR *string;
+     int flags;
+{
+  CHAR *se, *pe;
+
+  if (string == 0 || pattern == 0)
+    return FNM_NOMATCH;
+
+  se = string + STRLEN (string);
+  pe = pattern + STRLEN (pattern);
+
+  return (GMATCH (string, se, pattern, pe, flags));
+}
+
+/* Match STRING against the filename pattern PATTERN, returning zero if
+   it matches, nonzero if not.  */
+
+static int
+GMATCH (string, se, pattern, pe, flags)
+    CHAR *string, *se;
+    CHAR *pattern, *pe;
+    int flags;
+{
+  CHAR *p, *n;		/* pattern, string */
+  INT c;		/* current pattern character */
+  INT sc;		/* current string character */
+
+  p = pattern;
+  n = string;
+
+  if (string == 0 || pattern == 0)
+    return FNM_NOMATCH;
+
+#if DEBUG_MATCHING
+fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
+fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
+#endif
+
+  while (p < pe)
+    {
+      c = *p++;
+      c = FOLD (c);
+
+      sc = n < se ? *n : L('\0');
+
+#ifdef EXTENDED_GLOB
+      /* EXTMATCH () will handle recursively calling GMATCH, so we can
+	 just return what EXTMATCH() returns. */
+      if ((flags & FNM_EXTMATCH) && *p == L('(') &&
+	  (c == L('+') || c == L('*') || c == L('?')
+				|| c == L('@') || c == (L('!')))) /* ) */
+	{
+	  int lflags;
+	  /* If we're not matching the start of the string, we're not
+	     concerned about the special cases for matching `.' */
+	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
+	  return (EXTMATCH (c, n, se, p, pe, lflags));
+	}
+#endif
+
+      switch (c)
+	{
+	case L('?'):		/* Match single character */
+	  if (sc == L('\0'))
+	    return FNM_NOMATCH;
+	  else if (sc == L('/') && (flags & FNM_FILE_NAME))
+	    /* If we are matching a pathname, `?' can never match a `/'. */
+	    return FNM_NOMATCH;
+	  else if (sc == L('.') && (flags & FNM_PERIOD)
+		   && (n == string
+		       || (n[-1] == L('/') && (flags & FNM_FILE_NAME))))
+	    /* `?' cannot match a `.' if it is the first character of the
+	       string or if it is the first character following a slash and
+	       we are matching a pathname. */
+	    return FNM_NOMATCH;
+	  break;
+
+	case L('\\'):		/* backslash escape removes special meaning */
+	  if (p == pe)
+	    return FNM_NOMATCH;
+
+	  if ((flags & FNM_NOESCAPE) == 0)
+	    {
+	      c = *p++;
+	      /* A trailing `\' cannot match. */
+	      if (p > pe)
+		return FNM_NOMATCH;
+	      c = FOLD (c);
+	    }
+	  if (FOLD (sc) != c)
+	    return FNM_NOMATCH;
+	  break;
+
+	case L('*'):		/* Match zero or more characters */
+	  if (p == pe)
+	    return 0;
+
+	  if (sc == L('.') && (flags & FNM_PERIOD)
+	      && (n == string
+		  || (n[-1] == L('/') && (flags & FNM_FILE_NAME))))
+	    /* `*' cannot match a `.' if it is the first character of the
+	       string or if it is the first character following a slash and
+	       we are matching a pathname. */
+	    return FNM_NOMATCH;
+
+	  /* Collapse multiple consecutive, `*' and `?', but make sure that
+	     one character of the string is consumed for each `?'. */
+	  for (c = *p++; c == L('?') || c == L('*'); c = *p++)
+	    {
+	      if (sc == L('/') && (flags & FNM_FILE_NAME))
+		/* A slash does not match a wildcard under FNM_FILE_NAME.  */
+		return FNM_NOMATCH;
+	      else if (c == L('?'))
+		{
+		  /* A ? needs to match one character.  */
+		  if (sc == L('\0'))
+		    /* There isn't another character; no match.  */
+		    return FNM_NOMATCH;
+		  else
+		    /* One character of the string is consumed in matching
+		       this ? wildcard, so *??? won't match if there are
+		       less than three characters.  */
+		    ++n;
+		    sc = n < se ? *n : '\0';
+		}
+
+#ifdef EXTENDED_GLOB
+	      /* Handle ******(patlist) */
+	      if ((flags & FNM_EXTMATCH) && c == L('*') && *p == L('('))  /*)*/
+		{
+		  CHAR *newn;
+		  /* We need to check whether or not the extended glob
+		     pattern matches the remainder of the string.
+		     If it does, we match the entire pattern. */
+		  for (newn = n; newn < se; ++newn)
+		    {
+		      if (EXTMATCH (c, newn, se, p, pe, flags) == 0)
+			return (0);
+		    }
+		  /* We didn't match the extended glob pattern, but
+		     that's OK, since we can match 0 or more occurrences.
+		     We need to skip the glob pattern and see if we
+		     match the rest of the string. */
+		  newn = PATSCAN (p + 1, pe, 0);
+		  p = newn;
+		}
+#endif
+	      if (p == pe)
+		break;
+	    }
+
+	  /* If we've hit the end of the pattern and the last character of
+	     the pattern was handled by the loop above, we've succeeded.
+	     Otherwise, we need to match that last character. */
+	  if (p == pe && (c == L('?') || c == L('*')))
+	    return (0);
+
+	  /* General case, use recursion. */
+	  {
+	    INT c1;
+
+	    c1 = ((flags & FNM_NOESCAPE) == 0 && c == L('\\')) ? *p : c;
+	    c1 = FOLD (c1);
+	    for (--p; n < se; ++n)
+	      {
+		/* Only call fnmatch if the first character indicates a
+		   possible match.  We can check the first character if
+		   we're not doing an extended glob match. */
+		if ((flags & FNM_EXTMATCH) == 0 && c != L('[') && FOLD (*n) != c1)
+		  continue;
+
+		/* If we're doing an extended glob match and the pattern is not
+		   one of the extended glob patterns, we can check the first
+		   character. */
+		if ((flags & FNM_EXTMATCH) && p[1] != L('(') && /*)*/
+		    STRCHR (L("?*+@!"), *p) == 0 && c != L('[') && FOLD (*n) != c1)
+		  continue;
+
+		/* Otherwise, we just recurse. */
+		if (GMATCH (n, se, p, pe, flags & ~FNM_PERIOD) == 0)
+		  return (0);
+	      }
+	    return FNM_NOMATCH;
+	  }
+
+	case L('['):
+	  {
+	    if (sc == L('\0') || n == se)
+	      return FNM_NOMATCH;
+
+	    /* A character class cannot match a `.' if it is the first
+	       character of the string or if it is the first character
+	       following a slash and we are matching a pathname. */
+	    if (sc == L('.') && (flags & FNM_PERIOD) &&
+		(n == string || (n[-1] == L('/') && (flags & FNM_FILE_NAME))))
+	      return FNM_NOMATCH;
+
+	    p = BRACKMATCH (p, sc, flags);
+	    if (p == 0)
+	      return FNM_NOMATCH;
+	  }
+	  break;
+
+	default:
+	  if (c != FOLD (sc))
+	    return FNM_NOMATCH;
+	}
+
+      ++n;
+    }
+
+  if (n == se)
+    return (0);
+
+  if ((flags & FNM_LEADING_DIR) && *n == L('/'))
+    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
+    return 0;
+
+  return FNM_NOMATCH;
+}
+
+/* Parse a bracket expression collating symbol ([.sym.]) starting at P, find
+   the value of the symbol, and move P past the collating symbol expression.
+   The value is returned in *VP, if VP is not null. */
+static CHAR *
+PARSE_COLLSYM (p, vp)
+     CHAR *p;
+     INT *vp;
+{
+  int pc;
+  INT val;
+
+  p++;                          /* move past the `.' */
+
+  for (pc = 0; p[pc]; pc++)
+    if (p[pc] == L('.') && p[pc+1] == L(']'))
+      break;
+   val = COLLSYM (p, pc);
+   if (vp)
+     *vp = val;
+   return (p + pc + 2);
+}
+
+static CHAR *
+BRACKMATCH (p, test, flags)
+     CHAR *p;
+     INT test;
+     int flags;
+{
+  CHAR cstart, cend, c;
+  int not; /* Nonzero if the sense of the character class is inverted.  */
+  int brcnt;
+  INT pc;
+  CHAR *savep;
+
+  test = FOLD (test);
+    
+  savep = p;
+
+  /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
+     circumflex (`^') in its role in a `nonmatching list'.  A bracket
+     expression starting with an unquoted character produces
+     unspecified results.  This implementation treats the two identically. */
+  if (not = (*p == L('!') || *p == L('^')))
+    ++p;
+
+  c = *p++;
+  for (;;)
+    {
+      /* Initialize cstart and cend in case `-' is the last
+	 character of the pattern. */
+      cstart = cend = c;
+
+      /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
+	 the end of the equivalence class, move the pattern pointer past
+	 it, and check for equivalence.  XXX - this handles only
+	 single-character equivalence classes, which is wrong, or at
+	 least incomplete. */
+      if (c == L('[') && *p == L('=') && p[2] == L('=') && p[3] == L(']'))
+	{
+	  pc = FOLD (p[1]);
+	  p += 4;
+	  if (COLLEQUIV (test, pc))
+	    {
+/*[*/         /* Move past the closing `]', since the first thing we do at
+                 the `matched:' label is back p up one. */
+	      p++;
+	      goto matched;
+	    }
+	  else
+	    {
+	      c = *p++;
+	      if (c == L('\0'))
+		return ((test == L('[')) ? savep : (CHAR *)0);	/*]*/
+	      c = FOLD (c);
+	      continue;
+	    }
+	}
+
+      /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
+      if (c == L('[') && *p == L(':'))	/*]*/
+	{
+	  CHAR *close, *connotation;
+
+	  pc = 0;
+	  for (close = p + 1; *close != L('\0'); close++)
+	    if (*close == L(':') && *(close + 1) == L(']'))
+	      break;
+
+	  if (*close != L('\0'))
+	    {
+	      connotation = (CHAR *) (malloc ((close - p) * sizeof(CHAR)));
+	      memcpy (connotation, p + 1, (close - p - 1) * sizeof(CHAR));
+	      *(connotation + (close - p - 1)) = L('\0');
+
+	      pc = IS_CHAR_CLASS (test, connotation);
+	      if (pc == -1)
+		pc = 0;
+	      else
+		p = close + 2;
+
+	      free (connotation);
+	    }
+
+	  if (pc)
+	    {
+/*[*/         /* Move past the closing `]', since the first thing we do at
+                 the `matched:' label is back p up one. */
+	      p++;
+	      goto matched;
+	    }
+	  else
+	    {
+	      /* continue the loop here, since this expression can't be
+		 the first part of a range expression. */
+	      c = *p++;
+	      if (c == L('\0'))
+		return ((test == L('[')) ? savep : (CHAR *)0);
+	      else if (c == L(']'))
+		break;
+	      c = FOLD (c);
+	      continue;
+	    }
+	}
+
+      /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
+	 the symbol name, make sure it is terminated by `.]', translate
+	 the name to a character using the external table, and do the
+	 comparison. */
+      if (c == L('[') && *p == L('.'))
+	{
+	  p = PARSE_COLLSYM (p, &pc);
+	  /* An invalid collating symbol cannot be the first point of a
+	     range.  If it is, we set cstart to one greater than `test',
+	     so any comparisons later will fail. */
+	  cstart = (pc == INVALID) ? test + 1 : pc;
+	}
+
+      if (!(flags & FNM_NOESCAPE) && c == L('\\'))
+	{
+	  if (*p == L('\0'))
+	    return (CHAR *)0;
+	  cstart = cend = *p++;
+	}
+
+      cstart = cend = FOLD (cstart);
+
+      /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
+	 is not preceded by a backslash and is not part of a bracket
+	 expression produces undefined results.'  This implementation
+	 treats the `[' as just a character to be matched if there is
+	 not a closing `]'. */
+      if (c == L('\0'))
+	return ((test == L('[')) ? savep : (CHAR *)0);
+
+      c = *p++;
+      c = FOLD (c);
+
+      if ((flags & FNM_PATHNAME) && c == L('/'))
+	/* [/] can never match when matching a pathname.  */
+	return (CHAR *)0;
+
+      /* This introduces a range, unless the `-' is the last
+	 character of the class.  Find the end of the range
+	 and move past it. */
+      if (c == L('-') && *p != L(']'))
+	{
+	  cend = *p++;
+	  if (!(flags & FNM_NOESCAPE) && cend == L('\\'))
+	    cend = *p++;
+	  if (cend == L('\0'))
+	    return (CHAR *)0;
+	  if (cend == L('[') && *p == L('.'))
+	    {
+	      p = PARSE_COLLSYM (p, &pc);
+	      /* An invalid collating symbol cannot be the second part of a
+		 range expression.  If we get one, we set cend to one fewer
+		 than the test character to make sure the range test fails. */
+	      cend = (pc == INVALID) ? test - 1 : pc;
+	    }
+	  cend = FOLD (cend);
+
+	  c = *p++;
+
+	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
+	     equal to or higher than the starting range point; otherwise
+	     the expression shall be treated as invalid.''  Note that this
+	     applies to only the range expression; the rest of the bracket
+	     expression is still checked for matches. */
+	  if (RANGECMP (cstart, cend) > 0)
+	    {
+	      if (c == L(']'))
+		break;
+	      c = FOLD (c);
+	      continue;
+	    }
+	}
+
+      if (RANGECMP (test, cstart) >= 0 && RANGECMP (test, cend) <= 0)
+	goto matched;
+
+      if (c == L(']'))
+	break;
+    }
+  /* No match. */
+  return (!not ? (CHAR *)0 : p);
+
+matched:
+  /* Skip the rest of the [...] that already matched.  */
+#if 0
+  brcnt = (c != L(']')) + (c == L('[') && (*p == L('=')
+		|| *p == L(':') || *p == L('.')));
+#else
+  c = *--p;
+  brcnt = 1;
+#endif
+  while (brcnt > 0)
+    {
+      /* A `[' without a matching `]' is just another character to match. */
+      if (c == L('\0'))
+	return ((test == L('[')) ? savep : (CHAR *)0);
+
+      c = *p++;
+      if (c == L('[') && (*p == L('=') || *p == L(':') || *p == L('.')))
+	brcnt++;
+      else if (c == L(']'))
+	brcnt--;
+      else if (!(flags & FNM_NOESCAPE) && c == L('\\'))
+	{
+	  if (*p == L('\0'))
+	    return (CHAR *)0;
+	  /* XXX 1003.2d11 is unclear if this is right. */
+	  ++p;
+	}
+    }
+  return (not ? (CHAR *)0 : p);
+}
+
+#if defined (EXTENDED_GLOB)
+/* ksh-like extended pattern matching:
+
+	[?*+@!](pat-list)
+
+   where pat-list is a list of one or patterns separated by `|'.  Operation
+   is as follows:
+
+	?(patlist)      match zero or one of the given patterns
+	*(patlist)      match zero or more of the given patterns
+	+(patlist)      match one or more of the given patterns
+	@(patlist)      match exactly one of the given patterns
+	!(patlist)      match anything except one of the given patterns
+*/
+
+/* Scan a pattern starting at STRING and ending at END, keeping track of
+   embedded () and [].  If DELIM is 0, we scan until a matching `)'
+   because we're scanning a `patlist'.  Otherwise, we scan until we see
+   DELIM.  In all cases, we never scan past END.  The return value is the
+   first character after the matching DELIM. */
+static CHAR *
+PATSCAN (string, end, delim)
+     CHAR *string, *end;
+     INT delim;
+{
+  int pnest, bnest;
+  CHAR *s, c, *bfirst;
+  INT cchar;
+
+  pnest = bnest = 0;
+  cchar = 0;
+  bfirst = NULL;
+  for (s = string; c = *s; s++)
+    {
+      if (s >= end)
+	return (s);
+      switch (c)
+	{
+	case L('\0'):
+	  return (NULL);
+
+        /* `[' is not special inside a bracket expression, but it may
+           introduce one of the special POSIX bracket expressions
+           ([.SYM.], [=c=], [: ... :]) that needs special handling. */
+	case L('['):
+	  if (bnest == 0)
+	    {
+	      bfirst = s + 1;
+	      if (*bfirst == L('!') || *bfirst == L('^'))
+		bfirst++;
+	      bnest++;
+	    }
+	  else if (s[1] == L(':') || s[1] == L('.') || s[1] == L('='))
+	    cchar = s[1];
+	  break;
+
+        /* `]' is not special if it's the first char (after a leading `!'
+           or `^') in a bracket expression or if it's part of one of the
+           special POSIX bracket expressions ([.SYM.], [=c=], [: ... :]) */
+	case L(']'):
+	  if (bnest)
+	    {
+	      if (cchar && s[-1] == cchar)
+		cchar = 0;
+	      else if (s != bfirst)
+		{
+		  bnest--;
+		  bfirst = 0;
+		}
+	    }
+	  break;
+
+	case L('('):
+	  if (bnest == 0)
+	    pnest++;
+	  break;
+
+	case L(')'):
+#if 0
+	  if (bnest == 0)
+	    pnest--;
+	  if (pnest <= 0)
+	    return ++s;
+#else
+	  if (bnest == 0 && pnest-- <= 0)
+	    return ++s;
+#endif
+	  break;
+
+	case L('|'):
+	  if (bnest == 0 && pnest == 0 && delim == L('|'))
+	    return ++s;
+	  break;
+	}
+    }
+
+  return NULL;
+}
+
+/* Return 0 if dequoted pattern matches S in the current locale. */
+static int
+STRCOMPARE (p, pe, s, se)
+     CHAR *p, *pe, *s, *se;
+{
+  int ret;
+  CHAR c1, c2;
+
+  c1 = *pe;
+  c2 = *se;
+
+  *pe = *se = L('\0');
+#if HANDLE_MULTIBYTE || defined (HAVE_STRCOLL)
+  ret = STRCOLL (p, s);
+#else
+  ret = STRCMP (p, s);
+#endif
+
+  *pe = c1;
+  *se = c2;
+
+  return (ret == 0 ? ret : FNM_NOMATCH);
+}
+
+/* Match a ksh extended pattern specifier.  Return FNM_NOMATCH on failure or
+   0 on success.  This is handed the entire rest of the pattern and string
+   the first time an extended pattern specifier is encountered, so it calls
+   GMATCH recursively. */
+static int
+EXTMATCH (xc, s, se, p, pe, flags)
+     INT xc;            /* select which operation */
+     CHAR *s, *se;
+     CHAR *p, *pe;
+     int flags;
+{
+  CHAR *prest;                  /* pointer to rest of pattern */
+  CHAR *psub;                   /* pointer to sub-pattern */
+  CHAR *pnext;                  /* pointer to next sub-pattern */
+  CHAR *srest;                  /* pointer to rest of string */
+  int m1, m2;
+
+#if DEBUG_MATCHING
+fprintf(stderr, "EXTMATCH: xc = %c\n", xc);
+fprintf(stderr, "EXTMATCH: s = %s; se = %s\n", s, se);
+fprintf(stderr, "EXTMATCH: p = %s; pe = %s\n", p, pe);
+#endif
+
+  prest = PATSCAN (p + (*p == L('(')), pe, 0); /* ) */
+  if (prest == 0)
+    /* If PREST is 0, we failed to scan a valid pattern.  In this
+       case, we just want to compare the two as strings. */
+    return (STRCOMPARE (p - 1, pe, s, se));
+
+  switch (xc)
+    {
+    case L('+'):                   /* match one or more occurrences */
+    case L('*'):                   /* match zero or more occurrences */
+      /* If we can get away with no matches, don't even bother.  Just
+	 call GMATCH on the rest of the pattern and return success if
+	 it succeeds. */
+      if (xc == L('*') && (GMATCH (s, se, prest, pe, flags) == 0))
+	return 0;
+
+      /* OK, we have to do this the hard way.  First, we make sure one of
+	 the subpatterns matches, then we try to match the rest of the
+	 string. */
+      for (psub = p + 1; ; psub = pnext)
+	{
+	  pnext = PATSCAN (psub, pe, L('|'));
+	  for (srest = s; srest <= se; srest++)
+	    {
+	      /* Match this substring (S -> SREST) against this
+		 subpattern (psub -> pnext - 1) */
+	      m1 = GMATCH (s, srest, psub, pnext - 1, flags) == 0;
+	      /* OK, we matched a subpattern, so make sure the rest of the
+		 string matches the rest of the pattern.  Also handle
+		 multiple matches of the pattern. */
+	      if (m1)
+		m2 = (GMATCH (srest, se, prest, pe, flags) == 0) ||
+		      (s != srest && GMATCH (srest, se, p - 1, pe, flags) == 0);
+	      if (m1 && m2)
+		return (0);
+	    }
+	  if (pnext == prest)
+	    break;
+	}
+      return (FNM_NOMATCH);
+
+    case L('?'):           /* match zero or one of the patterns */
+    case L('@'):           /* match exactly one of the patterns */
+      /* If we can get away with no matches, don't even bother.  Just
+	 call GMATCH on the rest of the pattern and return success if
+	 it succeeds. */
+      if (xc == L('?') && (GMATCH (s, se, prest, pe, flags) == 0))
+	return 0;
+
+      /* OK, we have to do this the hard way.  First, we see if one of
+	 the subpatterns matches, then, if it does, we try to match the
+	 rest of the string. */
+      for (psub = p + 1; ; psub = pnext)
+	{
+	  pnext = PATSCAN (psub, pe, L('|'));
+	  srest = (prest == pe) ? se : s;
+	  for ( ; srest <= se; srest++)
+	    {
+	      if (GMATCH (s, srest, psub, pnext - 1, flags) == 0 &&
+		  GMATCH (srest, se, prest, pe, flags) == 0)
+		return (0);
+	    }
+	  if (pnext == prest)
+	    break;
+	}
+      return FNM_NOMATCH;
+
+    case L('!'):           /* match anything *except* one of the patterns */
+      for (srest = s; srest <= se; srest++)
+	{
+	  m1 = 0;
+	  for (psub = p + 1; ; psub = pnext)
+	    {
+	      pnext = PATSCAN (psub, pe, L('|'));
+	      /* If one of the patterns matches, just bail immediately. */
+	      if (m1 = (GMATCH (s, srest, psub, pnext - 1, flags) == 0))
+		break;
+	      if (pnext == prest)
+		break;
+	    }
+	  if (m1 == 0 && GMATCH (srest, se, prest, pe, flags) == 0)
+	    return (0);
+	}
+      return (FNM_NOMATCH);
+    }
+
+  return (FNM_NOMATCH);
+}
+#endif /* EXTENDED_GLOB */
+
+#undef IS_CHAR_CLASS
+#undef FOLD
+#undef CHAR
+#undef INT
+#undef INVALID
+#undef FCT
+#undef GMATCH
+#undef COLLSYM
+#undef PARSE_COLLSYM
+#undef PATSCAN
+#undef STRCOMPARE
+#undef EXTMATCH
+#undef BRACKMATCH
+#undef STRCHR
+#undef STRCOLL
+#undef STRLEN
+#undef STRCMP
+#undef COLLEQUIV
+#undef RANGECMP
+#undef L
diff -ruN bash-2.05.orig/lib/glob/glob.c bash-2.05/lib/glob/glob.c
--- bash-2.05.orig/lib/glob/glob.c	Thu Feb 15 06:53:39 2001
+++ bash-2.05/lib/glob/glob.c	Thu Jan 17 17:29:25 2002
@@ -128,46 +128,54 @@
 /* Global variable to return to signify an error in globbing. */
 char *glob_error_return;
 
+/* Compile `glob_loop.c' for unibyte characters. */
+#define CHAR    unsigned char
+#define INT     int
+#define L(CS)   CS
+#define INTERNAL_GLOB_PATTERN_P internal_glob_pattern_p
+#include "glob_loop.c"
+
+/* Compile 'glob_loop.c' again for multibyte characters. */
+#if HANDLE_MULTIBYTE
+# include "xmbsrtowcs.h"
+
+# define L(CS)   L##CS
+# define CHAR    wchar_t
+# define INT     wint_t
+# define INTERNAL_GLOB_PATTERN_P internal_glob_wpattern_p
+# include "glob_loop.c"
+#endif
+
 /* Return nonzero if PATTERN has any special globbing chars in it.  */
 int
 glob_pattern_p (pattern)
      char *pattern;
 {
-  register char *p;
-  register char c;
-  int bopen;
-
-  p = pattern;
-  bopen = 0;
-
-  while ((c = *p++) != '\0')
-    switch (c)
-      {
-      case '?':
-      case '*':
-	return (1);
-
-      case '[':		/* Only accept an open brace if there is a close */
-	bopen++;	/* brace to match it.  Bracket expressions must be */
-	continue;	/* complete, according to Posix.2 */
-      case ']':
-	if (bopen)
-	  return (1);
-	continue;      
-
-      case '+':		/* extended matching operators */
-      case '@':
-      case '!':
-	if (*p == '(')	/*) */
-	  return (1);
-	continue;
-
-      case '\\':
-	if (*p++ == '\0')
-	  return (0);
-      }
-
-  return (0);
+#if HANDLE_MULTIBYTE
+  size_t str_len, str_max;
+  char *ps;
+  mbstate_t pstate;
+  wchar_t *wpattern;
+
+  if (MB_CUR_MAX == 1)
+    /* This is an optimization for 8-bit character set.  */
+    return internal_glob_pattern_p (pattern);
+
+  /* Convert the strings into wide characters.  */
+  ps = pattern;
+  str_max = strlen (pattern) + 1;
+  memset (&pstate, '\0', sizeof (mbstate_t));
+  wpattern = (wchar_t *) alloca (str_max * sizeof (wchar_t));
+  str_len = xmbsrtowcs (wpattern, (const char **)&ps, str_max, &pstate);
+  if (str_len == (size_t)-1)
+    /* Something wrong. */
+    /* Invalide sequence, just try as is */
+    return internal_glob_pattern_p (pattern);
+
+  return internal_glob_wpattern_p (wpattern);
+#else
+  return internal_glob_pattern_p (pattern);
+#endif
 }
 
 /* Remove backslashes quoting characters in PATHNAME by modifying PATHNAME. */
@@ -175,23 +183,60 @@
 dequote_pathname (pathname)
      char *pathname;
 {
-  register int i, j;
+#if HANDLE_MULTIBYTE
+  if (MB_CUR_MAX > 1)
+    {
+      mbstate_t pstate;
+      size_t str_len, str_max;
+      wchar_t *wpathname;
+      char *ps;
+      int i, j;
+
+      /* Convert the strings into wide characters.  */
+      ps = pathname;
+      str_max = strlen (pathname) + 1;
+      memset (&pstate, '\0', sizeof (mbstate_t));
+      wpathname = (wchar_t *) alloca (str_max * sizeof (wchar_t));
+      str_len = xmbsrtowcs (wpathname, (const char **)&ps, str_max, &pstate);
+      if (str_len == (size_t) -1)
+	/* Something wrong. */
+	return;
+
+      for (i = j = 0; wpathname && wpathname[i]; )
+	{
+	  if (wpathname[i] == L'\\')
+	    i++;
+
+	  wpathname[j++] = wpathname[i++];
 
-  for (i = j = 0; pathname && pathname[i]; )
+	  if (!wpathname[i - 1])
+	    break;
+	}
+      wpathname[j] = L'\0';
+
+      /* Convert the wide character string into unibyte character set. */
+      memset (&pstate, '\0', sizeof(mbstate_t));
+      wcsrtombs (pathname, (const wchar_t **)&wpathname, str_max, &pstate);
+    }
+  else
+#endif
     {
-      if (pathname[i] == '\\')
-	i++;
+      register int i, j;
+
+      for (i = j = 0; pathname && pathname[i]; )
+	{
+	  if (pathname[i] == '\\')
+	    i++;
 
-      pathname[j++] = pathname[i++];
+	  pathname[j++] = pathname[i++];
 
-      if (!pathname[i - 1])
-	break;
+	  if (!pathname[i - 1])
+	    break;
+	}
+      pathname[j] = '\0';
     }
-  pathname[j] = '\0';
 }
 
-
-
 /* Test whether NAME exists. */
 
 #if defined (HAVE_LSTAT)
@@ -379,20 +424,62 @@
 	  if (REAL_DIR_ENTRY (dp) == 0)
 	    continue;
 
-	  /* If a leading dot need not be explicitly matched, and the pattern
-	     doesn't start with a `.', don't match `.' or `..' */
-#define dname dp->d_name
-	  if (noglob_dot_filenames == 0 && pat[0] != '.' &&
-		(pat[0] != '\\' || pat[1] != '.') &&
-		(dname[0] == '.' &&
-		  (dname[1] == '\0' || (dname[1] == '.' && dname[2] == '\0'))))
-#undef dname
-	    continue;
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      char *pat_p, *dn_p;
+	      wchar_t *wpat, *wdn;
+	      mbstate_t pat_state, dn_state;
+	      size_t wpat_len, wpat_max, wdn_len, wdn_max;
+
+	      pat_p = pat;
+	      wpat_max = strlen (pat) + 1;
+	      memset(&pat_state, '\0', sizeof(mbstate_t));
+	      wpat = (wchar_t *) alloca (wpat_max * sizeof(wchar_t));
+	      wpat_len = xmbsrtowcs (wpat, (const char **)&pat_p, 2, &pat_state);
+
+	      dn_p = dp->d_name;
+	      wdn_max= strlen(dp->d_name);
+	      memset(&dn_state, '\0', sizeof(mbstate_t));
+	      wdn = (wchar_t *) alloca (wdn_max * sizeof(wchar_t));
+	      wdn_len = xmbsrtowcs (wdn, (const char **)&dn_p, 3, &dn_state);
 
-	  /* If a dot must be explicity matched, check to see if they do. */
-	  if (noglob_dot_filenames && dp->d_name[0] == '.' && pat[0] != '.' &&
-		(pat[0] != '\\' || pat[1] != '.'))
-	    continue;
+	      if (wpat_len != (size_t)-1 && wdn_len !=(size_t)-1)
+		{
+		  /* If a leading dot need not be explicitly matched, and the
+		    pattern doesn't start with a `.', don't match `.' or `..' */
+		  if (noglob_dot_filenames == 0 && wpat[0] != L'.' &&
+			(wpat[0] != L'\\' || wpat[1] != L'.') &&
+			(wdn[0] == L'.' &&
+			(wdn[1] == L'\0' ||
+			     (wdn[1] == L'.' && wdn[2] == L'\0'))))
+		    continue;
+
+		  /* If a dot must be explicity matched, check to see if
+		     they do. */
+		  if (noglob_dot_filenames && wdn[0] == L'.' &&
+		      wpat[0] != L'.' &&
+		      (wpat[0] != L'\\' || wpat[1] != L'.'))
+		    continue;
+		}
+	    }
+	  else
+#endif
+	    {
+	      /* If a leading dot need not be explicitly matched, and the
+		 pattern doesn't start with a `.', don't match `.' or `..' */
+	      if (noglob_dot_filenames == 0 && pat[0] != '.' &&
+		    (pat[0] != '\\' || pat[1] != '.') &&
+		    (dp->d_name[0] == '.' &&
+		    (dp->d_name[1] == '\0' ||
+			 (dp->d_name[1] == '.' && dp->d_name[2] == '\0'))))
+		continue;
+
+	      /* If a dot must be explicity matched, check to see if they do. */
+	      if (noglob_dot_filenames && dp->d_name[0] == '.' &&
+		 pat[0] != '.' && (pat[0] != '\\' || pat[1] != '.'))
+		continue;
+	    }
 
 	  if (fnmatch (pat, dp->d_name, flags) != FNM_NOMATCH)
 	    {
@@ -447,7 +534,7 @@
   name_vector[count] = NULL;
   return (name_vector);
 }
-
+
 /* Return a new array which is the concatenation of each string in ARRAY
    to DIR.  This function expects you to pass in an allocated ARRAY, and
    it takes care of free()ing that array.  Thus, you might think of this
@@ -495,7 +582,7 @@
 
   return (result);
 }
-
+
 /* Do globbing on PATHNAME.  Return an array of pathnames that match,
    marking the end of the array with a null-pointer as an element.
    If no pathnames match, then the array is empty (first element is null).
@@ -667,7 +754,7 @@
 #endif /* SHELL */
   return (NULL);
 }
-
+
 #if defined (TEST)
 
 main (argc, argv)
diff -ruN bash-2.05.orig/lib/glob/glob_loop.c bash-2.05/lib/glob/glob_loop.c
--- bash-2.05.orig/lib/glob/glob_loop.c	Thu Jan  1 09:00:00 1970
+++ bash-2.05/lib/glob/glob_loop.c	Mon Apr 16 12:10:15 2001
@@ -0,0 +1,48 @@
+static int INTERNAL_GLOB_PATTERN_P (CHAR *pattern);
+
+/* Return nonzero if PATTERN has any special globbing chars in it.  */
+int
+INTERNAL_GLOB_PATTERN_P (pattern)
+     CHAR *pattern;
+{
+  CHAR *p;
+  CHAR c;
+  int bopen;
+
+  p = pattern;
+  bopen = 0;
+
+  while ((c = *p++) != L('\0'))
+    switch (c)
+      {
+      case L('?'):
+      case L('*'):
+	return 1;
+
+      case L('['):      /* Only accept an open brace if there is a close */
+	bopen++;        /* brace to match it.  Bracket expressions must be */
+	continue;       /* complete, according to Posix.2 */
+      case L(']'):
+	if (bopen)
+	  return 1;
+	continue;
+
+      case L('+'):         /* extended matching operators */
+      case L('@'):
+      case L('!'):
+	if (*p == L('('))  /*) */
+	  return 1;
+	continue;
+
+      case L('\\'):
+	if (*p++ == L('\0'))
+	  return 0;
+      }
+
+  return 0;
+}
+
+#undef INTERNAL_GLOB_PATTERN_P
+#undef L
+#undef INT
+#undef CHAR
diff -ruN bash-2.05.orig/lib/glob/xmbsrtowcs.c bash-2.05/lib/glob/xmbsrtowcs.c
--- bash-2.05.orig/lib/glob/xmbsrtowcs.c	Thu Jan  1 09:00:00 1970
+++ bash-2.05/lib/glob/xmbsrtowcs.c	Fri Aug 17 10:09:00 2001
@@ -0,0 +1,108 @@
+#include <config.h>
+
+#if defined (HAVE_STRING_H)
+# include <string.h>
+#else
+# include <strings.h>
+#endif /* HAVE_STRING_H */
+
+#if defined (HAVE_STDLIB_H)
+# include <stdlib.h>
+#else
+# include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+
+/* <wchar.h>, <wctype.h> and <stdlib.h> are included in "xmbsrtowcs.h".
+   If <wchar.h>, <wctype.h>, mbsrtowcs(), exist, HANDLE_MULTIBYTE
+   is defined as 1. */
+#include "xmbsrtowcs.h" 
+
+#if HANDLE_MULTIBYTE
+/* On some locales (ex. ja_JP.sjis), mbsrtowc doesn't convert 0x5c to U<0x5c>.
+   So, this function is made for converting 0x5c to U<0x5c>. */
+
+static mbstate_t local_state;
+static int local_state_use = 0;
+
+size_t
+xmbsrtowcs (dest, src, len, pstate)
+    wchar_t *dest;
+    const char **src;
+    size_t len;
+    mbstate_t *pstate;
+{
+  mbstate_t *ps;
+  size_t mblength, wclength, n;
+
+  ps = pstate;
+  if (pstate == NULL)
+    {
+      if (!local_state_use)
+	{
+	  memset (&local_state, '\0', sizeof(mbstate_t));
+	  local_state_use = 1;
+	}
+      ps = &local_state;
+    }
+
+  n = strlen(*src) + 1;
+
+  if (dest == NULL)
+    {
+      wchar_t *wsbuf;
+      char *mbsbuf, *mbsbuf_top;
+      mbstate_t psbuf;
+
+      wsbuf = (wchar_t *) malloc ((n + 1) * sizeof(wchar_t));
+      mbsbuf_top = mbsbuf = (char *) malloc (n + 1);
+      memcpy(mbsbuf, *src, n + 1);
+      psbuf = *ps;
+
+      wclength = mbsrtowcs (wsbuf, (const char **)&mbsbuf, n, &psbuf);
+
+      free (wsbuf);
+      free (mbsbuf_top);
+      return wclength;
+    }
+      
+  for(wclength = 0; wclength < len; wclength++, dest++)
+    {
+      if(mbsinit(ps))
+	{
+	  if (**src == '\0')
+	    {
+	      *dest = L'\0';
+	      *src = NULL;
+	      return (wclength);
+	    }
+	  else if (**src == '\\')
+	    {
+	      *dest = L'\\';
+	      mblength = 1;
+	    }
+	  else
+	    mblength = mbrtowc(dest, *src, n, ps);
+	}
+      else
+	mblength = mbrtowc(dest, *src, n, ps);
+
+      /* Cannot convert multibyte character to wide character. */
+      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+	return (size_t)-1;
+
+      *src += mblength;
+      n -= mblength;
+
+      /* The multibyte string  has  been  completely  converted,
+	 including  the terminating '\0'. */
+      if (*dest == L'\0')
+	{
+	  *src = NULL;
+	  break;
+	}
+    }
+
+    return (wclength);
+}
+#endif
diff -ruN bash-2.05.orig/lib/glob/xmbsrtowcs.h bash-2.05/lib/glob/xmbsrtowcs.h
--- bash-2.05.orig/lib/glob/xmbsrtowcs.h	Thu Jan  1 09:00:00 1970
+++ bash-2.05/lib/glob/xmbsrtowcs.h	Wed Jun 20 16:04:41 2001
@@ -0,0 +1,14 @@
+#ifndef _XMBSRTOWCS_H
+# define _XMBSRTOWCS_H 1
+
+# include "stdc.h"
+# include "config.h"
+
+# if HANDLE_MULTIBYTE
+/* On some locales, the non-first byte of some multibyte character are as
+   same number as some ascii character. So legacy strchr() may be returns
+   wrong value . */
+extern size_t xmbsrtowcs __P((wchar_t *dest, const char **src,
+			      size_t len, mbstate_t *pstate));
+# endif /* HANDLE_MULTIBYTE */
+#endif /* _XMBSRTOWCS_H */
diff -ruN bash-2.05.orig/make_cmd.c bash-2.05/make_cmd.c
--- bash-2.05.orig/make_cmd.c	Thu Feb 15 06:54:04 2001
+++ bash-2.05/make_cmd.c	Wed Jun 20 16:04:41 2001
@@ -47,6 +47,49 @@
 #include "jobs.h"
 #endif
 
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+/* Declare mbstate_t state, and creat in initial state. */
+#if HANDLE_MULTIBYTE
+# define DECLARE_STATE                                                  \
+  mbstate_t state;                                                      \
+  memset (&state, '\0', sizeof(mbstate_t))
+#else
+# define DECLARE_STATE
+#endif
+
+/* Skip one character, that character is unibyte or multibyte. */
+#if HANDLE_MULTIBYTE
+# define SKIP_ONE_CHARACTER(_string, _i)                                \
+   do                                                                   \
+    {                                                                   \
+      if(MB_CUR_MAX > 1)                                                \
+	{                                                               \
+	  mbstate_t state_bak;                                          \
+	  size_t mblength;                                              \
+									\
+	  state_bak = state;                                            \
+	  mblength = mbrlen(_string + _i, strlen(_string + _i), &state);  \
+									\
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)         \
+	    {                                                           \
+	      state = state_bak;                                        \
+	      _i++;                                                     \
+	    }                                                           \
+	  else                                                          \
+	      _i += mblength;                                           \
+	}                                                               \
+      else                                                              \
+	_i++;                                                           \
+    } while(0)
+#else
+# define SKIP_ONE_CHARACTER(_string, _i) _i++
+#endif
+
 extern int line_number, current_command_line_count;
 extern int disallow_filename_globbing;
 extern int last_command_exit_value;
@@ -76,22 +119,29 @@
      WORD_DESC *w;
      char *string;
 {
-  register char *s;
+  int i;
+
+  DECLARE_STATE;
 
-  for (s = string; *s; s++)
-    switch (*s)
-      {
-	case '$':
-	  w->flags |= W_HASDOLLAR;
-	  break;
-	case '\\':
-	  break;	/* continue the loop */
-	case '\'':
-	case '`':
-	case '"':
-	  w->flags |= W_QUOTED;
-	  break;
-      }
+  i = 0;
+  while(string[i])
+    {
+      switch (string[i])
+	{
+	  case '$':
+	    w->flags |= W_HASDOLLAR;
+	    break;
+	  case '\\':
+	    break;	/* continue the loop */
+	  case '\'':
+	  case '`':
+	  case '"':
+	    w->flags |= W_QUOTED;
+	    break;
+	}
+
+      SKIP_ONE_CHARACTER(string, i);
+    }
   return (w);
 }
 
diff -ruN bash-2.05.orig/parse.y bash-2.05/parse.y
--- bash-2.05.orig/parse.y	Wed Mar 28 00:06:12 2001
+++ bash-2.05/parse.y	Thu Jan 17 17:29:24 2002
@@ -130,6 +130,10 @@
 char *history_delimiting_chars ();
 #endif
 
+#ifdef HANDLE_MULTIBYTE
+static void analyze_shell_input_line();
+#endif
+
 extern int yyerror ();
 
 /* Default prompt strings */
@@ -1344,6 +1348,9 @@
   shell_input_line_index = 0;
   shell_input_line_terminator = '\0';
   parser_state &= ~PST_ALEXPNEXT;
+#ifdef HANDLE_MULTIBYTE
+  analyze_shell_input_line();
+#endif
 }
 
 /*
@@ -1377,6 +1384,9 @@
 #endif
 
   free ((char *)t);
+#ifdef HANDLE_MULTIBYTE
+  analyze_shell_input_line();
+#endif
 }
 
 static void
@@ -1569,6 +1579,71 @@
 
 #define pop_delimiter(ds)	ds.delimiter_depth--
 
+#ifdef HANDLE_MULTIBYTE
+#define last_shell_getc_is_singlebyte \
+                ((MB_CUR_MAX > 1 && shell_input_line_index > 1)? \
+                 shell_input_line_property[shell_input_line_index - 1] : 1)
+#else
+#define last_shell_getc_is_singlebyte (1)
+#endif
+
+#ifdef HANDLE_MULTIBYTE
+static char *shell_input_line_property = NULL;
+static void
+analyze_shell_input_line()
+{
+  int i, previ, len;
+  mbstate_t mbs, prevs;
+
+  if (MB_CUR_MAX == 1 || shell_input_line == NULL)
+    return;
+  len = strlen(shell_input_line);
+  if (shell_input_line_property != NULL)
+    free(shell_input_line_property);
+  shell_input_line_property = (char*) xmalloc(len + 1);
+
+  memset(&prevs, 0, sizeof(mbstate_t));
+  for (i = previ = 0 ; i < len ; i++)
+    {
+      size_t mbclen;
+      mbs = prevs;
+
+      if (shell_input_line[i] == EOF)
+        {
+          int j;
+          for (j = i ; j < len ; j++)
+            shell_input_line_property[j] = 1;
+          break;
+        }
+
+      mbclen = mbrlen(shell_input_line + previ, i - previ + 1, &mbs);
+      if (mbclen == (size_t) -1 || mbclen == 1)
+        {
+          /* singlebyte character.  */
+          mbclen = 1;
+          previ = i + 1;
+        }
+      else if (mbclen == (size_t) -2)
+        {
+          /* a part of a multibyte character.  */
+          mbclen = 0;
+        }
+      else if (mbclen > 1)
+        {
+          /* the end of a multibyte character.  */
+          mbclen = 0;
+          previ = i + 1;
+          prevs = mbs;
+        }
+      else
+        {
+          /* Can't reach.  */
+        }
+      shell_input_line_property[i] = mbclen;
+    }
+}
+#endif
+
 /* Return the next shell input character.  This always reads characters
    from shell_input_line; when that line is exhausted, it is time to
    read the next line.  This is called by read_token when the shell is
@@ -1678,6 +1753,9 @@
 
       shell_input_line_index = 0;
       shell_input_line_len = i;		/* == strlen (shell_input_line) */
+#ifdef HANDLE_MULTIBYTE
+      analyze_shell_input_line();
+#endif
 
 #if defined (HISTORY)
       if (remember_on_history && shell_input_line && shell_input_line[0])
@@ -1709,6 +1787,9 @@
 	      /* We have to force the xrealloc below because we don't know
 		 the true allocated size of shell_input_line anymore. */
 	      shell_input_line_size = shell_input_line_len;
+#ifdef HANDLE_MULTIBYTE
+	      analyze_shell_input_line();
+#endif
 	    }
 	}
       /* Try to do something intelligent with blank lines encountered while
@@ -1760,6 +1841,9 @@
 
 	  shell_input_line[shell_input_line_len] = '\n';
 	  shell_input_line[shell_input_line_len + 1] = '\0';
+#ifdef HANDLE_MULTIBYTE
+	  analyze_shell_input_line();
+#endif
 	}
     }
 
@@ -1769,7 +1853,8 @@
     shell_input_line_index++;
 
   if (c == '\\' && remove_quoted_newline &&
-      shell_input_line[shell_input_line_index] == '\n')
+      shell_input_line[shell_input_line_index] == '\n'
+      && last_shell_getc_is_singlebyte)
     {
 	prompt_again ();
 	line_number++;
@@ -2250,7 +2335,8 @@
       return (yacc_EOF);
     }
 
-  if (character == '#' && (!interactive || interactive_comments))
+  if (character == '#' && (!interactive || interactive_comments)
+      && last_shell_getc_is_singlebyte)
     {
       /* A comment.  Discard until EOL or EOF, and then return a newline. */
       discard_until ('\n');
@@ -2273,7 +2359,8 @@
     }
 
   /* Shell meta-characters. */
-  if (shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
+  if (shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0)
+      && last_shell_getc_is_singlebyte)
     {
 #if defined (ALIAS)
       /* Turn off alias tokenization iff this character sequence would
@@ -2376,15 +2463,20 @@
 #endif
 	    }
 	}
-      else if (character == '<' && peek_char == '&')
+      else if (character == '<' && peek_char == '&'
+	       && last_shell_getc_is_singlebyte)
 	return (LESS_AND);
-      else if (character == '>' && peek_char == '&')
+      else if (character == '>' && peek_char == '&'
+	       && last_shell_getc_is_singlebyte)
 	return (GREATER_AND);
-      else if (character == '<' && peek_char == '>')
+      else if (character == '<' && peek_char == '>'
+	       && last_shell_getc_is_singlebyte)
 	return (LESS_GREATER);
-      else if (character == '>' && peek_char == '|')
+      else if (character == '>' && peek_char == '|'
+	       && last_shell_getc_is_singlebyte)
 	return (GREATER_BAR);
-      else if (peek_char == '>' && character == '&')
+      else if (peek_char == '>' && character == '&'
+	       && last_shell_getc_is_singlebyte)
 	return (AND_GREATER);
 
       shell_ungetc (peek_char);
@@ -2392,7 +2484,8 @@
       /* If we look like we are reading the start of a function
 	 definition, then let the reader know about it so that
 	 we will do the right thing with `{'. */
-      if (character == ')' && last_read_token == '(' && token_before_that == WORD)
+      if (character == ')' && last_read_token == '(' && token_before_that == WORD
+	  && last_shell_getc_is_singlebyte)
 	{
 	  parser_state |= PST_ALLOWOPNBRC;
 #if defined (ALIAS)
@@ -2404,26 +2497,31 @@
       /* case pattern lists may be preceded by an optional left paren.  If
 	 we're not trying to parse a case pattern list, the left paren
 	 indicates a subshell. */
-      if (character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
+      if (character == '(' && (parser_state & PST_CASEPAT) == 0 /* ) */
+	  && last_shell_getc_is_singlebyte)
 	parser_state |= PST_SUBSHELL;
       /*(*/
-      else if ((parser_state & PST_CASEPAT) && character == ')')
+      else if ((parser_state & PST_CASEPAT) && character == ')'
+	       && last_shell_getc_is_singlebyte)
 	parser_state &= ~PST_CASEPAT;
       /*(*/
-      else if ((parser_state & PST_SUBSHELL) && character == ')')
+      else if ((parser_state & PST_SUBSHELL) && character == ')'
+	       && last_shell_getc_is_singlebyte)
 	parser_state &= ~PST_SUBSHELL;
 
 #if defined (PROCESS_SUBSTITUTION)
       /* Check for the constructs which introduce process substitution.
 	 Shells running in `posix mode' don't do process substitution. */
       if (posixly_correct ||
-	  ((character != '>' && character != '<') || peek_char != '('))
+	  (((character != '>' && character != '<') || peek_char != '(')
+	   && last_shell_getc_is_singlebyte))
 #endif /* PROCESS_SUBSTITUTION */
 	return (character);
     }
 
   /* Hack <&- (close stdin) case. */
-  if (character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
+  if (character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND)
+      && last_shell_getc_is_singlebyte)
     return (character);
 
   /* Okay, if we got this far, we have to read a word.  Read one,
@@ -2489,26 +2587,30 @@
 	    }
 
 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
-	  if (ch == CTLESC || ch == CTLNUL)
+	  if ((ch == CTLESC || ch == CTLNUL) && last_shell_getc_is_singlebyte)
 	    ret[retind++] = CTLESC;
 	  ret[retind++] = ch;
 	  continue;
 	}
-      else if (ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+      else if ((ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+	       && last_shell_getc_is_singlebyte)
 	{
 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
 	  ret[retind++] = CTLESC;
 	  ret[retind++] = ch;
 	  continue;
 	}
-      else if (ch == close)		/* ending delimiter */
+      else if (ch == close		/* ending delimiter */
+	       && last_shell_getc_is_singlebyte)
 	count--;
 #if 1
       /* handle nested ${...} specially. */
-      else if (open != close && was_dollar && open == '{' && ch == open) /* } */
+      else if (open != close && was_dollar && open == '{' && ch == open /* } */
+	       && last_shell_getc_is_singlebyte)
 	count++;
 #endif
-      else if (((flags & P_FIRSTCLOSE) == 0) && ch == open)		/* nested begin */
+      else if (((flags & P_FIRSTCLOSE) == 0) && ch == open		/* nested begin */
+	       && last_shell_getc_is_singlebyte)
 	count++;
 
       /* Add this character. */
@@ -2517,21 +2619,21 @@
 
       if (open == '\'')			/* '' inside grouping construct */
 	{
-	  if ((flags & P_ALLOWESC) && ch == '\\')
+	  if ((flags & P_ALLOWESC) && ch == '\\' && last_shell_getc_is_singlebyte)
 	    pass_next_character++;
 	  continue;
 	}
 
-      if (ch == '\\')			/* backslashes */
+      if (ch == '\\' && last_shell_getc_is_singlebyte)			/* backslashes */
 	pass_next_character++;
-
       if (open != close)		/* a grouping construct */
 	{
-	  if (shellquote (ch))
+	  if (shellquote (ch) && last_shell_getc_is_singlebyte)
 	    {
 	      /* '', ``, or "" inside $(...) or other grouping construct. */
 	      push_delimiter (dstack, ch);
-	      if (was_dollar && ch == '\'')	/* $'...' inside group */
+	      if (was_dollar && ch == '\''	/* $'...' inside group */
+		  && last_shell_getc_is_singlebyte)
 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC);
 	      else
 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, 0);
@@ -2541,7 +2643,7 @@
 		  free (ret);
 		  return &matched_pair_error;
 		}
-	      if (was_dollar && ch == '\'')
+	      if (was_dollar && ch == '\'' && last_shell_getc_is_singlebyte)
 		{
 		  /* Translate $'...' here. */
 		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
@@ -2551,7 +2653,7 @@
 		  nestlen = strlen (nestret);
 		  retind -= 2;		/* back up before the $' */
 		}
-	      else if (was_dollar && ch == '"')
+	      else if (was_dollar && ch == '"' && last_shell_getc_is_singlebyte)
 		{
 		  /* Locale expand $"..." here. */
 		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
@@ -2577,7 +2679,7 @@
       /* Parse an old-style command substitution within double quotes as a
 	 single word. */
       /* XXX - sh and ksh93 don't do this - XXX */
-      else if (open == '"' && ch == '`')
+      else if (open == '"' && ch == '`' && last_shell_getc_is_singlebyte)
 	{
 	  nestret = parse_matched_pair (0, '`', '`', &nestlen, 0);
 	  if (nestret == &matched_pair_error)
@@ -2593,7 +2695,8 @@
 	    }
 	  FREE (nestret);
 	}
-      else if (was_dollar && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
+      else if (was_dollar && (ch == '(' || ch == '{' || ch == '[')	/* ) } ] */
+	       && last_shell_getc_is_singlebyte)
 	/* check for $(), $[], or ${} inside quoted string. */
 	{
 	  if (open == ch)	/* undo previous increment */
@@ -2617,7 +2720,7 @@
 	    }
 	  FREE (nestret);
 	}
-      was_dollar = (ch == '$');
+      was_dollar = (ch == '$' && last_shell_getc_is_singlebyte);
     }
 
   ret[retind] = '\0';
@@ -2647,7 +2750,7 @@
     return -1;
   /* Check that the next character is the closing right paren.  If
      not, this is a syntax error. ( */
-  if ((c = shell_getc (0)) != ')')
+  if ((c = shell_getc (0)) != ')' && last_shell_getc_is_singlebyte)
     rval = 0;
 
   token = xmalloc (ttoklen + 4);
@@ -2902,7 +3005,7 @@
 
       /* Handle backslashes.  Quote lots of things when not inside of
 	 double-quotes, quote some things inside of double-quotes. */
-      if (character == '\\')
+      if (character == '\\' && last_shell_getc_is_singlebyte)
 	{
 	  peek_char = shell_getc (0);
 
@@ -2928,7 +3031,7 @@
 	}
 
       /* Parse a matched pair of quote characters. */
-      if (shellquote (character))
+      if (shellquote (character) && last_shell_getc_is_singlebyte)
 	{
 	  push_delimiter (dstack, character);
 	  ttok = parse_matched_pair (character, character, character, &ttoklen, 0);
@@ -2952,7 +3055,7 @@
       if (extended_glob && PATTERN_CHAR (character))
 	{
 	  peek_char = shell_getc (1);
-	  if (peek_char == '(')		/* ) */
+	  if (peek_char == '(' && last_shell_getc_is_singlebyte)	/* ) */
 	    {
 	      push_delimiter (dstack, peek_char);
 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
@@ -2981,8 +3084,9 @@
 	{
 	  peek_char = shell_getc (1);
 	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
-	  if (peek_char == '(' ||
+	  if ((peek_char == '(' ||
 		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
+	      && last_shell_getc_is_singlebyte)
 	    {
 	      if (peek_char == '{')		/* } */
 		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE);
@@ -3014,7 +3118,8 @@
 	      goto next_character;
 	    }
 	  /* This handles $'...' and $"..." new-style quoted strings. */
-	  else if (character == '$' && (peek_char == '\'' || peek_char == '"'))
+	  else if (character == '$' && (peek_char == '\'' || peek_char == '"')
+		   && last_shell_getc_is_singlebyte)
 	    {
 	      int first_line;
 
@@ -3066,7 +3171,8 @@
 	    }
 	  /* This could eventually be extended to recognize all of the
 	     shell's single-character parameter expansions, and set flags.*/
-	  else if (character == '$' && peek_char == '$')
+	  else if (character == '$' && peek_char == '$'
+		   && last_shell_getc_is_singlebyte)
 	    {
 	      ttok = xmalloc (3);
 	      ttok[0] = ttok[1] = '$';
@@ -3087,10 +3193,11 @@
 
 #if defined (ARRAY_VARS)
       /* Identify possible compound array variable assignment. */
-      else if (character == '=' && token_index > 0)
+      else if (character == '=' && token_index > 0
+	       && last_shell_getc_is_singlebyte)
 	{
 	  peek_char = shell_getc (1);
-	  if (peek_char == '(')		/* ) */
+	  if (peek_char == '(' && last_shell_getc_is_singlebyte)	/* ) */
 	    {
 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
 	      if (ttok == &matched_pair_error)
@@ -3118,7 +3225,7 @@
 
       /* When not parsing a multi-character word construct, shell meta-
 	 characters break words. */
-      if (shellbreak (character))
+      if (shellbreak (character) && last_shell_getc_is_singlebyte)
 	{
 	  shell_ungetc (character);
 	  goto got_token;
@@ -3159,14 +3266,15 @@
      Otherwise, it is just a word, and should be returned as such. */
   if (all_digits && (character == '<' || character == '>' ||
 		    last_read_token == LESS_AND ||
-		    last_read_token == GREATER_AND))
+		    last_read_token == GREATER_AND)
+      && last_shell_getc_is_singlebyte)
       {
 	yylval.number = atoi (token);
 	return (NUMBER);
       }
 
   /* Check for special case tokens. */
-  result = special_case_tokens (token);
+  result = (last_shell_getc_is_singlebyte)? special_case_tokens (token) : -1;
   if (result >= 0)
     return result;
 
@@ -3174,7 +3282,7 @@
   /* Posix.2 does not allow reserved words to be aliased, so check for all
      of them, including special cases, before expanding the current token
      as an alias. */
-  if (posixly_correct)
+  if (posixly_correct && last_shell_getc_is_singlebyte)
     CHECK_FOR_RESERVED_WORD (token);
 
   /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
@@ -3190,7 +3298,7 @@
 
   /* If not in Posix.2 mode, check for reserved words after alias
      expansion. */
-  if (posixly_correct == 0)
+  if (posixly_correct == 0 && last_shell_getc_is_singlebyte)
 #endif
     CHECK_FOR_RESERVED_WORD (token);
 
diff -ruN bash-2.05.orig/pathexp.c bash-2.05/pathexp.c
--- bash-2.05.orig/pathexp.c	Thu Feb 15 06:54:26 2001
+++ bash-2.05/pathexp.c	Wed Jun 20 16:04:41 2001
@@ -41,6 +41,12 @@
 #  include <glob/glob.h>
 #endif
 
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
 /* Control whether * matches .files in globbing. */
 int glob_dot_filenames;
 
@@ -55,6 +61,12 @@
   register int c;
   int open;
 
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
+
   open = 0;
   while (c = *string++)
     {
@@ -85,6 +97,24 @@
 	  if (*string++ == '\0')
 	    return (0);
 	}
+#if HANDLE_MULTIBYTE
+      if (MB_CUR_MAX > 1)
+	{
+	  mbstate_t state_bak;
+	  size_t mblength;
+
+	  state_bak = state;
+	  mblength = mbrlen (string, strlen(string), &state);
+
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)
+	    {
+	      state = state_bak;
+	      mblength = 1;
+	    }
+	  else
+	    string += (mblength < 1) ? 0 : (mblength - 1);
+	}
+#endif
     }
   return (0);
 }
@@ -136,6 +166,11 @@
      char *string;
 {
   char *temp, *s, *t;
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
 
   temp = xmalloc (strlen (string) * 2 + 1);
   for (t = temp, s = string; *s; )
@@ -156,7 +191,33 @@
 	    *t++ = '\\';
 	  break;
 	}
-      *t++ = *s++;
+
+#if HANDLE_MULTIBYTE
+      if (MB_CUR_MAX > 1)
+	{
+	  mbstate_t state_bak;
+	  size_t mblength;
+	  int i;
+
+	  state_bak = state;
+	  mblength = mbrlen (s, strlen (s), &state);
+
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)
+	    {
+	      state = state_bak;
+	      mblength = 1;
+	    }
+	  else
+	    mblength = (mblength < 1) ? 1 : mblength;
+
+	  for (i = 0; i < mblength; i++)
+	    *t++ = *s++;
+	}
+      else
+#endif
+	{
+	  *t++ = *s++;
+	}
     }
   *t = '\0';
   return temp;
diff -ruN bash-2.05.orig/shell.c bash-2.05/shell.c
--- bash-2.05.orig/shell.c	Tue Mar 27 23:25:51 2001
+++ bash-2.05/shell.c	Mon Apr 16 20:50:58 2001
@@ -48,6 +48,7 @@
 #include "mailcheck.h"
 #include "builtins.h"
 #include "builtins/common.h"
+#include "xstrchr.h"
 
 #if defined (JOB_CONTROL)
 #include "jobs.h"
@@ -1589,12 +1590,12 @@
       set_opts = savestring (shell_builtins[i].short_doc);
   if (set_opts)
     {
-      s = strchr (set_opts, '[');
+      s = xstrchr ((const char *)set_opts, '[');
       if (s == 0)
 	s = set_opts;
       while (*++s == '-')
 	;
-      t = strchr (s, ']');
+      t = xstrchr ((const char *)s, ']');
       if (t)
 	*t = '\0';
       fprintf (fp, "\t-%s or -o option\n", s);
diff -ruN bash-2.05.orig/subst.c bash-2.05/subst.c
--- bash-2.05.orig/subst.c	Tue Mar 27 03:06:16 2001
+++ bash-2.05/subst.c	Wed Jun 20 16:42:54 2001
@@ -45,6 +45,7 @@
 #include "trap.h"
 #include "pathexp.h"
 #include "mailcheck.h"
+#include "xstrchr.h"
 
 #if !defined (HAVE_RESTARTABLE_SYSCALLS)	/* for getc_with_restart */
 #include "input.h"
@@ -60,6 +61,12 @@
 extern int errno;
 #endif /* !errno */
 
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
 /* The size that strings change by. */
 #define DEFAULT_INITIAL_ARRAY_SIZE 112
 #define DEFAULT_ARRAY_SIZE 128
@@ -101,6 +108,43 @@
       (name[1] == '\0' && (sh_syntaxtab[*name] & CSPECVAR)) || \
       (wi && name[2] == '\0' && VALID_INDIR_PARAM (name[1])))
 
+/* Declare mbstate_t state, and creat in initial state. */
+#if HANDLE_MULTIBYTE
+# define DECLARE_STATE							\
+  mbstate_t state;							\
+  memset (&state, '\0', sizeof(mbstate_t))
+#else
+# define DECLARE_STATE
+#endif
+   
+/* Skip one character, that character is unibyte or multibyte. */
+#if HANDLE_MULTIBYTE
+# define SKIP_ONE_CHARACTER(_string, _i)				\
+   do									\
+    {									\
+      if(MB_CUR_MAX > 1)						\
+	{								\
+	  mbstate_t state_bak;						\
+	  size_t mblength;						\
+									\
+	  state_bak = state;						\
+	  mblength = mbrlen(_string + _i, strlen(_string + _i), &state);  \
+									\
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)		\
+	    {								\
+	      state = state_bak;					\
+	      _i++;							\
+	    }								\
+	  else								\
+	      _i += mblength;						\
+	}								\
+      else								\
+	_i++;								\
+    } while(0)
+#else
+# define SKIP_ONE_CHARACTER(_string, _i) _i++
+#endif
+
 /* Process ID of the last command executed within command substitution. */
 pid_t last_command_subst_pid = NO_PID;
 pid_t current_command_subst_pid = NO_PID;
@@ -142,7 +186,6 @@
    so the SIGCHLD handler in jobs.c can unwind-protect it when it runs a
    SIGCHLD trap. */
 WORD_LIST *subst_assign_varlist = (WORD_LIST *)NULL;
-
 /* A WORD_LIST of words to be expanded by expand_word_list_internal,
    without any leading variable assignments. */
 static WORD_LIST *garglist = (WORD_LIST *)NULL;
@@ -269,7 +312,10 @@
 {
   int sindex, c;
 
-  for (sindex = 0; c = string[sindex]; )
+  DECLARE_STATE;
+
+  sindex = 0;
+  while (c = string[sindex])
     {
       if (c == character)
 	return (1);
@@ -277,13 +323,13 @@
       switch (c)
 	{
 	default:
-	  sindex++;
+	  SKIP_ONE_CHARACTER(string, sindex);
 	  break;
 
 	case '\\':
 	  sindex++;
 	  if (string[sindex])
-	    sindex++;
+	    SKIP_ONE_CHARACTER(string, sindex);
 	  break;
 
 	case '\'':
@@ -305,6 +351,8 @@
 {
   int sindex, c, sublen;
 
+  DECLARE_STATE;
+
   if (substr == 0 || *substr == '\0')
     return (0);
 
@@ -320,7 +368,7 @@
 	  sindex++;
 
 	  if (string[sindex])
-	    sindex++;
+	    SKIP_ONE_CHARACTER(string, sindex);
 	  break;
 
 	case '\'':
@@ -332,7 +380,7 @@
 	  break;
 
 	default:
-	  sindex++;
+	  SKIP_ONE_CHARACTER(string, sindex);
 	  break;
 	}
     }
@@ -407,7 +455,10 @@
   register int c, i;
   char *temp;
 
-  for (i = *sindex; c = string[i]; i++)
+  DECLARE_STATE;
+
+  i = *sindex;
+  while (c = string[i])
     {
       if (c == '\\')
 	if (string[i + 1])
@@ -426,6 +477,8 @@
 #endif
       else if (MEMBER (c, charlist))
 	  break;
+
+      SKIP_ONE_CHARACTER(string, i);
     }
 
   temp = substring (string, *sindex, i);
@@ -450,10 +503,14 @@
   int pass_next, backquote, si;	/* State variables for the machine. */
   int dquote;
 
+  DECLARE_STATE;
+
   pass_next = backquote = dquote = 0;
   temp = xmalloc (1 + strlen (string) - *sindex);
 
-  for (j = 0, i = *sindex; c = string[i]; i++)
+  j = 0;
+  i = *sindex;
+  while (c = string[i])
     {
       /* Process a character that was quoted by a backslash. */
       if (pass_next)
@@ -462,7 +519,7 @@
 
 	     ``The backslash shall retain its special meaning as an escape
 	     character only when followed by one of the characters:
-	     	$	`	"	\	<newline>''.
+		$	`	"	\	<newline>''.
 
 	     If STRIPDQ is zero, we handle the double quotes here and let
 	     expand_word_internal handle the rest.  If STRIPDQ is non-zero,
@@ -481,10 +538,36 @@
 		The returned string will be run through expansion as if
 		it were double-quoted. */
 	  if ((stripdq == 0 && c != '"') ||
-	      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))
+              (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))
 	    temp[j++] = '\\';
-	  temp[j++] = c;
+
 	  pass_next = 0;
+
+add_one_character:
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      mbstate_t state_bak;
+	      size_t mblength;
+	      int k;
+
+	      state_bak = state;
+	      mblength = mbrlen (string + i, strlen(string + i), &state);
+
+	      if (mblength == (size_t)-2 || mblength == (size_t)-1)
+		{
+		  state = state_bak;
+		  mblength = 1;
+		}
+	      else
+		mblength = (mblength < 1) ? 1 : mblength;
+
+	      for (k = 0; k < mblength; k++)
+		temp[j++] = string[i++];
+	    }
+	  else
+#endif
+	    temp[j++] = string[i++];
 	  continue;
 	}
 
@@ -494,6 +577,7 @@
       if (c == '\\')
 	{
 	  pass_next++;
+	  i++;
 	  continue;
 	}
 
@@ -506,6 +590,7 @@
 	  if (c == '`')
 	    backquote = 0;
 	  temp[j++] = c;
+	  i++;
 	  continue;
 	}
 
@@ -513,6 +598,7 @@
 	{
 	  temp[j++] = c;
 	  backquote++;
+	  i++;
 	  continue;
 	}
 
@@ -535,21 +621,20 @@
 
 	  i = si;
 	  free (ret);
+	  i++;
 	  continue;
 	}
 
       /* Add any character but a double quote to the quoted string we're
 	 accumulating. */
       if (c != '"')
-	{
-	  temp[j++] = c;
-	  continue;
-	}
+	goto add_one_character;
 
       /* c == '"' */
       if (stripdq)
 	{
 	  dquote ^= 1;
+	  i++;
 	  continue;
 	}
 
@@ -566,6 +651,7 @@
 }
 
 /* This should really be another option to string_extract_double_quoted. */
+
 static inline int
 skip_double_quoted (string, sind)
      char *string;
@@ -575,29 +661,37 @@
   char *ret;
   int pass_next, backquote, si;
 
+  DECLARE_STATE;
+
   pass_next = backquote = 0;
 
-  for (j = 0, i = sind; c = string[i]; i++)
+  i = sind;
+  j = 0;
+  while (c = string[i])
     {
       if (pass_next)
 	{
 	  pass_next = 0;
+	  SKIP_ONE_CHARACTER(string, i);
 	  continue;
 	}
       else if (c == '\\')
 	{
 	  pass_next++;
+	  i++;
 	  continue;
 	}
       else if (backquote)
 	{
 	  if (c == '`')
 	    backquote = 0;
+	  SKIP_ONE_CHARACTER(string, i);
 	  continue;
 	}
       else if (c == '`')
 	{
 	  backquote++;
+	  i++;
 	  continue;
 	}
       else if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
@@ -610,10 +704,14 @@
 
 	  i = si;
 	  free (ret);
+	  i++;
 	  continue;
 	}
       else if (c != '"')
-	continue;
+	{
+	  SKIP_ONE_CHARACTER(string, i);
+	  continue;
+	}
       else
 	break;
     }
@@ -636,8 +734,11 @@
   register int i, j;
   char *t;
 
-  for (i = *sindex; string[i] && string[i] != '\''; i++)
-    ;
+  DECLARE_STATE;
+
+  i = *sindex;
+  while (string[i] && string[i] != '\'')
+    SKIP_ONE_CHARACTER(string, i);
 
   t = substring (string, *sindex, i);
 
@@ -655,8 +756,12 @@
 {
   register int c;
 
-  for (c = sind; string[c] && string[c] != '\''; c++)
-    ;
+  DECLARE_STATE;
+  
+  c = sind;
+  while (string[c] && string[c] != '\'')
+    SKIP_ONE_CHARACTER(string, c);
+
   if (string[c])
     c++;
   return c;
@@ -763,6 +868,8 @@
   int pass_character, nesting_level;
   int len_closer, len_opener, len_alt_opener;
 
+  DECLARE_STATE;
+
   len_opener = STRLEN (opener);
   len_alt_opener = STRLEN (alt_opener);
   len_closer = STRLEN (closer);
@@ -782,7 +889,7 @@
       if (pass_character)	/* previous char was backslash */
 	{
 	  pass_character = 0;
-	  i++;
+	  SKIP_ONE_CHARACTER(string, i);
 	  continue;
 	}
 
@@ -824,7 +931,7 @@
 	 the nesting level. */
       if (STREQN (string + i, closer, len_closer))
 	{
-	  i += len_closer - 1;	/* move to last char of the closer */
+	  i += len_closer - 1;	/* move to last byte of the closer */
 	  nesting_level--;
 	  if (nesting_level == 0)
 	    break;
@@ -856,7 +963,8 @@
 	  continue;
 	}
 
-      i++;	/* move past this character, which was not special. */
+      /* move past this character, which was not special. */
+      SKIP_ONE_CHARACTER(string, i);
     }
 
 #if 0
@@ -896,15 +1004,19 @@
   int pass_character, nesting_level, si;
   char *result, *t;
 
+  DECLARE_STATE;
+
   pass_character = 0;
 
   nesting_level = 1;
 
-  for (i = *sindex; (c = string[i]); i++)
+  i = *sindex;
+  while(c = string[i])
     {
       if (pass_character)
 	{
 	  pass_character = 0;
+	  SKIP_ONE_CHARACTER(string, i);
 	  continue;
 	}
 
@@ -912,13 +1024,14 @@
       if (c == CTLESC || c == '\\')
 	{
 	  pass_character++;
+	  i++;
 	  continue;
 	}
 
       if (string[i] == '$' && string[i+1] == LBRACE)
 	{
 	  nesting_level++;
-	  i++;
+	  i += 2;
 	  continue;
 	}
 
@@ -927,6 +1040,7 @@
 	  nesting_level--;
 	  if (nesting_level == 0)
 	    break;
+	  i++;
 	  continue;
 	}
 
@@ -938,6 +1052,7 @@
 	  t = string_extract (string, &si, "`", 0);
 	  i = si;
 	  free (t);
+	  i++;
 	  continue;
 	}
 
@@ -949,6 +1064,7 @@
 	  t = extract_delimited_string (string, &si, "$(", "(", ")"); /*)*/
 	  i = si;
 	  free (t);
+	  i++;
 	  continue;
 	}
 
@@ -960,9 +1076,9 @@
 	  i = (c == '\'') ? skip_single_quoted (string, si)
 			  : skip_double_quoted (string, si);
 	  /* skip_XXX_quoted leaves index one past close quote */
-	  i--;
 	  continue;
 	}
+      SKIP_ONE_CHARACTER(string, i);
     }
 
   if (c == 0 && nesting_level && no_longjmp_on_fatal_error == 0)
@@ -986,11 +1102,18 @@
 {
   register int i, l;
 
-  for (i = 0, l = strlen (string); i < l; i++)
-    if (string[i] == '\\' && (string[i + 1] == '`' || string[i + 1] == '\\' ||
+  DECLARE_STATE;
+
+  i = 0;
+  l = strlen (string);
+  while (string[i] != '\0')
+    {
+      if (string[i] == '\\' && (string[i + 1] == '`' || string[i + 1] == '\\' ||
 			      string[i + 1] == '$'))
       strcpy (string + i, string + i + 1);	/* XXX - should be memmove */
-  return (string);
+
+      SKIP_ONE_CHARACTER(string, i);
+    }
 }
 
 #if 0
@@ -1485,8 +1608,8 @@
 
   /* OK, now STRING points to a word that does not begin with white space.
      The splitting algorithm is:
-     	extract a word, stopping at a separator
-     	skip sequences of spc, tab, or nl as long as they are separators
+	extract a word, stopping at a separator
+	skip sequences of spc, tab, or nl as long as they are separators
      This obeys the field splitting rules in Posix.2. */
   for (result = (WORD_LIST *)NULL, sindex = 0; string[sindex]; )
     {
@@ -1542,11 +1665,11 @@
 	sindex++;
 
       /* If the first separator was IFS whitespace and the current character is
-	 a non-whitespace IFS character, it should be part of the current field
-	 delimiter, not a separate delimiter that would result in an empty field.
-	 Look at POSIX.2, 3.6.5, (3)(b). */
+         a non-whitespace IFS character, it should be part of the current field
+         delimiter, not a separate delimiter that would result in an empty field.
+         Look at POSIX.2, 3.6.5, (3)(b). */
       if (string[sindex] && whitesep && issep (string[sindex]) && !spctabnl (string[sindex]))
-	sindex++;
+        sindex++;
     }
   return (REVERSE_LIST (result, WORD_LIST *));
 }
@@ -1713,7 +1836,7 @@
   int ind, ni;
   SHELL_VAR *entry;
 
-  t = strchr (name, '[');
+  t = xstrchr ((const char *)name, '[');
   if (t == 0)
     return ((SHELL_VAR *)NULL);
   ind = t - name;
@@ -1727,12 +1850,12 @@
   ind = array_expand_index (t, ni - ind);
   if (ind < 0)
     {
-      t[-1] = '[';		/* restore original name ] */
+      t[-1] = '[';              /* restore original name ] */
       report_error ("%s: bad array subscript", name);
       return ((SHELL_VAR *)NULL);
     }
   entry = bind_array_variable (name, ind, value);
-  t[-1] = '[';		/* restore original name ] */
+  t[-1] = '[';          /* restore original name ] */
   return (entry);
 }
 #endif /* ARRAY_VARS */
@@ -1767,7 +1890,7 @@
       temp = name + offset + 1;
 
 #if defined (ARRAY_VARS)
-      if (expand && temp[0] == LPAREN && strchr (temp, RPAREN))
+      if (expand && temp[0] == LPAREN && xstrchr ((const char *)temp, RPAREN))
 	{
 	  assign_list = ni = 1;
 	  value = extract_delimited_string (temp, &ni, "(", (char *)NULL, ")");
@@ -1778,7 +1901,7 @@
       /* Perform tilde expansion. */
       if (expand && temp[0])
 	{
-	  temp = (strchr (temp, '~') && unquoted_member ('~', temp))
+	  temp = (xstrchr ((const char *)temp, '~') && unquoted_member ('~', temp))
 			? bash_tilde_expand (temp)
 			: savestring (temp);
 
@@ -1806,7 +1929,7 @@
 #define ASSIGN_RETURN(r)	do { FREE (value); free (name); return (r); } while (0)
 
 #if defined (ARRAY_VARS)
-  if (t = strchr (name, '['))	/*]*/
+  if (t = xstrchr ((const char *)name, '['))   /*]*/
     {
       if (assign_list)
 	{
@@ -1990,12 +2113,16 @@
   int i, saw_quote;
   char *ret;
 
-  for (i = saw_quote = 0; string[i]; i++)
+  DECLARE_STATE;
+
+  i = saw_quote = 0;
+  while(string[i])
     {
       if (EXP_CHAR (string[i]))
 	break;
       else if (string[i] == '\'' || string[i] == '\\' || string[i] == '"')
 	saw_quote = 1;
+      SKIP_ONE_CHARACTER(string, i);
     }
 
   if (string[i])
@@ -2079,7 +2206,7 @@
   if (w->word == 0 || w->word[0] == '\0')
     return ((char *)NULL);
 
-  if (strchr (w->word, '~') && unquoted_member ('~', w->word))
+  if (xstrchr ((const char *)w->word, '~') && unquoted_member ('~', w->word))
     {
       p = bash_tilde_expand (w->word);
       free (w->word);
@@ -2122,7 +2249,7 @@
   result = expand_word_internal (w, q, i, c, e);
   if (result == &expand_word_error || result == &expand_word_fatal)
     {
-      expand_no_split_dollar_star = 0;	/* XXX */
+      expand_no_split_dollar_star = 0;  /* XXX */
       /* By convention, each time this error is returned, w->word has
 	 already been freed (it sometimes may not be in the fatal case,
 	 but that doesn't result in a memory leak because we're going
@@ -2206,9 +2333,9 @@
   td.word = savestring (string);
 
   no_longjmp_on_fatal_error = 1;
+
   value = expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
   no_longjmp_on_fatal_error = 0;
-
   if (value == &expand_word_error || value == &expand_word_fatal)
     {
       value = make_word_list (make_bare_word (string), (WORD_LIST *)NULL);
@@ -2441,6 +2568,11 @@
 {
   register char *t;
   char *result;
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
 
   if (*string == 0)
     {
@@ -2455,7 +2587,32 @@
       for (t = result; *string; )
 	{
 	  *t++ = CTLESC;
-	  *t++ = *string++;
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      mbstate_t state_bak;
+	      size_t mblength;
+	      int i;
+
+	      state_bak = state;
+	      mblength = mbrlen (string, strlen(string), &state);
+
+	      if (mblength == (size_t)-2 || mblength == (size_t)-1)
+		{
+		  state = state_bak;
+		  mblength = 1;
+		}
+	      else
+		mblength = (mblength < 1) ? 1 : mblength;
+
+	      for (i = 0; i < mblength; i++)
+		*t++ = *string++;
+	    }
+	  else
+#endif
+	    {
+	      *t++ = *string++;
+	    }
 	}
       *t = '\0';
     }
@@ -2480,7 +2637,7 @@
 
   /* If no character in the string can be quoted, don't bother examining
      each character.  Just return a copy of the string passed to us. */
-  if (strchr (string, CTLESC) == NULL)		/* XXX */
+  if (xstrchr ((const char *)string, CTLESC) == NULL)		/* XXX */
     {						/* XXX */
       strcpy (result, string);			/* XXX */
       return (result);				/* XXX */
@@ -2535,22 +2692,55 @@
      char *string;
 {
   char *nstr, *s, *p;
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
 
   nstr = savestring (string);
   nstr[0] = '\0';
-  for (p = nstr, s = string; *s; s++)
+
+  p = nstr;
+  s = string;
+  while (*s)
     {
       if (*s == CTLESC)
 	{
 	  *p++ = *s++;	/* CTLESC */
 	  if (*s == 0)
 	    break;
-	  *p++ = *s;	/* quoted char */
+	}
+      else if (*s == CTLNUL)
+	{
+	  s++;
 	  continue;
 	}
-      if (*s == CTLNUL)
-	continue;
-      *p++ = *s;
+
+#if HANDLE_MULTIBYTE
+      if (MB_CUR_MAX > 1)
+	{
+	  mbstate_t state_bak;
+	  size_t mblength;
+	  int i;
+
+	  state_bak = state;
+	  mblength = mbrlen (s, strlen(s), &state);
+
+	  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+	    {
+	      state = state_bak;
+	      mblength = 1;
+	    }
+	  else
+	    mblength = (mblength < 1) ? 1 : mblength;
+
+	  for (i = 0; i< mblength; i++)
+	    *p++ = *s++;
+	}
+      else
+#endif
+	*p++ = *s++;
     }
   *p = '\0';
   strcpy (string, nstr);
@@ -2795,7 +2985,7 @@
   WORD_LIST *l;
   int i;
 
-  tword = strchr (value, '~') ? bash_tilde_expand (value) : savestring (value);
+  tword = xstrchr ((const char *)value, '~') ? bash_tilde_expand (value) : savestring (value);
 
   /* expand_string_internal () leaves WORD quoted and does not perform
      word splitting. */
@@ -2988,7 +3178,7 @@
   expand_no_split_dollar_star = 1;
   result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
   expand_no_split_dollar_star = 0;
-  
+
   return (result ? dequote_list (result) : result);
 }
 
@@ -3348,7 +3538,7 @@
   istring_index = istring_size = bufn = 0;
 
 #ifdef __CYGWIN__
-  setmode (fd, O_TEXT);		/* we don't want CR/LF, we want Unix-style */
+  setmode (fd, O_TEXT);         /* we don't want CR/LF, we want Unix-style */
 #endif
 
   /* Read the output of the command through the pipe. */
@@ -3366,12 +3556,12 @@
       c = *bufp++;
 
       if (c == 0)
-	{
+        {
 #if 0
-	  internal_warning ("read_comsub: ignored null byte in input");
+          internal_warning ("read_comsub: ignored null byte in input");
 #endif
-	  continue;
-	}
+          continue;
+        }
 
       /* Add the character to ISTRING, possibly after resizing it. */
       RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size, DEFAULT_ARRAY_SIZE);
@@ -3384,10 +3574,10 @@
 #if 0
 #if defined (__CYGWIN__)
       if (c == '\n' && istring_index > 1 && istring[istring_index - 2] == '\r')
-	{
-	  istring_index--;
-	  istring[istring_index - 1] = '\n';
-	}
+        {
+          istring_index--;
+          istring[istring_index - 1] = '\n';
+        }
 #endif
 #endif
     }
@@ -3475,7 +3665,7 @@
   old_pipeline_pgrp = pipeline_pgrp;
   /* Don't reset the pipeline pgrp if we're already a subshell in a pipeline. */
   if ((subshell_environment & SUBSHELL_PIPE) == 0)
-    pipeline_pgrp = shell_pgrp;
+  pipeline_pgrp = shell_pgrp;
   cleanup_the_pipeline ();
 #endif
 
@@ -3537,7 +3727,7 @@
       /* When not in POSIX mode, command substitution does not inherit
          the -e flag. */
       if (posixly_correct == 0)
-	exit_immediately_on_error = 0;
+        exit_immediately_on_error = 0;
 
       remove_quoted_escapes (string);
 
@@ -3598,7 +3788,7 @@
 #else
       if (interactive && pipeline_pgrp != (pid_t)0 && (subshell_environment & SUBSHELL_ASYNC) == 0)
 #endif
-	give_terminal_to (pipeline_pgrp, 0);
+        give_terminal_to (pipeline_pgrp, 0);
 #endif /* JOB_CONTROL */
 
       return (istring);
@@ -3621,7 +3811,7 @@
   char *t;
   int r, len;
 
-  t = strchr (name, '[');	/* ] */
+  t = xstrchr ((const char *)name, '[');	 /* ] */
   if (t)
     {
       *t = '\0';
@@ -3678,7 +3868,7 @@
   int ind, ni;
   SHELL_VAR *var;
 
-  t = strchr (s, '[');
+  t = xstrchr ((const char *)s, '[');
   ind = t - s;
   ni = skipsubscript (s, ind);
   if (ni <= ind + 1 || s[ni] != ']')
@@ -3689,7 +3879,7 @@
 
   *t = '\0';
   var = find_variable (s);
-  *t++ = '[';		/* ] */
+  *t++ = '[';           /* ] */
 
   if (subp)
     *subp = t;
@@ -3722,14 +3912,14 @@
 	  return ((char *)NULL);
 	}
       else if (array_p (var) == 0)
-	{
-	  l = (WORD_LIST *)NULL;
-	  l = add_string_to_list (value_cell (var), l);
-	}
+        {
+          l = (WORD_LIST *)NULL;
+          l = add_string_to_list (value_cell (var), l);
+        }
       else
-	{
-	  l = array_to_word_list (array_cell (var));
-	  if (l == (WORD_LIST *)NULL)
+        {
+          l = array_to_word_list (array_cell (var));
+          if (l == (WORD_LIST *)NULL)
 	    return ((char *) NULL);
 	}
 
@@ -3954,7 +4144,7 @@
   char *t, *t1, *temp;
   int hasdol;
 
-  temp = (*value == '~' || (strchr (value, '~') && unquoted_substring ("=~", value)))
+  temp = (*value == '~' || (xstrchr ((const char *)value, '~') && unquoted_substring ("=~", value)))
 	? bash_tilde_expand (value)
 	: savestring (value);
 
@@ -3991,8 +4181,8 @@
     {
       /* The brace expansion occurred between double quotes and there was
 	 a $@ in TEMP.  It does not matter if the $@ is quoted, as long as
- 	 it does not expand to anything.  In this case, we want to return
- 	 a quoted empty string. */
+	 it does not expand to anything.  In this case, we want to return
+	 a quoted empty string. */
       temp = xmalloc (2);
       temp[0] = CTLNUL;
       temp[1] = '\0';
@@ -4025,9 +4215,10 @@
 
   if (value && *value)
     {
-      temp = (*value == '~' || (strchr (value, '~') && unquoted_substring ("=~", value)))
-		? bash_tilde_expand (value)
-		: savestring (value);
+      temp = (*value == '~' || (xstrchr ((const char *)value, '~') &&
+	      unquoted_substring ("=~", value)))
+                ? bash_tilde_expand (value)
+                : savestring (value);
 
       l = expand_string (temp, 0);
       FREE (temp);
@@ -4051,9 +4242,9 @@
 valid_length_expression (name)
      char *name;
 {
-  return (name[1] == '\0' ||					/* ${#} */
-	  ((sh_syntaxtab[name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
-	  (isdigit (name[1]) && all_digits (name + 1)) ||	/* ${#11} */
+  return (name[1] == '\0' ||                                    /* ${#} */
+          ((sh_syntaxtab[name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
+          (isdigit (name[1]) && all_digits (name + 1)) ||       /* ${#11} */
 #if defined (ARRAY_VARS)
 	  valid_array_reference (name + 1) ||			/* ${#a[7]} */
 #endif
@@ -4146,8 +4337,8 @@
 /* Skip characters in SUBSTR until DELIM.  SUBSTR is an arithmetic expression,
    so we do some ad-hoc parsing of an arithmetic expression to find
    the first DELIM, instead of using strchr(3).  Two rules:
-	1.  If the substring contains a `(', read until closing `)'.
-	2.  If the substring contains a `?', read past one `:' for each `?'.
+        1.  If the substring contains a `(', read until closing `)'.
+        2.  If the substring contains a `?', read past one `:' for each `?'.
 */
 
 static char *
@@ -4155,40 +4346,50 @@
      char *substr;
      int delim;
 {
-  int skipcol, pcount;
-  char *t;
+  int skipcol, pcount, i;
+
+  DECLARE_STATE;
 
-  for (skipcol = pcount = 0, t = substr; *t; t++)
+  skipcol = pcount = i = 0;
+  while (substr[i])
     {
       /* Balance parens */
-      if (*t == '(')
-	{
-	  pcount++;
-	  continue;
-	}
-      if (*t == ')' && pcount)
+      if (substr[i] == '(')
+        {
+          pcount++;
+	  i++;
+          continue;
+        }
+      if (substr[i] == ')' && pcount)
+        {
+          pcount--;
+	  i++;
+          continue;
+        }
+      if (pcount)
 	{
-	  pcount--;
-	  continue;
+	  SKIP_ONE_CHARACTER(substr, i);
+          continue;
 	}
-      if (pcount)
-	continue;
 
       /* Skip one `:' for each `?' */
-      if (*t == ':' && skipcol)
-	{
-	  skipcol--;
-	  continue;
-	}
-      if (*t == delim)
-	break;
-      if (*t == '?')
-	{
-	  skipcol++;
-	  continue;
-	}
+      if (substr[i] == ':' && skipcol)
+        {
+          skipcol--;
+	  i++;
+          continue;
+        }
+      if (substr[i] == delim)
+        break;
+      if (substr[i] == '?')
+        {
+          skipcol++;
+	  i++;
+          continue;
+        }
+      SKIP_ONE_CHARACTER(substr, i);
     }
-  return t;
+  return (substr + i);
 }
 
 /* Verify and limit the start and end of the desired substring.  If
@@ -4212,11 +4413,11 @@
   /* duplicate behavior of strchr(3) */
   t = skiparith (substr, ':');
   if (*t && *t == ':')
-    *t = '\0'; 
+    *t = '\0';
   else
     t = (char *)0;
 #else
-  t = strchr (substr, ':');
+  t = xstrchr ((const char *)substr, ':');
   if (t)
     *t = '\0';
 #endif
@@ -4369,7 +4570,7 @@
     case VT_ARRAYMEMBER:
       temp = quoted ? quoted_substring (value, e1, e2) : substring (value, e1, e2);
       if (val && vtype == VT_ARRAYMEMBER)
-	free (val);
+        free (val);
       break;
     case VT_POSPARMS:
       temp = pos_params (varname, e1, e2, quoted);
@@ -4451,7 +4652,7 @@
 	  rptr += replen;
 	}
       if (s == e)
-	e++;		/* avoid infinite recursion on zero-length match */
+        e++;            /* avoid infinite recursion on zero-length match */
       str = e;		/* e == end of match */
       if (((mflags & MATCH_GLOBREP) == 0) || mtype != MATCH_ANY)
 	break;
@@ -4682,7 +4883,7 @@
   /* ${#-} is a valid expansion and means to take the length of $-.
      Similarly for ${#?} and ${##}... */
   if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
-	VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
+        VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
     {
       name = xrealloc (name, 3);
       name[1] = c;
@@ -4703,7 +4904,7 @@
      variable that expands to one of the positional parameters. */
   want_indir = *name == '!' &&
     (legal_variable_starter (name[1]) || isdigit (name[1])
-				      || VALID_INDIR_PARAM (name[1]));
+                                      || VALID_INDIR_PARAM (name[1]));
 
   /* Determine the value of this variable. */
 
@@ -4756,15 +4957,15 @@
       x = all_variables_matching_prefix (temp1);
       xlist = argv_to_word_list (x, 1, 0);
       if (string[sindex - 2] == '*')
-	temp = string_list_dollar_star (xlist);
+        temp = string_list_dollar_star (xlist);
       else
-	{
-	  temp = string_list_dollar_at (xlist, quoted);
-	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
-	    *quoted_dollar_atp = 1;
-	  if (contains_dollar_at)
-	    *contains_dollar_at = 1;
-	}
+        {
+          temp = string_list_dollar_at (xlist, quoted);
+          if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
+            *quoted_dollar_atp = 1;
+          if (contains_dollar_at)
+            *contains_dollar_at = 1;
+        }
       free (x);
       free (xlist);
       free (temp1);
@@ -4788,10 +4989,10 @@
 #if defined (ARRAY_VARS)
   if (valid_array_reference (name))
     {
-      temp1 = strchr (name, '[');
+      temp1 = xstrchr ((const char *)name, '[');
       if (temp1 && temp1[1] == '@' && temp1[2] == ']')
 	{
-  	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
+	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
 	    *quoted_dollar_atp = 1;
 	  if (contains_dollar_at)
 	    *contains_dollar_at = 1;
@@ -4893,18 +5094,18 @@
     case '+':
       if (var_is_set && var_is_null == 0)
 	{
-	  /* If the operator is `+', we don't want the value of the named
-	     variable for anything, just the value of the right hand side. */
+          /* If the operator is `+', we don't want the value of the named
+             variable for anything, just the value of the right hand side. */
 
-	  if (c == '+')
-	    {
-	      /* XXX -- if we're double-quoted and the named variable is "$@",
-			we want to turn off any special handling of "$@" --
-			we're not using it, so whatever is on the rhs applies. */
-	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
-		*quoted_dollar_atp = 0;
-	      if (contains_dollar_at)
-		*contains_dollar_at = 0;
+          if (c == '+')
+            {
+              /* XXX -- if we're double-quoted and the named variable is "$@",
+                        we want to turn off any special handling of "$@" --
+                        we're not using it, so whatever is on the rhs applies. */
+              if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
+                *quoted_dollar_atp = 0;
+              if (contains_dollar_at)
+                *contains_dollar_at = 0;
 
 	      FREE (temp);
 	      if (value)
@@ -4938,24 +5139,24 @@
 	  else if (c == '?')
 	    {
 	      parameter_brace_expand_error (name, value);
-	      return (interactive_shell ? &expand_param_error : &expand_param_fatal);
-	    }
-	  else if (c != '+')
-	    {
-	      /* XXX -- if we're double-quoted and the named variable is "$@",
-			we want to turn off any special handling of "$@" --
-			we're not using it, so whatever is on the rhs applies. */
-	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
-		*quoted_dollar_atp = 0;
-	      if (contains_dollar_at)
-		*contains_dollar_at = 0;
-
-	      temp = parameter_brace_expand_rhs (name, value, c, quoted,
-						 quoted_dollar_atp,
-						 contains_dollar_at);
-	    }
-	  free (value);
-	}
+              return (interactive_shell ? &expand_param_error : &expand_param_fatal);
+            }
+          else if (c != '+')
+            {
+              /* XXX -- if we're double-quoted and the named variable is "$@",
+                        we want to turn off any special handling of "$@" --
+                        we're not using it, so whatever is on the rhs applies. */
+              if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
+                *quoted_dollar_atp = 0;
+              if (contains_dollar_at)
+                *contains_dollar_at = 0;
+
+              temp = parameter_brace_expand_rhs (name, value, c, quoted,
+                                                 quoted_dollar_atp,
+                                                 contains_dollar_at);
+            }
+          free (value);
+        }
 
       break;
     }
@@ -5074,7 +5275,7 @@
 	{
 	  /* If the $* is not quoted it is identical to $@ */
 	  temp = string_list_dollar_at (list, quoted);
-	  if (expand_no_split_dollar_star == 0 && contains_dollar_at)
+          if (expand_no_split_dollar_star == 0 && contains_dollar_at)
 	    *contains_dollar_at = 1;
 	}
 
@@ -5119,21 +5320,21 @@
       /* Quoted nulls should be removed if there is anything else
 	 in the string. */
       /* Note that we saw the quoted null so we can add one back at
-	 the end of this function if there are no other characters
-	 in the string, discard TEMP, and go on.  The exception to
-	 this is when we have "${@}" and $1 is '', since $@ needs
-	 special handling. */
+         the end of this function if there are no other characters
+         in the string, discard TEMP, and go on.  The exception to
+         this is when we have "${@}" and $1 is '', since $@ needs
+         special handling. */
       if (temp && QUOTED_NULL (temp))
-	{
-	  if (had_quoted_null_p)
-	    *had_quoted_null_p = 1;
-	  if (*quoted_dollar_at_p == 0)
-	    {
-	      free (temp);
-	      temp = (char *)NULL;
-	    }
-	    
-	}
+        {
+          if (had_quoted_null_p)
+            *had_quoted_null_p = 1;
+          if (*quoted_dollar_at_p == 0)
+            {
+              free (temp);
+              temp = (char *)NULL;
+            }
+
+        }
 
       goto return0;
 
@@ -5326,6 +5527,9 @@
   /* The text of WORD. */
   register char *string;
 
+  /* The size of STRING. */
+  size_t string_size;
+
   /* The index into STRING. */
   int sindex;
 
@@ -5348,6 +5552,8 @@
   char ifscmap[256];
   char twochars[2];
 
+  DECLARE_STATE;
+
   istring = xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
   istring[istring_index = 0] = '\0';
   quoted_dollar_at = had_quoted_null = has_dollar_at = 0;
@@ -5356,6 +5562,7 @@
   string = word->word;
   if (string == 0)
     goto finished_with_string;
+  string_size = strlen (string);
 
   if (contains_dollar_at)
     *contains_dollar_at = 0;
@@ -5387,10 +5594,39 @@
 	  goto finished_with_string;
 
 	case CTLESC:
-	  temp = xmalloc (3);
-	  temp[0] = CTLESC;
-	  temp[1] = c = string[++sindex];
-	  temp[2] = '\0';
+	      sindex++;
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1 && string[sindex])
+	    {
+	      int i;
+	      mbstate_t state_bak;
+	      size_t mblength;
+
+	      state_bak = state;
+	      mblength = mbrlen (string + sindex, string_size - sindex, &state);
+	      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		{
+		  state = state_bak;
+		  mblength = 1;
+		}
+	      mblength = (mblength < 1) ? 1 : mblength;
+
+	      temp = xmalloc (mblength + 2);
+	      temp[0] = CTLESC;
+	      for (i = 0; i < mblength; i++)
+		temp[i + 1] = string[sindex++];
+	      temp[mblength + 1] = '\0';
+
+	      goto add_string;
+	    }
+	  else
+#endif
+	    {
+	      temp = xmalloc (3);
+	      temp[0] = CTLESC;
+	      temp[1] = c = string[sindex];
+	      temp[2] = '\0';
+	    }
 
 dollar_add_string:
 	  if (string[sindex])
@@ -5479,17 +5715,47 @@
 	  c = string[++sindex];
 
 	  if (quoted & Q_HERE_DOCUMENT)
-	    tflag = CBSHDOC;
-	  else if (quoted & Q_DOUBLE_QUOTES)
-	    tflag = CBSDQUOTE;
-	  else
-	    tflag = 0;
+            tflag = CBSHDOC;
+          else if (quoted & Q_DOUBLE_QUOTES)
+            tflag = CBSDQUOTE;
+          else
+            tflag = 0;
 
 
-	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))
+          if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] 
+& tflag) == 0))
 	    {
-	      twochars[0] = '\\';
-	      twochars[1] = c;
+#if HANDLE_MULTIBYTE
+	      if (MB_CUR_MAX > 1)
+		{
+		  int i;
+		  mbstate_t state_bak;
+		  size_t mblength;
+
+		  state_bak = state;
+		  mblength = mbrlen (string + sindex,
+			 string_size - sindex, &state);
+		  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		    {
+		      state = state_bak;
+		      mblength = 1;
+		    }
+		  mblength = (mblength < 1) ? 1 : mblength;
+
+		  temp = xmalloc (mblength + 2);
+		  temp[0] = '\\';
+		  for (i = 0; i < mblength; i++)
+		    temp[i + 1] = string[sindex++];
+		  temp[mblength + 1] = '\0';
+
+		  goto add_string;
+		}
+	      else
+#endif
+		{
+		  twochars[0] = '\\';
+		  twochars[1] = c;
+		}
 	    }
 	  else if (c == 0)
 	    {
@@ -5499,8 +5765,37 @@
 	    }
 	  else
 	    {
-	      twochars[0] = CTLESC;
-	      twochars[1] = c;
+#if HANDLE_MULTIBYTE
+	      if (MB_CUR_MAX > 1)
+		{
+		  int i;
+		  mbstate_t state_bak;
+		  size_t mblength;
+
+		  state_bak = state;
+		  mblength = mbrlen (string + sindex,
+			 string_size - sindex, &state);
+		  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		    {
+		      state = state_bak;
+		      mblength = 1;
+		    }
+		  mblength = (mblength < 1) ? 1 : mblength;
+
+		  temp = xmalloc (mblength + 2);
+		  temp[0] = CTLESC;
+		  for (i = 0; i < mblength; i++)
+		    temp[i + 1] = string[sindex++];
+		  temp[mblength + 1] = '\0';
+
+		  goto add_string;
+		}
+	      else
+#endif
+		{
+		  twochars[0] = CTLESC;
+		  twochars[1] = c;
+		}
 	    }
 
 	  sindex++;
@@ -5525,7 +5820,7 @@
 	     whole word was quoted. */
 	  quoted_state = (t_index == 1 && string[sindex] == '\0')
 			    ? WHOLLY_QUOTED
-	  		    : PARTIALLY_QUOTED;
+			    : PARTIALLY_QUOTED;
 
 	  if (temp && *temp)
 	    {
@@ -5661,7 +5956,7 @@
 	     then the string is wholly quoted. */
 	  quoted_state = (t_index == 1 && string[sindex] == '\0')
 			    ? WHOLLY_QUOTED
-	  		    : PARTIALLY_QUOTED;
+			    : PARTIALLY_QUOTED;
 
 	  /* If all we had was '', it is a null expansion. */
 	  if (*temp == '\0')
@@ -5691,7 +5986,7 @@
 
 	default:
 	  /* This is the fix for " $@ " */
-	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && ifscmap[c]))
+	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && ifscmap[(unsigned char)c]))
 	    {
 	      if (string[sindex])	/* from old goto dollar_add_string */
 		sindex++;
@@ -5702,11 +5997,66 @@
 		}
 	      else
 		{
-		  twochars[0] = CTLESC;
-		  twochars[1] = c;
-		  goto add_twochars;
+#if HANDLE_MULTIBYTE
+		  if (MB_CUR_MAX > 1)
+		    {
+		      int i;
+		      mbstate_t state_bak;
+		      size_t mblength;
+
+		      sindex--;
+		      state_bak = state;
+		      mblength = mbrlen (string + sindex,
+			     string_size - sindex, &state);
+		      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+			{
+			  state = state_bak;
+			  mblength = 1;
+			}
+		      mblength = (mblength < 1) ? 1 : mblength;
+
+		      temp = xmalloc (mblength + 2);
+		      temp[0] = CTLESC;
+		      for (i = 0; i < mblength; i++)
+			temp[i + 1] = string[sindex++];
+		      temp[mblength + 1] = '\0';
+
+		      goto add_string;
+		    }
+		  else
+#endif
+		    {
+		      twochars[0] = CTLESC;
+		      twochars[1] = c;
+		      goto add_twochars;
+		    }
+		}
+	    }
+
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      int i;
+	      mbstate_t state_bak;
+	      size_t mblength;
+
+	      state_bak = state;
+	      mblength = mbrlen (string + sindex, string_size - sindex, &state);
+	      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		{
+		  state = state_bak;
+		  mblength = 1;
 		}
+	      mblength = (mblength < 1) ? 1 : mblength;
+
+	      temp = xmalloc (mblength + 1);
+	      for (i = 0; i < mblength; i++)
+		temp[i] = string[sindex++];
+	      temp[mblength] = '\0';
+
+	      goto add_string;
 	    }
+#endif
 
 	add_character:
 	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 1, istring_size,
@@ -5830,6 +6180,12 @@
   char *r, *result_string, *temp;
   int sindex, tindex, c, dquote;
 
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
+
   /* The result can be no longer than the original string. */
   r = result_string = xmalloc (strlen (string) + 1);
 
@@ -5839,13 +6195,39 @@
 	{
 	case '\\':
 	  c = string[++sindex];
-	  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
+          if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
 	    *r++ = '\\';
 	  /* FALLTHROUGH */
 
 	default:
-	  *r++ = c;
-	  sindex++;
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      mbstate_t state_bak;
+	      size_t mblength;
+
+	      state_bak = state;
+	      mblength = mbrlen (string + sindex, strlen (string + sindex),
+				 &state);
+
+	      if (mblength == (size_t)-2 || mblength == (size_t)-1)
+		{
+		  state = state_bak;
+		  mblength = 1;
+		}
+	      mblength = (mblength < 1) ? 1 : mblength;
+
+	      FASTCOPY(string + sindex, r, mblength);
+
+	      r += mblength;
+	      sindex += mblength;
+	    }
+	  else
+#endif
+	    {
+	      *r++ = c;
+	      sindex++;
+	    }
 	  break;
 
 	case '\'':
@@ -6011,8 +6393,8 @@
   /* Separate out variable assignments at the start of the command.
      Loop invariant: vp->next == lp
      Loop postcondition:
-     	lp = list of words left after assignment statements skipped
-     	tlist = original list of words
+	lp = list of words left after assignment statements skipped
+	tlist = original list of words
   */
   while (lp && (lp->word->flags & W_ASSIGNMENT))
     {
@@ -6249,11 +6631,11 @@
       /* Only do brace expansion if the word has a brace character.  If
 	 not, just add the word list element to BRACES and continue.  In
 	 the common case, at least when running shell scripts, this will
-	 degenerate to a bunch of calls to `strchr', and then what is
+	 degenerate to a bunch of calls to `xstrchr', and then what is
 	 basically a reversal of TLIST into BRACES, which is corrected
 	 by a call to reverse_list () on BRACES when the end of TLIST
 	 is reached. */
-      if (strchr (tlist->word->word, LBRACE))
+      if (xstrchr ((const char *)tlist->word->word, LBRACE))
 	{
 	  expansions = brace_expand (tlist->word->word);
 
@@ -6313,7 +6695,7 @@
       if (temp_string[0] == '~' ||
 	    (((tlist->word->flags & (W_ASSIGNMENT|W_QUOTED)) == W_ASSIGNMENT) &&
 	     posixly_correct == 0 &&
-	     strchr (temp_string, '~') &&
+	     xstrchr ((const char *)temp_string, '~') &&
 	     (unquoted_substring ("=~", temp_string) || unquoted_substring (":~", temp_string))))
 	{
 	  tlist->word->word = bash_tilde_expand (temp_string);
@@ -6335,7 +6717,7 @@
 	  /* Dispose the new list we're building. */
 	  dispose_words (new_list);
 
-	  last_command_exit_value = EXECUTION_FAILURE;
+          last_command_exit_value = EXECUTION_FAILURE;
 	  if (expanded == &expand_word_error)
 	    jump_to_top_level (DISCARD);
 	  else
@@ -6409,13 +6791,13 @@
 		  tint = do_assignment (temp_list->word->word);
 		  /* Variable assignment errors in non-interactive shells
 		     running in Posix.2 mode cause the shell to exit. */
-		  if (tint == 0)
-		    {
-		      last_command_exit_value = EXECUTION_FAILURE;
-		      if (interactive_shell == 0 && posixly_correct)
-			jump_to_top_level (FORCE_EOF);
-		      else
-			jump_to_top_level (DISCARD);
+                  if (tint == 0)
+                    {
+                      last_command_exit_value = EXECUTION_FAILURE;
+                      if (interactive_shell == 0 && posixly_correct)
+                        jump_to_top_level (FORCE_EOF);
+                      else
+                        jump_to_top_level (DISCARD);
 		    }
 		}
 	      dispose_words (subst_assign_varlist);
@@ -6467,13 +6849,13 @@
 	  tint = (*assign_func) (temp_list->word->word);
 	  /* Variable assignment errors in non-interactive shells running
 	     in Posix.2 mode cause the shell to exit. */
-	  if (tint == 0 && assign_func == do_assignment)
-	    {
-	      last_command_exit_value = EXECUTION_FAILURE;
-	      if (interactive_shell == 0 && posixly_correct)
-		jump_to_top_level (FORCE_EOF);
-	      else
-		jump_to_top_level (DISCARD);
+          if (tint == 0 && assign_func == do_assignment)
+            {
+              last_command_exit_value = EXECUTION_FAILURE;
+              if (interactive_shell == 0 && posixly_correct)
+                jump_to_top_level (FORCE_EOF);
+              else
+                jump_to_top_level (DISCARD);
 	    }
 	}
 
diff -ruN bash-2.05.orig/support/mksignames.c bash-2.05/support/mksignames.c
--- bash-2.05.orig/support/mksignames.c	Wed Mar 29 00:12:40 2000
+++ bash-2.05/support/mksignames.c	Thu Jun 21 19:49:20 2001
@@ -19,6 +19,8 @@
    with Bash; see the file COPYING.  If not, write to the Free Software
    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 
+#include <config.h>
+
 #include <stdio.h>
 #include <sys/types.h>
 #include <signal.h>
diff -ruN bash-2.05.orig/support/recho.c bash-2.05/support/recho.c
--- bash-2.05.orig/support/recho.c	Thu Feb 20 02:17:28 1997
+++ bash-2.05/support/recho.c	Mon Apr 16 20:50:58 2001
@@ -21,7 +21,7 @@
 strprint(str)
 char	*str;
 {
-	register char *s;
+	register unsigned char *s;
 
 	for (s = str; s && *s; s++) {
 		if (*s < ' ') {
diff -ruN bash-2.05.orig/variables.c bash-2.05/variables.c
--- bash-2.05.orig/variables.c	Thu Feb 22 03:47:11 2001
+++ bash-2.05/variables.c	Wed Jun 20 16:04:41 2001
@@ -42,6 +42,7 @@
 #include "findcmd.h"
 #include "mailcheck.h"
 #include "input.h"
+#include "xstrchr.h"
 
 #include "builtins/getopt.h"
 #include "builtins/common.h"
@@ -62,6 +63,12 @@
 #  include "pcomplete.h"
 #endif
 
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
 /* Variables used here and defined in other files. */
 extern int posixly_correct;
 extern int variable_context, line_number;
@@ -212,7 +219,7 @@
 #if defined (ARRAY_VARS)
 #  if 0
       /* Array variables may not yet be exported. */
-      else if (*string == '(' && string[1] == '[' && strchr (string, ')'))
+      else if (*string == '(' && string[1] == '[' && xstrchr ((const char *)string, ')'))
 	{
 	  string_length = 1;
 	  temp_string = extract_array_assignment_list (string, &string_length);
@@ -662,7 +669,7 @@
   vv = make_new_array_variable ("BASH_VERSINFO");
   av = array_cell (vv);
   strcpy (d, dist_version);
-  s = strchr (d, '.');
+  s = xstrchr ((const char *)d, '.');
   if (s)
     *s++ = '\0';
   array_add_element (av, 0, d);
@@ -939,7 +946,7 @@
    assign_func is called from bind_variable, if bind_variable discovers
    that the variable being assigned to has such a function.  The function
    is called as
-  	SHELL_VAR *temp = (*(entry->assign_func)) (entry, value)
+	SHELL_VAR *temp = (*(entry->assign_func)) (entry, value)
    and the (SHELL_VAR *)temp is returned as the value of bind_variable.  It
    is usually ENTRY (self).
 
@@ -947,7 +954,7 @@
    the specified dynamic varible.  If this function is NULL, the variable
    is treated as a `normal' shell variable.  If it is not, however, then
    this function is called like this:
-  	tempvar = (*(var->dynamic_value)) (var);
+	tempvar = (*(var->dynamic_value)) (var);
 
    Sometimes `tempvar' will replace the value of `var'.  Other times, the
    shell will simply use the string value.  Pretty object-oriented, huh?
@@ -1786,7 +1793,7 @@
       if (l->word == 0 || l->word->word == 0 || l->word->word[0] == '\0')
 	continue;	/* should not happen, but just in case... */
       /* Don't bother if it doesn't look like [ind]=value */
-      if (l->word->word[0] != '[' || strchr (l->word->word, '=') == 0) /* ] */
+      if (l->word->word[0] != '[' || xstrchr ((const char *)l->word->word, '=') == 0) /* ] */
 	continue;
       s = nword = xmalloc (strlen (l->word->word) * 2 + 1);
       saw_eq = 0;
@@ -1820,7 +1827,7 @@
     return var;
 
   /* If this is called from declare_builtin, value[0] == '(' and
-     strchr(value, ')') != 0.  In this case, we need to extract
+     xstrchr((const char *)value, ')') != 0.  In this case, we need to extract
      the value from between the parens before going on. */
   if (*value == '(')	/*)*/
     {
@@ -2349,12 +2356,53 @@
 {
   int count, c;
 
-  for (count = 1; count && (c = s[++i]); )
+#if HANDLE_MULTIBYTE
+  mbstate_t state, state_bak;
+  size_t strlength, mblength;
+
+  if (MB_CUR_MAX > 1)
     {
-      if (c == '[')
-	count++;
-      else if (c == ']')
-	count--;
+      memset (&state, '\0', sizeof(mbstate_t));
+      strlength = strlen (s) - i;
+      count = 1;
+
+      while(count)
+	{
+	  state_bak = state;
+	  mblength = mbrlen (&(s[i]), strlength, &state);
+
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)
+	    {
+	      state = state_bak;
+	      i++;
+	      strlength--;
+	    }
+	  else if (mblength == (size_t)0)
+	    return i;
+	  else
+	    {
+	      i += mblength;
+	      strlength -= mblength;
+	    }
+
+	  c = s[i];
+
+	  if (c == '[')
+	    count++;
+	  else if (c == ']')
+	    count--;
+	}
+    }
+  else
+#endif
+    {
+      for (count = 1; count && (c = s[++i]); )
+	{
+	  if (c == '[')
+	    count++;
+	  else if (c == ']')
+	    count--;
+	}
     }
   return i;
 }
@@ -2650,7 +2698,7 @@
 	}
 
       temp = name + offset + 1;
-      temp = (strchr (temp, '~') != 0) ? bash_tilde_expand (temp) : savestring (temp);
+      temp = (xstrchr ((const char *)temp, '~') != 0) ? bash_tilde_expand (temp) : savestring (temp);
 
       list = expand_string_unsplit (temp, 0);
       value = string_list (list);
diff -ruN bash-2.05.orig/xstrchr.c bash-2.05/xstrchr.c
--- bash-2.05.orig/xstrchr.c	Thu Jan  1 09:00:00 1970
+++ bash-2.05/xstrchr.c	Fri Aug 24 14:09:21 2001
@@ -0,0 +1,49 @@
+#include <config.h>
+
+#include <stdlib.h> /* for MB_CUR_MAX */
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+/* On some locales, the non-first byte of some multibyte character are as 
+   same number as some ascii character. So legacy strchr() may be returns
+   wrong value . */
+
+char *
+xstrchr (const char *s, int c)
+{
+#if HANDLE_MULTIBYTE
+  if (MB_CUR_MAX > 1)
+    {
+      char *pos = (char *)s;
+      mbstate_t state;
+      size_t strlength, mblength;
+
+      memset (&state, '\0', sizeof(mbstate_t));
+      strlength = strlen (s);
+
+      while (strlength > 0)
+	{
+	  mblength = mbrlen (pos, strlength, &state); 
+
+	  if (mblength == (size_t)-2 ||
+		mblength == (size_t)-1
+		 || mblength == (size_t)0)
+	    mblength = 1;
+
+	  if (c == (unsigned char)*pos)
+	    return pos;
+
+	  strlength -= mblength;
+	  pos += mblength;
+	}
+
+      return (char *)NULL;
+    }
+  else
+#endif
+    return (strchr (s, c));
+}
diff -ruN bash-2.05.orig/xstrchr.h bash-2.05/xstrchr.h
--- bash-2.05.orig/xstrchr.h	Thu Jan  1 09:00:00 1970
+++ bash-2.05/xstrchr.h	Mon Apr 16 20:50:58 2001
@@ -0,0 +1,7 @@
+#ifndef _XSTRCHR_H
+# define _XSTRCHR_H 1
+
+# include "stdc.h"
+
+extern char *xstrchr __P((const char *s, int c));
+#endif /* _XSTRCHR_H */
