diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/Makefile.in bash-2.05/Makefile.in
--- bash-2.05.orig/Makefile.in	Wed Apr  4 04:03:24 2001
+++ bash-2.05/Makefile.in	Wed Apr 18 16:23:12 2001
@@ -253,8 +253,11 @@
 GLOB_DEP = $(GLOB_LIBRARY)
 
 GLOB_SOURCE = $(GLOB_LIBSRC)/glob.c $(GLOB_LIBSRC)/fnmatch.c \
-	      $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h
-GLOB_OBJ    = $(GLOB_LIBDIR)/glob.o $(GLOB_LIBDIR)/fnmatch.o
+	      $(GLOB_LIBSRC)/xmbsrtowcs.c \
+	      $(GLOB_LIBSRC)/glob.h $(GLOB_LIBSRC)/fnmatch.h \
+	      $(GLOB_LIBSRC)/xmbsrtowcs.h  
+GLOB_OBJ    = $(GLOB_LIBDIR)/glob.o $(GLOB_LIBDIR)/fnmatch.o \
+	      $(GLOB_LIBSRC)/xmbsrtowcs.o  
 
 # The source, object and documentation for the GNU Tilde library.
 TILDE_LIBSRC = $(LIBSRC)/tilde
@@ -325,11 +328,11 @@
 	   input.c bashhist.c array.c sig.c pathexp.c \
 	   unwind_prot.c siglist.c bashline.c bracecomp.c error.c \
 	   list.c stringlib.c locale.c findcmd.c redir.c \
-	   pcomplete.c pcomplib.c syntax.c xmalloc.c
+	   pcomplete.c pcomplib.c syntax.c xmalloc.c xstrchr.c
 
 HSOURCES = shell.h flags.h trap.h hashcmd.h hashlib.h jobs.h builtins.h \
 	   general.h variables.h config.h $(ALLOC_HEADERS) alias.h \
-	   quit.h unwind_prot.h syntax.h \
+	   quit.h unwind_prot.h syntax.h xstrchr.h \
 	   command.h input.h error.h bashansi.h dispose_cmd.h make_cmd.h \
 	   subst.h externs.h siglist.h bashhist.h bashline.h bashtypes.h \
 	   array.h sig.h mailcheck.h bashintl.h bashjmp.h ${GRAM_H} \
@@ -351,7 +354,7 @@
 	   trap.o input.o unwind_prot.o pathexp.o sig.o test.o version.o \
 	   alias.o array.o braces.o bracecomp.o bashhist.o bashline.o \
 	   siglist.o list.o stringlib.o locale.o findcmd.o redir.o \
-	   pcomplete.o pcomplib.o syntax.o xmalloc.o
+	   pcomplete.o pcomplib.o syntax.o xmalloc.o xstrchr.o
 
 # Where the source code of the shell builtins resides.
 BUILTIN_SRCDIR=$(srcdir)/builtins
@@ -742,7 +745,7 @@
 eval.o: input.h execute_cmd.h
 execute_cmd.o: config.h bashtypes.h ${BASHINCDIR}/filecntl.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
 execute_cmd.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-execute_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h
+execute_cmd.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 execute_cmd.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 execute_cmd.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 execute_cmd.o: ${BASHINCDIR}/memalloc.h ${GRAM_H} flags.h builtins.h jobs.h quit.h siglist.h
@@ -766,7 +769,7 @@
 flags.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 general.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
 general.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-general.o: general.h bashtypes.h variables.h array.h hashlib.h
+general.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 general.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 general.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 general.o: ${BASHINCDIR}/maxpath.h ${BASHINCDIR}/posixtime.h
@@ -827,7 +830,7 @@
 redir.o: flags.h execute_cmd.h redir.h input.h
 shell.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/filecntl.h
 shell.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-shell.o: general.h bashtypes.h variables.h array.h hashlib.h
+shell.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 shell.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 shell.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 shell.o: flags.h trap.h mailcheck.h builtins.h $(DEFSRC)/common.h
@@ -847,7 +850,7 @@
 stringlib.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 subst.o: config.h bashtypes.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h ${BASHINCDIR}/posixstat.h
 subst.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-subst.o: general.h bashtypes.h variables.h array.h hashlib.h
+subst.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 subst.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 subst.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 subst.o: flags.h jobs.h siglist.h execute_cmd.h ${BASHINCDIR}/filecntl.h trap.h pathexp.h
@@ -855,7 +858,7 @@
 subst.o: bashline.h bashhist.h ${GLOB_LIBSRC}/fnmatch.h
 test.o: bashtypes.h ${BASHINCDIR}/posixstat.h ${BASHINCDIR}/filecntl.h
 test.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-test.o: general.h bashtypes.h variables.h array.h hashlib.h
+test.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 test.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 test.o: make_cmd.h subst.h sig.h pathnames.h externs.h test.h
 test.o: ${DEFSRC}/common.h
@@ -869,7 +872,7 @@
 unwind_prot.o: general.h unwind_prot.h quit.h sig.h
 variables.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
 variables.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-variables.o: general.h bashtypes.h variables.h array.h hashlib.h
+variables.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 variables.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 variables.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 variables.o: flags.h execute_cmd.h mailcheck.h input.h $(DEFSRC)/common.h
@@ -877,6 +880,7 @@
 variables.o: pcomplete.h
 version.o: version.h .build
 xmalloc.o: config.h bashtypes.h ${BASHINCDIR}/ansi_stdlib.h error.h
+xstrchr.o: config.h xstrchr.h
 
 # job control
 
@@ -933,7 +937,7 @@
 bashhist.o: $(GLOB_LIBSRC)/fnmatch.h
 bashline.o: config.h bashtypes.h ${BASHINCDIR}/posixstat.h bashansi.h ${BASHINCDIR}/ansi_stdlib.h
 bashline.o: shell.h syntax.h config.h bashjmp.h ${BASHINCDIR}/posixjmp.h command.h ${BASHINCDIR}/stdc.h error.h
-bashline.o: general.h bashtypes.h variables.h array.h hashlib.h
+bashline.o: general.h bashtypes.h variables.h array.h hashlib.h xstrchr.h
 bashline.o: quit.h ${BASHINCDIR}/maxpath.h unwind_prot.h dispose_cmd.h
 bashline.o: make_cmd.h subst.h sig.h pathnames.h externs.h
 bashline.o: builtins.h bashhist.h bashline.h execute_cmd.h findcmd.h pathexp.h
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/alias.c bash-2.05/alias.c
--- bash-2.05.orig/alias.c	Thu Aug  5 20:17:24 1999
+++ bash-2.05/alias.c	Wed Apr 18 16:23:12 2001
@@ -36,6 +36,7 @@
 #include "general.h"
 #include "externs.h"
 #include "alias.h"
+#include "xstrchr.h"
 
 #if defined (PROGRAMMABLE_COMPLETION)
 #  include "pcomplete.h"
@@ -513,7 +514,7 @@
       /* If there is a backslash-escaped character quoted in TOKEN,
 	 then we don't do alias expansion.  This should check for all
 	 other quoting characters, too. */
-      if (strchr (token, '\\'))
+      if (xstrchr ((const char *)token, '\\'))
 	expand_this_token = 0;
 
       /* If we should be expanding here, if we are expanding all words, or if
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/bashline.c bash-2.05/bashline.c
--- bash-2.05.orig/bashline.c	Wed Mar  7 03:36:07 2001
+++ bash-2.05/bashline.c	Wed Apr 18 16:23:12 2001
@@ -42,6 +42,7 @@
 #include <readline/rlconf.h>
 #include <readline/readline.h>
 #include <readline/history.h>
+#include "xstrchr.h"
 
 #include <glob/glob.h>
 
@@ -920,7 +921,7 @@
 
   /* If the word starts in `~', and there is no slash in the word, then
      try completing this word as a username. */
-  if (!matches && *text == '~' && !strchr (text, '/'))
+  if (!matches && *text == '~' && !xstrchr ((const char *)text, '/'))
     matches = rl_completion_matches (text, rl_username_completion_function);
 
   /* Another one.  Why not?  If the word starts in '@', then look through
@@ -1835,13 +1836,13 @@
   local_dirname = *dirname;
 
 #if 0
-  should_expand_dirname = strchr (local_dirname, '$') || strchr (local_dirname, '`');
+  should_expand_dirname = xstrchr ((const char *)local_dirname, '$') || xstrchr ((const char *)local_dirname, '`');
 #else
-  if (strchr (local_dirname, '$'))
+  if (xstrchr ((const char *)local_dirname, '$'))
     should_expand_dirname = 1;
   else
     {
-      t = strchr (local_dirname, '`');
+      t = xstrchr ((const char *)local_dirname, '`');
       if (t && unclosed_pair (local_dirname, strlen (local_dirname), "`") == 0)
 	should_expand_dirname = 1;
     }
@@ -2269,7 +2270,7 @@
 	}
       /* OK, we have an unquoted character.  Check its presence in
 	 rl_completer_word_break_characters. */
-      if (strchr (rl_completer_word_break_characters, *s))
+      if (xstrchr ((const char *)rl_completer_word_break_characters, *s))
 	*r++ = '\\';
       *r++ = *s;
     }
@@ -2311,7 +2312,7 @@
      the word being completed contains newlines, since those are not
      quoted correctly using backslashes (a backslash-newline pair is
      special to the shell parser). */
-  if (*qcp == '\0' && cs == COMPLETE_BSQUOTE && strchr (mtext, '\n'))
+  if (*qcp == '\0' && cs == COMPLETE_BSQUOTE && xstrchr ((const char *)mtext, '\n'))
     cs = COMPLETE_SQUOTE;
   else if (*qcp == '"')
     cs = COMPLETE_DQUOTE;
@@ -2319,11 +2320,11 @@
     cs = COMPLETE_SQUOTE;
 #if defined (BANG_HISTORY)
   else if (*qcp == '\0' && history_expansion && cs == COMPLETE_DQUOTE &&
-	   history_expansion_inhibited == 0 && strchr (mtext, '!'))
+	   history_expansion_inhibited == 0 && xstrchr ((const char *)mtext, '!'))
     cs = COMPLETE_BSQUOTE;
 
   if (*qcp == '"' && history_expansion && cs == COMPLETE_DQUOTE &&
-	history_expansion_inhibited == 0 && strchr (mtext, '!'))
+	history_expansion_inhibited == 0 && xstrchr ((const char *)mtext, '!'))
     {
       cs = COMPLETE_BSQUOTE;
       *qcp = '\0';
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/braces.c bash-2.05/braces.c
--- bash-2.05.orig/braces.c	Thu Feb 15 06:51:23 2001
+++ bash-2.05/braces.c	Wed Apr 18 16:23:12 2001
@@ -44,6 +44,77 @@
 extern char *extract_command_subst ();
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrlen(s, n, ps) (mbrlen) (s, n, 0)
+#endif
+
+#if defined STDC_HEADERS
+# include <stdlib.h>
+#endif
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+/* Declare mbstate_t state, and creat in initial state. */
+#if HANDLE_MULTIBYTE
+# define DECLARE_STATE                                                  \
+  mbstate_t state;                                                      \
+  memset (&state, '\0', sizeof(mbstate_t))
+#else
+# define DECLARE_STATE
+#endif
+
+/* Initialize state. */
+#if HANDLE_MULTIBYTE
+# define INITIALIZE_STATE memset (&state, '\0', sizeof(mbstate_t))
+#else
+# define INITIALIZE_STATE
+#endif
+
+/* Skip one character, that character is unibyte or multibyte. */
+#if HANDLE_MULTIBYTE
+# define SKIP_ONE_CHARACTER(_string, _i)                                \
+   do                                                                   \
+    {                                                                   \
+      if(MB_CUR_MAX > 1)                                                \
+	{                                                               \
+	  mbstate_t state_bak;                                          \
+	  size_t mblength;                                              \
+									\
+	  state_bak = state;                                            \
+	  mblength = mbrlen(_string + _i, strlen(_string + _i), &state);  \
+									\
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)         \
+	    {                                                           \
+	      state = state_bak;                                        \
+	      _i++;                                                     \
+	    }                                                           \
+	  else                                                          \
+	      _i += mblength;                                           \
+	}                                                               \
+      else                                                              \
+	_i++;                                                           \
+    } while(0)
+#else
+# define SKIP_ONE_CHARACTER(_string, _i) _i++
+#endif
+
 /* Basic idea:
 
    Segregate the text into 3 sections: preamble (stuff before an open brace),
@@ -69,6 +140,8 @@
   char **tack, **result;
   int i, j, c;
 
+  DECLARE_STATE;
+
   /* Find the text of the preamble. */
   i = 0;
   c = brace_gobbler (text, &i, '{');
@@ -96,11 +169,13 @@
 #if defined (NOTDEF)
       /* Well, if we found an unquoted BRACE_ARG_SEPARATOR between START
 	 and I, then this should be an error.  Otherwise, it isn't. */
-      for (j = start; j < i; j++)
+      j = start;
+      while (j < i)
 	{
 	  if (text[j] == '\\')
 	    {
 	      j++;
+	      SKIP_ONE_CHARACTER(text, j);
 	      continue;
 	    }
 
@@ -110,6 +185,7 @@
 	      report_error ("missing `}'");
 	      throw_to_top_level ();
 	    }
+	  SKIP_ONE_CHARACTER(text, j);
 	}
 #endif
       free (preamble);		/* Same as result[0]; see initialization. */
@@ -126,17 +202,22 @@
 #endif
 
 #if defined (SHELL)
+  INITIALIZE_STATE;
+
   /* If the amble does not contain an unquoted BRACE_ARG_SEPARATOR, then
      just return without doing any expansion.  */
-  for (j = 0; amble[j]; j++)
+  j = 0;
+  while (amble[j])
     {
       if (amble[j] == '\\')
 	{
 	  j++;
+	  SKIP_ONE_CHARACTER(text, j);
 	  continue;
 	}
       if (amble[j] == brace_arg_separator)
 	break;
+      SKIP_ONE_CHARACTER(text, j);
     }
 
   if (!amble[j])
@@ -174,9 +255,12 @@
   char *tem;
   int start, i, c;
 
+  DECLARE_STATE;
+
   result = (char **)NULL;
 
-  for (start = 0, i = 0, c = 1; c; start = ++i)
+  start = 0;  i = 0;  c = 1;
+  while (c)
     {
       c = brace_gobbler (text, &i, brace_arg_separator);
 #if defined (SHELL)
@@ -206,6 +290,8 @@
 	  free (partial);
 	}
       free (tem);
+      SKIP_ONE_CHARACTER(text, i);
+      start = i;
     }
   return (result);
 }
@@ -226,13 +312,17 @@
   char *t;
 #endif
 
+  DECLARE_STATE;
+
   level = quoted = pass_next = 0;
 
-  for (i = *indx; c = text[i]; i++)
+  i = *indx;
+  while (c = text[i])
     {
       if (pass_next)
 	{
 	  pass_next = 0;
+	  SKIP_ONE_CHARACTER(text, i);
 	  continue;
 	}
 
@@ -241,6 +331,7 @@
       if (c == '\\' && (quoted == 0 || quoted == '"' || quoted == '`'))
 	{
 	  pass_next = 1;
+	  i++;
 	  continue;
 	}
 
@@ -248,12 +339,14 @@
 	{
 	  if (c == quoted)
 	    quoted = 0;
+	  SKIP_ONE_CHARACTER(text, i);
 	  continue;
 	}
 
       if (c == '"' || c == '\'' || c == '`')
 	{
 	  quoted = c;
+	  i++;
 	  continue;
 	}
 
@@ -265,6 +358,7 @@
 	  t = extract_command_subst (text, &si);
 	  i = si;
 	  free (t);
+	  i++;
 	  continue;
 	}
 #endif
@@ -277,7 +371,10 @@
 	  if (c == '{' &&
 	      ((!i || brace_whitespace (text[i - 1])) &&
 	       (brace_whitespace (text[i + 1]) || text[i + 1] == '}')))
-	    continue;
+	    {
+	      i++;
+	      continue;
+	    }
 #if defined (SHELL)
 	  /* If this is being compiled as part of bash, ignore the `{'
 	     in a `${}' construct */
@@ -290,6 +387,8 @@
 	level++;
       else if (c == '}' && level)
 	level--;
+
+      SKIP_ONE_CHARACTER(text, i);
     }
 
   *indx = i;
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/config.h.in bash-2.05/config.h.in
--- bash-2.05.orig/config.h.in	Mon Oct  2 22:44:22 2000
+++ bash-2.05/config.h.in	Wed Apr 18 16:15:41 2001
@@ -699,4 +699,12 @@
 
 #include "config-bot.h"
 
+/* for multibyte character handling*/
+#undef HAVE_WCTYPE_H
+#undef HAVE_WCHAR_H
+#undef HAVE_MBSRTOWCS
+#undef HAVE_MBRLEN
+#undef HAVE_MBSTATE_T
+
+
 #endif /* _CONFIG_H_ */
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/configure bash-2.05/configure
--- bash-2.05.orig/configure	Wed Jan 24 02:57:28 2001
+++ bash-2.05/configure	Wed Apr 18 16:17:43 2001
@@ -1185,7 +1185,7 @@
 
 
 BASHVERS=2.05
-BASHPATCH=0
+BASHPATCH=1
 
 echo "Beginning configuration for bash-$BASHVERS for ${host_cpu}-${host_vendor}-${host_os}"
 
@@ -3242,9 +3242,222 @@
 done
 
 
+for ac_hdr in wctype.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:3250: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3255 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:3260: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_hdr in wchar.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:3290: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3295 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:3300: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+echo $ac_n "checking for mbsrtowcs""... $ac_c" 1>&6
+echo "configure:3327: checking for mbsrtowcs" >&5
+if eval "test \"`echo '$''{'ac_cv_func_mbsrtowcs'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3332 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char mbsrtowcs(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char mbsrtowcs();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_mbsrtowcs) || defined (__stub___mbsrtowcs)
+choke me
+#else
+mbsrtowcs();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:3355: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_mbsrtowcs=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_mbsrtowcs=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'mbsrtowcs`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  cat >> confdefs.h <<\EOF
+#define HAVE_MBSRTOWCS 1
+EOF
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+echo $ac_n "checking for mbrlen""... $ac_c" 1>&6
+echo "configure:3378: checking for mbrlen" >&5
+if eval "test \"`echo '$''{'ac_cv_func_mbrlen'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3383 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char mbrlen(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char mbrlen();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_mbrlen) || defined (__stub___mbrlen)
+choke me
+#else
+mbrlen();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:3406: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_mbrlen=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_mbrlen=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'mbrlen`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  cat >> confdefs.h <<\EOF
+#define HAVE_MBRLEN 1
+EOF
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3432 "configure"
+#include "confdefs.h"
+
+#include <wchar.h>
+
+int
+main ()
+{
+  mbstate_t ps;
+  return 0;
+}
+EOF
+if { (eval echo configure:3444: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  cat >> confdefs.h <<\EOF
+#define HAVE_MBSTATE_T 1
+EOF
+
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+fi
+rm -fr conftest*
+fi
+
+
+
 if test "$ac_cv_func_bindtextdomain" = "no"; then
     echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
-echo "configure:3248: checking for bindtextdomain in -lintl" >&5
+echo "configure:3461: checking for bindtextdomain in -lintl" >&5
 ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3252,7 +3465,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lintl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3256 "configure"
+#line 3469 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3263,7 +3476,7 @@
 bindtextdomain()
 ; return 0; }
 EOF
-if { (eval echo configure:3267: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3480: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3294,12 +3507,12 @@
 	for ac_func in gettext textdomain bindtextdomain
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3298: checking for $ac_func" >&5
+echo "configure:3511: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3303 "configure"
+#line 3516 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3322,7 +3535,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:3326: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3539: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -3351,7 +3564,7 @@
 
 if test "$opt_static_link" != yes; then
 echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:3355: checking for dlopen in -ldl" >&5
+echo "configure:3568: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3359,7 +3572,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3363 "configure"
+#line 3576 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3370,7 +3583,7 @@
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:3374: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3587: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3400,12 +3613,12 @@
 for ac_func in dlopen dlclose dlsym
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3404: checking for $ac_func" >&5
+echo "configure:3617: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3409 "configure"
+#line 3622 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3428,7 +3641,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:3432: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3645: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -3455,12 +3668,12 @@
 fi
 
 echo $ac_n "checking for sys_siglist declaration in signal.h or unistd.h""... $ac_c" 1>&6
-echo "configure:3459: checking for sys_siglist declaration in signal.h or unistd.h" >&5
+echo "configure:3672: checking for sys_siglist declaration in signal.h or unistd.h" >&5
 if eval "test \"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3464 "configure"
+#line 3677 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -3472,7 +3685,7 @@
 char *msg = *(sys_siglist + 1);
 ; return 0; }
 EOF
-if { (eval echo configure:3476: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3689: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_decl_sys_siglist=yes
 else
@@ -3498,12 +3711,12 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:3502: checking for $ac_hdr that defines DIR" >&5
+echo "configure:3715: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3507 "configure"
+#line 3720 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
@@ -3511,7 +3724,7 @@
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:3515: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3728: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
@@ -3536,7 +3749,7 @@
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:3540: checking for opendir in -ldir" >&5
+echo "configure:3753: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3544,7 +3757,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3548 "configure"
+#line 3761 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3555,7 +3768,7 @@
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:3559: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3772: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3577,7 +3790,7 @@
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:3581: checking for opendir in -lx" >&5
+echo "configure:3794: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3585,7 +3798,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3589 "configure"
+#line 3802 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3596,7 +3809,7 @@
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:3600: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3813: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3619,12 +3832,12 @@
 fi
 
 echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
-echo "configure:3623: checking whether time.h and sys/time.h may both be included" >&5
+echo "configure:3836: checking whether time.h and sys/time.h may both be included" >&5
 if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3628 "configure"
+#line 3841 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/time.h>
@@ -3633,7 +3846,7 @@
 struct tm *tp;
 ; return 0; }
 EOF
-if { (eval echo configure:3637: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3850: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_time=yes
 else
@@ -3660,17 +3873,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3664: checking for $ac_hdr" >&5
+echo "configure:3877: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3669 "configure"
+#line 3882 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3674: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3887: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3702,17 +3915,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3706: checking for $ac_hdr" >&5
+echo "configure:3919: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3711 "configure"
+#line 3924 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3716: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3929: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3742,17 +3955,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3746: checking for $ac_hdr" >&5
+echo "configure:3959: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3751 "configure"
+#line 3964 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3756: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3969: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3782,12 +3995,12 @@
 if test "$ac_cv_func_inet_aton" != 'yes'; then
 
 echo $ac_n "checking for inet_aton""... $ac_c" 1>&6
-echo "configure:3786: checking for inet_aton" >&5
+echo "configure:3999: checking for inet_aton" >&5
 if eval "test \"`echo '$''{'bash_cv_func_inet_aton'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3791 "configure"
+#line 4004 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -3798,7 +4011,7 @@
  inet_aton("127.0.0.1", &ap); 
 ; return 0; }
 EOF
-if { (eval echo configure:3802: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4015: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_func_inet_aton=yes
 else
@@ -3822,7 +4035,7 @@
 
 case "$host_os" in
 irix4*)	echo $ac_n "checking for getpwent in -lsun""... $ac_c" 1>&6
-echo "configure:3826: checking for getpwent in -lsun" >&5
+echo "configure:4039: checking for getpwent in -lsun" >&5
 ac_lib_var=`echo sun'_'getpwent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3830,7 +4043,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsun  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3834 "configure"
+#line 4047 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3841,7 +4054,7 @@
 getpwent()
 ; return 0; }
 EOF
-if { (eval echo configure:3845: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4058: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3876,14 +4089,14 @@
 _bash_needmsg=
 else
 echo $ac_n "checking for socket library""... $ac_c" 1>&6
-echo "configure:3880: checking for socket library" >&5
+echo "configure:4093: checking for socket library" >&5
 _bash_needmsg=yes
 fi
 if eval "test \"`echo '$''{'bash_cv_have_socklib'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo $ac_n "checking for getpeername in -lsocket""... $ac_c" 1>&6
-echo "configure:3887: checking for getpeername in -lsocket" >&5
+echo "configure:4100: checking for getpeername in -lsocket" >&5
 ac_lib_var=`echo socket'_'getpeername | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3891,7 +4104,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket -lnsl $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3895 "configure"
+#line 4108 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3902,7 +4115,7 @@
 getpeername()
 ; return 0; }
 EOF
-if { (eval echo configure:3906: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4119: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3935,14 +4148,14 @@
     _bash_needmsg=
   else
     echo $ac_n "checking for libnsl""... $ac_c" 1>&6
-echo "configure:3939: checking for libnsl" >&5
+echo "configure:4152: checking for libnsl" >&5
     _bash_needmsg=yes
   fi
   if eval "test \"`echo '$''{'bash_cv_have_libnsl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo $ac_n "checking for t_open in -lnsl""... $ac_c" 1>&6
-echo "configure:3946: checking for t_open in -lnsl" >&5
+echo "configure:4159: checking for t_open in -lnsl" >&5
 ac_lib_var=`echo nsl'_'t_open | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3950,7 +4163,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3954 "configure"
+#line 4167 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3961,7 +4174,7 @@
 t_open()
 ; return 0; }
 EOF
-if { (eval echo configure:3965: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4178: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4009,14 +4222,14 @@
 _bash_needmsg=yes
 else
 echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
-echo "configure:4013: checking for gethostbyname in socket library" >&5
+echo "configure:4226: checking for gethostbyname in socket library" >&5
 _bash_needmsg=
 fi
 if eval "test \"`echo '$''{'bash_cv_have_gethostbyname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4020 "configure"
+#line 4233 "configure"
 #include "confdefs.h"
 #include <netdb.h>
 int main() {
@@ -4025,7 +4238,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:4029: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4242: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_have_gethostbyname=yes
 else
@@ -4040,7 +4253,7 @@
 
 if test "X$_bash_needmsg" = Xyes; then
     echo $ac_n "checking for gethostbyname in socket library""... $ac_c" 1>&6
-echo "configure:4044: checking for gethostbyname in socket library" >&5
+echo "configure:4257: checking for gethostbyname in socket library" >&5
 fi
 echo "$ac_t""$bash_cv_have_gethostbyname" 1>&6
 if test "$bash_cv_have_gethostbyname" = yes; then
@@ -4053,12 +4266,12 @@
 fi
 
 echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:4057: checking for uid_t in sys/types.h" >&5
+echo "configure:4270: checking for uid_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4062 "configure"
+#line 4275 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 EOF
@@ -4087,7 +4300,7 @@
 fi
 
 echo $ac_n "checking type of array argument to getgroups""... $ac_c" 1>&6
-echo "configure:4091: checking type of array argument to getgroups" >&5
+echo "configure:4304: checking type of array argument to getgroups" >&5
 if eval "test \"`echo '$''{'ac_cv_type_getgroups'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4095,7 +4308,7 @@
   ac_cv_type_getgroups=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 4099 "configure"
+#line 4312 "configure"
 #include "confdefs.h"
 
 /* Thanks to Mike Rendell for this test.  */
@@ -4120,7 +4333,7 @@
 }
 
 EOF
-if { (eval echo configure:4124: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4337: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
     ac_cv_type_getgroups=gid_t
 else
@@ -4134,7 +4347,7 @@
 
 if test $ac_cv_type_getgroups = cross; then
         cat > conftest.$ac_ext <<EOF
-#line 4138 "configure"
+#line 4351 "configure"
 #include "confdefs.h"
 #include <unistd.h>
 EOF
@@ -4158,12 +4371,12 @@
 
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:4162: checking for ANSI C header files" >&5
+echo "configure:4375: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4167 "configure"
+#line 4380 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
@@ -4171,7 +4384,7 @@
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4175: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4388: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4188,7 +4401,7 @@
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 4192 "configure"
+#line 4405 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -4206,7 +4419,7 @@
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 4210 "configure"
+#line 4423 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -4227,7 +4440,7 @@
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 4231 "configure"
+#line 4444 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -4238,7 +4451,7 @@
 exit (0); }
 
 EOF
-if { (eval echo configure:4242: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4455: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -4262,12 +4475,12 @@
 fi
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:4266: checking for off_t" >&5
+echo "configure:4479: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4271 "configure"
+#line 4484 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4295,12 +4508,12 @@
 fi
 
 echo $ac_n "checking for mode_t""... $ac_c" 1>&6
-echo "configure:4299: checking for mode_t" >&5
+echo "configure:4512: checking for mode_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4304 "configure"
+#line 4517 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4328,12 +4541,12 @@
 fi
 
 echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:4332: checking for uid_t in sys/types.h" >&5
+echo "configure:4545: checking for uid_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4337 "configure"
+#line 4550 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 EOF
@@ -4362,12 +4575,12 @@
 fi
 
 echo $ac_n "checking for pid_t""... $ac_c" 1>&6
-echo "configure:4366: checking for pid_t" >&5
+echo "configure:4579: checking for pid_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4371 "configure"
+#line 4584 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4395,12 +4608,12 @@
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:4399: checking for size_t" >&5
+echo "configure:4612: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4404 "configure"
+#line 4617 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4428,12 +4641,12 @@
 fi
 
 echo $ac_n "checking for time_t""... $ac_c" 1>&6
-echo "configure:4432: checking for time_t" >&5
+echo "configure:4645: checking for time_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_time_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4437 "configure"
+#line 4650 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4462,12 +4675,12 @@
 
 
 echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
-echo "configure:4466: checking return type of signal handlers" >&5
+echo "configure:4679: checking return type of signal handlers" >&5
 if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4471 "configure"
+#line 4684 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -4484,7 +4697,7 @@
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:4488: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4701: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_type_signal=void
 else
@@ -4504,7 +4717,7 @@
 
 
 echo $ac_n "checking size of char""... $ac_c" 1>&6
-echo "configure:4508: checking size of char" >&5
+echo "configure:4721: checking size of char" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4512,9 +4725,10 @@
   ac_cv_sizeof_char=1
 else
   cat > conftest.$ac_ext <<EOF
-#line 4516 "configure"
+#line 4729 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4523,7 +4737,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4527: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4741: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_char=`cat conftestval`
 else
@@ -4543,7 +4757,7 @@
 
 
 echo $ac_n "checking size of short""... $ac_c" 1>&6
-echo "configure:4547: checking size of short" >&5
+echo "configure:4761: checking size of short" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4551,9 +4765,10 @@
   ac_cv_sizeof_short=2
 else
   cat > conftest.$ac_ext <<EOF
-#line 4555 "configure"
+#line 4769 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4562,7 +4777,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4566: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4781: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_short=`cat conftestval`
 else
@@ -4582,7 +4797,7 @@
 
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:4586: checking size of int" >&5
+echo "configure:4801: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4590,9 +4805,10 @@
   ac_cv_sizeof_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 4594 "configure"
+#line 4809 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4601,7 +4817,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4605: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4821: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -4621,7 +4837,7 @@
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:4625: checking size of long" >&5
+echo "configure:4841: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4629,9 +4845,10 @@
   ac_cv_sizeof_long=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 4633 "configure"
+#line 4849 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4640,7 +4857,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4644: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4861: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -4660,7 +4877,7 @@
 
 
 echo $ac_n "checking size of char *""... $ac_c" 1>&6
-echo "configure:4664: checking size of char *" >&5
+echo "configure:4881: checking size of char *" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_char_p'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4668,9 +4885,10 @@
   ac_cv_sizeof_char_p=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 4672 "configure"
+#line 4889 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4679,7 +4897,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4683: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4901: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_char_p=`cat conftestval`
 else
@@ -4699,7 +4917,7 @@
 
 
 echo $ac_n "checking size of double""... $ac_c" 1>&6
-echo "configure:4703: checking size of double" >&5
+echo "configure:4921: checking size of double" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_double'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4707,9 +4925,10 @@
   ac_cv_sizeof_double=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 4711 "configure"
+#line 4929 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <sys/types.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -4718,7 +4937,7 @@
   exit(0);
 }
 EOF
-if { (eval echo configure:4722: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4941: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_double=`cat conftestval`
 else
@@ -4739,12 +4958,12 @@
 
 
 echo $ac_n "checking for u_int""... $ac_c" 1>&6
-echo "configure:4743: checking for u_int" >&5
+echo "configure:4962: checking for u_int" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4748 "configure"
+#line 4967 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4772,12 +4991,12 @@
 fi
 
 echo $ac_n "checking for u_long""... $ac_c" 1>&6
-echo "configure:4776: checking for u_long" >&5
+echo "configure:4995: checking for u_long" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4781 "configure"
+#line 5000 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4808,12 +5027,12 @@
 
 if test "$ac_cv_sizeof_short" = 2; then
   echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
-echo "configure:4812: checking for bits16_t" >&5
+echo "configure:5031: checking for bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4817 "configure"
+#line 5036 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4842,12 +5061,12 @@
 
 elif test "$ac_cv_sizeof_char" = 2; then
   echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
-echo "configure:4846: checking for bits16_t" >&5
+echo "configure:5065: checking for bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4851 "configure"
+#line 5070 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4876,12 +5095,12 @@
 
 else
   echo $ac_n "checking for bits16_t""... $ac_c" 1>&6
-echo "configure:4880: checking for bits16_t" >&5
+echo "configure:5099: checking for bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4885 "configure"
+#line 5104 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4913,12 +5132,12 @@
 
 if test "$ac_cv_sizeof_short" = 2; then
   echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
-echo "configure:4917: checking for u_bits16_t" >&5
+echo "configure:5136: checking for u_bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4922 "configure"
+#line 5141 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4947,12 +5166,12 @@
 
 elif test "$ac_cv_sizeof_char" = 2; then
   echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
-echo "configure:4951: checking for u_bits16_t" >&5
+echo "configure:5170: checking for u_bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4956 "configure"
+#line 5175 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -4981,12 +5200,12 @@
 
 else
   echo $ac_n "checking for u_bits16_t""... $ac_c" 1>&6
-echo "configure:4985: checking for u_bits16_t" >&5
+echo "configure:5204: checking for u_bits16_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits16_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4990 "configure"
+#line 5209 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5018,12 +5237,12 @@
 
 if test "$ac_cv_sizeof_int" = 4; then
   echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
-echo "configure:5022: checking for bits32_t" >&5
+echo "configure:5241: checking for bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5027 "configure"
+#line 5246 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5052,12 +5271,12 @@
 
 elif test "$ac_cv_sizeof_long" = 4; then
   echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
-echo "configure:5056: checking for bits32_t" >&5
+echo "configure:5275: checking for bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5061 "configure"
+#line 5280 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5086,12 +5305,12 @@
 
 else
   echo $ac_n "checking for bits32_t""... $ac_c" 1>&6
-echo "configure:5090: checking for bits32_t" >&5
+echo "configure:5309: checking for bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5095 "configure"
+#line 5314 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5123,12 +5342,12 @@
 
 if test "$ac_cv_sizeof_int" = 4; then
   echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
-echo "configure:5127: checking for u_bits32_t" >&5
+echo "configure:5346: checking for u_bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5132 "configure"
+#line 5351 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5157,12 +5376,12 @@
 
 elif test "$ac_cv_sizeof_long" = 4; then
   echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
-echo "configure:5161: checking for u_bits32_t" >&5
+echo "configure:5380: checking for u_bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5166 "configure"
+#line 5385 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5191,12 +5410,12 @@
 
 else
   echo $ac_n "checking for u_bits32_t""... $ac_c" 1>&6
-echo "configure:5195: checking for u_bits32_t" >&5
+echo "configure:5414: checking for u_bits32_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_u_bits32_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5200 "configure"
+#line 5419 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5228,12 +5447,12 @@
 
 if test "$ac_sv_sizeof_char_p" = 8; then
   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
-echo "configure:5232: checking for bits64_t" >&5
+echo "configure:5451: checking for bits64_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5237 "configure"
+#line 5456 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5262,12 +5481,12 @@
 
 elif test "$ac_cv_sizeof_double" = 8; then
   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
-echo "configure:5266: checking for bits64_t" >&5
+echo "configure:5485: checking for bits64_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5271 "configure"
+#line 5490 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5296,12 +5515,12 @@
 
 elif test "$ac_cv_sizeof_long" = 8; then
   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
-echo "configure:5300: checking for bits64_t" >&5
+echo "configure:5519: checking for bits64_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5305 "configure"
+#line 5524 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5330,12 +5549,12 @@
 
 else
   echo $ac_n "checking for bits64_t""... $ac_c" 1>&6
-echo "configure:5334: checking for bits64_t" >&5
+echo "configure:5553: checking for bits64_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_bits64_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5339 "configure"
+#line 5558 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5368,12 +5587,12 @@
 
 if test "$ac_cv_sizeof_int" = "$ac_cv_sizeof_char_p"; then
   echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
-echo "configure:5372: checking for ptrdiff_t" >&5
+echo "configure:5591: checking for ptrdiff_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5377 "configure"
+#line 5596 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5402,12 +5621,12 @@
 
 elif test "$ac_cv_sizeof_long" = "$ac_cv_sizeof_char_p"; then
   echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
-echo "configure:5406: checking for ptrdiff_t" >&5
+echo "configure:5625: checking for ptrdiff_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5411 "configure"
+#line 5630 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5436,12 +5655,12 @@
 
 else
   echo $ac_n "checking for ptrdiff_t""... $ac_c" 1>&6
-echo "configure:5440: checking for ptrdiff_t" >&5
+echo "configure:5659: checking for ptrdiff_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ptrdiff_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5445 "configure"
+#line 5664 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -5472,12 +5691,12 @@
 
 
 echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&6
-echo "configure:5476: checking whether stat file-mode macros are broken" >&5
+echo "configure:5695: checking whether stat file-mode macros are broken" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stat_broken'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5481 "configure"
+#line 5700 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -5529,14 +5748,14 @@
 
 
 echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
-echo "configure:5533: checking whether byte ordering is bigendian" >&5
+echo "configure:5752: checking whether byte ordering is bigendian" >&5
 if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_bigendian=unknown
 # See if sys/param.h defines the BYTE_ORDER macro.
 cat > conftest.$ac_ext <<EOF
-#line 5540 "configure"
+#line 5759 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -5547,11 +5766,11 @@
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:5551: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5770: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat > conftest.$ac_ext <<EOF
-#line 5555 "configure"
+#line 5774 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -5562,7 +5781,7 @@
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:5566: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5785: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_bigendian=yes
 else
@@ -5582,7 +5801,7 @@
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 5586 "configure"
+#line 5805 "configure"
 #include "confdefs.h"
 main () {
   /* Are we little or big endian?  From Harbison&Steele.  */
@@ -5595,7 +5814,7 @@
   exit (u.c[sizeof (long) - 1] == 1);
 }
 EOF
-if { (eval echo configure:5599: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:5818: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_bigendian=no
 else
@@ -5622,7 +5841,7 @@
 # Pull the hash mark out of the macro call to avoid m4 problems.
 ac_msg="whether #! works in shell scripts"
 echo $ac_n "checking $ac_msg""... $ac_c" 1>&6
-echo "configure:5626: checking $ac_msg" >&5
+echo "configure:5845: checking $ac_msg" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_interpreter'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5649,7 +5868,7 @@
 
 fi
 echo $ac_n "checking for restartable system calls""... $ac_c" 1>&6
-echo "configure:5653: checking for restartable system calls" >&5
+echo "configure:5872: checking for restartable system calls" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_restartable_syscalls'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5657,7 +5876,7 @@
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 5661 "configure"
+#line 5880 "configure"
 #include "confdefs.h"
 /* Exit 0 (true) if wait returns something other than -1,
    i.e. the pid of the child, which means that wait was restarted
@@ -5675,7 +5894,7 @@
 }
 
 EOF
-if { (eval echo configure:5679: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:5898: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sys_restartable_syscalls=yes
 else
@@ -5700,12 +5919,12 @@
 
 if test "$ac_cv_func_lstat" = "no"; then
 echo $ac_n "checking for lstat""... $ac_c" 1>&6
-echo "configure:5704: checking for lstat" >&5
+echo "configure:5923: checking for lstat" >&5
 if eval "test \"`echo '$''{'bash_cv_func_lstat'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5709 "configure"
+#line 5928 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -5715,7 +5934,7 @@
  lstat(".",(struct stat *)0); 
 ; return 0; }
 EOF
-if { (eval echo configure:5719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5938: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_func_lstat=yes
 else
@@ -5738,7 +5957,7 @@
 fi
 
 echo $ac_n "checking if dup2 fails to clear the close-on-exec flag""... $ac_c" 1>&6
-echo "configure:5742: checking if dup2 fails to clear the close-on-exec flag" >&5
+echo "configure:5961: checking if dup2 fails to clear the close-on-exec flag" >&5
 if eval "test \"`echo '$''{'bash_cv_dup2_broken'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5747,7 +5966,7 @@
      bash_cv_dup2_broken=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 5751 "configure"
+#line 5970 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -5767,7 +5986,7 @@
 }
 
 EOF
-if { (eval echo configure:5771: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:5990: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_dup2_broken=yes
 else
@@ -5792,7 +6011,7 @@
 
 
 echo $ac_n "checking whether pgrps need synchronization""... $ac_c" 1>&6
-echo "configure:5796: checking whether pgrps need synchronization" >&5
+echo "configure:6015: checking whether pgrps need synchronization" >&5
 if eval "test \"`echo '$''{'bash_cv_pgrp_pipe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5801,7 +6020,7 @@
     bash_cv_pgrp_pipe=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 5805 "configure"
+#line 6024 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_UNISTD_H
@@ -5853,7 +6072,7 @@
 }
 
 EOF
-if { (eval echo configure:5857: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6076: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_pgrp_pipe=no
 else
@@ -5878,13 +6097,13 @@
 
 
 echo $ac_n "checking for type of signal functions""... $ac_c" 1>&6
-echo "configure:5882: checking for type of signal functions" >&5
+echo "configure:6101: checking for type of signal functions" >&5
 if eval "test \"`echo '$''{'bash_cv_signal_vintage'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 5888 "configure"
+#line 6107 "configure"
 #include "confdefs.h"
 #include <signal.h>
 int main() {
@@ -5897,7 +6116,7 @@
   
 ; return 0; }
 EOF
-if { (eval echo configure:5901: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6120: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_signal_vintage=posix
 else
@@ -5906,7 +6125,7 @@
   rm -rf conftest*
   
     cat > conftest.$ac_ext <<EOF
-#line 5910 "configure"
+#line 6129 "configure"
 #include "confdefs.h"
 #include <signal.h>
 int main() {
@@ -5916,7 +6135,7 @@
     
 ; return 0; }
 EOF
-if { (eval echo configure:5920: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6139: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_signal_vintage=4.2bsd
 else
@@ -5925,7 +6144,7 @@
   rm -rf conftest*
   
       cat > conftest.$ac_ext <<EOF
-#line 5929 "configure"
+#line 6148 "configure"
 #include "confdefs.h"
 
 	#include <signal.h>
@@ -5938,7 +6157,7 @@
         
 ; return 0; }
 EOF
-if { (eval echo configure:5942: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6161: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_signal_vintage=svr3
 else
@@ -5980,7 +6199,7 @@
 if test "$ac_cv_sys_restartable_syscalls" = "no"; then
 
 echo $ac_n "checking whether posix sigaction restarts system calls by default""... $ac_c" 1>&6
-echo "configure:5984: checking whether posix sigaction restarts system calls by default" >&5
+echo "configure:6203: checking whether posix sigaction restarts system calls by default" >&5
 if eval "test \"`echo '$''{'bash_cv_sys_restartable_syscalls'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5988,7 +6207,7 @@
   echo "configure: warning: cannot check restartable syscalls if cross compiling" 1>&2
 else
   cat > conftest.$ac_ext <<EOF
-#line 5992 "configure"
+#line 6211 "configure"
 #include "confdefs.h"
 /* Exit 0 (true) if wait returns something other than -1,
    i.e. the pid of the child, which means that wait was restarted
@@ -6025,7 +6244,7 @@
 }
 
 EOF
-if { (eval echo configure:6029: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6248: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_sys_restartable_syscalls=yes
 else
@@ -6051,12 +6270,12 @@
 fi
 
 echo $ac_n "checking for sys_errlist and sys_nerr""... $ac_c" 1>&6
-echo "configure:6055: checking for sys_errlist and sys_nerr" >&5
+echo "configure:6274: checking for sys_errlist and sys_nerr" >&5
 if eval "test \"`echo '$''{'bash_cv_sys_errlist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6060 "configure"
+#line 6279 "configure"
 #include "confdefs.h"
 #include <errno.h>
 int main() {
@@ -6065,7 +6284,7 @@
  char *msg = sys_errlist[sys_nerr - 1];
 ; return 0; }
 EOF
-if { (eval echo configure:6069: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6288: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_sys_errlist=yes
 else
@@ -6086,7 +6305,7 @@
 
 
 echo $ac_n "checking for sys_siglist in system C library""... $ac_c" 1>&6
-echo "configure:6090: checking for sys_siglist in system C library" >&5
+echo "configure:6309: checking for sys_siglist in system C library" >&5
 if eval "test \"`echo '$''{'bash_cv_sys_siglist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6095,7 +6314,7 @@
 	 bash_cv_sys_siglist=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 6099 "configure"
+#line 6318 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -6112,7 +6331,7 @@
 exit(msg == 0);
 }
 EOF
-if { (eval echo configure:6116: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6335: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_sys_siglist=yes
 else
@@ -6135,12 +6354,12 @@
 fi
 
 echo $ac_n "checking for _sys_siglist in signal.h or unistd.h""... $ac_c" 1>&6
-echo "configure:6139: checking for _sys_siglist in signal.h or unistd.h" >&5
+echo "configure:6358: checking for _sys_siglist in signal.h or unistd.h" >&5
 if eval "test \"`echo '$''{'bash_cv_decl_under_sys_siglist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6144 "configure"
+#line 6363 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -6152,7 +6371,7 @@
  char *msg = _sys_siglist[2]; 
 ; return 0; }
 EOF
-if { (eval echo configure:6156: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6375: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_decl_under_sys_siglist=yes
 else
@@ -6173,7 +6392,7 @@
 
 
 echo $ac_n "checking for _sys_siglist in system C library""... $ac_c" 1>&6
-echo "configure:6177: checking for _sys_siglist in system C library" >&5
+echo "configure:6396: checking for _sys_siglist in system C library" >&5
 if eval "test \"`echo '$''{'bash_cv_under_sys_siglist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6182,7 +6401,7 @@
 	 bash_cv_under_sys_siglist=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 6186 "configure"
+#line 6405 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -6199,7 +6418,7 @@
 exit(msg == 0);
 }
 EOF
-if { (eval echo configure:6203: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6422: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_under_sys_siglist=yes
 else
@@ -6223,12 +6442,12 @@
 
 
 echo $ac_n "checking whether signal handlers are of type void""... $ac_c" 1>&6
-echo "configure:6227: checking whether signal handlers are of type void" >&5
+echo "configure:6446: checking whether signal handlers are of type void" >&5
 if eval "test \"`echo '$''{'bash_cv_void_sighandler'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6232 "configure"
+#line 6451 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -6243,7 +6462,7 @@
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:6247: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6466: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_void_sighandler=yes
 else
@@ -6263,12 +6482,12 @@
 fi
 
 echo $ac_n "checking for clock_t""... $ac_c" 1>&6
-echo "configure:6267: checking for clock_t" >&5
+echo "configure:6486: checking for clock_t" >&5
 if eval "test \"`echo '$''{'bash_cv_type_clock_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6272 "configure"
+#line 6491 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -6299,12 +6518,12 @@
 fi
 
 echo $ac_n "checking for sigset_t""... $ac_c" 1>&6
-echo "configure:6303: checking for sigset_t" >&5
+echo "configure:6522: checking for sigset_t" >&5
 if eval "test \"`echo '$''{'bash_cv_type_sigset_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6308 "configure"
+#line 6527 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -6335,12 +6554,12 @@
 fi
 
 echo $ac_n "checking for quad_t""... $ac_c" 1>&6
-echo "configure:6339: checking for quad_t" >&5
+echo "configure:6558: checking for quad_t" >&5
 if eval "test \"`echo '$''{'bash_cv_type_quad_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6344 "configure"
+#line 6563 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -6376,12 +6595,12 @@
 fi
 
 echo $ac_n "checking for size and type of struct rlimit fields""... $ac_c" 1>&6
-echo "configure:6380: checking for size and type of struct rlimit fields" >&5
+echo "configure:6599: checking for size and type of struct rlimit fields" >&5
 if eval "test \"`echo '$''{'bash_cv_type_rlimit'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6385 "configure"
+#line 6604 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/resource.h>
@@ -6389,7 +6608,7 @@
 rlim_t xxx;
 ; return 0; }
 EOF
-if { (eval echo configure:6393: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6612: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_type_rlimit=rlim_t
 else
@@ -6402,7 +6621,7 @@
          bash_cv_type_rlimit=long
 else
   cat > conftest.$ac_ext <<EOF
-#line 6406 "configure"
+#line 6625 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -6418,7 +6637,7 @@
   exit(1);
 }
 EOF
-if { (eval echo configure:6422: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6641: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_type_rlimit=quad_t
 else
@@ -6450,12 +6669,12 @@
 
 
 echo $ac_n "checking for a c_line member of struct termios""... $ac_c" 1>&6
-echo "configure:6454: checking for a c_line member of struct termios" >&5
+echo "configure:6673: checking for a c_line member of struct termios" >&5
 if eval "test \"`echo '$''{'bash_cv_termios_ldisc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6459 "configure"
+#line 6678 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <termios.h>
@@ -6463,7 +6682,7 @@
 struct termios t; int i; i = t.c_line;
 ; return 0; }
 EOF
-if { (eval echo configure:6467: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6686: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_termios_ldisc=yes
 else
@@ -6483,12 +6702,12 @@
 fi
 
 echo $ac_n "checking for a c_line member of struct termio""... $ac_c" 1>&6
-echo "configure:6487: checking for a c_line member of struct termio" >&5
+echo "configure:6706: checking for a c_line member of struct termio" >&5
 if eval "test \"`echo '$''{'bash_cv_termio_ldisc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6492 "configure"
+#line 6711 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <termio.h>
@@ -6496,7 +6715,7 @@
 struct termio t; int i; i = t.c_line;
 ; return 0; }
 EOF
-if { (eval echo configure:6500: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6719: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_termio_ldisc=yes
 else
@@ -6517,12 +6736,12 @@
 
 
 echo $ac_n "checking if struct dirent has a d_ino member""... $ac_c" 1>&6
-echo "configure:6521: checking if struct dirent has a d_ino member" >&5
+echo "configure:6740: checking if struct dirent has a d_ino member" >&5
 if eval "test \"`echo '$''{'bash_cv_dirent_has_dino'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6526 "configure"
+#line 6745 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -6551,7 +6770,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6555: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6774: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_dirent_has_dino=yes
 else
@@ -6573,12 +6792,12 @@
 
 
 echo $ac_n "checking if struct dirent has a d_fileno member""... $ac_c" 1>&6
-echo "configure:6577: checking if struct dirent has a d_fileno member" >&5
+echo "configure:6796: checking if struct dirent has a d_fileno member" >&5
 if eval "test \"`echo '$''{'bash_cv_dirent_has_d_fileno'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6582 "configure"
+#line 6801 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -6607,7 +6826,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6611: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6830: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_dirent_has_d_fileno=yes
 else
@@ -6628,12 +6847,12 @@
 fi
 
 echo $ac_n "checking for struct winsize in sys/ioctl.h and termios.h""... $ac_c" 1>&6
-echo "configure:6632: checking for struct winsize in sys/ioctl.h and termios.h" >&5
+echo "configure:6851: checking for struct winsize in sys/ioctl.h and termios.h" >&5
 if eval "test \"`echo '$''{'bash_cv_struct_winsize_header'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6637 "configure"
+#line 6856 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -6641,7 +6860,7 @@
 struct winsize x;
 ; return 0; }
 EOF
-if { (eval echo configure:6645: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6864: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_struct_winsize_header=ioctl_h
 else
@@ -6649,7 +6868,7 @@
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 6653 "configure"
+#line 6872 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <termios.h>
@@ -6657,7 +6876,7 @@
 struct winsize x;
 ; return 0; }
 EOF
-if { (eval echo configure:6661: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6880: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_struct_winsize_header=termios_h
 else
@@ -6689,13 +6908,13 @@
 fi
 
 echo $ac_n "checking for struct timeval in sys/time.h and time.h""... $ac_c" 1>&6
-echo "configure:6693: checking for struct timeval in sys/time.h and time.h" >&5
+echo "configure:6912: checking for struct timeval in sys/time.h and time.h" >&5
 if eval "test \"`echo '$''{'bash_cv_struct_timeval'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 cat > conftest.$ac_ext <<EOF
-#line 6699 "configure"
+#line 6918 "configure"
 #include "confdefs.h"
 #include <sys/time.h>
 EOF
@@ -6706,7 +6925,7 @@
 else
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 6710 "configure"
+#line 6929 "configure"
 #include "confdefs.h"
 #include <time.h>
 EOF
@@ -6736,12 +6955,12 @@
 
 
 echo $ac_n "checking for the existence of strsignal""... $ac_c" 1>&6
-echo "configure:6740: checking for the existence of strsignal" >&5
+echo "configure:6959: checking for the existence of strsignal" >&5
 if eval "test \"`echo '$''{'bash_cv_have_strsignal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6745 "configure"
+#line 6964 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -6749,7 +6968,7 @@
 char *s = (char *)strsignal(2);
 ; return 0; }
 EOF
-if { (eval echo configure:6753: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6972: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_have_strsignal=yes
 else
@@ -6770,7 +6989,7 @@
 fi
 
 echo $ac_n "checking if opendir() opens non-directories""... $ac_c" 1>&6
-echo "configure:6774: checking if opendir() opens non-directories" >&5
+echo "configure:6993: checking if opendir() opens non-directories" >&5
 if eval "test \"`echo '$''{'bash_cv_opendir_not_robust'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6780,7 +6999,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 6784 "configure"
+#line 7003 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -6822,7 +7041,7 @@
 exit (dir == 0);
 }
 EOF
-if { (eval echo configure:6826: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7045: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_opendir_not_robust=yes
 else
@@ -6845,7 +7064,7 @@
 fi
 
 echo $ac_n "checking for declaration of printf in <stdio.h>""... $ac_c" 1>&6
-echo "configure:6849: checking for declaration of printf in <stdio.h>" >&5
+echo "configure:7068: checking for declaration of printf in <stdio.h>" >&5
 if eval "test \"`echo '$''{'bash_cv_printf_declared'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6855,7 +7074,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 6859 "configure"
+#line 7078 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -6872,7 +7091,7 @@
 }
 
 EOF
-if { (eval echo configure:6876: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7095: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_printf_declared=yes
 else
@@ -6895,7 +7114,7 @@
 fi
 
 echo $ac_n "checking whether ulimit can substitute for getdtablesize""... $ac_c" 1>&6
-echo "configure:6899: checking whether ulimit can substitute for getdtablesize" >&5
+echo "configure:7118: checking whether ulimit can substitute for getdtablesize" >&5
 if eval "test \"`echo '$''{'bash_cv_ulimit_maxfds'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6905,7 +7124,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 6909 "configure"
+#line 7128 "configure"
 #include "confdefs.h"
 
 main()
@@ -6915,7 +7134,7 @@
 }
 
 EOF
-if { (eval echo configure:6919: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7138: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_ulimit_maxfds=yes
 else
@@ -6938,7 +7157,7 @@
 fi
 
 echo $ac_n "checking to see if getenv can be redefined""... $ac_c" 1>&6
-echo "configure:6942: checking to see if getenv can be redefined" >&5
+echo "configure:7161: checking to see if getenv can be redefined" >&5
 if eval "test \"`echo '$''{'bash_cv_getenv_redef'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6948,7 +7167,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 6952 "configure"
+#line 7171 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_UNISTD_H
@@ -6983,7 +7202,7 @@
 }
 
 EOF
-if { (eval echo configure:6987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7206: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_getenv_redef=yes
 else
@@ -7006,7 +7225,7 @@
 fi
 
 echo $ac_n "checking if getcwd() calls popen()""... $ac_c" 1>&6
-echo "configure:7010: checking if getcwd() calls popen()" >&5
+echo "configure:7229: checking if getcwd() calls popen()" >&5
 if eval "test \"`echo '$''{'bash_cv_getcwd_calls_popen'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7016,7 +7235,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7020 "configure"
+#line 7239 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -7071,7 +7290,7 @@
 }
 
 EOF
-if { (eval echo configure:7075: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7294: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_getcwd_calls_popen=no
 else
@@ -7094,12 +7313,12 @@
 fi
 
 echo $ac_n "checking for declaration of sbrk in <unistd.h>""... $ac_c" 1>&6
-echo "configure:7098: checking for declaration of sbrk in <unistd.h>" >&5
+echo "configure:7317: checking for declaration of sbrk in <unistd.h>" >&5
 if eval "test \"`echo '$''{'bash_cv_sbrk_declared'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7103 "configure"
+#line 7322 "configure"
 #include "confdefs.h"
 #include <unistd.h>
 EOF
@@ -7125,7 +7344,7 @@
 
 
 echo $ac_n "checking for presence of POSIX-style sigsetjmp/siglongjmp""... $ac_c" 1>&6
-echo "configure:7129: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
+echo "configure:7348: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
 if eval "test \"`echo '$''{'bash_cv_func_sigsetjmp'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7135,7 +7354,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7139 "configure"
+#line 7358 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_UNISTD_H
@@ -7176,7 +7395,7 @@
 #endif
 }
 EOF
-if { (eval echo configure:7180: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7399: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_func_sigsetjmp=present
 else
@@ -7200,7 +7419,7 @@
 
 
 echo $ac_n "checking whether or not strcoll and strcmp differ""... $ac_c" 1>&6
-echo "configure:7204: checking whether or not strcoll and strcmp differ" >&5
+echo "configure:7423: checking whether or not strcoll and strcmp differ" >&5
 if eval "test \"`echo '$''{'bash_cv_func_strcoll_broken'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7210,7 +7429,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7214 "configure"
+#line 7433 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -7249,7 +7468,7 @@
 }
 
 EOF
-if { (eval echo configure:7253: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7472: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_func_strcoll_broken=yes
 else
@@ -7275,7 +7494,7 @@
 
 
 echo $ac_n "checking if signal handlers must be reinstalled when invoked""... $ac_c" 1>&6
-echo "configure:7279: checking if signal handlers must be reinstalled when invoked" >&5
+echo "configure:7498: checking if signal handlers must be reinstalled when invoked" >&5
 if eval "test \"`echo '$''{'bash_cv_must_reinstall_sighandlers'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7285,7 +7504,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7289 "configure"
+#line 7508 "configure"
 #include "confdefs.h"
 
 #include <signal.h>
@@ -7332,7 +7551,7 @@
 }
 
 EOF
-if { (eval echo configure:7336: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7555: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_must_reinstall_sighandlers=no
 else
@@ -7356,7 +7575,7 @@
 
 
 echo $ac_n "checking for presence of necessary job control definitions""... $ac_c" 1>&6
-echo "configure:7360: checking for presence of necessary job control definitions" >&5
+echo "configure:7579: checking for presence of necessary job control definitions" >&5
 if eval "test \"`echo '$''{'bash_cv_job_control_missing'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7366,7 +7585,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7370 "configure"
+#line 7589 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7413,7 +7632,7 @@
 exit(0);
 }
 EOF
-if { (eval echo configure:7417: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7636: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_job_control_missing=present
 else
@@ -7436,7 +7655,7 @@
 fi
 
 echo $ac_n "checking for presence of named pipes""... $ac_c" 1>&6
-echo "configure:7440: checking for presence of named pipes" >&5
+echo "configure:7659: checking for presence of named pipes" >&5
 if eval "test \"`echo '$''{'bash_cv_sys_named_pipes'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7446,7 +7665,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7450 "configure"
+#line 7669 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7487,7 +7706,7 @@
 exit(0);
 }
 EOF
-if { (eval echo configure:7491: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7710: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_sys_named_pipes=present
 else
@@ -7511,12 +7730,12 @@
 
 
 echo $ac_n "checking for TIOCGWINSZ in sys/ioctl.h""... $ac_c" 1>&6
-echo "configure:7515: checking for TIOCGWINSZ in sys/ioctl.h" >&5
+echo "configure:7734: checking for TIOCGWINSZ in sys/ioctl.h" >&5
 if eval "test \"`echo '$''{'bash_cv_tiocgwinsz_in_ioctl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7520 "configure"
+#line 7739 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -7524,7 +7743,7 @@
 int x = TIOCGWINSZ;
 ; return 0; }
 EOF
-if { (eval echo configure:7528: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7747: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_tiocgwinsz_in_ioctl=yes
 else
@@ -7545,12 +7764,12 @@
 fi
 
 echo $ac_n "checking for TIOCSTAT in sys/ioctl.h""... $ac_c" 1>&6
-echo "configure:7549: checking for TIOCSTAT in sys/ioctl.h" >&5
+echo "configure:7768: checking for TIOCSTAT in sys/ioctl.h" >&5
 if eval "test \"`echo '$''{'bash_cv_tiocstat_in_ioctl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7554 "configure"
+#line 7773 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -7558,7 +7777,7 @@
 int x = TIOCSTAT;
 ; return 0; }
 EOF
-if { (eval echo configure:7562: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7781: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_tiocstat_in_ioctl=yes
 else
@@ -7579,12 +7798,12 @@
 fi
 
 echo $ac_n "checking for FIONREAD in sys/ioctl.h""... $ac_c" 1>&6
-echo "configure:7583: checking for FIONREAD in sys/ioctl.h" >&5
+echo "configure:7802: checking for FIONREAD in sys/ioctl.h" >&5
 if eval "test \"`echo '$''{'bash_cv_fionread_in_ioctl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7588 "configure"
+#line 7807 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -7592,7 +7811,7 @@
 int x = FIONREAD;
 ; return 0; }
 EOF
-if { (eval echo configure:7596: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7815: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_fionread_in_ioctl=yes
 else
@@ -7614,19 +7833,19 @@
 
 
 echo $ac_n "checking for speed_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:7618: checking for speed_t in sys/types.h" >&5
+echo "configure:7837: checking for speed_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'bash_cv_speed_t_in_sys_types'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7623 "configure"
+#line 7842 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 int main() {
 speed_t x;
 ; return 0; }
 EOF
-if { (eval echo configure:7630: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7849: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_speed_t_in_sys_types=yes
 else
@@ -7647,12 +7866,12 @@
 fi
 
 echo $ac_n "checking whether getpw functions are declared in pwd.h""... $ac_c" 1>&6
-echo "configure:7651: checking whether getpw functions are declared in pwd.h" >&5
+echo "configure:7870: checking whether getpw functions are declared in pwd.h" >&5
 if eval "test \"`echo '$''{'bash_cv_getpw_declared'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7656 "configure"
+#line 7875 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7683,7 +7902,7 @@
 fi
 
 echo $ac_n "checking for unusable real-time signals due to large values""... $ac_c" 1>&6
-echo "configure:7687: checking for unusable real-time signals due to large values" >&5
+echo "configure:7906: checking for unusable real-time signals due to large values" >&5
 if eval "test \"`echo '$''{'bash_cv_unusable_rtsigs'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7693,7 +7912,7 @@
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 7697 "configure"
+#line 7916 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7715,7 +7934,7 @@
   exit(rtmin < n_sigs);
 }
 EOF
-if { (eval echo configure:7719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:7938: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_unusable_rtsigs=yes
 else
@@ -7740,12 +7959,12 @@
 
 case "$host_os" in
 hpux*)	echo $ac_n "checking whether $host_os needs _KERNEL for RLIMIT defines""... $ac_c" 1>&6
-echo "configure:7744: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
+echo "configure:7963: checking whether $host_os needs _KERNEL for RLIMIT defines" >&5
 if eval "test \"`echo '$''{'bash_cv_kernel_rlimit'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7749 "configure"
+#line 7968 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7758,7 +7977,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:7762: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:7981: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_kernel_rlimit=no
 else
@@ -7766,7 +7985,7 @@
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 7770 "configure"
+#line 7989 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -7781,7 +8000,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:7785: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:8004: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_kernel_rlimit=yes
 else
@@ -7815,14 +8034,14 @@
 _bash_needmsg=yes
 else
 echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
-echo "configure:7819: checking which library has the termcap functions" >&5
+echo "configure:8038: checking which library has the termcap functions" >&5
 _bash_needmsg=
 fi
 if eval "test \"`echo '$''{'bash_cv_termcap_lib'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
-echo "configure:7826: checking for tgetent in -ltermcap" >&5
+echo "configure:8045: checking for tgetent in -ltermcap" >&5
 ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7830,7 +8049,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ltermcap  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7834 "configure"
+#line 8053 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7841,7 +8060,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:7845: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:8064: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7860,7 +8079,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
-echo "configure:7864: checking for tgetent in -lcurses" >&5
+echo "configure:8083: checking for tgetent in -lcurses" >&5
 ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7868,7 +8087,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7872 "configure"
+#line 8091 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7879,7 +8098,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:7883: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:8102: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7898,7 +8117,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
-echo "configure:7902: checking for tgetent in -lncurses" >&5
+echo "configure:8121: checking for tgetent in -lncurses" >&5
 ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7906,7 +8125,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lncurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7910 "configure"
+#line 8129 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7917,7 +8136,7 @@
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:7921: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:8140: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7946,7 +8165,7 @@
 
 if test "X$_bash_needmsg" = "Xyes"; then
 echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
-echo "configure:7950: checking which library has the termcap functions" >&5
+echo "configure:8169: checking which library has the termcap functions" >&5
 fi
 echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
 if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
@@ -7969,7 +8188,7 @@
 
 
 echo $ac_n "checking whether /dev/fd is available""... $ac_c" 1>&6
-echo "configure:7973: checking whether /dev/fd is available" >&5
+echo "configure:8192: checking whether /dev/fd is available" >&5
 if eval "test \"`echo '$''{'bash_cv_dev_fd'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -8005,7 +8224,7 @@
 fi
 
 echo $ac_n "checking whether /dev/stdin stdout stderr are available""... $ac_c" 1>&6
-echo "configure:8009: checking whether /dev/stdin stdout stderr are available" >&5
+echo "configure:8228: checking whether /dev/stdin stdout stderr are available" >&5
 if eval "test \"`echo '$''{'bash_cv_dev_stdin'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -8028,7 +8247,7 @@
 fi
 
 echo $ac_n "checking for default mail directory""... $ac_c" 1>&6
-echo "configure:8032: checking for default mail directory" >&5
+echo "configure:8251: checking for default mail directory" >&5
 if eval "test \"`echo '$''{'bash_cv_mail_dir'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -8164,7 +8383,7 @@
 if test "$ac_cv_func_dlopen" = "yes" && test -f ${srcdir}/support/shobj-conf
 then
 	echo $ac_n "checking shared object configuration for loadable builtins""... $ac_c" 1>&6
-echo "configure:8168: checking shared object configuration for loadable builtins" >&5
+echo "configure:8387: checking shared object configuration for loadable builtins" >&5
 	eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c "${host_cpu}" -o "${host_os}" -v "${host_vendor}"`
 	
 	
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/configure.in bash-2.05/configure.in
--- bash-2.05.orig/configure.in	Wed Jan 24 02:57:24 2001
+++ bash-2.05/configure.in	Wed Apr 18 16:15:08 2001
@@ -484,6 +484,23 @@
 AC_CHECK_HEADERS(libintl.h)
 AC_CHECK_FUNCS(gettext textdomain bindtextdomain)
 
+dnl checks for multibyte handling capability
+AC_CHECK_HEADERS(wctype.h)
+AC_CHECK_HEADERS(wchar.h)
+AC_CHECK_FUNC(mbsrtowcs,AC_DEFINE(HAVE_MBSRTOWCS),)
+AC_CHECK_FUNC(mbrlen,AC_DEFINE(HAVE_MBRLEN),)
+AC_TRY_RUN([
+#include <wchar.h>
+
+int
+main ()
+{
+  mbstate_t ps;
+  return 0;
+}],
+AC_DEFINE(HAVE_MBSTATE_T),)
+
+
 dnl check for GNU libintl if gettext/textdomain/bindtextdomain
 dnl are not found in libc
 if test "$ac_cv_func_bindtextdomain" = "no"; then
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/execute_cmd.c bash-2.05/execute_cmd.c
--- bash-2.05.orig/execute_cmd.c	Fri Mar 23 00:17:23 2001
+++ bash-2.05/execute_cmd.c	Wed Apr 18 16:23:12 2001
@@ -31,6 +31,7 @@
 #endif
 #include "filecntl.h"
 #include "posixstat.h"
+#include "xstrchr.h"
 #include <signal.h>
 #ifndef _MINIX
 #  include <sys/param.h>
@@ -75,6 +76,7 @@
 #include "trap.h"
 #include "pathexp.h"
 #include "hashcmd.h"
+#include "xstrchr.h"
 
 #if defined (COND_COMMAND)
 #  include "test.h"
@@ -864,16 +866,16 @@
 
 /* Interpret the format string FORMAT, interpolating the following escape
    sequences:
-   		%[prec][l][RUS]
+		%[prec][l][RUS]
 
    where the optional `prec' is a precision, meaning the number of
    characters after the decimal point, the optional `l' means to format
    using minutes and seconds (MMmNN[.FF]s), like the `times' builtin',
    and the last character is one of
    
-  		R	number of seconds of `real' time
-  		U	number of seconds of `user' time
-  		S	number of seconds of `system' time
+		R	number of seconds of `real' time
+		U	number of seconds of `user' time
+		S	number of seconds of `system' time
 
    An occurrence of `%%' in the format string is translated to a `%'.  The
    result is printed to FP, a pointer to a FILE.  The other variables are
@@ -3121,7 +3123,7 @@
   pathname = words->word->word;
 
 #if defined (RESTRICTED_SHELL)
-  if (restricted && strchr (pathname, '/'))
+  if (restricted && xstrchr ((const char *)pathname, '/'))
     {
       internal_error ("%s: restricted: cannot specify `/' in command names",
 		    pathname);
@@ -3534,7 +3536,7 @@
 
   fd_table_size = getdtablesize ();
   if (fd_table_size > 256)	/* clamp to a reasonable value */
-  	fd_table_size = 256;
+	fd_table_size = 256;
 
   for (i = 3; i < fd_table_size; i++)
     close (i);
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/general.c bash-2.05/general.c
--- bash-2.05.orig/general.c	Thu Mar  1 03:23:24 2001
+++ bash-2.05/general.c	Wed Apr 18 16:23:12 2001
@@ -40,6 +40,7 @@
 #include <tilde/tilde.h>
 
 #include "maxpath.h"
+#include "xstrchr.h"
 
 #if !defined (errno)
 extern int errno;
@@ -458,7 +459,7 @@
 absolute_program (string)
      char *string;
 {
-  return ((char *)strchr (string, '/') != (char *)NULL);
+  return ((char *)xstrchr ((const char *)string, '/') != (char *)NULL);
 }
 
 /* Return the `basename' of the pathname in STRING (the stuff after the
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/general.h bash-2.05/general.h
--- bash-2.05.orig/general.h	Thu Feb 15 06:53:05 2001
+++ bash-2.05/general.h	Wed Apr 18 16:23:12 2001
@@ -71,7 +71,7 @@
 #endif
 
 #ifndef member
-#  define member(c, s) ((c) ? ((char *)strchr ((s), (c)) != (char *)NULL) : 0)
+#  define member(c, s) ((c) ? ((char *)xstrchr ((const char *)(s), (c)) != (char *)NULL) : 0)
 #endif
 
 #ifndef whitespace
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/lib/glob/Makefile.in bash-2.05/lib/glob/Makefile.in
--- bash-2.05.orig/lib/glob/Makefile.in	Thu Aug  5 23:52:57 1999
+++ bash-2.05/lib/glob/Makefile.in	Wed Apr 18 16:23:12 2001
@@ -62,12 +62,12 @@
 LIBRARY_NAME = libglob.a
 
 # The C code source files for this library.
-CSOURCES = $(srcdir)/glob.c $(srcdir)/fnmatch.c
+CSOURCES = $(srcdir)/glob.c $(srcdir)/fnmatch.c $(srcdir)/xmbsrtowcs.c
 
 # The header files for this library.
 HSOURCES = $(srcdir)/fnmatch.h
 
-OBJECTS = glob.o fnmatch.o
+OBJECTS = glob.o fnmatch.o xmbsrtowcs.o
 
 # The texinfo files which document this library.
 DOCSOURCE = doc/glob.texi
@@ -129,6 +129,10 @@
 glob.o: $(BASHINCDIR)/posixstat.h $(BASHINCDIR)/memalloc.h
 glob.o: fnmatch.h
 
+xmbsrtowcs.o: $(BUILD_DIR)/config.h
+xmbsrtowcs.o: xmbsrtowcs.h
+
 # Rules for deficient makes, like SunOS and Solaris
 fnmatch.o: fnmatch.c
 glob.o: glob.c
+xmbsrtowcs.o: xmbsrtowcs.c
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/lib/glob/collsyms.h bash-2.05/lib/glob/collsyms.h
--- bash-2.05.orig/lib/glob/collsyms.h	Thu Aug  5 20:56:04 1999
+++ bash-2.05/lib/glob/collsyms.h	Wed Apr 18 16:23:12 2001
@@ -9,121 +9,120 @@
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any later
    version.
-              
+	      
    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
-                         
+			 
    You should have received a copy of the GNU General Public License along
    with Bash; see the file COPYING.  If not, write to the Free Software
    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
 
-#ifndef _COLLSYMS_H_
-#  define _COLLSYSMS_H_
-
 /* The upper-case letters, lower-case letters, and digits are omitted from
    this table.  The digits are not included in the table in the POSIX.2
    spec.  The upper and lower case letters are translated by the code
    in fnmatch.c:collsym(). */
 
-typedef struct _collsym {
-  char *name;
-  char code;
-} COLLSYM;
+typedef struct _COLLSYM {
+  CHAR *name;
+  CHAR code;
+} __COLLSYM;
 
-static COLLSYM posix_collsyms[] =
+static __COLLSYM POSIXCOLL [] =
 {
-  "NUL",	'\0',
-  "SOH",	'\001',
-  "STX",	'\002',
-  "ETX",	'\003',
-  "EOT",	'\004',
-  "ENQ",	'\005',
-  "ACK",	'\006',
+  L("NUL"),		L('\0'),
+  L("SOH"),		L('\001'),
+  L("STX"),		L('\002'),
+  L("ETX"),		L('\003'),
+  L("EOT"),		L('\004'),
+  L("ENQ"),		L('\005'),
+  L("ACK"),		L('\006'),
 #ifdef __STDC__
-  "alert",	'\a',
+  L("alert"),		L('\a'),
 #else
-  "alert",	'\007',
+  L("alert"),		L('\007'),
 #endif
-  "backspace",	'\b',
-  "tab",	'\t',
-  "newline",	'\n',
-  "vertical-tab",	'\v',
-  "form-feed",	'\f',
-  "carriage-return",	'\r',
-  "SO",		'\016',
-  "SI",		'\017',
-  "DLE",	'\020',
-  "DC1",	'\021',
-  "DC2",	'\022',
-  "DC3",	'\023',
-  "DC4",	'\024',
-  "NAK",	'\025',
-  "SYN",	'\026',
-  "ETB",	'\027',
-  "CAN",	'\030',
-  "EM",		'\031',
-  "SUB",	'\032',
-  "ESC",	'\033',
-  "IS4",	'\034',
-  "IS3",	'\035',
-  "IS2",	'\036',
-  "IS1",	'\037',
-  "space",		' ',
-  "exclamation-mark",	'!',
-  "quotation-mark",	'"',
-  "number-sign",	'#',
-  "dollar-sign",	'$',
-  "percent-sign",	'%',
-  "ampersand",		'&',
-  "apostrophe",		'\'',
-  "left-parenthesis",	'(',
-  "right-parenthesis",	')',
-  "asterisk",	'*',
-  "plus-sign",	'+',
-  "comma",	',',
-  "hyphen",	'-',
-  "minus",	'-',		/* extension from POSIX.2 */
-  "dash",	'-',		/* extension from POSIX.2 */
-  "period",	'.',
-  "slash",	'/',
-  "solidus",	'/',		/* extension from POSIX.2 */
-  "zero",	'0',
-  "one",	'1',
-  "two",	'2',
-  "three",	'3',
-  "four",	'4',
-  "five",	'5',
-  "six",	'6',
-  "seven",	'7',
-  "eight",	'8',
-  "nine",	'9',
-  "colon",	':',
-  "semicolon",	';',
-  "less-than-sign",	'<',
-  "equals-sign",	'=',
-  "greater-than-sign",	'>',
-  "question-mark",	'?',
-  "commercial-at",	'@',
+  L("backspace"),	L('\b'),
+  L("tab"),		L('\t'),
+  L("newline"),		L('\n'),
+  L("vertical-tab"),	L('\v'),
+  L("form-feed"),	L('\f'),
+  L("carriage-return"),	L('\r'),
+  L("SO"),		L('\016'),
+  L("SI"),		L('\017'),
+  L("DLE"),		L('\020'),
+  L("DC1"),		L('\021'),
+  L("DC2"),		L('\022'),
+  L("DC3"),		L('\023'),
+  L("DC4"),		L('\024'),
+  L("NAK"),		L('\025'),
+  L("SYN"),		L('\026'),
+  L("ETB"),		L('\027'),
+  L("CAN"),		L('\030'),
+  L("EM"),		L('\031'),
+  L("SUB"),		L('\032'),
+  L("ESC"),		L('\033'),
+  L("IS4"),		L('\034'),
+  L("IS3"),		L('\035'),
+  L("IS2"),		L('\036'),
+  L("IS1"),		L('\037'),
+  L("space"),		L(' '),
+  L("exclamation-mark"),	L('!'),
+  L("quotation-mark"),	L('"'),
+  L("number-sign"),	L('#'),
+  L("dollar-sign"),	L('$'),
+  L("percent-sign"),	L('%'),
+  L("ampersand"),	L('&'),
+  L("apostrophe"),	L('\''),
+  L("left-parenthesis"),	L('('),
+  L("right-parenthesis"),	L(')'),
+  L("asterisk"),	L('*'),
+  L("plus-sign"),	L('+'),
+  L("comma"),		L(','),
+  L("hyphen"),		L('-'),
+  L("minus"),		L('-'),		/* extension from POSIX.2 */
+  L("dash"),		L('-'),		/* extension from POSIX.2 */
+  L("period"),		L('.'),
+  L("slash"),		L('/'),
+  L("solidus"),		L('/'),		/* extension from POSIX.2 */
+  L("zero"),		L('0'),
+  L("one"),		L('1'),
+  L("two"),		L('2'),
+  L("three"),		L('3'),
+  L("four"),		L('4'),
+  L("five"),		L('5'),
+  L("six"),		L('6'),
+  L("seven"),		L('7'),
+  L("eight"),		L('8'),
+  L("nine"),		L('9'),
+  L("colon"),		L(':'),
+  L("semicolon"),	L(';'),
+  L("less-than-sign"),	L('<'),
+  L("equals-sign"),	L('='),
+  L("greater-than-sign"),	L('>'),
+  L("question-mark"),	L('?'),
+  L("commercial-at"),	L('@'),
   /* upper-case letters omitted */
-  "left-square-bracket",'[',
-  "backslash",		'\\',
-  "reverse-solidus",	'\\',
-  "right-square-bracket",	']',
-  "circumflex",		'^',
-  "circumflex-accent",	'^',		/* extension from POSIX.2 */
-  "underscore",		'_',
-  "grave-accent",		'`',
+  L("left-square-bracket")	,L('['),
+  L("backslash"),		L('\\'),
+  L("reverse-solidus"),		L('\\'),
+  L("right-square-bracket"),	L(']'),
+  L("circumflex"),		L('^'),
+  L("circumflex-accent"),	L('^'),		/* extension from POSIX.2 */
+  L("underscore"),		L('_'),
+  L("grave-accent"),		L('`'),
   /* lower-case letters omitted */
-  "left-brace",		'{',		/* extension from POSIX.2 */
-  "left-curly-bracket",	'{',
-  "vertical-line",	'|',
-  "right-brace",		'}',	/* extension from POSIX.2 */
-  "right-curly-bracket",	'}',
-  "tilde",		'~',
-  "DEL",	'\177',
-  0,	0,
+  L("left-brace"),		L('{'),		/* extension from POSIX.2 */
+  L("left-curly-bracket"),	L('{'),
+  L("vertical-line"),		L('|'),
+  L("right-brace"),		L('}'),		/* extension from POSIX.2 */
+  L("right-curly-bracket"),	L('}'),
+  L("tilde"),		L('~'),
+  L("DEL"),		L('\177'),
+  0,	0
 };
 
-#endif
+#undef _COLLSYM
+#undef __COLLSYM
+#undef POSIXCOLL
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/lib/glob/fnmatch.c bash-2.05/lib/glob/fnmatch.c
--- bash-2.05.orig/lib/glob/fnmatch.c	Sat Mar 17 03:24:27 2001
+++ bash-2.05/lib/glob/fnmatch.c	Wed Apr 18 16:23:12 2001
@@ -1,5 +1,5 @@
 /* fnmatch.c -- ksh-like extended pattern matching for the shell and filename
-		globbing. */
+                globbing. */
 
 /* Copyright (C) 1991, 1997 Free Software Foundation, Inc.
 
@@ -9,12 +9,12 @@
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any later
    version.
-	      
+              
    Bash is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
-			 
+                         
    You should have received a copy of the GNU General Public License along
    with Bash; see the file COPYING.  If not, write to the Free Software
    Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
@@ -22,64 +22,60 @@
 #include <config.h>
 
 #include <stdio.h>	/* for debugging */
-				
+
 #include "fnmatch.h"
-#include "collsyms.h"
+#include <errno.h>
 #include <ctype.h>
 
-#if defined (HAVE_STRING_H)
-#  include <string.h>
+#if HAVE_STRING_H
+# include <string.h>
 #else
-#  include <strings.h>
+# include <strings.h>
 #endif /* HAVE_STRING_H */
 
-static int gmatch ();
-static char *brackmatch ();
-#ifdef EXTENDED_GLOB
-static int extmatch ();
-static char *patscan ();
+#if defined STDC_HEADERS
+# include <stdlib.h>
 #endif
-  
-#if !defined (isascii)
-#  define isascii(c)	((unsigned int)(c) <= 0177)
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
 #endif
 
-/* Note that these evaluate C many times.  */
-
-#ifndef isblank
-#  define isblank(c)	((c) == ' ' || (c) == '\t')
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+# endif
 #endif
 
-#ifndef isgraph
-#  define isgraph(c)	((c) != ' ' && isprint((c)))
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define wcsrtombs(dest, src, len, ps) (wcsrtombs) (dest, src, len, 0)
 #endif
 
-#ifndef isxdigit
-#  define isxdigit(c)	(((c) >= '0' && (c) <= '9') || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+#ifndef errno
+extern int errno;
 #endif
 
-/* The result of FOLD is an `unsigned char' */
-# define FOLD(c) ((flags & FNM_CASEFOLD) && isupper ((unsigned char)c) \
-	? tolower ((unsigned char)c) \
-	: ((unsigned char)c))
+/* For unibyte characters. */
+#define CHAR	unsigned char   
+#define INT	int
+#define L(CS)	CS
+#define INVALID	EOF
 
-#ifndef STREQ
-#define STREQ(a, b) ((a)[0] == (b)[0] && strcmp(a, b) == 0)
+#undef STREQ
+#undef STREQN
+#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
 #define STREQN(a, b, n) ((a)[0] == (b)[0] && strncmp(a, b, n) == 0)
-#endif
-
-/* We use strcoll(3) for range comparisons in bracket expressions,
-   even though it can have unwanted side effects in locales
-   other than POSIX or US.  For instance, in the de locale, [A-Z] matches
-   all characters. */
 
-#if defined (HAVE_STRCOLL)
 /* Helper function for collating symbol equivalence. */
 static int rangecmp (c1, c2)
      int c1, c2;
 {
-  static char s1[2] = { ' ', '\0' };
-  static char s2[2] = { ' ', '\0' };
+#if defined HAVE_STRCOLL
+  unsigned char s1[2] = { ' ', '\0' };
+  unsigned char s2[2] = { ' ', '\0' };
   int ret;
 
   /* Eight bits only.  Period. */
@@ -87,32 +83,30 @@
   c2 &= 0xFF;
 
   if (c1 == c2)
-    return (0);
-
-  s1[0] = c1;
-  s2[0] = c2;
+    return 0;
 
   if ((ret = strcoll (s1, s2)) != 0)
     return ret;
   return (c1 - c2);
+#else	/* !HAVE_STRCOLL */
+  return (c1 - c2);
+#endif  /* !HAVE_STRCOLL */
 }
-#else /* !HAVE_STRCOLL */
-#  define rangecmp(c1, c2)	((int)(c1) - (int)(c2))
-#endif /* !HAVE_STRCOLL */
 
-#if defined (HAVE_STRCOLL)
 static int collequiv (c1, c2)
      int c1, c2;
 {
   return (rangecmp (c1, c2) == 0);
 }
-#else
-#  define collequiv(c1, c2)	((c1) == (c2))
-#endif
+
+#define _COLLSYM  _collsym
+#define __COLLSYM __collsym
+#define POSIXCOLL posix_collsyms
+#include "collsyms.h"
 
 static int
 collsym (s, len)
-     char *s;
+     unsigned char *s;
      int len;
 {
   register struct _collsym *csp;
@@ -124,699 +118,289 @@
     }
   if (len == 1)
     return s[0];
-  return -1;
+  return INVALID;
 }
 
-int
-fnmatch (pattern, string, flags)
-     char *pattern;
-     char *string;
-     int flags;
-{
-  char *se, *pe;
+/* unibyte character classification */
+#if !defined isascii
+# define isascii(c)    ((unsigned int)(c) <= 0177)
+#endif
+
+#ifndef isblank
+#  define isblank(c)    ((c) == ' ' || (c) == '\t')
+#endif
 
-  if (string == 0 || pattern == 0)
-    return FNM_NOMATCH;
+#ifndef isgraph
+#  define isgraph(c)    ((c) != ' ' && isprint((c)))
+#endif
 
-  se = string + strlen (string);
-  pe = pattern + strlen (pattern);
+#ifndef isxdigit
+#  define isxdigit(c)   (((c) >= '0' && (c) <= '9') || ((c) >= 'a' && (c) <= 'f'
+) || ((c) >= 'A' && (c) <= 'F'))
+#endif
 
-  return (gmatch (string, se, pattern, pe, flags));
-}
+enum Char_class
+  {
+    CC_NO_CLASS = 0,
+    CC_ASCII, CC_ALNUM, CC_ALPHA, CC_BLANK, CC_CNTRL, CC_DIGIT, CC_GRAPH,
+    CC_LOWER, CC_PRINT, CC_PUNCT, CC_SPACE, CC_UPPER, CC_XDIGIT
+  };
+
+static char const *const char_class_name[] =
+  {
+    "",
+    "ascii", "alnum", "alpha", "blank", "cntrl", "digit", "graph",
+    "lower", "print", "punct", "space", "upper", "xdigit" 
+  };
 
-/* Match STRING against the filename pattern PATTERN, returning zero if
-   it matches, FNM_NOMATCH if not.  */
 static int
-gmatch (string, se, pattern, pe, flags)
-     char *string, *se;
-     char *pattern, *pe;
-     int flags;
+is_char_class (c, name)
+int c;
+const char *name;
 {
-  register char *p, *n;		/* pattern, string */
-  register char c;		/* current pattern character */
-  register char sc;		/* current string character */
-
-  p = pattern;
-  n = string;
-
-  if (string == 0 || pattern == 0)
-    return FNM_NOMATCH;
+  enum Char_class char_class = CC_NO_CLASS;
+  int i;
+  int result;
+
+  for (i = 1; i < (sizeof(char_class_name) / sizeof(char_class_name[0])); i++)
+    if (strcmp ((const char *)name, char_class_name[i]) == 0)
+      {
+        char_class = (enum Char_class)i;
+	break;
+      }
 
-#if DEBUG_MATCHING
-fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
-fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
-#endif
+  if (!char_class)
+    return -1;
 
-  while (p < pe)
+  switch (char_class)
     {
-      c = *p++;
-      c = FOLD (c);
+      case CC_ASCII:
+	result = isascii (c);
+	break;
+      case CC_ALNUM:
+	result = isalnum (c);
+	break;
+      case CC_ALPHA:
+	result = isalpha (c);
+	break;
+      case CC_BLANK:
+	result = isblank (c);
+	break;
+      case CC_CNTRL:
+	result = iscntrl (c);
+	break;
+      case CC_DIGIT:
+	result = isdigit (c);
+	break;
+      case CC_GRAPH:
+	result = isgraph (c);
+	break;
+      case CC_LOWER:
+	result = islower (c);
+	break;
+      case CC_PRINT:
+	result = isprint (c);
+	break;
+      case CC_PUNCT:
+	result = ispunct (c);
+	break;
+      case CC_SPACE:
+	result = isspace (c);
+	break;
+      case CC_UPPER:
+	result = isupper (c);
+	break;
+      case CC_XDIGIT:
+	result = isxdigit (c);
+	break;
+      default:
+	result = -1;
+	break;
+    }
+  return result;
+}
 
-      sc = n < se ? *n : '\0';
+/* Now include "fnmatch_loop.c" for unibyte characters. */
+#define FOLD(c) ((flags & FNM_CASEFOLD) && isupper (c) ? tolower (c) : (c))
+#define FCT			internal_fnmatch
+#define GMATCH			gmatch
+#define COLLSYM			collsym
+#define PARSE_COLLSYM		parse_collsym
+#define BRACKMATCH		brackmatch
+#define PATSCAN			patscan
+#define STRCOMPARE		strcompare
+#define EXTMATCH		extmatch
+#define STRCHR(S, C)		strchr (S, C)
+#define STRCOLL(S1, S2)		strcoll (S1, S2)
+#define STRLEN(S)		strlen(S)
+#define STRCMP(S1, S2)		strcmp(S1, S2)
+#define RANGECMP(C1, C2)	rangecmp(C1, C2)
+#define COLLEQUIV(C1, C2)	collequiv (C1, C2)
+#define CTYPE_T			enum Char_class
+#define IS_CHAR_CLASS(C, S)	is_char_class(C, S)
+#include "fnmatch_loop.c"
+
+/* Compile `fnmatch_loop.c' again for multibyte characters. */
+#if HANDLE_MULTIBYTE
+# include "xmbsrtowcs.h"
+
+# define L(CS)	 L##CS
+# define CHAR	 wchar_t
+# define INT	 wint_t
+# define INVALID WEOF
+
+# undef STREQ
+# undef STREQN
+# define STREQ(s1, s2) ((wcscmp (s1, s2) == 0))
+# define STREQN(a, b, n) ((a)[0] == (b)[0] && wcsncmp(a, b, n) == 0)
 
-#ifdef EXTENDED_GLOB
-      /* extmatch () will handle recursively calling gmatch, so we can
-	 just return what extmatch() returns. */
-      if ((flags & FNM_EXTMATCH) && *p == '(' &&
-	  (c == '+' || c == '*' || c == '?' || c == '@' || c == '!')) /* ) */
-	{
-	  int lflags;
-	  /* If we're not matching the start of the string, we're not
-	     concerned about the special cases for matching `.' */
-	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
-	  return (extmatch (c, n, se, p, pe, lflags));
-	}
-#endif
-
-      switch (c)
-	{
-	case '?':		/* Match single character */
-	  if (sc == '\0')
-	    return FNM_NOMATCH;
-	  else if ((flags & FNM_PATHNAME) && sc == '/')
-	    /* If we are matching a pathname, `?' can never match a `/'. */
-	    return FNM_NOMATCH;
-	  else if ((flags & FNM_PERIOD) && sc == '.' &&
-		   (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
-	    /* `?' cannot match a `.' if it is the first character of the
-	       string or if it is the first character following a slash and
-	       we are matching a pathname. */
-	    return FNM_NOMATCH;
-	  break;
-
-	case '\\':		/* backslash escape removes special meaning */
-	  if (p == pe)
-	    return FNM_NOMATCH;
-
-	  if ((flags & FNM_NOESCAPE) == 0)
-	    {
-	      c = *p++;
-	      /* A trailing `\' cannot match. */
-	      if (p > pe)
-		return FNM_NOMATCH;
-	      c = FOLD (c);
-	    }
-	  if (FOLD (sc) != (unsigned char)c)
-	    return FNM_NOMATCH;
-	  break;
-
-	case '*':		/* Match zero or more characters */
-	  if (p == pe)
-	    return 0;
-	  
-	  if ((flags & FNM_PERIOD) && sc == '.' &&
-	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
-	    /* `*' cannot match a `.' if it is the first character of the
-	       string or if it is the first character following a slash and
-	       we are matching a pathname. */
-	    return FNM_NOMATCH;
-
-	  /* Collapse multiple consecutive, `*' and `?', but make sure that
-	     one character of the string is consumed for each `?'. */
-	  for (c = *p++; (c == '?' || c == '*'); c = *p++)
-	    {
-	      if ((flags & FNM_PATHNAME) && sc == '/')
-		/* A slash does not match a wildcard under FNM_PATHNAME. */
-		return FNM_NOMATCH;
-	      else if (c == '?')
-		{
-		  if (sc == '\0')
-		    return FNM_NOMATCH;
-		  /* One character of the string is consumed in matching
-		     this ? wildcard, so *??? won't match if there are
-		     fewer than three characters. */
-		  n++;
-		  sc = n < se ? *n : '\0';
-		}
-
-#ifdef EXTENDED_GLOB
-	      /* Handle ******(patlist) */
-	      if ((flags & FNM_EXTMATCH) && c == '*' && *p == '(')  /*)*/
-		{
-		  char *newn;
-		  /* We need to check whether or not the extended glob
-		     pattern matches the remainder of the string.
-		     If it does, we match the entire pattern. */
-		  for (newn = n; newn < se; ++newn)
-		    {
-		      if (extmatch (c, newn, se, p, pe, flags) == 0)
-			return (0);
-		    }
-		  /* We didn't match the extended glob pattern, but
-		     that's OK, since we can match 0 or more occurrences.
-		     We need to skip the glob pattern and see if we
-		     match the rest of the string. */
-		  newn = patscan (p + 1, pe, 0);
-		  p = newn;
-		}
-#endif
-	      if (p == pe)
-		break;
-	    }
-
-	  /* If we've hit the end of the pattern and the last character of
-	     the pattern was handled by the loop above, we've succeeded.
-	     Otherwise, we need to match that last character. */
-	  if (p == pe && (c == '?' || c == '*'))
-	    return (0);
-
-	  /* General case, use recursion. */
-	  {
-	    unsigned char c1;
-
-	    c1 = (unsigned char)((flags & FNM_NOESCAPE) == 0 && c == '\\') ? *p : c;
-	    c1 = FOLD (c1);
-	    for (--p; n < se; ++n)
-	      {
-		/* Only call fnmatch if the first character indicates a
-		   possible match.  We can check the first character if
-		   we're not doing an extended glob match. */
-		if ((flags & FNM_EXTMATCH) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
-		  continue;
-
-		/* If we're doing an extended glob match and the pattern is not
-		   one of the extended glob patterns, we can check the first
-		   character. */
-		if ((flags & FNM_EXTMATCH) && p[1] != '(' && /*)*/
-		    strchr ("?*+@!", *p) == 0 && c != '[' && FOLD (*n) != c1) /*]*/
-		  continue;
-
-		/* Otherwise, we just recurse. */
-		if (gmatch (n, se, p, pe, flags & ~FNM_PERIOD) == 0)
-		  return (0);
-	      }
-	    return FNM_NOMATCH;
-	  }
-
-	case '[':
-	  {
-	    if (sc == '\0' || n == se)
-	      return FNM_NOMATCH;
-
-	    /* A character class cannot match a `.' if it is the first
-	       character of the string or if it is the first character
-	       following a slash and we are matching a pathname. */
-	    if ((flags & FNM_PERIOD) && sc == '.' &&
-		(n == string || ((flags & FNM_PATHNAME) && n[-1] == '/')))
-	      return (FNM_NOMATCH);
-
-	    p = brackmatch (p, sc, flags);
-	    if (p == 0)
-	      return FNM_NOMATCH;
-	  }
-	  break;
-
-	default:
-	  if ((unsigned char)c != FOLD (sc))
-	    return (FNM_NOMATCH);
-	}
+/* Helper function for collating symbol equivalence. */
+static int rangecmp_wc (c1, c2)
+     wint_t c1, c2;
+{
+  wchar_t s1[2] = { L' ', L'\0' };
+  wchar_t s2[2] = { L' ', L'\0' };
+  int ret;
 
-      ++n;
-    }
+  if (c1 == c2)
+    return 0;
 
-  if (n == se)
-    return (0);
+  s1[0] = c1;
+  s2[0] = c2;
 
-  if ((flags & FNM_LEADING_DIR) && *n == '/')
-    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
-    return 0;
-	  
-  return (FNM_NOMATCH);
+  return (wcscoll (s1, s2));
 }
 
-/* Parse a bracket expression collating symbol ([.sym.]) starting at P, find
-   the value of the symbol, and move P past the collating symbol expression.
-   The value is returned in *VP, if VP is not null. */
-static char *
-parse_collsym (p, vp)
-     char *p;
-     int *vp;
+static int collequiv_wc (c1, c2)
+     wint_t c1, c2;
 {
-  register int pc;
-  int val;
-
-  p++;				/* move past the `.' */
-	  
-  for (pc = 0; p[pc]; pc++)
-    if (p[pc] == '.' && p[pc+1] == ']')
-      break;
-   val = collsym (p, pc);
-   if (vp)
-     *vp = val;
-   return (p + pc + 2);
+  return (rangecmp_wc (c1, c2) == 0);
 }
 
-static char *
-brackmatch (p, test, flags)
-     char *p;
-     unsigned char test;
-     int flags;
+# define _COLLSYM  _collwcsym
+# define __COLLSYM __collwcsym
+# define POSIXCOLL posix_collwcsyms
+# include "collsyms.h"
+static wint_t
+collwcsym (s, len)
+     wchar_t *s;
+     int len;
 {
-  register char cstart, cend, c;
-  register int not;    /* Nonzero if the sense of the character class is inverted.  */
-  int pc, brcnt;
-  char *savep;
-
-  test = FOLD (test);
-
-  savep = p;
-
-  /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
-     circumflex (`^') in its role in a `nonmatching list'.  A bracket
-     expression starting with an unquoted circumflex character produces
-     unspecified results.  This implementation treats the two identically. */
-  if (not = (*p == '!' || *p == '^'))
-    ++p;
+  struct _collwcsym *csp;
 
-  c = *p++;
-  for (;;)
+  for (csp = posix_collwcsyms; csp->name; csp++)
     {
-      /* Initialize cstart and cend in case `-' is the last
-	 character of the pattern. */
-      cstart = cend = c;
-
-      /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
-	 the end of the equivalence class, move the pattern pointer past
-	 it, and check for equivalence.  XXX - this handles only
-	 single-character equivalence classes, which is wrong, or at
-	 least incomplete. */
-      if (c == '[' && *p == '=' && p[2] == '=' && p[3] == ']')
-	{
-	  pc = FOLD (p[1]);
-	  p += 4;
-	  if (collequiv (test, pc))
-	    {
-/*[*/	      /* Move past the closing `]', since the first thing we do at
-		 the `matched:' label is back p up one. */
-	      p++;
-	      goto matched;
-	    }
-	  else
-	    {
-	      c = *p++;
-	      if (c == '\0')
-		return ((test == '[') ? savep : (char *)0); /*]*/
-	      c = FOLD (c);
-	      continue;
-	    }
-	}
-
-      /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
-      if (c == '[' && *p == ':')	/*]*/
-	{
-	  pc = 0;	/* make sure invalid char classes don't match. */
-	  if (STREQN (p+1, "alnum:]", 7))
-	    { pc = isalnum (test); p += 8; }
-	  else if (STREQN (p+1, "alpha:]", 7))
-	    { pc = isalpha (test); p += 8; }
-	  else if (STREQN (p+1, "blank:]", 7))
-	    { pc = isblank (test); p += 8; }
-	  else if (STREQN (p+1, "cntrl:]", 7))
-	    { pc = iscntrl (test); p += 8; }
-	  else if (STREQN (p+1, "digit:]", 7))
-	    { pc = isdigit (test); p += 8; }
-	  else if (STREQN (p+1, "graph:]", 7))
-	    { pc = isgraph (test); p += 8; }
-	  else if (STREQN (p+1, "lower:]", 7))
-	    { pc = islower (test); p += 8; }
-	  else if (STREQN (p+1, "print:]", 7))
-	    { pc = isprint (test); p += 8; }
-	  else if (STREQN (p+1, "punct:]", 7))
-	    { pc = ispunct (test); p += 8; }
-	  else if (STREQN (p+1, "space:]", 7))
-	    { pc = isspace (test); p += 8; }
-	  else if (STREQN (p+1, "upper:]", 7))
-	    { pc = isupper (test); p += 8; }
-	  else if (STREQN (p+1, "xdigit:]", 8))
-	    { pc = isxdigit (test); p += 9; }
-	  else if (STREQN (p+1, "ascii:]", 7))
-	    { pc = isascii (test); p += 8; }
-	  if (pc)
-	    {
-/*[*/	      /* Move past the closing `]', since the first thing we do at
-		 the `matched:' label is back p up one. */
-	      p++;
-	      goto matched;
-	    }
-	  else
-	    {
-	      /* continue the loop here, since this expression can't be
-		 the first part of a range expression. */
-	      c = *p++;
-	      if (c == '\0')
-		return ((test == '[') ? savep : (char *)0);
-	      else if (c == ']')
-		break;
-	      c = FOLD (c);
-	      continue;
-	    }
-	}
- 
-      /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
-	 the symbol name, make sure it is terminated by `.]', translate
-	 the name to a character using the external table, and do the
-	 comparison. */
-      if (c == '[' && *p == '.')
-	{
-	  p = parse_collsym (p, &pc);
-	  /* An invalid collating symbol cannot be the first point of a
-	     range.  If it is, we set cstart to one greater than `test',
-	     so any comparisons later will fail. */
-	  cstart = (pc == -1) ? test + 1 : pc;
-	}
-
-      if (!(flags & FNM_NOESCAPE) && c == '\\')
-	{
-	  if (*p == '\0')
-	    return (char *)0;
-	  cstart = cend = *p++;
-	}
-
-      cstart = cend = FOLD (cstart);
-
-      /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
-	 is not preceded by a backslash and is not part of a bracket
-	 expression produces undefined results.'  This implementation
-	 treats the `[' as just a character to be matched if there is
-	 not a closing `]'. */
-      if (c == '\0')
-	return ((test == '[') ? savep : (char *)0);
-
-      c = *p++;
-      c = FOLD (c);
-
-      if ((flags & FNM_PATHNAME) && c == '/')
-	/* [/] can never match when matching a pathname.  */
-	return (char *)0;
-
-      /* This introduces a range, unless the `-' is the last
-	 character of the class.  Find the end of the range
-	 and move past it. */
-      if (c == '-' && *p != ']')
-	{
-	  cend = *p++;
-	  if (!(flags & FNM_NOESCAPE) && cend == '\\')
-	    cend = *p++;
-	  if (cend == '\0')
-	    return (char *)0;
-	  if (cend == '[' && *p == '.')
-	    {
-	      p = parse_collsym (p, &pc);
-	      /* An invalid collating symbol cannot be the second part of a
-		 range expression.  If we get one, we set cend to one fewer
-		 than the test character to make sure the range test fails. */
-	      cend = (pc == -1) ? test - 1 : pc;
-	    }
-	  cend = FOLD (cend);
-
-	  c = *p++;
-
-	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
-	     equal to or higher than the starting range point; otherwise
-	     the expression shall be treated as invalid.''  Note that this
-	     applies to only the range expression; the rest of the bracket
-	     expression is still checked for matches. */
-	  if (rangecmp (cstart, cend) > 0)
-	    {
-	      if (c == ']')
-		break;
-	      c = FOLD (c);
-	      continue;
-	    }
-	}
-
-      if (rangecmp (test, cstart) >= 0 && rangecmp (test, cend) <= 0)
-	goto matched;
-
-      if (c == ']')
-	break;
-    }
-  /* No match. */
-  return (!not ? (char *)0 : p);
-
-matched:
-  /* Skip the rest of the [...] that already matched.  */
-#if 0
-  brcnt = (c != ']') + (c == '[' && (*p == '=' || *p == ':' || *p == '.'));
-#else
-  c = *--p;
-  brcnt = 1;
-#endif
-  while (brcnt > 0)
-    {
-      /* A `[' without a matching `]' is just another character to match. */
-      if (c == '\0')
-	return ((test == '[') ? savep : (char *)0);
-
-      c = *p++;
-      if (c == '[' && (*p == '=' || *p == ':' || *p == '.'))
-	brcnt++;
-      else if (c == ']')
-	brcnt--;
-      else if (!(flags & FNM_NOESCAPE) && c == '\\')
-	{
-	  if (*p == '\0')
-	    return (char *)0;
-	  /* XXX 1003.2d11 is unclear if this is right. */
-	  ++p;
-	}
+      if (STREQN(csp->name, s, len) && csp->name[len] == L'\0')
+	return (csp->code);
     }
-  return (not ? (char *)0 : p);
+  if (len == 1)
+    return s[0];
+  return INVALID;
 }
 
-#if defined (EXTENDED_GLOB)
-/* ksh-like extended pattern matching:
-
-	[?*+@!](pat-list)
-
-   where pat-list is a list of one or patterns separated by `|'.  Operation
-   is as follows:
-
-	?(patlist)	match zero or one of the given patterns
-	*(patlist)	match zero or more of the given patterns
-	+(patlist)	match one or more of the given patterns
-	@(patlist)	match exactly one of the given patterns
-	!(patlist)	match anything except one of the given patterns
-*/
-
-/* Scan a pattern starting at STRING and ending at END, keeping track of
-   embedded () and [].  If DELIM is 0, we scan until a matching `)'
-   because we're scanning a `patlist'.  Otherwise, we scan until we see
-   DELIM.  In all cases, we never scan past END.  The return value is the
-   first character after the matching DELIM. */
-static char *
-patscan (string, end, delim)
-     char *string, *end;
-     int delim;
+/* wide character classification. */
+static int
+is_wchar_class (wc, name)
+wint_t wc;
+wchar_t *name;
 {
-  int pnest, bnest, cchar;
-  char *s, c, *bfirst;
+  char *mbs;
+  mbstate_t state;
+  size_t mbslength;
+  wctype_t desc;
+
+  /* [[:ascii:] is bash ordinary character class. */
+  if (wctype("ascii") == (wctype_t)0)
+    if (wcscmp(name, L"ascii") == 0)
+      {
+	int c;
+	
+	if ((c = wctob (wc)) == EOF)
+	  return 0;
+        else
+          return(c <= 0x7F);
+      }
 
-  pnest = bnest = cchar = 0;
-  bfirst = 0;
-  for (s = string; c = *s; s++)
-    {
-      if (s >= end)
-	return (s);
-      switch (c)
-	{
-	case '\0':
-	  return ((char *)0);
-
-	/* `[' is not special inside a bracket expression, but it may
-	   introduce one of the special POSIX bracket expressions
-	   ([.SYM.], [=c=], [: ... :]) that needs special handling. */
-	case '[':
-	  if (bnest == 0)
-	    {
-	      bfirst = s + 1;
-	      if (*bfirst == '!' || *bfirst == '^')
-		bfirst++;
-	      bnest++;
-	    }
-	  else if (s[1] == ':' || s[1] == '.' || s[1] == '=')
-	    cchar = s[1];
-	  break;
-
-	/* `]' is not special if it's the first char (after a leading `!'
-	   or `^') in a bracket expression or if it's part of one of the
-	   special POSIX bracket expressions ([.SYM.], [=c=], [: ... :]) */
-	case ']':
-	  if (bnest)
-	    {
-	      if (cchar && s[-1] == cchar)
-		cchar = 0;
-	      else if (s != bfirst)
-		{
-		  bnest--;
-		  bfirst = 0;
-		}
-	    }
-	  break;
-
-	case '(':
-	  if (bnest == 0)
-	    pnest++;
-	  break;
-
-	case ')':
-#if 0
-	  if (bnest == 0)
-	    pnest--;
-	  if (pnest <= 0)
-	    return ++s;
-#else
-	  if (bnest == 0 && pnest-- <= 0)
-	    return ++s;
-#endif
-	  break;
+  memset (&state, '\0', sizeof (mbstate_t));
+  mbs = (char *) alloca (wcslen(name) * MB_CUR_MAX + 1);
 
-	case '|':
-	  if (bnest == 0 && pnest == 0 && delim == '|')
-	    return ++s;
-	  break;
-	}
-    }
+  mbslength = wcsrtombs(mbs, (const wchar_t **)&name,
+			 (wcslen(name) * MB_CUR_MAX + 1), &state);
+  
+  if (mbslength == (size_t)-1 || mbslength == (size_t)-2)
+    return -1;
+
+  desc = wctype(mbs);
+  if (desc == (wctype_t)0)
+    return -1;
 
-  return (char *)0;
+  return (iswctype(wc, desc));
 }
 
-/* Return 0 if dequoted pattern matches S in the current locale. */
-static int
-strcompare (p, pe, s, se)
-     char *p, *pe, *s, *se;
-{
-  int ret;
-  char c1, c2;
 
-  c1 = *pe;
-  c2 = *se;
+/* Now include "fnmatch_loop.c" for multibyte characters. */
+# define FOLD(c) ((flags & FNM_CASEFOLD) && iswupper (c) ? towlower (c) : (c))
+# define FCT			internal_fnwmatch
+# define GMATCH			gmatch_wc
+# define COLLSYM		collwcsym
+# define PARSE_COLLSYM		parse_collwcsym
+# define BRACKMATCH		brackmatch_wc
+# define PATSCAN		patscan_wc
+# define STRCOMPARE		strcompare_wc
+# define EXTMATCH		extmatch_wc
+# define STRCHR(S, C)		wcschr (S, C)
+# define STRCHRNUL(S, C)	__wcschrnul (S, C)
+# define STRCOLL(S1, S2) 	wcscoll (S1, S2)
+# define STRLEN(S)		wcslen(S)
+# define STRCMP(S1, S2)		wcscmp(S1, S2)
+# define RANGECMP(c1, c2)	rangecmp_wc(c1, c2)
+# define COLLEQUIV(c1, c2)	collequiv_wc (c1, c2)
+# define IS_CHAR_CLASS(C, S)	is_wchar_class(C, S)
 
-  *pe = *se = '\0';
-#if defined (HAVE_STRCOLL)
-  ret = strcoll (p, s);
-#else
-  ret = strcmp (p, s);
+# include "fnmatch_loop.c"
 #endif
 
-  *pe = c1;
-  *se = c2;
-
-  return (ret == 0 ? ret : FNM_NOMATCH);
-}
-
-/* Match a ksh extended pattern specifier.  Return FNM_NOMATCH on failure or
-   0 on success.  This is handed the entire rest of the pattern and string
-   the first time an extended pattern specifier is encountered, so it calls
-   gmatch recursively. */
-static int
-extmatch (xc, s, se, p, pe, flags)
-     int xc;		/* select which operation */
-     char *s, *se;
-     char *p, *pe;
+int
+fnmatch (pattern, string, flags)
+     char *pattern;
+     char *string;
      int flags;
 {
-  char *prest;			/* pointer to rest of pattern */
-  char *psub;			/* pointer to sub-pattern */
-  char *pnext;			/* pointer to next sub-pattern */
-  char *srest;			/* pointer to rest of string */
-  int m1, m2;
-
-#if DEBUG_MATCHING
-fprintf(stderr, "extmatch: xc = %c\n", xc);
-fprintf(stderr, "extmatch: s = %s; se = %s\n", s, se);
-fprintf(stderr, "extmatch: p = %s; pe = %s\n", p, pe);
-#endif
-
-  prest = patscan (p + (*p == '('), pe, 0); /* ) */
-  if (prest == 0)
-    /* If PREST is 0, we failed to scan a valid pattern.  In this
-       case, we just want to compare the two as strings. */
-    return (strcompare (p - 1, pe, s, se));
-
-  switch (xc)
-    {
-    case '+':			/* match one or more occurrences */
-    case '*':			/* match zero or more occurrences */
-      /* If we can get away with no matches, don't even bother.  Just
-	 call gmatch on the rest of the pattern and return success if
-	 it succeeds. */
-      if (xc == '*' && (gmatch (s, se, prest, pe, flags) == 0))
-	return 0;
-
-      /* OK, we have to do this the hard way.  First, we make sure one of
-	 the subpatterns matches, then we try to match the rest of the
-	 string. */
-      for (psub = p + 1; ; psub = pnext)
-	{
-	  pnext = patscan (psub, pe, '|');
-	  for (srest = s; srest <= se; srest++)
-	    {
-	      /* Match this substring (S -> SREST) against this
-		 subpattern (psub -> pnext - 1) */
-	      m1 = gmatch (s, srest, psub, pnext - 1, flags) == 0;
-	      /* OK, we matched a subpattern, so make sure the rest of the
-		 string matches the rest of the pattern.  Also handle
-		 multiple matches of the pattern. */
-	      if (m1)
-		m2 = (gmatch (srest, se, prest, pe, flags) == 0) ||
-		      (s != srest && gmatch (srest, se, p - 1, pe, flags) == 0);
-	      if (m1 && m2)
-		return (0);
-	    }
-	  if (pnext == prest)
-	    break;
-	}
-      return (FNM_NOMATCH);
-
-    case '?':		/* match zero or one of the patterns */
-    case '@':		/* match exactly one of the patterns */
-      /* If we can get away with no matches, don't even bother.  Just
-	 call gmatch on the rest of the pattern and return success if
-	 it succeeds. */
-      if (xc == '?' && (gmatch (s, se, prest, pe, flags) == 0))
-	return 0;
-
-      /* OK, we have to do this the hard way.  First, we see if one of
-	 the subpatterns matches, then, if it does, we try to match the
-	 rest of the string. */
-      for (psub = p + 1; ; psub = pnext)
-	{
-	  pnext = patscan (psub, pe, '|');
-	  srest = (prest == pe) ? se : s;
-	  for ( ; srest <= se; srest++)
-	    {
-	      if (gmatch (s, srest, psub, pnext - 1, flags) == 0 &&
-		  gmatch (srest, se, prest, pe, flags) == 0)
-		return (0);
-	    }
-	  if (pnext == prest)
-	    break;
-	}
-      return (FNM_NOMATCH);
-
-    case '!':		/* match anything *except* one of the patterns */
-      for (srest = s; srest <= se; srest++)
-	{
-	  m1 = 0;
-	  for (psub = p + 1; ; psub = pnext)
-	    {
-	      pnext = patscan (psub, pe, '|');
-	      /* If one of the patterns matches, just bail immediately. */
-	      if (m1 = (gmatch (s, srest, psub, pnext - 1, flags) == 0))
-		break;
-	      if (pnext == prest)
-		break;
-	    }
-	  if (m1 == 0 && gmatch (srest, se, prest, pe, flags) == 0)
-	    return (0);
-	}
-      return (FNM_NOMATCH);
-    }
+#if HANDLE_MULTIBYTE
+  mbstate_t ps;
+  size_t n;
+  wchar_t *wpattern;
+  wchar_t *wstring;
+
+  if (MB_CUR_MAX == 1)
+    /* This is an optimization for 8-bit character set.  */
+    return internal_fnmatch (pattern, string, flags);
+
+  /* Convert the strings into wide characters.  */
+  memset (&ps, '\0', sizeof (ps));
+  n = xmbsrtowcs (NULL, (const char **)&pattern, 0, &ps);
+  if (n == (size_t) -1)
+    /* Something wrong.
+       XXX Do we have to set `errno' to something which mbsrtows hasn't
+       already done?  */
+    return -1;
+  wpattern = (wchar_t *) alloca ((n + 1) * sizeof (wchar_t));
+  (void) xmbsrtowcs (wpattern, (const char **)&pattern, n + 1, &ps);
+
+  n = xmbsrtowcs (NULL, (const char **)&string, 0, &ps);
+  if (n == (size_t) -1)
+    /* Something wrong.
+       XXX Do we have to set `errno' to something which mbsrtows hasn't
+       already done?  */
+    return -1;
+  wstring = (wchar_t *) alloca ((n + 1) * sizeof (wchar_t));
+  (void) xmbsrtowcs (wstring, (const char **)&string, n + 1, &ps);
 
-  return (FNM_NOMATCH);
+  return internal_fnwmatch (wpattern, wstring, flags);
+#else
+  return internal_fnmatch (pattern, string, flags);
+#endif
 }
-#endif /* EXTENDED_GLOB */
 
 #ifdef TEST
 main (c, v)
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/lib/glob/fnmatch.h bash-2.05/lib/glob/fnmatch.h
--- bash-2.05.orig/lib/glob/fnmatch.h	Thu Aug  5 20:56:38 1999
+++ bash-2.05/lib/glob/fnmatch.h	Wed Apr 18 16:23:12 2001
@@ -1,20 +1,20 @@
-/* Copyright (C) 1991 Free Software Foundation, Inc.
-This file is part of the GNU C Library.
+/* Copyright (C) 1991, 92, 93, 96, 97, 98, 99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
 
-The GNU C Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The GNU C Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
-
-You should have received a copy of the GNU Library General Public
-License along with the GNU C Library; see the file COPYING.LIB.  If
-not, write to the Free Software Foundation, Inc.,
-59 Temple Place, Suite 330, Boston, MA 02111 USA.  */
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
 
 #ifndef	_FNMATCH_H
 #define	_FNMATCH_H	1
@@ -23,26 +23,27 @@
 
 /* We #undef these before defining them because some losing systems
    (HP-UX A.08.07 for example) define these in <unistd.h>.  */
-#undef  FNM_PATHNAME
-#undef  FNM_NOESCAPE
-#undef  FNM_PERIOD
+#undef	FNM_PATHNAME
+#undef	FNM_NOESCAPE
+#undef	FNM_PERIOD
 
 /* Bits set in the FLAGS argument to `fnmatch'.  */
 /* standard flags */
 #define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
 #define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
 #define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
+#define FNM_FILE_NAME	 FNM_PATHNAME	/* Preferred GNU name.  */
 
 /* extended flags */
-#define FNM_LEADING_DIR	(1 << 3) /* Ignore `/...' after a match. */
-#define FNM_CASEFOLD	(1 << 4) /* Compare without regard to case. */
-#define FNM_EXTMATCH	(1 << 5) /* Use ksh-like extended matching. */
+#define FNM_LEADING_DIR (1 << 3)	/* Ignore `/...' after a match.  */
+#define FNM_CASEFOLD	(1 << 4)	/* Compare without regard to case.  */
+#define FNM_EXTMATCH    (1 << 5) /* Use ksh-like extended matching. */
 
 /* Value returned by `fnmatch' if STRING does not match PATTERN.  */
 #define	FNM_NOMATCH	1
 
-/* Match STRING against the filename pattern PATTERN,
+/* Match NAME against the filename pattern PATTERN,
    returning zero if it matches, FNM_NOMATCH if not.  */
-extern int fnmatch __P((char *, char *, int));
+extern int fnmatch __P ((char *__pattern, char *__name, int __flags));
 
-#endif /* _FNMATCH_H */
+#endif /* fnmatch.h */
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/lib/glob/fnmatch_loop.c bash-2.05/lib/glob/fnmatch_loop.c
--- bash-2.05.orig/lib/glob/fnmatch_loop.c	Thu Jan  1 09:00:00 1970
+++ bash-2.05/lib/glob/fnmatch_loop.c	Wed Apr 18 16:23:12 2001
@@ -0,0 +1,740 @@
+/* Copyright (C) 1991-1993, 1996-1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+static int FCT (CHAR *pattern, CHAR *string, int flags);
+static int GMATCH(CHAR *string, CHAR *se, CHAR *pattern, CHAR *pe, int flags);
+static CHAR *PARSE_COLLSYM (CHAR *p, INT *vp);
+static CHAR *BRACKMATCH (CHAR *p, INT test, int flags);
+static int EXTMATCH (INT xc, CHAR *s, CHAR *se, CHAR *p, CHAR *pe, int flags);
+static CHAR *PATSCAN (CHAR *string, CHAR *end, INT delim);
+
+/* Match STRING against the filename pattern PATTERN, returning zero if
+   it matches, nonzero if not.  */
+
+static int
+FCT (pattern, string, flags)
+     CHAR *pattern;
+     CHAR *string;
+     int flags;
+{
+  CHAR *se, *pe;
+
+  if (string == 0 || pattern == 0)
+    return FNM_NOMATCH;
+
+  se = string + STRLEN (string);
+  pe = pattern + STRLEN (pattern);
+
+  return (GMATCH (string, se, pattern, pe, flags));
+}
+
+static int
+GMATCH (string, se, pattern, pe, flags)
+    CHAR *string, *se;
+    CHAR *pattern, *pe;
+    int flags;
+{
+  CHAR *p, *n;		/* pattern, string */
+  INT c;		/* current pattern character */
+  INT sc;		/* current string character */
+
+  p = pattern;
+  n = string;
+
+  if (string == 0 || pattern == 0)
+    return FNM_NOMATCH;
+
+#if DEBUG_MATCHING
+fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
+fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
+#endif
+
+  while (p < pe)
+    {
+      c = *p++;
+      c = FOLD (c);
+
+      sc = n < se ? *n : L('\0');
+
+#ifdef EXTENDED_GLOB
+      /* EXTMATCH () will handle recursively calling GMATCH, so we can
+	 just return what EXTMATCH() returns. */
+      if ((flags & FNM_EXTMATCH) && *p == L('(') &&
+	  (c == L('+') || c == L('*') || c == L('?')
+				|| c == L('@') || c == (L('!')))) /* ) */
+	{
+	  int lflags;
+	  /* If we're not matching the start of the string, we're not
+	     concerned about the special cases for matching `.' */
+	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
+	  return (EXTMATCH (c, n, se, p, pe, lflags));
+	}
+#endif
+
+      switch (c)
+	{
+	case L('?'):		/* Match single character */
+	  if (sc == L('\0'))
+	    return FNM_NOMATCH;
+	  else if (sc == L('/') && (flags & FNM_FILE_NAME))
+	    /* If we are matching a pathname, `?' can never match a `/'. */
+	    return FNM_NOMATCH;
+	  else if (sc == L('.') && (flags & FNM_PERIOD)
+		   && (n == string
+		       || (n[-1] == L('/') && (flags & FNM_FILE_NAME))))
+	    /* `?' cannot match a `.' if it is the first character of the
+	       string or if it is the first character following a slash and
+	       we are matching a pathname. */
+	    return FNM_NOMATCH;
+	  break;
+
+	case L('\\'):		/* backslash escape removes special meaning */
+	  if (p == pe)
+	    return FNM_NOMATCH;
+
+	  if (!(flags & FNM_NOESCAPE))
+	    {
+	      c = *p++;
+	      /* A trailing `\' cannot match. */
+	      if (p > pe)
+		return FNM_NOMATCH;
+	      c = FOLD (c);
+	    }
+	  if (FOLD (sc) != c)
+	    return FNM_NOMATCH;
+	  break;
+
+	case L('*'):		/* Match zero or more characters */
+	  if (p == pe)
+	    return 0;
+
+	  if (sc == L('.') && (flags & FNM_PERIOD)
+	      && (n == string
+		  || (n[-1] == L('/') && (flags & FNM_FILE_NAME))))
+	    /* `*' cannot match a `.' if it is the first character of the
+	       string or if it is the first character following a slash and
+	       we are matching a pathname. */
+	    return FNM_NOMATCH;
+
+	  /* Collapse multiple consecutive, `*' and `?', but make sure that
+	     one character of the string is consumed for each `?'. */
+	  for (c = *p++; c == L('?') || c == L('*'); c = *p++)
+	    {
+	      if (sc == L('/') && (flags & FNM_FILE_NAME))
+		/* A slash does not match a wildcard under FNM_FILE_NAME.  */
+		return FNM_NOMATCH;
+	      else if (c == L('?'))
+		{
+		  /* A ? needs to match one character.  */
+		  if (sc == L('\0'))
+		    /* There isn't another character; no match.  */
+		    return FNM_NOMATCH;
+		  else
+		    /* One character of the string is consumed in matching
+		       this ? wildcard, so *??? won't match if there are
+		       less than three characters.  */
+		    ++n;
+		    sc = n < se ? *n : '\0';
+		}
+
+#ifdef EXTENDED_GLOB
+	      /* Handle ******(patlist) */
+	      if ((flags & FNM_EXTMATCH) && c == L('*') && *p == L('('))  /*)*/
+		{
+		  CHAR *newn;
+		  /* We need to check whether or not the extended glob
+		     pattern matches the remainder of the string.
+		     If it does, we match the entire pattern. */
+		  for (newn = n; newn < se; ++newn)
+		    {
+		      if (EXTMATCH (c, newn, se, p, pe, flags) == 0)
+			return 0;
+		    }
+		  /* We didn't match the extended glob pattern, but
+		     that's OK, since we can match 0 or more occurrences.
+		     We need to skip the glob pattern and see if we
+		     match the rest of the string. */
+		  newn = PATSCAN (p + 1, pe, 0);
+		  p = newn;
+		}
+#endif
+	      if (p == pe)
+		break;
+	    }
+
+	  /* If we've hit the end of the pattern and the last character of
+	     the pattern was handled by the loop above, we've succeeded.
+	     Otherwise, we need to match that last character. */
+	  if (p == pe && (c == L('?') || c == L('*')))
+	    return 0;
+
+	  /* General case, use recursion. */
+	  {
+	    INT c1;
+
+	    c1 = ((flags & FNM_NOESCAPE) == 0 && c == L('\\')) ? *p : c;
+	    c1 = FOLD (c1);
+	    for (--p; n < se; ++n)
+	      {
+		/* Only call fnmatch if the first character indicates a
+		   possible match.  We can check the first character if
+		   we're not doing an extended glob match. */
+		if ((flags & FNM_EXTMATCH) == 0 && c != L('[') && FOLD (*n) != c1)
+		  continue;
+
+		/* If we're doing an extended glob match and the pattern is not
+		   one of the extended glob patterns, we can check the first
+		   character. */
+		if ((flags & FNM_EXTMATCH) && p[1] != L('(') && /*)*/
+		    STRCHR (L("?*+@!"), *p) == 0 && c != L('[') && FOLD (*n) != c1)
+		  continue;
+
+		/* Otherwise, we just recurse. */
+		if (GMATCH (n, se, p, pe, flags & ~FNM_PERIOD) == 0)
+		  return 0;
+	      }
+	    return FNM_NOMATCH;
+	  }
+
+	case L('['):
+	  {
+	    if (sc == L('\0') || n == se)
+	      return FNM_NOMATCH;
+
+	    /* A character class cannot match a `.' if it is the first
+	       character of the string or if it is the first character
+	       following a slash and we are matching a pathname. */
+	    if (sc == L('.') && (flags & FNM_PERIOD) &&
+		(n == string || (n[-1] == L('/') && (flags & FNM_FILE_NAME))))
+	      return FNM_NOMATCH;
+
+	    p = BRACKMATCH (p, sc, flags);
+	    if (p == 0)
+	      return FNM_NOMATCH;
+	  }
+	  break;
+
+	default:
+	  if (c != FOLD (sc))
+	    return FNM_NOMATCH;
+	}
+
+      ++n;
+    }
+
+  if (n == se)
+    return 0;
+
+  if ((flags & FNM_LEADING_DIR) && *n == L('/'))
+    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
+    return 0;
+
+  return FNM_NOMATCH;
+}
+
+/* Parse a bracket expression collating symbol ([.sym.]) starting at P, find
+   the value of the symbol, and move P past the collating symbol expression.
+   The value is returned in *VP, if VP is not null. */
+static CHAR *
+PARSE_COLLSYM (p, vp)
+     CHAR *p;
+     INT *vp;
+{
+  int pc;
+  INT val;
+
+  p++;                          /* move past the `.' */
+
+  for (pc = 0; p[pc]; pc++)
+    if (p[pc] == L('.') && p[pc+1] == L(']'))
+      break;
+   val = COLLSYM (p, pc);
+   if (vp)
+     *vp = val;
+   return (p + pc + 2);
+}
+
+static CHAR *
+BRACKMATCH (p, test, flags)
+     CHAR *p;
+     INT test;
+     int flags;
+{
+  CHAR cstart, cend, c;
+  int not; /* Nonzero if the sense of the character class is inverted.  */
+  int brcnt;
+  INT pc;
+  CHAR *savep;
+
+  test = FOLD (test);
+    
+  savep = p;
+
+  /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
+     circumflex (`^') in its role in a `nonmatching list'.  A bracket
+     expression starging with an unquoted character produces
+     unspecified results.  This implementation treats the two identically. */
+  if (not = (*p == L('!') || *p == L('^')))
+    ++p;
+
+  c = *p++;
+  for (;;)
+    {
+      /* Initialize cstart and cend in case `-' is the last
+	 character of the pattern. */
+      cstart = cend = c;
+
+      /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
+	 the end of the equivalence class, move the pattern pointer past
+	 it, and check for equivalence.  XXX - this handles only
+	 single-character equivalence classes, which is wrong, or at
+	 least incomplete. */
+      if (c == L('[') && *p == L('=') && p[2] == L('=') && p[3] == L(']'))
+	{
+	  pc = FOLD (p[1]);
+	  p += 4;
+	  if (COLLEQUIV (test, pc))
+	    {
+/*[*/         /* Move past the closing `]', since the first thing we do at
+                 the `matched:' label is back p up one. */
+	      p++;
+	      goto matched;
+	    }
+	  else
+	    {
+	      c = *p++;
+	      if (c == L('\0'))
+		return ((test == L('[')) ? savep : (CHAR *)0);	/*]*/
+	      c = FOLD (c);
+	      continue;
+	    }
+	}
+
+      /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
+      if (c == L('[') && *p == L(':'))	/*]*/
+	{
+	  CHAR *close, *connotation;
+
+	  pc = 0;
+	  for (close = p + 1; *close != L('\0'); close++)
+	    if (*close == L(':') && *(close + 1) == L(']'))
+	      break;
+
+	  if (*close != L('\0'))
+	    {
+	      connotation = (CHAR *) (alloca ((close - p) * sizeof(CHAR)));
+	      memcpy (connotation, p + 1, (close - p - 1) * sizeof(CHAR));
+	      *(connotation + (close - p - 1)) = L('\0');
+
+	      pc = IS_CHAR_CLASS (test, connotation);
+	      if (pc == -1)
+		pc = 0;
+	      else
+		p = close + 2;
+	    }
+
+	  if (pc)
+	    {
+/*[*/         /* Move past the closing `]', since the first thing we do at
+                 the `matched:' label is back p up one. */
+	      p++;
+	      goto matched;
+	    }
+	  else
+	    {
+	      /* continue the loop here, since this expression can't be
+		 the first part of a range expression. */
+	      c = *p++;
+	      if (c == L('\0'))
+		return ((test == L('[')) ? savep : (CHAR *)0);
+	      else if (c == L(']'))
+		break;
+	      c = FOLD (c);
+	      continue;
+	    }
+	}
+
+      /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
+	 the symbol name, make sure it is terminated by `.]', translate
+	 the name to a character using the external table, and do the
+	 comparison. */
+      if (c == L('[') && *p == L('.'))
+	{
+	  p = PARSE_COLLSYM (p, &pc);
+	  /* An invalid collating symbol cannot be the first point of a
+	     range.  If it is, we set cstart to one greater than `test',
+	     so any comparisons later will fail. */
+	  cstart = (pc == INVALID) ? test + 1 : pc;
+	}
+
+      if (!(flags & FNM_NOESCAPE) && c == L('\\'))
+	{
+	  if (*p == L('\0'))
+	    return (CHAR *)0;
+	  cstart = cend = *p++;
+	}
+
+      cstart = cend = FOLD (cstart);
+
+      /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
+	 is not preceded by a backslash and is not part of a bracket
+	 expression produces undefined results.'  This implementation
+	 treats the `[' as just a character to be matched if there is
+	 not a closing `]'. */
+      if (c == L('\0'))
+	return ((test == L('[')) ? savep : (CHAR *)0);
+
+      c = *p++;
+      c = FOLD (c);
+
+      if ((flags & FNM_PATHNAME) && c == L('/'))
+	/* [/] can never match when matching a pathname.  */
+	return (CHAR *)0;
+
+      /* This introduces a range, unless the `-' is the last
+	 character of the class.  Find the end of the range
+	 and move past it. */
+      if (c == L('-') && *p != L(']'))
+	{
+	  cend = *p++;
+	  if (!(flags & FNM_NOESCAPE) && cend == L('\\'))
+	    cend = *p++;
+	  if (cend == L('\0'))
+	    return (CHAR *)0;
+	  if (cend == L('[') && *p == L('.'))
+	    {
+	      p = PARSE_COLLSYM (p, &pc);
+	      /* An invalid collating symbol cannot be the second part of a
+		 range expression.  If we get one, we set cend to one fewer
+		 than the test character to make sure the range test fails. */
+	      cend = (pc == -1) ? test - 1 : pc;
+	    }
+	  cend = FOLD (cend);
+
+	  c = *p++;
+
+	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
+	     equal to or higher than the starting range point; otherwise
+	     the expression shall be treated as invalid.''  Note that this
+	     applies to only the range expression; the rest of the bracket
+	     expression is still checked for matches. */
+	  if (RANGECMP (cstart, cend) > 0)
+	    {
+	      if (c == L(']'))
+		break;
+	      c = FOLD (c);
+	      continue;
+	    }
+	}
+
+      if (RANGECMP (test, cstart) >= 0 && RANGECMP (test, cend) <= 0)
+	goto matched;
+
+      if (c == L(']'))
+	break;
+    }
+  /* No match. */
+  return (!not ? (CHAR *)0 : p);
+
+matched:
+  /* Skip the rest of the [...] that already matched.  */
+#if 0
+  brcnt = (c != L(']')) + (c == L('[') && (*p == L('=')
+		|| *p == L(':') || *p == L('.')));
+#else
+  c= *--p;
+  brcnt = 1;
+#endif
+  while (brcnt > 0)
+    {
+      /* A `[' without a matching `]' is just another character to match. */
+      if (c == L('\0'))
+	return ((test == L('[')) ? savep : (CHAR *)0);
+
+      c = *p++;
+      if (c == L('[') && (*p == L('=') || *p == L(':') || *p == L('.')))
+	brcnt++;
+      else if (c == L(']'))
+	brcnt--;
+      else if (!(flags & FNM_NOESCAPE) && c == L('\\'))
+	{
+	  if (*p == L('\0'))
+	    return (CHAR *)0;
+	  /* XXX 1003.2d11 is unclear if this is right. */
+	  ++p;
+	}
+    }
+  return (not ? (CHAR *)0 : p);
+}
+
+#if defined (EXTENDED_GLOB)
+/* ksh-like extended pattern matching:
+
+	[?*+@!](pat-list)
+
+   where pat-list is a list of one or patterns separated by `|'.  Operation
+   is as follows:
+
+	?(patlist)      match zero or one of the given patterns
+	*(patlist)      match zero or more of the given patterns
+	+(patlist)      match one or more of the given patterns
+	@(patlist)      match exactly one of the given patterns
+	!(patlist)      match anything except one of the given patterns
+*/
+
+/* Scan a pattern starting at STRING and ending at END, keeping track of
+   embedded () and [].  If DELIM is 0, we scan until a matching `)'
+   because we're scanning a `patlist'.  Otherwise, we scan until we see
+   DELIM.  In all cases, we never scan past END.  The return value is the
+   first character after the matching DELIM. */
+static CHAR *
+PATSCAN (string, end, delim)
+     CHAR *string, *end;
+     INT delim;
+{
+  int pnest, bnest;
+  CHAR *s, c, *bfirst;
+  INT cchar;
+
+  pnest = bnest = 0;
+  cchar = 0;
+  bfirst = NULL;
+  for (s = string; c = *s; s++)
+    {
+      if (s >= end)
+	return (s);
+      switch (c)
+	{
+	case L('\0'):
+	  return (NULL);
+
+        /* `[' is not special inside a bracket expression, but it may
+           introduce one of the special POSIX bracket expressions
+           ([.SYM.], [=c=], [: ... :]) that needs special handling. */
+	case L('['):
+	  if (bnest == 0)
+	    {
+	      bfirst = s + 1;
+	      if (*bfirst == L('!') || *bfirst == L('^'))
+		bfirst++;
+	      bnest++;
+	    }
+	  else if (s[1] == L(':') || s[1] == L('.') || s[1] == L('='))
+	    cchar = s[1];
+	  break;
+
+        /* `]' is not special if it's the first char (after a leading `!'
+           or `^') in a bracket expression or if it's part of one of the
+           special POSIX bracket expressions ([.SYM.], [=c=], [: ... :]) */
+	case L(']'):
+	  if (bnest)
+	    {
+	      if (cchar && s[-1] == cchar)
+		cchar = 0;
+	      else if (s != bfirst)
+		{
+		  bnest--;
+		  bfirst = 0;
+		}
+	    }
+	  break;
+
+	case L('('):
+	  if (bnest == 0)
+	    pnest++;
+	  break;
+
+	case L(')'):
+#if 0
+	  if (bnest == 0)
+	    pnest--;
+	  if (pnest <= 0)
+	    return ++s;
+#else
+	  if (bnest == 0 && pnest-- <= 0)
+	    return ++s;
+#endif
+	  break;
+
+	case L('|'):
+	  if (bnest == 0 && pnest == 0 && delim == L('|'))
+	    return ++s;
+	  break;
+	}
+    }
+
+  return NULL;
+}
+
+/* Return 0 if dequoted pattern matches S in the current locale. */
+static int
+STRCOMPARE (p, pe, s, se)
+     CHAR *p, *pe, *s, *se;
+{
+  int ret;
+  CHAR c1, c2;
+
+  c1 = *pe;
+  c2 = *se;
+
+  *pe = *se = L('\0');
+#if HANDLE_MULTIBYTE || defined (HAVE_STRCOLL)
+  ret = STRCOLL (p, s);
+#else
+  ret = STRCMP (p, s);
+#endif
+
+  *pe = c1;
+  *se = c2;
+
+  return (ret == 0 ? ret : FNM_NOMATCH);
+}
+
+/* Match a ksh extended pattern specifier.  Return FNM_NOMATCH on failure or
+   0 on success.  This is handed the entire rest of the pattern and string
+   the first time an extended pattern specifier is encountered, so it calls
+   GMATCH recursively. */
+static int
+EXTMATCH (xc, s, se, p, pe, flags)
+     INT xc;            /* select which operation */
+     CHAR *s, *se;
+     CHAR *p, *pe;
+     int flags;
+{
+  CHAR *prest;                  /* pointer to rest of pattern */
+  CHAR *psub;                   /* pointer to sub-pattern */
+  CHAR *pnext;                  /* pointer to next sub-pattern */
+  CHAR *srest;                  /* pointer to rest of string */
+  int m1, m2;
+
+#if DEBUG_MATCHING
+fprintf(stderr, "EXTMATCH: xc = %c\n", xc);
+fprintf(stderr, "EXTMATCH: s = %s; se = %s\n", s, se);
+fprintf(stderr, "EXTMATCH: p = %s; pe = %s\n", p, pe);
+#endif
+
+  prest = PATSCAN (p + (*p == L('(')), pe, 0); /* ) */
+  if (prest == 0)
+    /* If PREST is 0, we failed to scan a valid pattern.  In this
+       case, we just want to compare the two as strings. */
+    return (STRCOMPARE (p - 1, pe, s, se));
+
+  switch (xc)
+    {
+    case L('+'):                   /* match one or more occurrences */
+    case L('*'):                   /* match zero or more occurrences */
+      /* If we can get away with no matches, don't even bother.  Just
+	 call GMATCH on the rest of the pattern and return success if
+	 it succeeds. */
+      if (xc == L('*') && (GMATCH (s, se, prest, pe, flags) == 0))
+	return 0;
+
+      /* OK, we have to do this the hard way.  First, we make sure one of
+	 the subpatterns matches, then we try to match the rest of the
+	 string. */
+      for (psub = p + 1; ; psub = pnext)
+	{
+	  pnext = PATSCAN (psub, pe, L('|'));
+	  for (srest = s; srest <= se; srest++)
+	    {
+	      /* Match this substring (S -> SREST) against this
+		 subpattern (psub -> pnext - 1) */
+	      m1 = GMATCH (s, srest, psub, pnext - 1, flags) == 0;
+	      /* OK, we matched a subpattern, so make sure the rest of the
+		 string matches the rest of the pattern.  Also handle
+		 multiple matches of the pattern. */
+	      if (m1)
+		m2 = (GMATCH (srest, se, prest, pe, flags) == 0) ||
+		      (s != srest && GMATCH (srest, se, p - 1, pe, flags) == 0);
+	      if (m1 && m2)
+		return 0;
+	    }
+	  if (pnext == prest)
+	    break;
+	}
+      return FNM_NOMATCH;
+
+    case L('?'):           /* match zero or one of the patterns */
+    case L('@'):           /* match exactly one of the patterns */
+      /* If we can get away with no matches, don't even bother.  Just
+	 call GMATCH on the rest of the pattern and return success if
+	 it succeeds. */
+      if (xc == L('?') && (GMATCH (s, se, prest, pe, flags) == 0))
+	return 0;
+
+      /* OK, we have to do this the hard way.  First, we see if one of
+	 the subpatterns matches, then, if it does, we try to match the
+	 rest of the string. */
+      for (psub = p + 1; ; psub = pnext)
+	{
+	  pnext = PATSCAN (psub, pe, L('|'));
+	  srest = (prest == pe) ? se : s;
+	  for ( ; srest <= se; srest++)
+	    {
+	      if (GMATCH (s, srest, psub, pnext - 1, flags) == 0 &&
+		  GMATCH (srest, se, prest, pe, flags) == 0)
+		return 0;
+	    }
+	  if (pnext == prest)
+	    break;
+	}
+      return FNM_NOMATCH;
+
+    case L('!'):           /* match anything *except* one of the patterns */
+      for (srest = s; srest <= se; srest++)
+	{
+	  m1 = 0;
+	  for (psub = p + 1; ; psub = pnext)
+	    {
+	      pnext = PATSCAN (psub, pe, L('|'));
+	      /* If one of the patterns matches, just bail immediately. */
+	      if (m1 = (GMATCH (s, srest, psub, pnext - 1, flags) == 0))
+		break;
+	      if (pnext == prest)
+		break;
+	    }
+	  if (m1 == 0 && GMATCH (srest, se, prest, pe, flags) == 0)
+	    return 0;
+	}
+      return FNM_NOMATCH;
+    }
+
+  return FNM_NOMATCH;
+}
+#endif /* EXTENDED_GLOB */
+
+#undef IS_CHAR_CLASS
+#undef FOLD
+#undef CHAR
+#undef INT
+#undef INVALID
+#undef FCT
+#undef GMATCH
+#undef COLLSYM
+#undef PARSE_COLLSYM
+#undef PATSCAN
+#undef STRCOMPARE
+#undef EXTMATCH
+#undef BRACKMATCH
+#undef STRCHR
+#undef STRCOLL
+#undef STRLEN
+#undef STRCMP
+#undef COLLEQUIV
+#undef RANGECMP
+#undef L
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/lib/glob/glob.c bash-2.05/lib/glob/glob.c
--- bash-2.05.orig/lib/glob/glob.c	Thu Feb 15 06:53:39 2001
+++ bash-2.05/lib/glob/glob.c	Wed Apr 18 16:23:12 2001
@@ -48,6 +48,10 @@
 #  endif /* !HAVE_STRING_H */
 #endif
 
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
 #if defined (HAVE_DIRENT_H)
 #  include <dirent.h>
 #  define D_NAMLEN(d) strlen ((d)->d_name)
@@ -94,6 +98,20 @@
 #  include "memalloc.h"
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define wcsrtombs(dest, src, len, ps) (wcsrtombs) (dest, src, len, 0)
+#endif
+
 #include "fnmatch.h"
 
 #if !defined (HAVE_STDLIB_H) && !defined (SHELL)
@@ -128,46 +146,51 @@
 /* Global variable to return to signify an error in globbing. */
 char *glob_error_return;
 
+/* Compile `glob_loop.c' for unibyte characters. */
+#define CHAR    unsigned char
+#define INT     int
+#define L(CS)   CS
+#define INTERNAL_GLOB_PATTERN_P internal_glob_pattern_p
+#include "glob_loop.c"
+
+/* Compile 'glob_loop.c' again for multibyte characters. */
+#if HANDLE_MULTIBYTE
+# include "xmbsrtowcs.h"
+
+# define L(CS)   L##CS
+# define CHAR    wchar_t
+# define INT     wint_t
+# define INTERNAL_GLOB_PATTERN_P internal_glob_wpattern_p
+# include "glob_loop.c"
+#endif
+
 /* Return nonzero if PATTERN has any special globbing chars in it.  */
 int
 glob_pattern_p (pattern)
      char *pattern;
 {
-  register char *p;
-  register char c;
-  int bopen;
-
-  p = pattern;
-  bopen = 0;
-
-  while ((c = *p++) != '\0')
-    switch (c)
-      {
-      case '?':
-      case '*':
-	return (1);
-
-      case '[':		/* Only accept an open brace if there is a close */
-	bopen++;	/* brace to match it.  Bracket expressions must be */
-	continue;	/* complete, according to Posix.2 */
-      case ']':
-	if (bopen)
-	  return (1);
-	continue;      
-
-      case '+':		/* extended matching operators */
-      case '@':
-      case '!':
-	if (*p == '(')	/*) */
-	  return (1);
-	continue;
-
-      case '\\':
-	if (*p++ == '\0')
-	  return (0);
-      }
+#if HANDLE_MULTIBYTE
+  mbstate_t ps;
+  size_t n;
+  wchar_t *wpattern;
+
+  if (MB_CUR_MAX == 1)
+    /* This is an optimization for 8-bit character set.  */
+    return internal_glob_pattern_p (pattern);
+
+  /* Convert the strings into wide characters.  */
+  memset (&ps, '\0', sizeof (ps));
+  n = xmbsrtowcs (NULL, (const char **)&pattern, 0, &ps);
+  if (n == (size_t) -1)
+    /* Something wrong. */
+    return -1;
+  wpattern = (wchar_t *) alloca ((n + 1) * sizeof (wchar_t));
+  (void) xmbsrtowcs (wpattern, (const char **)&pattern, n + 1, &ps);
 
-  return (0);
+  return internal_glob_wpattern_p (wpattern);
+#else
+  return internal_glob_pattern_p (pattern);
+#endif
 }
 
 /* Remove backslashes quoting characters in PATHNAME by modifying PATHNAME. */
@@ -175,23 +198,65 @@
 dequote_pathname (pathname)
      char *pathname;
 {
-  register int i, j;
+#if HANDLE_MULTIBYTE
+  if (MB_CUR_MAX > 1)
+    {
+      mbstate_t ps;
+      size_t len, n;
+      wchar_t *wpathname;
+      char *pathname_bak;
+      int i, j;
+
+      len = strlen (pathname);
+      pathname_bak = (char *) alloca (len + 1);
+      memcpy (pathname_bak, pathname , len + 1);
+
+      /* Convert the strings into wide characters.  */
+      memset (&ps, '\0', sizeof (ps));
+      n = xmbsrtowcs (NULL, (const char **)&pathname_bak, 0, &ps);
+      if (n == (size_t) -1)
+	/* Something wrong. */
+	return;
+
+      wpathname = (wchar_t *) alloca ((n + 1) * sizeof (wchar_t));
+      (void) xmbsrtowcs (wpathname, (const char **)&pathname_bak, n + 1, &ps);
+
+      for (i = j = 0; wpathname && wpathname[i]; )
+	{
+	  if (wpathname[i] == L'\\')
+	    i++;
+
+	  wpathname[j++] = wpathname[i++];
 
-  for (i = j = 0; pathname && pathname[i]; )
+	  if (!wpathname[i - 1])
+	    break;
+	}
+      wpathname[j] = L'\0';
+
+      /* Convert the wide character string into unibyte character set. */
+      memset (&ps, '\0', sizeof(mbstate_t));
+      n = wcsrtombs(pathname, (const wchar_t **)&wpathname, len, &ps);
+      pathname[len] = '\0';
+    }
+  else
+#endif
     {
-      if (pathname[i] == '\\')
-	i++;
+      register int i, j;
 
-      pathname[j++] = pathname[i++];
+      for (i = j = 0; pathname && pathname[i]; )
+	{
+	  if (pathname[i] == '\\')
+	    i++;
+
+	  pathname[j++] = pathname[i++];
 
-      if (!pathname[i - 1])
-	break;
+	  if (!pathname[i - 1])
+	    break;
+	}
+      pathname[j] = '\0';
     }
-  pathname[j] = '\0';
 }
 
-
-
 /* Test whether NAME exists. */
 
 #if defined (HAVE_LSTAT)
@@ -379,20 +444,72 @@
 	  if (REAL_DIR_ENTRY (dp) == 0)
 	    continue;
 
-	  /* If a leading dot need not be explicitly matched, and the pattern
-	     doesn't start with a `.', don't match `.' or `..' */
-#define dname dp->d_name
-	  if (noglob_dot_filenames == 0 && pat[0] != '.' &&
-		(pat[0] != '\\' || pat[1] != '.') &&
-		(dname[0] == '.' &&
-		  (dname[1] == '\0' || (dname[1] == '.' && dname[2] == '\0'))))
-#undef dname
-	    continue;
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      char *pat_bak, *dn_bak;
+	      wchar_t *pat_wc, *dn_wc;
+	      mbstate_t pat_ps, dn_ps;
+	      size_t pat_n, dn_n, n;
+
+	      n = strlen(pat);
+	      pat_bak = (char *) alloca (n + 1);
+	      memcpy (pat_bak, pat, n + 1);
+
+	      n = strlen(dp->d_name);
+	      dn_bak = (char *) alloca (n + 1);
+	      memcpy (dn_bak, dp->d_name,  n + 1);
 
-	  /* If a dot must be explicity matched, check to see if they do. */
-	  if (noglob_dot_filenames && dp->d_name[0] == '.' && pat[0] != '.' &&
-		(pat[0] != '\\' || pat[1] != '.'))
-	    continue;
+	      memset(&pat_ps, '\0', sizeof(mbstate_t));
+	      memset(&dn_ps, '\0', sizeof(mbstate_t));
+
+	      pat_n = xmbsrtowcs (NULL, (const char **)&pat_bak, 0, &pat_ps);
+	      dn_n = xmbsrtowcs (NULL, (const char **)&dn_bak, 0, &dn_ps);
+
+	      if (pat_n != (size_t)-1 && dn_n !=(size_t)-1)
+		{
+		  pat_wc = (wchar_t *) alloca ((pat_n + 1) * sizeof(wchar_t));
+		  dn_wc = (wchar_t *) alloca ((dn_n + 1) * sizeof(wchar_t));
+
+		  (void) xmbsrtowcs (pat_wc, (const char **)&pat_bak,
+					 pat_n + 1, &pat_ps);
+		  (void) xmbsrtowcs (dn_wc, (const char **)&dn_bak,
+					 dn_n + 1, &dn_ps);
+
+		  /* If a leading dot need not be explicitly matched, and the
+		    pattern doesn't start with a `.', don't match `.' or `..' */
+		  if (noglob_dot_filenames == 0 && pat_wc[0] != L'.' &&
+			(pat_wc[0] != L'\\' || pat_wc[1] != L'.') &&
+			(dn_wc[0] == L'.' &&
+			(dn_wc[1] == L'\0' ||
+			     (dn_wc[1] == L'.' && dn_wc[2] == L'\0'))))
+		    continue;
+
+		  /* If a dot must be explicity matched, check to see if
+		     they do. */
+		  if (noglob_dot_filenames && dn_wc[0] == L'.' &&
+		      pat_wc[0] != L'.' &&
+		      (pat_wc[0] != L'\\' || pat_wc[1] != L'.'))
+		    continue;
+		}
+	    }
+	  else
+#endif
+	    {
+	      /* If a leading dot need not be explicitly matched, and the
+		 pattern doesn't start with a `.', don't match `.' or `..' */
+	      if (noglob_dot_filenames == 0 && pat[0] != '.' &&
+		    (pat[0] != '\\' || pat[1] != '.') &&
+		    (dp->d_name[0] == '.' &&
+		    (dp->d_name[1] == '\0' ||
+			 (dp->d_name[1] == '.' && dp->d_name[2] == '\0'))))
+		continue;
+
+	      /* If a dot must be explicity matched, check to see if they do. */
+	      if (noglob_dot_filenames && dp->d_name[0] == '.' &&
+		 pat[0] != '.' && (pat[0] != '\\' || pat[1] != '.'))
+		continue;
+	    }
 
 	  if (fnmatch (pat, dp->d_name, flags) != FNM_NOMATCH)
 	    {
@@ -447,7 +564,7 @@
   name_vector[count] = NULL;
   return (name_vector);
 }
-
+
 /* Return a new array which is the concatenation of each string in ARRAY
    to DIR.  This function expects you to pass in an allocated ARRAY, and
    it takes care of free()ing that array.  Thus, you might think of this
@@ -495,7 +612,7 @@
 
   return (result);
 }
-
+
 /* Do globbing on PATHNAME.  Return an array of pathnames that match,
    marking the end of the array with a null-pointer as an element.
    If no pathnames match, then the array is empty (first element is null).
@@ -667,7 +784,7 @@
 #endif /* SHELL */
   return (NULL);
 }
-
+
 #if defined (TEST)
 
 main (argc, argv)
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/lib/glob/glob_loop.c bash-2.05/lib/glob/glob_loop.c
--- bash-2.05.orig/lib/glob/glob_loop.c	Thu Jan  1 09:00:00 1970
+++ bash-2.05/lib/glob/glob_loop.c	Wed Apr 18 16:23:12 2001
@@ -0,0 +1,48 @@
+static int INTERNAL_GLOB_PATTERN_P (CHAR *pattern);
+
+/* Return nonzero if PATTERN has any special globbing chars in it.  */
+int
+INTERNAL_GLOB_PATTERN_P (pattern)
+     CHAR *pattern;
+{
+  CHAR *p;
+  CHAR c;
+  int bopen;
+
+  p = pattern;
+  bopen = 0;
+
+  while ((c = *p++) != L('\0'))
+    switch (c)
+      {
+      case L('?'):
+      case L('*'):
+	return 1;
+
+      case L('['):      /* Only accept an open brace if there is a close */
+	bopen++;        /* brace to match it.  Bracket expressions must be */
+	continue;       /* complete, according to Posix.2 */
+      case L(']'):
+	if (bopen)
+	  return 1;
+	continue;
+
+      case L('+'):         /* extended matching operators */
+      case L('@'):
+      case L('!'):
+	if (*p == L('('))  /*) */
+	  return 1;
+	continue;
+
+      case L('\\'):
+	if (*p++ == L('\0'))
+	  return 0;
+      }
+
+  return 0;
+}
+
+#undef INTERNAL_GLOB_PATTERN_P
+#undef L
+#undef INT
+#undef CHAR
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/lib/glob/xmbsrtowcs.c bash-2.05/lib/glob/xmbsrtowcs.c
--- bash-2.05.orig/lib/glob/xmbsrtowcs.c	Thu Jan  1 09:00:00 1970
+++ bash-2.05/lib/glob/xmbsrtowcs.c	Wed Apr 18 16:23:12 2001
@@ -0,0 +1,99 @@
+#include <config.h>
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+/* <wchar.h>, <wctype.h> and <stdlib.h> are included in "xmbsrtowcs.h".
+   If <wchar.h>, <wctype.h>, mbsrtowcs(), exist, HANDLE_MULTIBYTE
+   is defined as 1. */
+#include "xmbsrtowcs.h" 
+
+#if HANDLE_MULTIBYTE
+/* On some locales (ex. ja_JP.sjis), mbsrtowc doesn't convert 0x5c to U<0x5c>.
+   So, this function is made for converting 0x5c to U<0x5c>. */
+
+static mbstate_t local_state;
+static int local_state_use = 0;
+
+size_t
+xmbsrtowcs (dest, src, len, pstate)
+    wchar_t *dest;
+    const char **src;
+    size_t len;
+    mbstate_t *pstate;
+{
+  mbstate_t *ps;
+  size_t mblength, wclength, n;
+
+  ps = pstate;
+  if (pstate == NULL)
+    {
+      if (!local_state_use)
+	{
+	  memset (&local_state, '\0', sizeof(mbstate_t));
+	  local_state_use = 1;
+	}
+      ps = &local_state;
+    }
+
+  n = strlen(*src) + 1;
+
+  if (dest == NULL)
+    {
+      wchar_t *wsbuf;
+      char *mbsbuf;
+      mbstate_t psbuf;
+
+      wsbuf = (wchar_t *) alloca ((n + 1) * sizeof(wchar_t));
+      mbsbuf = (char *) alloca (n + 1);
+      memcpy(mbsbuf, *src, n + 1);
+      psbuf = *ps;
+
+      wclength = mbsrtowcs (wsbuf, (const char **)&mbsbuf, n, &psbuf);
+
+      return wclength;
+    }
+      
+  for(wclength = 0; wclength < len; wclength++, dest++)
+    {
+      if(mbsinit(ps))
+	{
+	  if (**src == '\0')
+	    {
+	      *dest = L'\0';
+	      *src = NULL;
+	      return (wclength);
+	    }
+	  else if (**src == '\\')
+	    {
+	      *dest = L'\\';
+	      mblength = 1;
+	    }
+	  else
+	    mblength = mbrtowc(dest, *src, n, ps);
+	}
+      else
+	mblength = mbrtowc(dest, *src, n, ps);
+
+      /* Cannot convert multibyte character to wide character. */
+      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+	return (size_t)-1;
+
+      *src += mblength;
+      n -= mblength;
+
+      /* The multibyte string  has  been  completely  converted,
+	 including  the terminating '\0'. */
+      if (*dest == L'\0')
+	{
+	  *src = NULL;
+	  break;
+	}
+    }
+
+    return (wclength);
+}
+#endif
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/lib/glob/xmbsrtowcs.h bash-2.05/lib/glob/xmbsrtowcs.h
--- bash-2.05.orig/lib/glob/xmbsrtowcs.h	Thu Jan  1 09:00:00 1970
+++ bash-2.05/lib/glob/xmbsrtowcs.h	Wed Apr 18 16:23:12 2001
@@ -0,0 +1,29 @@
+#ifndef _XMBSRTOWCS_H
+# define _XMBSRTOWCS_H 1
+
+# include "stdc.h"
+
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbsinit(ps) 1
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+# define mbsrtowcs(dest, src, len, ps) (mbsrtowcs) (dest, src, len, 0)
+#endif
+
+# if HANDLE_MULTIBYTE
+/* On some locales, the non-first byte of some multibyte character are as
+   same number as some ascii character. So legacy strchr() may be returns
+   wrong value . */
+extern size_t xmbsrtowcs __P((wchar_t *dest, const char **src,
+			      size_t len, mbstate_t *pstate));
+# endif /* HANDLE_MULTIBYTE */
+#endif /* _XMBSRTOWCS_H */
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/make_cmd.c bash-2.05/make_cmd.c
--- bash-2.05.orig/make_cmd.c	Thu Feb 15 06:54:04 2001
+++ bash-2.05/make_cmd.c	Wed Apr 18 16:23:12 2001
@@ -47,6 +47,70 @@
 #include "jobs.h"
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrlen(s, n, ps) (mbrlen) (s, n, 0)
+#endif
+
+#if defined STDC_HEADERS
+# include <stdlib.h>
+#endif
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+/* Declare mbstate_t state, and creat in initial state. */
+#if HANDLE_MULTIBYTE
+# define DECLARE_STATE                                                  \
+  mbstate_t state;                                                      \
+  memset (&state, '\0', sizeof(mbstate_t))
+#else
+# define DECLARE_STATE
+#endif
+
+/* Skip one character, that character is unibyte or multibyte. */
+#if HANDLE_MULTIBYTE
+# define SKIP_ONE_CHARACTER(_string, _i)                                \
+   do                                                                   \
+    {                                                                   \
+      if(MB_CUR_MAX > 1)                                                \
+	{                                                               \
+	  mbstate_t state_bak;                                          \
+	  size_t mblength;                                              \
+									\
+	  state_bak = state;                                            \
+	  mblength = mbrlen(_string + _i, strlen(_string + _i), &state);  \
+									\
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)         \
+	    {                                                           \
+	      state = state_bak;                                        \
+	      _i++;                                                     \
+	    }                                                           \
+	  else                                                          \
+	      _i += mblength;                                           \
+	}                                                               \
+      else                                                              \
+	_i++;                                                           \
+    } while(0)
+#else
+# define SKIP_ONE_CHARACTER(_string, _i) _i++
+#endif
+
 extern int line_number, current_command_line_count;
 extern int disallow_filename_globbing;
 extern int last_command_exit_value;
@@ -76,22 +140,29 @@
      WORD_DESC *w;
      char *string;
 {
-  register char *s;
+  int i;
+
+  DECLARE_STATE;
 
-  for (s = string; *s; s++)
-    switch (*s)
-      {
-	case '$':
-	  w->flags |= W_HASDOLLAR;
-	  break;
-	case '\\':
-	  break;	/* continue the loop */
-	case '\'':
-	case '`':
-	case '"':
-	  w->flags |= W_QUOTED;
-	  break;
-      }
+  i = 0;
+  while(string[i])
+    {
+      switch (string[i])
+	{
+	  case '$':
+	    w->flags |= W_HASDOLLAR;
+	    break;
+	  case '\\':
+	    break;	/* continue the loop */
+	  case '\'':
+	  case '`':
+	  case '"':
+	    w->flags |= W_QUOTED;
+	    break;
+	}
+
+      SKIP_ONE_CHARACTER(string, i);
+    }
   return (w);
 }
 
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/parse.y bash-2.05/parse.y
--- bash-2.05.orig/parse.y	Wed Mar 28 00:06:12 2001
+++ bash-2.05/parse.y	Wed Apr 18 16:23:12 2001
@@ -47,6 +47,35 @@
 #include "builtins/common.h"
 #include "builtins/builtext.h"
 
+/* Get MB_LEN_MAX.  */
+#if HAVE_LIMITS_H
+# include <limits.h>
+#endif
+
+/* MB_LEN_MAX is incorrectly defined to be 1 in at least one GCC
+   installation; work around this configuration error.  */
+#if MB_LEN_MAX < 16
+# define MB_LEN_MAX 16
+#endif
+
+#if defined STDC_HEADERS
+# include <stdlib.h>
+#endif
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
+/* For platform which support the ISO C amendement 1 functionality we
+   support user defined character classes.  */
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined (HAVE_MBSTATE_T) && defined (HAVE_MBRLEN)
+#  define HANDLE_MULTIBYTE      1
+# endif
+#endif
+
 #if defined (READLINE)
 #  include "bashline.h"
 #  include <readline/readline.h>
@@ -130,6 +159,10 @@
 char *history_delimiting_chars ();
 #endif
 
+#ifdef HANDLE_MULTIBYTE
+static void analyze_shell_input_line();
+#endif
+
 extern int yyerror ();
 
 /* Default prompt strings */
@@ -1344,6 +1377,9 @@
   shell_input_line_index = 0;
   shell_input_line_terminator = '\0';
   parser_state &= ~PST_ALEXPNEXT;
+#ifdef HANDLE_MULTIBYTE
+  analyze_shell_input_line();
+#endif
 }
 
 /*
@@ -1377,6 +1413,9 @@
 #endif
 
   free ((char *)t);
+#ifdef HANDLE_MULTIBYTE
+  analyze_shell_input_line();
+#endif
 }
 
 static void
@@ -1569,6 +1608,70 @@
 
 #define pop_delimiter(ds)	ds.delimiter_depth--
 
+#ifdef HANDLE_MULTIBYTE
+#define last_shell_getc_is_singlebyte ((shell_input_line_index > 1)? \
+                shell_input_line_property[shell_input_line_index - 1] : 1)
+#else
+#define last_shell_getc_is_singlebyte (1)
+#endif
+
+#ifdef HANDLE_MULTIBYTE
+static char *shell_input_line_property = NULL;
+static void
+analyze_shell_input_line()
+{
+  int i, previ, len;
+  mbstate_t mbs, prevs;
+
+  if (shell_input_line == NULL)
+    return;
+  len = strlen(shell_input_line);
+  if (shell_input_line_property != NULL)
+    free(shell_input_line_property);
+  shell_input_line_property = (char*) xmalloc(len + 1);
+
+  memset(&prevs, 0, sizeof(mbstate_t));
+  for (i = previ = 0 ; i < len ; i++)
+    {
+      size_t mbclen;
+      mbs = prevs;
+
+      if (shell_input_line[i] == EOF)
+        {
+          int j;
+          for (j = i ; j < len ; j++)
+            shell_input_line_property[j] = 1;
+          break;
+        }
+
+      mbclen = mbrlen(shell_input_line + previ, i - previ + 1, &mbs);
+      if (mbclen == (size_t) -1 || mbclen == 1)
+        {
+          /* singlebyte character.  */
+          mbclen = 1;
+          previ = i + 1;
+        }
+      else if (mbclen == (size_t) -2)
+        {
+          /* a part of a multibyte character.  */
+          mbclen = 0;
+        }
+      else if (mbclen > 1)
+        {
+          /* the end of a multibyte character.  */
+          mbclen = 0;
+          previ = i + 1;
+          prevs = mbs;
+        }
+      else
+        {
+          /* Can't reach.  */
+        }
+      shell_input_line_property[i] = mbclen;
+    }
+}
+#endif
+
 /* Return the next shell input character.  This always reads characters
    from shell_input_line; when that line is exhausted, it is time to
    read the next line.  This is called by read_token when the shell is
@@ -1678,6 +1781,9 @@
 
       shell_input_line_index = 0;
       shell_input_line_len = i;		/* == strlen (shell_input_line) */
+#ifdef HANDLE_MULTIBYTE
+      analyze_shell_input_line();
+#endif
 
 #if defined (HISTORY)
       if (remember_on_history && shell_input_line && shell_input_line[0])
@@ -1709,6 +1815,9 @@
 	      /* We have to force the xrealloc below because we don't know
 		 the true allocated size of shell_input_line anymore. */
 	      shell_input_line_size = shell_input_line_len;
+#ifdef HANDLE_MULTIBYTE
+	      analyze_shell_input_line();
+#endif
 	    }
 	}
       /* Try to do something intelligent with blank lines encountered while
@@ -1760,6 +1869,9 @@
 
 	  shell_input_line[shell_input_line_len] = '\n';
 	  shell_input_line[shell_input_line_len + 1] = '\0';
+#ifdef HANDLE_MULTIBYTE
+	  analyze_shell_input_line();
+#endif
 	}
     }
 
@@ -1769,7 +1881,8 @@
     shell_input_line_index++;
 
   if (c == '\\' && remove_quoted_newline &&
-      shell_input_line[shell_input_line_index] == '\n')
+      shell_input_line[shell_input_line_index] == '\n'
+      && last_shell_getc_is_singlebyte)
     {
 	prompt_again ();
 	line_number++;
@@ -2250,7 +2363,8 @@
       return (yacc_EOF);
     }
 
-  if (character == '#' && (!interactive || interactive_comments))
+  if (character == '#' && (!interactive || interactive_comments)
+      && last_shell_getc_is_singlebyte)
     {
       /* A comment.  Discard until EOL or EOF, and then return a newline. */
       discard_until ('\n');
@@ -2273,7 +2387,8 @@
     }
 
   /* Shell meta-characters. */
-  if (shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
+  if (shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0)
+      && last_shell_getc_is_singlebyte)
     {
 #if defined (ALIAS)
       /* Turn off alias tokenization iff this character sequence would
@@ -2376,15 +2491,20 @@
 #endif
 	    }
 	}
-      else if (character == '<' && peek_char == '&')
+      else if (character == '<' && peek_char == '&'
+	       && last_shell_getc_is_singlebyte)
 	return (LESS_AND);
-      else if (character == '>' && peek_char == '&')
+      else if (character == '>' && peek_char == '&'
+	       && last_shell_getc_is_singlebyte)
 	return (GREATER_AND);
-      else if (character == '<' && peek_char == '>')
+      else if (character == '<' && peek_char == '>'
+	       && last_shell_getc_is_singlebyte)
 	return (LESS_GREATER);
-      else if (character == '>' && peek_char == '|')
+      else if (character == '>' && peek_char == '|'
+	       && last_shell_getc_is_singlebyte)
 	return (GREATER_BAR);
-      else if (peek_char == '>' && character == '&')
+      else if (peek_char == '>' && character == '&'
+	       && last_shell_getc_is_singlebyte)
 	return (AND_GREATER);
 
       shell_ungetc (peek_char);
@@ -2392,7 +2512,8 @@
       /* If we look like we are reading the start of a function
 	 definition, then let the reader know about it so that
 	 we will do the right thing with `{'. */
-      if (character == ')' && last_read_token == '(' && token_before_that == WORD)
+      if (character == ')' && last_read_token == '(' && token_before_that == WORD
+	  && last_shell_getc_is_singlebyte)
 	{
 	  parser_state |= PST_ALLOWOPNBRC;
 #if defined (ALIAS)
@@ -2404,26 +2525,31 @@
       /* case pattern lists may be preceded by an optional left paren.  If
 	 we're not trying to parse a case pattern list, the left paren
 	 indicates a subshell. */
-      if (character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
+      if (character == '(' && (parser_state & PST_CASEPAT) == 0 /* ) */
+	  && last_shell_getc_is_singlebyte)
 	parser_state |= PST_SUBSHELL;
       /*(*/
-      else if ((parser_state & PST_CASEPAT) && character == ')')
+      else if ((parser_state & PST_CASEPAT) && character == ')'
+	       && last_shell_getc_is_singlebyte)
 	parser_state &= ~PST_CASEPAT;
       /*(*/
-      else if ((parser_state & PST_SUBSHELL) && character == ')')
+      else if ((parser_state & PST_SUBSHELL) && character == ')'
+	       && last_shell_getc_is_singlebyte)
 	parser_state &= ~PST_SUBSHELL;
 
 #if defined (PROCESS_SUBSTITUTION)
       /* Check for the constructs which introduce process substitution.
 	 Shells running in `posix mode' don't do process substitution. */
       if (posixly_correct ||
-	  ((character != '>' && character != '<') || peek_char != '('))
+	  (((character != '>' && character != '<') || peek_char != '(')
+	   && last_shell_getc_is_singlebyte))
 #endif /* PROCESS_SUBSTITUTION */
 	return (character);
     }
 
   /* Hack <&- (close stdin) case. */
-  if (character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
+  if (character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND)
+      && last_shell_getc_is_singlebyte)
     return (character);
 
   /* Okay, if we got this far, we have to read a word.  Read one,
@@ -2489,26 +2615,30 @@
 	    }
 
 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
-	  if (ch == CTLESC || ch == CTLNUL)
+	  if ((ch == CTLESC || ch == CTLNUL) && last_shell_getc_is_singlebyte)
 	    ret[retind++] = CTLESC;
 	  ret[retind++] = ch;
 	  continue;
 	}
-      else if (ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+      else if ((ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+	       && last_shell_getc_is_singlebyte)
 	{
 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
 	  ret[retind++] = CTLESC;
 	  ret[retind++] = ch;
 	  continue;
 	}
-      else if (ch == close)		/* ending delimiter */
+      else if (ch == close		/* ending delimiter */
+	       && last_shell_getc_is_singlebyte)
 	count--;
 #if 1
       /* handle nested ${...} specially. */
-      else if (open != close && was_dollar && open == '{' && ch == open) /* } */
+      else if (open != close && was_dollar && open == '{' && ch == open /* } */
+	       && last_shell_getc_is_singlebyte)
 	count++;
 #endif
-      else if (((flags & P_FIRSTCLOSE) == 0) && ch == open)		/* nested begin */
+      else if (((flags & P_FIRSTCLOSE) == 0) && ch == open		/* nested begin */
+	       && last_shell_getc_is_singlebyte)
 	count++;
 
       /* Add this character. */
@@ -2517,21 +2647,21 @@
 
       if (open == '\'')			/* '' inside grouping construct */
 	{
-	  if ((flags & P_ALLOWESC) && ch == '\\')
+	  if ((flags & P_ALLOWESC) && ch == '\\' && last_shell_getc_is_singlebyte)
 	    pass_next_character++;
 	  continue;
 	}
 
-      if (ch == '\\')			/* backslashes */
+      if (ch == '\\' && last_shell_getc_is_singlebyte)			/* backslashes */
 	pass_next_character++;
-
       if (open != close)		/* a grouping construct */
 	{
-	  if (shellquote (ch))
+	  if (shellquote (ch) && last_shell_getc_is_singlebyte)
 	    {
 	      /* '', ``, or "" inside $(...) or other grouping construct. */
 	      push_delimiter (dstack, ch);
-	      if (was_dollar && ch == '\'')	/* $'...' inside group */
+	      if (was_dollar && ch == '\''	/* $'...' inside group */
+		  && last_shell_getc_is_singlebyte)
 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC);
 	      else
 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, 0);
@@ -2541,7 +2671,7 @@
 		  free (ret);
 		  return &matched_pair_error;
 		}
-	      if (was_dollar && ch == '\'')
+	      if (was_dollar && ch == '\'' && last_shell_getc_is_singlebyte)
 		{
 		  /* Translate $'...' here. */
 		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
@@ -2551,7 +2681,7 @@
 		  nestlen = strlen (nestret);
 		  retind -= 2;		/* back up before the $' */
 		}
-	      else if (was_dollar && ch == '"')
+	      else if (was_dollar && ch == '"' && last_shell_getc_is_singlebyte)
 		{
 		  /* Locale expand $"..." here. */
 		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
@@ -2577,7 +2707,7 @@
       /* Parse an old-style command substitution within double quotes as a
 	 single word. */
       /* XXX - sh and ksh93 don't do this - XXX */
-      else if (open == '"' && ch == '`')
+      else if (open == '"' && ch == '`' && last_shell_getc_is_singlebyte)
 	{
 	  nestret = parse_matched_pair (0, '`', '`', &nestlen, 0);
 	  if (nestret == &matched_pair_error)
@@ -2593,7 +2723,8 @@
 	    }
 	  FREE (nestret);
 	}
-      else if (was_dollar && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
+      else if (was_dollar && (ch == '(' || ch == '{' || ch == '[')	/* ) } ] */
+	       && last_shell_getc_is_singlebyte)
 	/* check for $(), $[], or ${} inside quoted string. */
 	{
 	  if (open == ch)	/* undo previous increment */
@@ -2617,7 +2748,7 @@
 	    }
 	  FREE (nestret);
 	}
-      was_dollar = (ch == '$');
+      was_dollar = (ch == '$' && last_shell_getc_is_singlebyte);
     }
 
   ret[retind] = '\0';
@@ -2647,7 +2778,7 @@
     return -1;
   /* Check that the next character is the closing right paren.  If
      not, this is a syntax error. ( */
-  if ((c = shell_getc (0)) != ')')
+  if ((c = shell_getc (0)) != ')' && last_shell_getc_is_singlebyte)
     rval = 0;
 
   token = xmalloc (ttoklen + 4);
@@ -2902,7 +3033,7 @@
 
       /* Handle backslashes.  Quote lots of things when not inside of
 	 double-quotes, quote some things inside of double-quotes. */
-      if (character == '\\')
+      if (character == '\\' && last_shell_getc_is_singlebyte)
 	{
 	  peek_char = shell_getc (0);
 
@@ -2928,7 +3059,7 @@
 	}
 
       /* Parse a matched pair of quote characters. */
-      if (shellquote (character))
+      if (shellquote (character) && last_shell_getc_is_singlebyte)
 	{
 	  push_delimiter (dstack, character);
 	  ttok = parse_matched_pair (character, character, character, &ttoklen, 0);
@@ -2952,7 +3083,7 @@
       if (extended_glob && PATTERN_CHAR (character))
 	{
 	  peek_char = shell_getc (1);
-	  if (peek_char == '(')		/* ) */
+	  if (peek_char == '(' && last_shell_getc_is_singlebyte)	/* ) */
 	    {
 	      push_delimiter (dstack, peek_char);
 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
@@ -2981,8 +3112,9 @@
 	{
 	  peek_char = shell_getc (1);
 	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
-	  if (peek_char == '(' ||
+	  if ((peek_char == '(' ||
 		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
+	      && last_shell_getc_is_singlebyte)
 	    {
 	      if (peek_char == '{')		/* } */
 		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE);
@@ -3014,7 +3146,8 @@
 	      goto next_character;
 	    }
 	  /* This handles $'...' and $"..." new-style quoted strings. */
-	  else if (character == '$' && (peek_char == '\'' || peek_char == '"'))
+	  else if (character == '$' && (peek_char == '\'' || peek_char == '"')
+		   && last_shell_getc_is_singlebyte)
 	    {
 	      int first_line;
 
@@ -3066,7 +3199,8 @@
 	    }
 	  /* This could eventually be extended to recognize all of the
 	     shell's single-character parameter expansions, and set flags.*/
-	  else if (character == '$' && peek_char == '$')
+	  else if (character == '$' && peek_char == '$'
+		   && last_shell_getc_is_singlebyte)
 	    {
 	      ttok = xmalloc (3);
 	      ttok[0] = ttok[1] = '$';
@@ -3087,10 +3221,11 @@
 
 #if defined (ARRAY_VARS)
       /* Identify possible compound array variable assignment. */
-      else if (character == '=' && token_index > 0)
+      else if (character == '=' && token_index > 0
+	       && last_shell_getc_is_singlebyte)
 	{
 	  peek_char = shell_getc (1);
-	  if (peek_char == '(')		/* ) */
+	  if (peek_char == '(' && last_shell_getc_is_singlebyte)	/* ) */
 	    {
 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
 	      if (ttok == &matched_pair_error)
@@ -3118,7 +3253,7 @@
 
       /* When not parsing a multi-character word construct, shell meta-
 	 characters break words. */
-      if (shellbreak (character))
+      if (shellbreak (character) && last_shell_getc_is_singlebyte)
 	{
 	  shell_ungetc (character);
 	  goto got_token;
@@ -3159,14 +3294,15 @@
      Otherwise, it is just a word, and should be returned as such. */
   if (all_digits && (character == '<' || character == '>' ||
 		    last_read_token == LESS_AND ||
-		    last_read_token == GREATER_AND))
+		    last_read_token == GREATER_AND)
+      && last_shell_getc_is_singlebyte)
       {
 	yylval.number = atoi (token);
 	return (NUMBER);
       }
 
   /* Check for special case tokens. */
-  result = special_case_tokens (token);
+  result = (last_shell_getc_is_singlebyte)? special_case_tokens (token) : -1;
   if (result >= 0)
     return result;
 
@@ -3174,7 +3310,7 @@
   /* Posix.2 does not allow reserved words to be aliased, so check for all
      of them, including special cases, before expanding the current token
      as an alias. */
-  if (posixly_correct)
+  if (posixly_correct && last_shell_getc_is_singlebyte)
     CHECK_FOR_RESERVED_WORD (token);
 
   /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
@@ -3190,7 +3326,7 @@
 
   /* If not in Posix.2 mode, check for reserved words after alias
      expansion. */
-  if (posixly_correct == 0)
+  if (posixly_correct == 0 && last_shell_getc_is_singlebyte)
 #endif
     CHECK_FOR_RESERVED_WORD (token);
 
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/parser-built bash-2.05/parser-built
--- bash-2.05.orig/parser-built	Wed Oct 11 02:27:09 2000
+++ bash-2.05/parser-built	Wed Apr 18 16:23:23 2001
@@ -1,46 +1,3 @@
-#ifndef YYERRCODE
-#define YYERRCODE 256
-#endif
-
-#define IF 257
-#define THEN 258
-#define ELSE 259
-#define ELIF 260
-#define FI 261
-#define CASE 262
-#define ESAC 263
-#define FOR 264
-#define SELECT 265
-#define WHILE 266
-#define UNTIL 267
-#define DO 268
-#define DONE 269
-#define FUNCTION 270
-#define COND_START 271
-#define COND_END 272
-#define COND_ERROR 273
-#define IN 274
-#define BANG 275
-#define TIME 276
-#define TIMEOPT 277
-#define WORD 278
-#define ASSIGNMENT_WORD 279
-#define NUMBER 280
-#define ARITH_CMD 281
-#define ARITH_FOR_EXPRS 282
-#define COND_CMD 283
-#define AND_AND 284
-#define OR_OR 285
-#define GREATER_GREATER 286
-#define LESS_LESS 287
-#define LESS_AND 288
-#define GREATER_AND 289
-#define SEMI_SEMI 290
-#define LESS_LESS_MINUS 291
-#define AND_GREATER 292
-#define LESS_GREATER 293
-#define GREATER_BAR 294
-#define yacc_EOF 295
 typedef union {
   WORD_DESC *word;		/* the word that we read. */
   int number;			/* the number that we read. */
@@ -50,4 +7,45 @@
   ELEMENT element;
   PATTERN_LIST *pattern;
 } YYSTYPE;
+#define	IF	257
+#define	THEN	258
+#define	ELSE	259
+#define	ELIF	260
+#define	FI	261
+#define	CASE	262
+#define	ESAC	263
+#define	FOR	264
+#define	SELECT	265
+#define	WHILE	266
+#define	UNTIL	267
+#define	DO	268
+#define	DONE	269
+#define	FUNCTION	270
+#define	COND_START	271
+#define	COND_END	272
+#define	COND_ERROR	273
+#define	IN	274
+#define	BANG	275
+#define	TIME	276
+#define	TIMEOPT	277
+#define	WORD	278
+#define	ASSIGNMENT_WORD	279
+#define	NUMBER	280
+#define	ARITH_CMD	281
+#define	ARITH_FOR_EXPRS	282
+#define	COND_CMD	283
+#define	AND_AND	284
+#define	OR_OR	285
+#define	GREATER_GREATER	286
+#define	LESS_LESS	287
+#define	LESS_AND	288
+#define	GREATER_AND	289
+#define	SEMI_SEMI	290
+#define	LESS_LESS_MINUS	291
+#define	AND_GREATER	292
+#define	LESS_GREATER	293
+#define	GREATER_BAR	294
+#define	yacc_EOF	295
+
+
 extern YYSTYPE yylval;
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/pathexp.c bash-2.05/pathexp.c
--- bash-2.05.orig/pathexp.c	Thu Feb 15 06:54:26 2001
+++ bash-2.05/pathexp.c	Wed Apr 18 16:23:12 2001
@@ -41,6 +41,33 @@
 #  include <glob/glob.h>
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrlen(s, n, ps) (mbrlen) (s, n, 0)
+#endif
+
+#if defined STDC_HEADERS
+# include <stdlib.h>
+#endif
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
 /* Control whether * matches .files in globbing. */
 int glob_dot_filenames;
 
@@ -55,6 +82,12 @@
   register int c;
   int open;
 
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
+
   open = 0;
   while (c = *string++)
     {
@@ -85,6 +118,24 @@
 	  if (*string++ == '\0')
 	    return (0);
 	}
+#if HANDLE_MULTIBYTE
+      if (MB_CUR_MAX > 1)
+	{
+	  mbstate_t state_bak;
+	  size_t mblength;
+
+	  state_bak = state;
+	  mblength = mbrlen (string, strlen(string), &state);
+
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)
+	    {
+	      state = state_bak;
+	      mblength = 1;
+	    }
+	  else
+	    string += (mblength < 1) ? 0 : (mblength - 1);
+	}
+#endif
     }
   return (0);
 }
@@ -136,6 +187,11 @@
      char *string;
 {
   char *temp, *s, *t;
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
 
   temp = xmalloc (strlen (string) * 2 + 1);
   for (t = temp, s = string; *s; )
@@ -156,7 +212,33 @@
 	    *t++ = '\\';
 	  break;
 	}
-      *t++ = *s++;
+
+#if HANDLE_MULTIBYTE
+      if (MB_CUR_MAX > 1)
+	{
+	  mbstate_t state_bak;
+	  size_t mblength;
+	  int i;
+
+	  state_bak = state;
+	  mblength = mbrlen (s, strlen (s), &state);
+
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)
+	    {
+	      state = state_bak;
+	      mblength = 1;
+	    }
+	  else
+	    mblength = (mblength < 1) ? 1 : mblength;
+
+	  for (i = 0; i < mblength; i++)
+	    *t++ = *s++;
+	}
+      else
+#endif
+	{
+	  *t++ = *s++;
+	}
     }
   *t = '\0';
   return temp;
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/shell.c bash-2.05/shell.c
--- bash-2.05.orig/shell.c	Tue Mar 27 23:25:51 2001
+++ bash-2.05/shell.c	Wed Apr 18 16:23:12 2001
@@ -48,6 +48,7 @@
 #include "mailcheck.h"
 #include "builtins.h"
 #include "builtins/common.h"
+#include "xstrchr.h"
 
 #if defined (JOB_CONTROL)
 #include "jobs.h"
@@ -1589,12 +1590,12 @@
       set_opts = savestring (shell_builtins[i].short_doc);
   if (set_opts)
     {
-      s = strchr (set_opts, '[');
+      s = xstrchr ((const char *)set_opts, '[');
       if (s == 0)
 	s = set_opts;
       while (*++s == '-')
 	;
-      t = strchr (s, ']');
+      t = xstrchr ((const char *)s, ']');
       if (t)
 	*t = '\0';
       fprintf (fp, "\t-%s or -o option\n", s);
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/subst.c bash-2.05/subst.c
--- bash-2.05.orig/subst.c	Tue Mar 27 03:06:16 2001
+++ bash-2.05/subst.c	Wed Apr 18 16:23:12 2001
@@ -45,6 +45,7 @@
 #include "trap.h"
 #include "pathexp.h"
 #include "mailcheck.h"
+#include "xstrchr.h"
 
 #if !defined (HAVE_RESTARTABLE_SYSCALLS)	/* for getc_with_restart */
 #include "input.h"
@@ -60,6 +61,33 @@
 extern int errno;
 #endif /* !errno */
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrlen(s, n, ps) (mbrlen) (s, n, 0)
+#endif
+
+# if defined STDC_HEADERS
+#  include <stdlib.h>
+# endif
+# if !defined MB_CUR_MAX
+#  define MB_CUR_MAX 16
+# endif
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
 /* The size that strings change by. */
 #define DEFAULT_INITIAL_ARRAY_SIZE 112
 #define DEFAULT_ARRAY_SIZE 128
@@ -101,6 +129,43 @@
       (name[1] == '\0' && (sh_syntaxtab[*name] & CSPECVAR)) || \
       (wi && name[2] == '\0' && VALID_INDIR_PARAM (name[1])))
 
+/* Declare mbstate_t state, and creat in initial state. */
+#if HANDLE_MULTIBYTE
+# define DECLARE_STATE							\
+  mbstate_t state;							\
+  memset (&state, '\0', sizeof(mbstate_t))
+#else
+# define DECLARE_STATE
+#endif
+   
+/* Skip one character, that character is unibyte or multibyte. */
+#if HANDLE_MULTIBYTE
+# define SKIP_ONE_CHARACTER(_string, _i)				\
+   do									\
+    {									\
+      if(MB_CUR_MAX > 1)						\
+	{								\
+	  mbstate_t state_bak;						\
+	  size_t mblength;						\
+									\
+	  state_bak = state;						\
+	  mblength = mbrlen(_string + _i, strlen(_string + _i), &state);  \
+									\
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)		\
+	    {								\
+	      state = state_bak;					\
+	      _i++;							\
+	    }								\
+	  else								\
+	      _i += mblength;						\
+	}								\
+      else								\
+	_i++;								\
+    } while(0)
+#else
+# define SKIP_ONE_CHARACTER(_string, _i) _i++
+#endif
+
 /* Process ID of the last command executed within command substitution. */
 pid_t last_command_subst_pid = NO_PID;
 pid_t current_command_subst_pid = NO_PID;
@@ -142,7 +207,6 @@
    so the SIGCHLD handler in jobs.c can unwind-protect it when it runs a
    SIGCHLD trap. */
 WORD_LIST *subst_assign_varlist = (WORD_LIST *)NULL;
-
 /* A WORD_LIST of words to be expanded by expand_word_list_internal,
    without any leading variable assignments. */
 static WORD_LIST *garglist = (WORD_LIST *)NULL;
@@ -269,7 +333,10 @@
 {
   int sindex, c;
 
-  for (sindex = 0; c = string[sindex]; )
+  DECLARE_STATE;
+
+  sindex = 0;
+  while (c = string[sindex])
     {
       if (c == character)
 	return (1);
@@ -277,13 +344,13 @@
       switch (c)
 	{
 	default:
-	  sindex++;
+	  SKIP_ONE_CHARACTER(string, sindex);
 	  break;
 
 	case '\\':
 	  sindex++;
 	  if (string[sindex])
-	    sindex++;
+	    SKIP_ONE_CHARACTER(string, sindex);
 	  break;
 
 	case '\'':
@@ -305,6 +372,8 @@
 {
   int sindex, c, sublen;
 
+  DECLARE_STATE;
+
   if (substr == 0 || *substr == '\0')
     return (0);
 
@@ -320,7 +389,7 @@
 	  sindex++;
 
 	  if (string[sindex])
-	    sindex++;
+	    SKIP_ONE_CHARACTER(string, sindex);
 	  break;
 
 	case '\'':
@@ -332,7 +401,7 @@
 	  break;
 
 	default:
-	  sindex++;
+	  SKIP_ONE_CHARACTER(string, sindex);
 	  break;
 	}
     }
@@ -407,7 +476,10 @@
   register int c, i;
   char *temp;
 
-  for (i = *sindex; c = string[i]; i++)
+  DECLARE_STATE;
+
+  i = *sindex;
+  while (c = string[i])
     {
       if (c == '\\')
 	if (string[i + 1])
@@ -426,6 +498,8 @@
 #endif
       else if (MEMBER (c, charlist))
 	  break;
+
+      SKIP_ONE_CHARACTER(string, i);
     }
 
   temp = substring (string, *sindex, i);
@@ -450,10 +524,14 @@
   int pass_next, backquote, si;	/* State variables for the machine. */
   int dquote;
 
+  DECLARE_STATE;
+
   pass_next = backquote = dquote = 0;
   temp = xmalloc (1 + strlen (string) - *sindex);
 
-  for (j = 0, i = *sindex; c = string[i]; i++)
+  j = 0;
+  i = *sindex;
+  while (c = string[i])
     {
       /* Process a character that was quoted by a backslash. */
       if (pass_next)
@@ -462,7 +540,7 @@
 
 	     ``The backslash shall retain its special meaning as an escape
 	     character only when followed by one of the characters:
-	     	$	`	"	\	<newline>''.
+		$	`	"	\	<newline>''.
 
 	     If STRIPDQ is zero, we handle the double quotes here and let
 	     expand_word_internal handle the rest.  If STRIPDQ is non-zero,
@@ -481,10 +559,36 @@
 		The returned string will be run through expansion as if
 		it were double-quoted. */
 	  if ((stripdq == 0 && c != '"') ||
-	      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))
+              (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))
 	    temp[j++] = '\\';
-	  temp[j++] = c;
+
 	  pass_next = 0;
+
+add_one_character:
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      mbstate_t state_bak;
+	      size_t mblength;
+	      int k;
+
+	      state_bak = state;
+	      mblength = mbrlen (string + i, strlen(string + i), &state);
+
+	      if (mblength == (size_t)-2 || mblength == (size_t)-1)
+		{
+		  state = state_bak;
+		  mblength = 1;
+		}
+	      else
+		mblength = (mblength < 1) ? 1 : mblength;
+
+	      for (k = 0; k < mblength; k++)
+		temp[j++] = string[i++];
+	    }
+	  else
+#endif
+	    temp[j++] = string[i++];
 	  continue;
 	}
 
@@ -494,6 +598,7 @@
       if (c == '\\')
 	{
 	  pass_next++;
+	  i++;
 	  continue;
 	}
 
@@ -506,6 +611,7 @@
 	  if (c == '`')
 	    backquote = 0;
 	  temp[j++] = c;
+	  i++;
 	  continue;
 	}
 
@@ -513,6 +619,7 @@
 	{
 	  temp[j++] = c;
 	  backquote++;
+	  i++;
 	  continue;
 	}
 
@@ -535,21 +642,20 @@
 
 	  i = si;
 	  free (ret);
+	  i++;
 	  continue;
 	}
 
       /* Add any character but a double quote to the quoted string we're
 	 accumulating. */
       if (c != '"')
-	{
-	  temp[j++] = c;
-	  continue;
-	}
+	goto add_one_character;
 
       /* c == '"' */
       if (stripdq)
 	{
 	  dquote ^= 1;
+	  i++;
 	  continue;
 	}
 
@@ -566,6 +672,7 @@
 }
 
 /* This should really be another option to string_extract_double_quoted. */
+
 static inline int
 skip_double_quoted (string, sind)
      char *string;
@@ -575,29 +682,37 @@
   char *ret;
   int pass_next, backquote, si;
 
+  DECLARE_STATE;
+
   pass_next = backquote = 0;
 
-  for (j = 0, i = sind; c = string[i]; i++)
+  i = sind;
+  j = 0;
+  while (c = string[i])
     {
       if (pass_next)
 	{
 	  pass_next = 0;
+	  SKIP_ONE_CHARACTER(string, i);
 	  continue;
 	}
       else if (c == '\\')
 	{
 	  pass_next++;
+	  i++;
 	  continue;
 	}
       else if (backquote)
 	{
 	  if (c == '`')
 	    backquote = 0;
+	  SKIP_ONE_CHARACTER(string, i);
 	  continue;
 	}
       else if (c == '`')
 	{
 	  backquote++;
+	  i++;
 	  continue;
 	}
       else if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
@@ -610,10 +725,14 @@
 
 	  i = si;
 	  free (ret);
+	  i++;
 	  continue;
 	}
       else if (c != '"')
-	continue;
+	{
+	  SKIP_ONE_CHARACTER(string, i);
+	  continue;
+	}
       else
 	break;
     }
@@ -636,8 +755,11 @@
   register int i, j;
   char *t;
 
-  for (i = *sindex; string[i] && string[i] != '\''; i++)
-    ;
+  DECLARE_STATE;
+
+  i = *sindex;
+  while (string[i] && string[i] != '\'')
+    SKIP_ONE_CHARACTER(string, i);
 
   t = substring (string, *sindex, i);
 
@@ -655,8 +777,12 @@
 {
   register int c;
 
-  for (c = sind; string[c] && string[c] != '\''; c++)
-    ;
+  DECLARE_STATE;
+  
+  c = sind;
+  while (string[c] && string[c] != '\'')
+    SKIP_ONE_CHARACTER(string, c);
+
   if (string[c])
     c++;
   return c;
@@ -763,6 +889,8 @@
   int pass_character, nesting_level;
   int len_closer, len_opener, len_alt_opener;
 
+  DECLARE_STATE;
+
   len_opener = STRLEN (opener);
   len_alt_opener = STRLEN (alt_opener);
   len_closer = STRLEN (closer);
@@ -782,7 +910,7 @@
       if (pass_character)	/* previous char was backslash */
 	{
 	  pass_character = 0;
-	  i++;
+	  SKIP_ONE_CHARACTER(string, i);
 	  continue;
 	}
 
@@ -824,7 +952,7 @@
 	 the nesting level. */
       if (STREQN (string + i, closer, len_closer))
 	{
-	  i += len_closer - 1;	/* move to last char of the closer */
+	  i += len_closer - 1;	/* move to last byte of the closer */
 	  nesting_level--;
 	  if (nesting_level == 0)
 	    break;
@@ -856,7 +984,8 @@
 	  continue;
 	}
 
-      i++;	/* move past this character, which was not special. */
+      /* move past this character, which was not special. */
+      SKIP_ONE_CHARACTER(string, i);
     }
 
 #if 0
@@ -896,15 +1025,19 @@
   int pass_character, nesting_level, si;
   char *result, *t;
 
+  DECLARE_STATE;
+
   pass_character = 0;
 
   nesting_level = 1;
 
-  for (i = *sindex; (c = string[i]); i++)
+  i = *sindex;
+  while(c = string[i])
     {
       if (pass_character)
 	{
 	  pass_character = 0;
+	  SKIP_ONE_CHARACTER(string, i);
 	  continue;
 	}
 
@@ -912,13 +1045,14 @@
       if (c == CTLESC || c == '\\')
 	{
 	  pass_character++;
+	  i++;
 	  continue;
 	}
 
       if (string[i] == '$' && string[i+1] == LBRACE)
 	{
 	  nesting_level++;
-	  i++;
+	  i += 2;
 	  continue;
 	}
 
@@ -927,6 +1061,7 @@
 	  nesting_level--;
 	  if (nesting_level == 0)
 	    break;
+	  i++;
 	  continue;
 	}
 
@@ -938,6 +1073,7 @@
 	  t = string_extract (string, &si, "`", 0);
 	  i = si;
 	  free (t);
+	  i++;
 	  continue;
 	}
 
@@ -949,6 +1085,7 @@
 	  t = extract_delimited_string (string, &si, "$(", "(", ")"); /*)*/
 	  i = si;
 	  free (t);
+	  i++;
 	  continue;
 	}
 
@@ -960,9 +1097,9 @@
 	  i = (c == '\'') ? skip_single_quoted (string, si)
 			  : skip_double_quoted (string, si);
 	  /* skip_XXX_quoted leaves index one past close quote */
-	  i--;
 	  continue;
 	}
+      SKIP_ONE_CHARACTER(string, i);
     }
 
   if (c == 0 && nesting_level && no_longjmp_on_fatal_error == 0)
@@ -986,11 +1123,18 @@
 {
   register int i, l;
 
-  for (i = 0, l = strlen (string); i < l; i++)
-    if (string[i] == '\\' && (string[i + 1] == '`' || string[i + 1] == '\\' ||
+  DECLARE_STATE;
+
+  i = 0;
+  l = strlen (string);
+  while (string[i] != '\0')
+    {
+      if (string[i] == '\\' && (string[i + 1] == '`' || string[i + 1] == '\\' ||
 			      string[i + 1] == '$'))
       strcpy (string + i, string + i + 1);	/* XXX - should be memmove */
-  return (string);
+
+      SKIP_ONE_CHARACTER(string, i);
+    }
 }
 
 #if 0
@@ -1228,7 +1372,7 @@
       if (ts == te && d2 && member (string[ts], d2))
 	{
 	  te = ts + 1;
-	  while (member (string[te], d2))
+	  while (member(string[te], d2))
 	    te++;
 	}
 
@@ -1262,7 +1406,7 @@
       if (string[te] == 0)
 	break;
 
-      i = te + member (string[te], d);
+      i = te + member(string[te], d);
       while (member (string[i], d) && whitespace(string[i]))
 	i++;
 
@@ -1485,8 +1629,8 @@
 
   /* OK, now STRING points to a word that does not begin with white space.
      The splitting algorithm is:
-     	extract a word, stopping at a separator
-     	skip sequences of spc, tab, or nl as long as they are separators
+	extract a word, stopping at a separator
+	skip sequences of spc, tab, or nl as long as they are separators
      This obeys the field splitting rules in Posix.2. */
   for (result = (WORD_LIST *)NULL, sindex = 0; string[sindex]; )
     {
@@ -1542,11 +1686,11 @@
 	sindex++;
 
       /* If the first separator was IFS whitespace and the current character is
-	 a non-whitespace IFS character, it should be part of the current field
-	 delimiter, not a separate delimiter that would result in an empty field.
-	 Look at POSIX.2, 3.6.5, (3)(b). */
+         a non-whitespace IFS character, it should be part of the current field
+         delimiter, not a separate delimiter that would result in an empty fiel .
+         Look at POSIX.2, 3.6.5, (3)(b). */
       if (string[sindex] && whitesep && issep (string[sindex]) && !spctabnl (string[sindex]))
-	sindex++;
+        sindex++;
     }
   return (REVERSE_LIST (result, WORD_LIST *));
 }
@@ -1713,7 +1857,7 @@
   int ind, ni;
   SHELL_VAR *entry;
 
-  t = strchr (name, '[');
+  t = xstrchr ((const char *)name, '[');
   if (t == 0)
     return ((SHELL_VAR *)NULL);
   ind = t - name;
@@ -1727,12 +1871,12 @@
   ind = array_expand_index (t, ni - ind);
   if (ind < 0)
     {
-      t[-1] = '[';		/* restore original name ] */
+      t[-1] = '[';              /* restore original name ] */
       report_error ("%s: bad array subscript", name);
       return ((SHELL_VAR *)NULL);
     }
   entry = bind_array_variable (name, ind, value);
-  t[-1] = '[';		/* restore original name ] */
+  t[-1] = '[';          /* restore original name ] */
   return (entry);
 }
 #endif /* ARRAY_VARS */
@@ -1767,7 +1911,7 @@
       temp = name + offset + 1;
 
 #if defined (ARRAY_VARS)
-      if (expand && temp[0] == LPAREN && strchr (temp, RPAREN))
+      if (expand && temp[0] == LPAREN && xstrchr ((const char *)temp, RPAREN))
 	{
 	  assign_list = ni = 1;
 	  value = extract_delimited_string (temp, &ni, "(", (char *)NULL, ")");
@@ -1778,7 +1922,7 @@
       /* Perform tilde expansion. */
       if (expand && temp[0])
 	{
-	  temp = (strchr (temp, '~') && unquoted_member ('~', temp))
+	  temp = (xstrchr ((const char *)temp, '~') && unquoted_member ('~', temp))
 			? bash_tilde_expand (temp)
 			: savestring (temp);
 
@@ -1806,7 +1950,7 @@
 #define ASSIGN_RETURN(r)	do { FREE (value); free (name); return (r); } while (0)
 
 #if defined (ARRAY_VARS)
-  if (t = strchr (name, '['))	/*]*/
+  if (t = xstrchr ((const char *)name, '['))   /*]*/
     {
       if (assign_list)
 	{
@@ -1990,12 +2134,16 @@
   int i, saw_quote;
   char *ret;
 
-  for (i = saw_quote = 0; string[i]; i++)
+  DECLARE_STATE;
+
+  i = saw_quote = 0;
+  while(string[i])
     {
       if (EXP_CHAR (string[i]))
 	break;
       else if (string[i] == '\'' || string[i] == '\\' || string[i] == '"')
 	saw_quote = 1;
+      SKIP_ONE_CHARACTER(string, i);
     }
 
   if (string[i])
@@ -2079,7 +2227,7 @@
   if (w->word == 0 || w->word[0] == '\0')
     return ((char *)NULL);
 
-  if (strchr (w->word, '~') && unquoted_member ('~', w->word))
+  if (xstrchr ((const char *)w->word, '~') && unquoted_member ('~', w->word))
     {
       p = bash_tilde_expand (w->word);
       free (w->word);
@@ -2122,7 +2270,7 @@
   result = expand_word_internal (w, q, i, c, e);
   if (result == &expand_word_error || result == &expand_word_fatal)
     {
-      expand_no_split_dollar_star = 0;	/* XXX */
+      expand_no_split_dollar_star = 0;  /* XXX */
       /* By convention, each time this error is returned, w->word has
 	 already been freed (it sometimes may not be in the fatal case,
 	 but that doesn't result in a memory leak because we're going
@@ -2151,7 +2299,6 @@
 
   td.flags = 0;
   td.word = savestring (string);
-
   tresult = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
 
   FREE (td.word);
@@ -2208,7 +2355,6 @@
   no_longjmp_on_fatal_error = 1;
   value = expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
   no_longjmp_on_fatal_error = 0;
-
   if (value == &expand_word_error || value == &expand_word_fatal)
     {
       value = make_word_list (make_bare_word (string), (WORD_LIST *)NULL);
@@ -2441,6 +2587,11 @@
 {
   register char *t;
   char *result;
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
 
   if (*string == 0)
     {
@@ -2455,7 +2606,32 @@
       for (t = result; *string; )
 	{
 	  *t++ = CTLESC;
-	  *t++ = *string++;
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      mbstate_t state_bak;
+	      size_t mblength;
+	      int i;
+
+	      state_bak = state;
+	      mblength = mbrlen (string, strlen(string), &state);
+
+	      if (mblength == (size_t)-2 || mblength == (size_t)-1)
+		{
+		  state = state_bak;
+		  mblength = 1;
+		}
+	      else
+		mblength = (mblength < 1) ? 1 : mblength;
+
+	      for (i = 0; i < mblength; i++)
+		*t++ = *string++;
+	    }
+	  else
+#endif
+	    {
+	      *t++ = *string++;
+	    }
 	}
       *t = '\0';
     }
@@ -2480,7 +2656,7 @@
 
   /* If no character in the string can be quoted, don't bother examining
      each character.  Just return a copy of the string passed to us. */
-  if (strchr (string, CTLESC) == NULL)		/* XXX */
+  if (xstrchr ((const char *)string, CTLESC) == NULL)		/* XXX */
     {						/* XXX */
       strcpy (result, string);			/* XXX */
       return (result);				/* XXX */
@@ -2535,22 +2711,55 @@
      char *string;
 {
   char *nstr, *s, *p;
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
 
   nstr = savestring (string);
   nstr[0] = '\0';
-  for (p = nstr, s = string; *s; s++)
+
+  p = nstr;
+  s = string;
+  while (*s)
     {
       if (*s == CTLESC)
 	{
 	  *p++ = *s++;	/* CTLESC */
 	  if (*s == 0)
 	    break;
-	  *p++ = *s;	/* quoted char */
+	}
+      else if (*s == CTLNUL)
+	{
+	  s++;
 	  continue;
 	}
-      if (*s == CTLNUL)
-	continue;
-      *p++ = *s;
+
+#if HANDLE_MULTIBYTE
+      if (MB_CUR_MAX > 1)
+	{
+	  mbstate_t state_bak;
+	  size_t mblength;
+	  int i;
+
+	  state_bak = state;
+	  mblength = mbrlen (s, strlen(s), &state);
+
+	  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+	    {
+	      state = state_bak;
+	      mblength = 1;
+	    }
+	  else
+	    mblength = (mblength < 1) ? 1 : mblength;
+
+	  for (i = 0; i< mblength; i++)
+	    *p++ = *s++;
+	}
+      else
+#endif
+	*p++ = *s++;
     }
   *p = '\0';
   strcpy (string, nstr);
@@ -2795,7 +3004,7 @@
   WORD_LIST *l;
   int i;
 
-  tword = strchr (value, '~') ? bash_tilde_expand (value) : savestring (value);
+  tword = xstrchr ((const char *)value, '~') ? bash_tilde_expand (value) : savestring (value);
 
   /* expand_string_internal () leaves WORD quoted and does not perform
      word splitting. */
@@ -2988,7 +3197,7 @@
   expand_no_split_dollar_star = 1;
   result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
   expand_no_split_dollar_star = 0;
-  
+
   return (result ? dequote_list (result) : result);
 }
 
@@ -3348,7 +3557,7 @@
   istring_index = istring_size = bufn = 0;
 
 #ifdef __CYGWIN__
-  setmode (fd, O_TEXT);		/* we don't want CR/LF, we want Unix-style */
+  setmode (fd, O_TEXT);         /* we don't want CR/LF, we want Unix-style */
 #endif
 
   /* Read the output of the command through the pipe. */
@@ -3366,12 +3575,12 @@
       c = *bufp++;
 
       if (c == 0)
-	{
+        {
 #if 0
-	  internal_warning ("read_comsub: ignored null byte in input");
+          internal_warning ("read_comsub: ignored null byte in input");
 #endif
-	  continue;
-	}
+          continue;
+        }
 
       /* Add the character to ISTRING, possibly after resizing it. */
       RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size, DEFAULT_ARRAY_SIZE);
@@ -3384,10 +3593,10 @@
 #if 0
 #if defined (__CYGWIN__)
       if (c == '\n' && istring_index > 1 && istring[istring_index - 2] == '\r')
-	{
-	  istring_index--;
-	  istring[istring_index - 1] = '\n';
-	}
+        {
+          istring_index--;
+          istring[istring_index - 1] = '\n';
+        }
 #endif
 #endif
     }
@@ -3475,7 +3684,7 @@
   old_pipeline_pgrp = pipeline_pgrp;
   /* Don't reset the pipeline pgrp if we're already a subshell in a pipeline. */
   if ((subshell_environment & SUBSHELL_PIPE) == 0)
-    pipeline_pgrp = shell_pgrp;
+  pipeline_pgrp = shell_pgrp;
   cleanup_the_pipeline ();
 #endif
 
@@ -3537,7 +3746,7 @@
       /* When not in POSIX mode, command substitution does not inherit
          the -e flag. */
       if (posixly_correct == 0)
-	exit_immediately_on_error = 0;
+        exit_immediately_on_error = 0;
 
       remove_quoted_escapes (string);
 
@@ -3598,7 +3807,7 @@
 #else
       if (interactive && pipeline_pgrp != (pid_t)0 && (subshell_environment & SUBSHELL_ASYNC) == 0)
 #endif
-	give_terminal_to (pipeline_pgrp, 0);
+        give_terminal_to (pipeline_pgrp, 0);
 #endif /* JOB_CONTROL */
 
       return (istring);
@@ -3621,7 +3830,7 @@
   char *t;
   int r, len;
 
-  t = strchr (name, '[');	/* ] */
+  t = xstrchr ((const char *)name, '[');	 /* ] */
   if (t)
     {
       *t = '\0';
@@ -3678,7 +3887,7 @@
   int ind, ni;
   SHELL_VAR *var;
 
-  t = strchr (s, '[');
+  t = xstrchr ((const char *)s, '[');
   ind = t - s;
   ni = skipsubscript (s, ind);
   if (ni <= ind + 1 || s[ni] != ']')
@@ -3689,7 +3898,7 @@
 
   *t = '\0';
   var = find_variable (s);
-  *t++ = '[';		/* ] */
+  *t++ = '[';           /* ] */
 
   if (subp)
     *subp = t;
@@ -3722,14 +3931,14 @@
 	  return ((char *)NULL);
 	}
       else if (array_p (var) == 0)
-	{
-	  l = (WORD_LIST *)NULL;
-	  l = add_string_to_list (value_cell (var), l);
-	}
+        {
+          l = (WORD_LIST *)NULL;
+          l = add_string_to_list (value_cell (var), l);
+        }
       else
-	{
-	  l = array_to_word_list (array_cell (var));
-	  if (l == (WORD_LIST *)NULL)
+        {
+          l = array_to_word_list (array_cell (var));
+          if (l == (WORD_LIST *)NULL)
 	    return ((char *) NULL);
 	}
 
@@ -3954,7 +4163,7 @@
   char *t, *t1, *temp;
   int hasdol;
 
-  temp = (*value == '~' || (strchr (value, '~') && unquoted_substring ("=~", value)))
+  temp = (*value == '~' || (xstrchr ((const char *)value, '~') && unquoted_substring ("=~", value)))
 	? bash_tilde_expand (value)
 	: savestring (value);
 
@@ -3991,8 +4200,8 @@
     {
       /* The brace expansion occurred between double quotes and there was
 	 a $@ in TEMP.  It does not matter if the $@ is quoted, as long as
- 	 it does not expand to anything.  In this case, we want to return
- 	 a quoted empty string. */
+	 it does not expand to anything.  In this case, we want to return
+	 a quoted empty string. */
       temp = xmalloc (2);
       temp[0] = CTLNUL;
       temp[1] = '\0';
@@ -4025,9 +4234,10 @@
 
   if (value && *value)
     {
-      temp = (*value == '~' || (strchr (value, '~') && unquoted_substring ("=~", value)))
-		? bash_tilde_expand (value)
-		: savestring (value);
+      temp = (*value == '~' || (xstrchr ((const char *)value, '~') &&
+	      unquoted_substring ("=~", value)))
+                ? bash_tilde_expand (value)
+                : savestring (value);
 
       l = expand_string (temp, 0);
       FREE (temp);
@@ -4051,9 +4261,9 @@
 valid_length_expression (name)
      char *name;
 {
-  return (name[1] == '\0' ||					/* ${#} */
-	  ((sh_syntaxtab[name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
-	  (isdigit (name[1]) && all_digits (name + 1)) ||	/* ${#11} */
+  return (name[1] == '\0' ||                                    /* ${#} */
+          ((sh_syntaxtab[name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
+          (isdigit (name[1]) && all_digits (name + 1)) ||       /* ${#11} */
 #if defined (ARRAY_VARS)
 	  valid_array_reference (name + 1) ||			/* ${#a[7]} */
 #endif
@@ -4146,8 +4356,8 @@
 /* Skip characters in SUBSTR until DELIM.  SUBSTR is an arithmetic expression,
    so we do some ad-hoc parsing of an arithmetic expression to find
    the first DELIM, instead of using strchr(3).  Two rules:
-	1.  If the substring contains a `(', read until closing `)'.
-	2.  If the substring contains a `?', read past one `:' for each `?'.
+        1.  If the substring contains a `(', read until closing `)'.
+        2.  If the substring contains a `?', read past one `:' for each `?'.
 */
 
 static char *
@@ -4155,40 +4365,50 @@
      char *substr;
      int delim;
 {
-  int skipcol, pcount;
-  char *t;
+  int skipcol, pcount, i;
+
+  DECLARE_STATE;
 
-  for (skipcol = pcount = 0, t = substr; *t; t++)
+  skipcol = pcount = i = 0;
+  while (substr[i])
     {
       /* Balance parens */
-      if (*t == '(')
-	{
-	  pcount++;
-	  continue;
-	}
-      if (*t == ')' && pcount)
+      if (substr[i] == '(')
+        {
+          pcount++;
+	  i++;
+          continue;
+        }
+      if (substr[i] == ')' && pcount)
+        {
+          pcount--;
+	  i++;
+          continue;
+        }
+      if (pcount)
 	{
-	  pcount--;
-	  continue;
+	  SKIP_ONE_CHARACTER(substr, i);
+          continue;
 	}
-      if (pcount)
-	continue;
 
       /* Skip one `:' for each `?' */
-      if (*t == ':' && skipcol)
-	{
-	  skipcol--;
-	  continue;
-	}
-      if (*t == delim)
-	break;
-      if (*t == '?')
-	{
-	  skipcol++;
-	  continue;
-	}
+      if (substr[i] == ':' && skipcol)
+        {
+          skipcol--;
+	  i++;
+          continue;
+        }
+      if (substr[i] == delim)
+        break;
+      if (substr[i] == '?')
+        {
+          skipcol++;
+	  i++;
+          continue;
+        }
+      SKIP_ONE_CHARACTER(substr, i);
     }
-  return t;
+  return (substr + i);
 }
 
 /* Verify and limit the start and end of the desired substring.  If
@@ -4212,11 +4432,11 @@
   /* duplicate behavior of strchr(3) */
   t = skiparith (substr, ':');
   if (*t && *t == ':')
-    *t = '\0'; 
+    *t = '\0';
   else
     t = (char *)0;
 #else
-  t = strchr (substr, ':');
+  t = xstrchr ((const char *)substr, ':');
   if (t)
     *t = '\0';
 #endif
@@ -4369,7 +4589,7 @@
     case VT_ARRAYMEMBER:
       temp = quoted ? quoted_substring (value, e1, e2) : substring (value, e1, e2);
       if (val && vtype == VT_ARRAYMEMBER)
-	free (val);
+        free (val);
       break;
     case VT_POSPARMS:
       temp = pos_params (varname, e1, e2, quoted);
@@ -4451,7 +4671,7 @@
 	  rptr += replen;
 	}
       if (s == e)
-	e++;		/* avoid infinite recursion on zero-length match */
+        e++;            /* avoid infinite recursion on zero-length match */
       str = e;		/* e == end of match */
       if (((mflags & MATCH_GLOBREP) == 0) || mtype != MATCH_ANY)
 	break;
@@ -4682,7 +4902,7 @@
   /* ${#-} is a valid expansion and means to take the length of $-.
      Similarly for ${#?} and ${##}... */
   if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
-	VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
+        VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
     {
       name = xrealloc (name, 3);
       name[1] = c;
@@ -4703,7 +4923,7 @@
      variable that expands to one of the positional parameters. */
   want_indir = *name == '!' &&
     (legal_variable_starter (name[1]) || isdigit (name[1])
-				      || VALID_INDIR_PARAM (name[1]));
+                                      || VALID_INDIR_PARAM (name[1]));
 
   /* Determine the value of this variable. */
 
@@ -4756,15 +4976,15 @@
       x = all_variables_matching_prefix (temp1);
       xlist = argv_to_word_list (x, 1, 0);
       if (string[sindex - 2] == '*')
-	temp = string_list_dollar_star (xlist);
+        temp = string_list_dollar_star (xlist);
       else
-	{
-	  temp = string_list_dollar_at (xlist, quoted);
-	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
-	    *quoted_dollar_atp = 1;
-	  if (contains_dollar_at)
-	    *contains_dollar_at = 1;
-	}
+        {
+          temp = string_list_dollar_at (xlist, quoted);
+          if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
+            *quoted_dollar_atp = 1;
+          if (contains_dollar_at)
+            *contains_dollar_at = 1;
+        }
       free (x);
       free (xlist);
       free (temp1);
@@ -4788,10 +5008,10 @@
 #if defined (ARRAY_VARS)
   if (valid_array_reference (name))
     {
-      temp1 = strchr (name, '[');
+      temp1 = xstrchr ((const char *)name, '[');
       if (temp1 && temp1[1] == '@' && temp1[2] == ']')
 	{
-  	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
+	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
 	    *quoted_dollar_atp = 1;
 	  if (contains_dollar_at)
 	    *contains_dollar_at = 1;
@@ -4893,18 +5113,18 @@
     case '+':
       if (var_is_set && var_is_null == 0)
 	{
-	  /* If the operator is `+', we don't want the value of the named
-	     variable for anything, just the value of the right hand side. */
+          /* If the operator is `+', we don't want the value of the named
+             variable for anything, just the value of the right hand side. */
 
-	  if (c == '+')
-	    {
-	      /* XXX -- if we're double-quoted and the named variable is "$@",
-			we want to turn off any special handling of "$@" --
-			we're not using it, so whatever is on the rhs applies. */
-	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
-		*quoted_dollar_atp = 0;
-	      if (contains_dollar_at)
-		*contains_dollar_at = 0;
+          if (c == '+')
+            {
+              /* XXX -- if we're double-quoted and the named variable is "$@",
+                        we want to turn off any special handling of "$@" --
+                        we're not using it, so whatever is on the rhs applies. */
+              if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
+                *quoted_dollar_atp = 0;
+              if (contains_dollar_at)
+                *contains_dollar_at = 0;
 
 	      FREE (temp);
 	      if (value)
@@ -4938,24 +5158,24 @@
 	  else if (c == '?')
 	    {
 	      parameter_brace_expand_error (name, value);
-	      return (interactive_shell ? &expand_param_error : &expand_param_fatal);
-	    }
-	  else if (c != '+')
-	    {
-	      /* XXX -- if we're double-quoted and the named variable is "$@",
-			we want to turn off any special handling of "$@" --
-			we're not using it, so whatever is on the rhs applies. */
-	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
-		*quoted_dollar_atp = 0;
-	      if (contains_dollar_at)
-		*contains_dollar_at = 0;
-
-	      temp = parameter_brace_expand_rhs (name, value, c, quoted,
-						 quoted_dollar_atp,
-						 contains_dollar_at);
-	    }
-	  free (value);
-	}
+              return (interactive_shell ? &expand_param_error : &expand_param_fatal);
+            }
+          else if (c != '+')
+            {
+              /* XXX -- if we're double-quoted and the named variable is "$@",
+                        we want to turn off any special handling of "$@" --
+                        we're not using it, so whatever is on the rhs applies. */
+              if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
+                *quoted_dollar_atp = 0;
+              if (contains_dollar_at)
+                *contains_dollar_at = 0;
+
+              temp = parameter_brace_expand_rhs (name, value, c, quoted,
+                                                 quoted_dollar_atp,
+                                                 contains_dollar_at);
+            }
+          free (value);
+        }
 
       break;
     }
@@ -5074,7 +5294,7 @@
 	{
 	  /* If the $* is not quoted it is identical to $@ */
 	  temp = string_list_dollar_at (list, quoted);
-	  if (expand_no_split_dollar_star == 0 && contains_dollar_at)
+          if (expand_no_split_dollar_star == 0 && contains_dollar_at)
 	    *contains_dollar_at = 1;
 	}
 
@@ -5119,21 +5339,21 @@
       /* Quoted nulls should be removed if there is anything else
 	 in the string. */
       /* Note that we saw the quoted null so we can add one back at
-	 the end of this function if there are no other characters
-	 in the string, discard TEMP, and go on.  The exception to
-	 this is when we have "${@}" and $1 is '', since $@ needs
-	 special handling. */
+         the end of this function if there are no other characters
+         in the string, discard TEMP, and go on.  The exception to
+         this is when we have "${@}" and $1 is '', since $@ needs
+         special handling. */
       if (temp && QUOTED_NULL (temp))
-	{
-	  if (had_quoted_null_p)
-	    *had_quoted_null_p = 1;
-	  if (*quoted_dollar_at_p == 0)
-	    {
-	      free (temp);
-	      temp = (char *)NULL;
-	    }
-	    
-	}
+        {
+          if (had_quoted_null_p)
+            *had_quoted_null_p = 1;
+          if (*quoted_dollar_at_p == 0)
+            {
+              free (temp);
+              temp = (char *)NULL;
+            }
+
+        }
 
       goto return0;
 
@@ -5326,6 +5546,9 @@
   /* The text of WORD. */
   register char *string;
 
+  /* The size of STRING. */
+  size_t string_size;
+
   /* The index into STRING. */
   int sindex;
 
@@ -5348,6 +5571,8 @@
   char ifscmap[256];
   char twochars[2];
 
+  DECLARE_STATE;
+
   istring = xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
   istring[istring_index = 0] = '\0';
   quoted_dollar_at = had_quoted_null = has_dollar_at = 0;
@@ -5356,6 +5581,7 @@
   string = word->word;
   if (string == 0)
     goto finished_with_string;
+  string_size = strlen (string);
 
   if (contains_dollar_at)
     *contains_dollar_at = 0;
@@ -5387,10 +5613,39 @@
 	  goto finished_with_string;
 
 	case CTLESC:
-	  temp = xmalloc (3);
-	  temp[0] = CTLESC;
-	  temp[1] = c = string[++sindex];
-	  temp[2] = '\0';
+	      sindex++;
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1 && string[sindex])
+	    {
+	      int i;
+	      mbstate_t state_bak;
+	      size_t mblength;
+
+	      state_bak = state;
+	      mblength = mbrlen (string + sindex, string_size - sindex, &state);
+	      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		{
+		  state = state_bak;
+		  mblength = 1;
+		}
+	      mblength = (mblength < 1) ? 1 : mblength;
+
+	      temp = xmalloc (mblength + 2);
+	      temp[0] = CTLESC;
+	      for (i = 0; i < mblength; i++)
+		temp[i + 1] = string[sindex++];
+	      temp[mblength + 1] = '\0';
+
+	      goto add_string;
+	    }
+	  else
+#endif
+	    {
+	      temp = xmalloc (3);
+	      temp[0] = CTLESC;
+	      temp[1] = c = string[sindex];
+	      temp[2] = '\0';
+	    }
 
 dollar_add_string:
 	  if (string[sindex])
@@ -5479,17 +5734,47 @@
 	  c = string[++sindex];
 
 	  if (quoted & Q_HERE_DOCUMENT)
-	    tflag = CBSHDOC;
-	  else if (quoted & Q_DOUBLE_QUOTES)
-	    tflag = CBSDQUOTE;
-	  else
-	    tflag = 0;
+            tflag = CBSHDOC;
+          else if (quoted & Q_DOUBLE_QUOTES)
+            tflag = CBSDQUOTE;
+          else
+            tflag = 0;
 
 
-	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))
+          if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] 
+& tflag) == 0))
 	    {
-	      twochars[0] = '\\';
-	      twochars[1] = c;
+#if HANDLE_MULTIBYTE
+	      if (MB_CUR_MAX > 1)
+		{
+		  int i;
+		  mbstate_t state_bak;
+		  size_t mblength;
+
+		  state_bak = state;
+		  mblength = mbrlen (string + sindex,
+			 string_size - sindex, &state);
+		  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		    {
+		      state = state_bak;
+		      mblength = 1;
+		    }
+		  mblength = (mblength < 1) ? 1 : mblength;
+
+		  temp = xmalloc (mblength + 2);
+		  temp[0] = '\\';
+		  for (i = 0; i < mblength; i++)
+		    temp[i + 1] = string[sindex++];
+		  temp[mblength + 1] = '\0';
+
+		  goto add_string;
+		}
+	      else
+#endif
+		{
+		  twochars[0] = '\\';
+		  twochars[1] = c;
+		}
 	    }
 	  else if (c == 0)
 	    {
@@ -5499,8 +5784,37 @@
 	    }
 	  else
 	    {
-	      twochars[0] = CTLESC;
-	      twochars[1] = c;
+#if HANDLE_MULTIBYTE
+	      if (MB_CUR_MAX > 1)
+		{
+		  int i;
+		  mbstate_t state_bak;
+		  size_t mblength;
+
+		  state_bak = state;
+		  mblength = mbrlen (string + sindex,
+			 string_size - sindex, &state);
+		  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		    {
+		      state = state_bak;
+		      mblength = 1;
+		    }
+		  mblength = (mblength < 1) ? 1 : mblength;
+
+		  temp = xmalloc (mblength + 2);
+		  temp[0] = CTLESC;
+		  for (i = 0; i < mblength; i++)
+		    temp[i + 1] = string[sindex++];
+		  temp[mblength + 1] = '\0';
+
+		  goto add_string;
+		}
+	      else
+#endif
+		{
+		  twochars[0] = CTLESC;
+		  twochars[1] = c;
+		}
 	    }
 
 	  sindex++;
@@ -5525,7 +5839,7 @@
 	     whole word was quoted. */
 	  quoted_state = (t_index == 1 && string[sindex] == '\0')
 			    ? WHOLLY_QUOTED
-	  		    : PARTIALLY_QUOTED;
+			    : PARTIALLY_QUOTED;
 
 	  if (temp && *temp)
 	    {
@@ -5661,7 +5975,7 @@
 	     then the string is wholly quoted. */
 	  quoted_state = (t_index == 1 && string[sindex] == '\0')
 			    ? WHOLLY_QUOTED
-	  		    : PARTIALLY_QUOTED;
+			    : PARTIALLY_QUOTED;
 
 	  /* If all we had was '', it is a null expansion. */
 	  if (*temp == '\0')
@@ -5691,7 +6005,7 @@
 
 	default:
 	  /* This is the fix for " $@ " */
-	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && ifscmap[c]))
+	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && ifscmap[(unsigned char)c]))
 	    {
 	      if (string[sindex])	/* from old goto dollar_add_string */
 		sindex++;
@@ -5702,11 +6016,66 @@
 		}
 	      else
 		{
-		  twochars[0] = CTLESC;
-		  twochars[1] = c;
-		  goto add_twochars;
+#if HANDLE_MULTIBYTE
+		  if (MB_CUR_MAX > 1)
+		    {
+		      int i;
+		      mbstate_t state_bak;
+		      size_t mblength;
+
+		      sindex--;
+		      state_bak = state;
+		      mblength = mbrlen (string + sindex,
+			     string_size - sindex, &state);
+		      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+			{
+			  state = state_bak;
+			  mblength = 1;
+			}
+		      mblength = (mblength < 1) ? 1 : mblength;
+
+		      temp = xmalloc (mblength + 2);
+		      temp[0] = CTLESC;
+		      for (i = 0; i < mblength; i++)
+			temp[i + 1] = string[sindex++];
+		      temp[mblength + 1] = '\0';
+
+		      goto add_string;
+		    }
+		  else
+#endif
+		    {
+		      twochars[0] = CTLESC;
+		      twochars[1] = c;
+		      goto add_twochars;
+		    }
+		}
+	    }
+
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      int i;
+	      mbstate_t state_bak;
+	      size_t mblength;
+
+	      state_bak = state;
+	      mblength = mbrlen (string + sindex, string_size - sindex, &state);
+	      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		{
+		  state = state_bak;
+		  mblength = 1;
 		}
+	      mblength = (mblength < 1) ? 1 : mblength;
+
+	      temp = xmalloc (mblength + 1);
+	      for (i = 0; i < mblength; i++)
+		temp[i] = string[sindex++];
+	      temp[mblength] = '\0';
+
+	      goto add_string;
 	    }
+#endif
 
 	add_character:
 	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 1, istring_size,
@@ -5830,6 +6199,12 @@
   char *r, *result_string, *temp;
   int sindex, tindex, c, dquote;
 
+#if HANDLE_MULTIBYTE
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+#endif
+
   /* The result can be no longer than the original string. */
   r = result_string = xmalloc (strlen (string) + 1);
 
@@ -5839,13 +6214,39 @@
 	{
 	case '\\':
 	  c = string[++sindex];
-	  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
+          if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
 	    *r++ = '\\';
 	  /* FALLTHROUGH */
 
 	default:
-	  *r++ = c;
-	  sindex++;
+#if HANDLE_MULTIBYTE
+	  if (MB_CUR_MAX > 1)
+	    {
+	      mbstate_t state_bak;
+	      size_t mblength;
+
+	      state_bak = state;
+	      mblength = mbrlen (string + sindex, strlen (string + sindex),
+				 &state);
+
+	      if (mblength == (size_t)-2 || mblength == (size_t)-1)
+		{
+		  state = state_bak;
+		  mblength = 1;
+		}
+	      mblength = (mblength < 1) ? 1 : mblength;
+
+	      FASTCOPY(string + sindex, r, mblength);
+
+	      r += mblength;
+	      sindex += mblength;
+	    }
+	  else
+#endif
+	    {
+	      *r++ = c;
+	      sindex++;
+	    }
 	  break;
 
 	case '\'':
@@ -6011,8 +6412,8 @@
   /* Separate out variable assignments at the start of the command.
      Loop invariant: vp->next == lp
      Loop postcondition:
-     	lp = list of words left after assignment statements skipped
-     	tlist = original list of words
+	lp = list of words left after assignment statements skipped
+	tlist = original list of words
   */
   while (lp && (lp->word->flags & W_ASSIGNMENT))
     {
@@ -6249,11 +6650,11 @@
       /* Only do brace expansion if the word has a brace character.  If
 	 not, just add the word list element to BRACES and continue.  In
 	 the common case, at least when running shell scripts, this will
-	 degenerate to a bunch of calls to `strchr', and then what is
+	 degenerate to a bunch of calls to `xstrchr', and then what is
 	 basically a reversal of TLIST into BRACES, which is corrected
 	 by a call to reverse_list () on BRACES when the end of TLIST
 	 is reached. */
-      if (strchr (tlist->word->word, LBRACE))
+      if (xstrchr ((const char *)tlist->word->word, LBRACE))
 	{
 	  expansions = brace_expand (tlist->word->word);
 
@@ -6313,7 +6714,7 @@
       if (temp_string[0] == '~' ||
 	    (((tlist->word->flags & (W_ASSIGNMENT|W_QUOTED)) == W_ASSIGNMENT) &&
 	     posixly_correct == 0 &&
-	     strchr (temp_string, '~') &&
+	     xstrchr ((const char *)temp_string, '~') &&
 	     (unquoted_substring ("=~", temp_string) || unquoted_substring (":~", temp_string))))
 	{
 	  tlist->word->word = bash_tilde_expand (temp_string);
@@ -6335,7 +6736,7 @@
 	  /* Dispose the new list we're building. */
 	  dispose_words (new_list);
 
-	  last_command_exit_value = EXECUTION_FAILURE;
+          last_command_exit_value = EXECUTION_FAILURE;
 	  if (expanded == &expand_word_error)
 	    jump_to_top_level (DISCARD);
 	  else
@@ -6409,13 +6810,13 @@
 		  tint = do_assignment (temp_list->word->word);
 		  /* Variable assignment errors in non-interactive shells
 		     running in Posix.2 mode cause the shell to exit. */
-		  if (tint == 0)
-		    {
-		      last_command_exit_value = EXECUTION_FAILURE;
-		      if (interactive_shell == 0 && posixly_correct)
-			jump_to_top_level (FORCE_EOF);
-		      else
-			jump_to_top_level (DISCARD);
+                  if (tint == 0)
+                    {
+                      last_command_exit_value = EXECUTION_FAILURE;
+                      if (interactive_shell == 0 && posixly_correct)
+                        jump_to_top_level (FORCE_EOF);
+                      else
+                        jump_to_top_level (DISCARD);
 		    }
 		}
 	      dispose_words (subst_assign_varlist);
@@ -6467,13 +6868,13 @@
 	  tint = (*assign_func) (temp_list->word->word);
 	  /* Variable assignment errors in non-interactive shells running
 	     in Posix.2 mode cause the shell to exit. */
-	  if (tint == 0 && assign_func == do_assignment)
-	    {
-	      last_command_exit_value = EXECUTION_FAILURE;
-	      if (interactive_shell == 0 && posixly_correct)
-		jump_to_top_level (FORCE_EOF);
-	      else
-		jump_to_top_level (DISCARD);
+          if (tint == 0 && assign_func == do_assignment)
+            {
+              last_command_exit_value = EXECUTION_FAILURE;
+              if (interactive_shell == 0 && posixly_correct)
+                jump_to_top_level (FORCE_EOF);
+              else
+                jump_to_top_level (DISCARD);
 	    }
 	}
 
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/support/recho.c bash-2.05/support/recho.c
--- bash-2.05.orig/support/recho.c	Thu Feb 20 02:17:28 1997
+++ bash-2.05/support/recho.c	Wed Apr 18 16:23:12 2001
@@ -21,7 +21,7 @@
 strprint(str)
 char	*str;
 {
-	register char *s;
+	register unsigned char *s;
 
 	for (s = str; s && *s; s++) {
 		if (*s < ' ') {
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/variables.c bash-2.05/variables.c
--- bash-2.05.orig/variables.c	Thu Feb 22 03:47:11 2001
+++ bash-2.05/variables.c	Wed Apr 18 16:23:12 2001
@@ -42,6 +42,7 @@
 #include "findcmd.h"
 #include "mailcheck.h"
 #include "input.h"
+#include "xstrchr.h"
 
 #include "builtins/getopt.h"
 #include "builtins/common.h"
@@ -62,6 +63,33 @@
 #  include "pcomplete.h"
 #endif
 
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrlen(s, n, ps) (mbrlen) (s, n, 0)
+#endif
+
+#if defined STDC_HEADERS
+# include <stdlib.h>
+#endif
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
 /* Variables used here and defined in other files. */
 extern int posixly_correct;
 extern int variable_context, line_number;
@@ -212,7 +240,7 @@
 #if defined (ARRAY_VARS)
 #  if 0
       /* Array variables may not yet be exported. */
-      else if (*string == '(' && string[1] == '[' && strchr (string, ')'))
+      else if (*string == '(' && string[1] == '[' && xstrchr ((const char *)string, ')'))
 	{
 	  string_length = 1;
 	  temp_string = extract_array_assignment_list (string, &string_length);
@@ -662,7 +690,7 @@
   vv = make_new_array_variable ("BASH_VERSINFO");
   av = array_cell (vv);
   strcpy (d, dist_version);
-  s = strchr (d, '.');
+  s = xstrchr ((const char *)d, '.');
   if (s)
     *s++ = '\0';
   array_add_element (av, 0, d);
@@ -939,7 +967,7 @@
    assign_func is called from bind_variable, if bind_variable discovers
    that the variable being assigned to has such a function.  The function
    is called as
-  	SHELL_VAR *temp = (*(entry->assign_func)) (entry, value)
+	SHELL_VAR *temp = (*(entry->assign_func)) (entry, value)
    and the (SHELL_VAR *)temp is returned as the value of bind_variable.  It
    is usually ENTRY (self).
 
@@ -947,7 +975,7 @@
    the specified dynamic varible.  If this function is NULL, the variable
    is treated as a `normal' shell variable.  If it is not, however, then
    this function is called like this:
-  	tempvar = (*(var->dynamic_value)) (var);
+	tempvar = (*(var->dynamic_value)) (var);
 
    Sometimes `tempvar' will replace the value of `var'.  Other times, the
    shell will simply use the string value.  Pretty object-oriented, huh?
@@ -1786,7 +1814,7 @@
       if (l->word == 0 || l->word->word == 0 || l->word->word[0] == '\0')
 	continue;	/* should not happen, but just in case... */
       /* Don't bother if it doesn't look like [ind]=value */
-      if (l->word->word[0] != '[' || strchr (l->word->word, '=') == 0) /* ] */
+      if (l->word->word[0] != '[' || xstrchr ((const char *)l->word->word, '=') == 0) /* ] */
 	continue;
       s = nword = xmalloc (strlen (l->word->word) * 2 + 1);
       saw_eq = 0;
@@ -1820,7 +1848,7 @@
     return var;
 
   /* If this is called from declare_builtin, value[0] == '(' and
-     strchr(value, ')') != 0.  In this case, we need to extract
+     xstrchr((const char *)value, ')') != 0.  In this case, we need to extract
      the value from between the parens before going on. */
   if (*value == '(')	/*)*/
     {
@@ -2349,12 +2377,53 @@
 {
   int count, c;
 
-  for (count = 1; count && (c = s[++i]); )
+#if HANDLE_MULTIBYTE
+  mbstate_t state, state_bak;
+  size_t strlength, mblength;
+
+  if (MB_CUR_MAX > 1)
     {
-      if (c == '[')
-	count++;
-      else if (c == ']')
-	count--;
+      memset (&state, '\0', sizeof(mbstate_t));
+      strlength = strlen (s) - i;
+      count = 1;
+
+      while(count)
+	{
+	  state_bak = state;
+	  mblength = mbrlen (&(s[i]), strlength, &state);
+
+	  if (mblength == (size_t)-2 || mblength == (size_t)-1)
+	    {
+	      state = state_bak;
+	      i++;
+	      strlength--;
+	    }
+	  else if (mblength == (size_t)0)
+	    return i;
+	  else
+	    {
+	      i += mblength;
+	      strlength -= mblength;
+	    }
+
+	  c = s[i];
+
+	  if (c == '[')
+	    count++;
+	  else if (c == ']')
+	    count--;
+	}
+    }
+  else
+#endif
+    {
+      for (count = 1; count && (c = s[++i]); )
+	{
+	  if (c == '[')
+	    count++;
+	  else if (c == ']')
+	    count--;
+	}
     }
   return i;
 }
@@ -2650,7 +2719,7 @@
 	}
 
       temp = name + offset + 1;
-      temp = (strchr (temp, '~') != 0) ? bash_tilde_expand (temp) : savestring (temp);
+      temp = (xstrchr ((const char *)temp, '~') != 0) ? bash_tilde_expand (temp) : savestring (temp);
 
       list = expand_string_unsplit (temp, 0);
       value = string_list (list);
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/xstrchr.c bash-2.05/xstrchr.c
--- bash-2.05.orig/xstrchr.c	Thu Jan  1 09:00:00 1970
+++ bash-2.05/xstrchr.c	Wed Apr 18 16:23:12 2001
@@ -0,0 +1,68 @@
+#include <config.h>
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+#if defined STDC_HEADERS
+# include <stdlib.h>
+#endif
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined HAVE_MBSRTOWCS
+#  define HANDLE_MULTIBYTE 1
+# endif
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HANDLE_MULTIBYTE && !defined HAVE_MBSTATE_T
+# define mbrlen(s, n, ps) (mbrlen) (s, n, 0)
+#endif
+
+/* On some locales, the non-first byte of some multibyte character are as 
+   same number as some ascii character. So legacy strchr() may be returns
+   wrong value . */
+
+char *
+xstrchr (const char *s, int c)
+{
+#if HANDLE_MULTIBYTE
+  if (MB_CUR_MAX > 1)
+    {
+      char *pos = (char *)s;
+      mbstate_t state;
+      size_t strlength, mblength;
+
+      memset (&state, '\0', sizeof(mbstate_t));
+      strlength = strlen (s);
+
+      while (strlength > 0)
+	{
+	  mblength = mbrlen (pos, strlength, &state); 
+
+	  if (mblength == (size_t)-2 ||
+		mblength == (size_t)-1
+		 || mblength == (size_t)0)
+	  break;
+
+	  if (c == (unsigned char)*pos)
+	    return pos;
+
+	  strlength -= mblength;
+	  pos += mblength;
+	}
+
+      return (char *)NULL;
+    }
+  else
+#endif
+    return (strchr (s, c));
+}
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/xstrchr.h bash-2.05/xstrchr.h
--- bash-2.05.orig/xstrchr.h	Thu Jan  1 09:00:00 1970
+++ bash-2.05/xstrchr.h	Wed Apr 18 16:23:12 2001
@@ -0,0 +1,7 @@
+#ifndef _XSTRCHR_H
+# define _XSTRCHR_H 1
+
+# include "stdc.h"
+
+extern char *xstrchr __P((const char *s, int c));
+#endif /* _XSTRCHR_H */
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/y.tab.c bash-2.05/y.tab.c
--- bash-2.05.orig/y.tab.c	Wed Mar 28 00:06:14 2001
+++ bash-2.05/y.tab.c	Wed Apr 18 16:23:23 2001
@@ -1,19 +1,51 @@
-#ifndef lint
-static char const 
-yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
-#endif
-#include <stdlib.h>
-#define YYBYACC 1
-#define YYMAJOR 1
-#define YYMINOR 9
-#define YYLEX yylex()
-#define YYEMPTY -1
-#define yyclearin (yychar=(YYEMPTY))
-#define yyerrok (yyerrflag=0)
-#define YYRECOVERING() (yyerrflag!=0)
-static int yygrowstack();
-#define YYPREFIX "yy"
-#line 22 "/usr/homes/chet/src/bash/src/parse.y"
+
+/*  A Bison parser, made from ./parse.y
+    by GNU Bison version 1.28  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define	IF	257
+#define	THEN	258
+#define	ELSE	259
+#define	ELIF	260
+#define	FI	261
+#define	CASE	262
+#define	ESAC	263
+#define	FOR	264
+#define	SELECT	265
+#define	WHILE	266
+#define	UNTIL	267
+#define	DO	268
+#define	DONE	269
+#define	FUNCTION	270
+#define	COND_START	271
+#define	COND_END	272
+#define	COND_ERROR	273
+#define	IN	274
+#define	BANG	275
+#define	TIME	276
+#define	TIMEOPT	277
+#define	WORD	278
+#define	ASSIGNMENT_WORD	279
+#define	NUMBER	280
+#define	ARITH_CMD	281
+#define	ARITH_FOR_EXPRS	282
+#define	COND_CMD	283
+#define	AND_AND	284
+#define	OR_OR	285
+#define	GREATER_GREATER	286
+#define	LESS_LESS	287
+#define	LESS_AND	288
+#define	GREATER_AND	289
+#define	SEMI_SEMI	290
+#define	LESS_LESS_MINUS	291
+#define	AND_GREATER	292
+#define	LESS_GREATER	293
+#define	GREATER_BAR	294
+#define	yacc_EOF	295
+
+#line 21 "./parse.y"
+
 #include "config.h"
 
 #include "bashtypes.h"
@@ -42,6 +74,35 @@
 #include "builtins/common.h"
 #include "builtins/builtext.h"
 
+/* Get MB_LEN_MAX.  */
+#if HAVE_LIMITS_H
+# include <limits.h>
+#endif
+
+/* MB_LEN_MAX is incorrectly defined to be 1 in at least one GCC
+   installation; work around this configuration error.  */
+#if MB_LEN_MAX < 16
+# define MB_LEN_MAX 16
+#endif
+
+#if defined STDC_HEADERS
+# include <stdlib.h>
+#endif
+#if !defined MB_CUR_MAX
+# define MB_CUR_MAX 16
+#endif
+
+/* For platform which support the ISO C amendement 1 functionality we
+   support user defined character classes.  */
+#if defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+# if defined (HAVE_MBSTATE_T) && defined (HAVE_MBRLEN)
+#  define HANDLE_MULTIBYTE      1
+# endif
+#endif
+
 #if defined (READLINE)
 #  include "bashline.h"
 #  include <readline/readline.h>
@@ -125,6 +186,10 @@
 char *history_delimiting_chars ();
 #endif
 
+#ifdef HANDLE_MULTIBYTE
+static void analyze_shell_input_line();
+#endif
+
 extern int yyerror ();
 
 /* Default prompt strings */
@@ -180,7 +245,8 @@
 static int arith_for_lineno;
 
 static REDIRECTEE redir;
-#line 190 "/usr/homes/chet/src/bash/src/parse.y"
+
+#line 223 "./parse.y"
 typedef union {
   WORD_DESC *word;		/* the word that we read. */
   int number;			/* the number that we read. */
@@ -190,1363 +256,2604 @@
   ELEMENT element;
   PATTERN_LIST *pattern;
 } YYSTYPE;
-#line 194 "y.tab.c"
-#define YYERRCODE 256
-#define IF 257
-#define THEN 258
-#define ELSE 259
-#define ELIF 260
-#define FI 261
-#define CASE 262
-#define ESAC 263
-#define FOR 264
-#define SELECT 265
-#define WHILE 266
-#define UNTIL 267
-#define DO 268
-#define DONE 269
-#define FUNCTION 270
-#define COND_START 271
-#define COND_END 272
-#define COND_ERROR 273
-#define IN 274
-#define BANG 275
-#define TIME 276
-#define TIMEOPT 277
-#define WORD 278
-#define ASSIGNMENT_WORD 279
-#define NUMBER 280
-#define ARITH_CMD 281
-#define ARITH_FOR_EXPRS 282
-#define COND_CMD 283
-#define AND_AND 284
-#define OR_OR 285
-#define GREATER_GREATER 286
-#define LESS_LESS 287
-#define LESS_AND 288
-#define GREATER_AND 289
-#define SEMI_SEMI 290
-#define LESS_LESS_MINUS 291
-#define AND_GREATER 292
-#define LESS_GREATER 293
-#define GREATER_BAR 294
-#define yacc_EOF 295
-const short yylhs[] = {                                        -1,
-    0,    0,    0,    0,   27,   27,   24,   24,   24,   24,
-   24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
-   24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
-   24,   24,   24,   26,   26,   26,   25,   25,   10,   10,
-    1,    1,    1,    1,   11,   11,   11,   11,   11,   11,
-   11,   11,   11,   11,   11,   12,   12,   12,   12,   12,
-   12,   18,   18,   18,   18,   13,   13,   13,   13,   13,
-   13,   14,   14,   14,   19,   19,   19,   20,   20,   23,
-   21,   21,   21,   15,   16,   17,   22,   22,   22,   31,
-   31,   29,   29,   29,   29,   30,   30,   28,   28,    4,
-    7,    7,    5,    5,    5,    6,    6,    6,    6,    6,
-    6,   34,   34,   34,   33,   33,    8,    8,    8,    9,
-    9,    9,    9,    9,    3,    3,    3,    3,    3,    2,
-    2,   32,   32,
+#include <stdio.h>
+
+#ifndef __cplusplus
+#ifndef __STDC__
+#define const
+#endif
+#endif
+
+
+
+#define	YYFINAL		287
+#define	YYFLAG		-32768
+#define	YYNTBASE	53
+
+#define YYTRANSLATE(x) ((unsigned)(x) <= 295 ? yytranslate[x] : 88)
+
+static const char yytranslate[] = {     0,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,    43,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,    41,     2,    51,
+    52,     2,     2,     2,    48,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,    42,    47,
+     2,    46,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,    49,    45,    50,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
+     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
+    37,    38,    39,    40,    44
 };
-const short yylen[] = {                                         2,
-    2,    1,    2,    1,    1,    2,    2,    2,    3,    3,
-    2,    3,    2,    3,    2,    3,    2,    3,    2,    3,
-    2,    3,    2,    3,    2,    3,    2,    3,    2,    3,
-    2,    2,    3,    1,    1,    1,    1,    2,    1,    2,
-    1,    1,    2,    1,    1,    1,    5,    5,    1,    1,
-    1,    1,    1,    1,    1,    6,    6,    7,    7,   10,
-   10,    7,    7,    5,    5,    6,    6,    7,    7,   10,
-   10,    6,    7,    6,    5,    6,    4,    1,    2,    3,
-    5,    7,    6,    3,    1,    3,    4,    6,    5,    1,
-    2,    4,    4,    5,    5,    2,    3,    1,    3,    2,
-    1,    2,    3,    3,    3,    4,    4,    4,    4,    4,
-    1,    1,    1,    1,    0,    2,    1,    2,    2,    4,
-    4,    3,    3,    1,    1,    2,    2,    3,    3,    4,
-    1,    1,    2,
+
+#if YYDEBUG != 0
+static const short yyprhs[] = {     0,
+     0,     3,     5,     8,    10,    12,    15,    18,    21,    25,
+    29,    32,    36,    39,    43,    46,    50,    53,    57,    60,
+    64,    67,    71,    74,    78,    81,    85,    88,    92,    95,
+    99,   102,   105,   109,   111,   113,   115,   117,   120,   122,
+   125,   127,   129,   132,   134,   136,   138,   144,   150,   152,
+   154,   156,   158,   160,   162,   164,   171,   178,   186,   194,
+   205,   216,   224,   232,   238,   244,   251,   258,   266,   274,
+   285,   296,   303,   311,   318,   324,   331,   336,   338,   341,
+   345,   351,   359,   366,   370,   372,   376,   381,   388,   394,
+   396,   399,   404,   409,   415,   421,   424,   428,   430,   434,
+   437,   439,   442,   446,   450,   454,   459,   464,   469,   474,
+   479,   481,   483,   485,   487,   488,   491,   493,   496,   499,
+   504,   509,   513,   517,   519,   521,   524,   527,   531,   535,
+   540,   542,   544
+};
+
+static const short yyrhs[] = {    83,
+    43,     0,    43,     0,     1,    43,     0,    44,     0,    24,
+     0,    54,    24,     0,    46,    24,     0,    47,    24,     0,
+    26,    46,    24,     0,    26,    47,    24,     0,    32,    24,
+     0,    26,    32,    24,     0,    33,    24,     0,    26,    33,
+    24,     0,    34,    26,     0,    26,    34,    26,     0,    35,
+    26,     0,    26,    35,    26,     0,    34,    24,     0,    26,
+    34,    24,     0,    35,    24,     0,    26,    35,    24,     0,
+    37,    24,     0,    26,    37,    24,     0,    35,    48,     0,
+    26,    35,    48,     0,    34,    48,     0,    26,    34,    48,
+     0,    38,    24,     0,    26,    39,    24,     0,    39,    24,
+     0,    40,    24,     0,    26,    40,    24,     0,    24,     0,
+    25,     0,    55,     0,    55,     0,    57,    55,     0,    56,
+     0,    58,    56,     0,    58,     0,    60,     0,    60,    57,
+     0,    65,     0,    61,     0,    64,     0,    12,    78,    14,
+    78,    15,     0,    13,    78,    14,    78,    15,     0,    63,
+     0,    68,     0,    67,     0,    69,     0,    70,     0,    71,
+     0,    62,     0,    10,    24,    82,    14,    78,    15,     0,
+    10,    24,    82,    49,    78,    50,     0,    10,    24,    42,
+    82,    14,    78,    15,     0,    10,    24,    42,    82,    49,
+    78,    50,     0,    10,    24,    82,    20,    54,    81,    82,
+    14,    78,    15,     0,    10,    24,    82,    20,    54,    81,
+    82,    49,    78,    50,     0,    10,    28,    81,    82,    14,
+    78,    15,     0,    10,    28,    81,    82,    49,    78,    50,
+     0,    10,    28,    14,    78,    15,     0,    10,    28,    49,
+    78,    50,     0,    11,    24,    82,    14,    77,    15,     0,
+    11,    24,    82,    49,    77,    50,     0,    11,    24,    42,
+    82,    14,    77,    15,     0,    11,    24,    42,    82,    49,
+    77,    50,     0,    11,    24,    82,    20,    54,    81,    82,
+    14,    77,    15,     0,    11,    24,    82,    20,    54,    81,
+    82,    49,    77,    50,     0,     8,    24,    82,    20,    82,
+     9,     0,     8,    24,    82,    20,    75,    82,     9,     0,
+     8,    24,    82,    20,    73,     9,     0,    24,    51,    52,
+    82,    66,     0,    16,    24,    51,    52,    82,    66,     0,
+    16,    24,    82,    66,     0,    60,     0,    60,    57,     0,
+    51,    78,    52,     0,     3,    78,     4,    78,     7,     0,
+     3,    78,     4,    78,     5,    78,     7,     0,     3,    78,
+     4,    78,    72,     7,     0,    49,    78,    50,     0,    27,
+     0,    17,    29,    18,     0,     6,    78,     4,    78,     0,
+     6,    78,     4,    78,     5,    78,     0,     6,    78,     4,
+    78,    72,     0,    74,     0,    75,    74,     0,    82,    76,
+    52,    78,     0,    82,    76,    52,    82,     0,    82,    51,
+    76,    52,    78,     0,    82,    51,    76,    52,    82,     0,
+    74,    36,     0,    75,    74,    36,     0,    24,     0,    76,
+    45,    24,     0,    82,    79,     0,    77,     0,    82,    80,
+     0,    80,    43,    82,     0,    80,    41,    82,     0,    80,
+    42,    82,     0,    80,    30,    82,    80,     0,    80,    31,
+    82,    80,     0,    80,    41,    82,    80,     0,    80,    42,
+    82,    80,     0,    80,    43,    82,    80,     0,    85,     0,
+    43,     0,    42,     0,    44,     0,     0,    82,    43,     0,
+    84,     0,    84,    41,     0,    84,    42,     0,    84,    30,
+    82,    84,     0,    84,    31,    82,    84,     0,    84,    41,
+    84,     0,    84,    42,    84,     0,    85,     0,    86,     0,
+    21,    86,     0,    87,    86,     0,    87,    21,    86,     0,
+    21,    87,    86,     0,    86,    45,    82,    86,     0,    59,
+     0,    22,     0,    22,    23,     0
+};
+
+#endif
+
+#if YYDEBUG != 0
+static const short yyrline[] = { 0,
+   273,   282,   289,   304,   314,   316,   320,   325,   330,   335,
+   340,   345,   350,   356,   362,   367,   372,   377,   382,   387,
+   392,   397,   402,   409,   416,   421,   426,   431,   436,   441,
+   446,   451,   456,   463,   465,   467,   471,   475,   486,   488,
+   492,   494,   496,   512,   516,   518,   520,   522,   524,   526,
+   528,   530,   532,   534,   536,   540,   542,   544,   546,   548,
+   550,   554,   556,   558,   560,   564,   568,   572,   576,   580,
+   584,   590,   592,   594,   598,   601,   604,   609,   611,   642,
+   649,   651,   653,   658,   662,   666,   670,   672,   674,   678,
+   679,   683,   685,   687,   689,   693,   694,   698,   700,   709,
+   717,   718,   724,   725,   732,   736,   738,   740,   747,   749,
+   751,   755,   756,   757,   760,   761,   770,   776,   785,   793,
+   795,   797,   804,   807,   811,   813,   818,   823,   828,   835,
+   838,   842,   844
 };
-const short yydefred[] = {                                      0,
-    0,  115,    0,    0,    0,  115,  115,    0,    0,    0,
-    0,    0,   35,    0,   85,    0,    0,    0,    0,    0,
-    0,    0,    0,    2,    4,    0,    0,  115,  115,    0,
-  131,    0,  124,    0,    0,    0,    0,   45,   49,   46,
-   52,   53,   54,   55,   44,   50,   51,   36,   39,    0,
-    3,  101,    0,    0,  115,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,  133,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,   11,   13,   19,   15,   27,
-   21,   17,   25,   23,   29,   31,   32,    7,    8,    0,
-    0,  115,    1,  115,  115,    0,    0,   34,   40,   37,
-    0,    0,    0,  115,  116,  111,  100,    0,    0,  115,
-    0,  115,  113,  112,  114,  115,  115,  115,    0,  115,
-  115,    0,    0,   86,    0,  115,   12,   14,   20,   16,
-   28,   22,   18,   26,   24,   30,   33,    9,   10,   84,
-   80,    0,    0,    0,    0,    0,   38,    0,    0,  115,
-  115,  115,  115,  115,  115,    0,  115,    0,  115,    0,
-    0,    0,    0,  115,    0,  115,    0,    0,  115,    0,
-   77,    0,    0,  120,  121,    0,    0,  115,  115,   81,
-    0,    0,    0,    0,    0,    0,    0,  115,    0,    0,
-  115,  115,    0,    5,    0,    0,   64,   65,  115,  115,
-  115,  115,    0,    0,    0,    0,   47,   48,    0,    0,
-   75,    0,    0,   83,  106,  107,    0,    0,    0,   96,
-    0,    0,   74,   72,   98,    0,    0,    0,    0,   56,
-    6,  115,   57,    0,    0,    0,    0,   66,    0,  115,
-   67,   76,   82,  115,  115,  115,  115,   97,   73,    0,
-    0,  115,   58,   59,    0,   62,   63,   68,   69,    0,
-    0,    0,    0,    0,  115,   99,   92,    0,  115,  115,
-  115,  115,  115,   89,   94,    0,    0,    0,    0,    0,
-   88,   60,   61,   70,   71,
+#endif
+
+
+#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+
+static const char * const yytname[] = {   "$","error","$undefined.","IF","THEN",
+"ELSE","ELIF","FI","CASE","ESAC","FOR","SELECT","WHILE","UNTIL","DO","DONE",
+"FUNCTION","COND_START","COND_END","COND_ERROR","IN","BANG","TIME","TIMEOPT",
+"WORD","ASSIGNMENT_WORD","NUMBER","ARITH_CMD","ARITH_FOR_EXPRS","COND_CMD","AND_AND",
+"OR_OR","GREATER_GREATER","LESS_LESS","LESS_AND","GREATER_AND","SEMI_SEMI","LESS_LESS_MINUS",
+"AND_GREATER","LESS_GREATER","GREATER_BAR","'&'","';'","'\\n'","yacc_EOF","'|'",
+"'>'","'<'","'-'","'{'","'}'","'('","')'","inputunit","word_list","redirection",
+"simple_command_element","redirection_list","simple_command","command","shell_command",
+"for_command","arith_for_command","select_command","case_command","function_def",
+"function_body","subshell","if_command","group_command","arith_command","cond_command",
+"elif_clause","case_clause","pattern_list","case_clause_sequence","pattern",
+"list","compound_list","list0","list1","list_terminator","newline_list","simple_list",
+"simple_list1","pipeline_command","pipeline","timespec", NULL
 };
-const short yydgoto[] = {                                      30,
-   31,   32,  106,   52,  107,  108,   53,   34,  145,   36,
-   37,   38,   39,   40,   41,   42,   43,   44,   45,  171,
-   46,  181,   47,   48,  101,   49,  195,  227,  187,  188,
-  189,   50,   54,  117,
+#endif
+
+static const short yyr1[] = {     0,
+    53,    53,    53,    53,    54,    54,    55,    55,    55,    55,
+    55,    55,    55,    55,    55,    55,    55,    55,    55,    55,
+    55,    55,    55,    55,    55,    55,    55,    55,    55,    55,
+    55,    55,    55,    56,    56,    56,    57,    57,    58,    58,
+    59,    59,    59,    59,    60,    60,    60,    60,    60,    60,
+    60,    60,    60,    60,    60,    61,    61,    61,    61,    61,
+    61,    62,    62,    62,    62,    63,    63,    63,    63,    63,
+    63,    64,    64,    64,    65,    65,    65,    66,    66,    67,
+    68,    68,    68,    69,    70,    71,    72,    72,    72,    73,
+    73,    74,    74,    74,    74,    75,    75,    76,    76,    77,
+    78,    78,    79,    79,    79,    80,    80,    80,    80,    80,
+    80,    81,    81,    81,    82,    82,    83,    83,    83,    84,
+    84,    84,    84,    84,    85,    85,    85,    85,    85,    86,
+    86,    87,    87
 };
-const short yysindex[] = {                                    -10,
-    2,    0, -258, -255, -246,    0,    0, -237, -249,  846,
- -226,   15,    0,  123,    0, -211, -203,  -44,  -43, -199,
- -198, -194, -193,    0,    0, -192, -191,    0,    0,    0,
-    0,  -41,    0,   78,   23,  956,  975,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,  721,
-    0,    0, -169,   71,    0,   35,   -6,   39, -177, -172,
-   61, -168,  -41,  933,    0,   62, -176, -173,  -30,  -27,
- -166, -163, -162, -160, -159,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,  -17,
-   69,    0,    0,    0,    0,  813,  813,    0,    0,    0,
-  975,  933,  -41,    0,    0,    0,    0,   19,   -7,    0,
-   66,    0,    0,    0,    0,    0,    0,    0,   99,    0,
-    0,   79,  305,    0,  -41,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,  104,   71,   71, -247, -247,    0,  -41, -195,    0,
-    0,    0,    0,    0,    0,    4,    0, -156,    0, -145,
-    1,    7,   12,    0, -156,    0, -144, -140,    0,  975,
-    0,  305,  -41,    0,    0,  813,  813,    0,    0,    0,
- -138,   71,   71,   71,   71,   71, -158,    0, -129,   -4,
-    0,    0, -132,    0,   -5,   16,    0,    0,    0,    0,
-    0,    0, -126,   71,   -5,   20,    0,    0,  305,  975,
-    0, -115, -111,    0,    0,    0, -240, -240, -240,    0,
- -142,   32,    0,    0,    0, -128,  -34, -120,   26,    0,
-    0,    0,    0, -114,   36, -107,   38,    0,   19,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,  -25,
- -113,    0,    0,    0,   29,    0,    0,    0,    0,   37,
- -201,   71,   71,   71,    0,    0,    0,   71,    0,    0,
-    0,    0,    0,    0,    0,   71, -100,   45,  -98,   48,
-    0,    0,    0,    0,    0,
+
+static const short yyr2[] = {     0,
+     2,     1,     2,     1,     1,     2,     2,     2,     3,     3,
+     2,     3,     2,     3,     2,     3,     2,     3,     2,     3,
+     2,     3,     2,     3,     2,     3,     2,     3,     2,     3,
+     2,     2,     3,     1,     1,     1,     1,     2,     1,     2,
+     1,     1,     2,     1,     1,     1,     5,     5,     1,     1,
+     1,     1,     1,     1,     1,     6,     6,     7,     7,    10,
+    10,     7,     7,     5,     5,     6,     6,     7,     7,    10,
+    10,     6,     7,     6,     5,     6,     4,     1,     2,     3,
+     5,     7,     6,     3,     1,     3,     4,     6,     5,     1,
+     2,     4,     4,     5,     5,     2,     3,     1,     3,     2,
+     1,     2,     3,     3,     3,     4,     4,     4,     4,     4,
+     1,     1,     1,     1,     0,     2,     1,     2,     2,     4,
+     4,     3,     3,     1,     1,     2,     2,     3,     3,     4,
+     1,     1,     2
 };
-const short yyrindex[] = {                                      0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-  888,   33,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,  450,    0,    0,  164,  118,  162,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,  126,    0,  126,    0,    0,
-  216,    0,  462,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,  165,  166,    0,    0,    0,
-  174,    0,  495,    0,    0,    0,    0,  436,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,  507,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,   11,   18,    0,  540,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,  403,
-    0,    0,  553,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,  573,  662,  765,  -85,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,  416,
-    0,    0,    0,    0,    0,    0,  587,  599,  611,    0,
-  -84,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-  -81,    0,    0,    0,    0,    0,    0, -250,    0,    0,
-    0,    0,    0,    0,    0, -244,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,
+
+static const short yydefact[] = {     0,
+     0,   115,     0,     0,     0,   115,   115,     0,     0,     0,
+   132,    34,    35,     0,    85,     0,     0,     0,     0,     0,
+     0,     0,     0,     2,     4,     0,     0,   115,   115,    36,
+    39,    41,   131,    42,    45,    55,    49,    46,    44,    51,
+    50,    52,    53,    54,     0,   117,   124,   125,     0,     3,
+   101,     0,     0,   115,   115,     0,   115,     0,     0,   115,
+     0,   126,     0,   133,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,    11,    13,    19,    15,    27,    21,
+    17,    25,    23,    29,    31,    32,     7,     8,     0,     0,
+    34,    40,    37,    43,     1,   115,   115,   118,   119,   115,
+     0,   127,   115,   116,   100,   102,   111,     0,   115,     0,
+   115,   113,   112,   114,   115,   115,   115,     0,   115,   115,
+     0,     0,    86,   129,   115,    12,    14,    20,    16,    28,
+    22,    18,    26,    24,    30,    33,     9,    10,    84,    80,
+    38,     0,     0,   122,   123,     0,   128,     0,   115,   115,
+   115,   115,   115,   115,     0,   115,     0,   115,     0,     0,
+     0,     0,   115,     0,   115,     0,     0,   115,    78,    77,
+     0,   120,   121,     0,     0,   130,   115,   115,    81,     0,
+     0,     0,   104,   105,   103,     0,    90,   115,     0,   115,
+   115,     0,     5,     0,     0,    64,    65,   115,   115,   115,
+   115,     0,     0,     0,     0,    47,    48,     0,    79,    75,
+     0,     0,    83,   106,   107,   108,   109,   110,    74,    96,
+    91,     0,    72,    98,     0,     0,     0,     0,    56,     6,
+   115,    57,     0,     0,     0,     0,    66,     0,   115,    67,
+    76,    82,   115,   115,   115,   115,    97,    73,     0,     0,
+   115,    58,    59,     0,    62,    63,    68,    69,     0,    87,
+     0,     0,     0,   115,    99,    92,    93,   115,   115,   115,
+   115,   115,    89,    94,    95,     0,     0,     0,     0,    88,
+    60,    61,    70,    71,     0,     0,     0
 };
-const short yygindex[] = {                                      0,
-    0,   -2,   10, -133,    0,  340,  798,    0,   24,    0,
- -112,    0,    0,    0,    0,    0,    0,    0,    0, -146,
-    0,  -80,    0,  -28,   21,  152,   25,  -33,    8,    0,
-    0,  182, 1196, -170,
+
+static const short yydefgoto[] = {   285,
+   194,    30,    31,    94,    32,    33,    34,    35,    36,    37,
+    38,    39,   170,    40,    41,    42,    43,    44,   180,   186,
+   187,   188,   226,    51,    52,   105,   106,   116,    53,    45,
+   144,   107,    48,    49
 };
-#define YYTABLESIZE 1468
-const short yytable[] = {                                      24,
-   80,   83,  105,  114,  114,  105,  252,   63,  100,   33,
-  170,   51,   93,  105,  131,  265,  105,  134,   95,   55,
-  122,  105,   56,   35,  232,  211,   57,  123,  154,   29,
-  203,   58,  206,   62,  240,  226,   94,   95,  105,   93,
-   61,  105,   34,  150,  151,   95,  105,  103,  122,   27,
-   65,   26,  113,  113,   66,  123,  152,  273,  179,  170,
-   96,  125,  242,  178,  179,  180,   76,  236,  237,  122,
-   34,  226,  147,   34,   77,  105,  123,  153,   84,   85,
-  105,   97,   92,   86,   87,   88,   89,   93,  104,  251,
-  120,   34,   34,  110,   34,  121,  170,  118,  251,  148,
-  122,  127,  126,  124,  128,   33,   33,  140,  105,  141,
-   29,  135,   28,  105,  136,  137,  116,  138,  139,  169,
-  146,  194,  214,  197,  207,  198,  192,   41,  208,  200,
-   27,  220,   26,  223,  202,  115,  230,  279,  280,  173,
-  233,  100,  238,   29,  241,  243,  244,  248,  253,  225,
-  254,  270,   33,   33,  256,   41,   34,   34,   41,  272,
-  257,  258,  259,   27,  266,   26,  174,  175,  282,  283,
-  284,   42,  285,  117,  118,  119,   41,   90,   91,   87,
-  274,  147,   75,   43,   74,   33,   33,   99,  159,  205,
-  210,   64,  250,   28,    0,  221,    0,    0,    0,   42,
-  146,    0,   42,    0,    0,    0,    0,    0,    0,    0,
-    0,   43,    0,    0,   43,    0,    0,    0,    0,    0,
-   42,  166,    0,    0,    0,  115,   28,    0,    0,    0,
-    0,    0,   43,   78,   81,   79,   82,    0,    0,    0,
-    0,   41,   41,    0,    0,    1,    2,  129,  115,  130,
-  132,    3,  133,    4,    5,    6,    7,    0,  224,    8,
-    9,  112,    0,    0,   10,   11,  155,   12,   13,   14,
-   15,  191,  231,  225,  199,   16,   17,   18,   19,  201,
-   20,   21,   22,   23,   25,   42,   42,    0,  115,  115,
-   34,   34,   34,   34,  249,   34,  269,   43,   43,    0,
-   34,   34,  150,  151,  271,    0,   94,   95,    0,  225,
-   34,   34,   34,    0,  105,    0,   34,   34,   34,   34,
-   34,   34,   34,   34,   34,   34,   34,    2,    0,    0,
-    0,    0,    3,  157,    4,    5,    6,    7,  115,  158,
-    8,    9,    0,    0,   29,   10,   11,    0,   12,   13,
-   14,   15,    0,    0,    0,    0,   16,   17,   18,   19,
-    2,   20,   21,   22,   23,    3,  164,    4,    5,    6,
-    7,    0,  165,    8,    9,   41,   41,   41,   41,    0,
-   41,   12,   13,   14,   15,   41,   41,    0,    0,   16,
-   17,   18,   19,  115,   20,   21,   22,   23,    0,  115,
-    0,   41,   41,    0,    0,    0,    0,   41,   67,   68,
-   69,   70,   78,   71,    0,   72,   73,    0,    0,   42,
-   42,   42,   42,    0,   42,   79,    0,   28,    0,   42,
-   42,   43,   43,   43,   43,    0,   43,    0,    0,    0,
-   78,   43,   43,   78,    0,   42,   42,    0,    0,    0,
-    0,   42,    0,   79,    0,    0,   79,   43,   43,  125,
-    0,   78,    0,   43,    0,    0,    0,    0,    0,    0,
-    0,  126,  115,    0,   79,    0,  102,  115,    0,  115,
-  115,  115,  115,    0,    0,    0,  115,  125,    0,    0,
-  125,    0,    0,    0,    0,    0,  115,    0,    0,  126,
-    0,    0,  126,    0,  127,    0,    0,    0,  125,    0,
-    0,    0,    0,    0,    0,    0,  129,    0,    0,    0,
-  126,  215,  216,  217,  218,  219,   78,   78,    0,    0,
-    0,    0,  127,    0,    0,  127,    0,    0,    0,   79,
-   79,    0,    0,  239,  129,    0,    0,  129,    0,  128,
-    0,    0,    0,  127,    0,    0,    0,    0,    0,    0,
-  102,    2,  130,    0,    0,  129,    3,    0,    4,    5,
-    6,    7,    0,    0,  125,    9,    0,  128,    0,    0,
-  128,    0,    0,    0,    0,   15,  126,    0,    0,    0,
-  130,    0,    0,  130,    0,    0,  108,    0,  128,    0,
-    0,  217,  218,  219,    0,    0,    0,    0,  109,    0,
-    0,  130,    0,  104,    0,    0,    0,    0,    0,  127,
-  110,    0,    0,    0,  108,    0,    0,  108,    0,    0,
-    0,  129,    0,    0,    0,    0,  109,    0,    0,  109,
-    0,    0,    0,    0,    0,  108,    0,    0,  110,    0,
-    0,  110,    0,    0,    0,    0,    0,  109,    0,    0,
-   78,   78,   78,   78,  128,   78,    0,    0,    0,  110,
-   78,   78,    0,   79,   79,   79,   79,  130,   79,    0,
-    0,    0,    0,   79,   79,    0,   78,   78,    0,    0,
-    0,    0,   78,  102,  102,  102,  102,  104,  102,   79,
-   79,    0,  105,  102,  102,   79,    0,  125,  125,  125,
-  125,  108,  125,    0,    0,    0,    0,  125,  125,  126,
-  126,  126,  126,  109,  126,  102,    0,    0,    0,  126,
-  126,    0,    0,  125,  125,  110,    0,    0,    0,  125,
-    0,    0,    0,    0,    0,  126,  126,    0,    0,    0,
-    0,  126,  127,  127,  127,  127,    0,  127,    0,    0,
-   29,    0,  127,  127,  129,  129,  129,  129,    0,  129,
-    0,    0,    0,    0,  129,  129,    0,    0,  127,  127,
-   27,    0,   26,    0,  127,    0,  105,    0,    0,    0,
-  129,  129,    0,    0,    0,    0,  129,  128,  128,  128,
-  128,    0,  128,   59,   60,  103,    0,  128,  128,    0,
-  130,  130,  130,  130,    0,  130,    0,    0,    0,    0,
-  130,  130,    0,  128,  128,   90,   91,    0,    0,  128,
-  104,  104,  104,  104,    0,  104,  130,  130,    0,    0,
-  104,  104,  130,   28,  108,  108,  108,  108,    0,  108,
-    0,    0,   29,    0,  108,  108,  109,  109,  109,  109,
-    0,  109,  104,    0,    0,    0,  109,  109,  110,  110,
-  110,  110,   27,  110,   26,    0,  108,    0,  110,  110,
-    0,    0,    0,    0,    0,   29,    0,    0,  109,  103,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-  110,  149,    0,    0,    0,   27,    0,   26,    0,  160,
-    0,    0,    0,  161,    0,    0,    0,  167,  168,  105,
-  105,  105,  105,    0,  105,    0,    0,  132,    0,  105,
-  105,    0,    0,    0,    0,   28,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,  132,    0,  132,
-    0,  105,    0,    0,  193,    0,  196,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,   28,    0,
-    0,    0,   29,    0,    0,  212,  213,    2,    0,    0,
-    0,    0,    3,    0,    4,    5,    6,    7,  228,  229,
-    8,    9,   27,    0,   26,  102,  234,  235,   12,   13,
-   14,   15,    0,    0,    0,    0,   16,   17,   18,   19,
-  132,   20,   21,   22,   23,   27,    0,   26,    0,    0,
-    0,    0,  103,  103,  103,  103,    0,  103,    0,    0,
-    0,    0,  103,  103,   27,    0,   26,    0,    0,    0,
-    0,  261,    0,    0,    0,    0,    0,    0,    0,  267,
-    0,    0,    0,    0,  103,   28,    0,    0,    0,    0,
-    0,    0,  275,    0,    0,    0,  277,  278,    0,    2,
-  281,    0,    0,    0,    3,    0,    4,    5,    6,    7,
-    0,    0,    8,    9,    0,    0,    0,   10,   11,    0,
-   12,   13,   14,   15,    0,    0,    0,    0,   16,   17,
-   18,   19,    2,   20,   21,   22,   23,    3,    0,    4,
-    5,    6,    7,    0,    0,    8,    9,    0,    0,    0,
-    0,   11,    0,   12,   13,   14,   15,    0,    0,    0,
-    0,   16,   17,   18,   19,    0,   20,   21,   22,   23,
-    0,    0,    0,    0,  132,    0,    0,    0,    0,  132,
-    0,  132,  132,  132,  132,    0,    0,  132,  132,    0,
-    0,    0,  132,    0,    0,  132,  132,  132,  132,    0,
-    0,    0,    0,  132,  132,  132,  132,    0,  132,  132,
-  132,  132,    0,    0,    0,    0,    0,    0,    0,    2,
-    0,    0,    0,    0,    3,    0,    4,    5,    6,    7,
-    0,    0,    8,    9,    0,    0,    0,    0,    0,    0,
-   12,   13,   14,   15,    0,    0,    0,    0,   16,   17,
-   18,   19,    0,   20,   21,   22,   23,    0,    0,    0,
-    0,    0,    0,   98,   13,   14,    0,    0,    0,    0,
-    0,   16,   17,   18,   19,    0,   20,   21,   22,   23,
-  109,  111,    0,  119,   14,    0,  123,    0,    0,    0,
-   16,   17,   18,   19,    0,   20,   21,   22,   23,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,  142,    0,  143,
-  144,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,  156,    0,    0,    0,    0,
-    0,    0,  162,  163,    0,    0,    0,    0,    0,    0,
-    0,  172,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,  182,  183,  184,  185,  186,
-  190,    0,    0,    0,    0,    0,    0,    0,    0,  204,
-    0,  204,    0,    0,  209,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,  222,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,  204,  204,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,  255,    0,    0,
-    0,    0,    0,    0,    0,  260,    0,    0,    0,    0,
-  262,  263,  264,    0,    0,    0,    0,  268,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-  276,    0,    0,    0,    0,    0,  204,  204,
+
+static const short yypact[] = {   264,
+   -30,-32768,    -7,    -9,    34,-32768,-32768,    40,    -1,   390,
+    47,   -14,-32768,   177,-32768,    43,    57,    42,    56,    59,
+    65,    67,    82,-32768,-32768,    87,    88,-32768,-32768,-32768,
+-32768,   544,-32768,   560,-32768,-32768,-32768,-32768,-32768,-32768,
+-32768,-32768,-32768,-32768,    72,   107,-32768,    78,   432,-32768,
+-32768,   127,   306,-32768,    90,    10,   103,   110,   121,   104,
+   139,    78,   516,-32768,   114,   143,   149,    60,   157,   150,
+   158,   163,   170,   171,-32768,-32768,-32768,-32768,-32768,-32768,
+-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   151,   144,
+-32768,-32768,-32768,   560,-32768,-32768,-32768,   348,   348,-32768,
+   516,    78,-32768,-32768,-32768,   188,-32768,    14,-32768,   -11,
+-32768,-32768,-32768,-32768,-32768,-32768,-32768,     6,-32768,-32768,
+   152,   148,-32768,    78,-32768,-32768,-32768,-32768,-32768,-32768,
+-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+-32768,   306,   306,    44,    44,   474,    78,    89,-32768,-32768,
+-32768,-32768,-32768,-32768,    13,-32768,   174,-32768,   185,   153,
+    73,    93,-32768,   174,-32768,   187,   191,-32768,   560,-32768,
+   148,-32768,-32768,   348,   348,    78,-32768,-32768,-32768,   201,
+   306,   306,   306,   306,   306,   204,   189,-32768,    20,-32768,
+-32768,   211,-32768,   146,   178,-32768,-32768,-32768,-32768,-32768,
+-32768,   217,   306,   146,   183,-32768,-32768,   148,   560,-32768,
+   227,   231,-32768,-32768,-32768,    48,    48,    48,-32768,-32768,
+   200,    26,-32768,-32768,   214,   -31,   224,   192,-32768,-32768,
+-32768,-32768,   226,   193,   229,   198,-32768,   188,-32768,-32768,
+-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   -27,   225,
+-32768,-32768,-32768,   119,-32768,-32768,-32768,-32768,   120,    94,
+   306,   306,   306,-32768,-32768,-32768,   306,-32768,-32768,-32768,
+-32768,-32768,-32768,-32768,   306,   235,   202,   236,   203,-32768,
+-32768,-32768,-32768,-32768,   254,   255,-32768
 };
-const short yycheck[] = {                                      10,
-   45,   45,   10,   10,   10,   10,   41,   10,   37,    0,
-  123,   10,  263,   10,   45,   41,   10,   45,  263,  278,
-   10,   10,  278,    0,  195,  172,  282,   10,   10,   40,
-  164,  278,  166,  283,  205,   40,  284,  285,   10,  290,
-  278,   10,   10,  284,  285,  290,   10,   50,   38,   60,
-  277,   62,   59,   59,   40,   38,   38,  259,  260,  172,
-   38,   64,  209,  259,  260,  261,  278,  201,  202,   59,
-   38,   40,  101,   41,  278,   10,   59,   59,  278,  278,
-   10,   59,  124,  278,  278,  278,  278,   10,  258,  124,
-  268,   59,   60,   59,   62,  268,  209,   59,  124,  102,
-   40,  278,   41,  272,  278,   96,   97,  125,   10,   41,
-   40,  278,  123,   10,  278,  278,  123,  278,  278,   41,
-   97,  278,  261,  269,  269,  125,  123,   10,  269,  123,
-   60,  290,   62,  263,  123,   10,  269,  271,  272,  142,
-  125,  170,  269,   40,  125,  261,  258,  290,  269,  278,
-  125,  123,  143,  144,  269,   38,  124,  125,   41,  123,
-  125,  269,  125,   60,  278,   62,  143,  144,  269,  125,
-  269,   10,  125,   10,   10,   10,   59,  263,  263,  261,
-  261,  210,   60,   10,   62,  176,  177,   36,  123,  165,
-  170,   10,  226,  123,   -1,  188,   -1,   -1,   -1,   38,
-  177,   -1,   41,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   38,   -1,   -1,   41,   -1,   -1,   -1,   -1,   -1,
-   59,  123,   -1,   -1,   -1,   10,  123,   -1,   -1,   -1,
-   -1,   -1,   59,  278,  278,  280,  280,   -1,   -1,   -1,
-   -1,  124,  125,   -1,   -1,  256,  257,  278,  123,  280,
-  278,  262,  280,  264,  265,  266,  267,   -1,  263,  270,
-  271,  268,   -1,   -1,  275,  276,  274,  278,  279,  280,
-  281,  268,  278,  278,  268,  286,  287,  288,  289,  268,
-  291,  292,  293,  294,  295,  124,  125,   -1,  295,  295,
-  258,  259,  260,  261,  263,  263,  268,  124,  125,   -1,
-  268,  269,  284,  285,  268,   -1,  284,  285,   -1,  278,
-  278,  279,  280,   -1,   10,   -1,  284,  285,  286,  287,
-  288,  289,  290,  291,  292,  293,  294,  257,   -1,   -1,
-   -1,   -1,  262,  268,  264,  265,  266,  267,  123,  274,
-  270,  271,   -1,   -1,   40,  275,  276,   -1,  278,  279,
-  280,  281,   -1,   -1,   -1,   -1,  286,  287,  288,  289,
-  257,  291,  292,  293,  294,  262,  268,  264,  265,  266,
-  267,   -1,  274,  270,  271,  258,  259,  260,  261,   -1,
-  263,  278,  279,  280,  281,  268,  269,   -1,   -1,  286,
-  287,  288,  289,  268,  291,  292,  293,  294,   -1,  274,
-   -1,  284,  285,   -1,   -1,   -1,   -1,  290,  286,  287,
-  288,  289,   10,  291,   -1,  293,  294,   -1,   -1,  258,
-  259,  260,  261,   -1,  263,   10,   -1,  123,   -1,  268,
-  269,  258,  259,  260,  261,   -1,  263,   -1,   -1,   -1,
-   38,  268,  269,   41,   -1,  284,  285,   -1,   -1,   -1,
-   -1,  290,   -1,   38,   -1,   -1,   41,  284,  285,   10,
-   -1,   59,   -1,  290,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   10,  257,   -1,   59,   -1,   41,  262,   -1,  264,
-  265,  266,  267,   -1,   -1,   -1,  271,   38,   -1,   -1,
-   41,   -1,   -1,   -1,   -1,   -1,  281,   -1,   -1,   38,
-   -1,   -1,   41,   -1,   10,   -1,   -1,   -1,   59,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   10,   -1,   -1,   -1,
-   59,  182,  183,  184,  185,  186,  124,  125,   -1,   -1,
-   -1,   -1,   38,   -1,   -1,   41,   -1,   -1,   -1,  124,
-  125,   -1,   -1,  204,   38,   -1,   -1,   41,   -1,   10,
-   -1,   -1,   -1,   59,   -1,   -1,   -1,   -1,   -1,   -1,
-  125,  257,   10,   -1,   -1,   59,  262,   -1,  264,  265,
-  266,  267,   -1,   -1,  125,  271,   -1,   38,   -1,   -1,
-   41,   -1,   -1,   -1,   -1,  281,  125,   -1,   -1,   -1,
-   38,   -1,   -1,   41,   -1,   -1,   10,   -1,   59,   -1,
-   -1,  262,  263,  264,   -1,   -1,   -1,   -1,   10,   -1,
-   -1,   59,   -1,   41,   -1,   -1,   -1,   -1,   -1,  125,
-   10,   -1,   -1,   -1,   38,   -1,   -1,   41,   -1,   -1,
-   -1,  125,   -1,   -1,   -1,   -1,   38,   -1,   -1,   41,
-   -1,   -1,   -1,   -1,   -1,   59,   -1,   -1,   38,   -1,
-   -1,   41,   -1,   -1,   -1,   -1,   -1,   59,   -1,   -1,
-  258,  259,  260,  261,  125,  263,   -1,   -1,   -1,   59,
-  268,  269,   -1,  258,  259,  260,  261,  125,  263,   -1,
-   -1,   -1,   -1,  268,  269,   -1,  284,  285,   -1,   -1,
-   -1,   -1,  290,  258,  259,  260,  261,  125,  263,  284,
-  285,   -1,   41,  268,  269,  290,   -1,  258,  259,  260,
-  261,  125,  263,   -1,   -1,   -1,   -1,  268,  269,  258,
-  259,  260,  261,  125,  263,  290,   -1,   -1,   -1,  268,
-  269,   -1,   -1,  284,  285,  125,   -1,   -1,   -1,  290,
-   -1,   -1,   -1,   -1,   -1,  284,  285,   -1,   -1,   -1,
-   -1,  290,  258,  259,  260,  261,   -1,  263,   -1,   -1,
-   40,   -1,  268,  269,  258,  259,  260,  261,   -1,  263,
-   -1,   -1,   -1,   -1,  268,  269,   -1,   -1,  284,  285,
-   60,   -1,   62,   -1,  290,   -1,  125,   -1,   -1,   -1,
-  284,  285,   -1,   -1,   -1,   -1,  290,  258,  259,  260,
-  261,   -1,  263,    6,    7,   41,   -1,  268,  269,   -1,
-  258,  259,  260,  261,   -1,  263,   -1,   -1,   -1,   -1,
-  268,  269,   -1,  284,  285,   28,   29,   -1,   -1,  290,
-  258,  259,  260,  261,   -1,  263,  284,  285,   -1,   -1,
-  268,  269,  290,  123,  258,  259,  260,  261,   -1,  263,
-   -1,   -1,   40,   -1,  268,  269,  258,  259,  260,  261,
-   -1,  263,  290,   -1,   -1,   -1,  268,  269,  258,  259,
-  260,  261,   60,  263,   62,   -1,  290,   -1,  268,  269,
-   -1,   -1,   -1,   -1,   -1,   40,   -1,   -1,  290,  125,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-  290,  104,   -1,   -1,   -1,   60,   -1,   62,   -1,  112,
-   -1,   -1,   -1,  116,   -1,   -1,   -1,  120,  121,  258,
-  259,  260,  261,   -1,  263,   -1,   -1,   40,   -1,  268,
-  269,   -1,   -1,   -1,   -1,  123,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   60,   -1,   62,
-   -1,  290,   -1,   -1,  157,   -1,  159,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  123,   -1,
-   -1,   -1,   40,   -1,   -1,  178,  179,  257,   -1,   -1,
-   -1,   -1,  262,   -1,  264,  265,  266,  267,  191,  192,
-  270,  271,   60,   -1,   62,  275,  199,  200,  278,  279,
-  280,  281,   -1,   -1,   -1,   -1,  286,  287,  288,  289,
-  123,  291,  292,  293,  294,   60,   -1,   62,   -1,   -1,
-   -1,   -1,  258,  259,  260,  261,   -1,  263,   -1,   -1,
-   -1,   -1,  268,  269,   60,   -1,   62,   -1,   -1,   -1,
-   -1,  244,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  252,
-   -1,   -1,   -1,   -1,  290,  123,   -1,   -1,   -1,   -1,
-   -1,   -1,  265,   -1,   -1,   -1,  269,  270,   -1,  257,
-  273,   -1,   -1,   -1,  262,   -1,  264,  265,  266,  267,
-   -1,   -1,  270,  271,   -1,   -1,   -1,  275,  276,   -1,
-  278,  279,  280,  281,   -1,   -1,   -1,   -1,  286,  287,
-  288,  289,  257,  291,  292,  293,  294,  262,   -1,  264,
-  265,  266,  267,   -1,   -1,  270,  271,   -1,   -1,   -1,
-   -1,  276,   -1,  278,  279,  280,  281,   -1,   -1,   -1,
-   -1,  286,  287,  288,  289,   -1,  291,  292,  293,  294,
-   -1,   -1,   -1,   -1,  257,   -1,   -1,   -1,   -1,  262,
-   -1,  264,  265,  266,  267,   -1,   -1,  270,  271,   -1,
-   -1,   -1,  275,   -1,   -1,  278,  279,  280,  281,   -1,
-   -1,   -1,   -1,  286,  287,  288,  289,   -1,  291,  292,
-  293,  294,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
-   -1,   -1,   -1,   -1,  262,   -1,  264,  265,  266,  267,
-   -1,   -1,  270,  271,   -1,   -1,   -1,   -1,   -1,   -1,
-  278,  279,  280,  281,   -1,   -1,   -1,   -1,  286,  287,
-  288,  289,   -1,  291,  292,  293,  294,   -1,   -1,   -1,
-   -1,   -1,   -1,  278,  279,  280,   -1,   -1,   -1,   -1,
-   -1,  286,  287,  288,  289,   -1,  291,  292,  293,  294,
-   55,   56,   -1,   58,  280,   -1,   61,   -1,   -1,   -1,
-  286,  287,  288,  289,   -1,  291,  292,  293,  294,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   92,   -1,   94,
-   95,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,  110,   -1,   -1,   -1,   -1,
-   -1,   -1,  117,  118,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,  126,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,  150,  151,  152,  153,  154,
-  155,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  164,
-   -1,  166,   -1,   -1,  169,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,  188,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,  201,  202,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,  232,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,  240,   -1,   -1,   -1,   -1,
-  245,  246,  247,   -1,   -1,   -1,   -1,  252,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-  265,   -1,   -1,   -1,   -1,   -1,  271,  272,
+
+static const short yypgoto[] = {-32768,
+    92,   -29,   228,    95,-32768,-32768,  -120,-32768,-32768,-32768,
+-32768,-32768,  -163,-32768,-32768,-32768,-32768,-32768,     1,-32768,
+    69,-32768,    45,  -153,    -6,-32768,  -142,  -188,   -24,-32768,
+    11,     4,    -3,   249
 };
-#define YYFINAL 30
-#ifndef YYDEBUG
-#define YYDEBUG 0
-#endif
-#define YYMAXTOKEN 295
-#if YYDEBUG
-const char * const yyname[] = {
-"end-of-file",0,0,0,0,0,0,0,0,0,"'\\n'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,"'&'",0,"'('","')'",0,0,0,"'-'",0,0,0,0,0,0,0,0,0,0,0,0,0,"';'",
-"'<'",0,"'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'","'|'","'}'",0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,"IF","THEN","ELSE","ELIF","FI","CASE","ESAC","FOR","SELECT",
-"WHILE","UNTIL","DO","DONE","FUNCTION","COND_START","COND_END","COND_ERROR",
-"IN","BANG","TIME","TIMEOPT","WORD","ASSIGNMENT_WORD","NUMBER","ARITH_CMD",
-"ARITH_FOR_EXPRS","COND_CMD","AND_AND","OR_OR","GREATER_GREATER","LESS_LESS",
-"LESS_AND","GREATER_AND","SEMI_SEMI","LESS_LESS_MINUS","AND_GREATER",
-"LESS_GREATER","GREATER_BAR","yacc_EOF",
+
+
+#define	YYLAST		607
+
+
+static const short yytable[] = {    58,
+    59,   169,   156,    47,    93,   231,    62,   210,   157,   202,
+    46,   205,    50,   250,    55,   239,    54,   250,    56,   163,
+   251,    89,    90,   111,   264,   164,   190,    61,   223,   108,
+   110,   104,   118,   154,   248,   122,    65,   158,   214,   215,
+   216,   217,   218,   224,   241,   102,   235,   236,   104,   224,
+   169,   112,   113,   114,   165,   104,   104,    57,   115,   124,
+   238,   191,   104,    60,   141,    77,    75,    78,   104,    64,
+   225,   142,   143,    96,    97,   146,   225,   149,   150,    80,
+    76,    81,    83,   128,   155,   129,   198,   169,    84,    79,
+    85,   161,   162,   177,   178,   179,   148,   147,   272,   178,
+   171,    47,    47,    82,   159,    86,   200,   130,   160,   145,
+    87,    88,   166,   167,    95,   104,   278,   279,   216,   217,
+   218,   199,   100,   119,   181,   182,   183,   184,   185,   189,
+   103,   109,   268,   270,   120,   104,    96,    97,   203,    93,
+   203,   201,   176,   208,   117,    47,    47,    98,    99,   192,
+     2,   195,   172,   173,   121,     3,   123,     4,     5,     6,
+     7,   104,   104,   222,     9,   125,   126,   269,   271,   230,
+   211,   212,   127,   134,    15,   203,   203,    47,    47,   141,
+   131,   135,   132,   227,   228,   145,   136,   112,   113,   114,
+   104,   233,   234,   137,   138,   140,    28,   193,    29,   196,
+   139,   206,   197,   168,   133,   207,   254,   213,    66,    67,
+    68,    69,   219,    70,   259,    71,    72,   149,   150,   261,
+   262,   263,    73,    74,   220,   229,   267,   232,   151,   152,
+   153,   237,   240,   242,   243,   247,   260,   224,   252,   275,
+   255,   253,   256,   257,   266,   203,   203,   258,   265,   281,
+   283,   282,   284,   286,   287,   204,   221,   274,    63,    92,
+   273,   276,   277,   209,     1,   280,     2,     0,     0,   249,
+     0,     3,     0,     4,     5,     6,     7,     0,     0,     8,
+     9,     0,     0,     0,    10,    11,     0,    12,    13,    14,
+    15,     0,     0,     0,     0,    16,    17,    18,    19,     0,
+    20,    21,    22,    23,     0,     0,    24,    25,     2,    26,
+    27,     0,    28,     3,    29,     4,     5,     6,     7,     0,
+     0,     8,     9,     0,     0,     0,    10,    11,     0,    12,
+    13,    14,    15,     0,     0,     0,     0,    16,    17,    18,
+    19,     0,    20,    21,    22,    23,     0,     0,   104,     0,
+     2,    26,    27,     0,    28,     3,    29,     4,     5,     6,
+     7,     0,     0,     8,     9,     0,     0,     0,    10,    11,
+     0,    12,    13,    14,    15,     0,     0,     0,     0,    16,
+    17,    18,    19,     0,    20,    21,    22,    23,     0,     0,
+     0,     0,     2,    26,    27,     0,    28,     3,    29,     4,
+     5,     6,     7,     0,     0,     8,     9,     0,     0,     0,
+     0,    11,     0,    12,    13,    14,    15,     0,     0,     0,
+     0,    16,    17,    18,    19,     0,    20,    21,    22,    23,
+     0,     0,     0,     0,     2,    26,    27,     0,    28,     3,
+    29,     4,     5,     6,     7,     0,     0,     8,     9,     0,
+     0,     0,   101,     0,     0,    12,    13,    14,    15,     0,
+     0,     0,     0,    16,    17,    18,    19,     0,    20,    21,
+    22,    23,     0,     0,     0,     0,     2,    26,    27,     0,
+    28,     3,    29,     4,     5,     6,     7,     0,     0,     8,
+     9,     0,     0,     0,     0,     0,     0,    12,    13,    14,
+    15,     0,     0,     0,     0,    16,    17,    18,    19,     0,
+    20,    21,    22,    23,     0,     0,   104,     0,     2,    26,
+    27,     0,    28,     3,    29,     4,     5,     6,     7,     0,
+     0,     8,     9,     0,     0,     0,     0,     0,     0,    12,
+    13,    14,    15,     0,     0,     0,     0,    16,    17,    18,
+    19,     0,    20,    21,    22,    23,     0,     0,     0,     0,
+     0,    26,    27,     0,    28,     0,    29,    91,    13,    14,
+     0,     0,     0,     0,     0,    16,    17,    18,    19,     0,
+    20,    21,    22,    23,     0,    14,     0,     0,     0,    26,
+    27,    16,    17,    18,    19,     0,    20,    21,    22,    23,
+     0,     0,     0,     0,     0,    26,    27
 };
-const char * const yyrule[] = {
-"$accept : inputunit",
-"inputunit : simple_list '\\n'",
-"inputunit : '\\n'",
-"inputunit : error '\\n'",
-"inputunit : yacc_EOF",
-"word_list : WORD",
-"word_list : word_list WORD",
-"redirection : '>' WORD",
-"redirection : '<' WORD",
-"redirection : NUMBER '>' WORD",
-"redirection : NUMBER '<' WORD",
-"redirection : GREATER_GREATER WORD",
-"redirection : NUMBER GREATER_GREATER WORD",
-"redirection : LESS_LESS WORD",
-"redirection : NUMBER LESS_LESS WORD",
-"redirection : LESS_AND NUMBER",
-"redirection : NUMBER LESS_AND NUMBER",
-"redirection : GREATER_AND NUMBER",
-"redirection : NUMBER GREATER_AND NUMBER",
-"redirection : LESS_AND WORD",
-"redirection : NUMBER LESS_AND WORD",
-"redirection : GREATER_AND WORD",
-"redirection : NUMBER GREATER_AND WORD",
-"redirection : LESS_LESS_MINUS WORD",
-"redirection : NUMBER LESS_LESS_MINUS WORD",
-"redirection : GREATER_AND '-'",
-"redirection : NUMBER GREATER_AND '-'",
-"redirection : LESS_AND '-'",
-"redirection : NUMBER LESS_AND '-'",
-"redirection : AND_GREATER WORD",
-"redirection : NUMBER LESS_GREATER WORD",
-"redirection : LESS_GREATER WORD",
-"redirection : GREATER_BAR WORD",
-"redirection : NUMBER GREATER_BAR WORD",
-"simple_command_element : WORD",
-"simple_command_element : ASSIGNMENT_WORD",
-"simple_command_element : redirection",
-"redirection_list : redirection",
-"redirection_list : redirection_list redirection",
-"simple_command : simple_command_element",
-"simple_command : simple_command simple_command_element",
-"command : simple_command",
-"command : shell_command",
-"command : shell_command redirection_list",
-"command : function_def",
-"shell_command : for_command",
-"shell_command : case_command",
-"shell_command : WHILE compound_list DO compound_list DONE",
-"shell_command : UNTIL compound_list DO compound_list DONE",
-"shell_command : select_command",
-"shell_command : if_command",
-"shell_command : subshell",
-"shell_command : group_command",
-"shell_command : arith_command",
-"shell_command : cond_command",
-"shell_command : arith_for_command",
-"for_command : FOR WORD newline_list DO compound_list DONE",
-"for_command : FOR WORD newline_list '{' compound_list '}'",
-"for_command : FOR WORD ';' newline_list DO compound_list DONE",
-"for_command : FOR WORD ';' newline_list '{' compound_list '}'",
-"for_command : FOR WORD newline_list IN word_list list_terminator newline_list DO compound_list DONE",
-"for_command : FOR WORD newline_list IN word_list list_terminator newline_list '{' compound_list '}'",
-"arith_for_command : FOR ARITH_FOR_EXPRS list_terminator newline_list DO compound_list DONE",
-"arith_for_command : FOR ARITH_FOR_EXPRS list_terminator newline_list '{' compound_list '}'",
-"arith_for_command : FOR ARITH_FOR_EXPRS DO compound_list DONE",
-"arith_for_command : FOR ARITH_FOR_EXPRS '{' compound_list '}'",
-"select_command : SELECT WORD newline_list DO list DONE",
-"select_command : SELECT WORD newline_list '{' list '}'",
-"select_command : SELECT WORD ';' newline_list DO list DONE",
-"select_command : SELECT WORD ';' newline_list '{' list '}'",
-"select_command : SELECT WORD newline_list IN word_list list_terminator newline_list DO list DONE",
-"select_command : SELECT WORD newline_list IN word_list list_terminator newline_list '{' list '}'",
-"case_command : CASE WORD newline_list IN newline_list ESAC",
-"case_command : CASE WORD newline_list IN case_clause_sequence newline_list ESAC",
-"case_command : CASE WORD newline_list IN case_clause ESAC",
-"function_def : WORD '(' ')' newline_list function_body",
-"function_def : FUNCTION WORD '(' ')' newline_list function_body",
-"function_def : FUNCTION WORD newline_list function_body",
-"function_body : shell_command",
-"function_body : shell_command redirection_list",
-"subshell : '(' compound_list ')'",
-"if_command : IF compound_list THEN compound_list FI",
-"if_command : IF compound_list THEN compound_list ELSE compound_list FI",
-"if_command : IF compound_list THEN compound_list elif_clause FI",
-"group_command : '{' compound_list '}'",
-"arith_command : ARITH_CMD",
-"cond_command : COND_START COND_CMD COND_END",
-"elif_clause : ELIF compound_list THEN compound_list",
-"elif_clause : ELIF compound_list THEN compound_list ELSE compound_list",
-"elif_clause : ELIF compound_list THEN compound_list elif_clause",
-"case_clause : pattern_list",
-"case_clause : case_clause_sequence pattern_list",
-"pattern_list : newline_list pattern ')' compound_list",
-"pattern_list : newline_list pattern ')' newline_list",
-"pattern_list : newline_list '(' pattern ')' compound_list",
-"pattern_list : newline_list '(' pattern ')' newline_list",
-"case_clause_sequence : pattern_list SEMI_SEMI",
-"case_clause_sequence : case_clause_sequence pattern_list SEMI_SEMI",
-"pattern : WORD",
-"pattern : pattern '|' WORD",
-"list : newline_list list0",
-"compound_list : list",
-"compound_list : newline_list list1",
-"list0 : list1 '\\n' newline_list",
-"list0 : list1 '&' newline_list",
-"list0 : list1 ';' newline_list",
-"list1 : list1 AND_AND newline_list list1",
-"list1 : list1 OR_OR newline_list list1",
-"list1 : list1 '&' newline_list list1",
-"list1 : list1 ';' newline_list list1",
-"list1 : list1 '\\n' newline_list list1",
-"list1 : pipeline_command",
-"list_terminator : '\\n'",
-"list_terminator : ';'",
-"list_terminator : yacc_EOF",
-"newline_list :",
-"newline_list : newline_list '\\n'",
-"simple_list : simple_list1",
-"simple_list : simple_list1 '&'",
-"simple_list : simple_list1 ';'",
-"simple_list1 : simple_list1 AND_AND newline_list simple_list1",
-"simple_list1 : simple_list1 OR_OR newline_list simple_list1",
-"simple_list1 : simple_list1 '&' simple_list1",
-"simple_list1 : simple_list1 ';' simple_list1",
-"simple_list1 : pipeline_command",
-"pipeline_command : pipeline",
-"pipeline_command : BANG pipeline",
-"pipeline_command : timespec pipeline",
-"pipeline_command : timespec BANG pipeline",
-"pipeline_command : BANG timespec pipeline",
-"pipeline : pipeline '|' newline_list pipeline",
-"pipeline : command",
-"timespec : TIME",
-"timespec : TIME TIMEOPT",
+
+static const short yycheck[] = {     6,
+     7,   122,    14,     0,    34,   194,    10,   171,    20,   163,
+     0,   165,    43,    45,    24,   204,    24,    45,    28,    14,
+    52,    28,    29,    14,    52,    20,    14,    29,     9,    54,
+    55,    43,    57,    20,     9,    60,    51,    49,   181,   182,
+   183,   184,   185,    24,   208,    49,   200,   201,    43,    24,
+   171,    42,    43,    44,    49,    43,    43,    24,    49,    63,
+   203,    49,    43,    24,    94,    24,    24,    26,    43,    23,
+    51,    96,    97,    30,    31,   100,    51,    30,    31,    24,
+    24,    26,    24,    24,   109,    26,    14,   208,    24,    48,
+    24,   116,   117,     5,     6,     7,   103,   101,     5,     6,
+   125,    98,    99,    48,   111,    24,    14,    48,   115,    99,
+    24,    24,   119,   120,    43,    43,   270,   271,   261,   262,
+   263,    49,    45,    14,   149,   150,   151,   152,   153,   154,
+     4,    42,    14,    14,    14,    43,    30,    31,   163,   169,
+   165,    49,   146,   168,    42,   142,   143,    41,    42,   156,
+     3,   158,   142,   143,    51,     8,    18,    10,    11,    12,
+    13,    43,    43,   188,    17,    52,    24,    49,    49,    24,
+   177,   178,    24,    24,    27,   200,   201,   174,   175,   209,
+    24,    24,    26,   190,   191,   175,    24,    42,    43,    44,
+    43,   198,   199,    24,    24,    52,    49,    24,    51,    15,
+    50,    15,    50,    52,    48,    15,   231,     7,    32,    33,
+    34,    35,     9,    37,   239,    39,    40,    30,    31,   244,
+   245,   246,    46,    47,    36,    15,   251,    50,    41,    42,
+    43,    15,    50,     7,     4,    36,   243,    24,    15,   264,
+    15,    50,    50,    15,   251,   270,   271,    50,    24,    15,
+    15,    50,    50,     0,     0,   164,   188,   264,    10,    32,
+   260,   268,   269,   169,     1,   272,     3,    -1,    -1,   225,
+    -1,     8,    -1,    10,    11,    12,    13,    -1,    -1,    16,
+    17,    -1,    -1,    -1,    21,    22,    -1,    24,    25,    26,
+    27,    -1,    -1,    -1,    -1,    32,    33,    34,    35,    -1,
+    37,    38,    39,    40,    -1,    -1,    43,    44,     3,    46,
+    47,    -1,    49,     8,    51,    10,    11,    12,    13,    -1,
+    -1,    16,    17,    -1,    -1,    -1,    21,    22,    -1,    24,
+    25,    26,    27,    -1,    -1,    -1,    -1,    32,    33,    34,
+    35,    -1,    37,    38,    39,    40,    -1,    -1,    43,    -1,
+     3,    46,    47,    -1,    49,     8,    51,    10,    11,    12,
+    13,    -1,    -1,    16,    17,    -1,    -1,    -1,    21,    22,
+    -1,    24,    25,    26,    27,    -1,    -1,    -1,    -1,    32,
+    33,    34,    35,    -1,    37,    38,    39,    40,    -1,    -1,
+    -1,    -1,     3,    46,    47,    -1,    49,     8,    51,    10,
+    11,    12,    13,    -1,    -1,    16,    17,    -1,    -1,    -1,
+    -1,    22,    -1,    24,    25,    26,    27,    -1,    -1,    -1,
+    -1,    32,    33,    34,    35,    -1,    37,    38,    39,    40,
+    -1,    -1,    -1,    -1,     3,    46,    47,    -1,    49,     8,
+    51,    10,    11,    12,    13,    -1,    -1,    16,    17,    -1,
+    -1,    -1,    21,    -1,    -1,    24,    25,    26,    27,    -1,
+    -1,    -1,    -1,    32,    33,    34,    35,    -1,    37,    38,
+    39,    40,    -1,    -1,    -1,    -1,     3,    46,    47,    -1,
+    49,     8,    51,    10,    11,    12,    13,    -1,    -1,    16,
+    17,    -1,    -1,    -1,    -1,    -1,    -1,    24,    25,    26,
+    27,    -1,    -1,    -1,    -1,    32,    33,    34,    35,    -1,
+    37,    38,    39,    40,    -1,    -1,    43,    -1,     3,    46,
+    47,    -1,    49,     8,    51,    10,    11,    12,    13,    -1,
+    -1,    16,    17,    -1,    -1,    -1,    -1,    -1,    -1,    24,
+    25,    26,    27,    -1,    -1,    -1,    -1,    32,    33,    34,
+    35,    -1,    37,    38,    39,    40,    -1,    -1,    -1,    -1,
+    -1,    46,    47,    -1,    49,    -1,    51,    24,    25,    26,
+    -1,    -1,    -1,    -1,    -1,    32,    33,    34,    35,    -1,
+    37,    38,    39,    40,    -1,    26,    -1,    -1,    -1,    46,
+    47,    32,    33,    34,    35,    -1,    37,    38,    39,    40,
+    -1,    -1,    -1,    -1,    -1,    46,    47
 };
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/usr/share/bison/bison.simple"
+/* This file comes from bison-1.28.  */
+
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
+#ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#else /* not GNU C.  */
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
+#include <alloca.h>
+#else /* not sparc */
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
+#include <malloc.h>
+#endif
+#else /* not MSDOS, or __TURBOC__ */
+#if defined(_AIX)
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
+ #pragma alloca
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#endif /* __hpux */
+#endif
+#endif /* not _AIX */
+#endif /* not MSDOS, or __TURBOC__ */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
+
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
+#else
+#define YYSTACK_ALLOC malloc
 #endif
-#if YYDEBUG
-#include <stdio.h>
-#endif
-#ifdef YYSTACKSIZE
-#undef YYMAXDEPTH
-#define YYMAXDEPTH YYSTACKSIZE
+
+/* Note: there must be only one dollar sign in this file.
+   It is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(token, value) \
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    { yychar = (token), yylval = (value);			\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+#ifndef YYPURE
+#define YYLEX		yylex()
+#endif
+
+#ifdef YYPURE
+#ifdef YYLSP_NEEDED
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
 #else
-#ifdef YYMAXDEPTH
-#define YYSTACKSIZE YYMAXDEPTH
+#define YYLEX		yylex(&yylval, &yylloc)
+#endif
+#else /* not YYLSP_NEEDED */
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, YYLEX_PARAM)
 #else
-#define YYSTACKSIZE 10000
-#define YYMAXDEPTH 10000
+#define YYLEX		yylex(&yylval)
 #endif
+#endif /* not YYLSP_NEEDED */
 #endif
-#define YYINITSTACKSIZE 200
-int yydebug;
-int yynerrs;
-int yyerrflag;
-int yychar;
-short *yyssp;
-YYSTYPE *yyvsp;
-YYSTYPE yyval;
-YYSTYPE yylval;
-short *yyss;
-short *yysslim;
-YYSTYPE *yyvs;
-int yystacksize;
-#line 815 "/usr/homes/chet/src/bash/src/parse.y"
 
-/* Possible states for the parser that require it to do special things. */
-#define PST_CASEPAT	0x001		/* in a case pattern list */
-#define PST_ALEXPNEXT	0x002		/* expand next word for aliases */
-#define PST_ALLOWOPNBRC	0x004		/* allow open brace for function def */
-#define PST_NEEDCLOSBRC	0x008		/* need close brace */
-#define PST_DBLPAREN	0x010		/* double-paren parsing */
-#define PST_SUBSHELL	0x020		/* ( ... ) subshell */
-#define PST_CMDSUBST	0x040		/* $( ... ) command substitution */
-#define PST_CASESTMT	0x080		/* parsing a case statement */
-#define PST_CONDCMD	0x100		/* parsing a [[...]] command */
-#define PST_CONDEXPR	0x200		/* parsing the guts of [[...]] */
-#define PST_ARITHFOR	0x400		/* parsing an arithmetic for command */
+/* If nonreentrant, generate the variables here */
 
-/* Initial size to allocate for tokens, and the
-   amount to grow them by. */
-#define TOKEN_DEFAULT_INITIAL_SIZE 496
-#define TOKEN_DEFAULT_GROW_SIZE 512
+#ifndef YYPURE
 
-/* The token currently being read. */
-static int current_token;
+int	yychar;			/*  the lookahead symbol		*/
+YYSTYPE	yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
 
-/* The last read token, or NULL.  read_token () uses this for context
-   checking. */
-static int last_read_token;
+#ifdef YYLSP_NEEDED
+YYLTYPE yylloc;			/*  location data for the lookahead	*/
+				/*  symbol				*/
+#endif
 
-/* The token read prior to last_read_token. */
-static int token_before_that;
+int yynerrs;			/*  number of parse errors so far       */
+#endif  /* not YYPURE */
 
-/* The token read prior to token_before_that. */
-static int two_tokens_ago;
+#if YYDEBUG != 0
+int yydebug;			/*  nonzero means print parse trace	*/
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
 
-/* If non-zero, it is the token that we want read_token to return
-   regardless of what text is (or isn't) present to be read.  This
-   is reset by read_token.  If token_to_read == WORD or
-   ASSIGNMENT_WORD, yylval.word should be set to word_desc_to_read. */
-static int token_to_read;
-static WORD_DESC *word_desc_to_read;
+/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
 
-/* The current parser state. */
-static int parser_state;
+#ifndef	YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
 
-/* Global var is non-zero when end of file has been reached. */
-int EOF_Reached = 0;
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
 
-void
-debug_parser (i)
-     int i;
-{
-#if YYDEBUG != 0
-  yydebug = i;
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
 #endif
-}
 
-/* yy_getc () returns the next available character from input or EOF.
-   yy_ungetc (c) makes `c' the next character to read.
-   init_yy_io (get, unget, type, location) makes the function GET the
-   installed function for getting the next character, makes UNGET the
-   installed function for un-getting a character, sets the type of stream
-   (either string or file) from TYPE, and makes LOCATION point to where
-   the input is coming from. */
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+/* Define __yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
+#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
+#else				/* not GNU C or C++ */
+#ifndef __cplusplus
 
-/* Unconditionally returns end-of-file. */
-int
-return_EOF ()
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (to, from, count)
+     char *to;
+     char *from;
+     unsigned int count;
 {
-  return (EOF);
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
 }
 
-/* Variable containing the current get and unget functions.
-   See ./input.h for a clearer description. */
-BASH_INPUT bash_input;
+#else /* __cplusplus */
 
-/* Set all of the fields in BASH_INPUT to NULL.  Free bash_input.name if it
-   is non-null, avoiding a memory leak. */
-void
-initialize_bash_input ()
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (char *to, char *from, unsigned int count)
 {
-  bash_input.type = st_none;
-  FREE (bash_input.name);
-  bash_input.name = (char *)NULL;
-  bash_input.location.file = (FILE *)NULL;
-  bash_input.location.string = (char *)NULL;
-  bash_input.getter = (Function *)NULL;
-  bash_input.ungetter = (Function *)NULL;
+  register char *t = to;
+  register char *f = from;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
 }
 
-/* Set the contents of the current bash input stream from
-   GET, UNGET, TYPE, NAME, and LOCATION. */
-void
-init_yy_io (get, unget, type, name, location)
-     Function *get, *unget;
-     enum stream_type type;
-     char *name;
-     INPUT_STREAM location;
-{
-  bash_input.type = type;
-  FREE (bash_input.name);
-  bash_input.name = name ? savestring (name) : (char *)NULL;
+#endif
+#endif
+
+#line 217 "/usr/share/bison/bison.simple"
 
-  /* XXX */
-#if defined (CRAY)
-  memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+#ifdef __cplusplus
+#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else /* not __cplusplus */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+#endif /* not __cplusplus */
+#else /* not YYPARSE_PARAM */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif /* not YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+int yyparse (void *);
 #else
-  bash_input.location = location;
+int yyparse (void);
+#endif
 #endif
-  bash_input.getter = get;
-  bash_input.ungetter = unget;
-}
-
-/* Call this to get the next character of input. */
-int
-yy_getc ()
-{
-  return (*(bash_input.getter)) ();
-}
 
-/* Call this to unget C.  That is, to make C the next character
-   to be read. */
 int
-yy_ungetc (c)
-     int c;
+yyparse(YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
 {
-  return (*(bash_input.ungetter)) (c);
-}
+  register int yystate;
+  register int yyn;
+  register short *yyssp;
+  register YYSTYPE *yyvsp;
+  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
+  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+
+  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
+  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+
+  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
+  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
 
-#if defined (BUFFERED_INPUT)
-int
-input_file_descriptor ()
-{
-  switch (bash_input.type)
-    {
-    case st_stream:
-      return (fileno (bash_input.location.file));
-    case st_bstream:
-      return (bash_input.location.buffered_fd);
-    case st_stdin:
-    default:
-      return (fileno (stdin));
-    }
-}
-#endif /* BUFFERED_INPUT */
+#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
 
-/* **************************************************************** */
-/*								    */
-/*		  Let input be read from readline ().		    */
-/*								    */
-/* **************************************************************** */
+  int yystacksize = YYINITDEPTH;
+  int yyfree_stacks = 0;
 
-#if defined (READLINE)
-char *current_readline_prompt = (char *)NULL;
-char *current_readline_line = (char *)NULL;
-int current_readline_line_index = 0;
+#ifdef YYPURE
+  int yychar;
+  YYSTYPE yylval;
+  int yynerrs;
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylloc;
+#endif
+#endif
 
-static int
-yy_readline_get ()
-{
-  SigHandler *old_sigint;
-  int line_len, c;
+  YYSTYPE yyval;		/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
 
-  if (!current_readline_line)
-    {
-      if (!bash_readline_initialized)
-	initialize_readline ();
+  int yylen;
 
-#if defined (JOB_CONTROL)
-      if (job_control)
-	give_terminal_to (shell_pgrp, 0);
-#endif /* JOB_CONTROL */
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Starting parse\n");
+#endif
 
-      if (signal_is_ignored (SIGINT) == 0)
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss - 1;
+  yyvsp = yyvs;
+#ifdef YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+
+/* Push a new state, which is found in  yystate  .  */
+/* In all cases, when you get here, the value and location stacks
+   have just been pushed. so pushing a state here evens the stacks.  */
+yynewstate:
+
+  *++yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Give user a chance to reallocate the stack */
+      /* Use copies of these so that the &'s don't force the real ones into memory. */
+      YYSTYPE *yyvs1 = yyvs;
+      short *yyss1 = yyss;
+#ifdef YYLSP_NEEDED
+      YYLTYPE *yyls1 = yyls;
+#endif
+
+      /* Get the current used size of the three stacks, in elements.  */
+      int size = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      /* Each stack pointer address is followed by the size of
+	 the data in use in that stack, in bytes.  */
+#ifdef YYLSP_NEEDED
+      /* This used to be a conditional around just the two extra args,
+	 but that might be undefined if yyoverflow is a macro.  */
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yyls1, size * sizeof (*yylsp),
+		 &yystacksize);
+#else
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yystacksize);
+#endif
+
+      yyss = yyss1; yyvs = yyvs1;
+#ifdef YYLSP_NEEDED
+      yyls = yyls1;
+#endif
+#else /* no yyoverflow */
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
 	{
-	  old_sigint = (SigHandler *)set_signal_handler (SIGINT, sigint_sighandler);
-	  interrupt_immediately++;
+	  yyerror("parser stack overflow");
+	  if (yyfree_stacks)
+	    {
+	      free (yyss);
+	      free (yyvs);
+#ifdef YYLSP_NEEDED
+	      free (yyls);
+#endif
+	    }
+	  return 2;
 	}
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+#ifndef YYSTACK_USE_ALLOCA
+      yyfree_stacks = 1;
+#endif
+      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1,
+		   size * (unsigned int) sizeof (*yyssp));
+      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+		   size * (unsigned int) sizeof (*yyvsp));
+#ifdef YYLSP_NEEDED
+      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1,
+		   size * (unsigned int) sizeof (*yylsp));
+#endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + size - 1;
+      yyvsp = yyvs + size - 1;
+#ifdef YYLSP_NEEDED
+      yylsp = yyls + size - 1;
+#endif
 
-      current_readline_line = readline (current_readline_prompt ?
-      					  current_readline_prompt : "");
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
+#endif
 
-      if (signal_is_ignored (SIGINT) == 0)
-	{
-	  interrupt_immediately--;
-	  set_signal_handler (SIGINT, old_sigint);
-	}
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
 
-#if 0
-      /* Reset the prompt to the decoded value of prompt_string_pointer. */
-      reset_readline_prompt ();
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Entering state %d\n", yystate);
 #endif
 
-      if (current_readline_line == 0)
-	return (EOF);
+  goto yybackup;
+ yybackup:
 
-      current_readline_line_index = 0;
-      line_len = strlen (current_readline_line);
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
 
-      current_readline_line = xrealloc (current_readline_line, 2 + line_len);
-      current_readline_line[line_len++] = '\n';
-      current_readline_line[line_len] = '\0';
-    }
+  /* First try to decide what to do without reference to lookahead token.  */
 
-  if (current_readline_line[current_readline_line_index] == 0)
-    {
-      free (current_readline_line);
-      current_readline_line = (char *)NULL;
-      return (yy_readline_get ());
-    }
-  else
-    {
-      c = (unsigned char)current_readline_line[current_readline_line_index++];
-      return (c);
-    }
-}
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
 
-static int
-yy_readline_unget (c)
-     int c;
-{
-  if (current_readline_line_index && current_readline_line)
-    current_readline_line[--current_readline_line_index] = c;
-  return (c);
-}
+  /* Not known => get a lookahead token if don't already have one.  */
 
-void
-with_input_from_stdin ()
-{
-  INPUT_STREAM location;
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
 
-  if (bash_input.type != st_stdin && stream_on_stack (st_stdin) == 0)
+  if (yychar == YYEMPTY)
     {
-      location.string = current_readline_line;
-      init_yy_io (yy_readline_get, yy_readline_unget,
-		  st_stdin, "readline stdin", location);
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Reading a token: ");
+#endif
+      yychar = YYLEX;
     }
-}
-
-#else  /* !READLINE */
-
-void
-with_input_from_stdin ()
-{
-  with_input_from_stream (stdin, "stdin");
-}
-#endif	/* !READLINE */
-
-/* **************************************************************** */
-/*								    */
-/*   Let input come from STRING.  STRING is zero terminated.	    */
-/*								    */
-/* **************************************************************** */
-
-static int
-yy_string_get ()
-{
-  register char *string;
-  register int c;
 
-  string = bash_input.location.string;
-  c = EOF;
+  /* Convert token to internal form (in yychar1) for indexing tables with */
 
-  /* If the string doesn't exist, or is empty, EOF found. */
-  if (string && *string)
+  if (yychar <= 0)		/* This means end of input. */
     {
-      c = *(unsigned char *)string++;
-      bash_input.location.string = string;
-    }
-  return (c);
-}
-
-static int
-yy_string_unget (c)
-     int c;
-{
-  *(--bash_input.location.string) = c;
-  return (c);
-}
-
-void
-with_input_from_string (string, name)
-     char *string, *name;
-{
-  INPUT_STREAM location;
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
 
-  location.string = string;
-  init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
-}
-
-/* **************************************************************** */
-/*								    */
-/*		     Let input come from STREAM.		    */
-/*								    */
-/* **************************************************************** */
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Now at end of input.\n");
+#endif
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE(yychar);
 
-/* These two functions used to test the value of the HAVE_RESTARTABLE_SYSCALLS
-   define, and just use getc/ungetc if it was defined, but since bash
-   installs its signal handlers without the SA_RESTART flag, some signals
-   (like SIGCHLD, SIGWINCH, etc.) received during a read(2) will not cause
-   the read to be restarted.  We need to restart it ourselves. */
+#if YYDEBUG != 0
+      if (yydebug)
+	{
+	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise meaning
+	     of a token, for further debugging info.  */
+#ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+#endif
+	  fprintf (stderr, ")\n");
+	}
+#endif
+    }
 
-static int
-yy_stream_get ()
-{
-  int result;
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
 
-  result = EOF;
-  if (bash_input.location.file)
-    result = getc_with_restart (bash_input.location.file);
+  yyn = yytable[yyn];
 
-  return (result);
-}
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
 
-static int
-yy_stream_unget (c)
-     int c;
-{
-  return (ungetc_with_restart (c, bash_input.location.file));
-}
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
 
-void
-with_input_from_stream (stream, name)
-     FILE *stream;
-     char *name;
-{
-  INPUT_STREAM location;
+  if (yyn == YYFINAL)
+    YYACCEPT;
 
-  location.file = stream;
-  init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
-}
+  /* Shift the lookahead token.  */
 
-typedef struct stream_saver {
-  struct stream_saver *next;
-  BASH_INPUT bash_input;
-  int line;
-#if defined (BUFFERED_INPUT)
-  BUFFERED_STREAM *bstream;
-#endif /* BUFFERED_INPUT */
-} STREAM_SAVER;
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
+#endif
 
-/* The globally known line number. */
-int line_number = 0;
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
 
-#if defined (COND_COMMAND)
-static int cond_lineno;
-static int cond_token;
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
 #endif
 
-STREAM_SAVER *stream_list = (STREAM_SAVER *)NULL;
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (yyerrstatus) yyerrstatus--;
 
-void
-push_stream (reset_lineno)
-     int reset_lineno;
-{
-  STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));
+  yystate = yyn;
+  goto yynewstate;
 
-  xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));
+/* Do the default action for the current state.  */
+yydefault:
 
-#if defined (BUFFERED_INPUT)
-  saver->bstream = (BUFFERED_STREAM *)NULL;
-  /* If we have a buffered stream, clear out buffers[fd]. */
-  if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
-    saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
-    					  (BUFFERED_STREAM *)NULL);
-#endif /* BUFFERED_INPUT */
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
 
-  saver->line = line_number;
-  bash_input.name = (char *)NULL;
-  saver->next = stream_list;
-  stream_list = saver;
-  EOF_Reached = 0;
-  if (reset_lineno)
-    line_number = 0;
-}
+/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+yyreduce:
+  yylen = yyr2[yyn];
+  if (yylen > 0)
+    yyval = yyvsp[1-yylen]; /* implement default value of the action */
 
-void
-pop_stream ()
-{
-  if (!stream_list)
-    EOF_Reached = 1;
-  else
+#if YYDEBUG != 0
+  if (yydebug)
     {
-      STREAM_SAVER *saver = stream_list;
-
-      EOF_Reached = 0;
-      stream_list = stream_list->next;
-
-      init_yy_io (saver->bash_input.getter,
-		  saver->bash_input.ungetter,
-		  saver->bash_input.type,
-		  saver->bash_input.name,
-		  saver->bash_input.location);
-
-#if defined (BUFFERED_INPUT)
-      /* If we have a buffered stream, restore buffers[fd]. */
-      /* If the input file descriptor was changed while this was on the
-	 save stack, update the buffered fd to the new file descriptor and
-	 re-establish the buffer <-> bash_input fd correspondence. */
-      if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
-	{
-	  if (bash_input_fd_changed)
-	    {
-	      bash_input_fd_changed = 0;
-	      if (default_buffered_input >= 0)
-		{
-		  bash_input.location.buffered_fd = default_buffered_input;
-		  saver->bstream->b_fd = default_buffered_input;
-		  SET_CLOSE_ON_EXEC (default_buffered_input);
-		}
-	    }
-	  /* XXX could free buffered stream returned as result here. */
-	  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);
-	}
-#endif /* BUFFERED_INPUT */
+      int i;
 
-      line_number = saver->line;
+      fprintf (stderr, "Reducing via rule %d (line %d), ",
+	       yyn, yyrline[yyn]);
 
-      FREE (saver->bash_input.name);
-      free (saver);
+      /* Print the symbols being reduced, and their result.  */
+      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
+	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
+      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
     }
-}
+#endif
 
-/* Return 1 if a stream of type TYPE is saved on the stack. */
-int
-stream_on_stack (type)
-     enum stream_type type;
-{
-  register STREAM_SAVER *s;
 
-  for (s = stream_list; s; s = s->next)
-    if (s->bash_input.type == type)
-      return 1;
-  return 0;
-}
+  switch (yyn) {
 
-/* Save the current token state and return it in a malloced array. */
-int *
-save_token_state ()
+case 1:
+#line 274 "./parse.y"
 {
-  int *ret;
-
-  ret = (int *)xmalloc (3 * sizeof (int));
-  ret[0] = last_read_token;
-  ret[1] = token_before_that;
-  ret[2] = two_tokens_ago;
-  return ret;
-}
-
-void
-restore_token_state (ts)
-     int *ts;
+			  /* Case of regular command.  Discard the error
+			     safety net,and return the command just parsed. */
+			  global_command = yyvsp[-1].command;
+			  eof_encountered = 0;
+			  discard_parser_constructs (0);
+			  YYACCEPT;
+			;
+    break;}
+case 2:
+#line 283 "./parse.y"
 {
-  if (ts == 0)
-    return;
-  last_read_token = ts[0];
-  token_before_that = ts[1];
-  two_tokens_ago = ts[2];
-}
-
-/*
- * This is used to inhibit alias expansion and reserved word recognition
- * inside case statement pattern lists.  A `case statement pattern list' is:
- *
- *	everything between the `in' in a `case word in' and the next ')'
- *	or `esac'
- *	everything between a `;;' and the next `)' or `esac'
- */
-
-#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
-
-#if !defined (ALIAS)
-typedef void *alias_t;
-#endif
-
-#define END_OF_ALIAS 0
-
-/*
- * Pseudo-global variables used in implementing token-wise alias expansion.
- */
-
-/*
- * Pushing and popping strings.  This works together with shell_getc to
- * implement alias expansion on a per-token basis.
- */
-
-typedef struct string_saver {
-  struct string_saver *next;
-  int expand_alias;  /* Value to set expand_alias to when string is popped. */
-  char *saved_line;
-#if defined (ALIAS)
-  alias_t *expander;   /* alias that caused this line to be pushed. */
-#endif
-  int saved_line_size, saved_line_index, saved_line_terminator;
-} STRING_SAVER;
-
-STRING_SAVER *pushed_string_list = (STRING_SAVER *)NULL;
-
-/*
- * Push the current shell_input_line onto a stack of such lines and make S
- * the current input.  Used when expanding aliases.  EXPAND is used to set
- * the value of expand_next_token when the string is popped, so that the
- * word after the alias in the original line is handled correctly when the
- * alias expands to multiple words.  TOKEN is the token that was expanded
- * into S; it is saved and used to prevent infinite recursive expansion.
- */
-static void
-push_string (s, expand, ap)
-     char *s;
-     int expand;
-     alias_t *ap;
+			  /* Case of regular command, but not a very
+			     interesting one.  Return a NULL command. */
+			  global_command = (COMMAND *)NULL;
+			  YYACCEPT;
+			;
+    break;}
+case 3:
+#line 290 "./parse.y"
 {
-  STRING_SAVER *temp = (STRING_SAVER *) xmalloc (sizeof (STRING_SAVER));
-
-  temp->expand_alias = expand;
-  temp->saved_line = shell_input_line;
-  temp->saved_line_size = shell_input_line_size;
-  temp->saved_line_index = shell_input_line_index;
-  temp->saved_line_terminator = shell_input_line_terminator;
-#if defined (ALIAS)
-  temp->expander = ap;
-#endif
-  temp->next = pushed_string_list;
-  pushed_string_list = temp;
-
-#if defined (ALIAS)
-  if (ap)
-    ap->flags |= AL_BEINGEXPANDED;
-#endif
-
-  shell_input_line = s;
-  shell_input_line_size = strlen (s);
-  shell_input_line_index = 0;
-  shell_input_line_terminator = '\0';
-  parser_state &= ~PST_ALEXPNEXT;
-}
-
-/*
- * Make the top of the pushed_string stack be the current shell input.
- * Only called when there is something on the stack.  Called from shell_getc
- * when it thinks it has consumed the string generated by an alias expansion
- * and needs to return to the original input line.
- */
-static void
-pop_string ()
+			  /* Error during parsing.  Return NULL command. */
+			  global_command = (COMMAND *)NULL;
+			  eof_encountered = 0;
+			  discard_parser_constructs (1);
+			  if (interactive)
+			    {
+			      YYACCEPT;
+			    }
+			  else
+			    {
+			      YYABORT;
+			    }
+			;
+    break;}
+case 4:
+#line 305 "./parse.y"
 {
-  STRING_SAVER *t;
-
-  FREE (shell_input_line);
-  shell_input_line = pushed_string_list->saved_line;
-  shell_input_line_index = pushed_string_list->saved_line_index;
-  shell_input_line_size = pushed_string_list->saved_line_size;
-  shell_input_line_terminator = pushed_string_list->saved_line_terminator;
-
-  if (pushed_string_list->expand_alias)
-    parser_state |= PST_ALEXPNEXT;
-  else
-    parser_state &= ~PST_ALEXPNEXT;
-
-  t = pushed_string_list;
-  pushed_string_list = pushed_string_list->next;
-
-#if defined (ALIAS)
-  if (t->expander)
-    t->expander->flags &= ~AL_BEINGEXPANDED;
-#endif
-
-  free ((char *)t);
-}
-
-static void
-free_string_list ()
+			  /* Case of EOF seen by itself.  Do ignoreeof or
+			     not. */
+			  global_command = (COMMAND *)NULL;
+			  handle_eof_input_unit ();
+			  YYACCEPT;
+			;
+    break;}
+case 5:
+#line 315 "./parse.y"
+{ yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
+    break;}
+case 6:
+#line 317 "./parse.y"
+{ yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-1].word_list); ;
+    break;}
+case 7:
+#line 321 "./parse.y"
 {
-  register STRING_SAVER *t, *t1;
-
-  for (t = pushed_string_list; t; )
-    {
-      t1 = t->next;
-      FREE (t->saved_line);
-#if defined (ALIAS)
-      if (t->expander)
-	t->expander->flags &= ~AL_BEINGEXPANDED;
-#endif
-      free ((char *)t);
-      t = t1;
-    }
-  pushed_string_list = (STRING_SAVER *)NULL;
-}
-
-#endif /* ALIAS || DPAREN_ARITHMETIC */
-
-/* Return a line of text, taken from wherever yylex () reads input.
-   If there is no more input, then we return NULL.  If REMOVE_QUOTED_NEWLINE
-   is non-zero, we remove unquoted \<newline> pairs.  This is used by
-   read_secondary_line to read here documents. */
-static char *
-read_a_line (remove_quoted_newline)
-     int remove_quoted_newline;
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (1, r_output_direction, redir);
+			;
+    break;}
+case 8:
+#line 326 "./parse.y"
 {
-  static char *line_buffer = (char *)NULL;
-  static int buffer_size = 0;
-  int indx = 0, c, peekc, pass_next;
-
-#if defined (READLINE)
-  if (interactive && bash_input.type != st_string && no_line_editing)
-#else
-  if (interactive && bash_input.type != st_string)
-#endif
-    print_prompt ();
-
-  pass_next = 0;
-  while (1)
-    {
-      c = yy_getc ();
-
-      /* Allow immediate exit if interrupted during input. */
-      QUIT;
-
-      /* Ignore null bytes in input. */
-      if (c == 0)
-	{
-#if 0
-	  internal_warning ("read_a_line: ignored null byte in input");
-#endif
-	  continue;
-	}
-
-      /* If there is no more input, then we return NULL. */
-      if (c == EOF)
-	{
-	  if (interactive && bash_input.type == st_stream)
-	    clearerr (stdin);
-	  if (indx == 0)
-	    return ((char *)NULL);
-	  c = '\n';
-	}
-
-      /* `+2' in case the final character in the buffer is a newline. */
-      RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);
-
-      /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
-	 here document with an unquoted delimiter.  In this case,
-	 the line will be expanded as if it were in double quotes.
-	 We allow a backslash to escape the next character, but we
-	 need to treat the backslash specially only if a backslash
-	 quoting a backslash-newline pair appears in the line. */
-      if (pass_next)
-	{
-	  line_buffer[indx++] = c;
-	  pass_next = 0;
-	}
-      else if (c == '\\' && remove_quoted_newline)
-	{
-	  peekc = yy_getc ();
-	  if (peekc == '\n')
-	    continue;	/* Make the unquoted \<newline> pair disappear. */
-	  else
-	    {
-	      yy_ungetc (peekc);
-	      pass_next = 1;
-	      line_buffer[indx++] = c;		/* Preserve the backslash. */
-	    }
-	}
-      else
-	line_buffer[indx++] = c;
-
-      if (c == '\n')
-	{
-	  line_buffer[indx] = '\0';
-	  return (line_buffer);
-	}
-    }
-}
-
-/* Return a line as in read_a_line (), but insure that the prompt is
-   the secondary prompt.  This is used to read the lines of a here
-   document.  REMOVE_QUOTED_NEWLINE is non-zero if we should remove
-   newlines quoted with backslashes while reading the line.  It is
-   non-zero unless the delimiter of the here document was quoted. */
-char *
-read_secondary_line (remove_quoted_newline)
-     int remove_quoted_newline;
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (0, r_input_direction, redir);
+			;
+    break;}
+case 9:
+#line 331 "./parse.y"
 {
-  prompt_string_pointer = &ps2_prompt;
-  prompt_again ();
-  return (read_a_line (remove_quoted_newline));
-}
-
-/* **************************************************************** */
-/*								    */
-/*				YYLEX ()			    */
-/*								    */
-/* **************************************************************** */
-
-/* Reserved words.  These are only recognized as the first word of a
-   command. */
-STRING_INT_ALIST word_token_alist[] = {
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_direction, redir);
+			;
+    break;}
+case 10:
+#line 336 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_direction, redir);
+			;
+    break;}
+case 11:
+#line 341 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (1, r_appending_to, redir);
+			;
+    break;}
+case 12:
+#line 346 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_appending_to, redir);
+			;
+    break;}
+case 13:
+#line 351 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (0, r_reading_until, redir);
+			  redir_stack[need_here_doc++] = yyval.redirect;
+			;
+    break;}
+case 14:
+#line 357 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_reading_until, redir);
+			  redir_stack[need_here_doc++] = yyval.redirect;
+			;
+    break;}
+case 15:
+#line 363 "./parse.y"
+{
+			  redir.dest = yyvsp[0].number;
+			  yyval.redirect = make_redirection (0, r_duplicating_input, redir);
+			;
+    break;}
+case 16:
+#line 368 "./parse.y"
+{
+			  redir.dest = yyvsp[0].number;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input, redir);
+			;
+    break;}
+case 17:
+#line 373 "./parse.y"
+{
+			  redir.dest = yyvsp[0].number;
+			  yyval.redirect = make_redirection (1, r_duplicating_output, redir);
+			;
+    break;}
+case 18:
+#line 378 "./parse.y"
+{
+			  redir.dest = yyvsp[0].number;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output, redir);
+			;
+    break;}
+case 19:
+#line 383 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (0, r_duplicating_input_word, redir);
+			;
+    break;}
+case 20:
+#line 388 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input_word, redir);
+			;
+    break;}
+case 21:
+#line 393 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (1, r_duplicating_output_word, redir);
+			;
+    break;}
+case 22:
+#line 398 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output_word, redir);
+			;
+    break;}
+case 23:
+#line 403 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection
+			    (0, r_deblank_reading_until, redir);
+			  redir_stack[need_here_doc++] = yyval.redirect;
+			;
+    break;}
+case 24:
+#line 410 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection
+			    (yyvsp[-2].number, r_deblank_reading_until, redir);
+			  redir_stack[need_here_doc++] = yyval.redirect;
+			;
+    break;}
+case 25:
+#line 417 "./parse.y"
+{
+			  redir.dest = 0L;
+			  yyval.redirect = make_redirection (1, r_close_this, redir);
+			;
+    break;}
+case 26:
+#line 422 "./parse.y"
+{
+			  redir.dest = 0L;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
+			;
+    break;}
+case 27:
+#line 427 "./parse.y"
+{
+			  redir.dest = 0L;
+			  yyval.redirect = make_redirection (0, r_close_this, redir);
+			;
+    break;}
+case 28:
+#line 432 "./parse.y"
+{
+			  redir.dest = 0L;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
+			;
+    break;}
+case 29:
+#line 437 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (1, r_err_and_out, redir);
+			;
+    break;}
+case 30:
+#line 442 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_output, redir);
+			;
+    break;}
+case 31:
+#line 447 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (0, r_input_output, redir);
+			;
+    break;}
+case 32:
+#line 452 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (1, r_output_force, redir);
+			;
+    break;}
+case 33:
+#line 457 "./parse.y"
+{
+			  redir.filename = yyvsp[0].word;
+			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_force, redir);
+			;
+    break;}
+case 34:
+#line 464 "./parse.y"
+{ yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
+    break;}
+case 35:
+#line 466 "./parse.y"
+{ yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; ;
+    break;}
+case 36:
+#line 468 "./parse.y"
+{ yyval.element.redirect = yyvsp[0].redirect; yyval.element.word = 0; ;
+    break;}
+case 37:
+#line 472 "./parse.y"
+{
+			  yyval.redirect = yyvsp[0].redirect;
+			;
+    break;}
+case 38:
+#line 476 "./parse.y"
+{
+			  register REDIRECT *t;
+
+			  for (t = yyvsp[-1].redirect; t->next; t = t->next)
+			    ;
+			  t->next = yyvsp[0].redirect;
+			  yyval.redirect = yyvsp[-1].redirect;
+			;
+    break;}
+case 39:
+#line 487 "./parse.y"
+{ yyval.command = make_simple_command (yyvsp[0].element, (COMMAND *)NULL); ;
+    break;}
+case 40:
+#line 489 "./parse.y"
+{ yyval.command = make_simple_command (yyvsp[0].element, yyvsp[-1].command); ;
+    break;}
+case 41:
+#line 493 "./parse.y"
+{ yyval.command = clean_simple_command (yyvsp[0].command); ;
+    break;}
+case 42:
+#line 495 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 43:
+#line 497 "./parse.y"
+{
+			  COMMAND *tc;
+
+			  tc = yyvsp[-1].command;
+			  if (tc->redirects)
+			    {
+			      register REDIRECT *t;
+			      for (t = tc->redirects; t->next; t = t->next)
+				;
+			      t->next = yyvsp[0].redirect;
+			    }
+			  else
+			    tc->redirects = yyvsp[0].redirect;
+			  yyval.command = yyvsp[-1].command;
+			;
+    break;}
+case 44:
+#line 513 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 45:
+#line 517 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 46:
+#line 519 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 47:
+#line 521 "./parse.y"
+{ yyval.command = make_while_command (yyvsp[-3].command, yyvsp[-1].command); ;
+    break;}
+case 48:
+#line 523 "./parse.y"
+{ yyval.command = make_until_command (yyvsp[-3].command, yyvsp[-1].command); ;
+    break;}
+case 49:
+#line 525 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 50:
+#line 527 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 51:
+#line 529 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 52:
+#line 531 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 53:
+#line 533 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 54:
+#line 535 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 55:
+#line 537 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 56:
+#line 541 "./parse.y"
+{ yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
+    break;}
+case 57:
+#line 543 "./parse.y"
+{ yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command); ;
+    break;}
+case 58:
+#line 545 "./parse.y"
+{ yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
+    break;}
+case 59:
+#line 547 "./parse.y"
+{ yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); ;
+    break;}
+case 60:
+#line 549 "./parse.y"
+{ yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
+    break;}
+case 61:
+#line 551 "./parse.y"
+{ yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); ;
+    break;}
+case 62:
+#line 555 "./parse.y"
+{ yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); ;
+    break;}
+case 63:
+#line 557 "./parse.y"
+{ yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); ;
+    break;}
+case 64:
+#line 559 "./parse.y"
+{ yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); ;
+    break;}
+case 65:
+#line 561 "./parse.y"
+{ yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); ;
+    break;}
+case 66:
+#line 565 "./parse.y"
+{
+			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
+			;
+    break;}
+case 67:
+#line 569 "./parse.y"
+{
+			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command);
+			;
+    break;}
+case 68:
+#line 573 "./parse.y"
+{
+			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
+			;
+    break;}
+case 69:
+#line 577 "./parse.y"
+{
+			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
+			;
+    break;}
+case 70:
+#line 581 "./parse.y"
+{
+			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
+			;
+    break;}
+case 71:
+#line 585 "./parse.y"
+{
+			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
+			;
+    break;}
+case 72:
+#line 591 "./parse.y"
+{ yyval.command = make_case_command (yyvsp[-4].word, (PATTERN_LIST *)NULL); ;
+    break;}
+case 73:
+#line 593 "./parse.y"
+{ yyval.command = make_case_command (yyvsp[-5].word, yyvsp[-2].pattern); ;
+    break;}
+case 74:
+#line 595 "./parse.y"
+{ yyval.command = make_case_command (yyvsp[-4].word, yyvsp[-1].pattern); ;
+    break;}
+case 75:
+#line 599 "./parse.y"
+{ yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
+    break;}
+case 76:
+#line 602 "./parse.y"
+{ yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); ;
+    break;}
+case 77:
+#line 605 "./parse.y"
+{ yyval.command = make_function_def (yyvsp[-2].word, yyvsp[0].command, function_dstart, function_bstart); ;
+    break;}
+case 78:
+#line 610 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 79:
+#line 612 "./parse.y"
+{
+			  COMMAND *tc;
+
+			  tc = yyvsp[-1].command;
+			  /* According to Posix.2 3.9.5, redirections
+			     specified after the body of a function should
+			     be attached to the function and performed when
+			     the function is executed, not as part of the
+			     function definition command. */
+			  /* XXX - I don't think it matters, but we might
+			     want to change this in the future to avoid
+			     problems differentiating between a function
+			     definition with a redirection and a function
+			     definition containing a single command with a
+			     redirection.  The two are semantically equivalent,
+			     though -- the only difference is in how the
+			     command printing code displays the redirections. */
+			  if (tc->redirects)
+			    {
+			      register REDIRECT *t;
+			      for (t = tc->redirects; t->next; t = t->next)
+				;
+			      t->next = yyvsp[0].redirect;
+			    }
+			  else
+			    tc->redirects = yyvsp[0].redirect;
+			  yyval.command = yyvsp[-1].command;
+			;
+    break;}
+case 80:
+#line 643 "./parse.y"
+{
+			  yyval.command = make_subshell_command (yyvsp[-1].command);
+			  yyval.command->flags |= CMD_WANT_SUBSHELL;
+			;
+    break;}
+case 81:
+#line 650 "./parse.y"
+{ yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, (COMMAND *)NULL); ;
+    break;}
+case 82:
+#line 652 "./parse.y"
+{ yyval.command = make_if_command (yyvsp[-5].command, yyvsp[-3].command, yyvsp[-1].command); ;
+    break;}
+case 83:
+#line 654 "./parse.y"
+{ yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[-1].command); ;
+    break;}
+case 84:
+#line 659 "./parse.y"
+{ yyval.command = make_group_command (yyvsp[-1].command); ;
+    break;}
+case 85:
+#line 663 "./parse.y"
+{ yyval.command = make_arith_command (yyvsp[0].word_list); ;
+    break;}
+case 86:
+#line 667 "./parse.y"
+{ yyval.command = yyvsp[-1].command; ;
+    break;}
+case 87:
+#line 671 "./parse.y"
+{ yyval.command = make_if_command (yyvsp[-2].command, yyvsp[0].command, (COMMAND *)NULL); ;
+    break;}
+case 88:
+#line 673 "./parse.y"
+{ yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[0].command); ;
+    break;}
+case 89:
+#line 675 "./parse.y"
+{ yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, yyvsp[0].command); ;
+    break;}
+case 91:
+#line 680 "./parse.y"
+{ yyvsp[0].pattern->next = yyvsp[-1].pattern; yyval.pattern = yyvsp[0].pattern; ;
+    break;}
+case 92:
+#line 684 "./parse.y"
+{ yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
+    break;}
+case 93:
+#line 686 "./parse.y"
+{ yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
+    break;}
+case 94:
+#line 688 "./parse.y"
+{ yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); ;
+    break;}
+case 95:
+#line 690 "./parse.y"
+{ yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); ;
+    break;}
+case 97:
+#line 695 "./parse.y"
+{ yyvsp[-1].pattern->next = yyvsp[-2].pattern; yyval.pattern = yyvsp[-1].pattern; ;
+    break;}
+case 98:
+#line 699 "./parse.y"
+{ yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); ;
+    break;}
+case 99:
+#line 701 "./parse.y"
+{ yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-2].word_list); ;
+    break;}
+case 100:
+#line 710 "./parse.y"
+{
+			  yyval.command = yyvsp[0].command;
+			  if (need_here_doc)
+			    gather_here_documents ();
+			 ;
+    break;}
+case 102:
+#line 719 "./parse.y"
+{
+			  yyval.command = yyvsp[0].command;
+			;
+    break;}
+case 104:
+#line 726 "./parse.y"
+{
+			  if (yyvsp[-2].command->type == cm_connection)
+			    yyval.command = connect_async_list (yyvsp[-2].command, (COMMAND *)NULL, '&');
+			  else
+			    yyval.command = command_connect (yyvsp[-2].command, (COMMAND *)NULL, '&');
+			;
+    break;}
+case 106:
+#line 737 "./parse.y"
+{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
+    break;}
+case 107:
+#line 739 "./parse.y"
+{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
+    break;}
+case 108:
+#line 741 "./parse.y"
+{
+			  if (yyvsp[-3].command->type == cm_connection)
+			    yyval.command = connect_async_list (yyvsp[-3].command, yyvsp[0].command, '&');
+			  else
+			    yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '&');
+			;
+    break;}
+case 109:
+#line 748 "./parse.y"
+{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
+    break;}
+case 110:
+#line 750 "./parse.y"
+{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); ;
+    break;}
+case 111:
+#line 752 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 117:
+#line 771 "./parse.y"
+{
+			  yyval.command = yyvsp[0].command;
+			  if (need_here_doc)
+			    gather_here_documents ();
+			;
+    break;}
+case 118:
+#line 777 "./parse.y"
+{
+			  if (yyvsp[-1].command->type == cm_connection)
+			    yyval.command = connect_async_list (yyvsp[-1].command, (COMMAND *)NULL, '&');
+			  else
+			    yyval.command = command_connect (yyvsp[-1].command, (COMMAND *)NULL, '&');
+			  if (need_here_doc)
+			    gather_here_documents ();
+			;
+    break;}
+case 119:
+#line 786 "./parse.y"
+{
+			  yyval.command = yyvsp[-1].command;
+			  if (need_here_doc)
+			    gather_here_documents ();
+			;
+    break;}
+case 120:
+#line 794 "./parse.y"
+{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); ;
+    break;}
+case 121:
+#line 796 "./parse.y"
+{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); ;
+    break;}
+case 122:
+#line 798 "./parse.y"
+{
+			  if (yyvsp[-2].command->type == cm_connection)
+			    yyval.command = connect_async_list (yyvsp[-2].command, yyvsp[0].command, '&');
+			  else
+			    yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, '&');
+			;
+    break;}
+case 123:
+#line 805 "./parse.y"
+{ yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, ';'); ;
+    break;}
+case 124:
+#line 808 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 125:
+#line 812 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 126:
+#line 814 "./parse.y"
+{
+			  yyvsp[0].command->flags |= CMD_INVERT_RETURN;
+			  yyval.command = yyvsp[0].command;
+			;
+    break;}
+case 127:
+#line 819 "./parse.y"
+{
+			  yyvsp[0].command->flags |= yyvsp[-1].number;
+			  yyval.command = yyvsp[0].command;
+			;
+    break;}
+case 128:
+#line 824 "./parse.y"
+{
+			  yyvsp[0].command->flags |= yyvsp[-2].number|CMD_INVERT_RETURN;
+			  yyval.command = yyvsp[0].command;
+			;
+    break;}
+case 129:
+#line 829 "./parse.y"
+{
+			  yyvsp[0].command->flags |= yyvsp[-1].number|CMD_INVERT_RETURN;
+			  yyval.command = yyvsp[0].command;
+			;
+    break;}
+case 130:
+#line 837 "./parse.y"
+{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '|'); ;
+    break;}
+case 131:
+#line 839 "./parse.y"
+{ yyval.command = yyvsp[0].command; ;
+    break;}
+case 132:
+#line 843 "./parse.y"
+{ yyval.number = CMD_TIME_PIPELINE; ;
+    break;}
+case 133:
+#line 845 "./parse.y"
+{ yyval.number = CMD_TIME_PIPELINE|CMD_TIME_POSIX; ;
+    break;}
+}
+   /* the action file gets copied in in place of this dollarsign */
+#line 543 "/usr/share/bison/bison.simple"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#ifdef YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+
+#ifdef YYLSP_NEEDED
+  yylsp++;
+  if (yylen == 0)
+    {
+      yylsp->first_line = yylloc.first_line;
+      yylsp->first_column = yylloc.first_column;
+      yylsp->last_line = (yylsp-1)->last_line;
+      yylsp->last_column = (yylsp-1)->last_column;
+      yylsp->text = 0;
+    }
+  else
+    {
+      yylsp->last_line = (yylsp+yylen-1)->last_line;
+      yylsp->last_column = (yylsp+yylen-1)->last_column;
+    }
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+yyerrlab:   /* here on detecting error */
+
+  if (! yyerrstatus)
+    /* If not already recovering from an error, report this error.  */
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  int size = 0;
+	  char *msg;
+	  int x, count;
+
+	  count = 0;
+	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
+	  for (x = (yyn < 0 ? -yyn : 0);
+	       x < (sizeof(yytname) / sizeof(char *)); x++)
+	    if (yycheck[x + yyn] == x)
+	      size += strlen(yytname[x]) + 15, count++;
+	  msg = (char *) malloc(size + 15);
+	  if (msg != 0)
+	    {
+	      strcpy(msg, "parse error");
+
+	      if (count < 5)
+		{
+		  count = 0;
+		  for (x = (yyn < 0 ? -yyn : 0);
+		       x < (sizeof(yytname) / sizeof(char *)); x++)
+		    if (yycheck[x + yyn] == x)
+		      {
+			strcat(msg, count == 0 ? ", expecting `" : " or `");
+			strcat(msg, yytname[x]);
+			strcat(msg, "'");
+			count++;
+		      }
+		}
+	      yyerror(msg);
+	      free(msg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exceeded");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror("parse error");
+    }
+
+  goto yyerrlab1;
+yyerrlab1:   /* here on error raised explicitly by an action */
+
+  if (yyerrstatus == 3)
+    {
+      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
+#endif
+
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+yyerrdefault:  /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (yyn) goto yydefault;
+#endif
+
+yyerrpop:   /* pop the current state because it cannot handle the error token */
+
+  if (yyssp == yyss) YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#ifdef YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "Error: state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+yyerrhandle:
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+
+ yyacceptlab:
+  /* YYACCEPT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 0;
+
+ yyabortlab:
+  /* YYABORT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 1;
+}
+#line 847 "./parse.y"
+
+
+/* Possible states for the parser that require it to do special things. */
+#define PST_CASEPAT	0x001		/* in a case pattern list */
+#define PST_ALEXPNEXT	0x002		/* expand next word for aliases */
+#define PST_ALLOWOPNBRC	0x004		/* allow open brace for function def */
+#define PST_NEEDCLOSBRC	0x008		/* need close brace */
+#define PST_DBLPAREN	0x010		/* double-paren parsing */
+#define PST_SUBSHELL	0x020		/* ( ... ) subshell */
+#define PST_CMDSUBST	0x040		/* $( ... ) command substitution */
+#define PST_CASESTMT	0x080		/* parsing a case statement */
+#define PST_CONDCMD	0x100		/* parsing a [[...]] command */
+#define PST_CONDEXPR	0x200		/* parsing the guts of [[...]] */
+#define PST_ARITHFOR	0x400		/* parsing an arithmetic for command */
+
+/* Initial size to allocate for tokens, and the
+   amount to grow them by. */
+#define TOKEN_DEFAULT_INITIAL_SIZE 496
+#define TOKEN_DEFAULT_GROW_SIZE 512
+
+/* The token currently being read. */
+static int current_token;
+
+/* The last read token, or NULL.  read_token () uses this for context
+   checking. */
+static int last_read_token;
+
+/* The token read prior to last_read_token. */
+static int token_before_that;
+
+/* The token read prior to token_before_that. */
+static int two_tokens_ago;
+
+/* If non-zero, it is the token that we want read_token to return
+   regardless of what text is (or isn't) present to be read.  This
+   is reset by read_token.  If token_to_read == WORD or
+   ASSIGNMENT_WORD, yylval.word should be set to word_desc_to_read. */
+static int token_to_read;
+static WORD_DESC *word_desc_to_read;
+
+/* The current parser state. */
+static int parser_state;
+
+/* Global var is non-zero when end of file has been reached. */
+int EOF_Reached = 0;
+
+void
+debug_parser (i)
+     int i;
+{
+#if YYDEBUG != 0
+  yydebug = i;
+#endif
+}
+
+/* yy_getc () returns the next available character from input or EOF.
+   yy_ungetc (c) makes `c' the next character to read.
+   init_yy_io (get, unget, type, location) makes the function GET the
+   installed function for getting the next character, makes UNGET the
+   installed function for un-getting a character, sets the type of stream
+   (either string or file) from TYPE, and makes LOCATION point to where
+   the input is coming from. */
+
+/* Unconditionally returns end-of-file. */
+int
+return_EOF ()
+{
+  return (EOF);
+}
+
+/* Variable containing the current get and unget functions.
+   See ./input.h for a clearer description. */
+BASH_INPUT bash_input;
+
+/* Set all of the fields in BASH_INPUT to NULL.  Free bash_input.name if it
+   is non-null, avoiding a memory leak. */
+void
+initialize_bash_input ()
+{
+  bash_input.type = st_none;
+  FREE (bash_input.name);
+  bash_input.name = (char *)NULL;
+  bash_input.location.file = (FILE *)NULL;
+  bash_input.location.string = (char *)NULL;
+  bash_input.getter = (Function *)NULL;
+  bash_input.ungetter = (Function *)NULL;
+}
+
+/* Set the contents of the current bash input stream from
+   GET, UNGET, TYPE, NAME, and LOCATION. */
+void
+init_yy_io (get, unget, type, name, location)
+     Function *get, *unget;
+     enum stream_type type;
+     char *name;
+     INPUT_STREAM location;
+{
+  bash_input.type = type;
+  FREE (bash_input.name);
+  bash_input.name = name ? savestring (name) : (char *)NULL;
+
+  /* XXX */
+#if defined (CRAY)
+  memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
+#else
+  bash_input.location = location;
+#endif
+  bash_input.getter = get;
+  bash_input.ungetter = unget;
+}
+
+/* Call this to get the next character of input. */
+int
+yy_getc ()
+{
+  return (*(bash_input.getter)) ();
+}
+
+/* Call this to unget C.  That is, to make C the next character
+   to be read. */
+int
+yy_ungetc (c)
+     int c;
+{
+  return (*(bash_input.ungetter)) (c);
+}
+
+#if defined (BUFFERED_INPUT)
+int
+input_file_descriptor ()
+{
+  switch (bash_input.type)
+    {
+    case st_stream:
+      return (fileno (bash_input.location.file));
+    case st_bstream:
+      return (bash_input.location.buffered_fd);
+    case st_stdin:
+    default:
+      return (fileno (stdin));
+    }
+}
+#endif /* BUFFERED_INPUT */
+
+/* **************************************************************** */
+/*								    */
+/*		  Let input be read from readline ().		    */
+/*								    */
+/* **************************************************************** */
+
+#if defined (READLINE)
+char *current_readline_prompt = (char *)NULL;
+char *current_readline_line = (char *)NULL;
+int current_readline_line_index = 0;
+
+static int
+yy_readline_get ()
+{
+  SigHandler *old_sigint;
+  int line_len, c;
+
+  if (!current_readline_line)
+    {
+      if (!bash_readline_initialized)
+	initialize_readline ();
+
+#if defined (JOB_CONTROL)
+      if (job_control)
+	give_terminal_to (shell_pgrp, 0);
+#endif /* JOB_CONTROL */
+
+      if (signal_is_ignored (SIGINT) == 0)
+	{
+	  old_sigint = (SigHandler *)set_signal_handler (SIGINT, sigint_sighandler);
+	  interrupt_immediately++;
+	}
+
+      current_readline_line = readline (current_readline_prompt ?
+      					  current_readline_prompt : "");
+
+      if (signal_is_ignored (SIGINT) == 0)
+	{
+	  interrupt_immediately--;
+	  set_signal_handler (SIGINT, old_sigint);
+	}
+
+#if 0
+      /* Reset the prompt to the decoded value of prompt_string_pointer. */
+      reset_readline_prompt ();
+#endif
+
+      if (current_readline_line == 0)
+	return (EOF);
+
+      current_readline_line_index = 0;
+      line_len = strlen (current_readline_line);
+
+      current_readline_line = xrealloc (current_readline_line, 2 + line_len);
+      current_readline_line[line_len++] = '\n';
+      current_readline_line[line_len] = '\0';
+    }
+
+  if (current_readline_line[current_readline_line_index] == 0)
+    {
+      free (current_readline_line);
+      current_readline_line = (char *)NULL;
+      return (yy_readline_get ());
+    }
+  else
+    {
+      c = (unsigned char)current_readline_line[current_readline_line_index++];
+      return (c);
+    }
+}
+
+static int
+yy_readline_unget (c)
+     int c;
+{
+  if (current_readline_line_index && current_readline_line)
+    current_readline_line[--current_readline_line_index] = c;
+  return (c);
+}
+
+void
+with_input_from_stdin ()
+{
+  INPUT_STREAM location;
+
+  if (bash_input.type != st_stdin && stream_on_stack (st_stdin) == 0)
+    {
+      location.string = current_readline_line;
+      init_yy_io (yy_readline_get, yy_readline_unget,
+		  st_stdin, "readline stdin", location);
+    }
+}
+
+#else  /* !READLINE */
+
+void
+with_input_from_stdin ()
+{
+  with_input_from_stream (stdin, "stdin");
+}
+#endif	/* !READLINE */
+
+/* **************************************************************** */
+/*								    */
+/*   Let input come from STRING.  STRING is zero terminated.	    */
+/*								    */
+/* **************************************************************** */
+
+static int
+yy_string_get ()
+{
+  register char *string;
+  register int c;
+
+  string = bash_input.location.string;
+  c = EOF;
+
+  /* If the string doesn't exist, or is empty, EOF found. */
+  if (string && *string)
+    {
+      c = *(unsigned char *)string++;
+      bash_input.location.string = string;
+    }
+  return (c);
+}
+
+static int
+yy_string_unget (c)
+     int c;
+{
+  *(--bash_input.location.string) = c;
+  return (c);
+}
+
+void
+with_input_from_string (string, name)
+     char *string, *name;
+{
+  INPUT_STREAM location;
+
+  location.string = string;
+  init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
+}
+
+/* **************************************************************** */
+/*								    */
+/*		     Let input come from STREAM.		    */
+/*								    */
+/* **************************************************************** */
+
+/* These two functions used to test the value of the HAVE_RESTARTABLE_SYSCALLS
+   define, and just use getc/ungetc if it was defined, but since bash
+   installs its signal handlers without the SA_RESTART flag, some signals
+   (like SIGCHLD, SIGWINCH, etc.) received during a read(2) will not cause
+   the read to be restarted.  We need to restart it ourselves. */
+
+static int
+yy_stream_get ()
+{
+  int result;
+
+  result = EOF;
+  if (bash_input.location.file)
+    result = getc_with_restart (bash_input.location.file);
+
+  return (result);
+}
+
+static int
+yy_stream_unget (c)
+     int c;
+{
+  return (ungetc_with_restart (c, bash_input.location.file));
+}
+
+void
+with_input_from_stream (stream, name)
+     FILE *stream;
+     char *name;
+{
+  INPUT_STREAM location;
+
+  location.file = stream;
+  init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
+}
+
+typedef struct stream_saver {
+  struct stream_saver *next;
+  BASH_INPUT bash_input;
+  int line;
+#if defined (BUFFERED_INPUT)
+  BUFFERED_STREAM *bstream;
+#endif /* BUFFERED_INPUT */
+} STREAM_SAVER;
+
+/* The globally known line number. */
+int line_number = 0;
+
+#if defined (COND_COMMAND)
+static int cond_lineno;
+static int cond_token;
+#endif
+
+STREAM_SAVER *stream_list = (STREAM_SAVER *)NULL;
+
+void
+push_stream (reset_lineno)
+     int reset_lineno;
+{
+  STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));
+
+  xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));
+
+#if defined (BUFFERED_INPUT)
+  saver->bstream = (BUFFERED_STREAM *)NULL;
+  /* If we have a buffered stream, clear out buffers[fd]. */
+  if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
+    saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
+    					  (BUFFERED_STREAM *)NULL);
+#endif /* BUFFERED_INPUT */
+
+  saver->line = line_number;
+  bash_input.name = (char *)NULL;
+  saver->next = stream_list;
+  stream_list = saver;
+  EOF_Reached = 0;
+  if (reset_lineno)
+    line_number = 0;
+}
+
+void
+pop_stream ()
+{
+  if (!stream_list)
+    EOF_Reached = 1;
+  else
+    {
+      STREAM_SAVER *saver = stream_list;
+
+      EOF_Reached = 0;
+      stream_list = stream_list->next;
+
+      init_yy_io (saver->bash_input.getter,
+		  saver->bash_input.ungetter,
+		  saver->bash_input.type,
+		  saver->bash_input.name,
+		  saver->bash_input.location);
+
+#if defined (BUFFERED_INPUT)
+      /* If we have a buffered stream, restore buffers[fd]. */
+      /* If the input file descriptor was changed while this was on the
+	 save stack, update the buffered fd to the new file descriptor and
+	 re-establish the buffer <-> bash_input fd correspondence. */
+      if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
+	{
+	  if (bash_input_fd_changed)
+	    {
+	      bash_input_fd_changed = 0;
+	      if (default_buffered_input >= 0)
+		{
+		  bash_input.location.buffered_fd = default_buffered_input;
+		  saver->bstream->b_fd = default_buffered_input;
+		  SET_CLOSE_ON_EXEC (default_buffered_input);
+		}
+	    }
+	  /* XXX could free buffered stream returned as result here. */
+	  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);
+	}
+#endif /* BUFFERED_INPUT */
+
+      line_number = saver->line;
+
+      FREE (saver->bash_input.name);
+      free (saver);
+    }
+}
+
+/* Return 1 if a stream of type TYPE is saved on the stack. */
+int
+stream_on_stack (type)
+     enum stream_type type;
+{
+  register STREAM_SAVER *s;
+
+  for (s = stream_list; s; s = s->next)
+    if (s->bash_input.type == type)
+      return 1;
+  return 0;
+}
+
+/* Save the current token state and return it in a malloced array. */
+int *
+save_token_state ()
+{
+  int *ret;
+
+  ret = (int *)xmalloc (3 * sizeof (int));
+  ret[0] = last_read_token;
+  ret[1] = token_before_that;
+  ret[2] = two_tokens_ago;
+  return ret;
+}
+
+void
+restore_token_state (ts)
+     int *ts;
+{
+  if (ts == 0)
+    return;
+  last_read_token = ts[0];
+  token_before_that = ts[1];
+  two_tokens_ago = ts[2];
+}
+
+/*
+ * This is used to inhibit alias expansion and reserved word recognition
+ * inside case statement pattern lists.  A `case statement pattern list' is:
+ *
+ *	everything between the `in' in a `case word in' and the next ')'
+ *	or `esac'
+ *	everything between a `;;' and the next `)' or `esac'
+ */
+
+#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
+
+#if !defined (ALIAS)
+typedef void *alias_t;
+#endif
+
+#define END_OF_ALIAS 0
+
+/*
+ * Pseudo-global variables used in implementing token-wise alias expansion.
+ */
+
+/*
+ * Pushing and popping strings.  This works together with shell_getc to
+ * implement alias expansion on a per-token basis.
+ */
+
+typedef struct string_saver {
+  struct string_saver *next;
+  int expand_alias;  /* Value to set expand_alias to when string is popped. */
+  char *saved_line;
+#if defined (ALIAS)
+  alias_t *expander;   /* alias that caused this line to be pushed. */
+#endif
+  int saved_line_size, saved_line_index, saved_line_terminator;
+} STRING_SAVER;
+
+STRING_SAVER *pushed_string_list = (STRING_SAVER *)NULL;
+
+/*
+ * Push the current shell_input_line onto a stack of such lines and make S
+ * the current input.  Used when expanding aliases.  EXPAND is used to set
+ * the value of expand_next_token when the string is popped, so that the
+ * word after the alias in the original line is handled correctly when the
+ * alias expands to multiple words.  TOKEN is the token that was expanded
+ * into S; it is saved and used to prevent infinite recursive expansion.
+ */
+static void
+push_string (s, expand, ap)
+     char *s;
+     int expand;
+     alias_t *ap;
+{
+  STRING_SAVER *temp = (STRING_SAVER *) xmalloc (sizeof (STRING_SAVER));
+
+  temp->expand_alias = expand;
+  temp->saved_line = shell_input_line;
+  temp->saved_line_size = shell_input_line_size;
+  temp->saved_line_index = shell_input_line_index;
+  temp->saved_line_terminator = shell_input_line_terminator;
+#if defined (ALIAS)
+  temp->expander = ap;
+#endif
+  temp->next = pushed_string_list;
+  pushed_string_list = temp;
+
+#if defined (ALIAS)
+  if (ap)
+    ap->flags |= AL_BEINGEXPANDED;
+#endif
+
+  shell_input_line = s;
+  shell_input_line_size = strlen (s);
+  shell_input_line_index = 0;
+  shell_input_line_terminator = '\0';
+  parser_state &= ~PST_ALEXPNEXT;
+#ifdef HANDLE_MULTIBYTE
+  analyze_shell_input_line();
+#endif
+}
+
+/*
+ * Make the top of the pushed_string stack be the current shell input.
+ * Only called when there is something on the stack.  Called from shell_getc
+ * when it thinks it has consumed the string generated by an alias expansion
+ * and needs to return to the original input line.
+ */
+static void
+pop_string ()
+{
+  STRING_SAVER *t;
+
+  FREE (shell_input_line);
+  shell_input_line = pushed_string_list->saved_line;
+  shell_input_line_index = pushed_string_list->saved_line_index;
+  shell_input_line_size = pushed_string_list->saved_line_size;
+  shell_input_line_terminator = pushed_string_list->saved_line_terminator;
+
+  if (pushed_string_list->expand_alias)
+    parser_state |= PST_ALEXPNEXT;
+  else
+    parser_state &= ~PST_ALEXPNEXT;
+
+  t = pushed_string_list;
+  pushed_string_list = pushed_string_list->next;
+
+#if defined (ALIAS)
+  if (t->expander)
+    t->expander->flags &= ~AL_BEINGEXPANDED;
+#endif
+
+  free ((char *)t);
+#ifdef HANDLE_MULTIBYTE
+  analyze_shell_input_line();
+#endif
+}
+
+static void
+free_string_list ()
+{
+  register STRING_SAVER *t, *t1;
+
+  for (t = pushed_string_list; t; )
+    {
+      t1 = t->next;
+      FREE (t->saved_line);
+#if defined (ALIAS)
+      if (t->expander)
+	t->expander->flags &= ~AL_BEINGEXPANDED;
+#endif
+      free ((char *)t);
+      t = t1;
+    }
+  pushed_string_list = (STRING_SAVER *)NULL;
+}
+
+#endif /* ALIAS || DPAREN_ARITHMETIC */
+
+/* Return a line of text, taken from wherever yylex () reads input.
+   If there is no more input, then we return NULL.  If REMOVE_QUOTED_NEWLINE
+   is non-zero, we remove unquoted \<newline> pairs.  This is used by
+   read_secondary_line to read here documents. */
+static char *
+read_a_line (remove_quoted_newline)
+     int remove_quoted_newline;
+{
+  static char *line_buffer = (char *)NULL;
+  static int buffer_size = 0;
+  int indx = 0, c, peekc, pass_next;
+
+#if defined (READLINE)
+  if (interactive && bash_input.type != st_string && no_line_editing)
+#else
+  if (interactive && bash_input.type != st_string)
+#endif
+    print_prompt ();
+
+  pass_next = 0;
+  while (1)
+    {
+      c = yy_getc ();
+
+      /* Allow immediate exit if interrupted during input. */
+      QUIT;
+
+      /* Ignore null bytes in input. */
+      if (c == 0)
+	{
+#if 0
+	  internal_warning ("read_a_line: ignored null byte in input");
+#endif
+	  continue;
+	}
+
+      /* If there is no more input, then we return NULL. */
+      if (c == EOF)
+	{
+	  if (interactive && bash_input.type == st_stream)
+	    clearerr (stdin);
+	  if (indx == 0)
+	    return ((char *)NULL);
+	  c = '\n';
+	}
+
+      /* `+2' in case the final character in the buffer is a newline. */
+      RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);
+
+      /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
+	 here document with an unquoted delimiter.  In this case,
+	 the line will be expanded as if it were in double quotes.
+	 We allow a backslash to escape the next character, but we
+	 need to treat the backslash specially only if a backslash
+	 quoting a backslash-newline pair appears in the line. */
+      if (pass_next)
+	{
+	  line_buffer[indx++] = c;
+	  pass_next = 0;
+	}
+      else if (c == '\\' && remove_quoted_newline)
+	{
+	  peekc = yy_getc ();
+	  if (peekc == '\n')
+	    continue;	/* Make the unquoted \<newline> pair disappear. */
+	  else
+	    {
+	      yy_ungetc (peekc);
+	      pass_next = 1;
+	      line_buffer[indx++] = c;		/* Preserve the backslash. */
+	    }
+	}
+      else
+	line_buffer[indx++] = c;
+
+      if (c == '\n')
+	{
+	  line_buffer[indx] = '\0';
+	  return (line_buffer);
+	}
+    }
+}
+
+/* Return a line as in read_a_line (), but insure that the prompt is
+   the secondary prompt.  This is used to read the lines of a here
+   document.  REMOVE_QUOTED_NEWLINE is non-zero if we should remove
+   newlines quoted with backslashes while reading the line.  It is
+   non-zero unless the delimiter of the here document was quoted. */
+char *
+read_secondary_line (remove_quoted_newline)
+     int remove_quoted_newline;
+{
+  prompt_string_pointer = &ps2_prompt;
+  prompt_again ();
+  return (read_a_line (remove_quoted_newline));
+}
+
+/* **************************************************************** */
+/*								    */
+/*				YYLEX ()			    */
+/*								    */
+/* **************************************************************** */
+
+/* Reserved words.  These are only recognized as the first word of a
+   command. */
+STRING_INT_ALIST word_token_alist[] = {
   { "if", IF },
   { "then", THEN },
   { "else", ELSE },
@@ -1610,6 +2917,70 @@
 
 #define pop_delimiter(ds)	ds.delimiter_depth--
 
+#ifdef HANDLE_MULTIBYTE
+#define last_shell_getc_is_singlebyte ((shell_input_line_index > 1)? \
+                shell_input_line_property[shell_input_line_index - 1] : 1)
+#else
+#define last_shell_getc_is_singlebyte (1)
+#endif
+
+#ifdef HANDLE_MULTIBYTE
+static char *shell_input_line_property = NULL;
+static void
+analyze_shell_input_line()
+{
+  int i, previ, len;
+  mbstate_t mbs, prevs;
+
+  if (shell_input_line == NULL)
+    return;
+  len = strlen(shell_input_line);
+  if (shell_input_line_property != NULL)
+    free(shell_input_line_property);
+  shell_input_line_property = (char*) xmalloc(len + 1);
+
+  memset(&prevs, 0, sizeof(mbstate_t));
+  for (i = previ = 0 ; i < len ; i++)
+    {
+      size_t mbclen;
+      mbs = prevs;
+
+      if (shell_input_line[i] == EOF)
+        {
+          int j;
+          for (j = i ; j < len ; j++)
+            shell_input_line_property[j] = 1;
+          break;
+        }
+
+      mbclen = mbrlen(shell_input_line + previ, i - previ + 1, &mbs);
+      if (mbclen == (size_t) -1 || mbclen == 1)
+        {
+          /* singlebyte character.  */
+          mbclen = 1;
+          previ = i + 1;
+        }
+      else if (mbclen == (size_t) -2)
+        {
+          /* a part of a multibyte character.  */
+          mbclen = 0;
+        }
+      else if (mbclen > 1)
+        {
+          /* the end of a multibyte character.  */
+          mbclen = 0;
+          previ = i + 1;
+          prevs = mbs;
+        }
+      else
+        {
+          /* Can't reach.  */
+        }
+      shell_input_line_property[i] = mbclen;
+    }
+}
+#endif
+
 /* Return the next shell input character.  This always reads characters
    from shell_input_line; when that line is exhausted, it is time to
    read the next line.  This is called by read_token when the shell is
@@ -1719,6 +3090,9 @@
 
       shell_input_line_index = 0;
       shell_input_line_len = i;		/* == strlen (shell_input_line) */
+#ifdef HANDLE_MULTIBYTE
+      analyze_shell_input_line();
+#endif
 
 #if defined (HISTORY)
       if (remember_on_history && shell_input_line && shell_input_line[0])
@@ -1750,6 +3124,9 @@
 	      /* We have to force the xrealloc below because we don't know
 		 the true allocated size of shell_input_line anymore. */
 	      shell_input_line_size = shell_input_line_len;
+#ifdef HANDLE_MULTIBYTE
+	      analyze_shell_input_line();
+#endif
 	    }
 	}
       /* Try to do something intelligent with blank lines encountered while
@@ -1801,6 +3178,9 @@
 
 	  shell_input_line[shell_input_line_len] = '\n';
 	  shell_input_line[shell_input_line_len + 1] = '\0';
+#ifdef HANDLE_MULTIBYTE
+	  analyze_shell_input_line();
+#endif
 	}
     }
 
@@ -1810,7 +3190,8 @@
     shell_input_line_index++;
 
   if (c == '\\' && remove_quoted_newline &&
-      shell_input_line[shell_input_line_index] == '\n')
+      shell_input_line[shell_input_line_index] == '\n'
+      && last_shell_getc_is_singlebyte)
     {
 	prompt_again ();
 	line_number++;
@@ -2291,7 +3672,8 @@
       return (yacc_EOF);
     }
 
-  if (character == '#' && (!interactive || interactive_comments))
+  if (character == '#' && (!interactive || interactive_comments)
+      && last_shell_getc_is_singlebyte)
     {
       /* A comment.  Discard until EOL or EOF, and then return a newline. */
       discard_until ('\n');
@@ -2314,7 +3696,8 @@
     }
 
   /* Shell meta-characters. */
-  if (shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
+  if (shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0)
+      && last_shell_getc_is_singlebyte)
     {
 #if defined (ALIAS)
       /* Turn off alias tokenization iff this character sequence would
@@ -2417,15 +3800,20 @@
 #endif
 	    }
 	}
-      else if (character == '<' && peek_char == '&')
+      else if (character == '<' && peek_char == '&'
+	       && last_shell_getc_is_singlebyte)
 	return (LESS_AND);
-      else if (character == '>' && peek_char == '&')
+      else if (character == '>' && peek_char == '&'
+	       && last_shell_getc_is_singlebyte)
 	return (GREATER_AND);
-      else if (character == '<' && peek_char == '>')
+      else if (character == '<' && peek_char == '>'
+	       && last_shell_getc_is_singlebyte)
 	return (LESS_GREATER);
-      else if (character == '>' && peek_char == '|')
+      else if (character == '>' && peek_char == '|'
+	       && last_shell_getc_is_singlebyte)
 	return (GREATER_BAR);
-      else if (peek_char == '>' && character == '&')
+      else if (peek_char == '>' && character == '&'
+	       && last_shell_getc_is_singlebyte)
 	return (AND_GREATER);
 
       shell_ungetc (peek_char);
@@ -2433,7 +3821,8 @@
       /* If we look like we are reading the start of a function
 	 definition, then let the reader know about it so that
 	 we will do the right thing with `{'. */
-      if (character == ')' && last_read_token == '(' && token_before_that == WORD)
+      if (character == ')' && last_read_token == '(' && token_before_that == WORD
+	  && last_shell_getc_is_singlebyte)
 	{
 	  parser_state |= PST_ALLOWOPNBRC;
 #if defined (ALIAS)
@@ -2445,26 +3834,31 @@
       /* case pattern lists may be preceded by an optional left paren.  If
 	 we're not trying to parse a case pattern list, the left paren
 	 indicates a subshell. */
-      if (character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
+      if (character == '(' && (parser_state & PST_CASEPAT) == 0 /* ) */
+	  && last_shell_getc_is_singlebyte)
 	parser_state |= PST_SUBSHELL;
       /*(*/
-      else if ((parser_state & PST_CASEPAT) && character == ')')
+      else if ((parser_state & PST_CASEPAT) && character == ')'
+	       && last_shell_getc_is_singlebyte)
 	parser_state &= ~PST_CASEPAT;
       /*(*/
-      else if ((parser_state & PST_SUBSHELL) && character == ')')
+      else if ((parser_state & PST_SUBSHELL) && character == ')'
+	       && last_shell_getc_is_singlebyte)
 	parser_state &= ~PST_SUBSHELL;
 
 #if defined (PROCESS_SUBSTITUTION)
       /* Check for the constructs which introduce process substitution.
 	 Shells running in `posix mode' don't do process substitution. */
       if (posixly_correct ||
-	  ((character != '>' && character != '<') || peek_char != '('))
+	  (((character != '>' && character != '<') || peek_char != '(')
+	   && last_shell_getc_is_singlebyte))
 #endif /* PROCESS_SUBSTITUTION */
 	return (character);
     }
 
   /* Hack <&- (close stdin) case. */
-  if (character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
+  if (character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND)
+      && last_shell_getc_is_singlebyte)
     return (character);
 
   /* Okay, if we got this far, we have to read a word.  Read one,
@@ -2530,26 +3924,30 @@
 	    }
 
 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
-	  if (ch == CTLESC || ch == CTLNUL)
+	  if ((ch == CTLESC || ch == CTLNUL) && last_shell_getc_is_singlebyte)
 	    ret[retind++] = CTLESC;
 	  ret[retind++] = ch;
 	  continue;
 	}
-      else if (ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+      else if ((ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+	       && last_shell_getc_is_singlebyte)
 	{
 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
 	  ret[retind++] = CTLESC;
 	  ret[retind++] = ch;
 	  continue;
 	}
-      else if (ch == close)		/* ending delimiter */
+      else if (ch == close		/* ending delimiter */
+	       && last_shell_getc_is_singlebyte)
 	count--;
 #if 1
       /* handle nested ${...} specially. */
-      else if (open != close && was_dollar && open == '{' && ch == open) /* } */
+      else if (open != close && was_dollar && open == '{' && ch == open /* } */
+	       && last_shell_getc_is_singlebyte)
 	count++;
 #endif
-      else if (((flags & P_FIRSTCLOSE) == 0) && ch == open)		/* nested begin */
+      else if (((flags & P_FIRSTCLOSE) == 0) && ch == open		/* nested begin */
+	       && last_shell_getc_is_singlebyte)
 	count++;
 
       /* Add this character. */
@@ -2558,21 +3956,21 @@
 
       if (open == '\'')			/* '' inside grouping construct */
 	{
-	  if ((flags & P_ALLOWESC) && ch == '\\')
+	  if ((flags & P_ALLOWESC) && ch == '\\' && last_shell_getc_is_singlebyte)
 	    pass_next_character++;
 	  continue;
 	}
 
-      if (ch == '\\')			/* backslashes */
+      if (ch == '\\' && last_shell_getc_is_singlebyte)			/* backslashes */
 	pass_next_character++;
-
       if (open != close)		/* a grouping construct */
 	{
-	  if (shellquote (ch))
+	  if (shellquote (ch) && last_shell_getc_is_singlebyte)
 	    {
 	      /* '', ``, or "" inside $(...) or other grouping construct. */
 	      push_delimiter (dstack, ch);
-	      if (was_dollar && ch == '\'')	/* $'...' inside group */
+	      if (was_dollar && ch == '\''	/* $'...' inside group */
+		  && last_shell_getc_is_singlebyte)
 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC);
 	      else
 		nestret = parse_matched_pair (ch, ch, ch, &nestlen, 0);
@@ -2582,7 +3980,7 @@
 		  free (ret);
 		  return &matched_pair_error;
 		}
-	      if (was_dollar && ch == '\'')
+	      if (was_dollar && ch == '\'' && last_shell_getc_is_singlebyte)
 		{
 		  /* Translate $'...' here. */
 		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
@@ -2592,7 +3990,7 @@
 		  nestlen = strlen (nestret);
 		  retind -= 2;		/* back up before the $' */
 		}
-	      else if (was_dollar && ch == '"')
+	      else if (was_dollar && ch == '"' && last_shell_getc_is_singlebyte)
 		{
 		  /* Locale expand $"..." here. */
 		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
@@ -2618,7 +4016,7 @@
       /* Parse an old-style command substitution within double quotes as a
 	 single word. */
       /* XXX - sh and ksh93 don't do this - XXX */
-      else if (open == '"' && ch == '`')
+      else if (open == '"' && ch == '`' && last_shell_getc_is_singlebyte)
 	{
 	  nestret = parse_matched_pair (0, '`', '`', &nestlen, 0);
 	  if (nestret == &matched_pair_error)
@@ -2634,7 +4032,8 @@
 	    }
 	  FREE (nestret);
 	}
-      else if (was_dollar && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
+      else if (was_dollar && (ch == '(' || ch == '{' || ch == '[')	/* ) } ] */
+	       && last_shell_getc_is_singlebyte)
 	/* check for $(), $[], or ${} inside quoted string. */
 	{
 	  if (open == ch)	/* undo previous increment */
@@ -2658,7 +4057,7 @@
 	    }
 	  FREE (nestret);
 	}
-      was_dollar = (ch == '$');
+      was_dollar = (ch == '$' && last_shell_getc_is_singlebyte);
     }
 
   ret[retind] = '\0';
@@ -2688,7 +4087,7 @@
     return -1;
   /* Check that the next character is the closing right paren.  If
      not, this is a syntax error. ( */
-  if ((c = shell_getc (0)) != ')')
+  if ((c = shell_getc (0)) != ')' && last_shell_getc_is_singlebyte)
     rval = 0;
 
   token = xmalloc (ttoklen + 4);
@@ -2943,7 +4342,7 @@
 
       /* Handle backslashes.  Quote lots of things when not inside of
 	 double-quotes, quote some things inside of double-quotes. */
-      if (character == '\\')
+      if (character == '\\' && last_shell_getc_is_singlebyte)
 	{
 	  peek_char = shell_getc (0);
 
@@ -2969,7 +4368,7 @@
 	}
 
       /* Parse a matched pair of quote characters. */
-      if (shellquote (character))
+      if (shellquote (character) && last_shell_getc_is_singlebyte)
 	{
 	  push_delimiter (dstack, character);
 	  ttok = parse_matched_pair (character, character, character, &ttoklen, 0);
@@ -2993,7 +4392,7 @@
       if (extended_glob && PATTERN_CHAR (character))
 	{
 	  peek_char = shell_getc (1);
-	  if (peek_char == '(')		/* ) */
+	  if (peek_char == '(' && last_shell_getc_is_singlebyte)	/* ) */
 	    {
 	      push_delimiter (dstack, peek_char);
 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
@@ -3022,8 +4421,9 @@
 	{
 	  peek_char = shell_getc (1);
 	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
-	  if (peek_char == '(' ||
+	  if ((peek_char == '(' ||
 		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
+	      && last_shell_getc_is_singlebyte)
 	    {
 	      if (peek_char == '{')		/* } */
 		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE);
@@ -3055,7 +4455,8 @@
 	      goto next_character;
 	    }
 	  /* This handles $'...' and $"..." new-style quoted strings. */
-	  else if (character == '$' && (peek_char == '\'' || peek_char == '"'))
+	  else if (character == '$' && (peek_char == '\'' || peek_char == '"')
+		   && last_shell_getc_is_singlebyte)
 	    {
 	      int first_line;
 
@@ -3107,7 +4508,8 @@
 	    }
 	  /* This could eventually be extended to recognize all of the
 	     shell's single-character parameter expansions, and set flags.*/
-	  else if (character == '$' && peek_char == '$')
+	  else if (character == '$' && peek_char == '$'
+		   && last_shell_getc_is_singlebyte)
 	    {
 	      ttok = xmalloc (3);
 	      ttok[0] = ttok[1] = '$';
@@ -3128,10 +4530,11 @@
 
 #if defined (ARRAY_VARS)
       /* Identify possible compound array variable assignment. */
-      else if (character == '=' && token_index > 0)
+      else if (character == '=' && token_index > 0
+	       && last_shell_getc_is_singlebyte)
 	{
 	  peek_char = shell_getc (1);
-	  if (peek_char == '(')		/* ) */
+	  if (peek_char == '(' && last_shell_getc_is_singlebyte)	/* ) */
 	    {
 	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
 	      if (ttok == &matched_pair_error)
@@ -3153,2020 +4556,1046 @@
 	      goto next_character;
 	    }
 	  else
-	    shell_ungetc (peek_char);
-	}
-#endif
-
-      /* When not parsing a multi-character word construct, shell meta-
-	 characters break words. */
-      if (shellbreak (character))
-	{
-	  shell_ungetc (character);
-	  goto got_token;
-	}
-
-    got_character:
-
-      all_digits &= isdigit (character);
-      dollar_present |= character == '$';
-
-      if (character == CTLESC || character == CTLNUL)
-	token[token_index++] = CTLESC;
-
-      token[token_index++] = character;
-
-      RESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,
-			      TOKEN_DEFAULT_GROW_SIZE);
-
-    next_character:
-      if (character == '\n' && interactive &&
-	(bash_input.type == st_stdin || bash_input.type == st_stream))
-	prompt_again ();
-
-      /* We want to remove quoted newlines (that is, a \<newline> pair)
-	 unless we are within single quotes or pass_next_character is
-	 set (the shell equivalent of literal-next). */
-      cd = current_delimiter (dstack);
-      character = shell_getc (cd != '\'' && pass_next_character == 0);
-    }	/* end for (;;) */
-
-got_token:
-
-  token[token_index] = '\0';
-
-  /* Check to see what thing we should return.  If the last_read_token
-     is a `<', or a `&', or the character which ended this token is
-     a '>' or '<', then, and ONLY then, is this input token a NUMBER.
-     Otherwise, it is just a word, and should be returned as such. */
-  if (all_digits && (character == '<' || character == '>' ||
-		    last_read_token == LESS_AND ||
-		    last_read_token == GREATER_AND))
-      {
-	yylval.number = atoi (token);
-	return (NUMBER);
-      }
-
-  /* Check for special case tokens. */
-  result = special_case_tokens (token);
-  if (result >= 0)
-    return result;
-
-#if defined (ALIAS)
-  /* Posix.2 does not allow reserved words to be aliased, so check for all
-     of them, including special cases, before expanding the current token
-     as an alias. */
-  if (posixly_correct)
-    CHECK_FOR_RESERVED_WORD (token);
-
-  /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
-     inhibits alias expansion. */
-  if (expand_aliases && quoted == 0)
-    {
-      result = alias_expand_token (token);
-      if (result == RE_READ_TOKEN)
-	return (RE_READ_TOKEN);
-      else if (result == NO_EXPANSION)
-	parser_state &= ~PST_ALEXPNEXT;
-    }
-
-  /* If not in Posix.2 mode, check for reserved words after alias
-     expansion. */
-  if (posixly_correct == 0)
-#endif
-    CHECK_FOR_RESERVED_WORD (token);
-
-  the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
-  the_word->word = xmalloc (1 + token_index);
-  the_word->flags = 0;
-  strcpy (the_word->word, token);
-  if (dollar_present)
-    the_word->flags |= W_HASDOLLAR;
-  if (quoted)
-    the_word->flags |= W_QUOTED;
-  /* A word is an assignment if it appears at the beginning of a
-     simple command, or after another assignment word.  This is
-     context-dependent, so it cannot be handled in the grammar. */
-  if (assignment (token))
-    {
-      the_word->flags |= W_ASSIGNMENT;
-      /* Don't perform word splitting on assignment statements. */
-      if (assignment_acceptable (last_read_token))
-	the_word->flags |= W_NOSPLIT;
-    }
-
-  yylval.word = the_word;
-
-  result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
-		? ASSIGNMENT_WORD : WORD;
-
-  if (last_read_token == FUNCTION)
-    {
-      parser_state |= PST_ALLOWOPNBRC;
-      function_dstart = line_number;
-    }
-
-  return (result);
-}
-
-/* $'...' ANSI-C expand the portion of STRING between START and END and
-   return the result.  The result cannot be longer than the input string. */
-static char *
-ansiexpand (string, start, end, lenp)
-     char *string;
-     int start, end, *lenp;
-{
-  char *temp, *t;
-  int len, tlen;
-
-  temp = xmalloc (end - start + 1);
-  for (tlen = 0, len = start; len < end; )
-    temp[tlen++] = string[len++];
-  temp[tlen] = '\0';
-
-  if (*temp)
-    {
-      t = ansicstr (temp, tlen, 0, (int *)NULL, lenp);
-      free (temp);
-      return (t);
-    }
-  else
-    {
-      if (lenp)
-	*lenp = 0;
-      return (temp);
-    }
-}
-
-/* Change a bash string into a string suitable for inclusion in a `po' file.
-   This backslash-escapes `"' and `\' and changes newlines into \\\n"\n". */
-static char *
-mk_msgstr (string, foundnlp)
-     char *string;
-     int *foundnlp;
-{
-  register int c, len;
-  char *result, *r, *s;
-
-  for (len = 0, s = string; s && *s; s++)
-    {
-      len++;
-      if (*s == '"' || *s == '\\')
-	len++;
-      else if (*s == '\n')
-	len += 5;
-    }
-  
-  r = result = xmalloc (len + 3);
-  *r++ = '"';
-
-  for (s = string; s && (c = *s); s++)
-    {
-      if (c == '\n')	/* <NL> -> \n"<NL>" */
-	{
-	  *r++ = '\\';
-	  *r++ = 'n';
-	  *r++ = '"';
-	  *r++ = '\n';
-	  *r++ = '"';
-	  if (foundnlp)
-	    *foundnlp = 1;
-	  continue;
+	    shell_ungetc (peek_char);
 	}
-      if (c == '"' || c == '\\')
-	*r++ = '\\';
-      *r++ = c;
-    }
-
-  *r++ = '"';
-  *r++ = '\0';
-
-  return result;
-}
+#endif
 
-/* $"..." -- Translate the portion of STRING between START and END
-   according to current locale using gettext (if available) and return
-   the result.  The caller will take care of leaving the quotes intact.
-   The string will be left without the leading `$' by the caller.
-   If translation is performed, the translated string will be double-quoted
-   by the caller.  The length of the translated string is returned in LENP,
-   if non-null. */
-static char *
-localeexpand (string, start, end, lineno, lenp)
-     char *string;
-     int start, end, lineno, *lenp;
-{
-  int len, tlen, foundnl;
-  char *temp, *t, *t2;
+      /* When not parsing a multi-character word construct, shell meta-
+	 characters break words. */
+      if (shellbreak (character) && last_shell_getc_is_singlebyte)
+	{
+	  shell_ungetc (character);
+	  goto got_token;
+	}
 
-  temp = xmalloc (end - start + 1);
-  for (tlen = 0, len = start; len < end; )
-    temp[tlen++] = string[len++];
-  temp[tlen] = '\0';
+    got_character:
 
-  /* If we're just dumping translatable strings, don't do anything with the
-     string itself, but if we're dumping in `po' file format, convert it into a form more palatable to gettext(3)
-     and friends by quoting `"' and `\' with backslashes and converting <NL>
-     into `\n"<NL>"'.  If we find a newline in TEMP, we first output a
-     `msgid ""' line and then the translated string; otherwise we output the
-     `msgid' and translated string all on one line. */
-  if (dump_translatable_strings)
-    {
-      if (dump_po_strings)
-	{
-	  foundnl = 0;
-	  t = mk_msgstr (temp, &foundnl);
-	  t2 = foundnl ? "\"\"\n" : "";
+      all_digits &= isdigit (character);
+      dollar_present |= character == '$';
 
-	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
-		  (bash_input.name ? bash_input.name : "stdin"), lineno, t2, t);
-	  free (t);
-	}
-      else
-	printf ("\"%s\"\n", temp);
+      if (character == CTLESC || character == CTLNUL)
+	token[token_index++] = CTLESC;
 
-      if (lenp)
-	*lenp = tlen;
-      return (temp);
-    }
-  else if (*temp)
-    {
-      t = localetrans (temp, tlen, &len);
-      free (temp);
-      if (lenp)
-	*lenp = len;
-      return (t);
-    }
-  else
-    {
-      if (lenp)
-	*lenp = 0;
-      return (temp);
-    }
-}
+      token[token_index++] = character;
 
-/* Return 1 if TOKEN is a token that after being read would allow
-   a reserved word to be seen, else 0. */
-static int
-reserved_word_acceptable (token)
-     int token;
-{
-  if (token == '\n' || token == ';' || token == '(' || token == ')' ||
-      token == '|' || token == '&' || token == '{' ||
-      token == '}' ||			/* XXX */
-      token == AND_AND ||
-      token == BANG ||
-      token == TIME || token == TIMEOPT ||
-      token == DO ||
-      token == ELIF ||
-      token == ELSE ||
-      token == FI ||
-      token == IF ||
-      token == OR_OR ||
-      token == SEMI_SEMI ||
-      token == THEN ||
-      token == UNTIL ||
-      token == WHILE ||
-      token == DONE ||		/* XXX these two are experimental */
-      token == ESAC ||
-      token == 0)
-    return (1);
-  else
-    return (0);
-}
+      RESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,
+			      TOKEN_DEFAULT_GROW_SIZE);
 
-/* Return the index of TOKEN in the alist of reserved words, or -1 if
-   TOKEN is not a shell reserved word. */
-int
-find_reserved_word (token)
-     char *token;
-{
-  int i;
-  for (i = 0; word_token_alist[i].word; i++)
-    if (STREQ (token, word_token_alist[i].word))
-      return i;
-  return -1;
-}
+    next_character:
+      if (character == '\n' && interactive &&
+	(bash_input.type == st_stdin || bash_input.type == st_stream))
+	prompt_again ();
 
-#if 0
-#if defined (READLINE)
-/* Called after each time readline is called.  This insures that whatever
-   the new prompt string is gets propagated to readline's local prompt
-   variable. */
-static void
-reset_readline_prompt ()
-{
-  char *temp_prompt;
+      /* We want to remove quoted newlines (that is, a \<newline> pair)
+	 unless we are within single quotes or pass_next_character is
+	 set (the shell equivalent of literal-next). */
+      cd = current_delimiter (dstack);
+      character = shell_getc (cd != '\'' && pass_next_character == 0);
+    }	/* end for (;;) */
 
-  if (prompt_string_pointer)
-    {
-      temp_prompt = (*prompt_string_pointer)
-			? decode_prompt_string (*prompt_string_pointer)
-			: (char *)NULL;
+got_token:
 
-      if (temp_prompt == 0)
-	{
-	  temp_prompt = xmalloc (1);
-	  temp_prompt[0] = '\0';
-	}
+  token[token_index] = '\0';
 
-      FREE (current_readline_prompt);
-      current_readline_prompt = temp_prompt;
-    }
-}
-#endif /* READLINE */
-#endif /* 0 */
+  /* Check to see what thing we should return.  If the last_read_token
+     is a `<', or a `&', or the character which ended this token is
+     a '>' or '<', then, and ONLY then, is this input token a NUMBER.
+     Otherwise, it is just a word, and should be returned as such. */
+  if (all_digits && (character == '<' || character == '>' ||
+		    last_read_token == LESS_AND ||
+		    last_read_token == GREATER_AND)
+      && last_shell_getc_is_singlebyte)
+      {
+	yylval.number = atoi (token);
+	return (NUMBER);
+      }
 
-#if defined (HISTORY)
-/* A list of tokens which can be followed by newlines, but not by
-   semi-colons.  When concatenating multiple lines of history, the
-   newline separator for such tokens is replaced with a space. */
-static int no_semi_successors[] = {
-  '\n', '{', '(', ')', ';', '&', '|',
-  CASE, DO, ELSE, IF, SEMI_SEMI, THEN, UNTIL, WHILE, AND_AND, OR_OR, IN,
-  0
-};
+  /* Check for special case tokens. */
+  result = (last_shell_getc_is_singlebyte)? special_case_tokens (token) : -1;
+  if (result >= 0)
+    return result;
 
-/* If we are not within a delimited expression, try to be smart
-   about which separators can be semi-colons and which must be
-   newlines.  Returns the string that should be added into the
-   history entry. */
-char *
-history_delimiting_chars ()
-{
-  register int i;
+#if defined (ALIAS)
+  /* Posix.2 does not allow reserved words to be aliased, so check for all
+     of them, including special cases, before expanding the current token
+     as an alias. */
+  if (posixly_correct && last_shell_getc_is_singlebyte)
+    CHECK_FOR_RESERVED_WORD (token);
 
-  if (dstack.delimiter_depth != 0)
-    return ("\n");
-    
-  /* First, handle some special cases. */
-  /*(*/
-  /* If we just read `()', assume it's a function definition, and don't
-     add a semicolon.  If the token before the `)' was not `(', and we're
-     not in the midst of parsing a case statement, assume it's a
-     parenthesized command and add the semicolon. */
-  /*)(*/
-  if (token_before_that == ')')
+  /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
+     inhibits alias expansion. */
+  if (expand_aliases && quoted == 0)
     {
-      if (two_tokens_ago == '(')	/*)*/	/* function def */
-	return " ";
-      /* This does not work for subshells inside case statement
-	 command lists.  It's a suboptimal solution. */
-      else if (parser_state & PST_CASESTMT)	/* case statement pattern */
-	return " ";
-      else	
-	return "; ";				/* (...) subshell */
+      result = alias_expand_token (token);
+      if (result == RE_READ_TOKEN)
+	return (RE_READ_TOKEN);
+      else if (result == NO_EXPANSION)
+	parser_state &= ~PST_ALEXPNEXT;
     }
-  else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
-    return " ";		/* function def using `function name' without `()' */
 
-  else if (token_before_that == WORD && two_tokens_ago == FOR)
+  /* If not in Posix.2 mode, check for reserved words after alias
+     expansion. */
+  if (posixly_correct == 0 && last_shell_getc_is_singlebyte)
+#endif
+    CHECK_FOR_RESERVED_WORD (token);
+
+  the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
+  the_word->word = xmalloc (1 + token_index);
+  the_word->flags = 0;
+  strcpy (the_word->word, token);
+  if (dollar_present)
+    the_word->flags |= W_HASDOLLAR;
+  if (quoted)
+    the_word->flags |= W_QUOTED;
+  /* A word is an assignment if it appears at the beginning of a
+     simple command, or after another assignment word.  This is
+     context-dependent, so it cannot be handled in the grammar. */
+  if (assignment (token))
     {
-      /* Tricky.  `for i\nin ...' should not have a semicolon, but
-	 `for i\ndo ...' should.  We do what we can. */
-      for (i = shell_input_line_index; whitespace(shell_input_line[i]); i++)
-	;
-      if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')
-	return " ";
-      return ";";
+      the_word->flags |= W_ASSIGNMENT;
+      /* Don't perform word splitting on assignment statements. */
+      if (assignment_acceptable (last_read_token))
+	the_word->flags |= W_NOSPLIT;
     }
 
-  for (i = 0; no_semi_successors[i]; i++)
+  yylval.word = the_word;
+
+  result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
+		? ASSIGNMENT_WORD : WORD;
+
+  if (last_read_token == FUNCTION)
     {
-      if (token_before_that == no_semi_successors[i])
-	return (" ");
+      parser_state |= PST_ALLOWOPNBRC;
+      function_dstart = line_number;
     }
 
-  return ("; ");
+  return (result);
 }
-#endif /* HISTORY */
 
-/* Issue a prompt, or prepare to issue a prompt when the next character
-   is read. */
-static void
-prompt_again ()
+/* $'...' ANSI-C expand the portion of STRING between START and END and
+   return the result.  The result cannot be longer than the input string. */
+static char *
+ansiexpand (string, start, end, lenp)
+     char *string;
+     int start, end, *lenp;
 {
-  char *temp_prompt;
-
-  if (!interactive)	/* XXX */
-    return;
-
-  ps1_prompt = get_string_value ("PS1");
-  ps2_prompt = get_string_value ("PS2");
-
-  if (!prompt_string_pointer)
-    prompt_string_pointer = &ps1_prompt;
-
-  temp_prompt = *prompt_string_pointer
-			? decode_prompt_string (*prompt_string_pointer)
-			: (char *)NULL;
-
-  if (temp_prompt == 0)
-    {
-      temp_prompt = xmalloc (1);
-      temp_prompt[0] = '\0';
-    }
+  char *temp, *t;
+  int len, tlen;
 
-  current_prompt_string = *prompt_string_pointer;
-  prompt_string_pointer = &ps2_prompt;
+  temp = xmalloc (end - start + 1);
+  for (tlen = 0, len = start; len < end; )
+    temp[tlen++] = string[len++];
+  temp[tlen] = '\0';
 
-#if defined (READLINE)
-  if (!no_line_editing)
+  if (*temp)
     {
-      FREE (current_readline_prompt);
-      current_readline_prompt = temp_prompt;
+      t = ansicstr (temp, tlen, 0, (int *)NULL, lenp);
+      free (temp);
+      return (t);
     }
   else
-#endif	/* READLINE */
     {
-      FREE (current_decoded_prompt);
-      current_decoded_prompt = temp_prompt;
+      if (lenp)
+	*lenp = 0;
+      return (temp);
     }
 }
 
-int
-get_current_prompt_level ()
-{
-  return ((current_prompt_string && current_prompt_string == ps2_prompt) ? 2 : 1);
-}
-
-void
-set_current_prompt_level (x)
-     int x;
-{
-  prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
-  current_prompt_string = *prompt_string_pointer;
-}
-      
-static void
-print_prompt ()
-{
-  fprintf (stderr, "%s", current_decoded_prompt);
-  fflush (stderr);
-}
-
-/* Return a string which will be printed as a prompt.  The string
-   may contain special characters which are decoded as follows:
-
-	\a	bell (ascii 07)
-	\e	escape (ascii 033)
-	\d	the date in Day Mon Date format
-	\h	the hostname up to the first `.'
-	\H	the hostname
-	\j	the number of active jobs
-	\l	the basename of the shell's tty device name
-	\n	CRLF
-	\s	the name of the shell
-	\t	the time in 24-hour hh:mm:ss format
-	\T	the time in 12-hour hh:mm:ss format
-	\@	the time in 12-hour am/pm format
-	\v	the version of bash (e.g., 2.00)
-	\V	the release of bash, version + patchlevel (e.g., 2.00.0)
-	\w	the current working directory
-	\W	the last element of $PWD
-	\u	your username
-	\#	the command number of this command
-	\!	the history number of this command
-	\$	a $ or a # if you are root
-	\nnn	character code nnn in octal
-	\\	a backslash
-	\[	begin a sequence of non-printing chars
-	\]	end a sequence of non-printing chars
-*/
-#define PROMPT_GROWTH 48
-char *
-decode_prompt_string (string)
+/* Change a bash string into a string suitable for inclusion in a `po' file.
+   This backslash-escapes `"' and `\' and changes newlines into \\\n"\n". */
+static char *
+mk_msgstr (string, foundnlp)
      char *string;
+     int *foundnlp;
 {
-  WORD_LIST *list;
-  char *result, *t;
-  struct dstack save_dstack;
-#if defined (PROMPT_STRING_DECODE)
-  int result_size, result_index;
-  int c, n;
-  char *temp, octal_string[4];
-  time_t the_time;
+  register int c, len;
+  char *result, *r, *s;
 
-  result = xmalloc (result_size = PROMPT_GROWTH);
-  result[result_index = 0] = 0;
-  temp = (char *)NULL;
+  for (len = 0, s = string; s && *s; s++)
+    {
+      len++;
+      if (*s == '"' || *s == '\\')
+	len++;
+      else if (*s == '\n')
+	len += 5;
+    }
+  
+  r = result = xmalloc (len + 3);
+  *r++ = '"';
 
-  while (c = *string++)
+  for (s = string; s && (c = *s); s++)
     {
-      if (posixly_correct && c == '!')
+      if (c == '\n')	/* <NL> -> \n"<NL>" */
 	{
-	  if (*string == '!')
-	    {
-	      temp = savestring ("!");
-	      goto add_string;
-	    }
-	  else
-	    {
-#if !defined (HISTORY)
-		temp = savestring ("1");
-#else /* HISTORY */
-		temp = itos (history_number ());
-#endif /* HISTORY */
-		string--;	/* add_string increments string again. */
-		goto add_string;
-	    }
+	  *r++ = '\\';
+	  *r++ = 'n';
+	  *r++ = '"';
+	  *r++ = '\n';
+	  *r++ = '"';
+	  if (foundnlp)
+	    *foundnlp = 1;
+	  continue;
 	}
-      if (c == '\\')
-	{
-	  c = *string;
-
-	  switch (c)
-	    {
-	    case '0':
-	    case '1':
-	    case '2':
-	    case '3':
-	    case '4':
-	    case '5':
-	    case '6':
-	    case '7':
-	      strncpy (octal_string, string, 3);
-	      octal_string[3] = '\0';
-
-	      n = read_octal (octal_string);
-	      temp = xmalloc (3);
-
-	      if (n == CTLESC || n == CTLNUL)
-		{
-		  temp[0] = CTLESC;
-		  temp[1] = n;
-		  temp[2] = '\0';
-		}
-	      else if (n == -1)
-		{
-		  temp[0] = '\\';
-		  temp[1] = '\0';
-		}
-	      else
-		{
-		  temp[0] = n;
-		  temp[1] = '\0';
-		}
-
-	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
-		string++;
-
-	      c = 0;
-	      goto add_string;
+      if (c == '"' || c == '\\')
+	*r++ = '\\';
+      *r++ = c;
+    }
 
-	    case 't':
-	    case 'd':
-	    case 'T':
-	    case '@':
-	      /* Make the current time/date into a string. */
-	      the_time = time (0);
-	      temp = ctime (&the_time);
+  *r++ = '"';
+  *r++ = '\0';
 
-	      temp = (c != 'd') ? savestring (temp + 11) : savestring (temp);
-	      temp[(c != 'd') ? 8 : 10] = '\0';
+  return result;
+}
 
-	      /* quick and dirty conversion to 12-hour time */
-	      if (c == 'T' || c == '@')
-		{
-		  if (c == '@')
-		    {
-		      temp[5] = 'a';	/* am/pm format */
-		      temp[6] = 'm';
-		      temp[7] = '\0';
-		    }
-		  c = temp[2];
-		  temp[2] = '\0';
-		  n = atoi (temp);
-		  temp[2] = c;
-		  n -= 12;
-		  if (n > 0)
-		    {
-		      temp[0] = (n / 10) + '0';
-		      temp[1] = (n % 10) + '0';
-		    }
-		  if (n >= 0 && temp[5] == 'a')
-		    temp[5] = 'p';
-		}
-	      goto add_string;
+/* $"..." -- Translate the portion of STRING between START and END
+   according to current locale using gettext (if available) and return
+   the result.  The caller will take care of leaving the quotes intact.
+   The string will be left without the leading `$' by the caller.
+   If translation is performed, the translated string will be double-quoted
+   by the caller.  The length of the translated string is returned in LENP,
+   if non-null. */
+static char *
+localeexpand (string, start, end, lineno, lenp)
+     char *string;
+     int start, end, lineno, *lenp;
+{
+  int len, tlen, foundnl;
+  char *temp, *t, *t2;
 
-	    case 'r':
-	      temp = xmalloc (2);
-	      temp[0] = '\r';
-	      temp[1] = '\0';
-	      goto add_string;
+  temp = xmalloc (end - start + 1);
+  for (tlen = 0, len = start; len < end; )
+    temp[tlen++] = string[len++];
+  temp[tlen] = '\0';
 
-	    case 'n':
-	      temp = xmalloc (3);
-	      temp[0] = no_line_editing ? '\n' : '\r';
-	      temp[1] = no_line_editing ? '\0' : '\n';
-	      temp[2] = '\0';
-	      goto add_string;
+  /* If we're just dumping translatable strings, don't do anything with the
+     string itself, but if we're dumping in `po' file format, convert it into a form more palatable to gettext(3)
+     and friends by quoting `"' and `\' with backslashes and converting <NL>
+     into `\n"<NL>"'.  If we find a newline in TEMP, we first output a
+     `msgid ""' line and then the translated string; otherwise we output the
+     `msgid' and translated string all on one line. */
+  if (dump_translatable_strings)
+    {
+      if (dump_po_strings)
+	{
+	  foundnl = 0;
+	  t = mk_msgstr (temp, &foundnl);
+	  t2 = foundnl ? "\"\"\n" : "";
 
-	    case 's':
-	      temp = base_pathname (shell_name);
-	      temp = savestring (temp);
-	      goto add_string;
+	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
+		  (bash_input.name ? bash_input.name : "stdin"), lineno, t2, t);
+	  free (t);
+	}
+      else
+	printf ("\"%s\"\n", temp);
 
-	    case 'v':
-	    case 'V':
-	      temp = xmalloc (8);
-	      if (c == 'v')
-		strcpy (temp, dist_version);
-	      else
-		sprintf (temp, "%s.%d", dist_version, patch_level);
-	      goto add_string;
+      if (lenp)
+	*lenp = tlen;
+      return (temp);
+    }
+  else if (*temp)
+    {
+      t = localetrans (temp, tlen, &len);
+      free (temp);
+      if (lenp)
+	*lenp = len;
+      return (t);
+    }
+  else
+    {
+      if (lenp)
+	*lenp = 0;
+      return (temp);
+    }
+}
 
-	    case 'w':
-	    case 'W':
-	      {
-		/* Use the value of PWD because it is much more efficient. */
-		char t_string[PATH_MAX];
-		int tlen;
+/* Return 1 if TOKEN is a token that after being read would allow
+   a reserved word to be seen, else 0. */
+static int
+reserved_word_acceptable (token)
+     int token;
+{
+  if (token == '\n' || token == ';' || token == '(' || token == ')' ||
+      token == '|' || token == '&' || token == '{' ||
+      token == '}' ||			/* XXX */
+      token == AND_AND ||
+      token == BANG ||
+      token == TIME || token == TIMEOPT ||
+      token == DO ||
+      token == ELIF ||
+      token == ELSE ||
+      token == FI ||
+      token == IF ||
+      token == OR_OR ||
+      token == SEMI_SEMI ||
+      token == THEN ||
+      token == UNTIL ||
+      token == WHILE ||
+      token == DONE ||		/* XXX these two are experimental */
+      token == ESAC ||
+      token == 0)
+    return (1);
+  else
+    return (0);
+}
 
-		temp = get_string_value ("PWD");
+/* Return the index of TOKEN in the alist of reserved words, or -1 if
+   TOKEN is not a shell reserved word. */
+int
+find_reserved_word (token)
+     char *token;
+{
+  int i;
+  for (i = 0; word_token_alist[i].word; i++)
+    if (STREQ (token, word_token_alist[i].word))
+      return i;
+  return -1;
+}
 
-		if (temp == 0)
-		  {
-		    if (getcwd (t_string, sizeof(t_string)) == 0)
-		      {
-			t_string[0] = '.';
-			tlen = 1;
-		      }
-		    else
-		      tlen = strlen (t_string);
-		  }
-		else
-		  {
-		    tlen = sizeof (t_string) - 1;
-		    strncpy (t_string, temp, tlen);
-		  }
-		t_string[tlen] = '\0';
+#if 0
+#if defined (READLINE)
+/* Called after each time readline is called.  This insures that whatever
+   the new prompt string is gets propagated to readline's local prompt
+   variable. */
+static void
+reset_readline_prompt ()
+{
+  char *temp_prompt;
 
-#define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
-#define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
-		if (c == 'W')
-		  {
-		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
-		      {
-			t = strrchr (t_string, '/');
-			if (t)
-			  strcpy (t_string, t + 1);
-		      }
-		  }
-#undef ROOT_PATH
-#undef DOUBLE_SLASH_ROOT
-		else
-		  /* polite_directory_format is guaranteed to return a string
-		     no longer than PATH_MAX - 1 characters. */
-		  strcpy (t_string, polite_directory_format (t_string));
+  if (prompt_string_pointer)
+    {
+      temp_prompt = (*prompt_string_pointer)
+			? decode_prompt_string (*prompt_string_pointer)
+			: (char *)NULL;
 
-		/* If we're going to be expanding the prompt string later,
-		   quote the directory name. */
-		if (promptvars || posixly_correct)
-		  /* Make sure that expand_prompt_string is called with a
-		     second argument of Q_DOUBLE_QUOTE if we use this
-		     function here. */
-		  temp = sh_backslash_quote_for_double_quotes (t_string);
-		else
-		  temp = savestring (t_string);
+      if (temp_prompt == 0)
+	{
+	  temp_prompt = xmalloc (1);
+	  temp_prompt[0] = '\0';
+	}
 
-		goto add_string;
-	      }
+      FREE (current_readline_prompt);
+      current_readline_prompt = temp_prompt;
+    }
+}
+#endif /* READLINE */
+#endif /* 0 */
 
-	    case 'u':
-	      if (current_user.user_name == 0)
-		get_current_user_info ();
-	      temp = savestring (current_user.user_name);
-	      goto add_string;
+#if defined (HISTORY)
+/* A list of tokens which can be followed by newlines, but not by
+   semi-colons.  When concatenating multiple lines of history, the
+   newline separator for such tokens is replaced with a space. */
+static int no_semi_successors[] = {
+  '\n', '{', '(', ')', ';', '&', '|',
+  CASE, DO, ELSE, IF, SEMI_SEMI, THEN, UNTIL, WHILE, AND_AND, OR_OR, IN,
+  0
+};
 
-	    case 'h':
-	    case 'H':
-	      temp = savestring (current_host_name);
-	      if (c == 'h' && (t = (char *)strchr (temp, '.')))
-		*t = '\0';
-	      goto add_string;
+/* If we are not within a delimited expression, try to be smart
+   about which separators can be semi-colons and which must be
+   newlines.  Returns the string that should be added into the
+   history entry. */
+char *
+history_delimiting_chars ()
+{
+  register int i;
+
+  if (dstack.delimiter_depth != 0)
+    return ("\n");
+    
+  /* First, handle some special cases. */
+  /*(*/
+  /* If we just read `()', assume it's a function definition, and don't
+     add a semicolon.  If the token before the `)' was not `(', and we're
+     not in the midst of parsing a case statement, assume it's a
+     parenthesized command and add the semicolon. */
+  /*)(*/
+  if (token_before_that == ')')
+    {
+      if (two_tokens_ago == '(')	/*)*/	/* function def */
+	return " ";
+      /* This does not work for subshells inside case statement
+	 command lists.  It's a suboptimal solution. */
+      else if (parser_state & PST_CASESTMT)	/* case statement pattern */
+	return " ";
+      else	
+	return "; ";				/* (...) subshell */
+    }
+  else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
+    return " ";		/* function def using `function name' without `()' */
+
+  else if (token_before_that == WORD && two_tokens_ago == FOR)
+    {
+      /* Tricky.  `for i\nin ...' should not have a semicolon, but
+	 `for i\ndo ...' should.  We do what we can. */
+      for (i = shell_input_line_index; whitespace(shell_input_line[i]); i++)
+	;
+      if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')
+	return " ";
+      return ";";
+    }
 
-	    case '#':
-	      temp = itos (current_command_number);
-	      goto add_string;
+  for (i = 0; no_semi_successors[i]; i++)
+    {
+      if (token_before_that == no_semi_successors[i])
+	return (" ");
+    }
 
-	    case '!':
-#if !defined (HISTORY)
-	      temp = savestring ("1");
-#else /* HISTORY */
-	      temp = itos (history_number ());
+  return ("; ");
+}
 #endif /* HISTORY */
-	      goto add_string;
 
-	    case '$':
-	      t = temp = xmalloc (3);
-	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
-		*t++ = '\\';
-	      *t++ = current_user.euid == 0 ? '#' : '$';
-	      *t = '\0';
-	      goto add_string;
-
-	    case 'j':
-	      temp = itos (count_all_jobs ());
-	      goto add_string;
-
-	    case 'l':
-#if defined (HAVE_TTYNAME)
-	      temp = (char *)ttyname (fileno (stdin));
-	      t = temp ? base_pathname (temp) : "tty";
-	      temp = savestring (t);
-#else
-	      temp = savestring ("tty");
-#endif /* !HAVE_TTYNAME */
-	      goto add_string;
+/* Issue a prompt, or prepare to issue a prompt when the next character
+   is read. */
+static void
+prompt_again ()
+{
+  char *temp_prompt;
 
-#if defined (READLINE)
-	    case '[':
-	    case ']':
-	      temp = xmalloc (3);
-	      temp[0] = '\001';
-	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
-	      temp[2] = '\0';
-	      goto add_string;
-#endif /* READLINE */
+  if (!interactive)	/* XXX */
+    return;
 
-	    case '\\':
-	      temp = xmalloc (2);
-	      temp[0] = c;
-	      temp[1] = '\0';
-	      goto add_string;
+  ps1_prompt = get_string_value ("PS1");
+  ps2_prompt = get_string_value ("PS2");
 
-	    case 'a':
-	    case 'e':
-	      temp = xmalloc (2);
-	      temp[0] = (c == 'a') ? '\07' : '\033';
-	      temp[1] = '\0';
-	      goto add_string;
+  if (!prompt_string_pointer)
+    prompt_string_pointer = &ps1_prompt;
 
-	    default:
-	      temp = xmalloc (3);
-	      temp[0] = '\\';
-	      temp[1] = c;
-	      temp[2] = '\0';
+  temp_prompt = *prompt_string_pointer
+			? decode_prompt_string (*prompt_string_pointer)
+			: (char *)NULL;
 
-	    add_string:
-	      if (c)
-		string++;
-	      result =
-		sub_append_string (temp, result, &result_index, &result_size);
-	      temp = (char *)NULL; /* Freed in sub_append_string (). */
-	      result[result_index] = '\0';
-	      break;
-	    }
-	}
-      else
-	{
-	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
-	  result[result_index++] = c;
-	  result[result_index] = '\0';
-	}
+  if (temp_prompt == 0)
+    {
+      temp_prompt = xmalloc (1);
+      temp_prompt[0] = '\0';
     }
-#else /* !PROMPT_STRING_DECODE */
-  result = savestring (string);
-#endif /* !PROMPT_STRING_DECODE */
 
-  /* Save the delimiter stack and point `dstack' to temp space so any
-     command substitutions in the prompt string won't result in screwing
-     up the parser's quoting state. */
-  save_dstack = dstack;
-  dstack = temp_dstack;
-  dstack.delimiter_depth = 0;
+  current_prompt_string = *prompt_string_pointer;
+  prompt_string_pointer = &ps2_prompt;
 
-  /* Perform variable and parameter expansion and command substitution on
-     the prompt string. */
-  if (promptvars || posixly_correct)
+#if defined (READLINE)
+  if (!no_line_editing)
     {
-      list = expand_prompt_string (result, Q_DOUBLE_QUOTES);
-      free (result);
-      result = string_list (list);
-      dispose_words (list);
+      FREE (current_readline_prompt);
+      current_readline_prompt = temp_prompt;
     }
   else
+#endif	/* READLINE */
     {
-      t = dequote_string (result);
-      free (result);
-      result = t;
+      FREE (current_decoded_prompt);
+      current_decoded_prompt = temp_prompt;
     }
-
-  dstack = save_dstack;
-
-  return (result);
 }
 
-/* Report a syntax error, and restart the parser.  Call here for fatal
-   errors. */
 int
-yyerror ()
+get_current_prompt_level ()
 {
-  report_syntax_error ((char *)NULL);
-  reset_parser ();
-  return (0);
+  return ((current_prompt_string && current_prompt_string == ps2_prompt) ? 2 : 1);
 }
 
-/* Report a syntax error with line numbers, etc.
-   Call here for recoverable errors.  If you have a message to print,
-   then place it in MESSAGE, otherwise pass NULL and this will figure
-   out an appropriate message for you. */
+void
+set_current_prompt_level (x)
+     int x;
+{
+  prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
+  current_prompt_string = *prompt_string_pointer;
+}
+      
 static void
-report_syntax_error (message)
-     char *message;
+print_prompt ()
 {
-  char *msg, *t;
-  int token_end, i;
-  char msg2[2];
-
-  if (message)
-    {
-      parser_error (line_number, "%s", message);
-      if (interactive && EOF_Reached)
-	EOF_Reached = 0;
-      last_command_exit_value = EX_USAGE;
-      return;
-    }
-
-  /* If the line of input we're reading is not null, try to find the
-     objectionable token. */
-  if (shell_input_line && *shell_input_line)
-    {
-      t = shell_input_line;
-      i = shell_input_line_index;
-      token_end = 0;
-
-      if (i && t[i] == '\0')
-	i--;
-
-      while (i && (whitespace (t[i]) || t[i] == '\n'))
-	i--;
+  fprintf (stderr, "%s", current_decoded_prompt);
+  fflush (stderr);
+}
 
-      if (i)
-	token_end = i + 1;
+/* Return a string which will be printed as a prompt.  The string
+   may contain special characters which are decoded as follows:
 
-      while (i && (member (t[i], " \n\t;|&") == 0))
-	i--;
+	\a	bell (ascii 07)
+	\e	escape (ascii 033)
+	\d	the date in Day Mon Date format
+	\h	the hostname up to the first `.'
+	\H	the hostname
+	\j	the number of active jobs
+	\l	the basename of the shell's tty device name
+	\n	CRLF
+	\s	the name of the shell
+	\t	the time in 24-hour hh:mm:ss format
+	\T	the time in 12-hour hh:mm:ss format
+	\@	the time in 12-hour am/pm format
+	\v	the version of bash (e.g., 2.00)
+	\V	the release of bash, version + patchlevel (e.g., 2.00.0)
+	\w	the current working directory
+	\W	the last element of $PWD
+	\u	your username
+	\#	the command number of this command
+	\!	the history number of this command
+	\$	a $ or a # if you are root
+	\nnn	character code nnn in octal
+	\\	a backslash
+	\[	begin a sequence of non-printing chars
+	\]	end a sequence of non-printing chars
+*/
+#define PROMPT_GROWTH 48
+char *
+decode_prompt_string (string)
+     char *string;
+{
+  WORD_LIST *list;
+  char *result, *t;
+  struct dstack save_dstack;
+#if defined (PROMPT_STRING_DECODE)
+  int result_size, result_index;
+  int c, n;
+  char *temp, octal_string[4];
+  time_t the_time;
 
-      while (i != token_end && (whitespace (t[i]) || t[i] == '\n'))
-	i++;
+  result = xmalloc (result_size = PROMPT_GROWTH);
+  result[result_index = 0] = 0;
+  temp = (char *)NULL;
 
-      /* Print the offending token. */
-      if (token_end || (i == 0 && token_end == 0))
+  while (c = *string++)
+    {
+      if (posixly_correct && c == '!')
 	{
-	  if (token_end)
-	    msg = substring (t, i, token_end);
-	  else	/* one-character token */
+	  if (*string == '!')
 	    {
-	      msg2[0] = t[i];
-	      msg2[1] = '\0';
-	      msg = msg2;
+	      temp = savestring ("!");
+	      goto add_string;
+	    }
+	  else
+	    {
+#if !defined (HISTORY)
+		temp = savestring ("1");
+#else /* HISTORY */
+		temp = itos (history_number ());
+#endif /* HISTORY */
+		string--;	/* add_string increments string again. */
+		goto add_string;
 	    }
-
-	  parser_error (line_number, "syntax error near unexpected token `%s'", msg);
-
-	  if (msg != msg2)
-	    free (msg);
 	}
-
-      /* If not interactive, print the line containing the error. */
-      if (interactive == 0)
+      if (c == '\\')
 	{
-	  msg = savestring (shell_input_line);
-	  token_end = strlen (msg);
-	  while (token_end && msg[token_end - 1] == '\n')
-	    msg[--token_end] = '\0';
-
-	  parser_error (line_number, "`%s'", msg);
-	  free (msg);
-	}
-    }
-  else
-    {
-      msg = EOF_Reached ? "syntax error: unexpected end of file" : "syntax error";
-      parser_error (line_number, "%s", msg);
-      /* When the shell is interactive, this file uses EOF_Reached
-	 only for error reporting.  Other mechanisms are used to
-	 decide whether or not to exit. */
-      if (interactive && EOF_Reached)
-	EOF_Reached = 0;
-    }
-  last_command_exit_value = EX_USAGE;
-}
+	  c = *string;
 
-/* ??? Needed function. ??? We have to be able to discard the constructs
-   created during parsing.  In the case of error, we want to return
-   allocated objects to the memory pool.  In the case of no error, we want
-   to throw away the information about where the allocated objects live.
-   (dispose_command () will actually free the command. */
-static void
-discard_parser_constructs (error_p)
-     int error_p;
-{
-}
+	  switch (c)
+	    {
+	    case '0':
+	    case '1':
+	    case '2':
+	    case '3':
+	    case '4':
+	    case '5':
+	    case '6':
+	    case '7':
+	      strncpy (octal_string, string, 3);
+	      octal_string[3] = '\0';
 
-/* Do that silly `type "bye" to exit' stuff.  You know, "ignoreeof". */
+	      n = read_octal (octal_string);
+	      temp = xmalloc (3);
 
-/* A flag denoting whether or not ignoreeof is set. */
-int ignoreeof = 0;
+	      if (n == CTLESC || n == CTLNUL)
+		{
+		  temp[0] = CTLESC;
+		  temp[1] = n;
+		  temp[2] = '\0';
+		}
+	      else if (n == -1)
+		{
+		  temp[0] = '\\';
+		  temp[1] = '\0';
+		}
+	      else
+		{
+		  temp[0] = n;
+		  temp[1] = '\0';
+		}
 
-/* The number of times that we have encountered an EOF character without
-   another character intervening.  When this gets above the limit, the
-   shell terminates. */
-int eof_encountered = 0;
+	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
+		string++;
 
-/* The limit for eof_encountered. */
-int eof_encountered_limit = 10;
+	      c = 0;
+	      goto add_string;
 
-/* If we have EOF as the only input unit, this user wants to leave
-   the shell.  If the shell is not interactive, then just leave.
-   Otherwise, if ignoreeof is set, and we haven't done this the
-   required number of times in a row, print a message. */
-static void
-handle_eof_input_unit ()
-{
-  if (interactive)
-    {
-      /* shell.c may use this to decide whether or not to write out the
-	 history, among other things.  We use it only for error reporting
-	 in this file. */
-      if (EOF_Reached)
-	EOF_Reached = 0;
+	    case 't':
+	    case 'd':
+	    case 'T':
+	    case '@':
+	      /* Make the current time/date into a string. */
+	      the_time = time (0);
+	      temp = ctime (&the_time);
 
-      /* If the user wants to "ignore" eof, then let her do so, kind of. */
-      if (ignoreeof)
-	{
-	  if (eof_encountered < eof_encountered_limit)
-	    {
-	      fprintf (stderr, "Use \"%s\" to leave the shell.\n",
-		       login_shell ? "logout" : "exit");
-	      eof_encountered++;
-	      /* Reset the prompt string to be $PS1. */
-	      prompt_string_pointer = (char **)NULL;
-	      prompt_again ();
-	      last_read_token = current_token = '\n';
-	      return;
-	    }
-	}
+	      temp = (c != 'd') ? savestring (temp + 11) : savestring (temp);
+	      temp[(c != 'd') ? 8 : 10] = '\0';
 
-      /* In this case EOF should exit the shell.  Do it now. */
-      reset_parser ();
-      exit_builtin ((WORD_LIST *)NULL);
-    }
-  else
-    {
-      /* We don't write history files, etc., for non-interactive shells. */
-      EOF_Reached = 1;
-    }
-}
+	      /* quick and dirty conversion to 12-hour time */
+	      if (c == 'T' || c == '@')
+		{
+		  if (c == '@')
+		    {
+		      temp[5] = 'a';	/* am/pm format */
+		      temp[6] = 'm';
+		      temp[7] = '\0';
+		    }
+		  c = temp[2];
+		  temp[2] = '\0';
+		  n = atoi (temp);
+		  temp[2] = c;
+		  n -= 12;
+		  if (n > 0)
+		    {
+		      temp[0] = (n / 10) + '0';
+		      temp[1] = (n % 10) + '0';
+		    }
+		  if (n >= 0 && temp[5] == 'a')
+		    temp[5] = 'p';
+		}
+	      goto add_string;
 
-static WORD_LIST parse_string_error;
+	    case 'r':
+	      temp = xmalloc (2);
+	      temp[0] = '\r';
+	      temp[1] = '\0';
+	      goto add_string;
 
-/* Take a string and run it through the shell parser, returning the
-   resultant word list.  Used by compound array assignment. */
-WORD_LIST *
-parse_string_to_word_list (s, whom)
-     char *s, *whom;
-{
-  WORD_LIST *wl;
-  int tok, orig_line_number, orig_input_terminator;
-  int orig_line_count;
-#if defined (HISTORY)
-  int old_remember_on_history, old_history_expansion_inhibited;
-#endif
+	    case 'n':
+	      temp = xmalloc (3);
+	      temp[0] = no_line_editing ? '\n' : '\r';
+	      temp[1] = no_line_editing ? '\0' : '\n';
+	      temp[2] = '\0';
+	      goto add_string;
 
-#if defined (HISTORY)
-  old_remember_on_history = remember_on_history;
-#  if defined (BANG_HISTORY)
-  old_history_expansion_inhibited = history_expansion_inhibited;
-#  endif
-  bash_history_disable ();
-#endif
+	    case 's':
+	      temp = base_pathname (shell_name);
+	      temp = savestring (temp);
+	      goto add_string;
 
-  orig_line_number = line_number;
-  orig_line_count = current_command_line_count;
-  orig_input_terminator = shell_input_line_terminator;
+	    case 'v':
+	    case 'V':
+	      temp = xmalloc (8);
+	      if (c == 'v')
+		strcpy (temp, dist_version);
+	      else
+		sprintf (temp, "%s.%d", dist_version, patch_level);
+	      goto add_string;
 
-  push_stream (1);
-  last_read_token = '\n';
-  current_command_line_count = 0;
+	    case 'w':
+	    case 'W':
+	      {
+		/* Use the value of PWD because it is much more efficient. */
+		char t_string[PATH_MAX];
+		int tlen;
 
-  with_input_from_string (s, whom);
-  wl = (WORD_LIST *)NULL;
-  while ((tok = read_token (READ)) != yacc_EOF)
-    {
-      if (tok == '\n' && *bash_input.location.string == '\0')
-	break;
-      if (tok == '\n')		/* Allow newlines in compound assignments */
-	continue;
-      if (tok != WORD && tok != ASSIGNMENT_WORD)
-	{
-	  line_number = orig_line_number + line_number - 1;
-	  yyerror ();	/* does the right thing */
-	  if (wl)
-	    dispose_words (wl);
-	  wl = &parse_string_error;
-	  break;
-	}
-      wl = make_word_list (yylval.word, wl);
-    }
-  
-  last_read_token = '\n';
-  pop_stream ();
+		temp = get_string_value ("PWD");
 
-#if defined (HISTORY)
-  remember_on_history = old_remember_on_history;
-#  if defined (BANG_HISTORY)
-  history_expansion_inhibited = old_history_expansion_inhibited;
-#  endif /* BANG_HISTORY */
-#endif /* HISTORY */
+		if (temp == 0)
+		  {
+		    if (getcwd (t_string, sizeof(t_string)) == 0)
+		      {
+			t_string[0] = '.';
+			tlen = 1;
+		      }
+		    else
+		      tlen = strlen (t_string);
+		  }
+		else
+		  {
+		    tlen = sizeof (t_string) - 1;
+		    strncpy (t_string, temp, tlen);
+		  }
+		t_string[tlen] = '\0';
 
-  current_command_line_count = orig_line_count;
-  shell_input_line_terminator = orig_input_terminator;
+#define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
+#define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
+		if (c == 'W')
+		  {
+		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
+		      {
+			t = strrchr (t_string, '/');
+			if (t)
+			  strcpy (t_string, t + 1);
+		      }
+		  }
+#undef ROOT_PATH
+#undef DOUBLE_SLASH_ROOT
+		else
+		  /* polite_directory_format is guaranteed to return a string
+		     no longer than PATH_MAX - 1 characters. */
+		  strcpy (t_string, polite_directory_format (t_string));
 
-  if (wl == &parse_string_error)
-    {
-      last_command_exit_value = EXECUTION_FAILURE;
-      if (interactive_shell == 0 && posixly_correct)
-	jump_to_top_level (FORCE_EOF);
-      else
-	jump_to_top_level (DISCARD);
-    }
+		/* If we're going to be expanding the prompt string later,
+		   quote the directory name. */
+		if (promptvars || posixly_correct)
+		  /* Make sure that expand_prompt_string is called with a
+		     second argument of Q_DOUBLE_QUOTE if we use this
+		     function here. */
+		  temp = sh_backslash_quote_for_double_quotes (t_string);
+		else
+		  temp = savestring (t_string);
 
-  return (REVERSE_LIST (wl, WORD_LIST *));
-}
-#line 4199 "y.tab.c"
-/* allocate initial stack or double stack size, up to YYMAXDEPTH */
-static int yygrowstack()
-{
-    int newsize, i;
-    short *newss;
-    YYSTYPE *newvs;
-
-    if ((newsize = yystacksize) == 0)
-        newsize = YYINITSTACKSIZE;
-    else if (newsize >= YYMAXDEPTH)
-        return -1;
-    else if ((newsize *= 2) > YYMAXDEPTH)
-        newsize = YYMAXDEPTH;
-    i = yyssp - yyss;
-    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
-      (short *)malloc(newsize * sizeof *newss);
-    if (newss == NULL)
-        return -1;
-    yyss = newss;
-    yyssp = newss + i;
-    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
-      (YYSTYPE *)malloc(newsize * sizeof *newvs);
-    if (newvs == NULL)
-        return -1;
-    yyvs = newvs;
-    yyvsp = newvs + i;
-    yystacksize = newsize;
-    yysslim = yyss + newsize - 1;
-    return 0;
-}
-
-#define YYABORT goto yyabort
-#define YYREJECT goto yyabort
-#define YYACCEPT goto yyaccept
-#define YYERROR goto yyerrlab
-
-#ifndef YYPARSE_PARAM
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG void
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif	/* ANSI-C/C++ */
-#else	/* YYPARSE_PARAM */
-#ifndef YYPARSE_PARAM_TYPE
-#define YYPARSE_PARAM_TYPE void *
-#endif
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
-#endif	/* ANSI-C/C++ */
-#endif	/* ! YYPARSE_PARAM */
+		goto add_string;
+	      }
 
-int
-yyparse (YYPARSE_PARAM_ARG)
-    YYPARSE_PARAM_DECL
-{
-    register int yym, yyn, yystate;
-#if YYDEBUG
-    register const char *yys;
+	    case 'u':
+	      if (current_user.user_name == 0)
+		get_current_user_info ();
+	      temp = savestring (current_user.user_name);
+	      goto add_string;
 
-    if ((yys = getenv("YYDEBUG")))
-    {
-        yyn = *yys;
-        if (yyn >= '0' && yyn <= '9')
-            yydebug = yyn - '0';
-    }
-#endif
+	    case 'h':
+	    case 'H':
+	      temp = savestring (current_host_name);
+	      if (c == 'h' && (t = (char *)strchr (temp, '.')))
+		*t = '\0';
+	      goto add_string;
 
-    yynerrs = 0;
-    yyerrflag = 0;
-    yychar = (-1);
+	    case '#':
+	      temp = itos (current_command_number);
+	      goto add_string;
 
-    if (yyss == NULL && yygrowstack()) goto yyoverflow;
-    yyssp = yyss;
-    yyvsp = yyvs;
-    *yyssp = yystate = 0;
+	    case '!':
+#if !defined (HISTORY)
+	      temp = savestring ("1");
+#else /* HISTORY */
+	      temp = itos (history_number ());
+#endif /* HISTORY */
+	      goto add_string;
 
-yyloop:
-    if ((yyn = yydefred[yystate])) goto yyreduce;
-    if (yychar < 0)
-    {
-        if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, reading %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
-    }
-    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
-    {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: state %d, shifting to state %d\n",
-                    YYPREFIX, yystate, yytable[yyn]);
-#endif
-        if (yyssp >= yysslim && yygrowstack())
-        {
-            goto yyoverflow;
-        }
-        *++yyssp = yystate = yytable[yyn];
-        *++yyvsp = yylval;
-        yychar = (-1);
-        if (yyerrflag > 0)  --yyerrflag;
-        goto yyloop;
-    }
-    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
-    {
-        yyn = yytable[yyn];
-        goto yyreduce;
-    }
-    if (yyerrflag) goto yyinrecovery;
-#if defined(lint) || defined(__GNUC__)
-    goto yynewerror;
-#endif
-yynewerror:
-    yyerror("syntax error");
-#if defined(lint) || defined(__GNUC__)
-    goto yyerrlab;
-#endif
-yyerrlab:
-    ++yynerrs;
-yyinrecovery:
-    if (yyerrflag < 3)
-    {
-        yyerrflag = 3;
-        for (;;)
-        {
-            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
-                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: state %d, error recovery shifting\
- to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
-#endif
-                if (yyssp >= yysslim && yygrowstack())
-                {
-                    goto yyoverflow;
-                }
-                *++yyssp = yystate = yytable[yyn];
-                *++yyvsp = yylval;
-                goto yyloop;
-            }
-            else
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: error recovery discarding state %d\n",
-                            YYPREFIX, *yyssp);
-#endif
-                if (yyssp <= yyss) goto yyabort;
-                --yyssp;
-                --yyvsp;
-            }
-        }
-    }
-    else
-    {
-        if (yychar == 0) goto yyabort;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
-        yychar = (-1);
-        goto yyloop;
-    }
-yyreduce:
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
-                YYPREFIX, yystate, yyn, yyrule[yyn]);
-#endif
-    yym = yylen[yyn];
-    yyval = yyvsp[1-yym];
-    switch (yyn)
-    {
-case 1:
-#line 241 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  /* Case of regular command.  Discard the error
-			     safety net,and return the command just parsed. */
-			  global_command = yyvsp[-1].command;
-			  eof_encountered = 0;
-			  discard_parser_constructs (0);
-			  YYACCEPT;
-			}
-break;
-case 2:
-#line 250 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  /* Case of regular command, but not a very
-			     interesting one.  Return a NULL command. */
-			  global_command = (COMMAND *)NULL;
-			  YYACCEPT;
-			}
-break;
-case 3:
-#line 257 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  /* Error during parsing.  Return NULL command. */
-			  global_command = (COMMAND *)NULL;
-			  eof_encountered = 0;
-			  discard_parser_constructs (1);
-			  if (interactive)
-			    {
-			      YYACCEPT;
-			    }
-			  else
-			    {
-			      YYABORT;
-			    }
-			}
-break;
-case 4:
-#line 272 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  /* Case of EOF seen by itself.  Do ignoreeof or
-			     not. */
-			  global_command = (COMMAND *)NULL;
-			  handle_eof_input_unit ();
-			  YYACCEPT;
-			}
-break;
-case 5:
-#line 282 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); }
-break;
-case 6:
-#line 284 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-1].word_list); }
-break;
-case 7:
-#line 288 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (1, r_output_direction, redir);
-			}
-break;
-case 8:
-#line 293 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (0, r_input_direction, redir);
-			}
-break;
-case 9:
-#line 298 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_direction, redir);
-			}
-break;
-case 10:
-#line 303 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_direction, redir);
-			}
-break;
-case 11:
-#line 308 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (1, r_appending_to, redir);
-			}
-break;
-case 12:
-#line 313 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_appending_to, redir);
-			}
-break;
-case 13:
-#line 318 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (0, r_reading_until, redir);
-			  redir_stack[need_here_doc++] = yyval.redirect;
-			}
-break;
-case 14:
-#line 324 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_reading_until, redir);
-			  redir_stack[need_here_doc++] = yyval.redirect;
-			}
-break;
-case 15:
-#line 330 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.dest = yyvsp[0].number;
-			  yyval.redirect = make_redirection (0, r_duplicating_input, redir);
-			}
-break;
-case 16:
-#line 335 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.dest = yyvsp[0].number;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input, redir);
-			}
-break;
-case 17:
-#line 340 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.dest = yyvsp[0].number;
-			  yyval.redirect = make_redirection (1, r_duplicating_output, redir);
-			}
-break;
-case 18:
-#line 345 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.dest = yyvsp[0].number;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output, redir);
-			}
-break;
-case 19:
-#line 350 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (0, r_duplicating_input_word, redir);
-			}
-break;
-case 20:
-#line 355 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_input_word, redir);
-			}
-break;
-case 21:
-#line 360 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (1, r_duplicating_output_word, redir);
-			}
-break;
-case 22:
-#line 365 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_duplicating_output_word, redir);
-			}
-break;
-case 23:
-#line 370 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection
-			    (0, r_deblank_reading_until, redir);
-			  redir_stack[need_here_doc++] = yyval.redirect;
-			}
-break;
-case 24:
-#line 377 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection
-			    (yyvsp[-2].number, r_deblank_reading_until, redir);
-			  redir_stack[need_here_doc++] = yyval.redirect;
-			}
-break;
-case 25:
-#line 384 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.dest = 0L;
-			  yyval.redirect = make_redirection (1, r_close_this, redir);
-			}
-break;
-case 26:
-#line 389 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.dest = 0L;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
-			}
-break;
-case 27:
-#line 394 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.dest = 0L;
-			  yyval.redirect = make_redirection (0, r_close_this, redir);
-			}
-break;
-case 28:
-#line 399 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.dest = 0L;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_close_this, redir);
-			}
-break;
-case 29:
-#line 404 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (1, r_err_and_out, redir);
-			}
-break;
-case 30:
-#line 409 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_input_output, redir);
-			}
-break;
-case 31:
-#line 414 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (0, r_input_output, redir);
-			}
-break;
-case 32:
-#line 419 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (1, r_output_force, redir);
-			}
-break;
-case 33:
-#line 424 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  redir.filename = yyvsp[0].word;
-			  yyval.redirect = make_redirection (yyvsp[-2].number, r_output_force, redir);
-			}
-break;
-case 34:
-#line 431 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; }
-break;
-case 35:
-#line 433 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.element.word = yyvsp[0].word; yyval.element.redirect = 0; }
-break;
-case 36:
-#line 435 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.element.redirect = yyvsp[0].redirect; yyval.element.word = 0; }
-break;
-case 37:
-#line 439 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.redirect = yyvsp[0].redirect;
-			}
-break;
-case 38:
-#line 443 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  register REDIRECT *t;
+	    case '$':
+	      t = temp = xmalloc (3);
+	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
+		*t++ = '\\';
+	      *t++ = current_user.euid == 0 ? '#' : '$';
+	      *t = '\0';
+	      goto add_string;
 
-			  for (t = yyvsp[-1].redirect; t->next; t = t->next)
-			    ;
-			  t->next = yyvsp[0].redirect;
-			  yyval.redirect = yyvsp[-1].redirect;
-			}
-break;
-case 39:
-#line 454 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_simple_command (yyvsp[0].element, (COMMAND *)NULL); }
-break;
-case 40:
-#line 456 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_simple_command (yyvsp[0].element, yyvsp[-1].command); }
-break;
-case 41:
-#line 460 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = clean_simple_command (yyvsp[0].command); }
-break;
-case 42:
-#line 462 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 43:
-#line 464 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  COMMAND *tc;
+	    case 'j':
+	      temp = itos (count_all_jobs ());
+	      goto add_string;
 
-			  tc = yyvsp[-1].command;
-			  if (tc->redirects)
-			    {
-			      register REDIRECT *t;
-			      for (t = tc->redirects; t->next; t = t->next)
-				;
-			      t->next = yyvsp[0].redirect;
-			    }
-			  else
-			    tc->redirects = yyvsp[0].redirect;
-			  yyval.command = yyvsp[-1].command;
-			}
-break;
-case 44:
-#line 480 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 45:
-#line 484 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 46:
-#line 486 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 47:
-#line 488 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_while_command (yyvsp[-3].command, yyvsp[-1].command); }
-break;
-case 48:
-#line 490 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_until_command (yyvsp[-3].command, yyvsp[-1].command); }
-break;
-case 49:
-#line 492 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 50:
-#line 494 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 51:
-#line 496 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 52:
-#line 498 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 53:
-#line 500 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 54:
-#line 502 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 55:
-#line 504 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 56:
-#line 508 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); }
-break;
-case 57:
-#line 510 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_for_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command); }
-break;
-case 58:
-#line 512 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); }
-break;
-case 59:
-#line 514 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_for_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command); }
-break;
-case 60:
-#line 516 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); }
-break;
-case 61:
-#line 518 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_for_command (yyvsp[-8].word, REVERSE_LIST (yyvsp[-5].word_list, WORD_LIST *), yyvsp[-1].command); }
-break;
-case 62:
-#line 522 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); }
-break;
-case 63:
-#line 524 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_arith_for_command (yyvsp[-5].word_list, yyvsp[-1].command, arith_for_lineno); }
-break;
-case 64:
-#line 526 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); }
-break;
-case 65:
-#line 528 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_arith_for_command (yyvsp[-3].word_list, yyvsp[-1].command, arith_for_lineno); }
-break;
-case 66:
-#line 532 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
-			}
-break;
-case 67:
-#line 536 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = make_select_command (yyvsp[-4].word, add_string_to_list ("$@", (WORD_LIST *)NULL), yyvsp[-1].command);
-			}
-break;
-case 68:
-#line 540 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
-			}
-break;
-case 69:
-#line 544 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = make_select_command (yyvsp[-5].word, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), yyvsp[-1].command);
-			}
-break;
-case 70:
-#line 548 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
-			}
-break;
-case 71:
-#line 552 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = make_select_command (yyvsp[-8].word, (WORD_LIST *)reverse_list (yyvsp[-5].word_list), yyvsp[-1].command);
-			}
-break;
-case 72:
-#line 558 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_case_command (yyvsp[-4].word, (PATTERN_LIST *)NULL); }
-break;
-case 73:
-#line 560 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_case_command (yyvsp[-5].word, yyvsp[-2].pattern); }
-break;
-case 74:
-#line 562 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_case_command (yyvsp[-4].word, yyvsp[-1].pattern); }
-break;
-case 75:
-#line 566 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); }
-break;
-case 76:
-#line 569 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_function_def (yyvsp[-4].word, yyvsp[0].command, function_dstart, function_bstart); }
-break;
-case 77:
-#line 572 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_function_def (yyvsp[-2].word, yyvsp[0].command, function_dstart, function_bstart); }
-break;
-case 78:
-#line 577 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 79:
-#line 579 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  COMMAND *tc;
+	    case 'l':
+#if defined (HAVE_TTYNAME)
+	      temp = (char *)ttyname (fileno (stdin));
+	      t = temp ? base_pathname (temp) : "tty";
+	      temp = savestring (t);
+#else
+	      temp = savestring ("tty");
+#endif /* !HAVE_TTYNAME */
+	      goto add_string;
 
-			  tc = yyvsp[-1].command;
-			  /* According to Posix.2 3.9.5, redirections
-			     specified after the body of a function should
-			     be attached to the function and performed when
-			     the function is executed, not as part of the
-			     function definition command. */
-			  /* XXX - I don't think it matters, but we might
-			     want to change this in the future to avoid
-			     problems differentiating between a function
-			     definition with a redirection and a function
-			     definition containing a single command with a
-			     redirection.  The two are semantically equivalent,
-			     though -- the only difference is in how the
-			     command printing code displays the redirections. */
-			  if (tc->redirects)
-			    {
-			      register REDIRECT *t;
-			      for (t = tc->redirects; t->next; t = t->next)
-				;
-			      t->next = yyvsp[0].redirect;
-			    }
-			  else
-			    tc->redirects = yyvsp[0].redirect;
-			  yyval.command = yyvsp[-1].command;
-			}
-break;
-case 80:
-#line 610 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = make_subshell_command (yyvsp[-1].command);
-			  yyval.command->flags |= CMD_WANT_SUBSHELL;
-			}
-break;
-case 81:
-#line 617 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, (COMMAND *)NULL); }
-break;
-case 82:
-#line 619 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_if_command (yyvsp[-5].command, yyvsp[-3].command, yyvsp[-1].command); }
-break;
-case 83:
-#line 621 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[-1].command); }
-break;
-case 84:
-#line 626 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_group_command (yyvsp[-1].command); }
-break;
-case 85:
-#line 630 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_arith_command (yyvsp[0].word_list); }
-break;
-case 86:
-#line 634 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[-1].command; }
-break;
-case 87:
-#line 638 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_if_command (yyvsp[-2].command, yyvsp[0].command, (COMMAND *)NULL); }
-break;
-case 88:
-#line 640 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_if_command (yyvsp[-4].command, yyvsp[-2].command, yyvsp[0].command); }
-break;
-case 89:
-#line 642 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = make_if_command (yyvsp[-3].command, yyvsp[-1].command, yyvsp[0].command); }
-break;
-case 91:
-#line 647 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyvsp[0].pattern->next = yyvsp[-1].pattern; yyval.pattern = yyvsp[0].pattern; }
-break;
-case 92:
-#line 651 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); }
-break;
-case 93:
-#line 653 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); }
-break;
-case 94:
-#line 655 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.pattern = make_pattern_list (yyvsp[-2].word_list, yyvsp[0].command); }
-break;
-case 95:
-#line 657 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.pattern = make_pattern_list (yyvsp[-2].word_list, (COMMAND *)NULL); }
-break;
-case 97:
-#line 662 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyvsp[-1].pattern->next = yyvsp[-2].pattern; yyval.pattern = yyvsp[-1].pattern; }
-break;
-case 98:
-#line 666 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.word_list = make_word_list (yyvsp[0].word, (WORD_LIST *)NULL); }
-break;
-case 99:
-#line 668 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.word_list = make_word_list (yyvsp[0].word, yyvsp[-2].word_list); }
-break;
-case 100:
-#line 677 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = yyvsp[0].command;
-			  if (need_here_doc)
-			    gather_here_documents ();
-			 }
-break;
-case 102:
-#line 686 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = yyvsp[0].command;
-			}
-break;
-case 104:
-#line 693 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  if (yyvsp[-2].command->type == cm_connection)
-			    yyval.command = connect_async_list (yyvsp[-2].command, (COMMAND *)NULL, '&');
-			  else
-			    yyval.command = command_connect (yyvsp[-2].command, (COMMAND *)NULL, '&');
-			}
-break;
-case 106:
-#line 704 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); }
-break;
-case 107:
-#line 706 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); }
-break;
-case 108:
-#line 708 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  if (yyvsp[-3].command->type == cm_connection)
-			    yyval.command = connect_async_list (yyvsp[-3].command, yyvsp[0].command, '&');
-			  else
-			    yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '&');
-			}
-break;
-case 109:
-#line 715 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); }
-break;
-case 110:
-#line 717 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, ';'); }
-break;
-case 111:
-#line 719 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 117:
-#line 738 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = yyvsp[0].command;
-			  if (need_here_doc)
-			    gather_here_documents ();
-			}
-break;
-case 118:
-#line 744 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  if (yyvsp[-1].command->type == cm_connection)
-			    yyval.command = connect_async_list (yyvsp[-1].command, (COMMAND *)NULL, '&');
-			  else
-			    yyval.command = command_connect (yyvsp[-1].command, (COMMAND *)NULL, '&');
-			  if (need_here_doc)
-			    gather_here_documents ();
-			}
-break;
-case 119:
-#line 753 "/usr/homes/chet/src/bash/src/parse.y"
-{
-			  yyval.command = yyvsp[-1].command;
-			  if (need_here_doc)
-			    gather_here_documents ();
-			}
-break;
-case 120:
-#line 761 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, AND_AND); }
-break;
-case 121:
-#line 763 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, OR_OR); }
-break;
-case 122:
-#line 765 "/usr/homes/chet/src/bash/src/parse.y"
+#if defined (READLINE)
+	    case '[':
+	    case ']':
+	      temp = xmalloc (3);
+	      temp[0] = '\001';
+	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
+	      temp[2] = '\0';
+	      goto add_string;
+#endif /* READLINE */
+
+	    case '\\':
+	      temp = xmalloc (2);
+	      temp[0] = c;
+	      temp[1] = '\0';
+	      goto add_string;
+
+	    case 'a':
+	    case 'e':
+	      temp = xmalloc (2);
+	      temp[0] = (c == 'a') ? '\07' : '\033';
+	      temp[1] = '\0';
+	      goto add_string;
+
+	    default:
+	      temp = xmalloc (3);
+	      temp[0] = '\\';
+	      temp[1] = c;
+	      temp[2] = '\0';
+
+	    add_string:
+	      if (c)
+		string++;
+	      result =
+		sub_append_string (temp, result, &result_index, &result_size);
+	      temp = (char *)NULL; /* Freed in sub_append_string (). */
+	      result[result_index] = '\0';
+	      break;
+	    }
+	}
+      else
+	{
+	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
+	  result[result_index++] = c;
+	  result[result_index] = '\0';
+	}
+    }
+#else /* !PROMPT_STRING_DECODE */
+  result = savestring (string);
+#endif /* !PROMPT_STRING_DECODE */
+
+  /* Save the delimiter stack and point `dstack' to temp space so any
+     command substitutions in the prompt string won't result in screwing
+     up the parser's quoting state. */
+  save_dstack = dstack;
+  dstack = temp_dstack;
+  dstack.delimiter_depth = 0;
+
+  /* Perform variable and parameter expansion and command substitution on
+     the prompt string. */
+  if (promptvars || posixly_correct)
+    {
+      list = expand_prompt_string (result, Q_DOUBLE_QUOTES);
+      free (result);
+      result = string_list (list);
+      dispose_words (list);
+    }
+  else
+    {
+      t = dequote_string (result);
+      free (result);
+      result = t;
+    }
+
+  dstack = save_dstack;
+
+  return (result);
+}
+
+/* Report a syntax error, and restart the parser.  Call here for fatal
+   errors. */
+int
+yyerror ()
 {
-			  if (yyvsp[-2].command->type == cm_connection)
-			    yyval.command = connect_async_list (yyvsp[-2].command, yyvsp[0].command, '&');
-			  else
-			    yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, '&');
-			}
-break;
-case 123:
-#line 772 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = command_connect (yyvsp[-2].command, yyvsp[0].command, ';'); }
-break;
-case 124:
-#line 775 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 125:
-#line 779 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 126:
-#line 781 "/usr/homes/chet/src/bash/src/parse.y"
+  report_syntax_error ((char *)NULL);
+  reset_parser ();
+  return (0);
+}
+
+/* Report a syntax error with line numbers, etc.
+   Call here for recoverable errors.  If you have a message to print,
+   then place it in MESSAGE, otherwise pass NULL and this will figure
+   out an appropriate message for you. */
+static void
+report_syntax_error (message)
+     char *message;
 {
-			  yyvsp[0].command->flags |= CMD_INVERT_RETURN;
-			  yyval.command = yyvsp[0].command;
-			}
-break;
-case 127:
-#line 786 "/usr/homes/chet/src/bash/src/parse.y"
+  char *msg, *t;
+  int token_end, i;
+  char msg2[2];
+
+  if (message)
+    {
+      parser_error (line_number, "%s", message);
+      if (interactive && EOF_Reached)
+	EOF_Reached = 0;
+      last_command_exit_value = EX_USAGE;
+      return;
+    }
+
+  /* If the line of input we're reading is not null, try to find the
+     objectionable token. */
+  if (shell_input_line && *shell_input_line)
+    {
+      t = shell_input_line;
+      i = shell_input_line_index;
+      token_end = 0;
+
+      if (i && t[i] == '\0')
+	i--;
+
+      while (i && (whitespace (t[i]) || t[i] == '\n'))
+	i--;
+
+      if (i)
+	token_end = i + 1;
+
+      while (i && (member (t[i], " \n\t;|&") == 0))
+	i--;
+
+      while (i != token_end && (whitespace (t[i]) || t[i] == '\n'))
+	i++;
+
+      /* Print the offending token. */
+      if (token_end || (i == 0 && token_end == 0))
+	{
+	  if (token_end)
+	    msg = substring (t, i, token_end);
+	  else	/* one-character token */
+	    {
+	      msg2[0] = t[i];
+	      msg2[1] = '\0';
+	      msg = msg2;
+	    }
+
+	  parser_error (line_number, "syntax error near unexpected token `%s'", msg);
+
+	  if (msg != msg2)
+	    free (msg);
+	}
+
+      /* If not interactive, print the line containing the error. */
+      if (interactive == 0)
+	{
+	  msg = savestring (shell_input_line);
+	  token_end = strlen (msg);
+	  while (token_end && msg[token_end - 1] == '\n')
+	    msg[--token_end] = '\0';
+
+	  parser_error (line_number, "`%s'", msg);
+	  free (msg);
+	}
+    }
+  else
+    {
+      msg = EOF_Reached ? "syntax error: unexpected end of file" : "syntax error";
+      parser_error (line_number, "%s", msg);
+      /* When the shell is interactive, this file uses EOF_Reached
+	 only for error reporting.  Other mechanisms are used to
+	 decide whether or not to exit. */
+      if (interactive && EOF_Reached)
+	EOF_Reached = 0;
+    }
+  last_command_exit_value = EX_USAGE;
+}
+
+/* ??? Needed function. ??? We have to be able to discard the constructs
+   created during parsing.  In the case of error, we want to return
+   allocated objects to the memory pool.  In the case of no error, we want
+   to throw away the information about where the allocated objects live.
+   (dispose_command () will actually free the command. */
+static void
+discard_parser_constructs (error_p)
+     int error_p;
 {
-			  yyvsp[0].command->flags |= yyvsp[-1].number;
-			  yyval.command = yyvsp[0].command;
-			}
-break;
-case 128:
-#line 791 "/usr/homes/chet/src/bash/src/parse.y"
+}
+
+/* Do that silly `type "bye" to exit' stuff.  You know, "ignoreeof". */
+
+/* A flag denoting whether or not ignoreeof is set. */
+int ignoreeof = 0;
+
+/* The number of times that we have encountered an EOF character without
+   another character intervening.  When this gets above the limit, the
+   shell terminates. */
+int eof_encountered = 0;
+
+/* The limit for eof_encountered. */
+int eof_encountered_limit = 10;
+
+/* If we have EOF as the only input unit, this user wants to leave
+   the shell.  If the shell is not interactive, then just leave.
+   Otherwise, if ignoreeof is set, and we haven't done this the
+   required number of times in a row, print a message. */
+static void
+handle_eof_input_unit ()
 {
-			  yyvsp[0].command->flags |= yyvsp[-2].number|CMD_INVERT_RETURN;
-			  yyval.command = yyvsp[0].command;
-			}
-break;
-case 129:
-#line 796 "/usr/homes/chet/src/bash/src/parse.y"
+  if (interactive)
+    {
+      /* shell.c may use this to decide whether or not to write out the
+	 history, among other things.  We use it only for error reporting
+	 in this file. */
+      if (EOF_Reached)
+	EOF_Reached = 0;
+
+      /* If the user wants to "ignore" eof, then let her do so, kind of. */
+      if (ignoreeof)
+	{
+	  if (eof_encountered < eof_encountered_limit)
+	    {
+	      fprintf (stderr, "Use \"%s\" to leave the shell.\n",
+		       login_shell ? "logout" : "exit");
+	      eof_encountered++;
+	      /* Reset the prompt string to be $PS1. */
+	      prompt_string_pointer = (char **)NULL;
+	      prompt_again ();
+	      last_read_token = current_token = '\n';
+	      return;
+	    }
+	}
+
+      /* In this case EOF should exit the shell.  Do it now. */
+      reset_parser ();
+      exit_builtin ((WORD_LIST *)NULL);
+    }
+  else
+    {
+      /* We don't write history files, etc., for non-interactive shells. */
+      EOF_Reached = 1;
+    }
+}
+
+static WORD_LIST parse_string_error;
+
+/* Take a string and run it through the shell parser, returning the
+   resultant word list.  Used by compound array assignment. */
+WORD_LIST *
+parse_string_to_word_list (s, whom)
+     char *s, *whom;
 {
-			  yyvsp[0].command->flags |= yyvsp[-1].number|CMD_INVERT_RETURN;
-			  yyval.command = yyvsp[0].command;
-			}
-break;
-case 130:
-#line 804 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = command_connect (yyvsp[-3].command, yyvsp[0].command, '|'); }
-break;
-case 131:
-#line 806 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.command = yyvsp[0].command; }
-break;
-case 132:
-#line 810 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.number = CMD_TIME_PIPELINE; }
-break;
-case 133:
-#line 812 "/usr/homes/chet/src/bash/src/parse.y"
-{ yyval.number = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }
-break;
-#line 5117 "y.tab.c"
-    }
-    yyssp -= yym;
-    yystate = *yyssp;
-    yyvsp -= yym;
-    yym = yylhs[yyn];
-    if (yystate == 0 && yym == 0)
-    {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: after reduction, shifting from state 0 to\
- state %d\n", YYPREFIX, YYFINAL);
-#endif
-        yystate = YYFINAL;
-        *++yyssp = YYFINAL;
-        *++yyvsp = yyval;
-        if (yychar < 0)
-        {
-            if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-            if (yydebug)
-            {
-                yys = 0;
-                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-                if (!yys) yys = "illegal-symbol";
-                printf("%sdebug: state %d, reading %d (%s)\n",
-                        YYPREFIX, YYFINAL, yychar, yys);
-            }
+  WORD_LIST *wl;
+  int tok, orig_line_number, orig_input_terminator;
+  int orig_line_count;
+#if defined (HISTORY)
+  int old_remember_on_history, old_history_expansion_inhibited;
 #endif
-        }
-        if (yychar == 0) goto yyaccept;
-        goto yyloop;
+
+#if defined (HISTORY)
+  old_remember_on_history = remember_on_history;
+#  if defined (BANG_HISTORY)
+  old_history_expansion_inhibited = history_expansion_inhibited;
+#  endif
+  bash_history_disable ();
+#endif
+
+  orig_line_number = line_number;
+  orig_line_count = current_command_line_count;
+  orig_input_terminator = shell_input_line_terminator;
+
+  push_stream (1);
+  last_read_token = '\n';
+  current_command_line_count = 0;
+
+  with_input_from_string (s, whom);
+  wl = (WORD_LIST *)NULL;
+  while ((tok = read_token (READ)) != yacc_EOF)
+    {
+      if (tok == '\n' && *bash_input.location.string == '\0')
+	break;
+      if (tok == '\n')		/* Allow newlines in compound assignments */
+	continue;
+      if (tok != WORD && tok != ASSIGNMENT_WORD)
+	{
+	  line_number = orig_line_number + line_number - 1;
+	  yyerror ();	/* does the right thing */
+	  if (wl)
+	    dispose_words (wl);
+	  wl = &parse_string_error;
+	  break;
+	}
+      wl = make_word_list (yylval.word, wl);
     }
-    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
-        yystate = yytable[yyn];
-    else
-        yystate = yydgoto[yym];
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: after reduction, shifting from state %d \
-to state %d\n", YYPREFIX, *yyssp, yystate);
-#endif
-    if (yyssp >= yysslim && yygrowstack())
-    {
-        goto yyoverflow;
-    }
-    *++yyssp = yystate;
-    *++yyvsp = yyval;
-    goto yyloop;
-yyoverflow:
-    yyerror("yacc stack overflow");
-yyabort:
-    return (1);
-yyaccept:
-    return (0);
+  
+  last_read_token = '\n';
+  pop_stream ();
+
+#if defined (HISTORY)
+  remember_on_history = old_remember_on_history;
+#  if defined (BANG_HISTORY)
+  history_expansion_inhibited = old_history_expansion_inhibited;
+#  endif /* BANG_HISTORY */
+#endif /* HISTORY */
+
+  current_command_line_count = orig_line_count;
+  shell_input_line_terminator = orig_input_terminator;
+
+  if (wl == &parse_string_error)
+    {
+      last_command_exit_value = EXECUTION_FAILURE;
+      if (interactive_shell == 0 && posixly_correct)
+	jump_to_top_level (FORCE_EOF);
+      else
+	jump_to_top_level (DISCARD);
+    }
+
+  return (REVERSE_LIST (wl, WORD_LIST *));
 }
diff -urN -x _distribution -x _patchlevel -x readline bash-2.05.orig/y.tab.h bash-2.05/y.tab.h
--- bash-2.05.orig/y.tab.h	Wed Mar 28 00:06:14 2001
+++ bash-2.05/y.tab.h	Wed Apr 18 16:23:23 2001
@@ -1,46 +1,3 @@
-#ifndef YYERRCODE
-#define YYERRCODE 256
-#endif
-
-#define IF 257
-#define THEN 258
-#define ELSE 259
-#define ELIF 260
-#define FI 261
-#define CASE 262
-#define ESAC 263
-#define FOR 264
-#define SELECT 265
-#define WHILE 266
-#define UNTIL 267
-#define DO 268
-#define DONE 269
-#define FUNCTION 270
-#define COND_START 271
-#define COND_END 272
-#define COND_ERROR 273
-#define IN 274
-#define BANG 275
-#define TIME 276
-#define TIMEOPT 277
-#define WORD 278
-#define ASSIGNMENT_WORD 279
-#define NUMBER 280
-#define ARITH_CMD 281
-#define ARITH_FOR_EXPRS 282
-#define COND_CMD 283
-#define AND_AND 284
-#define OR_OR 285
-#define GREATER_GREATER 286
-#define LESS_LESS 287
-#define LESS_AND 288
-#define GREATER_AND 289
-#define SEMI_SEMI 290
-#define LESS_LESS_MINUS 291
-#define AND_GREATER 292
-#define LESS_GREATER 293
-#define GREATER_BAR 294
-#define yacc_EOF 295
 typedef union {
   WORD_DESC *word;		/* the word that we read. */
   int number;			/* the number that we read. */
@@ -50,4 +7,45 @@
   ELEMENT element;
   PATTERN_LIST *pattern;
 } YYSTYPE;
+#define	IF	257
+#define	THEN	258
+#define	ELSE	259
+#define	ELIF	260
+#define	FI	261
+#define	CASE	262
+#define	ESAC	263
+#define	FOR	264
+#define	SELECT	265
+#define	WHILE	266
+#define	UNTIL	267
+#define	DO	268
+#define	DONE	269
+#define	FUNCTION	270
+#define	COND_START	271
+#define	COND_END	272
+#define	COND_ERROR	273
+#define	IN	274
+#define	BANG	275
+#define	TIME	276
+#define	TIMEOPT	277
+#define	WORD	278
+#define	ASSIGNMENT_WORD	279
+#define	NUMBER	280
+#define	ARITH_CMD	281
+#define	ARITH_FOR_EXPRS	282
+#define	COND_CMD	283
+#define	AND_AND	284
+#define	OR_OR	285
+#define	GREATER_GREATER	286
+#define	LESS_LESS	287
+#define	LESS_AND	288
+#define	GREATER_AND	289
+#define	SEMI_SEMI	290
+#define	LESS_LESS_MINUS	291
+#define	AND_GREATER	292
+#define	LESS_GREATER	293
+#define	GREATER_BAR	294
+#define	yacc_EOF	295
+
+
 extern YYSTYPE yylval;
