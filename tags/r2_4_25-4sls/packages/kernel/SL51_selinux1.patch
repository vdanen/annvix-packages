diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/alpha/vmlinux.lds.in 2425sls2.ea.acl.nfsacl.sec.selinux/arch/alpha/vmlinux.lds.in
--- 2425sls2.ea.acl.nfsacl.sec/arch/alpha/vmlinux.lds.in	2003-06-13 17:51:29.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/alpha/vmlinux.lds.in	2004-03-02 23:41:23.000000000 +0200
@@ -44,6 +44,13 @@ SECTIONS
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
 
+  .= ALIGN(8)
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
+
   . = ALIGN(2*8192);	/* Align double page for init_task_union */
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/arm/vmlinux-armo.lds.in 2425sls2.ea.acl.nfsacl.sec.selinux/arch/arm/vmlinux-armo.lds.in
--- 2425sls2.ea.acl.nfsacl.sec/arch/arm/vmlinux-armo.lds.in	2002-02-25 21:37:52.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/arm/vmlinux-armo.lds.in	2004-03-02 23:41:23.000000000 +0200
@@ -29,6 +29,11 @@ SECTIONS
 		__initcall_start = .;
 			*(.initcall.init)
 		__initcall_end = .;
+		.security_initcall.init : {
+			__security_initcall_start = .;
+			*(.security_initcall.init)
+			__security_initcall_end = .;
+		}
 		. = ALIGN(32768);
 		__init_end = .;
 	}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/arm/vmlinux-armv.lds.in 2425sls2.ea.acl.nfsacl.sec.selinux/arch/arm/vmlinux-armv.lds.in
--- 2425sls2.ea.acl.nfsacl.sec/arch/arm/vmlinux-armv.lds.in	2002-02-25 21:37:52.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/arm/vmlinux-armv.lds.in	2004-03-02 23:41:23.000000000 +0200
@@ -28,6 +28,11 @@ SECTIONS
 		__initcall_start = .;
 			*(.initcall.init)
 		__initcall_end = .;
+		.security_initcall.init : {
+			__security_initcall_start = .;
+			*(.security_initcall.init)
+			__security_initcall_end = .;
+		}
 		. = ALIGN(4096);
 		__init_end = .;
 	}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/cris/cris.ld 2425sls2.ea.acl.nfsacl.sec.selinux/arch/cris/cris.ld
--- 2425sls2.ea.acl.nfsacl.sec/arch/cris/cris.ld	2001-10-08 21:43:54.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/cris/cris.ld	2004-03-02 23:41:23.000000000 +0200
@@ -65,6 +65,11 @@ SECTIONS
 		__initcall_start = .;
 		*(.initcall.init);
 		__initcall_end = .;
+	}
+	.security_initcall.init : {
+		__security_initcall_start = .;
+		*(.security_initcall.init)
+		__security_initcall_end = .;
 
 		/* We fill to the next page, so we can discard all init
 		   pages without needing to consider what payload might be
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/ia64/config.in 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/config.in
--- 2425sls2.ea.acl.nfsacl.sec/arch/ia64/config.in	2004-02-18 15:36:30.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/config.in	2004-03-02 23:41:23.000000000 +0200
@@ -319,3 +319,6 @@ fi
 int 'Kernel messages buffer length shift (0 = default)' CONFIG_LOG_BUF_SHIFT 0
 
 endmenu
+
+source security/Config.in
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/ia64/ia32/sys_ia32.c 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/ia32/sys_ia32.c
--- 2425sls2.ea.acl.nfsacl.sec/arch/ia64/ia32/sys_ia32.c	2004-02-18 15:36:30.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/ia32/sys_ia32.c	2004-03-02 23:41:23.000000000 +0200
@@ -49,6 +49,7 @@
 #include <linux/personality.h>
 #include <linux/stat.h>
 #include <linux/ipc.h>
+#include <linux/security.h>
 
 #include <asm/types.h>
 #include <asm/uaccess.h>
@@ -3330,6 +3331,7 @@ sys32_iopl (int level)
 	unsigned int old;
 	unsigned long addr;
 	mm_segment_t old_fs = get_fs ();
+	int retval;
 
 	if (level != 3)
 		return(-EINVAL);
@@ -3339,6 +3341,11 @@ sys32_iopl (int level)
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
 	}
+	retval = security_iopl(old,level);
+	if (retval) {
+		return retval;
+	}
+
 	set_fs(KERNEL_DS);
 	fd = sys_open("/dev/mem", O_SYNC | O_RDWR, 0);
 	set_fs(old_fs);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/ia64/kernel/entry.S 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/kernel/entry.S
--- 2425sls2.ea.acl.nfsacl.sec/arch/ia64/kernel/entry.S	2003-11-28 20:26:19.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/kernel/entry.S	2004-03-02 23:41:23.000000000 +0200
@@ -1397,7 +1397,7 @@ sys_call_table:
 	data8 ia64_ni_syscall			// 1230
 	data8 ia64_ni_syscall
 	data8 ia64_ni_syscall
-	data8 ia64_ni_syscall
+	data8 sys_security
 	data8 ia64_ni_syscall
 	data8 ia64_ni_syscall			// 1235
 	data8 ia64_ni_syscall
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/ia64/kernel/ptrace.c 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/kernel/ptrace.c
--- 2425sls2.ea.acl.nfsacl.sec/arch/ia64/kernel/ptrace.c	2003-11-28 20:26:19.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/kernel/ptrace.c	2004-03-02 23:41:23.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/ptrace.h>
 #include <linux/smp_lock.h>
 #include <linux/user.h>
+#include <linux/security.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
@@ -1254,6 +1255,9 @@ sys_ptrace (long request, pid_t pid, uns
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+		ret = security_ptrace(current->p_pptr, current);
+		if (ret)
+			goto out;
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
 		goto out;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/ia64/vmlinux.lds.S 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/vmlinux.lds.S
--- 2425sls2.ea.acl.nfsacl.sec/arch/ia64/vmlinux.lds.S	2003-08-25 14:44:39.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ia64/vmlinux.lds.S	2004-03-02 23:41:23.000000000 +0200
@@ -120,6 +120,13 @@ SECTIONS
 	  *(.initcall.init)
 	  __initcall_end = .;
 	}
+  .security_initcall.init : AT(ADDR(.security_initcall.init) - PAGE_OFFSET)
+	{ 
+	  __security_initcall_start = .;
+	  *(.security_initcall.init)
+	  __security_initcall_end = .;
+	}
+
   . = ALIGN(PAGE_SIZE);
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/i386/boot/compressed/Makefile 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/boot/compressed/Makefile
--- 2425sls2.ea.acl.nfsacl.sec/arch/i386/boot/compressed/Makefile	2002-02-25 21:37:52.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/boot/compressed/Makefile	2004-03-02 23:41:23.000000000 +0200
@@ -11,6 +11,11 @@ OBJECTS = $(HEAD) misc.o
 
 ZLDFLAGS = -e startup_32
 
+# if we have a StackGuard compiler, then we need to turn off the canary death handler stuff
+CFLAGS += $(shell if $(CC) -fno-canary-all-functions -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-fno-canary-all-functions"; fi)
+CFLAGS += $(shell if $(CC) -mno-terminator-canary -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-mno-terminator-canary"; fi)
+CFLAGS += $(shell if $(CC) -fno-stackguard-canary -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-fno-stackguard-canary"; fi)
+
 #
 # ZIMAGE_OFFSET is the load offset of the compression loader
 # BZIMAGE_OFFSET is the load offset of the high loaded compression loader
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/i386/config.in 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/config.in
--- 2425sls2.ea.acl.nfsacl.sec/arch/i386/config.in	2004-02-18 15:36:30.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/config.in	2004-03-02 23:41:23.000000000 +0200
@@ -486,4 +486,5 @@ int 'Kernel messages buffer length shift
 endmenu
 
 source crypto/Config.in
+source security/Config.in
 source lib/Config.in
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/i386/kernel/entry.S 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/kernel/entry.S
--- 2425sls2.ea.acl.nfsacl.sec/arch/i386/kernel/entry.S	2003-06-13 17:51:29.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/kernel/entry.S	2004-03-02 23:41:23.000000000 +0200
@@ -627,7 +627,7 @@ ENTRY(sys_call_table)
 	.long SYMBOL_NAME(sys_getdents64)	/* 220 */
 	.long SYMBOL_NAME(sys_fcntl64)
 	.long SYMBOL_NAME(sys_ni_syscall)	/* reserved for TUX */
-	.long SYMBOL_NAME(sys_ni_syscall)	/* Reserved for Security */
+	.long SYMBOL_NAME(sys_security)		/* Reserved for Security */
 	.long SYMBOL_NAME(sys_gettid)
 	.long SYMBOL_NAME(sys_readahead)	/* 225 */
 	.long SYMBOL_NAME(sys_setxattr)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/i386/kernel/ioport.c 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/kernel/ioport.c
--- 2425sls2.ea.acl.nfsacl.sec/arch/i386/kernel/ioport.c	2003-06-13 17:51:29.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/kernel/ioport.c	2004-03-02 23:41:23.000000000 +0200
@@ -14,6 +14,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/stddef.h>
+#include <linux/security.h>
 
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, short base, short extent, int new_value)
@@ -56,11 +57,18 @@ asmlinkage int sys_ioperm(unsigned long 
 {
 	struct thread_struct * t = &current->thread;
 	struct tss_struct * tss = init_tss + smp_processor_id();
+	int retval;
 
 	if ((from + num <= from) || (from + num > IO_BITMAP_SIZE*32))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
 		return -EPERM;
+
+	retval = security_ioperm(from, num, turn_on);
+	if (retval) {
+		return retval;
+	}
+
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -104,6 +112,7 @@ asmlinkage int sys_iopl(unsigned long un
 	struct pt_regs * regs = (struct pt_regs *) &unused;
 	unsigned int level = regs->ebx;
 	unsigned int old = (regs->eflags >> 12) & 3;
+	int retval;
 
 	if (level > 3)
 		return -EINVAL;
@@ -112,6 +121,11 @@ asmlinkage int sys_iopl(unsigned long un
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
 	}
+	retval = security_iopl(old, level);
+	if (retval) {
+		return retval;
+	}
+
 	regs->eflags = (regs->eflags & 0xffffcfff) | (level << 12);
 	return 0;
 }
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/i386/kernel/ptrace.c 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/kernel/ptrace.c
--- 2425sls2.ea.acl.nfsacl.sec/arch/i386/kernel/ptrace.c	2002-08-03 03:39:42.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/kernel/ptrace.c	2004-03-02 23:41:23.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/errno.h>
 #include <linux/ptrace.h>
 #include <linux/user.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -159,6 +160,9 @@ asmlinkage int sys_ptrace(long request, 
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+		ret = security_ptrace(current->p_pptr, current);
+		if (ret)
+			goto out;
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/i386/vmlinux.lds.S 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/vmlinux.lds.S
--- 2425sls2.ea.acl.nfsacl.sec/arch/i386/vmlinux.lds.S	2002-02-25 21:37:53.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/i386/vmlinux.lds.S	2004-03-02 23:41:23.000000000 +0200
@@ -49,6 +49,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(4096);
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/mips/ld.script.in 2425sls2.ea.acl.nfsacl.sec.selinux/arch/mips/ld.script.in
--- 2425sls2.ea.acl.nfsacl.sec/arch/mips/ld.script.in	2004-02-18 15:36:30.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/mips/ld.script.in	2004-03-02 23:41:23.000000000 +0200
@@ -46,6 +46,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(4096);	/* Align double page for init_task_union */
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/mips64/ld.script.elf32.S 2425sls2.ea.acl.nfsacl.sec.selinux/arch/mips64/ld.script.elf32.S
--- 2425sls2.ea.acl.nfsacl.sec/arch/mips64/ld.script.elf32.S	2004-02-18 15:36:30.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/mips64/ld.script.elf32.S	2004-03-02 23:41:23.000000000 +0200
@@ -47,6 +47,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  } 
   . = ALIGN(4096);	/* Align double page for init_task_union */
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/mips64/ld.script.elf64 2425sls2.ea.acl.nfsacl.sec.selinux/arch/mips64/ld.script.elf64
--- 2425sls2.ea.acl.nfsacl.sec/arch/mips64/ld.script.elf64	2004-02-18 15:36:30.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/mips64/ld.script.elf64	2004-03-02 23:41:23.000000000 +0200
@@ -56,6 +56,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(4096);	/* Align double page for init_task_union */
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/m68k/vmlinux.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/m68k/vmlinux.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/m68k/vmlinux.lds	2002-02-25 21:37:53.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/m68k/vmlinux.lds	2004-03-02 23:41:23.000000000 +0200
@@ -48,6 +48,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(8192);
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/m68k/vmlinux-sun3.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/m68k/vmlinux-sun3.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/m68k/vmlinux-sun3.lds	2002-02-25 21:37:53.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/m68k/vmlinux-sun3.lds	2004-03-02 23:41:23.000000000 +0200
@@ -44,6 +44,11 @@ __init_begin = .;
 	__initcall_start = .;
 	.initcall.init : { *(.initcall.init) }
 	__initcall_end = .;
+	.security_initcall.init : {
+		__security_initcall_start = .;
+		*(.security_initcall.init)
+		__security_initcall_end = .;
+	}
 	. = ALIGN(8192);
 	__init_end = .;
 	.init.task : { *(init_task) }
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/parisc/vmlinux.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/parisc/vmlinux.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/parisc/vmlinux.lds	2003-06-13 17:51:31.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/parisc/vmlinux.lds	2004-03-02 23:41:23.000000000 +0200
@@ -46,6 +46,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) } 
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   __init_end = .;
 
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/parisc/vmlinux64.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/parisc/vmlinux64.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/parisc/vmlinux64.lds	2003-06-13 17:51:31.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/parisc/vmlinux64.lds	2004-03-02 23:41:23.000000000 +0200
@@ -49,6 +49,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) } 
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   __init_end = .;
 
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/ppc/vmlinux.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ppc/vmlinux.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/ppc/vmlinux.lds	2003-08-25 14:44:40.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ppc/vmlinux.lds	2004-03-02 23:41:23.000000000 +0200
@@ -101,6 +101,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(4096);
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/ppc64/vmlinux.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ppc64/vmlinux.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/ppc64/vmlinux.lds	2003-11-28 20:26:19.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/ppc64/vmlinux.lds	2004-03-02 23:41:23.000000000 +0200
@@ -103,7 +103,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
-
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
 
   . = ALIGN(4096);
   __init_end = .;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/sh/vmlinux.lds.S 2425sls2.ea.acl.nfsacl.sec.selinux/arch/sh/vmlinux.lds.S
--- 2425sls2.ea.acl.nfsacl.sec/arch/sh/vmlinux.lds.S	2002-02-25 21:37:56.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/sh/vmlinux.lds.S	2004-03-02 23:41:23.000000000 +0200
@@ -65,6 +65,11 @@ SECTIONS
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
   __machvec_start = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   .machvec.init : { *(.machvec.init) }
   __machvec_end = .;
   . = ALIGN(4096);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/sparc/vmlinux.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/sparc/vmlinux.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/sparc/vmlinux.lds	2001-07-03 00:40:58.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/sparc/vmlinux.lds	2004-03-02 23:41:23.000000000 +0200
@@ -47,6 +47,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(4096);
   __init_end = .;
   . = ALIGN(32);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/sparc64/vmlinux.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/sparc64/vmlinux.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/sparc64/vmlinux.lds	2001-09-07 21:01:20.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/sparc64/vmlinux.lds	2004-03-02 23:41:23.000000000 +0200
@@ -48,6 +48,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(8192);
   __init_end = .;
   . = ALIGN(64);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/s390/vmlinux.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/s390/vmlinux.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/s390/vmlinux.lds	2002-02-25 21:37:56.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/s390/vmlinux.lds	2004-03-02 23:41:23.000000000 +0200
@@ -54,6 +54,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(4096);
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/s390/vmlinux-shared.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/s390/vmlinux-shared.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/s390/vmlinux-shared.lds	2002-02-25 21:37:56.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/s390/vmlinux-shared.lds	2004-03-02 23:41:23.000000000 +0200
@@ -56,6 +56,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(4096);
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/s390x/vmlinux.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/s390x/vmlinux.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/s390x/vmlinux.lds	2003-08-25 14:44:40.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/s390x/vmlinux.lds	2004-03-02 23:41:23.000000000 +0200
@@ -54,6 +54,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+ .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+ }
   . = ALIGN(4096);
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/s390x/vmlinux-shared.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/s390x/vmlinux-shared.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/s390x/vmlinux-shared.lds	2003-08-25 14:44:40.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/s390x/vmlinux-shared.lds	2004-03-02 23:41:23.000000000 +0200
@@ -56,6 +56,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(4096);
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/arch/x86_64/vmlinux.lds 2425sls2.ea.acl.nfsacl.sec.selinux/arch/x86_64/vmlinux.lds
--- 2425sls2.ea.acl.nfsacl.sec/arch/x86_64/vmlinux.lds	2003-06-13 17:51:32.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/arch/x86_64/vmlinux.lds	2004-03-02 23:41:23.000000000 +0200
@@ -89,6 +89,11 @@ SECTIONS
   __initcall_start = .;
   .initcall.init : { *(.initcall.init) }
   __initcall_end = .;
+  .security_initcall.init : {
+	__security_initcall_start = .;
+	*(.security_initcall.init)
+	__security_initcall_end = .;
+  }
   . = ALIGN(4096);
   __init_end = .;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/Documentation/Configure.help 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/Configure.help
--- 2425sls2.ea.acl.nfsacl.sec/Documentation/Configure.help	2004-03-03 00:08:40.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/Configure.help	2004-03-02 23:41:23.000000000 +0200
@@ -17865,6 +17865,24 @@ CONFIG_DEVPTS_FS
   Note that the experimental "/dev file system support"
   (CONFIG_DEVFS_FS)  is a more general facility.
 
+/dev/pts Extended Attributes
+CONFIG_DEVPTS_FS_XATTR
+  Extended attributes are name:value pairs associated with inodes by 
+  the kernel or by users (see the attr(5) manual page, or visit
+  <http://acl.bestbits.at/> for details).
+
+  If unsure, say N.
+
+/dev/pts Security Labels
+CONFIG_DEVPTS_FS_SECURITY
+  Security labels support alternative access control models
+  implemented by security modules like SELinux.  This option
+  enables an extended attribute handler for file security
+  labels in the /dev/pts filesystem.
+
+  If you are not using a security module that requires using
+  extended attributes for file security labels, say N.
+
 FreeVxFS file system support (VERITAS VxFS(TM) compatible)
 CONFIG_VXFS_FS
   FreeVxFS is a file system driver that support the VERITAS VxFS(TM)
@@ -29018,6 +29036,139 @@ CONFIG_SOUND_WM97XX
   
   If unsure, say N.
 
+Different Security Model Support
+CONFIG_SECURITY
+  This allows you to choose different security modules to be
+  configured into your kernel.
+
+  If this option is not selected, the default Linux security
+  model will be used.
+
+  If you are unsure how to answer this question, answer N.
+
+Socket and Networking Security Hooks
+CONFIG_SECURITY_NETWORK
+  This enables the socket and networking security hooks.
+  If enabled, a security module can use these hooks to
+  implement socket and networking access controls.
+  If you are unsure how to answer this question, answer N.
+
+Capabilities Support
+CONFIG_SECURITY_CAPABILITIES
+  This enables the "default" Linux capabilities functionality.
+  If you are unsure how to answer this question, answer Y.
+
+NSA SELinux Support
+CONFIG_SECURITY_SELINUX
+  This enables NSA Security-Enhanced Linux (SELinux), which 
+  provides fine-grained and flexible nondiscretionary access 
+  controls, including support for a generalization of Type 
+  Enforcement, Role-Based Access Control and optionally 
+  Multi-Level Security.  To use SELinux, you should obtain the 
+  SELinux archive from http://www.nsa.gov/selinux and follow the 
+  README instructions in it.  That archive provides additional 
+  components needed by SELinux, such as a kernel patch with 
+  additional changes, the checkpolicy policy compiler, the example 
+  security policy configuration, the setfiles file labeling 
+  utility, and a set of new and modified daemons and utility 
+  programs extended to deal with security contexts.  
+  If you want to use SELinux, say Y here.  You should also enable
+  the Capabilities security module built-in.
+
+NSA SELinux Development Support
+CONFIG_SECURITY_SELINUX_DEVELOP
+  This causes NSA SELinux to be built with development support
+  enabled.  With this option, SELinux starts in permissive mode, 
+  logging permission failures but not enforcing them.  You can 
+  use permissive mode in order to determine what additional 
+  permissions are needed for your particular system and can then 
+  revise your policy configuration accordingly.  You can subsequently
+  run the avc_toggle program to switch into enforcing mode.  Once in 
+  enforcing mode, you can only switch back to permissive mode 
+  if authorized by the policy (in the example policy, only the 
+  administrator role can do this).  Once you are satisfied that 
+  your policy configuration is sufficient for your system, you 
+  should either specify "enforcing=1" on the kernel command line 
+  to start in enforcing mode at boot time, or you should rebuild 
+  the kernel without this option so that it is always in enforcing 
+  mode.  The first option leaves open the possibility of switching 
+  back to permissive mode by an administrator, while the latter 
+  option provides stricter security.  
+  If unsure, say Y.
+
+NSA SELinux MLS policy (EXPERIMENTAL)
+CONFIG_SECURITY_SELINUX_MLS
+  This enables the optional Multi-Level Security (MLS) policy of 
+  NSA SELinux.  This policy is considered experimental and has 
+  not been configured for use.  If you want to experiment with it, 
+  see the README.MLS file in the SELinux archive from 
+  http://www.nsa.gov/selinux.  
+  If unsure, say N.
+
+LSM port of Openwall
+CONFIG_SECURITY_OWLSM
+  This enables the LSM port of the Openwall kernel patch.  This is NOT
+  official Openwall.  For more information on the Openwall kernel patch
+  go to <http://www.openwall.com/>
+  
+Enforce RLIMIT_NPROC on execve(2)
+CONFIG_OWLSM_RLIMIT_NPROC
+  This option is an LSM port of the Openwall CONFIG_SECURE_RLIMIT_NPROC
+  patch. It is derived from Openwall but is not official Openwall.  This
+  option is only valid if you have chosen to build the LSM port of
+  Openwall (CONFIG_SECURITY_OWLSM).
+
+  Linux lets you set a limit on how many processes a user can have, via
+  a setrlimit(2) call with RLIMIT_NPROC. Unfortunately, this limit is
+  only looked at when a new process is created on fork(2). If a process
+  changes its UID, it might exceed the limit for its new UID. This is
+  not a security issue by itself, as changing the UID is a privileged
+  operation. However, there're privileged programs that want to switch
+  to a user's context, including setting up some resource limits. The
+  only fork(2) required (if at all) is done before switching the UID,
+  and thus doesn't result in a check against RLIMIT_NPROC. Enable this
+  option to enforce RLIMIT_NPROC on execve(2) calls.
+
+  If you are unsure how to answer this question, answer N.
+
+Restricted links in /tmp
+CONFIG_OWLSM_LINK
+  This option is an LSM port of the Openwall CONFIG_SECURE_LINK patch.
+  It is derived from Openwall but is not official Openwall.  This option
+  is only valid if you have chosen to build the LSM port of Openwall
+  (CONFIG_SECURITY_OWLSM).
+
+  There's a very common attack that involves a malicious user creating
+  a symbolic link in /tmp, with a carefully chosen name, pointing at
+  another user's file. When the victim then writes to that file name,
+  without the required precautions, they inadvertently write to the
+  wrong file. Enabling this option reduces the impact of this class of
+  holes (some get fixed, many others allow for DoS attacks only, most
+  of the rest become harder to exploit) by preventing a process from
+  following a link which is in a +t directory, unless the link owner
+  is trusted (that is, it's the user we're running as or the directory
+  owner). To prevent from using a hard link in an attack instead, this
+  option does not allow users to create hard links to files they don't
+  own. This might break things. Say Y if security is more important.
+
+Special handling of fd 0, 1, and 2
+CONFIG_OWLSM_FD
+  This option is an LSM port of the Openwall CONFIG_SECURE_FD_0_1_2
+  patch.  It is derived from Openwall but is not official Openwall.
+  This option is only valid if you have chosen to build the LSM port of
+  Openwall (CONFIG_SECURITY_OWLSM).
+
+  File descriptors 0, 1, and 2 have a special meaning for the C library
+  and lots of programs. Thus, they're often referenced by number. Still,
+  it is normally possible to execute a program with one or more of these
+  fd's closed, and any open(2) calls it might do will happily provide
+  these fd numbers. The program (or the libraries it is linked with)
+  will continue using the fd's for their usual purposes, in reality
+  accessing files the program has just opened. If such a program is
+  installed SUID and/or SGID, then we might have a security problem.
+  Enable this option to ensure that fd's 0, 1, and 2 are always open on
+  execution of a SUID/SGID binary.
+
 IP Security Protocol (IPSEC) (EXPERIMENTAL)
 CONFIG_IPSEC
   This unit is experimental code.
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/Documentation/DocBook/deviceiobook.tmpl 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/DocBook/deviceiobook.tmpl
--- 2425sls2.ea.acl.nfsacl.sec/Documentation/DocBook/deviceiobook.tmpl	2001-05-02 00:20:25.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/DocBook/deviceiobook.tmpl	2004-03-02 23:41:23.000000000 +0200
@@ -224,9 +224,4 @@
 
   </chapter>
 
-  <chapter id="pubfunctions">
-     <title>Public Functions Provided</title>
-!Einclude/asm-i386/io.h
-  </chapter>
-
 </book>
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/Documentation/DocBook/kernel-api.tmpl 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/DocBook/kernel-api.tmpl
--- 2425sls2.ea.acl.nfsacl.sec/Documentation/DocBook/kernel-api.tmpl	2003-06-13 17:51:29.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/DocBook/kernel-api.tmpl	2004-03-02 23:41:23.000000000 +0200
@@ -185,6 +185,11 @@
 !Efs/devfs/base.c
   </chapter>
 
+  <chapter id="security">
+     <title>Security Framework</title>
+!Esecurity/security.c
+  </chapter>
+
   <chapter id="pmfuncs">
      <title>Power Management</title>
 !Ekernel/pm.c
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/Documentation/DocBook/lsm.tmpl 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/DocBook/lsm.tmpl
--- 2425sls2.ea.acl.nfsacl.sec/Documentation/DocBook/lsm.tmpl	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/DocBook/lsm.tmpl	2004-03-02 23:41:23.000000000 +0200
@@ -0,0 +1,285 @@
+<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN"[]>
+<article class="whitepaper" id="LinuxSecurityModule" lang="en">
+ <artheader>
+ <title>Linux Security Modules:  General Security Hooks for Linux</title>
+ <authorgroup>
+ <author>
+ <firstname>Stephen</firstname> 
+ <surname>Smalley</surname>
+ <affiliation>
+ <orgname>NAI Labs</orgname>
+ <address><email>ssmalley@nai.com</email></address>
+ </affiliation>
+ </author>
+ <author>
+ <firstname>Timothy</firstname> 
+ <surname>Fraser</surname>
+ <affiliation>
+ <orgname>NAI Labs</orgname>
+ <address><email>tfraser@nai.com</email></address>
+ </affiliation>
+ </author>
+ <author>
+ <firstname>Chris</firstname> 
+ <surname>Vance</surname>
+ <affiliation>
+ <orgname>NAI Labs</orgname>
+ <address><email>cvance@nai.com</email></address>
+ </affiliation>
+ </author>
+ </authorgroup
+ </artheader>
+
+<sect1><title>Introduction</title>
+
+<para>
+In March 2001, the National Security Agency (NSA) gave a presentation
+about Security-Enhanced Linux (SELinux) at the 2.5 Linux Kernel
+Summit.  SELinux is an implementation of flexible and fine-grained
+nondiscretionary access controls in the Linux kernel, originally
+implemented as its own particular kernel patch.  Several other
+security projects (e.g. RSBAC, Medusa) have also developed flexible
+access control architectures for the Linux kernel, and various
+projects have developed particular access control models for Linux
+(e.g. LIDS, DTE, SubDomain).  Each project has developed and
+maintained its own kernel patch to support its security needs.
+</para>
+
+<para>
+In response to the NSA presentation, Linus Torvalds made a set of
+remarks that described a security framework he would be willing to
+consider for inclusion in the mainstream Linux kernel.  He described a
+general framework that would provide a set of security hooks to
+control operations on kernel objects and a set of opaque security
+fields in kernel data structures for maintaining security attributes.
+This framework could then be used by loadable kernel modules to
+implement any desired model of security.  Linus also suggested the
+possibility of migrating the Linux capabilities code into such a
+module.
+</para>
+
+<para>
+The Linux Security Modules (LSM) project was started by WireX to
+develop such a framework.  LSM is a joint development effort by
+several security projects, including Immunix, SELinux, SGI and Janus,
+and several individuals, including Greg Kroah-Hartman and James
+Morris, to develop a Linux kernel patch that implements this
+framework.  The patch is currently tracking the 2.4 series and is
+targeted for integration into the 2.5 development series.  This
+technical report provides an overview of the framework and the example
+capabilities security module provided by the LSM kernel patch.
+</para>
+
+</sect1>
+
+<sect1 id="framework"><title>LSM Framework</title>
+
+<para>
+The LSM kernel patch provides a general kernel framework to support
+security modules.  In particular, the LSM framework is primarily
+focused on supporting access control modules, although future
+development is likely to address other security needs such as
+auditing.  By itself, the framework does not provide any additional
+security; it merely provides the infrastructure to support security
+modules.  The LSM kernel patch also moves most of the capabilities
+logic into an optional security module, with the system defaulting
+to the traditional superuser logic.  This capabilities module
+is discussed further in <XRef LinkEnd="cap">.
+</para>
+
+<para>
+The LSM kernel patch adds security fields to kernel data structures
+and inserts calls to hook functions at critical points in the kernel
+code to manage the security fields and to perform access control.  It
+also adds functions for registering and unregistering security
+modules, and adds a general <function>security</function> system call
+to support new system calls for security-aware applications.
+</para>
+
+<para>
+The LSM security fields are simply <type>void*</type> pointers.  For
+process and program execution security information, security fields
+were added to <structname>struct task_struct</structname> and 
+<structname>struct linux_binprm</structname>.  For filesystem security
+information, a security field was added to 
+<structname>struct super_block</structname>.  For pipe, file, and socket
+security information, security fields were added to 
+<structname>struct inode</structname> and 
+<structname>struct file</structname>.  For packet and network device security
+information, security fields were added to
+<structname>struct sk_buff</structname> and
+<structname>struct net_device</structname>.  For System V IPC security
+information, security fields were added to
+<structname>struct kern_ipc_perm</structname> and
+<structname>struct msg_msg</structname>; additionally, the definitions
+for <structname>struct msg_msg</structname>, <structname>struct 
+msg_queue</structname>, and <structname>struct 
+shmid_kernel</structname> were moved to header files
+(<filename>include/linux/msg.h</filename> and
+<filename>include/linux/shm.h</filename> as appropriate) to allow
+the security modules to use these definitions.
+</para>
+
+<para>
+Each LSM hook is a function pointer in a global table,
+security_ops. This table is a
+<structname>security_operations</structname> structure as defined by
+<filename>include/linux/security.h</filename>.  Detailed documentation
+for each hook is included in this header file.  At present, this
+structure consists of a collection of substructures that group related
+hooks based on the kernel object (e.g. task, inode, file, sk_buff,
+etc) as well as some top-level hook function pointers for system
+operations.  This structure is likely to be flattened in the future
+for performance.  The placement of the hook calls in the kernel code
+is described by the "called:" lines in the per-hook documentation in
+the header file.  The hook calls can also be easily found in the
+kernel code by looking for the string "security_ops->".
+
+</para>
+
+<para>
+Linus mentioned per-process security hooks in his original remarks as a
+possible alternative to global security hooks.  However, if LSM were
+to start from the perspective of per-process hooks, then the base
+framework would have to deal with how to handle operations that
+involve multiple processes (e.g. kill), since each process might have
+its own hook for controlling the operation.  This would require a
+general mechanism for composing hooks in the base framework.
+Additionally, LSM would still need global hooks for operations that
+have no process context (e.g. network input operations).
+Consequently, LSM provides global security hooks, but a security
+module is free to implement per-process hooks (where that makes sense)
+by storing a security_ops table in each process' security field and
+then invoking these per-process hooks from the global hooks.
+The problem of composition is thus deferred to the module.
+</para>
+
+<para>
+The global security_ops table is initialized to a set of hook
+functions provided by a dummy security module that provides
+traditional superuser logic.  A <function>register_security</function>
+function (in <filename>security/security.c</filename>) is provided to
+allow a security module to set security_ops to refer to its own hook
+functions, and an <function>unregister_security</function> function is
+provided to revert security_ops to the dummy module hooks.  This
+mechanism is used to set the primary security module, which is
+responsible for making the final decision for each hook.
+</para>
+
+<para>
+LSM also provides a simple mechanism for stacking additional security
+modules with the primary security module.  It defines
+<function>register_security</function> and
+<function>unregister_security</function> hooks in the
+<structname>security_operations</structname> structure and provides
+<function>mod_reg_security</function> and
+<function>mod_unreg_security</function> functions that invoke these
+hooks after performing some sanity checking.  A security module can
+call these functions in order to stack with other modules.  However,
+the actual details of how this stacking is handled are deferred to the
+module, which can implement these hooks in any way it wishes
+(including always returning an error if it does not wish to support
+stacking).  In this manner, LSM again defers the problem of
+composition to the module.
+</para>
+
+<para>
+Although the LSM hooks are organized into substructures based on
+kernel object, all of the hooks can be viewed as falling into two
+major categories: hooks that are used to manage the security fields
+and hooks that are used to perform access control.  Examples of the
+first category of hooks include the
+<function>alloc_security</function> and
+<function>free_security</function> hooks defined for each kernel data
+structure that has a security field.  These hooks are used to allocate
+and free security structures for kernel objects.  The first category
+of hooks also includes hooks that set information in the security
+field after allocation, such as the <function>post_lookup</function>
+hook in <structname>struct inode_security_ops</structname>.  This hook
+is used to set security information for inodes after successful lookup
+operations.  An example of the second category of hooks is the
+<function>permission</function> hook in 
+<structname>struct inode_security_ops</structname>.  This hook checks
+permission when accessing an inode.
+</para>
+
+<para>
+LSM adds a general <function>security</function> system call that
+simply invokes the <function>sys_security</function> hook.  This
+system call and hook permits security modules to implement new system
+calls for security-aware applications.  The interface is similar to
+socketcall, but also has an <parameter>id</parameter> to help identify
+the security module whose call is being invoked.  
+To eliminate the need for a central registry of ids,
+the recommended convention for creating the hexadecimal id value is:
+<programlisting>
+<![CDATA[
+ echo "Name_of_module" | md5sum | cut -c -8
+]]>
+</programlisting>
+C code will need to prefix this result with ``0x''.
+For example, the id for ``SGI Trusted Linux'' could be used in C as:
+<programlisting>
+<![CDATA[
+ #define SYS_SECURITY_MODID 0xc4c7be22
+]]>
+</programlisting>
+</para>
+
+</sect1>
+
+<sect1 id="cap"><title>LSM Capabilities Module</title>
+
+<para>
+The LSM kernel patch moves most of the existing POSIX.1e capabilities
+logic into an optional security module stored in the file
+<filename>security/capability.c</filename>.  This change allows
+users who do not want to use capabilities to omit this code entirely
+from their kernel, instead using the dummy module for traditional
+superuser logic or any other module that they desire.  This change
+also allows the developers of the capabilities logic to maintain and
+enhance their code more freely, without needing to integrate patches
+back into the base kernel.
+</para>
+
+<para>
+In addition to moving the capabilities logic, the LSM kernel patch
+could move the capability-related fields from the kernel data
+structures into the new security fields managed by the security
+modules.  However, at present, the LSM kernel patch leaves the
+capability fields in the kernel data structures.  In his original
+remarks, Linus suggested that this might be preferable so that other
+security modules can be easily stacked with the capabilities module
+without needing to chain multiple security structures on the security field.
+It also avoids imposing extra overhead on the capabilities module
+to manage the security fields.  However, the LSM framework could
+certainly support such a move if it is determined to be desirable,
+with only a few additional changes described below.
+</para>
+
+<para>
+At present, the capabilities logic for computing process capabilities
+on <function>execve</function> and <function>set*uid</function>,
+checking capabilities for a particular process, saving and checking
+capabilities for netlink messages, and handling the
+<function>capget</function> and <function>capset</function> system
+calls have been moved into the capabilities module.  There are still a
+few locations in the base kernel where capability-related fields are
+directly examined or modified, but the current version of the LSM
+patch does allow a security module to completely replace the
+assignment and testing of capabilities.  These few locations would
+need to be changed if the capability-related fields were moved into
+the security field.  The following is a list of known locations that
+still perform such direct examination or modification of
+capability-related fields:
+<itemizedlist>
+<listitem><para><filename>fs/open.c</filename>:<function>sys_access</function></para></listitem>
+<listitem><para><filename>fs/lockd/host.c</filename>:<function>nlm_bind_host</function></para></listitem>
+<listitem><para><filename>fs/nfsd/auth.c</filename>:<function>nfsd_setuser</function></para></listitem>
+<listitem><para><filename>fs/proc/array.c</filename>:<function>task_cap</function></para></listitem>
+</itemizedlist>
+</para>
+
+</sect1>
+
+</article>
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/Documentation/DocBook/Makefile 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/DocBook/Makefile
--- 2425sls2.ea.acl.nfsacl.sec/Documentation/DocBook/Makefile	2002-11-29 01:53:08.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/Documentation/DocBook/Makefile	2004-03-02 23:41:23.000000000 +0200
@@ -2,7 +2,7 @@ BOOKS	:= wanbook.sgml z8530book.sgml mca
 	   kernel-api.sgml parportbook.sgml kernel-hacking.sgml \
 	   kernel-locking.sgml via-audio.sgml mousedrivers.sgml sis900.sgml \
 	   deviceiobook.sgml procfs-guide.sgml tulip-user.sgml \
-	   journal-api.sgml
+	   journal-api.sgml lsm.sgml
 
 PS	:=	$(patsubst %.sgml, %.ps, $(BOOKS))
 PDF	:=	$(patsubst %.sgml, %.pdf, $(BOOKS))
@@ -44,6 +44,9 @@ man:	kernel-api-man
 $(TOPDIR)/scripts/docproc:
 	$(MAKE) -C $(TOPDIR)/scripts docproc
 
+lsm.sgml: lsm.tmpl 
+	$(TOPDIR)/scripts/docgen <$< >$@
+
 mousedrivers.sgml: mousedrivers.tmpl
 	$(TOPDIR)/scripts/docgen <$< >$@
 
@@ -90,6 +93,7 @@ APISOURCES :=	$(TOPDIR)/drivers/media/vi
 		$(TOPDIR)/arch/i386/kernel/irq.c \
 		$(TOPDIR)/arch/i386/kernel/mca.c \
 		$(TOPDIR)/arch/i386/kernel/mtrr.c \
+		$(TOPDIR)/drivers/block/genhd.c \
 		$(TOPDIR)/drivers/char/misc.c \
 		$(TOPDIR)/kernel/printk.c \
 		$(TOPDIR)/drivers/net/net_init.c \
@@ -121,6 +125,7 @@ APISOURCES :=	$(TOPDIR)/drivers/media/vi
 		$(TOPDIR)/kernel/printk.c \
 		$(TOPDIR)/kernel/sched.c \
 		$(TOPDIR)/kernel/sysctl.c \
+		$(TOPDIR)/security/security.c \
 		$(TOPDIR)/lib/string.c \
 		$(TOPDIR)/lib/vsprintf.c \
 		$(TOPDIR)/net/netsyms.c
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/drivers/char/tty_io.c 2425sls2.ea.acl.nfsacl.sec.selinux/drivers/char/tty_io.c
--- 2425sls2.ea.acl.nfsacl.sec/drivers/char/tty_io.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/drivers/char/tty_io.c	2004-03-02 23:41:23.000000000 +0200
@@ -90,6 +90,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/smp_lock.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -1491,6 +1492,10 @@ static int tty_fasync(int fd, struct fil
 		if (!waitqueue_active(&tty->read_wait))
 			tty->minimum_to_wake = 1;
 		if (filp->f_owner.pid == 0) {
+			retval = security_file_set_fowner(filp);
+			if (retval)
+				return retval;
+
 			filp->f_owner.pid = (-tty->pgrp) ? : current->pid;
 			filp->f_owner.uid = current->uid;
 			filp->f_owner.euid = current->euid;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/attr.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/attr.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/attr.c	2002-02-25 21:38:07.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/attr.c	2004-03-02 23:41:23.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/dnotify.h>
 #include <linux/fcntl.h>
 #include <linux/quotaops.h>
+#include <linux/security.h>
 
 /* Taken over from the old code... */
 
@@ -128,10 +129,14 @@ int notify_change(struct dentry * dentry
 		attr->ia_mtime = now;
 
 	lock_kernel();
-	if (inode->i_op && inode->i_op->setattr) 
-		error = inode->i_op->setattr(dentry, attr);
-	else {
+	if (inode->i_op && inode->i_op->setattr) {
+		error = security_inode_setattr(dentry, attr);
+		if (!error)
+			error = inode->i_op->setattr(dentry, attr);
+	} else {
 		error = inode_change_ok(inode, attr);
+		if (!error)
+			error = security_inode_setattr(dentry, attr);
 		if (!error) {
 			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
 			    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid))
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/binfmt_elf.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/binfmt_elf.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/binfmt_elf.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/binfmt_elf.c	2004-03-02 23:41:23.000000000 +0200
@@ -33,6 +33,7 @@
 #include <linux/smp_lock.h>
 #include <linux/compiler.h>
 #include <linux/highmem.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
@@ -107,12 +108,15 @@ static void padzero(unsigned long elf_bs
 }
 
 static elf_addr_t * 
-create_elf_tables(char *p, int argc, int envc,
+create_elf_tables(struct linux_binprm *bprm,
 		  struct elfhdr * exec,
 		  unsigned long load_addr,
 		  unsigned long load_bias,
 		  unsigned long interp_load_addr, int ibcs)
 {
+        char *p = bprm->p;
+        int argc = bprm->argc;
+        int envc = bprm->envc;
 	elf_caddr_t *argv;
 	elf_caddr_t *envp;
 	elf_addr_t *sp, *csp;
@@ -196,6 +200,7 @@ create_elf_tables(char *p, int argc, int
 	NEW_AUX_ENT(10, AT_EUID, (elf_addr_t) current->euid);
 	NEW_AUX_ENT(11, AT_GID, (elf_addr_t) current->gid);
 	NEW_AUX_ENT(12, AT_EGID, (elf_addr_t) current->egid);
+  	NEW_AUX_ENT(13, AT_SECURE, (elf_addr_t) security_bprm_secureexec(bprm));
 #ifdef ARCH_DLINFO
 	/* 
 	 * ARCH_DLINFO must come last so platform specific code can enforce
@@ -750,9 +755,7 @@ static int load_elf_binary(struct linux_
 	compute_creds(bprm);
 	current->flags &= ~PF_FORKNOEXEC;
 	bprm->p = (unsigned long)
-	  create_elf_tables((char *)bprm->p,
-			bprm->argc,
-			bprm->envc,
+	  create_elf_tables(bprm,
 			&elf_ex,
 			load_addr, load_bias,
 			interp_load_addr,
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/buffer.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/buffer.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/buffer.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/buffer.c	2004-03-02 23:41:23.000000000 +0200
@@ -47,6 +47,7 @@
 #include <linux/highmem.h>
 #include <linux/module.h>
 #include <linux/completion.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -2965,15 +2966,20 @@ int block_sync_page(struct page *page)
 
 asmlinkage long sys_bdflush(int func, long data)
 {
+	int error;
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+	error = security_bdflush(func, data);
+	if( error )
+		return error;
+
 	if (func == 1) {
 		/* do_exit directly and let kupdate to do its work alone. */
 		do_exit(0);
 #if 0 /* left here as it's the only example of lazy-mm-stuff used from
 	 a syscall that doesn't care about the current mm context. */
-		int error;
 		struct mm_struct *user_mm;
 
 		/*
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/Config.in 2425sls2.ea.acl.nfsacl.sec.selinux/fs/Config.in
--- 2425sls2.ea.acl.nfsacl.sec/fs/Config.in	2004-03-03 00:08:40.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/Config.in	2004-03-02 23:41:23.000000000 +0200
@@ -96,6 +96,10 @@ fi
 # who don't know what they are doing turn it on and complain when it
 # breaks.
 dep_bool '/dev/pts file system for Unix98 PTYs' CONFIG_DEVPTS_FS $CONFIG_UNIX98_PTYS
+dep_bool '  /dev/pts Extended Attributes' \
+	CONFIG_DEVPTS_FS_XATTR $CONFIG_DEVPTS_FS
+dep_bool '    /dev/pts Security Labels' \
+	CONFIG_DEVPTS_FS_SECURITY $CONFIG_DEVPTS_FS_XATTR
 
 tristate 'QNX4 file system support (read only)' CONFIG_QNX4FS_FS
 dep_mbool '  QNX4FS write support (DANGEROUS)' CONFIG_QNX4FS_RW $CONFIG_QNX4FS_FS $CONFIG_EXPERIMENTAL
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/dcache.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/dcache.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/dcache.c	2003-06-13 17:51:37.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/dcache.c	2004-03-02 23:41:23.000000000 +0200
@@ -25,6 +25,7 @@
 #include <linux/module.h>
 
 #include <asm/uaccess.h>
+#include <linux/security.h>
 
 #define DCACHE_PARANOIA 1
 /* #define DCACHE_DEBUG 1 */
@@ -656,6 +657,7 @@ void d_instantiate(struct dentry *entry,
 		list_add(&entry->d_alias, &inode->i_dentry);
 	entry->d_inode = inode;
 	spin_unlock(&dcache_lock);
+	security_d_instantiate(entry, inode);
 }
 
 /**
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/devpts/inode.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/inode.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/devpts/inode.c	2001-10-25 10:02:26.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/inode.c	2004-03-02 23:41:24.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/tty.h>
 #include <asm/bitops.h>
 #include <asm/uaccess.h>
+#include "xattr.h"
 
 #include "devpts_i.h"
 
@@ -180,6 +181,13 @@ static int devpts_statfs(struct super_bl
 
 static DECLARE_FSTYPE(devpts_fs_type, "devpts", devpts_read_super, FS_SINGLE);
 
+static struct inode_operations devpts_file_inode_operations = {
+	.setxattr	= devpts_setxattr,
+	.getxattr	= devpts_getxattr,
+	.listxattr	= devpts_listxattr,
+	.removexattr	= devpts_removexattr,
+};
+
 void devpts_pty_new(int number, kdev_t device)
 {
 	struct super_block *sb = devpts_mnt->mnt_sb;
@@ -199,6 +207,7 @@ void devpts_pty_new(int number, kdev_t d
 	inode->i_gid = sbi->setgid ? sbi->gid : current->fsgid;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	init_special_inode(inode, S_IFCHR|sbi->mode, kdev_t_to_nr(device));
+	inode->i_op = &devpts_file_inode_operations;
 
 	if ( sbi->inodes[number] ) {
 		iput(inode);
@@ -222,7 +231,10 @@ void devpts_pty_kill(int number)
 
 static int __init init_devpts_fs(void)
 {
-	int err = register_filesystem(&devpts_fs_type);
+	int err = init_devpts_xattr();
+	if (err)
+		return err;
+	err = register_filesystem(&devpts_fs_type);
 	if (!err) {
 		devpts_mnt = kern_mount(&devpts_fs_type);
 		err = PTR_ERR(devpts_mnt);
@@ -246,6 +258,7 @@ static void __exit exit_devpts_fs(void)
 #endif
 	unregister_filesystem(&devpts_fs_type);
 	kern_umount(devpts_mnt);
+	exit_devpts_xattr();
 }
 
 module_init(init_devpts_fs)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/devpts/Makefile 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/Makefile
--- 2425sls2.ea.acl.nfsacl.sec/fs/devpts/Makefile	2000-12-30 00:07:23.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/Makefile	2004-03-02 23:41:24.000000000 +0200
@@ -6,6 +6,14 @@ O_TARGET := devpts.o
 
 obj-y    := root.o inode.o
 
+ifeq ($(CONFIG_DEVPTS_FS_XATTR),y)
+obj-y += xattr.o 
+endif
+
+ifeq ($(CONFIG_DEVPTS_FS_SECURITY),y)
+obj-y += xattr_security.o
+endif
+
 obj-m    := $(O_TARGET)
 
 include $(TOPDIR)/Rules.make
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/devpts/xattr.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/xattr.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/devpts/xattr.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/xattr.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,214 @@
+/*
+  File: fs/devpts/xattr.c
+ 
+  Derived from fs/ext3/xattr.c, changed in the following ways:
+      drop everything related to persistent storage of EAs
+      pass dentry rather than inode to internal methods
+      only presently define a handler for security modules
+*/
+
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <asm/semaphore.h>
+#include "xattr.h"
+
+static struct devpts_xattr_handler *devpts_xattr_handlers[DEVPTS_XATTR_INDEX_MAX];
+static rwlock_t devpts_handler_lock = RW_LOCK_UNLOCKED;
+
+int
+devpts_xattr_register(int name_index, struct devpts_xattr_handler *handler)
+{
+	int error = -EINVAL;
+
+	if (name_index > 0 && name_index <= DEVPTS_XATTR_INDEX_MAX) {
+		write_lock(&devpts_handler_lock);
+		if (!devpts_xattr_handlers[name_index-1]) {
+			devpts_xattr_handlers[name_index-1] = handler;
+			error = 0;
+		}
+		write_unlock(&devpts_handler_lock);
+	}
+	return error;
+}
+
+void
+devpts_xattr_unregister(int name_index, struct devpts_xattr_handler *handler)
+{
+	if (name_index > 0 || name_index <= DEVPTS_XATTR_INDEX_MAX) {
+		write_lock(&devpts_handler_lock);
+		devpts_xattr_handlers[name_index-1] = NULL;
+		write_unlock(&devpts_handler_lock);
+	}
+}
+
+static inline const char *
+strcmp_prefix(const char *a, const char *a_prefix)
+{
+	while (*a_prefix && *a == *a_prefix) {
+		a++;
+		a_prefix++;
+	}
+	return *a_prefix ? NULL : a;
+}
+
+/*
+ * Decode the extended attribute name, and translate it into
+ * the name_index and name suffix.
+ */
+static inline struct devpts_xattr_handler *
+devpts_xattr_resolve_name(const char **name)
+{
+	struct devpts_xattr_handler *handler = NULL;
+	int i;
+
+	if (!*name)
+		return NULL;
+	read_lock(&devpts_handler_lock);
+	for (i=0; i<DEVPTS_XATTR_INDEX_MAX; i++) {
+		if (devpts_xattr_handlers[i]) {
+			const char *n = strcmp_prefix(*name,
+				devpts_xattr_handlers[i]->prefix);
+			if (n) {
+				handler = devpts_xattr_handlers[i];
+				*name = n;
+				break;
+			}
+		}
+	}
+	read_unlock(&devpts_handler_lock);
+	return handler;
+}
+
+static inline struct devpts_xattr_handler *
+devpts_xattr_handler(int name_index)
+{
+	struct devpts_xattr_handler *handler = NULL;
+	if (name_index > 0 && name_index <= DEVPTS_XATTR_INDEX_MAX) {
+		read_lock(&devpts_handler_lock);
+		handler = devpts_xattr_handlers[name_index-1];
+		read_unlock(&devpts_handler_lock);
+	}
+	return handler;
+}
+
+/*
+ * Inode operation getxattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+ssize_t
+devpts_getxattr(struct dentry *dentry, const char *name,
+	      void *buffer, size_t size)
+{
+	struct devpts_xattr_handler *handler;
+
+	handler = devpts_xattr_resolve_name(&name);
+	if (!handler)
+		return -EOPNOTSUPP;
+	return handler->get(dentry, name, buffer, size);
+}
+
+/*
+ * Inode operation listxattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+ssize_t
+devpts_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)
+{
+	struct devpts_xattr_handler *handler = NULL;
+	int i, error = 0;
+	unsigned int size = 0;
+	char *buf;
+
+	read_lock(&devpts_handler_lock);
+
+	for (i=0; i<DEVPTS_XATTR_INDEX_MAX; i++) {
+		handler = devpts_xattr_handlers[i];
+		if (handler)
+			size += handler->list(dentry, NULL);
+	}
+
+	if (!buffer) {
+		error = size;
+		goto out;
+	} else {
+		error = -ERANGE;
+		if (size > buffer_size)
+			goto out;
+	}
+
+	buf = buffer;
+	for (i=0; i<DEVPTS_XATTR_INDEX_MAX; i++) {
+		handler = devpts_xattr_handlers[i];
+		if (handler)
+			buf += handler->list(dentry, buf);
+	}
+	error = size;
+
+out:
+	read_unlock(&devpts_handler_lock);
+	return size;
+}
+
+/*
+ * Inode operation setxattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+int
+devpts_setxattr(struct dentry *dentry, const char *name,
+	      const void *value, size_t size, int flags)
+{
+	struct devpts_xattr_handler *handler;
+
+	if (size == 0)
+		value = "";  /* empty EA, do not remove */
+	handler = devpts_xattr_resolve_name(&name);
+	if (!handler)
+		return -EOPNOTSUPP;
+	return handler->set(dentry, name, value, size, flags);
+}
+
+/*
+ * Inode operation removexattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+int
+devpts_removexattr(struct dentry *dentry, const char *name)
+{
+	struct devpts_xattr_handler *handler;
+
+	handler = devpts_xattr_resolve_name(&name);
+	if (!handler)
+		return -EOPNOTSUPP;
+	return handler->set(dentry, name, NULL, 0, XATTR_REPLACE);
+}
+
+int __init
+init_devpts_xattr(void)
+{
+#ifdef CONFIG_DEVPTS_FS_SECURITY	
+	int	err;
+
+	err = devpts_xattr_register(DEVPTS_XATTR_INDEX_SECURITY,
+				    &devpts_xattr_security_handler);
+	if (err)
+		return err;
+#endif
+
+	return 0;
+}
+
+void
+exit_devpts_xattr(void)
+{
+#ifdef CONFIG_DEVPTS_FS_SECURITY	
+	devpts_xattr_unregister(DEVPTS_XATTR_INDEX_SECURITY,
+				&devpts_xattr_security_handler);
+#endif
+
+}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/devpts/xattr.h 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/xattr.h
--- 2425sls2.ea.acl.nfsacl.sec/fs/devpts/xattr.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/xattr.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+  File: fs/devpts/xattr.h
+ 
+  Derived from fs/ext3/xattr.h, changed in the following ways:
+      drop everything related to persistent storage of EAs
+      pass dentry rather than inode to internal methods
+      only presently define a handler for security modules
+*/
+
+#include <linux/config.h>
+#include <linux/xattr.h>
+
+/* Name indexes */
+#define DEVPTS_XATTR_INDEX_MAX			10
+#define DEVPTS_XATTR_INDEX_SECURITY	        1
+
+# ifdef CONFIG_DEVPTS_FS_XATTR
+
+struct devpts_xattr_handler {
+	char *prefix;
+	size_t (*list)(struct dentry *dentry, char *buffer);
+	int (*get)(struct dentry *dentry, const char *name, void *buffer,
+		   size_t size);
+	int (*set)(struct dentry *dentry, const char *name, const void *buffer,
+		   size_t size, int flags);
+};
+
+extern int devpts_xattr_register(int, struct devpts_xattr_handler *);
+extern void devpts_xattr_unregister(int, struct devpts_xattr_handler *);
+
+extern int devpts_setxattr(struct dentry *, const char *, const void *, size_t, int);
+extern ssize_t devpts_getxattr(struct dentry *, const char *, void *, size_t);
+extern ssize_t devpts_listxattr(struct dentry *, char *, size_t);
+extern int devpts_removexattr(struct dentry *, const char *);
+
+extern int init_devpts_xattr(void);
+extern void exit_devpts_xattr(void);
+
+# else  /* CONFIG_DEVPTS_FS_XATTR */
+#  define devpts_setxattr		NULL
+#  define devpts_getxattr		NULL
+#  define devpts_listxattr	NULL
+#  define devpts_removexattr	NULL
+
+static inline int
+init_devpts_xattr(void)
+{
+	return 0;
+}
+
+static inline void
+exit_devpts_xattr(void)
+{
+}
+
+# endif  /* CONFIG_DEVPTS_FS_XATTR */
+
+extern struct devpts_xattr_handler devpts_xattr_security_handler;
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/devpts/xattr_security.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/xattr_security.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/devpts/xattr_security.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/devpts/xattr_security.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * File: fs/devpts/xattr_security.c
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/fs.h>
+#include <linux/security.h>
+#include "xattr.h"
+
+#define XATTR_SECURITY_PREFIX "security."
+
+static size_t
+devpts_xattr_security_list(struct dentry *dentry, char *buffer)
+{
+	return security_inode_listsecurity(dentry, buffer);
+}
+
+static int
+devpts_xattr_security_get(struct dentry *dentry, const char *name,
+			  void *buffer, size_t size)
+{
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	return security_inode_getsecurity(dentry, name, buffer, size);
+}
+
+static int
+devpts_xattr_security_set(struct dentry *dentry, const char *name,
+			  const void *value, size_t size, int flags)
+{
+	if (strcmp(name, "") == 0)
+		return -EINVAL;
+	return security_inode_setsecurity(dentry, name, value, size, flags);
+}
+
+struct devpts_xattr_handler devpts_xattr_security_handler = {
+	.prefix	= XATTR_SECURITY_PREFIX,
+	.list	= devpts_xattr_security_list,
+	.get	= devpts_xattr_security_get,
+	.set	= devpts_xattr_security_set,
+};
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/dnotify.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/dnotify.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/dnotify.c	2002-11-29 01:53:15.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/dnotify.c	2004-03-02 23:41:23.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/init.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
+#include <linux/security.h>
 
 extern void send_sigio(struct fown_struct *fown, int fd, int band);
 
@@ -68,6 +69,7 @@ int fcntl_dirnotify(int fd, struct file 
 	struct dnotify_struct **prev;
 	struct inode *inode;
 	fl_owner_t id = current->files;
+	int error = 0;
 
 	if ((arg & ~DN_MULTISHOT) == 0) {
 		dnotify_flush(filp, id);
@@ -88,11 +90,15 @@ int fcntl_dirnotify(int fd, struct file 
 			odn->dn_fd = fd;
 			odn->dn_mask |= arg;
 			inode->i_dnotify_mask |= arg & ~DN_MULTISHOT;
-			kmem_cache_free(dn_cache, dn);
-			goto out;
+			goto out_free;
 		}
 		prev = &odn->dn_next;
 	}
+
+	error = security_file_set_fowner(filp);
+	if (error)
+		goto out_free;
+
 	filp->f_owner.pid = current->pid;
 	filp->f_owner.uid = current->uid;
 	filp->f_owner.euid = current->euid;
@@ -105,7 +111,10 @@ int fcntl_dirnotify(int fd, struct file 
 	inode->i_dnotify = dn;
 out:
 	write_unlock(&dn_lock);
-	return 0;
+	return error;
+out_free:
+	kmem_cache_free(dn_cache, dn);
+	goto out;
 }
 
 void __inode_dir_notify(struct inode *inode, unsigned long event)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/dquot.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/dquot.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/dquot.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/dquot.c	2004-03-02 23:41:23.000000000 +0200
@@ -68,6 +68,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/proc_fs.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -1324,6 +1325,9 @@ int vfs_quota_on(struct super_block *sb,
 	error = -EIO;
 	if (!f->f_op || !f->f_op->read || !f->f_op->write)
 		goto out_f;
+	error = security_quota_on(f);
+	if (error)
+		goto out_f;
 	inode = f->f_dentry->d_inode;
 	error = -EACCES;
 	if (!S_ISREG(inode->i_mode))
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/exec.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/exec.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/exec.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/exec.c	2004-03-02 23:41:23.000000000 +0200
@@ -37,6 +37,7 @@
 #include <linux/personality.h>
 #include <linux/swap.h>
 #include <linux/utsname.h>
+#include <linux/security.h>
 #define __NO_VERSION__
 #include <linux/module.h>
 
@@ -663,6 +664,7 @@ int prepare_binprm(struct linux_binprm *
 {
 	int mode;
 	struct inode * inode = bprm->file->f_dentry->d_inode;
+	int retval;
 
 	mode = inode->i_mode;
 	/*
@@ -692,27 +694,10 @@ int prepare_binprm(struct linux_binprm *
 			bprm->e_gid = inode->i_gid;
 	}
 
-	/* We don't have VFS support for capabilities yet */
-	cap_clear(bprm->cap_inheritable);
-	cap_clear(bprm->cap_permitted);
-	cap_clear(bprm->cap_effective);
-
-	/*  To support inheritance of root-permissions and suid-root
-         *  executables under compatibility mode, we raise all three
-         *  capability sets for the file.
-         *
-         *  If only the real uid is 0, we only raise the inheritable
-         *  and permitted sets of the executable file.
-         */
-
-	if (!issecure(SECURE_NOROOT)) {
-		if (bprm->e_uid == 0 || current->uid == 0) {
-			cap_set_full(bprm->cap_inheritable);
-			cap_set_full(bprm->cap_permitted);
-		}
-		if (bprm->e_uid == 0) 
-			cap_set_full(bprm->cap_effective);
-	}
+	/* fill in binprm security blob */
+	retval = security_bprm_set(bprm);
+	if (retval)
+		return retval;
 
 	memset(bprm->buf,0,BINPRM_BUF_SIZE);
 	return kernel_read(bprm->file,0,bprm->buf,BINPRM_BUF_SIZE);
@@ -735,16 +720,9 @@ int prepare_binprm(struct linux_binprm *
 
 void compute_creds(struct linux_binprm *bprm) 
 {
-	kernel_cap_t new_permitted, working;
 	int do_unlock = 0;
 
-	new_permitted = cap_intersect(bprm->cap_permitted, cap_bset);
-	working = cap_intersect(bprm->cap_inheritable,
-				current->cap_inheritable);
-	new_permitted = cap_combine(new_permitted, working);
-
-	if (bprm->e_uid != current->uid || bprm->e_gid != current->gid ||
-	    !cap_issubset(new_permitted, current->cap_permitted)) {
+	if (bprm->e_uid != current->uid || bprm->e_gid != current->gid) {
                 current->mm->dumpable = 0;
 		
 		lock_kernel();
@@ -756,32 +734,17 @@ void compute_creds(struct linux_binprm *
 				bprm->e_uid = current->uid;
 				bprm->e_gid = current->gid;
 			}
-			if(!capable(CAP_SETPCAP)) {
-				new_permitted = cap_intersect(new_permitted,
-							current->cap_permitted);
-			}
 		}
 		do_unlock = 1;
 	}
 
-
-	/* For init, we want to retain the capabilities set
-         * in the init_task struct. Thus we skip the usual
-         * capability rules */
-	if (current->pid != 1) {
-		current->cap_permitted = new_permitted;
-		current->cap_effective =
-			cap_intersect(new_permitted, bprm->cap_effective);
-	}
-	
-        /* AUD: Audit candidate if current->cap_effective is set */
-
         current->suid = current->euid = current->fsuid = bprm->e_uid;
         current->sgid = current->egid = current->fsgid = bprm->e_gid;
 
 	if(do_unlock)
 		unlock_kernel();
-	current->keep_capabilities = 0;
+
+	security_bprm_compute_creds(bprm);
 }
 
 
@@ -851,6 +814,10 @@ int search_binary_handler(struct linux_b
 	    }
 	}
 #endif
+	retval = security_bprm_check(bprm);
+	if (retval) 
+		return retval;
+
 	/* kernel module loader fixup */
 	/* so we don't try to load run modprobe in kernel space. */
 	set_fs(USER_DS);
@@ -927,6 +894,7 @@ int do_execve(char * filename, char ** a
 	bprm.sh_bang = 0;
 	bprm.loader = 0;
 	bprm.exec = 0;
+	bprm.security = NULL;
 	if ((bprm.argc = count(argv, bprm.p / sizeof(void *))) < 0) {
 		allow_write_access(file);
 		fput(file);
@@ -939,6 +907,10 @@ int do_execve(char * filename, char ** a
 		return bprm.envc;
 	}
 
+	retval = security_bprm_alloc(&bprm);
+	if (retval) 
+		goto out;
+
 	retval = prepare_binprm(&bprm);
 	if (retval < 0) 
 		goto out; 
@@ -957,9 +929,11 @@ int do_execve(char * filename, char ** a
 		goto out; 
 
 	retval = search_binary_handler(&bprm,regs);
-	if (retval >= 0)
+	if (retval >= 0) {
 		/* execve success */
+		security_bprm_free(&bprm);
 		return retval;
+	}
 
 out:
 	/* Something went wrong, return the inode and free the argument pages*/
@@ -973,6 +947,9 @@ out:
 			__free_page(page);
 	}
 
+	if (bprm.security)
+		security_bprm_free(&bprm);
+
 	return retval;
 }
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/fcntl.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/fcntl.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/fcntl.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/fcntl.c	2004-03-02 23:41:23.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/slab.h>
 #include <linux/iobuf.h>
 #include <linux/ptrace.h>
+#include <linux/security.h>
 
 #include <asm/poll.h>
 #include <asm/siginfo.h>
@@ -279,11 +280,11 @@ static long do_fcntl(unsigned int fd, un
 			unlock_kernel();
 			break;
 		case F_GETLK:
-			err = fcntl_getlk(fd, (struct flock *) arg);
+			err = fcntl_getlk(filp, (struct flock *) arg);
 			break;
 		case F_SETLK:
 		case F_SETLKW:
-			err = fcntl_setlk(fd, cmd, (struct flock *) arg);
+			err = fcntl_setlk(filp, cmd, (struct flock *) arg);
 			break;
 		case F_GETOWN:
 			/*
@@ -298,6 +299,13 @@ static long do_fcntl(unsigned int fd, un
 			break;
 		case F_SETOWN:
 			lock_kernel();
+
+			err = security_file_set_fowner(filp);
+			if (err) {
+				unlock_kernel();
+				break;
+			}
+
 			filp->f_owner.pid = arg;
 			filp->f_owner.uid = current->uid;
 			filp->f_owner.euid = current->euid;
@@ -346,6 +354,12 @@ asmlinkage long sys_fcntl(unsigned int f
 	if (!filp)
 		goto out;
 
+	err = security_file_fcntl(filp, cmd, arg);
+	if (err) {
+		fput(filp);
+		return err;
+	}
+
 	err = do_fcntl(fd, cmd, arg, filp);
 
  	fput(filp);
@@ -364,15 +378,20 @@ asmlinkage long sys_fcntl64(unsigned int
 	if (!filp)
 		goto out;
 
+	err = security_file_fcntl(filp, cmd, arg);
+	if (err) {
+		fput(filp);
+		return err;
+	}
+	err = -EBADF;
+	
 	switch (cmd) {
 		case F_GETLK64:
-			err = fcntl_getlk64(fd, (struct flock64 *) arg);
+			err = fcntl_getlk64(filp, (struct flock64 *) arg);
 			break;
 		case F_SETLK64:
-			err = fcntl_setlk64(fd, cmd, (struct flock64 *) arg);
-			break;
 		case F_SETLKW64:
-			err = fcntl_setlk64(fd, cmd, (struct flock64 *) arg);
+			err = fcntl_setlk64(filp, cmd, (struct flock64 *) arg);
 			break;
 		default:
 			err = do_fcntl(fd, cmd, arg, filp);
@@ -404,6 +423,10 @@ static void send_sigio_to_task(struct ta
 	    (fown->euid ^ p->suid) && (fown->euid ^ p->uid) &&
 	    (fown->uid ^ p->suid) && (fown->uid ^ p->uid))
 		return;
+
+	if (security_file_send_sigiotask(p, fown, fd, reason))
+		return;
+
 	switch (fown->signum) {
 		siginfo_t si;
 		default:
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/file_table.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/file_table.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/file_table.c	2002-11-29 01:53:15.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/file_table.c	2004-03-02 23:41:24.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/module.h>
 #include <linux/smp_lock.h>
 #include <linux/iobuf.h>
+#include <linux/security.h>
 
 /* sysctl tunables... */
 struct files_stat_struct files_stat = {0, 0, NR_FILE};
@@ -42,6 +43,12 @@ struct file * get_empty_filp(void)
 		files_stat.nr_free_files--;
 	new_one:
 		memset(f, 0, sizeof(*f));
+		if (security_file_alloc(f)) {
+			list_add(&f->f_list, &free_list);
+			files_stat.nr_free_files++;
+			file_list_unlock();
+			return NULL;
+		}
 		atomic_set(&f->f_count,1);
 		f->f_version = ++event;
 		f->f_uid = current->fsuid;
@@ -79,22 +86,41 @@ struct file * get_empty_filp(void)
 
 /*
  * Clear and initialize a (private) struct file for the given dentry,
- * and call the open function (if any).  The caller must verify that
- * inode->i_fop is not NULL.
+ * allocate the security structure, and call the open function (if any).  
+ * The file should be released using close_private_file.
  */
-int init_private_file(struct file *filp, struct dentry *dentry, int mode)
+int open_private_file(struct file *filp, struct dentry *dentry, int flags)
 {
+	int error;
 	memset(filp, 0, sizeof(*filp));
-	filp->f_mode   = mode;
+ 	filp->f_flags  = flags;
+ 	filp->f_mode   = (flags+1) & O_ACCMODE;
 	atomic_set(&filp->f_count, 1);
 	filp->f_dentry = dentry;
 	filp->f_uid    = current->fsuid;
 	filp->f_gid    = current->fsgid;
 	filp->f_op     = dentry->d_inode->i_fop;
-	if (filp->f_op->open)
-		return filp->f_op->open(dentry->d_inode, filp);
-	else
-		return 0;
+	error = security_file_alloc(filp);
+	if (!error)
+		if (filp->f_op && filp->f_op->open) {
+			error = filp->f_op->open(dentry->d_inode, filp);
+			if (error)
+				security_file_free(filp);
+		}
+	return error;
+}
+
+/*
+ * Release a private file by calling the release function (if any) and
+ * freeing the security structure.
+ */
+void close_private_file(struct file *file)
+{
+	struct inode * inode = file->f_dentry->d_inode;
+
+	if (file->f_op && file->f_op->release)
+		file->f_op->release(inode, file);
+	security_file_free(file);
 }
 
 void fput(struct file * file)
@@ -111,6 +137,8 @@ void fput(struct file * file)
 
 		if (file->f_op && file->f_op->release)
 			file->f_op->release(inode, file);
+		security_file_free (file);
+
 		fops_put(file->f_op);
 		if (file->f_mode & FMODE_WRITE)
 			put_write_access(inode);
@@ -144,6 +172,7 @@ struct file * fget(unsigned int fd)
 void put_filp(struct file *file)
 {
 	if(atomic_dec_and_test(&file->f_count)) {
+		security_file_free(file);
 		file_list_lock();
 		list_del(&file->f_list);
 		list_add(&file->f_list, &free_list);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/inode.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/inode.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/inode.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/inode.c	2004-03-02 23:43:14.000000000 +0200
@@ -17,6 +17,7 @@
 #include <linux/swapctl.h>
 #include <linux/prefetch.h>
 #include <linux/locks.h>
+#include <linux/security.h>
 
 /*
  * New inode.c implementation.
@@ -114,6 +115,14 @@ static struct inode *alloc_inode(struct 
 		inode->i_pipe = NULL;
 		inode->i_bdev = NULL;
 		inode->i_cdev = NULL;
+		inode->i_security = NULL;
+		if (security_inode_alloc(inode)) {
+			if (inode->i_sb->s_op->destroy_inode)
+				inode->i_sb->s_op->destroy_inode(inode);
+			else
+				kmem_cache_free(inode_cachep, inode);
+			return NULL;
+		}
 
 		mapping->a_ops = &empty_aops;
 		mapping->host = inode;
@@ -131,6 +140,7 @@ static void destroy_inode(struct inode *
 	   may have left stale entries on it which it can't remove (since
 	   it knows we're freeing the inode right now */
 	init_waitqueue_head(&inode->i_wait);
+	security_inode_free(inode);
 	if (inode->i_sb->s_op->destroy_inode)
 		inode->i_sb->s_op->destroy_inode(inode);
 	else
@@ -1220,6 +1230,8 @@ void iput(struct inode *inode)
 			if (inode->i_data.nrpages)
 				truncate_inode_pages(&inode->i_data, 0);
 
+			security_inode_delete(inode);
+
 			if (op && op->delete_inode) {
 				void (*delete)(struct inode *) = op->delete_inode;
 				if (!is_bad_inode(inode))
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/ioctl.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/ioctl.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/ioctl.c	2003-08-25 14:44:43.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/ioctl.c	2004-03-02 23:41:24.000000000 +0200
@@ -7,6 +7,7 @@
 #include <linux/mm.h>
 #include <linux/smp_lock.h>
 #include <linux/file.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
@@ -56,6 +57,14 @@ asmlinkage long sys_ioctl(unsigned int f
 	if (!filp)
 		goto out;
 	error = 0;
+
+	/* Call the Linux Security Module to perform its checks. */
+	error = security_file_ioctl(filp, cmd, arg);
+        if (error) {
+                fput(filp);
+                goto out;
+        }
+
 	lock_kernel();
 	switch (cmd) {
 		case FIOCLEX:
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/locks.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/locks.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/locks.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/locks.c	2004-03-02 23:47:30.000000000 +0200
@@ -122,6 +122,7 @@
 #include <linux/capability.h>
 #include <linux/sched.h>
 #include <linux/timer.h>
+#include <linux/security.h>
 
 #include <asm/semaphore.h>
 #include <asm/uaccess.h>
@@ -1277,6 +1278,9 @@ int fcntl_setlease(unsigned int fd, stru
 		return -EACCES;
 	if (!S_ISREG(inode->i_mode))
 		return -EINVAL;
+	error = security_file_lock(filp, arg);
+	if (error)
+		return error;
 
 	lock_kernel();
 
@@ -1344,6 +1348,11 @@ int fcntl_setlease(unsigned int fd, stru
 	fl->fl_next = *before;
 	*before = fl;
 	list_add(&fl->fl_link, &file_lock_list);
+
+	error = security_file_set_fowner(filp);
+	if (error)
+		goto out_unlock;
+
 	filp->f_owner.pid = current->pid;
 	filp->f_owner.uid = current->uid;
 	filp->f_owner.euid = current->euid;
@@ -1394,6 +1403,10 @@ asmlinkage long sys_flock(unsigned int f
 		&& !(filp->f_mode & 3))
 		goto out_putf;
 
+	error = security_file_lock(filp, type);
+	if (error)
+		goto out_putf;
+
 	lock_kernel();
 	error = flock_lock_file(filp, type,
 				(cmd & (LOCK_UN | LOCK_NB)) ? 0 : 1);
@@ -1408,9 +1421,8 @@ out:
 /* Report the first existing lock that would conflict with l.
  * This implements the F_GETLK command of fcntl().
  */
-int fcntl_getlk(unsigned int fd, struct flock *l)
+int fcntl_getlk(struct file *filp, struct flock *l)
 {
-	struct file *filp;
 	struct file_lock *fl, file_lock;
 	struct flock flock;
 	int error;
@@ -1422,19 +1434,14 @@ int fcntl_getlk(unsigned int fd, struct 
 	if ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))
 		goto out;
 
-	error = -EBADF;
-	filp = fget(fd);
-	if (!filp)
-		goto out;
-
 	error = flock_to_posix_lock(filp, &file_lock, &flock);
 	if (error)
-		goto out_putf;
+		goto out;
 
 	if (filp->f_op && filp->f_op->lock) {
 		error = filp->f_op->lock(filp, F_GETLK, &file_lock);
 		if (error < 0)
-			goto out_putf;
+			goto out;
 		else if (error == LOCK_USE_CLNT)
 		  /* Bypass for NFS with no locking - 2.0.36 compat */
 		  fl = posix_test_lock(filp, &file_lock);
@@ -1454,10 +1461,10 @@ int fcntl_getlk(unsigned int fd, struct 
 		 */
 		error = -EOVERFLOW;
 		if (fl->fl_start > OFFT_OFFSET_MAX)
-			goto out_putf;
+			goto out;
 		if ((fl->fl_end != OFFSET_MAX)
 		    && (fl->fl_end > OFFT_OFFSET_MAX))
-			goto out_putf;
+			goto out;
 #endif
 		flock.l_start = fl->fl_start;
 		flock.l_len = fl->fl_end == OFFSET_MAX ? 0 :
@@ -1469,8 +1476,6 @@ int fcntl_getlk(unsigned int fd, struct 
 	if (!copy_to_user(l, &flock, sizeof(flock)))
 		error = 0;
   
-out_putf:
-	fput(filp);
 out:
 	return error;
 }
@@ -1478,12 +1483,11 @@ out:
 /* Apply the lock described by l to an open file descriptor.
  * This implements both the F_SETLK and F_SETLKW commands of fcntl().
  */
-int fcntl_setlk(unsigned int fd, unsigned int cmd, struct flock *l)
+int fcntl_setlk(struct file *filp, unsigned int cmd, struct flock *l)
 {
-	struct file *filp;
 	struct file_lock *file_lock = locks_alloc_lock();
 	struct flock flock;
-	struct inode *inode;
+	struct inode *inode = filp->f_dentry->d_inode;
 	int error;
 
 	if (file_lock == NULL)
@@ -1496,17 +1500,6 @@ int fcntl_setlk(unsigned int fd, unsigne
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
 
-	/* Get arguments and validate them ...
-	 */
-
-	error = -EBADF;
-	filp = fget(fd);
-	if (!filp)
-		goto out;
-
-	error = -EINVAL;
-	inode = filp->f_dentry->d_inode;
-
 	/* Don't allow mandatory locks on files that may be memory mapped
 	 * and shared.
 	 */
@@ -1516,23 +1509,25 @@ int fcntl_setlk(unsigned int fd, unsigne
 
 		if (mapping->i_mmap_shared != NULL) {
 			error = -EAGAIN;
-			goto out_putf;
+			goto out;
 		}
 	}
 
+	/* Get arguments and validate them ...
+	 */
 	error = flock_to_posix_lock(filp, file_lock, &flock);
 	if (error)
-		goto out_putf;
+		goto out;
 	
 	error = -EBADF;
 	switch (flock.l_type) {
 	case F_RDLCK:
 		if (!(filp->f_mode & FMODE_READ))
-			goto out_putf;
+			goto out;
 		break;
 	case F_WRLCK:
 		if (!(filp->f_mode & FMODE_WRITE))
-			goto out_putf;
+			goto out;
 		break;
 	case F_UNLCK:
 		break;
@@ -1550,23 +1545,25 @@ int fcntl_setlk(unsigned int fd, unsigne
 	}
 }
 		if (!(filp->f_mode & 3))
-			goto out_putf;
+			goto out;
 		break;
 #endif
 	default:
 		error = -EINVAL;
-		goto out_putf;
+		goto out;
 	}
 
+	error = security_file_lock(filp, file_lock->fl_type);
+	if (error)
+		goto out;
+
 	if (filp->f_op && filp->f_op->lock != NULL) {
 		error = filp->f_op->lock(filp, cmd, file_lock);
 		if (error < 0)
-			goto out_putf;
+			goto out;
 	}
 	error = posix_lock_file(filp, file_lock, cmd == F_SETLKW);
 
-out_putf:
-	fput(filp);
 out:
 	locks_free_lock(file_lock);
 	return error;
@@ -1576,9 +1573,8 @@ out:
 /* Report the first existing lock that would conflict with l.
  * This implements the F_GETLK command of fcntl().
  */
-int fcntl_getlk64(unsigned int fd, struct flock64 *l)
+int fcntl_getlk64(struct file *filp, struct flock64 *l)
 {
-	struct file *filp;
 	struct file_lock *fl, file_lock;
 	struct flock64 flock;
 	int error;
@@ -1590,19 +1586,15 @@ int fcntl_getlk64(unsigned int fd, struc
 	if ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))
 		goto out;
 
-	error = -EBADF;
-	filp = fget(fd);
-	if (!filp)
-		goto out;
 
 	error = flock64_to_posix_lock(filp, &file_lock, &flock);
 	if (error)
-		goto out_putf;
+		goto out;
 
 	if (filp->f_op && filp->f_op->lock) {
 		error = filp->f_op->lock(filp, F_GETLK, &file_lock);
 		if (error < 0)
-			goto out_putf;
+			goto out;
 		else if (error == LOCK_USE_CLNT)
 		  /* Bypass for NFS with no locking - 2.0.36 compat */
 		  fl = posix_test_lock(filp, &file_lock);
@@ -1625,8 +1617,6 @@ int fcntl_getlk64(unsigned int fd, struc
 	if (!copy_to_user(l, &flock, sizeof(flock)))
 		error = 0;
   
-out_putf:
-	fput(filp);
 out:
 	return error;
 }
@@ -1634,12 +1624,11 @@ out:
 /* Apply the lock described by l to an open file descriptor.
  * This implements both the F_SETLK and F_SETLKW commands of fcntl().
  */
-int fcntl_setlk64(unsigned int fd, unsigned int cmd, struct flock64 *l)
+int fcntl_setlk64(struct file *filp, unsigned int cmd, struct flock64 *l)
 {
-	struct file *filp;
 	struct file_lock *file_lock = locks_alloc_lock();
 	struct flock64 flock;
-	struct inode *inode;
+	struct inode *inode = filp->f_dentry->d_inode;
 	int error;
 
 	if (file_lock == NULL)
@@ -1652,16 +1641,6 @@ int fcntl_setlk64(unsigned int fd, unsig
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
 
-	/* Get arguments and validate them ...
-	 */
-
-	error = -EBADF;
-	filp = fget(fd);
-	if (!filp)
-		goto out;
-
-	error = -EINVAL;
-	inode = filp->f_dentry->d_inode;
 
 	/* Don't allow mandatory locks on files that may be memory mapped
 	 * and shared.
@@ -1672,23 +1651,25 @@ int fcntl_setlk64(unsigned int fd, unsig
 
 		if (mapping->i_mmap_shared != NULL) {
 			error = -EAGAIN;
-			goto out_putf;
+			goto out;
 		}
 	}
 
+	/* Get arguments and validate them ...
+	 */
 	error = flock64_to_posix_lock(filp, file_lock, &flock);
 	if (error)
-		goto out_putf;
+		goto out;
 	
 	error = -EBADF;
 	switch (flock.l_type) {
 	case F_RDLCK:
 		if (!(filp->f_mode & FMODE_READ))
-			goto out_putf;
+			goto out;
 		break;
 	case F_WRLCK:
 		if (!(filp->f_mode & FMODE_WRITE))
-			goto out_putf;
+			goto out;
 		break;
 	case F_UNLCK:
 		break;
@@ -1696,18 +1677,20 @@ int fcntl_setlk64(unsigned int fd, unsig
 	case F_EXLCK:
 	default:
 		error = -EINVAL;
-		goto out_putf;
+		goto out;
 	}
 
+	error = security_file_lock(filp, file_lock->fl_type);
+	if (error)
+		goto out;
+
 	if (filp->f_op && filp->f_op->lock != NULL) {
 		error = filp->f_op->lock(filp, cmd, file_lock);
 		if (error < 0)
-			goto out_putf;
+			goto out;
 	}
 	error = posix_lock_file(filp, file_lock, cmd == F_SETLKW64);
 
-out_putf:
-	fput(filp);
 out:
 	locks_free_lock(file_lock);
 	return error;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/namei.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/namei.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/namei.c	2004-03-02 23:20:51.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/namei.c	2004-03-02 23:41:24.000000000 +0200
@@ -22,6 +22,7 @@
 #include <linux/dnotify.h>
 #include <linux/smp_lock.h>
 #include <linux/personality.h>
+#include <linux/security.h>
 
 #include <asm/namei.h>
 #include <asm/uaccess.h>
@@ -198,14 +199,23 @@ int vfs_permission(struct inode * inode,
 
 int permission(struct inode * inode,int mask)
 {
+	int retval;
+	int submask;
+
+	/* Ordinary permission routines do not understand MAY_APPEND. */
+	submask = mask & ~MAY_APPEND;
+
 	if (inode->i_op && inode->i_op->permission) {
-		int retval;
 		lock_kernel();
-		retval = inode->i_op->permission(inode, mask);
+		retval = inode->i_op->permission(inode, submask);
 		unlock_kernel();
-		return retval;
+	} else {
+		retval = vfs_permission(inode, submask);
 	}
-	return vfs_permission(inode, mask);
+	if (retval)
+		return retval;
+
+	return security_inode_permission(inode, mask);
 }
 
 /*
@@ -334,7 +344,7 @@ static struct dentry * real_lookup(struc
  */
 static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	int err;
+	int err = -ELOOP;
 	if (current->link_count >= 5)
 		goto loop;
 	if (current->total_link_count >= 40)
@@ -343,6 +353,9 @@ static inline int do_follow_link(struct 
 		current->state = TASK_RUNNING;
 		schedule();
 	}
+	err = security_inode_follow_link(dentry, nd);
+	if (err)
+		goto loop;
 	current->link_count++;
 	current->total_link_count++;
 	UPDATE_ATIME(dentry->d_inode);
@@ -351,7 +364,7 @@ static inline int do_follow_link(struct 
 	return err;
 loop:
 	path_release(nd);
-	return -ELOOP;
+	return err;
 }
 
 static inline int __follow_up(struct vfsmount **mnt, struct dentry **base)
@@ -973,14 +986,20 @@ int vfs_create(struct inode *dir, struct
 	if (!dir->i_op || !dir->i_op->create)
 		goto exit_lock;
 
+	error = security_inode_create(dir, dentry, mode);
+	if (error)
+		goto exit_lock;
+
 	DQUOT_INIT(dir);
 	lock_kernel();
 	error = dir->i_op->create(dir, dentry, mode);
 	unlock_kernel();
 exit_lock:
 	up(&dir->i_zombie);
-	if (!error)
+	if (!error) {
 		inode_dir_notify(dir, DN_CREATE);
+		security_inode_post_create(dir, dentry, mode);
+	}
 	return error;
 }
 
@@ -1008,6 +1027,11 @@ int open_namei(const char * pathname, in
 
 	acc_mode = ACC_MODE(flag);
 
+	/* Allow the LSM permission hook to distinguish append 
+	   access from general write access. */
+	if (flag & O_APPEND)
+		acc_mode |= MAY_APPEND;
+
 	/*
 	 * The simplest case - just a plain lookup.
 	 */
@@ -1185,6 +1209,9 @@ do_link:
 	 * stored in nd->last.name and we will have to putname() it when we
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
+	error = security_inode_follow_link(dentry, nd);
+	if (error)
+		goto exit_dput;
 	UPDATE_ATIME(dentry->d_inode);
 	error = dentry->d_inode->i_op->follow_link(dentry, nd);
 	dput(dentry);
@@ -1251,14 +1278,20 @@ int vfs_mknod(struct inode *dir, struct 
 	if (!dir->i_op || !dir->i_op->mknod)
 		goto exit_lock;
 
+	error = security_inode_mknod(dir, dentry, mode, dev);
+	if (error)
+		goto exit_lock;
+
 	DQUOT_INIT(dir);
 	lock_kernel();
 	error = dir->i_op->mknod(dir, dentry, mode, dev);
 	unlock_kernel();
 exit_lock:
 	up(&dir->i_zombie);
-	if (!error)
+	if (!error) {
 		inode_dir_notify(dir, DN_CREATE);
+		security_inode_post_mknod(dir, dentry, mode, dev);
+	}
 	return error;
 }
 
@@ -1320,16 +1353,22 @@ int vfs_mkdir(struct inode *dir, struct 
 	if (!dir->i_op || !dir->i_op->mkdir)
 		goto exit_lock;
 
-	DQUOT_INIT(dir);
 	mode &= (S_IRWXUGO|S_ISVTX);
+	error = security_inode_mkdir(dir, dentry, mode);
+	if (error)
+		goto exit_lock;
+
+	DQUOT_INIT(dir);
 	lock_kernel();
 	error = dir->i_op->mkdir(dir, dentry, mode);
 	unlock_kernel();
 
 exit_lock:
 	up(&dir->i_zombie);
-	if (!error)
+	if (!error) {
 		inode_dir_notify(dir, DN_CREATE);
+		security_inode_post_mkdir(dir,dentry, mode);
+	}
 	return error;
 }
 
@@ -1414,11 +1453,14 @@ int vfs_rmdir(struct inode *dir, struct 
 	if (d_mountpoint(dentry))
 		error = -EBUSY;
 	else {
-		lock_kernel();
-		error = dir->i_op->rmdir(dir, dentry);
-		unlock_kernel();
-		if (!error)
-			dentry->d_inode->i_flags |= S_DEAD;
+		error = security_inode_rmdir(dir, dentry);
+		if (!error) {
+			lock_kernel();
+			error = dir->i_op->rmdir(dir, dentry);
+			unlock_kernel();
+			if (!error)
+				dentry->d_inode->i_flags |= S_DEAD;
+		}
 	}
 	double_up(&dir->i_zombie, &dentry->d_inode->i_zombie);
 	if (!error) {
@@ -1484,11 +1526,14 @@ int vfs_unlink(struct inode *dir, struct
 			if (d_mountpoint(dentry))
 				error = -EBUSY;
 			else {
-				lock_kernel();
-				error = dir->i_op->unlink(dir, dentry);
-				unlock_kernel();
-				if (!error)
-					d_delete(dentry);
+				error = security_inode_unlink(dir, dentry);
+				if (!error) {
+					lock_kernel();
+					error = dir->i_op->unlink(dir, dentry);
+					unlock_kernel();
+					if (!error)
+						d_delete(dentry);
+				}
 			}
 		}
 	}
@@ -1553,6 +1598,10 @@ int vfs_symlink(struct inode *dir, struc
 	if (!dir->i_op || !dir->i_op->symlink)
 		goto exit_lock;
 
+	error = security_inode_symlink(dir, dentry, oldname);
+	if (error)
+		goto exit_lock;
+
 	DQUOT_INIT(dir);
 	lock_kernel();
 	error = dir->i_op->symlink(dir, dentry, oldname);
@@ -1560,8 +1609,10 @@ int vfs_symlink(struct inode *dir, struc
 
 exit_lock:
 	up(&dir->i_zombie);
-	if (!error)
+	if (!error) {
 		inode_dir_notify(dir, DN_CREATE);
+		security_inode_post_symlink(dir, dentry, oldname);
+	}
 	return error;
 }
 
@@ -1626,6 +1677,10 @@ int vfs_link(struct dentry *old_dentry, 
 	if (!dir->i_op || !dir->i_op->link)
 		goto exit_lock;
 
+	error = security_inode_link(old_dentry, dir, new_dentry);
+	if (error)
+		goto exit_lock;
+
 	DQUOT_INIT(dir);
 	lock_kernel();
 	error = dir->i_op->link(old_dentry, dir, new_dentry);
@@ -1633,8 +1688,10 @@ int vfs_link(struct dentry *old_dentry, 
 
 exit_lock:
 	up(&dir->i_zombie);
-	if (!error)
+	if (!error) {
 		inode_dir_notify(dir, DN_CREATE);
+		security_inode_post_link(old_dentry, dir, new_dentry);
+	}
 	return error;
 }
 
@@ -1746,6 +1803,10 @@ int vfs_rename_dir(struct inode *old_dir
 	if (error)
 		return error;
 
+	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
+	if (error)
+		return error;
+
 	DQUOT_INIT(old_dir);
 	DQUOT_INIT(new_dir);
 	down(&old_dir->i_sb->s_vfs_rename_sem);
@@ -1782,8 +1843,11 @@ int vfs_rename_dir(struct inode *old_dir
 		double_up(&old_dir->i_zombie,
 			  &new_dir->i_zombie);
 		
-	if (!error)
+	if (!error) {
 		d_move(old_dentry,new_dentry);
+		security_inode_post_rename(old_dir, old_dentry,
+							new_dir, new_dentry);
+	}
 out_unlock:
 	up(&old_dir->i_sb->s_vfs_rename_sem);
 	return error;
@@ -1814,6 +1878,10 @@ int vfs_rename_other(struct inode *old_d
 	if (!old_dir->i_op || !old_dir->i_op->rename)
 		return -EPERM;
 
+	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
+	if (error)
+		return error;
+
 	DQUOT_INIT(old_dir);
 	DQUOT_INIT(new_dir);
 	double_down(&old_dir->i_zombie, &new_dir->i_zombie);
@@ -1828,6 +1896,7 @@ int vfs_rename_other(struct inode *old_d
 	if (!(old_dir->i_sb->s_type->fs_flags & FS_ODD_RENAME)) {
 		d_move(old_dentry, new_dentry);
 	}
+	security_inode_post_rename(old_dir, old_dentry, new_dir, new_dentry);
 	return 0;
 }
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/namespace.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/namespace.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/namespace.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/namespace.c	2004-03-02 23:41:24.000000000 +0200
@@ -15,6 +15,7 @@
 #include <linux/quotaops.h>
 #include <linux/acct.h>
 #include <linux/module.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -291,6 +292,10 @@ static int do_umount(struct vfsmount *mn
 	struct super_block * sb = mnt->mnt_sb;
 	int retval = 0;
 
+	retval = security_sb_umount(mnt, flags);
+	if (retval)
+		return retval;
+
 	/*
 	 * If we may have to abort operations to get out of this
 	 * mount, and they will themselves hold resources we must
@@ -340,6 +345,7 @@ static int do_umount(struct vfsmount *mn
 		DQUOT_OFF(sb);
 		acct_auto_close(sb->s_dev);
 		unlock_kernel();
+		security_sb_umount_close(mnt);
 		spin_lock(&dcache_lock);
 	}
 	retval = -EBUSY;
@@ -349,6 +355,8 @@ static int do_umount(struct vfsmount *mn
 		retval = 0;
 	}
 	spin_unlock(&dcache_lock);
+	if (retval)
+		security_sb_umount_busy(mnt);
 	up_write(&current->namespace->sem);
 	return retval;
 }
@@ -466,6 +474,10 @@ static int graft_tree(struct vfsmount *m
 	if (IS_DEADDIR(nd->dentry->d_inode))
 		goto out_unlock;
 
+	err = security_sb_check_sb(mnt, nd);
+	if (err)
+		goto out_unlock;
+
 	spin_lock(&dcache_lock);
 	if (IS_ROOT(nd->dentry) || !d_unhashed(nd->dentry)) {
 		struct list_head head;
@@ -478,6 +490,8 @@ static int graft_tree(struct vfsmount *m
 	spin_unlock(&dcache_lock);
 out_unlock:
 	up(&nd->dentry->d_inode->i_zombie);
+	if (!err)
+		security_sb_post_addmount(mnt, nd);
 	return err;
 }
 
@@ -547,6 +561,8 @@ static int do_remount(struct nameidata *
 	if (!err)
 		nd->mnt->mnt_flags=mnt_flags;
 	up_write(&sb->s_umount);
+	if (!err)
+		security_sb_post_remount(nd->mnt, flags, data);
 	return err;
 }
 
@@ -732,6 +748,10 @@ long do_mount(char * dev_name, char * di
 	if (retval)
 		return retval;
 
+	retval = security_sb_mount(dev_name, &nd, type_page, flags, data_page);
+	if (retval)
+		goto dput_out;
+
 	if (flags & MS_REMOUNT)
 		retval = do_remount(&nd, flags & ~MS_REMOUNT, mnt_flags,
 				    data_page);
@@ -742,6 +762,7 @@ long do_mount(char * dev_name, char * di
 	else
 		retval = do_add_mount(&nd, type_page, flags, mnt_flags,
 				      dev_name, data_page);
+dput_out:
 	path_release(&nd);
 	return retval;
 }
@@ -925,6 +946,12 @@ asmlinkage long sys_pivot_root(const cha
 	if (error)
 		goto out1;
 
+	error = security_sb_pivotroot(&old_nd, &new_nd);
+	if (error) {
+		path_release(&old_nd);
+		goto out1;
+	}
+
 	read_lock(&current->fs->lock);
 	user_nd.mnt = mntget(current->fs->rootmnt);
 	user_nd.dentry = dget(current->fs->root);
@@ -969,6 +996,7 @@ asmlinkage long sys_pivot_root(const cha
 	attach_mnt(new_nd.mnt, &root_parent);
 	spin_unlock(&dcache_lock);
 	chroot_fs_refs(&user_nd, &new_nd);
+	security_sb_post_pivotroot(&user_nd, &new_nd);
 	error = 0;
 	path_release(&root_parent);
 	path_release(&parent_nd);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/nfsd/nfsctl.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/nfsd/nfsctl.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/nfsd/nfsctl.c	2002-08-03 03:39:45.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/nfsd/nfsctl.c	2004-03-02 23:41:24.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/security.h>
 
 #include <linux/nfs.h>
 #include <linux/sunrpc/svc.h>
@@ -251,6 +252,10 @@ asmlinkage handle_sys_nfsservctl(int cmd
 		goto done;
 	}
 
+	err = security_nfsservctl(cmd, arg);
+	if (err)
+		goto done;
+
 	switch(cmd) {
 	case NFSCTL_SVC:
 		err = nfsctl_svc(&arg->ca_svc);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/nfsd/nfsfh.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/nfsd/nfsfh.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/nfsd/nfsfh.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/nfsd/nfsfh.c	2004-03-02 23:41:24.000000000 +0200
@@ -85,7 +85,7 @@ static int nfsd_get_name(struct dentry *
 	/*
 	 * Open the directory ...
 	 */
-	error = init_private_file(&file, dentry, FMODE_READ);
+	error = open_private_file(&file, dentry, O_RDONLY);
 	if (error)
 		goto out;
 	error = -EINVAL;
@@ -113,8 +113,7 @@ static int nfsd_get_name(struct dentry *
 	}
 
 out_close:
-	if (file.f_op->release)
-		file.f_op->release(dir, &file);
+	close_private_file(&file);
 out:
 	return error;
 }
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/nfsd/vfs.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/nfsd/vfs.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/nfsd/vfs.c	2004-03-02 23:29:59.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/nfsd/vfs.c	2004-03-02 23:41:24.000000000 +0200
@@ -430,11 +430,13 @@ nfsd_open(struct svc_rqst *rqstp, struct
 {
 	struct dentry	*dentry;
 	struct inode	*inode;
-	int		err;
+	int		flags = O_RDONLY|O_LARGEFILE, err;
 
-	/* If we get here, then the client has already done an "open", and (hopefully)
-	 * checked permission - so allow OWNER_OVERRIDE in case a chmod has now revoked
-	 * permission */
+	/*
+	 * If we get here, then the client has already done an "open",
+	 * and (hopefully) checked permission - so allow OWNER_OVERRIDE
+	 * in case a chmod has now revoked permission.
+	 */
 	err = fh_verify(rqstp, fhp, type, access | MAY_OWNER_OVERRIDE);
 	if (err)
 		goto out;
@@ -459,37 +461,22 @@ nfsd_open(struct svc_rqst *rqstp, struct
 	if (err)
 		goto out_nfserr;
 
-	if ((access & MAY_WRITE) && (err = get_write_access(inode)) != 0)
-		goto out_nfserr;
-
-	memset(filp, 0, sizeof(*filp));
-	filp->f_op    = fops_get(inode->i_fop);
-	atomic_set(&filp->f_count, 1);
-	filp->f_dentry = dentry;
-	filp->f_vfsmnt = fhp->fh_export->ex_mnt;
 	if (access & MAY_WRITE) {
-		filp->f_flags = O_WRONLY|O_LARGEFILE;
-		filp->f_mode  = FMODE_WRITE;
+		err = get_write_access(inode);
+		if (err)
+			goto out_nfserr;
+
+		flags = O_WRONLY|O_LARGEFILE;
+
 		DQUOT_INIT(inode);
-	} else {
-		filp->f_flags = O_RDONLY|O_LARGEFILE;
-		filp->f_mode  = FMODE_READ;
 	}
 
-	err = 0;
-	if (filp->f_op && filp->f_op->open) {
-		err = filp->f_op->open(inode, filp);
-		if (err) {
-			fops_put(filp->f_op);
-			if (access & MAY_WRITE)
-				put_write_access(inode);
-
-			/* I nearly added put_filp() call here, but this filp
-			 * is really on callers stack frame. -DaveM
-			 */
-			atomic_dec(&filp->f_count);
-		}
-	}
+	err = open_private_file(filp, dentry, flags);
+	if (!err) {
+		filp->f_vfsmnt = fhp->fh_export->ex_mnt;
+	} else if (access & MAY_WRITE)
+		put_write_access(inode);
+
 out_nfserr:
 	if (err)
 		err = nfserrno(err);
@@ -506,9 +493,7 @@ nfsd_close(struct file *filp)
 	struct dentry	*dentry = filp->f_dentry;
 	struct inode	*inode = dentry->d_inode;
 
-	if (filp->f_op && filp->f_op->release)
-		filp->f_op->release(inode, filp);
-	fops_put(filp->f_op);
+	close_private_file(filp);
 	if (filp->f_mode & FMODE_WRITE)
 		put_write_access(inode);
 }
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/open.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/open.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/open.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/open.c	2004-03-02 23:41:24.000000000 +0200
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/iobuf.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -28,6 +29,9 @@ int vfs_statfs(struct super_block *sb, s
 		retval = -ENOSYS;
 		if (sb->s_op && sb->s_op->statfs) {
 			memset(buf, 0, sizeof(struct statfs));
+			retval = security_sb_statfs(sb);
+			if (retval)
+				return retval;
 			lock_kernel();
 			retval = sb->s_op->statfs(sb, buf);
 			unlock_kernel();
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/proc/base.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/proc/base.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/proc/base.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/proc/base.c	2004-03-02 23:41:24.000000000 +0200
@@ -25,6 +25,7 @@
 #include <linux/string.h>
 #include <linux/seq_file.h>
 #include <linux/namespace.h>
+#include <linux/security.h>
 
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
@@ -126,7 +127,8 @@ static int proc_root_link(struct inode *
 #define MAY_PTRACE(task) \
 	(task == current || \
 	(task->p_pptr == current && \
-	(task->ptrace & PT_PTRACED) && task->state == TASK_STOPPED))
+	(task->ptrace & PT_PTRACED) && task->state == TASK_STOPPED && \
+	security_ptrace(current,task) == 0))
 
 static int may_ptrace_attach(struct task_struct *task)
 {
@@ -146,6 +148,9 @@ static int may_ptrace_attach(struct task
 	if (!is_dumpable(task) && !capable(CAP_SYS_PTRACE))
 		goto out;
 
+	if (security_ptrace(current, task))
+		goto out;
+
 	retval = 1;
 
 out:
@@ -357,8 +362,10 @@ static ssize_t proc_info_read(struct fil
 	if (count + *ppos > length)
 		count = length - *ppos;
 	end = count + *ppos;
-	copy_to_user(buf, (char *) page + *ppos, count);
-	*ppos = end;
+	if (copy_to_user(buf, (char *) page + *ppos, count))
+		count = -EFAULT;
+	else
+		*ppos = end;
 	free_page(page);
 	return count;
 }
@@ -599,6 +606,13 @@ enum pid_directory_inos {
 	PROC_PID_MAPS,
 	PROC_PID_CPU,
 	PROC_PID_MOUNTS,
+#ifdef CONFIG_SECURITY
+	PROC_PID_ATTR,
+	PROC_PID_ATTR_CURRENT,
+	PROC_PID_ATTR_PREV,
+	PROC_PID_ATTR_EXEC,
+	PROC_PID_ATTR_FSCREATE,
+#endif
 	PROC_PID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
 };
 
@@ -619,8 +633,20 @@ static struct pid_entry base_stuff[] = {
   E(PROC_PID_ROOT,	"root",		S_IFLNK|S_IRWXUGO),
   E(PROC_PID_EXE,	"exe",		S_IFLNK|S_IRWXUGO),
   E(PROC_PID_MOUNTS,	"mounts",	S_IFREG|S_IRUGO),
+#ifdef CONFIG_SECURITY
+  E(PROC_PID_ATTR,	"attr",		S_IFDIR|S_IRUGO|S_IXUGO),
+#endif
+  {0,0,NULL,0}
+};
+#ifdef CONFIG_SECURITY
+static struct pid_entry attr_stuff[] = {
+  E(PROC_PID_ATTR_CURRENT,	"current",	S_IFREG|S_IRUGO|S_IWUGO),
+  E(PROC_PID_ATTR_PREV,	"prev",	S_IFREG|S_IRUGO),
+  E(PROC_PID_ATTR_EXEC,	"exec",	S_IFREG|S_IRUGO|S_IWUGO),
+  E(PROC_PID_ATTR_FSCREATE,	"fscreate",	S_IFREG|S_IRUGO|S_IWUGO),
   {0,0,NULL,0}
 };
+#endif
 #undef E
 
 #define NUMBUF 10
@@ -688,13 +714,16 @@ out:
 	return retval;
 }
 
-static int proc_base_readdir(struct file * filp,
-	void * dirent, filldir_t filldir)
+static int proc_pident_readdir(struct file *filp,
+		void *dirent, filldir_t filldir,
+		struct pid_entry *ents, unsigned int nents)
 {
 	int i;
 	int pid;
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct dentry *dentry = filp->f_dentry;
+	struct inode *inode = dentry->d_inode;
 	struct pid_entry *p;
+	ino_t ino;
 
 	pid = inode->u.proc_i.task->pid;
 	if (!pid)
@@ -702,22 +731,24 @@ static int proc_base_readdir(struct file
 	i = filp->f_pos;
 	switch (i) {
 		case 0:
-			if (filldir(dirent, ".", 1, i, inode->i_ino, DT_DIR) < 0)
+			ino = inode->i_ino;
+			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
 				return 0;
 			i++;
 			filp->f_pos++;
 			/* fall through */
 		case 1:
-			if (filldir(dirent, "..", 2, i, PROC_ROOT_INO, DT_DIR) < 0)
+			ino = dentry->d_parent->d_inode->i_ino;
+			if (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)
 				return 0;
 			i++;
 			filp->f_pos++;
 			/* fall through */
 		default:
 			i -= 2;
-			if (i>=sizeof(base_stuff)/sizeof(base_stuff[0]))
+			if (i >= nents)
 				return 1;
-			p = base_stuff + i;
+			p = ents + i;
 			while (p->name) {
 				if (filldir(dirent, p->name, p->len, filp->f_pos,
 					    fake_ino(pid, p->type), p->mode >> 12) < 0)
@@ -729,6 +760,13 @@ static int proc_base_readdir(struct file
 	return 1;
 }
 
+static int proc_base_readdir(struct file * filp,
+			     void * dirent, filldir_t filldir)
+{
+	return proc_pident_readdir(filp,dirent,filldir,
+				   base_stuff,ARRAY_SIZE(base_stuff));
+}
+
 /* building an inode */
 
 static int task_dumpable(struct task_struct *task)
@@ -774,6 +812,7 @@ static struct inode *proc_pid_make_inode
 		inode->i_uid = task->euid;
 		inode->i_gid = task->egid;
 	}
+	security_task_to_inode(task, inode);
 
 out:
 	return inode;
@@ -797,8 +836,20 @@ static int pid_fd_revalidate(struct dent
  */
 static int pid_base_revalidate(struct dentry * dentry, int flags)
 {
-	if (dentry->d_inode->u.proc_i.task->pid)
+	struct inode *inode = dentry->d_inode;
+	struct task_struct *task = inode->u.proc_i.task;
+	if (task->pid) {
+		if (inode->u.proc_i.type == PROC_PID_INO || 
+		    task_dumpable(task)) {
+			inode->i_uid = task->euid;
+			inode->i_gid = task->egid;
+		} else {
+			inode->i_uid = 0;
+			inode->i_gid = 0;
+		}
+		security_task_to_inode(task, inode);
 		return 1;
+	}
 	d_drop(dentry);
 	return 0;
 }
@@ -904,7 +955,85 @@ static struct inode_operations proc_fd_i
 	permission:	proc_permission,
 };
 
-static struct dentry *proc_base_lookup(struct inode *dir, struct dentry *dentry)
+#ifdef CONFIG_SECURITY
+static ssize_t proc_pid_attr_read(struct file * file, char * buf,
+				  size_t count, loff_t *ppos)
+{
+	struct inode * inode = file->f_dentry->d_inode;
+	unsigned long page;
+	ssize_t length;
+	ssize_t end;
+	struct task_struct *task = inode->u.proc_i.task;
+
+	if (count > PAGE_SIZE)
+		count = PAGE_SIZE;
+	if (!(page = __get_free_page(GFP_KERNEL)))
+		return -ENOMEM;
+
+	length = security_getprocattr(task, 
+				      (char*)file->f_dentry->d_name.name, 
+				      (void*)page, count);
+	if (length < 0) {
+		free_page(page);
+		return length;
+	}
+	/* Static 4kB (or whatever) block capacity */
+	if (*ppos >= length) {
+		free_page(page);
+		return 0;
+	}
+	if (count + *ppos > length)
+		count = length - *ppos;
+	end = count + *ppos;
+	if (copy_to_user(buf, (char *) page + *ppos, count))
+		count = -EFAULT;
+	else
+		*ppos = end;
+	free_page(page);
+	return count;
+}
+
+static ssize_t proc_pid_attr_write(struct file * file, const char * buf,
+				   size_t count, loff_t *ppos)
+{ 
+	struct inode * inode = file->f_dentry->d_inode;
+	char *page; 
+	ssize_t length; 
+	struct task_struct *task = inode->u.proc_i.task; 
+
+	if (count > PAGE_SIZE) 
+		count = PAGE_SIZE; 
+	if (*ppos != 0) {
+		/* No partial writes. */
+		return -EINVAL;
+	}
+	page = (char*)__get_free_page(GFP_USER); 
+	if (!page) 
+		return -ENOMEM;
+	length = -EFAULT; 
+	if (copy_from_user(page, buf, count)) 
+		goto out;
+
+	length = security_setprocattr(task, 
+				      (char*)file->f_dentry->d_name.name, 
+				      (void*)page, count);
+out:
+	free_page((unsigned long) page);
+	return length;
+} 
+
+static struct file_operations proc_pid_attr_operations = {
+	.read		= proc_pid_attr_read,
+	.write		= proc_pid_attr_write,
+};
+
+static struct file_operations proc_attr_operations;
+static struct inode_operations proc_attr_inode_operations;
+#endif
+
+static struct dentry *proc_pident_lookup(struct inode *dir, 
+					 struct dentry *dentry,
+					 struct pid_entry *ents)
 {
 	struct inode *inode;
 	int error;
@@ -914,7 +1043,7 @@ static struct dentry *proc_base_lookup(s
 	error = -ENOENT;
 	inode = NULL;
 
-	for (p = base_stuff; p->name; p++) {
+	for (p = ents; p->name; p++) {
 		if (p->len != dentry->d_name.len)
 			continue;
 		if (!memcmp(dentry->d_name.name, p->name, p->len))
@@ -987,6 +1116,19 @@ static struct dentry *proc_base_lookup(s
 		case PROC_PID_MOUNTS:
 			inode->i_fop = &proc_mounts_operations;
 			break;
+#ifdef CONFIG_SECURITY
+		case PROC_PID_ATTR:
+			inode->i_nlink = 2;
+			inode->i_op = &proc_attr_inode_operations;
+			inode->i_fop = &proc_attr_operations;
+			break;
+		case PROC_PID_ATTR_CURRENT:
+		case PROC_PID_ATTR_PREV:
+		case PROC_PID_ATTR_EXEC:
+		case PROC_PID_ATTR_FSCREATE:
+			inode->i_fop = &proc_pid_attr_operations;
+			break;
+#endif
 		default:
 			printk("procfs: impossible type (%d)",p->type);
 			iput(inode);
@@ -1000,6 +1142,10 @@ out:
 	return ERR_PTR(error);
 }
 
+static struct dentry *proc_base_lookup(struct inode *dir, struct dentry *dentry){
+	return proc_pident_lookup(dir, dentry, base_stuff);
+}
+
 static struct file_operations proc_base_operations = {
 	read:		generic_read_dir,
 	readdir:	proc_base_readdir,
@@ -1009,6 +1155,28 @@ static struct inode_operations proc_base
 	lookup:		proc_base_lookup,
 };
 
+#ifdef CONFIG_SECURITY
+static int proc_attr_readdir(struct file * filp,
+			     void * dirent, filldir_t filldir)
+{
+	return proc_pident_readdir(filp,dirent,filldir,
+				   attr_stuff,ARRAY_SIZE(attr_stuff));
+}
+
+static struct file_operations proc_attr_operations = {
+	.read		= generic_read_dir,
+	.readdir	= proc_attr_readdir,
+};
+
+static struct dentry *proc_attr_lookup(struct inode *dir, struct dentry *dentry){
+	return proc_pident_lookup(dir, dentry, attr_stuff);
+}
+
+static struct inode_operations proc_attr_inode_operations = {
+	.lookup		= proc_attr_lookup,
+};
+#endif
+
 /*
  * /proc/self:
  */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/quota.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/quota.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/quota.c	2003-08-25 14:44:43.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/quota.c	2004-03-02 23:41:24.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/smp_lock.h>
 #include <linux/quotaops.h>
 #include <linux/quotacompat.h>
+#include <linux/security.h>
 
 struct dqstats dqstats;
 
@@ -101,7 +102,7 @@ static int check_quotactl_valid(struct s
 	else if (cmd != Q_GETFMT && cmd != Q_SYNC && cmd != Q_GETINFO && cmd != Q_XGETQSTAT)
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
-	return 0;
+	return security_quotactl (cmd, type, id, sb);
 }
 
 /* Resolve device pathname to superblock */
@@ -314,7 +315,7 @@ static int check_compat_quotactl_valid(s
 	else if (cmd != Q_V1_GETSTATS && cmd != Q_V2_GETSTATS && cmd != Q_V2_GETINFO && cmd != Q_COMP_SYNC)
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
-	return 0;
+	return security_quotactl (cmd, type, id, sb);
 }
 
 static int v1_set_rsquash(struct super_block *sb, int type, int flag)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/readdir.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/readdir.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/readdir.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/readdir.c	2004-03-02 23:41:24.000000000 +0200
@@ -10,6 +10,7 @@
 #include <linux/stat.h>
 #include <linux/file.h>
 #include <linux/smp_lock.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -19,6 +20,11 @@ int vfs_readdir(struct file *file, filld
 	int res = -ENOTDIR;
 	if (!file->f_op || !file->f_op->readdir)
 		goto out;
+
+	res = security_file_permission(file, MAY_READ);
+	if (res)
+		goto out;
+
 	down(&inode->i_sem);
 	down(&inode->i_zombie);
 	res = -ENOENT;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/read_write.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/read_write.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/read_write.c	2003-08-25 14:44:43.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/read_write.c	2004-03-02 23:41:24.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/uio.h>
 #include <linux/smp_lock.h>
 #include <linux/dnotify.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -114,6 +115,7 @@ asmlinkage off_t sys_lseek(unsigned int 
 	file = fget(fd);
 	if (!file)
 		goto bad;
+
 	retval = -EINVAL;
 	if (origin <= 2) {
 		loff_t res = llseek(file, offset, origin);
@@ -139,6 +141,7 @@ asmlinkage long sys_llseek(unsigned int 
 	file = fget(fd);
 	if (!file)
 		goto bad;
+
 	retval = -EINVAL;
 	if (origin > 2)
 		goto out_putf;
@@ -173,8 +176,11 @@ asmlinkage ssize_t sys_read(unsigned int
 			if (!ret) {
 				ssize_t (*read)(struct file *, char *, size_t, loff_t *);
 				ret = -EINVAL;
-				if (file->f_op && (read = file->f_op->read) != NULL)
-					ret = read(file, buf, count, &file->f_pos);
+				if (file->f_op && (read = file->f_op->read) != NULL) {
+					ret = security_file_permission (file, MAY_READ);
+					if (!ret)
+						ret = read(file, buf, count, &file->f_pos);
+				}
 			}
 		}
 		if (ret > 0)
@@ -199,8 +205,11 @@ asmlinkage ssize_t sys_write(unsigned in
 			if (!ret) {
 				ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
 				ret = -EINVAL;
-				if (file->f_op && (write = file->f_op->write) != NULL)
-					ret = write(file, buf, count, &file->f_pos);
+				if (file->f_op && (write = file->f_op->write) != NULL) {
+					ret = security_file_permission (file, MAY_WRITE);
+					if (!ret)
+						ret = write(file, buf, count, &file->f_pos);
+				}
 			}
 		}
 		if (ret > 0)
@@ -338,8 +347,11 @@ asmlinkage ssize_t sys_readv(unsigned lo
 	if (!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_READ) &&
-	    (file->f_op->readv || file->f_op->read))
-		ret = do_readv_writev(VERIFY_WRITE, file, vector, count);
+	    (file->f_op->readv || file->f_op->read)) {
+		ret = security_file_permission (file, MAY_READ);
+		if (!ret)
+			ret = do_readv_writev(VERIFY_WRITE, file, vector, count);
+	}
 	fput(file);
 
 bad_file:
@@ -358,8 +370,11 @@ asmlinkage ssize_t sys_writev(unsigned l
 	if (!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_WRITE) &&
-	    (file->f_op->writev || file->f_op->write))
-		ret = do_readv_writev(VERIFY_READ, file, vector, count);
+	    (file->f_op->writev || file->f_op->write)) {
+		ret = security_file_permission (file, MAY_WRITE);
+		if (!ret)
+			ret = do_readv_writev(VERIFY_READ, file, vector, count);
+	}
 	fput(file);
 
 bad_file:
@@ -392,6 +407,11 @@ asmlinkage ssize_t sys_pread(unsigned in
 		goto out;
 	if (pos < 0)
 		goto out;
+
+	ret = security_file_permission (file, MAY_READ);
+	if (ret)
+		goto out;
+
 	ret = read(file, buf, count, &pos);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_ACCESS);
@@ -424,6 +444,10 @@ asmlinkage ssize_t sys_pwrite(unsigned i
 	if (pos < 0)
 		goto out;
 
+	ret = security_file_permission (file, MAY_WRITE);
+	if (ret)
+		goto out;
+
 	ret = write(file, buf, count, &pos);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_MODIFY);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/stat.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/stat.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/stat.c	2004-02-18 15:36:31.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/stat.c	2004-03-02 23:41:24.000000000 +0200
@@ -10,6 +10,7 @@
 #include <linux/file.h>
 #include <linux/smp_lock.h>
 #include <linux/highuid.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -19,9 +20,14 @@
 static __inline__ int
 do_revalidate(struct dentry *dentry)
 {
+	int error;
 	struct inode * inode = dentry->d_inode;
-	if (inode->i_op && inode->i_op->revalidate)
+	if (inode->i_op && inode->i_op->revalidate) {
+		error = security_inode_revalidate(dentry);
+		if (error)
+			return error;
 		return inode->i_op->revalidate(dentry);
+	}
 	return 0;
 }
 
@@ -36,8 +42,13 @@ static int cp_old_stat(struct inode * in
 {
 	static int warncount = 5;
 	struct __old_kernel_stat tmp;
+	int retval;
 
 	memset(&tmp, 0, sizeof(struct __old_kernel_stat));
+
+	retval = security_inode_stat(inode);
+	if (retval)
+		return retval;
 	
 	if (warncount > 0) {
 		warncount--;
@@ -72,6 +83,11 @@ static int cp_new_stat(struct inode * in
 {
 	struct stat tmp;
 	unsigned int blocks, indirect;
+	int retval;
+
+	retval = security_inode_stat(inode);
+	if (retval)
+		return retval;
 
 	memset(&tmp, 0, sizeof(tmp));
 	tmp.st_dev = kdev_t_to_nr(inode->i_dev);
@@ -260,8 +276,11 @@ asmlinkage long sys_readlink(const char 
 		error = -EINVAL;
 		if (inode->i_op && inode->i_op->readlink &&
 		    !(error = do_revalidate(nd.dentry))) {
-			UPDATE_ATIME(inode);
-			error = inode->i_op->readlink(nd.dentry, buf, bufsiz);
+			error = security_inode_readlink(nd.dentry);
+			if (!error) {
+				UPDATE_ATIME(inode);
+				error = inode->i_op->readlink(nd.dentry, buf, bufsiz);
+			}
 		}
 		path_release(&nd);
 	}
@@ -276,6 +295,11 @@ static long cp_new_stat64(struct inode *
 {
 	struct stat64 tmp;
 	unsigned int blocks, indirect;
+	int retval;
+
+	retval = security_inode_stat(inode);
+	if (retval)
+		return retval;
 
 	memset(&tmp, 0, sizeof(tmp));
 	tmp.st_dev = kdev_t_to_nr(inode->i_dev);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/super.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/super.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/super.c	2003-08-25 14:44:43.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/super.c	2004-03-02 23:41:24.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/major.h>
 #include <linux/acct.h>
 #include <linux/quotaops.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -267,6 +268,11 @@ static struct super_block *alloc_super(v
 	struct super_block *s = kmalloc(sizeof(struct super_block),  GFP_USER);
 	if (s) {
 		memset(s, 0, sizeof(struct super_block));
+		if (security_sb_alloc(s)) {
+			kfree(s);
+			s = NULL;
+			goto out;
+		}
 		INIT_LIST_HEAD(&s->s_dirty);
 		INIT_LIST_HEAD(&s->s_locked_inodes);
 		INIT_LIST_HEAD(&s->s_files);
@@ -285,6 +291,7 @@ static struct super_block *alloc_super(v
 		s->dq_op = sb_dquot_ops;
 		s->s_qcop = sb_quotactl_ops;
 	}
+out:
 	return s;
 }
 
@@ -296,6 +303,7 @@ static struct super_block *alloc_super(v
  */
 static inline void destroy_super(struct super_block *s)
 {
+	security_sb_free(s);
 	kfree(s);
 }
 
@@ -787,12 +795,15 @@ static struct super_block *get_sb_single
 	return s;
 }
 
+void kill_super(struct super_block *sb);
+
 struct vfsmount *
 do_kern_mount(const char *fstype, int flags, char *name, void *data)
 {
 	struct file_system_type *type = get_fs_type(fstype);
 	struct super_block *sb = ERR_PTR(-ENOMEM);
 	struct vfsmount *mnt;
+	int error;
 
 	if (!type)
 		return ERR_PTR(-ENODEV);
@@ -810,6 +821,13 @@ do_kern_mount(const char *fstype, int fl
 		goto out_mnt;
 	if (type->fs_flags & FS_NOMOUNT)
 		sb->s_flags |= MS_NOUSER;
+	error = security_sb_kern_mount(sb);
+	if (error) {
+		up_write(&sb->s_umount);
+		kill_super(sb);
+		sb = ERR_PTR(error);
+		goto out_mnt;
+	}
 	mnt->mnt_sb = sb;
 	mnt->mnt_root = dget(sb->s_root);
 	mnt->mnt_mountpoint = sb->s_root;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/fs/xattr.c 2425sls2.ea.acl.nfsacl.sec.selinux/fs/xattr.c
--- 2425sls2.ea.acl.nfsacl.sec/fs/xattr.c	2004-03-03 00:08:40.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/fs/xattr.c	2004-03-02 23:41:24.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/smp_lock.h>
 #include <linux/file.h>
 #include <linux/xattr.h>
+#include <linux/security.h>
 #include <asm/uaccess.h>
 
 /*
@@ -73,9 +74,6 @@ setxattr(struct dentry *d, char *name, v
 	if (error < 0)
 		return error;
 
-	if (strncmp(kname, "security.", 9) == 0 && !capable(CAP_SYS_ADMIN))
-		return -EPERM;
-
 	kvalue = xattr_alloc(size, XATTR_SIZE_MAX);
 	if (IS_ERR(kvalue))
 		return PTR_ERR(kvalue);
@@ -89,11 +87,16 @@ setxattr(struct dentry *d, char *name, v
 	if (d->d_inode->i_op && d->d_inode->i_op->setxattr) {
 		down(&d->d_inode->i_sem);
 		lock_kernel();
+		error = security_inode_setxattr(d, kname, kvalue, size, flags);
+		if (error)
+			goto out;
 		error = d->d_inode->i_op->setxattr(d, kname, kvalue, size, flags);
+		if (!error)
+			security_inode_post_setxattr(d, kname, kvalue, size, flags);
+out:
 		unlock_kernel();
 		up(&d->d_inode->i_sem);
 	}
-
 	xattr_free(kvalue, size);
 	return error;
 }
@@ -162,6 +165,9 @@ getxattr(struct dentry *d, char *name, v
 
 	error = -EOPNOTSUPP;
 	if (d->d_inode->i_op && d->d_inode->i_op->getxattr) {
+		error = security_inode_getxattr(d, kname);
+		if (error)
+			goto out;
 		lock_kernel();
 		error = d->d_inode->i_op->getxattr(d, kname, kvalue, size);
 		unlock_kernel();
@@ -170,6 +176,7 @@ getxattr(struct dentry *d, char *name, v
 	if (kvalue && error > 0)
 		if (copy_to_user(value, kvalue, error))
 			error = -EFAULT;
+out:
 	xattr_free(kvalue, size);
 	return error;
 }
@@ -231,6 +238,9 @@ listxattr(struct dentry *d, char *list, 
 
 	error = -EOPNOTSUPP;
 	if (d->d_inode->i_op && d->d_inode->i_op->listxattr) {
+		error = security_inode_listxattr(d);
+		if (error)
+			goto out;
 		lock_kernel();
 		error = d->d_inode->i_op->listxattr(d, klist, size);
 		unlock_kernel();
@@ -239,6 +249,7 @@ listxattr(struct dentry *d, char *list, 
 	if (klist && error > 0)
 		if (copy_to_user(list, klist, error))
 			error = -EFAULT;
+out:
 	xattr_free(klist, size);
 	return error;
 }
@@ -300,17 +311,18 @@ removexattr(struct dentry *d, char *name
 	if (error < 0)
 		return error;
 
-	if (strncmp(kname, "security.", 9) == 0 && !capable(CAP_SYS_ADMIN))
-		return -EPERM;
-
 	error = -EOPNOTSUPP;
 	if (d->d_inode->i_op && d->d_inode->i_op->removexattr) {
+		error = security_inode_removexattr(d, kname);
+		if (error)
+			goto out;
 		down(&d->d_inode->i_sem);
 		lock_kernel();
 		error = d->d_inode->i_op->removexattr(d, kname);
 		unlock_kernel();
 		up(&d->d_inode->i_sem);
 	}
+out:
 	return error;
 }
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/binfmts.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/binfmts.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/binfmts.h	2004-03-02 19:52:23.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/binfmts.h	2004-03-02 23:41:24.000000000 +0200
@@ -27,6 +27,7 @@ struct linux_binprm{
 	struct file * file;
 	int e_uid, e_gid;
 	kernel_cap_t cap_inheritable, cap_permitted, cap_effective;
+	void *security;
 	int argc, envc;
 	char * filename;	/* Name of binary */
 	unsigned long loader, exec;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/elf.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/elf.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/elf.h	2004-03-02 19:55:29.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/elf.h	2004-03-02 23:41:24.000000000 +0200
@@ -179,6 +179,8 @@ typedef __s64	Elf64_Sxword;
 #define AT_HWCAP  16    /* arch dependent hints at CPU capabilities */
 #define AT_CLKTCK 17	/* frequency at which times() increments */
 
+#define AT_SECURE 23   /* secure mode boolean */
+
 typedef struct dynamic{
   Elf32_Sword d_tag;
   union{
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/fs.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/fs.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/fs.h	2004-03-02 23:20:51.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/fs.h	2004-03-02 23:41:24.000000000 +0200
@@ -70,6 +70,7 @@ extern int leases_enable, dir_notify_ena
 #define MAY_EXEC 1
 #define MAY_WRITE 2
 #define MAY_READ 4
+#define MAY_APPEND 8
 
 #define FMODE_READ 1
 #define FMODE_WRITE 2
@@ -491,6 +492,7 @@ struct inode {
 
 	atomic_t		i_writecount;
 	unsigned int		i_attr_flags;
+	void			*i_security;
 	__u32			i_generation;
 	union {
 		struct minix_inode_info		minix_i;
@@ -562,6 +564,7 @@ struct fown_struct {
 	int pid;		/* pid or -pgrp where SIGIO should be sent */
 	uid_t uid, euid;	/* uid/euid of process setting the owner */
 	int signum;		/* posix.1b rt signal to be delivered on IO */
+	void *security;
 };
 
 struct file {
@@ -579,6 +582,7 @@ struct file {
 	int			f_error;
 
 	unsigned long		f_version;
+	void			*f_security;
 
 	/* needed for tty driver, and maybe others */
 	void			*private_data;
@@ -594,7 +598,10 @@ extern spinlock_t files_lock;
 #define get_file(x)	atomic_inc(&(x)->f_count)
 #define file_count(x)	atomic_read(&(x)->f_count)
 
-extern int init_private_file(struct file *, struct dentry *, int);
+/* Initialize and open a private file and allocate its security structure. */
+extern int open_private_file(struct file *, struct dentry *, int);
+/* Release a private file and free its security structure. */
+extern void close_private_file(struct file *file);
 
 #define	MAX_NON_LFS	((1UL<<31) - 1)
 
@@ -658,11 +665,11 @@ extern struct list_head file_lock_list;
 
 #include <linux/fcntl.h>
 
-extern int fcntl_getlk(unsigned int, struct flock *);
-extern int fcntl_setlk(unsigned int, unsigned int, struct flock *);
+extern int fcntl_getlk(struct file *, struct flock *);
+extern int fcntl_setlk(struct file *, unsigned int, struct flock *);
 
-extern int fcntl_getlk64(unsigned int, struct flock64 *);
-extern int fcntl_setlk64(unsigned int, unsigned int, struct flock64 *);
+extern int fcntl_getlk64(struct file *, struct flock64 *);
+extern int fcntl_setlk64(struct file *, unsigned int, struct flock64 *);
 
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);
@@ -759,6 +766,7 @@ struct super_block {
 	struct semaphore	s_lock;
 	int			s_count;
 	atomic_t		s_active;
+	void                    *s_security;
 
 	struct list_head	s_dirty;	/* dirty inodes */
 	struct list_head	s_locked_inodes;/* inodes being synced */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/init.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/init.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/init.h	2004-03-02 19:52:23.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/init.h	2004-03-02 23:41:24.000000000 +0200
@@ -49,12 +49,16 @@ typedef int (*initcall_t)(void);
 typedef void (*exitcall_t)(void);
 
 extern initcall_t __initcall_start, __initcall_end;
+extern initcall_t __security_initcall_start, __security_initcall_end;
 
 #define __initcall(fn)								\
 	static initcall_t __initcall_##fn __init_call = fn
 #define __exitcall(fn)								\
 	static exitcall_t __exitcall_##fn __exit_call = fn
 
+#define security_initcall(fn) \
+	static initcall_t __initcall_##fn __attribute__ ((unused,__section__ (".security_initcall.init"))) = fn
+
 /*
  * Used for kernel command line parameter setup
  */
@@ -118,6 +122,8 @@ extern struct kernel_param __setup_start
 #define __initdata
 #define __exitdata
 #define __initcall(fn)
+#define __security_initcall(fn)
+
 /* For assembly routines */
 #define __INIT
 #define __FINIT
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/input.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/input.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/input.h	2004-03-02 20:05:11.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/input.h	2004-03-02 23:41:24.000000000 +0200
@@ -475,7 +475,7 @@ struct input_event {
 #define BUS_HIL			0x04
 #define BUS_BLUETOOTH		0x05
 
-#define BUS_ISA			0x10
+/* #define BUS_ISA			0x10   conflicts with sysctl.h */
 #define BUS_I8042		0x11
 #define BUS_XTKBD		0x12
 #define BUS_RS232		0x13
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/ipc.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/ipc.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/ipc.h	2004-03-02 19:52:23.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/ipc.h	2004-03-02 23:41:24.000000000 +0200
@@ -63,6 +63,7 @@ struct kern_ipc_perm
 	gid_t		cgid;
 	mode_t		mode; 
 	unsigned long	seq;
+	void		*security;
 };
 
 #endif /* __KERNEL__ */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/ip.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/ip.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/ip.h	2004-03-02 19:55:04.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/ip.h	2004-03-02 23:41:24.000000000 +0200
@@ -58,6 +58,7 @@
 #define IPOPT_SEC	(2 |IPOPT_CONTROL|IPOPT_COPY)
 #define IPOPT_LSRR	(3 |IPOPT_CONTROL|IPOPT_COPY)
 #define IPOPT_TIMESTAMP	(4 |IPOPT_MEASUREMENT)
+#define IPOPT_CIPSO	(6 |IPOPT_CONTROL|IPOPT_COPY)
 #define IPOPT_RR	(7 |IPOPT_CONTROL)
 #define IPOPT_SID	(8 |IPOPT_CONTROL|IPOPT_COPY)
 #define IPOPT_SSRR	(9 |IPOPT_CONTROL|IPOPT_COPY)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/msg.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/msg.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/msg.h	2004-03-02 19:57:36.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/msg.h	2004-03-02 23:41:24.000000000 +0200
@@ -63,6 +63,36 @@ struct msginfo {
 
 #ifdef __KERNEL__
 
+/* one msg_msg structure for each message */
+struct msg_msg {
+	struct list_head m_list; 
+	long  m_type;          
+	int m_ts;           /* message text size */
+	struct msg_msgseg* next;
+	void *security;
+	/* the actual message follows immediately */
+};
+
+#define DATALEN_MSG	(PAGE_SIZE-sizeof(struct msg_msg))
+#define DATALEN_SEG	(PAGE_SIZE-sizeof(struct msg_msgseg))
+
+/* one msq_queue structure for each present queue on the system */
+struct msg_queue {
+	struct kern_ipc_perm q_perm;
+	time_t q_stime;			/* last msgsnd time */
+	time_t q_rtime;			/* last msgrcv time */
+	time_t q_ctime;			/* last change time */
+	unsigned long q_cbytes;		/* current number of bytes on queue */
+	unsigned long q_qnum;		/* number of messages in queue */
+	unsigned long q_qbytes;		/* max number of bytes on queue */
+	pid_t q_lspid;			/* pid of last msgsnd */
+	pid_t q_lrpid;			/* last receive pid */
+
+	struct list_head q_messages;
+	struct list_head q_receivers;
+	struct list_head q_senders;
+};
+
 asmlinkage long sys_msgget (key_t key, int msgflg);
 asmlinkage long sys_msgsnd (int msqid, struct msgbuf *msgp, size_t msgsz, int msgflg);
 asmlinkage long sys_msgrcv (int msqid, struct msgbuf *msgp, size_t msgsz, long msgtyp, int msgflg);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/netdevice.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/netdevice.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/netdevice.h	2004-03-02 19:55:15.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/netdevice.h	2004-03-02 23:41:24.000000000 +0200
@@ -452,6 +452,9 @@ struct net_device
 	/* this will get initialized at each interface type init routine */
 	struct divert_blk	*divert;
 #endif /* CONFIG_NET_DIVERT */
+#ifdef CONFIG_SECURITY_NETWORK
+	void			*security;
+#endif
 };
 
 /* 2.6 compatibility */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/sched.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/sched.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/sched.h	2004-03-02 19:52:23.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/sched.h	2004-03-02 23:41:24.000000000 +0200
@@ -407,6 +407,8 @@ struct task_struct {
 	void *notifier_data;
 	sigset_t *notifier_mask;
 	
+	void *security;
+
 /* Thread group tracking */
    	u32 parent_exec_id;
    	u32 self_exec_id;
@@ -739,20 +741,19 @@ static inline int fsuser(void)
  * New privilege checks should use this interface, rather than suser() or
  * fsuser(). See include/linux/capability.h for defined capabilities.
  */
-
+#ifdef CONFIG_SECURITY
+/* code is in security.c */
+extern int capable(int cap);
+#else
 static inline int capable(int cap)
 {
-#if 1 /* ok now */
-	if (cap_raised(current->cap_effective, cap))
-#else
-	if (cap_is_fs_cap(cap) ? current->fsuid == 0 : current->euid == 0)
-#endif
-	{
+	if (cap_raised(current->cap_effective, cap)) {
 		current->flags |= PF_SUPERPRIV;
 		return 1;
 	}
 	return 0;
 }
+#endif
 
 /*
  * Routines for handling mm_structs
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/security.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/security.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/security.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/security.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,3336 @@
+/*
+ * Linux Security plug
+ *
+ * Copyright (C) 2001 WireX Communications, Inc <chris@wirex.com>
+ * Copyright (C) 2001 Greg Kroah-Hartman <greg@kroah.com>
+ * Copyright (C) 2001 Networks Associates Technology, Inc <ssmalley@nai.com>
+ * Copyright (C) 2001 James Morris <jmorris@intercode.com.au>
+ * Copyright (C) 2001 Silicon Graphics, Inc. (Trust Technology Group)
+ * Copyright (C) 2002 International Business Machines <robb@austin.ibm.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	Due to this file being licensed under the GPL there is controversy over
+ *	whether this permits you to write a module that #includes this file
+ *	without placing your module under the GPL.  Please consult a lawyer for
+ *	advice before doing this.
+ *
+ */
+
+#ifndef __LINUX_SECURITY_H
+#define __LINUX_SECURITY_H
+
+#include <linux/fs.h>
+#include <linux/binfmts.h>
+#include <linux/signal.h>
+#include <linux/resource.h>
+#include <linux/sem.h>
+#include <linux/sysctl.h>
+#include <linux/shm.h>
+#include <linux/msg.h>
+#include <linux/time.h>
+#include <linux/sched.h>
+
+/*
+ * These functions are in security/capability.c and are used
+ * as the default capabilities functions
+ */
+extern int cap_capable (struct task_struct *tsk, int cap);
+struct sk_buff;
+extern int cap_netlink_send (struct sk_buff *skb);
+extern int cap_netlink_recv (struct sk_buff *skb);
+extern int cap_ip_decode_options (struct sk_buff *skb, const char *optptr,
+				  unsigned char **pp_ptr);
+extern int cap_ptrace (struct task_struct *parent, struct task_struct *child);
+extern int cap_capget (struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable, kernel_cap_t *permitted);
+extern int cap_capset_check (struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable, kernel_cap_t *permitted);
+extern void cap_capset_set (struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable, kernel_cap_t *permitted);
+extern int cap_bprm_set_security (struct linux_binprm *bprm);
+extern void cap_bprm_compute_creds (struct linux_binprm *bprm);
+extern int cap_bprm_secureexec(struct linux_binprm *bprm);
+extern int cap_task_post_setuid (uid_t old_ruid, uid_t old_euid, uid_t old_suid, int flags);
+extern void cap_task_kmod_set_label (void);
+extern void cap_task_reparent_to_init (struct task_struct *p);
+extern int cap_syslog (int type);
+
+/*
+ * Values used in the task_security_ops calls
+ */
+/* setuid or setgid, id0 == uid or gid */
+#define LSM_SETID_ID	1
+
+/* setreuid or setregid, id0 == real, id1 == eff */
+#define LSM_SETID_RE	2
+
+/* setresuid or setresgid, id0 == real, id1 == eff, uid2 == saved */
+#define LSM_SETID_RES	4
+
+/* setfsuid or setfsgid, id0 == fsuid or fsgid */
+#define LSM_SETID_FS	8
+
+/* forward declares to avoid warnings */
+struct socket;
+struct sock;
+struct sockaddr;
+struct msghdr;
+struct net_device;
+struct nfsctl_arg;
+struct sched_param;
+struct swap_info_struct;
+struct open_request;
+
+#ifdef CONFIG_SECURITY
+
+/**
+ * struct security_operations - main security structure
+ * Security hooks for program execution operations.
+ *
+ * @bprm_alloc_security:
+ *	Allocate and attach a security structure to the @bprm->security field.
+ *	The security field is initialized to NULL when the bprm structure is
+ *	allocated.
+ *	@bprm contains the linux_binprm structure to be modified.
+ *	Return 0 if operation was successful.
+ * @bprm_free_security:
+ *	@bprm contains the linux_binprm structure to be modified.
+ *	Deallocate and clear the @bprm->security field.
+ * @bprm_compute_creds:
+ *	Compute and set the security attributes of a process being transformed
+ *	by an execve operation based on the old attributes (current->security)
+ *	and the information saved in @bprm->security by the set_security hook.
+ *	Since this hook function (and its caller) are void, this hook can not
+ *	return an error.  However, it can leave the security attributes of the
+ *	process unchanged if an access failure occurs at this point. It can
+ *	also perform other state changes on the process (e.g.  closing open
+ *	file descriptors to which access is no longer granted if the attributes
+ *	were changed). 
+ *	@bprm contains the linux_binprm structure.
+ * @bprm_set_security:
+ *	Save security information in the bprm->security field, typically based
+ *	on information about the bprm->file, for later use by the compute_creds
+ *	hook.  This hook may also optionally check permissions (e.g. for
+ *	transitions between security domains).
+ *	This hook may be called multiple times during a single execve, e.g. for
+ *	interpreters.  The hook can tell whether it has already been called by
+ *	checking to see if @bprm->security is non-NULL.  If so, then the hook
+ *	may decide either to retain the security information saved earlier or
+ *	to replace it.
+ *	@bprm contains the linux_binprm structure.
+ *	Return 0 if the hook is successful and permission is granted.
+ * @bprm_check_security:
+ * 	This hook mediates the point when a search for a binary handler	will
+ * 	begin.  It allows a check the @bprm->security value which is set in
+ * 	the preceding set_security call.  The primary difference from
+ * 	set_security is that the argv list and envp list are reliably
+ * 	available in @bprm.  This hook may be called multiple times
+ * 	during a single execve; and in each pass set_security is called
+ * 	first.
+ * 	@bprm contains the linux_binprm structure.
+ *	Return 0 if the hook is successful and permission is granted.
+ * @bprm_secureexec:
+ *      Return a boolean value (0 or 1) indicating whether a "secure exec" 
+ *      is required.  The flag is passed in the auxiliary table
+ *      on the initial stack to the ELF interpreter to indicate whether libc 
+ *      should enable secure mode.
+ *      @bprm contains the linux_binprm structure.
+ *
+ * Security hooks for filesystem operations.
+ *
+ * @sb_alloc_security:
+ *	Allocate and attach a security structure to the sb->s_security field.
+ *	The s_security field is initialized to NULL when the structure is
+ *	allocated.
+ *	@sb contains the super_block structure to be modified.
+ *	Return 0 if operation was successful.
+ * @sb_free_security:
+ *	Deallocate and clear the sb->s_security field.
+ *	@sb contains the super_block structure to be modified.
+ * @sb_statfs:
+ *	Check permission before obtaining filesystem statistics for the @sb
+ *	filesystem.
+ *	@sb contains the super_block structure for the filesystem.
+ *	Return 0 if permission is granted.  
+ * @sb_mount:
+ *	Check permission before an object specified by @dev_name is mounted on
+ *	the mount point named by @nd.  For an ordinary mount, @dev_name
+ *	identifies a device if the file system type requires a device.  For a
+ *	remount (@flags & MS_REMOUNT), @dev_name is irrelevant.  For a
+ *	loopback/bind mount (@flags & MS_BIND), @dev_name identifies the
+ *	pathname of the object being mounted.
+ *	@dev_name contains the name for object being mounted.
+ *	@nd contains the nameidata structure for mount point object.
+ *	@type contains the filesystem type.
+ *	@flags contains the mount flags.
+ *	@data contains the filesystem-specific data.
+ *	Return 0 if permission is granted.
+ * @sb_check_sb:
+ *	Check permission before the device with superblock @mnt->sb is mounted
+ *	on the mount point named by @nd.
+ *	@mnt contains the vfsmount for device being mounted.
+ *	@nd contains the nameidata object for the mount point.
+ *	Return 0 if permission is granted.
+ * @sb_umount:
+ *	Check permission before the @mnt file system is unmounted.
+ *	@mnt contains the mounted file system.
+ *	@flags contains the unmount flags, e.g. MNT_FORCE.
+ *	Return 0 if permission is granted.
+ * @sb_umount_close:
+ *	Close any files in the @mnt mounted filesystem that are held open by
+ *	the security module.  This hook is called during an umount operation
+ *	prior to checking whether the filesystem is still busy.
+ *	@mnt contains the mounted filesystem.
+ * @sb_umount_busy:
+ *	Handle a failed umount of the @mnt mounted filesystem, e.g.  re-opening
+ *	any files that were closed by umount_close.  This hook is called during
+ *	an umount operation if the umount fails after a call to the
+ *	umount_close hook.
+ *	@mnt contains the mounted filesystem.
+ * @sb_post_remount:
+ *	Update the security module's state when a filesystem is remounted.
+ *	This hook is only called if the remount was successful.
+ *	@mnt contains the mounted file system.
+ *	@flags contains the new filesystem flags.
+ *	@data contains the filesystem-specific data.
+ * @sb_post_mountroot:
+ *	Update the security module's state when the root filesystem is mounted.
+ *	This hook is only called if the mount was successful.
+ * @sb_post_addmount:
+ *	Update the security module's state when a filesystem is mounted.
+ *	This hook is called any time a mount is successfully grafetd to
+ *	the tree.
+ *	@mnt contains the mounted filesystem.
+ *	@mountpoint_nd contains the nameidata structure for the mount point.
+ * @sb_pivotroot:
+ *	Check permission before pivoting the root filesystem.
+ *	@old_nd contains the nameidata structure for the new location of the current root (put_old).
+ *      @new_nd contains the nameidata structure for the new root (new_root).
+ *	Return 0 if permission is granted.
+ * @sb_post_pivotroot:
+ *	Update module state after a successful pivot.
+ *	@old_nd contains the nameidata structure for the old root.
+ *      @new_nd contains the nameidata structure for the new root.
+ *
+ * Security hooks for inode operations.
+ *
+ * @inode_alloc_security:
+ *	Allocate and attach a security structure to @inode->i_security.  The
+ *	i_security field is initialized to NULL when the inode structure is
+ *	allocated.
+ *	@inode contains the inode structure.
+ *	Return 0 if operation was successful.
+ * @inode_free_security:
+ *	@inode contains the inode structure.
+ *	Deallocate the inode security structure and set @inode->i_security to
+ *	NULL. 
+ * @inode_create:
+ *	Check permission to create a regular file.
+ *	@dir contains inode structure of the parent of the new file.
+ *	@dentry contains the dentry structure for the file to be created.
+ *	@mode contains the file mode of the file to be created.
+ *	Return 0 if permission is granted.
+ * @inode_post_create:
+ *	Set the security attributes on a newly created regular file.  This hook
+ *	is called after a file has been successfully created.
+ *	@dir contains the inode structure of the parent directory of the new file.
+ *	@dentry contains the the dentry structure for the newly created file.
+ *	@mode contains the file mode.
+ * @inode_link:
+ *	Check permission before creating a new hard link to a file.
+ *	@old_dentry contains the dentry structure for an existing link to the file.
+ *	@dir contains the inode structure of the parent directory of the new link.
+ *	@new_dentry contains the dentry structure for the new link.
+ *	Return 0 if permission is granted.
+ * @inode_post_link:
+ *	Set security attributes for a new hard link to a file.
+ *	@old_dentry contains the dentry structure for the existing link.
+ *	@dir contains the inode structure of the parent directory of the new file.
+ *	@new_dentry contains the dentry structure for the new file link.
+ * @inode_unlink:
+ *	Check the permission to remove a hard link to a file. 
+ *	@dir contains the inode structure of parent directory of the file.
+ *	@dentry contains the dentry structure for file to be unlinked.
+ *	Return 0 if permission is granted.
+ * @inode_symlink:
+ *	Check the permission to create a symbolic link to a file.
+ *	@dir contains the inode structure of parent directory of the symbolic link.
+ *	@dentry contains the dentry structure of the symbolic link.
+ *	@old_name contains the pathname of file.
+ *	Return 0 if permission is granted.
+ * @inode_post_symlink:
+ *	@dir contains the inode structure of the parent directory of the new link.
+ *	@dentry contains the dentry structure of new symbolic link.
+ *	@old_name contains the pathname of file.
+ *	Set security attributes for a newly created symbolic link.  Note that
+ *	@dentry->d_inode may be NULL, since the filesystem might not
+ *	instantiate the dentry (e.g. NFS).
+ * @inode_mkdir:
+ *	Check permissions to create a new directory in the existing directory
+ *	associated with inode strcture @dir. 
+ *	@dir containst the inode structure of parent of the directory to be created.
+ *	@dentry contains the dentry structure of new directory.
+ *	@mode contains the mode of new directory.
+ *	Return 0 if permission is granted.
+ * @inode_post_mkdir:
+ *	Set security attributes on a newly created directory.
+ *	@dir contains the inode structure of parent of the directory to be created.
+ *	@dentry contains the dentry structure of new directory.
+ *	@mode contains the mode of new directory.
+ * @inode_rmdir:
+ *	Check the permission to remove a directory.
+ *	@dir contains the inode structure of parent of the directory to be removed.
+ *	@dentry contains the dentry structure of directory to be removed.
+ *	Return 0 if permission is granted.
+ * @inode_mknod:
+ *	Check permissions when creating a special file (or a socket or a fifo
+ *	file created via the mknod system call).  Note that if mknod operation
+ *	is being done for a regular file, then the create hook will be called
+ *	and not this hook.
+ *	@dir contains the inode structure of parent of the new file.
+ *	@dentry contains the dentry structure of the new file.
+ *	@mode contains the mode of the new file.
+ *	@dev contains the the device number.
+ *	Return 0 if permission is granted.
+ * @inode_post_mknod:
+ *	Set security attributes on a newly created special file (or socket or
+ *	fifo file created via the mknod system call).
+ *	@dir contains the inode structure of parent of the new node.
+ *	@dentry contains the dentry structure of the new node.
+ *	@mode contains the mode of the new node.
+ *	@dev contains the the device number.
+ * @inode_rename:
+ *	Check for permission to rename a file or directory.
+ *	@old_dir contains the inode structure for parent of the old link.
+ *	@old_dentry contains the dentry structure of the old link.
+ *	@new_dir contains the inode structure for parent of the new link.
+ *	@new_dentry contains the dentry structure of the new link.
+ *	Return 0 if permission is granted.
+ * @inode_post_rename:
+ *	Set security attributes on a renamed file or directory.
+ *	@old_dir contains the inode structure for parent of the old link.
+ *	@old_dentry contains the dentry structure of the old link.
+ *	@new_dir contains the inode structure for parent of the new link.
+ *	@new_dentry contains the dentry structure of the new link.
+ * @inode_readlink:
+ *	Check the permission to read the symbolic link.
+ *	@dentry contains the dentry structure for the file link.
+ *	Return 0 if permission is granted.
+ * @inode_follow_link:
+ *	Check permission to follow a symbolic link when looking up a pathname.
+ *	@dentry contains the dentry structure for the link.
+ *	@nd contains the nameidata structure for the parent directory.
+ *	Return 0 if permission is granted.
+ * @inode_permission:
+ *	Check permission before accessing an inode.  This hook is called by the
+ *	existing Linux permission function, so a security module can use it to
+ *	provide additional checking for existing Linux permission checks.
+ *	Notice that this hook is called when a file is opened (as well as many
+ *	other operations), whereas the file_security_ops permission hook is
+ *	called when the actual read/write operations are performed.
+ *	@inode contains the inode structure to check.
+ *	@mask contains the permission mask.
+ *	Return 0 if permission is granted.
+ * @inode_revalidate:
+ *	Revalidate the inode attributes.  This hook can be used by a security
+ *	module to revalidate the attributes stored in the i_security field to
+ *	maintain consistency when the file is remote.
+ *	@dentry contains the dentry structure associated with the inode.
+ *	Return 0 if successful.
+ * @inode_setattr:
+ *	Check permission before setting file attributes.  Note that the kernel
+ *	call to notify_change is performed from several locations, whenever
+ *	file attributes change (such as when a file is truncated, chown/chmod
+ *	operations, transferring disk quotas, etc).
+ *	@dentry contains the dentry structure for the file.
+ *	@attr is the iattr structure containing the new file attributes.
+ *	Return 0 if permission is granted.
+ * @inode_stat:
+ *	Check permission before obtaining file attributes.
+ *	@inode contains the inode structure for the file.
+ *	Return 0 if permission is granted.
+ * @inode_delete:
+ *	@inode contains the inode structure for deleted inode.
+ *	This hook is called when a deleted inode is released (i.e. an inode
+ *	with no hard links has its use count drop to zero).  A security module
+ *	can use this hook to release any persistent label associated with the
+ *	inode.
+ * @inode_setxattr:
+ * 	Check permission before setting the extended attributes
+ * 	@value identified by @name for @dentry.
+ * 	Return 0 if permission is granted.
+ * @inode_post_setxattr:
+ * 	Update inode security field after successful setxattr operation.
+ * 	@value identified by @name for @dentry.
+ * @inode_getxattr:
+ * 	Check permission before obtaining the extended attributes
+ * 	identified by @name for @dentry.
+ * 	Return 0 if permission is granted.
+ * @inode_listxattr:
+ * 	Check permission before obtaining the list of extended attribute 
+ * 	names for @dentry.
+ * 	Return 0 if permission is granted.
+ * @inode_removexattr:
+ * 	Check permission before removing the extended attribute
+ * 	identified by @name for @dentry.
+ * 	Return 0 if permission is granted.
+ * @inode_getsecurity:
+ *	Copy the extended attribute representation of the security label 
+ *	associated with @name for @dentry into @buffer.  @buffer may be 
+ *	NULL to request the size of the buffer required.  @size indicates
+ *	the size of @buffer in bytes.  Note that @name is the remainder
+ *	of the attribute name after the security. prefix has been removed.
+ *	Return number of bytes used/required on success.
+ * @inode_setsecurity:
+ *	Set the security label associated with @name for @dentry from the 
+ *	extended attribute value @value.  @size indicates the size of the
+ *	@value in bytes.  @flags may be XATTR_CREATE, XATTR_REPLACE, or 0.
+ *	Note that @name is the remainder of the attribute name after the 
+ *	security. prefix has been removed.
+ *	Return 0 on success.
+ * @inode_listsecurity:
+ *	Copy the extended attribute names for the security labels
+ *	associated with @dentry into @buffer.  @buffer may be NULL to 
+ *	request the size of the buffer required.  
+ *	Returns number of bytes used/required on success.
+ *
+ * Security hooks for file operations
+ *
+ * @file_permission:
+ *	Check file permissions before accessing an open file.  This hook is
+ *	called by various operations that read or write files.  A security
+ *	module can use this hook to perform additional checking on these
+ *	operations, e.g.  to revalidate permissions on use to support privilege
+ *	bracketing or policy changes.  Notice that this hook is used when the
+ *	actual read/write operations are performed, whereas the
+ *	inode_security_ops hook is called when a file is opened (as well as
+ *	many other operations).
+ *	Caveat:  Although this hook can be used to revalidate permissions for
+ *	various system call operations that read or write files, it does not
+ *	address the revalidation of permissions for memory-mapped files.
+ *	Security modules must handle this separately if they need such
+ *	revalidation.
+ *	@file contains the file structure being accessed.
+ *	@mask contains the requested permissions.
+ *	Return 0 if permission is granted.
+ * @file_alloc_security:
+ *	Allocate and attach a security structure to the file->f_security field.
+ *	The security field is initialized to NULL when the structure is first
+ *	created.
+ *	@file contains the file structure to secure.
+ *	Return 0 if the hook is successful and permission is granted.
+ * @file_free_security:
+ *	Deallocate and free any security structures stored in file->f_security.
+ *	@file contains the file structure being modified.
+ * @file_ioctl:
+ *	@file contains the file structure.
+ *	@cmd contains the operation to perform.
+ *	@arg contains the operational arguments.
+ *	Check permission for an ioctl operation on @file.  Note that @arg can
+ *	sometimes represents a user space pointer; in other cases, it may be a
+ *	simple integer value.  When @arg represents a user space pointer, it
+ *	should never be used by the security module.
+ *	Return 0 if permission is granted.
+ * @file_mmap :
+ *	Check permissions for a mmap operation.  The @file may be NULL, e.g.
+ *	if mapping anonymous memory.
+ *	@file contains the file structure for file to map (may be NULL).
+ *	@prot contains the requested permissions.
+ *	@flags contains the operational flags.
+ *	Return 0 if permission is granted.
+ * @file_mprotect:
+ *	Check permissions before changing memory access permissions.
+ *	@vma contains the memory region to modify.
+ *	@prot contains the requested permissions.
+ *	Return 0 if permission is granted.
+ * @file_lock:
+ *	Check permission before performing file locking operations.
+ *	Note: this hook mediates both flock and fcntl style locks.
+ *	@file contains the file structure.
+ *	@cmd contains the posix-translated lock operation to perform
+ *	(e.g. F_RDLCK, F_WRLCK).
+ *	Return 0 if permission is granted.
+ * @file_fcntl:
+ *	Check permission before allowing the file operation specified by @cmd
+ *	from being performed on the file @file.  Note that @arg can sometimes
+ *	represents a user space pointer; in other cases, it may be a simple
+ *	integer value.  When @arg represents a user space pointer, it should
+ *	never be used by the security module.
+ *	@file contains the file structure.
+ *	@cmd contains the operation to be performed.
+ *	@arg contains the operational arguments.
+ *	Return 0 if permission is granted.
+ * @file_set_fowner:
+ *	Save owner security information (typically from current->security) in
+ *	file->f_security for later use by the send_sigiotask hook.
+ *	@file contains the file structure to update.
+ *	Return 0 on success.
+ * @file_send_sigiotask:
+ *	Check permission for the file owner @fown to send SIGIO to the process
+ *	@tsk.  Note that this hook is always called from interrupt.  Note that
+ *	the fown_struct, @fown, is never outside the context of a struct file,
+ *	so the file structure (and associated security information) can always
+ *	be obtained:
+ *		(struct file *)((long)fown - offsetof(struct file,f_owner));
+ * 	@tsk contains the structure of task receiving signal.
+ *	@fown contains the file owner information.
+ *	@fd contains the file descriptor.
+ *	@reason contains the operational flags.
+ *	Return 0 if permission is granted.
+ * @file_receive:
+ *	This hook allows security modules to control the ability of a process
+ *	to receive an open file descriptor via socket IPC.
+ *	@file contains the file structure being received.
+ *	Return 0 if permission is granted.
+ *
+ * Security hooks for task operations.
+ *
+ * @task_create:
+ *	Check permission before creating a child process.  See the clone(2)
+ *	manual page for definitions of the @clone_flags.
+ *	@clone_flags contains the flags indicating what should be shared.
+ *	Return 0 if permission is granted.
+ * @task_alloc_security:
+ *	@p contains the task_struct for child process.
+ *	Allocate and attach a security structure to the p->security field. The
+ *	security field is initialized to NULL when the task structure is
+ *	allocated.
+ *	Return 0 if operation was successful.
+ * @task_free_security:
+ *	@p contains the task_struct for process.
+ *	Deallocate and clear the p->security field.
+ * @task_setuid:
+ *	Check permission before setting one or more of the user identity
+ *	attributes of the current process.  The @flags parameter indicates
+ *	which of the set*uid system calls invoked this hook and how to
+ *	interpret the @id0, @id1, and @id2 parameters.  See the LSM_SETID
+ *	definitions at the beginning of this file for the @flags values and
+ *	their meanings.
+ *	@id0 contains a uid.
+ *	@id1 contains a uid.
+ *	@id2 contains a uid.
+ *	@flags contains one of the LSM_SETID_* values.
+ *	Return 0 if permission is granted.
+ * @task_post_setuid:
+ *	Update the module's state after setting one or more of the user
+ *	identity attributes of the current process.  The @flags parameter
+ *	indicates which of the set*uid system calls invoked this hook.  If
+ *	@flags is LSM_SETID_FS, then @old_ruid is the old fs uid and the other
+ *	parameters are not used.
+ *	@old_ruid contains the old real uid (or fs uid if LSM_SETID_FS).
+ *	@old_euid contains the old effective uid (or -1 if LSM_SETID_FS).
+ *	@old_suid contains the old saved uid (or -1 if LSM_SETID_FS).
+ *	@flags contains one of the LSM_SETID_* values.
+ *	Return 0 on success.
+ * @task_setgid:
+ *	Check permission before setting one or more of the group identity
+ *	attributes of the current process.  The @flags parameter indicates
+ *	which of the set*gid system calls invoked this hook and how to
+ *	interpret the @id0, @id1, and @id2 parameters.  See the LSM_SETID
+ *	definitions at the beginning of this file for the @flags values and
+ *	their meanings.
+ *	@id0 contains a gid.
+ *	@id1 contains a gid.
+ *	@id2 contains a gid.
+ *	@flags contains one of the LSM_SETID_* values.
+ *	Return 0 if permission is granted.
+ * @task_setpgid:
+ *	Check permission before setting the process group identifier of the
+ *	process @p to @pgid.
+ *	@p contains the task_struct for process being modified.
+ *	@pgid contains the new pgid.
+ *	Return 0 if permission is granted.
+ * @task_getpgid:
+ *	Check permission before getting the process group identifier of the
+ *	process @p.
+ *	@p contains the task_struct for the process.
+ *	Return 0 if permission is granted.
+ * @task_getsid:
+ *	Check permission before getting the session identifier of the process
+ *	@p.
+ *	@p contains the task_struct for the process.
+ *	Return 0 if permission is granted.
+ * @task_setgroups:
+ *	Check permission before setting the supplementary group set of the
+ *	current process to @grouplist.
+ *	@gidsetsize contains the number of elements in @grouplist.
+ *	@grouplist contains the array of gids.
+ *	Return 0 if permission is granted.
+ * @task_setnice:
+ *	Check permission before setting the nice value of @p to @nice.
+ *	@p contains the task_struct of process.
+ *	@nice contains the new nice value.
+ *	Return 0 if permission is granted.
+ * @task_setrlimit:
+ *	Check permission before setting the resource limits of the current
+ *	process for @resource to @new_rlim.  The old resource limit values can
+ *	be examined by dereferencing (current->rlim + resource).
+ *	@resource contains the resource whose limit is being set.
+ *	@new_rlim contains the new limits for @resource.
+ *	Return 0 if permission is granted.
+ * @task_setscheduler:
+ *	Check permission before setting scheduling policy and/or parameters of
+ *	process @p based on @policy and @lp.
+ *	@p contains the task_struct for process.
+ *	@policy contains the scheduling policy.
+ *	@lp contains the scheduling parameters.
+ *	Return 0 if permission is granted.
+ * @task_getscheduler:
+ *	Check permission before obtaining scheduling information for process
+ *	@p.
+ *	@p contains the task_struct for process.
+ *	Return 0 if permission is granted.
+ * @task_kill:
+ *	Check permission before sending signal @sig to @p.  @info can be NULL,
+ *	the constant 1, or a pointer to a siginfo structure.  If @info is 1 or
+ *	SI_FROMKERNEL(info) is true, then the signal should be viewed as coming
+ *	from the kernel and should typically be permitted.
+ *	SIGIO signals are handled separately by the send_sigiotask hook in
+ *	file_security_ops.
+ *	@p contains the task_struct for process.
+ *	@info contains the signal information.
+ *	@sig contains the signal value.
+ *	Return 0 if permission is granted.
+ * @task_wait:
+ *	Check permission before allowing a process to reap a child process @p
+ *	and collect its status information.
+ *	@p contains the task_struct for process.
+ *	Return 0 if permission is granted.
+ * @task_prctl:
+ *	Check permission before performing a process control operation on the
+ *	current process.
+ *	@option contains the operation.
+ *	@arg2 contains a argument.
+ *	@arg3 contains a argument.
+ *	@arg4 contains a argument.
+ *	@arg5 contains a argument.
+ *	Return 0 if permission is granted.
+ * @task_kmod_set_label:
+ *	Set the security attributes in current->security for the kernel module
+ *	loader thread, so that it has the permissions needed to perform its
+ *	function.
+ * @task_reparent_to_init:
+ * 	Set the security attributes in @p->security for a kernel thread that
+ * 	is being reparented to the init task.
+ *	@p contains the task_struct for the kernel thread.
+ * @task_to_inode:
+ * 	Set the security attributes for an inode based on an associated task's
+ * 	security attributes, e.g. for /proc/pid inodes.
+ *	@p contains the task_struct for the task.
+ *	@inode contains the inode structure for the inode.
+ *
+ * Security hooks for socket operations.
+ *
+ * @socket_create:
+ *	Check permissions prior to creating a new socket.
+ *	@family contains the requested protocol family.
+ *	@type contains the requested communications type.
+ *	@protocol contains the requested protocol.
+ *	Return 0 if permission is granted.
+ * @socket_post_create:
+ *	This hook allows a module to update or allocate a per-socket security
+ *	structure. Note that the security field was not added directly to the
+ *	socket structure, but rather, the socket security information is stored
+ *	in the associated inode.  Typically, the inode alloc_security hook will
+ *	allocate and and attach security information to
+ *	sock->inode->i_security.  This hook may be used to update the
+ *	sock->inode->i_security field with additional information that wasn't
+ *	available when the inode was allocated.
+ *	@sock contains the newly created socket structure.
+ *	@family contains the requested protocol family.
+ *	@type contains the requested communications type.
+ *	@protocol contains the requested protocol.
+ * @socket_bind:
+ *	Check permission before socket protocol layer bind operation is
+ *	performed and the socket @sock is bound to the address specified in the
+ *	@address parameter.
+ *	@sock contains the socket structure.
+ *	@address contains the address to bind to.
+ *	@addrlen contains the length of address.
+ *	Return 0 if permission is granted.  
+ * @socket_connect:
+ *	Check permission before socket protocol layer connect operation
+ *	attempts to connect socket @sock to a remote address, @address.
+ *	@sock contains the socket structure.
+ *	@address contains the address of remote endpoint.
+ *	@addrlen contains the length of address.
+ *	Return 0 if permission is granted.  
+ * @socket_listen:
+ *	Check permission before socket protocol layer listen operation.
+ *	@sock contains the socket structure.
+ *	@backlog contains the maximum length for the pending connection queue.
+ *	Return 0 if permission is granted.
+ * @socket_accept:
+ *	Check permission before accepting a new connection.  Note that the new
+ *	socket, @newsock, has been created and some information copied to it,
+ *	but the accept operation has not actually been performed.
+ *	@sock contains the listening socket structure.
+ *	@newsock contains the newly created server socket for connection.
+ *	Return 0 if permission is granted.
+ * @socket_post_accept:
+ *	This hook allows a security module to copy security
+ *	information into the newly created socket's inode.
+ *	@sock contains the listening socket structure.
+ *	@newsock contains the newly created server socket for connection.
+ * @socket_sendmsg:
+ *	Check permission before transmitting a message to another socket.
+ *	@sock contains the socket structure.
+ *	@msg contains the message to be transmitted.
+ *	@size contains the size of message.
+ *	Return 0 if permission is granted.
+ * @socket_recvmsg:
+ *	Check permission before receiving a message from a socket.
+ *	@sock contains the socket structure.
+ *	@msg contains the message structure.
+ *	@size contains the size of message structure.
+ *	@flags contains the operational flags.
+ *	Return 0 if permission is granted.  
+ * @socket_getsockname:
+ *	Check permission before the local address (name) of the socket object
+ *	@sock is retrieved.
+ *	@sock contains the socket structure.
+ *	Return 0 if permission is granted.
+ * @socket_getpeername:
+ *	Check permission before the remote address (name) of a socket object
+ *	@sock is retrieved.
+ *	@sock contains the socket structure.
+ *	Return 0 if permission is granted.
+ * @socket_getsockopt:
+ *	Check permissions before retrieving the options associated with socket
+ *	@sock.
+ *	@sock contains the socket structure.
+ *	@level contains the protocol level to retrieve option from.
+ *	@optname contains the name of option to retrieve.
+ *	Return 0 if permission is granted.
+ * @socket_setsockopt:
+ *	Check permissions before setting the options associated with socket
+ *	@sock.
+ *	@sock contains the socket structure.
+ *	@level contains the protocol level to set options for.
+ *	@optname contains the name of the option to set.
+ *	Return 0 if permission is granted.  
+ * @socket_shutdown:
+ *	Checks permission before all or part of a connection on the socket
+ *	@sock is shut down.
+ *	@sock contains the socket structure.
+ *	@how contains the flag indicating how future sends and receives are handled.
+ *	Return 0 if permission is granted.
+ * @socket_sock_alloc_security:
+ *      @sk contains the sock structure.
+ *	@gfp_mask contains the kernel allocation gfp_mask value.
+ *      Allocate and attach a security structure to @sk->security.  The
+ *      security field is initialized to NULL when the sock structure is
+ *      allocated.
+ *      Return 0 if operation was successful.
+ * @socket_sock_free_security:
+ *      @sk contains the sock structure.
+ *      Deallocate and clear the sk->security field.
+ * @socket_sock_rcv_skb:
+ *	Check permissions on incoming network packets.  This hook is distinct
+ *	from the network input hooks of ip_security_ops since it is the first
+ *	time that the incoming sk_buff @skb has been associated with a
+ *	particular socket, @sk.  Security modules should not try to dereference
+ *	@sk->socket if the socket is in a time wait state 
+ *	(@sk->state == TCP_TIME_WAIT), since the @sk refers to a tcp_tw_bucket
+ *	structure in that case.  Also, even if the socket is not in this state,
+ *	@sk->socket may be NULL, e.g. a newly created server socket for a
+ *	connection that has not yet been accepted by a process.
+ *	@sk contains the sock (not socket) associated with the incoming sk_buff.
+ *	@skb contains the incoming network data.
+ * 	Return 0 if permission is granted.
+ * @open_request_alloc_security:
+ *      Allocate the security blob for an open_request structure. The
+ *      req->security field is initialized to NULL when the structure is
+ *      allocated.
+ *      @req Pointer to the open_request structure.
+ *      Return 0 if successful, or -ENOMEM on out of memory condition.
+ * @open_request_free_security:
+ *      Free the security blob for an open_request structure.
+ *      @req Pointer to the open_request structure.
+ * @tcp_connection_request:
+ *      A new connection is being requested on a server. This hook allows
+ *      security information to be attached to the new connection request.
+ *      @sk contains the listening sock.
+ *      @skb contains the incoming network packet.
+ *      @req contains the open_request structure.
+ * @tcp_synack:
+ *      A TCP SYN-ACK packet is being sent out, the second part of the TCP
+ *      three-way handshake for a new connection.
+ *      @sk contains the listening sock.
+ *      @skb contains the outgoing network packet.
+ *      @req contains the open_request structure.
+ * @tcp_create_openreq_child:
+ *      A new connection is being established on a TCP sock. This hook allows
+ *      the association of security information with the new sock as it is
+ *      being created.
+ *      @sk contains the listening sock.
+ *      @newsk contains the sock associated with the new connection.
+ *      @skb contains the incoming network packet that finalized the connection.
+ *      @req contains the open_request structure.
+ *
+ * Lifecycle hooks for network buffers.
+ *
+ * @skb_alloc_security:
+ *	This hook is called by the &sk_buff allocator when a new buffer is
+ *	being allocated.  An LSM module may allocate and assign a new security
+ *	blob for the &sk_buff via this hook.
+ *	@skb contains the buffer being allocated.
+ *	@gfp_mask contains the kernel allocation gfp_mask value.
+ *	Return 0 if successful, or -ENOMEM on out of memory condition.
+ * @skb_clone:
+ *	This hook is called when an &sk_buff is being cloned, and may be used,
+ *	for example, to increment a reference count on the associated security
+ *	blob.  The security blob in the @newskb will not have been allocated.
+ *	@newskb contains the newly cloned buffer.
+ *	@oldskb contains the buffer being cloned.
+ *	Returns 0 on success -ENOMEM on failure.
+ * @skb_copy:
+ *	This hook is called when an &sk_buff header is being copied, which
+ *	occurs during the skb_copy() and pskb_copy() functions in
+ *	<net/core/skbuff.c>
+ *	@newskb contains the newly copied buffer.
+ *	@oldskb contains the buffer being copied.
+ * @skb_set_owner_w:
+ *	This hook is called when the ownership of an &sk_buff is being assigned
+ *	to a sending socket.  Typically, this would be used to copy security
+ *	attributes from the sending socket to the &sk_buff.
+ *	@skb contains the buffer being owned.
+ *	@sk contains sock to which ownership is being assigned.
+ * @skb_recv_datagram:
+ *      This hook is called when a process is receiving a datagram
+ *      message.  At this point, there is an association between the
+ *      current process, the socket, and the skb.
+ *      @skb contains the buffer being returned.
+ *      @sk is the receiving sock.
+ *      @flags contains operational flags.
+ * @skb_free_security:
+ *	This hook is called when an &sk_buff is being destroyed, and should be
+ *	used to free any associated security blob.
+ *	@skb contains the buffer being destroyed.
+ *
+ * These are the lifecycle hooks for network buffers. They are used to help
+ * manage the lifecycle of security blobs for &sk_buff structures, and are not
+ * intended to be used for access decisions.
+ *
+ * IPv4 networking hooks.
+ *
+ * @ip_fragment:
+ *	This is called for each fragment generated when an outgoing packet is
+ *	being fragmented, and may be used to copy security attributes from the
+ *	original packet to each fragment.
+ *	@newskb contains the newly created fragment.
+ *	@oldskb contains the original packet being fragmented.
+ * @ip_defragment:
+ *	This hook is called when an incoming fragment is about to be inserted
+ *	into a reassembly queue.  It's purpose is to enable the validation of
+ *	security attributes for each fragment.  An LSM module using this hook
+ *	will likely need to maintain its own fragment queue information, handle
+ *	fragment expiration and implement DoS countermeasures.
+ *	@skb contains the incoming fragment.
+ *	Returns 0 on success.
+ * @ip_encapsulate:
+ *	This hook is called when an IP packet is encapsulated, and may be used
+ *	to update security attributes prior to reprocessing via the local_out
+ *	or forward hooks.
+ *	@skb contains the encapsulated packet.
+ * @ip_decapsulate:
+ *	This hook is called when a packet is decapsulated, and may be used to
+ *	process security attributes at each level of encapsulation.  An example
+ *	of this would be keeping track of nested security associations for an
+ *	incoming packet.
+ *	@skb contains the decapsulated packet.
+ * @ip_decode_options:
+ *	This hook is used for processing IP security options at the network
+ *	layer when labeled networking (e.g. CIPSO) is implemented.
+ *	For outgoing packets, IP options passed down from the application or
+ *	transport layers may be verified here prior the packet being built.
+ *	For incoming packets, IP options may be verified and their values
+ *	recorded via the &sk_buff security blob for later processing.
+ *	@skb contains the &sk_buff containing IP packet (usually NULL for outgoing).
+ *	@optptr contains the &ip_options structure.
+ *	@pp_ptr contains the parameter problem pointer.
+ *	Returns 0 on success.
+ *	A non-zero return value will cause an ICMP parameter problem message to
+ *	be generated and transmitted to the sender.  The @pp_ptr parameter may
+ *	be used to point to the offending option parameter.
+ *
+ * Security hooks for network devices.
+ * @netdev_unregister:
+ *	Update the module's state when a network device is unregistered,
+ *	deallocating the dev->security field if it was previously allocated.
+ *	@dev contains the network device
+ *
+ * These are the hooks for network device operations.  Since it would be quite
+ * invasive to provide hooks in every location where a network device might be
+ * probed or initialized, there are no separate hooks for allocation or
+ * initialization.  Security modules can allocate and initialize the
+ * dev->security field on the first access to the device, but should be careful
+ * to use nonblocking allocation.
+ *
+ * Security hooks for kernel module operations.
+ *
+ * @module_create:
+ *	Check the permission before allocating space for a module.
+ *	@name contains the module name.
+ *	@size contains the module size.
+ *	Return 0 if permission is granted.
+ * @module_initialize:
+ * 	Check permission before initializing a module.
+ * 	@mod contains a pointer to the module being initialized.
+ *	Return 0 if permission is granted.
+ * @module_delete:
+ *	Check permission before removing a module.
+ *	@mod contains a pointer to the module being deleted.
+ *	Return 0 if permission is granted.
+ * 
+ * These are the hooks for kernel module operations.  All hooks are called with
+ * the big kernel lock held, and @delete_module is also called with the
+ * unload_lock held.
+ *
+ * Security hooks affecting all System V IPC operations.
+ *
+ * @ipc_permission:
+ *	Check user, group, and other permissions for access to IPC
+ *	@ipcp contains the IPC permission set
+ *	@flag contains the desired (requested) permission set
+ *	Return 0 if permission is granted.
+ *
+ * Security hooks for individual messages held in System V IPC message queues
+ * @msg_msg_alloc_security:
+ *	Allocate and attach a security structure to the msg->security field.
+ *	The security field is initialized to NULL when the structure is first
+ *	created.
+ *	@msg contains the message structure to be modified.
+ *	Return 0 if operation was successful and permission is granted.
+ * @msg_msg_free_security:
+ *	Deallocate the security structure for this message.
+ *	@msg contains the message structure to be modified.
+ *
+ *
+ * Security hooks for System V IPC Message Queues
+ *
+ * @msg_queue_alloc_security:
+ *	Allocate and attach a security structure to the
+ *	msq->q_perm.security field. The security field is initialized to
+ *	NULL when the structure is first created.
+ *	@msq contains the message queue structure to be modified.
+ *	Return 0 if operation was successful and permission is granted.
+ * @msg_queue_free_security:
+ *	Deallocate security structure for this message queue.
+ *	@msq contains the message queue structure to be modified.
+ * @msg_queue_associate:
+ *	Check permission when a message queue is requested through the
+ *	msgget system call.  This hook is only called when returning the
+ *	message queue identifier for an existing message queue, not when a
+ *	new message queue is created.
+ *	@msq contains the message queue to act upon.
+ *	@msqflg contains the operation control flags.
+ *	Return 0 if permission is granted.
+ * @msg_queue_msgctl:
+ *	Check permission when a message control operation specified by @cmd
+ *	is to be performed on the message queue @msq.
+ *	The @msq may be NULL, e.g. for IPC_INFO or MSG_INFO.
+ *	@msq contains the message queue to act upon.  May be NULL.
+ *	@cmd contains the operation to be performed.
+ *	Return 0 if permission is granted.  
+ * @msg_queue_msgsnd:
+ *	Check permission before a message, @msg, is enqueued on the message
+ *	queue, @msq.
+ *	@msq contains the message queue to send message to.
+ *	@msg contains the message to be enqueued.
+ *	@msqflg contains operational flags.
+ *	Return 0 if permission is granted.
+ * @msg_queue_msgrcv:
+ *	Check permission before a message, @msg, is removed from the message
+ *	queue, @msq.  The @target task structure contains a pointer to the 
+ *	process that will be receiving the message (not equal to the current 
+ *	process when inline receives are being performed).
+ *	@msq contains the message queue to retrieve message from.
+ *	@msg contains the message destination.
+ *	@target contains the task structure for recipient process.
+ *	@type contains the type of message requested.
+ *	@mode contains the operational flags.
+ *	Return 0 if permission is granted.
+ *
+ * Security hooks for System V Shared Memory Segments
+ *
+ * @shm_alloc_security:
+ *	Allocate and attach a security structure to the shp->shm_perm.security
+ *	field.  The security field is initialized to NULL when the structure is
+ *	first created.
+ *	@shp contains the shared memory structure to be modified.
+ *	Return 0 if operation was successful and permission is granted.
+ * @shm_free_security:
+ *	Deallocate the security struct for this memory segment.
+ *	@shp contains the shared memory structure to be modified.
+ * @shm_associate:
+ *	Check permission when a shared memory region is requested through the
+ *	shmget system call.  This hook is only called when returning the shared
+ *	memory region identifier for an existing region, not when a new shared
+ *	memory region is created.
+ *	@shp contains the shared memory structure to be modified.
+ *	@shmflg contains the operation control flags.
+ *	Return 0 if permission is granted.
+ * @shm_shmctl:
+ *	Check permission when a shared memory control operation specified by
+ *	@cmd is to be performed on the shared memory region @shp.
+ *	The @shp may be NULL, e.g. for IPC_INFO or SHM_INFO.
+ *	@shp contains shared memory structure to be modified.
+ *	@cmd contains the operation to be performed.
+ *	Return 0 if permission is granted.
+ * @shm_shmat:
+ *	Check permissions prior to allowing the shmat system call to attach the
+ *	shared memory segment @shp to the data segment of the calling process.
+ *	The attaching address is specified by @shmaddr.
+ *	@shp contains the shared memory structure to be modified.
+ *	@shmaddr contains the address to attach memory region to.
+ *	@shmflg contains the operational flags.
+ *	Return 0 if permission is granted.
+ *
+ * Security hooks for System V Semaphores
+ *
+ * @sem_alloc_security:
+ *	Allocate and attach a security structure to the sma->sem_perm.security
+ *	field.  The security field is initialized to NULL when the structure is
+ *	first created.
+ *	@sma contains the semaphore structure
+ *	Return 0 if operation was successful and permission is granted.
+ * @sem_free_security:
+ *	deallocate security struct for this semaphore
+ *	@sma contains the semaphore structure.
+ * @sem_associate:
+ *	Check permission when a semaphore is requested through the semget
+ *	system call.  This hook is only called when returning the semaphore
+ *	identifier for an existing semaphore, not when a new one must be
+ *	created.
+ *	@sma contains the semaphore structure.
+ *	@semflg contains the operation control flags.
+ *	Return 0 if permission is granted.
+ * @sem_semctl:
+ *	Check permission when a semaphore operation specified by @cmd is to be
+ *	performed on the semaphore @sma.  The @sma may be NULL, e.g. for 
+ *	IPC_INFO or SEM_INFO.
+ *	@sma contains the semaphore structure.  May be NULL.
+ *	@cmd contains the operation to be performed.
+ *	Return 0 if permission is granted.
+ * @sem_semop
+ *	Check permissions before performing operations on members of the
+ *	semaphore set @sma.  If the @alter flag is nonzero, the semaphore 
+ *      set may be modified.
+ *	@sma contains the semaphore structure.
+ *	@sops contains the operations to perform.
+ *	@nsops contains the number of operations to perform.
+ *	@alter contains the flag indicating whether changes are to be made.
+ *	Return 0 if permission is granted.
+ *
+ * @sys_security:
+ *	Security modules may use this hook to implement new system calls for
+ *	security-aware applications.  The interface is similar to socketcall,
+ *	but with an @id parameter to help identify the security module whose
+ *	call is being invoked.  The module is responsible for interpreting the
+ *	parameters, and must copy in the @args array from user space if it is
+ *	used.
+ *	The recommended convention for creating the hexadecimal @id value is
+ *	echo "Name_of_module" | md5sum | cut -c -8; by using this convention,
+ *	there is no need for a central registry.
+ *	@id contains the security module identifier.
+ *	@call contains the call value.
+ *	@args contains the call arguments (user space pointer).
+ *	The module should return -ENOSYS if it does not implement any new
+ *	system calls.
+ * @nfsservctl:
+ *	Check permission before having the kernel NFS daemon perform command
+ *	@cmd with arguments @arg.
+ *	See the nfsservctl(2) manual page for an explanation of @cmd and @arg
+ *	values.
+ *	@cmd contains the command value.
+ *	@arg contains the command arguments.
+ *	Return 0 if permission is granted.
+ * @bdflush:
+ *	Check permission before tuning the bdflush parameter.  
+ *	See the bdflush(2) manual page for an explanation of the @func and
+ *	@data parameters.  The @data parameter should only be used by the
+ *	module if it is an input value.
+ *	@func contains the tuning function.
+ *	@data contains the tuning parameter pointer (user space pointer) or value.
+ *	Return 0 if permission is granted.
+ *
+ * @sethostname:
+ *	Check permission before the hostname is set to @hostname.
+ *	@hostname contains the new hostname
+ *	Return 0 if permission is granted.
+ * @setdomainname:
+ *	Check permission before the domainname is set to @domainname.
+ *	@domainname contains the new domainname
+ *	Return 0 if permission is granted.
+ * @reboot:
+ *	Check permission before rebooting or enabling/disabling the
+ *	Ctrl-Alt-Del key sequence.
+ *	The values for @cmd are defined in the reboot(2) manual page.
+ *	@cmd contains the reboot command.
+ *	Return 0 if permission is granted.
+ * @ioperm:
+ *	Check permission before setting port input/output permissions for the
+ *	process for @num bytes starting from the port address @from to the
+ *	value @turn_on.
+ *	@from contains the starting port address.
+ *	@num contains the number of bytes starting from @from.
+ *	@turn_on contains the permissions value.
+ *	Return 0 if permission is granted.
+ * @iopl:
+ *	Check permission before changing the I/O privilege level of the current
+ *	process from @old to @level.
+ *	@old contains the old level.
+ *	@level contains the new level.
+ *	Return 0 if permission is granted.
+ * @ptrace:
+ *	Check permission before allowing the @parent process to trace the
+ *	@child process.
+ *	Security modules may also want to perform a process tracing check
+ *	during an execve in the set_security or compute_creds hooks of
+ *	binprm_security_ops if the process is being traced and its security
+ *	attributes would be changed by the execve.
+ *	@parent contains the task_struct structure for parent process.
+ *	@child contains the task_struct structure for child process.
+ *	Return 0 if permission is granted.
+ * @capget:
+ *	Get the @effective, @inheritable, and @permitted capability sets for
+ *	the @target process.  The hook may also perform permission checking to
+ *	determine if the current process is allowed to see the capability sets
+ *	of the @target process.
+ *	@target contains the task_struct structure for target process.
+ *	@effective contains the effective capability set.
+ *	@inheritable contains the inheritable capability set.
+ *	@permitted contains the permitted capability set.
+ *	Return 0 if the capability sets were successfully obtained.
+ * @capset_check:
+ *	Check permission before setting the @effective, @inheritable, and
+ *	@permitted capability sets for the @target process.
+ *	Caveat:  @target is also set to current if a set of processes is
+ *	specified (i.e. all processes other than current and init or a
+ *	particular process group).  Hence, the capset_set hook may need to
+ *	revalidate permission to the actual target process.
+ *	@target contains the task_struct structure for target process.
+ *	@effective contains the effective capability set.
+ *	@inheritable contains the inheritable capability set.
+ *	@permitted contains the permitted capability set.
+ *	Return 0 if permission is granted.
+ * @capset_set:
+ *	Set the @effective, @inheritable, and @permitted capability sets for
+ *	the @target process.  Since capset_check cannot always check permission
+ *	to the real @target process, this hook may also perform permission
+ *	checking to determine if the current process is allowed to set the
+ *	capability sets of the @target process.  However, this hook has no way
+ *	of returning an error due to the structure of the sys_capset code.
+ *	@target contains the task_struct structure for target process.
+ *	@effective contains the effective capability set.
+ *	@inheritable contains the inheritable capability set.
+ *	@permitted contains the permitted capability set.
+ * @acct:
+ *	Check permission before enabling or disabling process accounting.  If
+ *	accounting is being enabled, then @file refers to the open file used to
+ *	store accounting records.  If accounting is being disabled, then @file
+ *	is NULL.
+ *	@file contains the file structure for the accounting file (may be NULL).
+ *	Return 0 if permission is granted.
+ * @sysctl:
+ *	Check permission before accessing the @table sysctl variable in the
+ *	manner specified by @op.
+ *	@table contains the ctl_table structure for the sysctl variable.
+ *	@op contains the operation (001 = search, 002 = write, 004 = read).
+ *	Return 0 if permission is granted.
+ * @capable:
+ *	Check whether the @tsk process has the @cap capability.
+ *	@tsk contains the task_struct for the process.
+ *	@cap contains the capability <include/linux/capability.h>.
+ *	Return 0 if the capability is granted for @tsk.
+ * @swapon:
+ *	Check permission before enabling swapping to the file or block device
+ *	identified by @swap.
+ *	@swap contains the swap_info_struct structure for the swap file and device.
+ *	Return 0 if permission is granted.
+ * @swapoff:
+ *	Check permission before disabling swapping to the file or block device
+ *	identified by @swap.
+ *	@swap contains the swap_info_struct structure for the swap file and device.
+ *	Return 0 if permission is granted.
+ * @quotactl:
+ *	Check permission before performing the quota operation identified by
+ *	@cmd for the specified @type, @id, and @sb.  The @sb parameter may be
+ *	NULL, e.g. for the Q_SYNC and Q_GETSTATS commands.
+ *	@cmd contains the command value.
+ *	@type contains the type of quota (USRQUOTA or GRPQUOTA).
+ *	@id contains the user or group identifier.
+ *	@sb contains the super_block structure for the filesystem (may be NULL).
+ *	Return 0 if permission is granted.
+ * @quota_on:
+ *	Check permission before enabling quotas for a file system using @f as
+ *	the quota file.
+ *	@f contains the open file for storing quotas.
+ *	Return 0 if permission is granted.
+ * @syslog:
+ *	Check permission before accessing the kernel message ring or changing
+ *	logging to the console.
+ *	See the syslog(2) manual page for an explanation of the @type values.  
+ *	@type contains the type of action.
+ *	Return 0 if permission is granted.
+ * @settime:
+ *      Check permission to change the system time. 
+ *      struct timeval and timezone are defined in include/linux/time.h
+ *      @tv contains new time
+ *      @tz contains new timezone
+ *      Return 0 if permission is granted.
+ *
+ * @netlink_send:
+ *	Save security information for a netlink message so that permission
+ *	checking can be performed when the message is processed.  The security
+ *	information can either be saved using the existing eff_cap field of the
+ *	netlink_skb_parms structure or it can be saved using the skbuff
+ *	lsm_security field.
+ *	@skb contains the sk_buff structure for the netlink message.
+ *	Return 0 if the information was successfully saved.
+ * @netlink_recv:
+ *	Check permission before processing the received netlink message in
+ *	@skb.
+ *	@skb contains the sk_buff structure for the netlink message.
+ *	Return 0 if permission is granted.
+ * @unix_stream_connect:
+ *	Check permissions before establishing a Unix domain stream connection
+ *	between @sock and @other.
+ *	@sock contains the socket structure.
+ *	@other contains the peer socket structure.
+ *	Return 0 if permission is granted.
+ * @unix_may_send:
+ *	Check permissions before connecting or sending datagrams from @sock to
+ *	@other.
+ *	@sock contains the socket structure.
+ *	@sock contains the peer socket structure.
+ *	Return 0 if permission is granted.
+ *
+ * The @unix_stream_connect and @unix_may_send hooks were necessary because
+ * Linux provides an alternative to the conventional file name space for Unix
+ * domain sockets.  Whereas binding and connecting to sockets in the file name
+ * space is mediated by the typical file permissions (and caught by the mknod
+ * and permission hooks in inode_security_ops), binding and connecting to
+ * sockets in the abstract name space is completely unmediated.  Sufficient
+ * control of Unix domain sockets in the abstract name space isn't possible
+ * using only the socket layer hooks, since we need to know the actual target
+ * socket, which is not looked up until we are inside the af_unix code.
+ *
+ * @register_security:
+ * 	allow module stacking.
+ * 	@name contains the name of the security module being stacked.
+ * 	@ops contains a pointer to the struct security_operations of the module to stack.
+ * @unregister_security:
+ *	remove a stacked module.
+ *	@name contains the name of the security module being unstacked.
+ *	@ops contains a pointer to the struct security_operations of the module to unstack.
+ * 
+ * This is the main security structure.
+ */
+struct security_operations {
+	int (*sys_security) (unsigned int id, unsigned call,
+			     unsigned long *args);
+	int (*nfsservctl) (int cmd, struct nfsctl_arg * arg);
+
+	int (*bdflush) (int func, long data);
+
+	int (*module_create) (const char *name, size_t size);
+	int (*module_initialize) (struct module * mod);
+	int (*module_delete) (const struct module * mod);
+
+	int (*sethostname) (char *hostname);
+	int (*setdomainname) (char *domainname);
+	int (*reboot) (unsigned int cmd);
+	int (*ioperm) (unsigned long from, unsigned long num, int turn_on);
+	int (*iopl) (unsigned int old, unsigned int level);
+	int (*ptrace) (struct task_struct * parent, struct task_struct * child);
+	int (*capget) (struct task_struct * target,
+		       kernel_cap_t * effective,
+		       kernel_cap_t * inheritable, kernel_cap_t * permitted);
+	int (*capset_check) (struct task_struct * target,
+			     kernel_cap_t * effective,
+			     kernel_cap_t * inheritable,
+			     kernel_cap_t * permitted);
+	void (*capset_set) (struct task_struct * target,
+			    kernel_cap_t * effective,
+			    kernel_cap_t * inheritable,
+			    kernel_cap_t * permitted);
+	int (*acct) (struct file * file);
+	int (*sysctl) (ctl_table * table, int op);
+	int (*capable) (struct task_struct * tsk, int cap);
+	int (*swapon) (struct swap_info_struct * swap);
+	int (*swapoff) (struct swap_info_struct * swap);
+	int (*quotactl) (int cmds, int type, int id, struct super_block * sb);
+	int (*quota_on) (struct file * f);
+	int (*syslog) (int type);
+	int (*settime) (struct timeval *tv, struct timezone *tz);
+
+	int (*netlink_send) (struct sk_buff * skb);
+	int (*netlink_recv) (struct sk_buff * skb);
+	int (*ip_decode_options) (struct sk_buff * skb,
+				  const char *optptr, unsigned char **pp_ptr);
+
+	int (*bprm_alloc_security) (struct linux_binprm * bprm);
+	void (*bprm_free_security) (struct linux_binprm * bprm);
+	void (*bprm_compute_creds) (struct linux_binprm * bprm);
+	int (*bprm_set_security) (struct linux_binprm * bprm);
+	int (*bprm_check_security) (struct linux_binprm * bprm);
+	int (*bprm_secureexec) (struct linux_binprm * bprm);
+
+	int (*sb_alloc_security) (struct super_block * sb);
+	void (*sb_free_security) (struct super_block * sb);
+	int (*sb_kern_mount) (struct super_block *sb);
+	int (*sb_statfs) (struct super_block * sb);
+	int (*sb_mount) (char *dev_name, struct nameidata * nd,
+			 char *type, unsigned long flags, void *data);
+	int (*sb_check_sb) (struct vfsmount * mnt, struct nameidata * nd);
+	int (*sb_umount) (struct vfsmount * mnt, int flags);
+	void (*sb_umount_close) (struct vfsmount * mnt);
+	void (*sb_umount_busy) (struct vfsmount * mnt);
+	void (*sb_post_remount) (struct vfsmount * mnt,
+				 unsigned long flags, void *data);
+	void (*sb_post_mountroot) (void);
+	void (*sb_post_addmount) (struct vfsmount * mnt,
+				  struct nameidata * mountpoint_nd);
+	int (*sb_pivotroot) (struct nameidata * old_nd,
+			     struct nameidata * new_nd);
+	void (*sb_post_pivotroot) (struct nameidata * old_nd,
+				   struct nameidata * new_nd);
+
+	int (*inode_alloc_security) (struct inode *inode);	
+	void (*inode_free_security) (struct inode *inode);
+	int (*inode_create) (struct inode *dir,
+	                     struct dentry *dentry, int mode);
+	void (*inode_post_create) (struct inode *dir,
+	                           struct dentry *dentry, int mode);
+	int (*inode_link) (struct dentry *old_dentry,
+	                   struct inode *dir, struct dentry *new_dentry);
+	void (*inode_post_link) (struct dentry *old_dentry,
+	                         struct inode *dir, struct dentry *new_dentry);
+	int (*inode_unlink) (struct inode *dir, struct dentry *dentry);
+	int (*inode_symlink) (struct inode *dir,
+	                      struct dentry *dentry, const char *old_name);
+	void (*inode_post_symlink) (struct inode *dir,
+	                            struct dentry *dentry,
+	                            const char *old_name);
+	int (*inode_mkdir) (struct inode *dir, struct dentry *dentry, int mode);
+	void (*inode_post_mkdir) (struct inode *dir, struct dentry *dentry, 
+			    int mode);
+	int (*inode_rmdir) (struct inode *dir, struct dentry *dentry);
+	int (*inode_mknod) (struct inode *dir, struct dentry *dentry,
+	                    int mode, dev_t dev);
+	void (*inode_post_mknod) (struct inode *dir, struct dentry *dentry,
+	                          int mode, dev_t dev);
+	int (*inode_rename) (struct inode *old_dir, struct dentry *old_dentry,
+	                     struct inode *new_dir, struct dentry *new_dentry);
+	void (*inode_post_rename) (struct inode *old_dir,
+	                           struct dentry *old_dentry,
+	                           struct inode *new_dir,
+	                           struct dentry *new_dentry);
+	int (*inode_readlink) (struct dentry *dentry);
+	int (*inode_follow_link) (struct dentry *dentry, struct nameidata *nd);
+	int (*inode_permission) (struct inode *inode, int mask);
+        int (*inode_revalidate) (struct dentry *dentry);
+	void (*inode_post_setxattr) (struct dentry *dentry, char *name, void *value,
+				     size_t size, int flags);
+	int (*inode_setattr)	(struct dentry *dentry, struct iattr *attr);
+        int (*inode_stat) (struct inode *inode);
+        void (*inode_delete) (struct inode *inode);
+	int (*inode_setxattr) (struct dentry *dentry, char *name, void *value,
+			       size_t size, int flags);
+	int (*inode_getxattr) (struct dentry *dentry, char *name);
+	int (*inode_listxattr) (struct dentry *dentry);
+	int (*inode_removexattr) (struct dentry *dentry, char *name);
+	int (*inode_getsecurity)(struct dentry *dentry, const char *name, void *buffer, size_t size);
+  	int (*inode_setsecurity)(struct dentry *dentry, const char *name, const void *value, size_t size, int flags);
+  	int (*inode_listsecurity)(struct dentry *dentry, char *buffer);
+
+	int (*file_permission) (struct file * file, int mask);
+	int (*file_alloc_security) (struct file * file);
+	void (*file_free_security) (struct file * file);
+	int (*file_ioctl) (struct file * file, unsigned int cmd,
+			   unsigned long arg);
+	int (*file_mmap) (struct file * file,
+			  unsigned long prot, unsigned long flags);
+	int (*file_mprotect) (struct vm_area_struct * vma, unsigned long prot);
+	int (*file_lock) (struct file * file, unsigned int cmd);
+	int (*file_fcntl) (struct file * file, unsigned int cmd,
+			   unsigned long arg);
+	int (*file_set_fowner) (struct file * file);
+	int (*file_send_sigiotask) (struct task_struct * tsk,
+				    struct fown_struct * fown,
+				    int fd, int reason);
+	int (*file_receive) (struct file * file);
+
+	int (*task_create) (unsigned long clone_flags);
+	int (*task_alloc_security) (struct task_struct * p);
+	void (*task_free_security) (struct task_struct * p);
+	int (*task_setuid) (uid_t id0, uid_t id1, uid_t id2, int flags);
+	int (*task_post_setuid) (uid_t old_ruid /* or fsuid */ ,
+				 uid_t old_euid, uid_t old_suid, int flags);
+	int (*task_setgid) (gid_t id0, gid_t id1, gid_t id2, int flags);
+	int (*task_setpgid) (struct task_struct * p, pid_t pgid);
+	int (*task_getpgid) (struct task_struct * p);
+	int (*task_getsid) (struct task_struct * p);
+	int (*task_setgroups) (int gidsetsize, gid_t * grouplist);
+	int (*task_setnice) (struct task_struct * p, int nice);
+	int (*task_setrlimit) (unsigned int resource, struct rlimit * new_rlim);
+	int (*task_setscheduler) (struct task_struct * p, int policy,
+				  struct sched_param * lp);
+	int (*task_getscheduler) (struct task_struct * p);
+	int (*task_kill) (struct task_struct * p,
+			  struct siginfo * info, int sig);
+	int (*task_wait) (struct task_struct * p);
+	int (*task_prctl) (int option, unsigned long arg2,
+			   unsigned long arg3, unsigned long arg4,
+			   unsigned long arg5);
+	void (*task_kmod_set_label) (void);
+	void (*task_reparent_to_init) (struct task_struct * p);
+	void (*task_to_inode)(struct task_struct *p, struct inode *inode);
+
+	int (*ipc_permission) (struct kern_ipc_perm * ipcp, short flag);
+
+	int (*msg_msg_alloc_security) (struct msg_msg * msg);
+	void (*msg_msg_free_security) (struct msg_msg * msg);
+
+	int (*msg_queue_alloc_security) (struct msg_queue * msq);
+	void (*msg_queue_free_security) (struct msg_queue * msq);
+	int (*msg_queue_associate) (struct msg_queue * msq, int msqflg);
+	int (*msg_queue_msgctl) (struct msg_queue * msq, int cmd);
+	int (*msg_queue_msgsnd) (struct msg_queue * msq,
+				 struct msg_msg * msg, int msqflg);
+	int (*msg_queue_msgrcv) (struct msg_queue * msq,
+				 struct msg_msg * msg,
+				 struct task_struct * target,
+				 long type, int mode);
+
+	int (*shm_alloc_security) (struct shmid_kernel * shp);
+	void (*shm_free_security) (struct shmid_kernel * shp);
+	int (*shm_associate) (struct shmid_kernel * shp, int shmflg);
+	int (*shm_shmctl) (struct shmid_kernel * shp, int cmd);
+	int (*shm_shmat) (struct shmid_kernel * shp, 
+			  char *shmaddr, int shmflg);
+
+	int (*sem_alloc_security) (struct sem_array * sma);
+	void (*sem_free_security) (struct sem_array * sma);
+	int (*sem_associate) (struct sem_array * sma, int semflg);
+	int (*sem_semctl) (struct sem_array * sma, int cmd);
+	int (*sem_semop) (struct sem_array * sma, 
+			  struct sembuf * sops, unsigned nsops, int alter);
+
+	/* allow module stacking */
+	int (*register_security) (const char *name,
+	                          struct security_operations *ops);
+	int (*unregister_security) (const char *name,
+	                            struct security_operations *ops);
+
+	void (*d_instantiate) (struct dentry * dentry, struct inode * inode);
+	int (*getprocattr)(struct task_struct *p, char *name, void *value, size_t size);
+ 	int (*setprocattr)(struct task_struct *p, char *name, void *value, size_t size);
+
+#ifdef CONFIG_SECURITY_NETWORK
+	int (*unix_stream_connect) (struct socket * sock,
+				    struct socket * other, struct sock * newsk);
+	int (*unix_may_send) (struct socket * sock, struct socket * other);
+
+	int (*socket_create) (int family, int type, int protocol);
+	void (*socket_post_create) (struct socket * sock, int family,
+				    int type, int protocol);
+	int (*socket_bind) (struct socket * sock,
+			    struct sockaddr * address, int addrlen);
+	int (*socket_connect) (struct socket * sock,
+			       struct sockaddr * address, int addrlen);
+	int (*socket_listen) (struct socket * sock, int backlog);
+	int (*socket_accept) (struct socket * sock, struct socket * newsock);
+	void (*socket_post_accept) (struct socket * sock,
+				    struct socket * newsock);
+	int (*socket_sendmsg) (struct socket * sock,
+			       struct msghdr * msg, int size);
+	int (*socket_recvmsg) (struct socket * sock,
+			       struct msghdr * msg, int size, int flags);
+	int (*socket_getsockname) (struct socket * sock);
+	int (*socket_getpeername) (struct socket * sock);
+	int (*socket_getsockopt) (struct socket * sock, int level, int optname);
+	int (*socket_setsockopt) (struct socket * sock, int level, int optname);
+	int (*socket_shutdown) (struct socket * sock, int how);
+	int (*socket_sock_alloc_security) (struct sock * sk, int gfp_mask);
+	void (*socket_sock_free_security) (struct sock * sk);
+	int (*socket_sock_rcv_skb) (struct sock * sk, struct sk_buff * skb);
+	int (*open_request_alloc_security) (struct open_request * req);
+	void (*open_request_free_security) (struct open_request * req);
+	void (*tcp_connection_request) (struct sock * sk, struct sk_buff * skb,
+					struct open_request * req);
+	void (*tcp_synack) (struct sock * sk, struct sk_buff * skb,
+			    struct open_request * req);
+	void (*tcp_create_openreq_child) (struct sock * sk, struct sock * newsk,
+					  struct sk_buff * skb,
+					  struct open_request * req);
+
+	int (*skb_alloc_security) (struct sk_buff * skb, int gfp_mask);
+	int (*skb_clone) (struct sk_buff * newskb,
+			  const struct sk_buff * oldskb);
+	void (*skb_copy) (struct sk_buff * newskb,
+			  const struct sk_buff * oldskb);
+	void (*skb_set_owner_w) (struct sk_buff * skb, struct sock * sk);
+	void (*skb_recv_datagram) (struct sk_buff * skb, struct sock * sk,
+				   unsigned flags);
+	void (*skb_free_security) (struct sk_buff * skb);
+
+	void (*ip_fragment) (struct sk_buff * newskb,
+			     const struct sk_buff * oldskb);
+	int (*ip_defragment) (struct sk_buff * skb);
+	void (*ip_encapsulate) (struct sk_buff * skb);
+	void (*ip_decapsulate) (struct sk_buff * skb);
+
+	void (*netdev_unregister) (struct net_device * dev);
+#endif
+};
+
+/* global variables */
+extern struct security_operations *security_ops;
+
+/* inline stuff */
+static inline int security_syscall(unsigned int id, unsigned call,
+				   unsigned long *args)
+{
+	return security_ops->sys_security(id, call, args);
+}
+
+static inline int security_nfsservctl(int cmd, struct nfsctl_arg * arg)
+{
+	return security_ops->nfsservctl(cmd, arg);
+}
+
+static inline int security_bdflush(int func, long data)
+{
+	return security_ops->bdflush(func, data);
+}
+
+static inline int security_module_create(const char *name, size_t size)
+{
+	return security_ops->module_create(name, size);
+}
+
+static inline int security_module_initialize(struct module * mod)
+{
+	return security_ops->module_initialize(mod);
+}
+
+static inline int security_module_delete(const struct module * mod)
+{
+	return security_ops->module_delete(mod);
+}
+
+static inline int security_sethostname (char *hostname)
+{
+	return security_ops->sethostname (hostname);
+}
+
+static inline int security_setdomainname (char *domainname)
+{
+	return security_ops->setdomainname (domainname);
+}
+
+static inline int security_reboot (unsigned int cmd)
+{
+	return security_ops->reboot (cmd);
+}
+
+static inline int security_ioperm (unsigned long from, unsigned long num, int turn_on)
+{
+	return security_ops->ioperm (from, num, turn_on);
+}
+
+static inline int security_iopl (unsigned int old, unsigned int level)
+{
+	return security_ops->iopl (old, level);
+}
+
+static inline int security_ptrace (struct task_struct * parent, struct task_struct * child)
+{
+	return security_ops->ptrace (parent, child);
+}
+
+static inline int security_capget (struct task_struct *target,
+				   kernel_cap_t *effective,
+				   kernel_cap_t *inheritable,
+				   kernel_cap_t *permitted)
+{
+	return security_ops->capget (target, effective, inheritable, permitted);
+}
+
+static inline int security_capset_check (struct task_struct *target,
+					 kernel_cap_t *effective,
+					 kernel_cap_t *inheritable,
+					 kernel_cap_t *permitted)
+{
+	return security_ops->capset_check (target, effective, inheritable, permitted);
+}
+
+static inline void security_capset_set (struct task_struct *target,
+					kernel_cap_t *effective,
+					kernel_cap_t *inheritable,
+					kernel_cap_t *permitted)
+{
+	security_ops->capset_set (target, effective, inheritable, permitted);
+}
+
+static inline int security_acct (struct file *file)
+{
+	return security_ops->acct (file);
+}
+
+static inline int security_sysctl(ctl_table * table, int op)
+{
+	return security_ops->sysctl(table, op);
+}
+
+static inline int security_capable(struct task_struct * tsk, int cap)
+{
+	return security_ops->capable(tsk, cap);
+}
+
+static inline int security_swapon(struct swap_info_struct * swap)
+{
+	return security_ops->swapon(swap);
+}
+
+static inline int security_swapoff(struct swap_info_struct * swap)
+{
+	return security_ops->swapoff(swap);
+}
+
+static inline int security_quotactl (int cmds, int type, int id,
+				     struct super_block *sb)
+{
+	return security_ops->quotactl (cmds, type, id, sb);
+}
+
+static inline int security_quota_on (struct file * file)
+{
+	return security_ops->quota_on (file);
+}
+
+static inline int security_syslog(int type)
+{
+	return security_ops->syslog(type);
+}
+
+static inline int security_settime(struct timeval *tv, struct timezone *tz)
+{
+	return security_ops->settime(tv, tz);
+}
+
+static inline int security_netlink_send(struct sk_buff * skb)
+{
+	return security_ops->netlink_send(skb);
+}
+
+static inline int security_netlink_recv(struct sk_buff * skb)
+{
+	return security_ops->netlink_recv(skb);
+}
+
+static inline int security_ip_decode_options(struct sk_buff * skb, 
+					     const char *optptr, 
+					     unsigned char **pp_ptr)
+{
+	return security_ops->ip_decode_options(skb, optptr, pp_ptr);
+}
+
+static inline int security_bprm_alloc (struct linux_binprm *bprm)
+{
+	return security_ops->bprm_alloc_security (bprm);
+}
+static inline void security_bprm_free (struct linux_binprm *bprm)
+{
+	security_ops->bprm_free_security (bprm);
+}
+static inline void security_bprm_compute_creds (struct linux_binprm *bprm)
+{
+	security_ops->bprm_compute_creds (bprm);
+}
+static inline int security_bprm_set (struct linux_binprm *bprm)
+{
+	return security_ops->bprm_set_security (bprm);
+}
+
+static inline int security_bprm_check (struct linux_binprm *bprm)
+{
+	return security_ops->bprm_check_security (bprm);
+}
+
+static inline int security_bprm_secureexec (struct linux_binprm *bprm)
+{
+	return security_ops->bprm_secureexec (bprm);
+}
+
+static inline int security_sb_alloc (struct super_block *sb)
+{
+	return security_ops->sb_alloc_security (sb);
+}
+
+static inline void security_sb_free (struct super_block *sb)
+{
+	security_ops->sb_free_security (sb);
+}
+
+static inline int security_sb_kern_mount (struct super_block *sb)
+{
+	return security_ops->sb_kern_mount (sb);
+}
+
+static inline int security_sb_statfs (struct super_block *sb)
+{
+	return security_ops->sb_statfs (sb);
+}
+
+static inline int security_sb_mount (char *dev_name, struct nameidata *nd,
+				    char *type, unsigned long flags,
+				    void *data)
+{
+	return security_ops->sb_mount (dev_name, nd, type, flags, data);
+}
+
+static inline int security_sb_check_sb (struct vfsmount *mnt,
+					struct nameidata *nd)
+{
+	return security_ops->sb_check_sb (mnt, nd);
+}
+
+static inline int security_sb_umount (struct vfsmount *mnt, int flags)
+{
+	return security_ops->sb_umount (mnt, flags);
+}
+
+static inline void security_sb_umount_close (struct vfsmount *mnt)
+{
+	security_ops->sb_umount_close (mnt);
+}
+
+static inline void security_sb_umount_busy (struct vfsmount *mnt)
+{
+	security_ops->sb_umount_busy (mnt);
+}
+
+static inline void security_sb_post_remount (struct vfsmount *mnt,
+					     unsigned long flags, void *data)
+{
+	security_ops->sb_post_remount (mnt, flags, data);
+}
+
+static inline void security_sb_post_mountroot (void)
+{
+	security_ops->sb_post_mountroot ();
+}
+
+static inline void security_sb_post_addmount (struct vfsmount *mnt,
+					      struct nameidata *mountpoint_nd)
+{
+	security_ops->sb_post_addmount (mnt, mountpoint_nd);
+}
+
+static inline int security_sb_pivotroot (struct nameidata *old_nd,
+					 struct nameidata *new_nd)
+{
+	return security_ops->sb_pivotroot (old_nd, new_nd);
+}
+
+static inline void security_sb_post_pivotroot (struct nameidata *old_nd,
+					       struct nameidata *new_nd)
+{
+	security_ops->sb_post_pivotroot (old_nd, new_nd);
+}
+
+static inline int security_inode_alloc (struct inode *inode)
+{
+	return security_ops->inode_alloc_security (inode);
+}
+
+static inline void security_inode_free (struct inode *inode)
+{
+	security_ops->inode_free_security (inode);
+}
+	
+static inline int security_inode_create (struct inode *dir,
+					 struct dentry *dentry,
+					 int mode)
+{
+	return security_ops->inode_create (dir, dentry, mode);
+}
+
+static inline void security_inode_post_create (struct inode *dir,
+					       struct dentry *dentry,
+					       int mode)
+{
+	security_ops->inode_post_create (dir, dentry, mode);
+}
+
+static inline int security_inode_link (struct dentry *old_dentry,
+				       struct inode *dir,
+				       struct dentry *new_dentry)
+{
+	return security_ops->inode_link (old_dentry, dir, new_dentry);
+}
+
+static inline void security_inode_post_link (struct dentry *old_dentry,
+					     struct inode *dir,
+					     struct dentry *new_dentry)
+{
+	security_ops->inode_post_link (old_dentry, dir, new_dentry);
+}
+
+static inline int security_inode_unlink (struct inode *dir,
+					 struct dentry *dentry)
+{
+	return security_ops->inode_unlink (dir, dentry);
+}
+
+static inline int security_inode_symlink (struct inode *dir,
+					  struct dentry *dentry,
+					  const char *old_name)
+{
+	return security_ops->inode_symlink (dir, dentry, old_name);
+}
+
+static inline void security_inode_post_symlink (struct inode *dir,
+						struct dentry *dentry,
+						const char *old_name)
+{
+	security_ops->inode_post_symlink (dir, dentry, old_name);
+}
+
+static inline int security_inode_mkdir (struct inode *dir,
+					struct dentry *dentry,
+					int mode)
+{
+	return security_ops->inode_mkdir (dir, dentry, mode);
+}
+
+static inline void security_inode_post_mkdir (struct inode *dir,
+					      struct dentry *dentry,
+					      int mode)
+{
+	security_ops->inode_post_mkdir (dir, dentry, mode);
+}
+
+static inline int security_inode_rmdir (struct inode *dir,
+					struct dentry *dentry)
+{
+	return security_ops->inode_rmdir (dir, dentry);
+}
+
+static inline int security_inode_mknod (struct inode *dir,
+					struct dentry *dentry,
+					int mode, dev_t dev)
+{
+	return security_ops->inode_mknod (dir, dentry, mode, dev);
+}
+
+static inline void security_inode_post_mknod (struct inode *dir,
+					      struct dentry *dentry,
+					      int mode, dev_t dev)
+{
+	security_ops->inode_post_mknod (dir, dentry, mode, dev);
+}
+
+static inline int security_inode_rename (struct inode *old_dir,
+					 struct dentry *old_dentry,
+					 struct inode *new_dir,
+					 struct dentry *new_dentry)
+{
+	return security_ops->inode_rename (old_dir, old_dentry,
+					   new_dir, new_dentry);
+}
+
+static inline void security_inode_post_rename (struct inode *old_dir,
+					       struct dentry *old_dentry,
+					       struct inode *new_dir,
+					       struct dentry *new_dentry)
+{
+	security_ops->inode_post_rename (old_dir, old_dentry,
+						new_dir, new_dentry);
+}
+
+static inline int security_inode_readlink (struct dentry *dentry)
+{
+	return security_ops->inode_readlink (dentry);
+}
+
+static inline int security_inode_follow_link (struct dentry *dentry,
+					      struct nameidata *nd)
+{
+	return security_ops->inode_follow_link (dentry, nd);
+}
+
+static inline int security_inode_permission (struct inode *inode, int mask)
+{
+	return security_ops->inode_permission (inode, mask);
+}
+
+static inline int security_inode_revalidate (struct dentry *dentry)
+{
+	return security_ops->inode_revalidate (dentry);
+}
+
+static inline int security_inode_setattr (struct dentry *dentry,
+					  struct iattr *attr)
+{
+	return security_ops->inode_setattr (dentry, attr);
+}
+
+static inline int security_inode_stat (struct inode *inode)
+{
+	return security_ops->inode_stat (inode);
+}
+
+static inline void security_inode_delete (struct inode *inode)
+{
+	security_ops->inode_delete (inode);
+}
+
+static inline int security_inode_setxattr (struct dentry *dentry, char *name,
+					   void *value, size_t size, int flags)
+{
+	return security_ops->inode_setxattr (dentry, name, value, size, flags);
+}
+
+static inline void security_inode_post_setxattr (struct dentry *dentry, char *name,
+						void *value, size_t size, int flags)
+{
+	security_ops->inode_post_setxattr (dentry, name, value, size, flags);
+}
+
+static inline int security_inode_getxattr (struct dentry *dentry, char *name)
+{
+	return security_ops->inode_getxattr (dentry, name);
+}
+
+static inline int security_inode_listxattr (struct dentry *dentry)
+{
+	return security_ops->inode_listxattr (dentry);
+}
+
+static inline int security_inode_removexattr (struct dentry *dentry, char *name)
+{
+	return security_ops->inode_removexattr (dentry, name);
+}
+
+static inline int security_inode_getsecurity(struct dentry *dentry, const char *name, void *buffer, size_t size)
+{
+	return security_ops->inode_getsecurity(dentry, name, buffer, size);
+}
+
+static inline int security_inode_setsecurity(struct dentry *dentry, const char *name, const void *value, size_t size, int flags) 
+{
+	return security_ops->inode_setsecurity(dentry, name, value, size, flags);
+}
+
+static inline int security_inode_listsecurity(struct dentry *dentry, char *buffer)
+{
+	return security_ops->inode_listsecurity(dentry, buffer);
+}
+
+static inline int security_file_permission (struct file *file, int mask)
+{
+	return security_ops->file_permission (file, mask);
+}
+
+static inline int security_file_alloc (struct file *file)
+{
+	return security_ops->file_alloc_security (file);
+}
+
+static inline void security_file_free (struct file *file)
+{
+	security_ops->file_free_security (file);
+}
+
+static inline int security_file_ioctl (struct file *file, unsigned int cmd,
+				       unsigned long arg)
+{
+	return security_ops->file_ioctl (file, cmd, arg);
+}
+
+static inline int security_file_mmap (struct file *file, unsigned long prot,
+				      unsigned long flags)
+{
+	return security_ops->file_mmap (file, prot, flags);
+}
+
+static inline int security_file_mprotect (struct vm_area_struct *vma,
+					  unsigned long prot)
+{
+	return security_ops->file_mprotect (vma, prot);
+}
+
+static inline int security_file_lock (struct file *file, unsigned int cmd)
+{
+	return security_ops->file_lock (file, cmd);
+}
+
+static inline int security_file_fcntl (struct file *file, unsigned int cmd,
+				       unsigned long arg)
+{
+	return security_ops->file_fcntl (file, cmd, arg);
+}
+
+static inline int security_file_set_fowner (struct file *file)
+{
+	return security_ops->file_set_fowner (file);
+}
+
+static inline int security_file_send_sigiotask (struct task_struct *tsk,
+						struct fown_struct *fown,
+						int fd, int reason)
+{
+	return security_ops->file_send_sigiotask (tsk, fown, fd, reason);
+}
+
+static inline int security_file_receive (struct file *file)
+{
+	return security_ops->file_receive (file);
+}
+
+static inline int security_task_create (unsigned long clone_flags)
+{
+	return security_ops->task_create (clone_flags);
+}
+
+static inline int security_task_alloc (struct task_struct *p)
+{
+	return security_ops->task_alloc_security (p);
+}
+
+static inline void security_task_free (struct task_struct *p)
+{
+	security_ops->task_free_security (p);
+}
+
+static inline int security_task_setuid (uid_t id0, uid_t id1, uid_t id2,
+					int flags)
+{
+	return security_ops->task_setuid (id0, id1, id2, flags);
+}
+
+static inline int security_task_post_setuid (uid_t old_ruid, uid_t old_euid,
+					     uid_t old_suid, int flags)
+{
+	return security_ops->task_post_setuid (old_ruid, old_euid, old_suid, flags);
+}
+
+static inline int security_task_setgid (gid_t id0, gid_t id1, gid_t id2,
+					int flags)
+{
+	return security_ops->task_setgid (id0, id1, id2, flags);
+}
+
+static inline int security_task_setpgid (struct task_struct *p, pid_t pgid)
+{
+	return security_ops->task_setpgid (p, pgid);
+}
+
+static inline int security_task_getpgid (struct task_struct *p)
+{
+	return security_ops->task_getpgid (p);
+}
+
+static inline int security_task_getsid (struct task_struct *p)
+{
+	return security_ops->task_getsid (p);
+}
+
+static inline int security_task_setgroups (int gidsetsize, gid_t *grouplist)
+{
+	return security_ops->task_setgroups (gidsetsize, grouplist);
+}
+
+static inline int security_task_setnice (struct task_struct *p, int nice)
+{
+	return security_ops->task_setnice (p, nice);
+}
+
+static inline int security_task_setrlimit (unsigned int resource,
+					   struct rlimit *new_rlim)
+{
+	return security_ops->task_setrlimit (resource, new_rlim);
+}
+
+static inline int security_task_setscheduler (struct task_struct *p,
+					      int policy,
+					      struct sched_param *lp)
+{
+	return security_ops->task_setscheduler (p, policy, lp);
+}
+
+static inline int security_task_getscheduler (struct task_struct *p)
+{
+	return security_ops->task_getscheduler (p);
+}
+
+static inline int security_task_kill (struct task_struct *p,
+				      struct siginfo *info, int sig)
+{
+	return security_ops->task_kill (p, info, sig);
+}
+
+static inline int security_task_wait (struct task_struct *p)
+{
+	return security_ops->task_wait (p);
+}
+
+static inline int security_task_prctl (int option, unsigned long arg2,
+				       unsigned long arg3,
+				       unsigned long arg4,
+				       unsigned long arg5)
+{
+	return security_ops->task_prctl (option, arg2, arg3, arg4, arg5);
+}
+
+static inline void security_task_kmod_set_label (void)
+{
+	security_ops->task_kmod_set_label ();
+}
+
+static inline void security_task_reparent_to_init (struct task_struct *p)
+{
+	security_ops->task_reparent_to_init (p);
+}
+
+static inline void security_task_to_inode(struct task_struct *p, struct inode *inode)
+{
+	security_ops->task_to_inode(p, inode);
+}
+
+static inline int security_ipc_permission (struct kern_ipc_perm *ipcp,
+					   short flag)
+{
+	return security_ops->ipc_permission (ipcp, flag);
+}
+
+static inline int security_msg_msg_alloc (struct msg_msg * msg)
+{
+	return security_ops->msg_msg_alloc_security (msg);
+}
+
+static inline void security_msg_msg_free (struct msg_msg * msg)
+{
+	security_ops->msg_msg_free_security(msg);
+}
+
+static inline int security_msg_queue_alloc (struct msg_queue *msq)
+{
+	return security_ops->msg_queue_alloc_security (msq);
+}
+
+static inline void security_msg_queue_free (struct msg_queue *msq)
+{
+	security_ops->msg_queue_free_security (msq);
+}
+
+static inline int security_msg_queue_associate (struct msg_queue * msq, 
+						int msqflg)
+{
+	return security_ops->msg_queue_associate (msq, msqflg);
+}
+
+static inline int security_msg_queue_msgctl (struct msg_queue * msq, int cmd)
+{
+	return security_ops->msg_queue_msgctl (msq, cmd);
+}
+
+static inline int security_msg_queue_msgsnd (struct msg_queue * msq,
+					     struct msg_msg * msg, int msqflg)
+{
+	return security_ops->msg_queue_msgsnd (msq, msg, msqflg);
+}
+
+static inline int security_msg_queue_msgrcv (struct msg_queue * msq,
+					     struct msg_msg * msg,
+					     struct task_struct * target,
+					     long type, int mode)
+{
+	return security_ops->msg_queue_msgrcv (msq, msg, target, type, mode);
+}
+
+static inline int security_shm_alloc (struct shmid_kernel *shp)
+{
+	return security_ops->shm_alloc_security (shp);
+}
+
+static inline void security_shm_free (struct shmid_kernel *shp)
+{
+	security_ops->shm_free_security (shp);
+}
+
+static inline int security_shm_associate (struct shmid_kernel * shp, 
+					  int shmflg)
+{
+	return security_ops->shm_associate(shp, shmflg);
+}
+
+static inline int security_shm_shmctl (struct shmid_kernel * shp, int cmd)
+{
+	return security_ops->shm_shmctl (shp, cmd);
+}
+
+static inline int security_shm_shmat (struct shmid_kernel * shp, 
+				      char *shmaddr, int shmflg)
+{
+	return security_ops->shm_shmat(shp, shmaddr, shmflg);
+}
+
+static inline int security_sem_alloc (struct sem_array *sma)
+{
+	return security_ops->sem_alloc_security (sma);
+}
+
+static inline void security_sem_free (struct sem_array *sma)
+{
+	security_ops->sem_free_security (sma);
+}
+
+static inline int security_sem_associate (struct sem_array * sma, int semflg)
+{
+	return security_ops->sem_associate (sma, semflg);
+}
+
+static inline int security_sem_semctl (struct sem_array * sma, int cmd)
+{
+	return security_ops->sem_semctl(sma, cmd);
+}
+
+static inline int security_sem_semop (struct sem_array * sma, 
+				      struct sembuf * sops, unsigned nsops, 
+				      int alter)
+{
+	return security_ops->sem_semop(sma, sops, nsops, alter);
+}
+
+static inline void security_d_instantiate (struct dentry *dentry, struct inode *inode)
+{
+	security_ops->d_instantiate (dentry, inode);
+}
+
+static inline int security_getprocattr(struct task_struct *p, char *name, void *value, size_t size)
+{
+	return security_ops->getprocattr(p, name, value, size);
+}
+
+static inline int security_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
+{
+	return security_ops->setprocattr(p, name, value, size);
+}
+
+/* prototypes */
+extern int security_scaffolding_startup	(void);
+extern int register_security	(struct security_operations *ops);
+extern int unregister_security	(struct security_operations *ops);
+extern int mod_reg_security	(const char *name, struct security_operations *ops);
+extern int mod_unreg_security	(const char *name, struct security_operations *ops);
+
+#else /* CONFIG_SECURITY */
+
+/*
+ * This is the default capabilities functionality.  Most of these functions
+ * are just stubbed out, but a few must call the proper capable code.
+ */
+
+static inline int security_scaffolding_startup (void)
+{
+	return 0;
+}
+
+static inline int security_syscall(unsigned int id, unsigned call,
+				   unsigned long *args)
+{
+	return -ENOSYS;
+}
+
+static inline int security_nfsservctl(int cmd, struct nfsctl_arg * arg)
+{
+	return 0;
+}
+
+static inline int security_bdflush(int func, long data)
+{
+	return 0;
+}
+
+static inline int security_module_create(const char *name, size_t size)
+{
+	return 0;
+}
+
+static inline int security_module_initialize(struct module * mod)
+{
+	return 0;
+}
+
+static inline int security_module_delete(const struct module * mod)
+{
+	return 0;
+}
+
+static inline int security_sethostname (char *hostname)
+{
+	return 0;
+}
+
+static inline int security_setdomainname (char *domainname)
+{
+	return 0;
+}
+
+static inline int security_reboot (unsigned int cmd)
+{
+	return 0;
+}
+
+static inline int security_ioperm (unsigned long from, unsigned long num, int turn_on)
+{
+	return 0;
+}
+
+static inline int security_iopl (unsigned int old, unsigned int level)
+{
+	return 0;
+}
+
+static inline int security_ptrace (struct task_struct *parent, struct task_struct * child)
+{
+	return cap_ptrace (parent, child);
+}
+
+static inline int security_capget (struct task_struct *target,
+				   kernel_cap_t *effective,
+				   kernel_cap_t *inheritable,
+				   kernel_cap_t *permitted)
+{
+	return cap_capget (target, effective, inheritable, permitted);
+}
+
+static inline int security_capset_check (struct task_struct *target,
+					 kernel_cap_t *effective,
+					 kernel_cap_t *inheritable,
+					 kernel_cap_t *permitted)
+{
+	return cap_capset_check (target, effective, inheritable, permitted);
+}
+
+static inline void security_capset_set (struct task_struct *target,
+					kernel_cap_t *effective,
+					kernel_cap_t *inheritable,
+					kernel_cap_t *permitted)
+{
+	cap_capset_set (target, effective, inheritable, permitted);
+}
+
+static inline int security_acct (struct file *file)
+{
+	return 0;
+}
+
+static inline int security_sysctl(ctl_table * table, int op)
+{
+	return 0;
+}
+
+static inline int security_capable(struct task_struct * tsk, int cap)
+{
+	return cap_capable(tsk, cap);
+}
+
+static inline int security_swapon(struct swap_info_struct * swap)
+{
+	return 0;
+}
+
+static inline int security_swapoff(struct swap_info_struct * swap)
+{
+	return 0;
+}
+
+static inline int security_quotactl (int cmds, int type, int id,
+				     struct super_block * sb)
+{
+	return 0;
+}
+
+static inline int security_quota_on (struct file * file)
+{
+	return 0;
+}
+
+static inline int security_syslog(int type)
+{
+	return cap_syslog(type);
+}
+
+static inline int security_settime(struct timeval *tv, struct timezone *tz)
+{
+	return 0;
+}
+
+static inline int security_netlink_send(struct sk_buff * skb)
+{
+	return cap_netlink_send(skb);
+}
+
+static inline int security_netlink_recv(struct sk_buff * skb)
+{
+	return cap_netlink_recv(skb);
+}
+
+static inline int security_ip_decode_options(struct sk_buff * skb, 
+					     const char *optptr, 
+					     unsigned char **pp_ptr)
+{
+	return cap_ip_decode_options(skb,optptr,pp_ptr);
+}
+
+static inline int security_bprm_alloc (struct linux_binprm *bprm)
+{
+	return 0;
+}
+
+static inline void security_bprm_free (struct linux_binprm *bprm)
+{ }
+
+static inline void security_bprm_compute_creds (struct linux_binprm *bprm)
+{ 
+	cap_bprm_compute_creds (bprm);
+}
+
+static inline int security_bprm_set (struct linux_binprm *bprm)
+{
+	return cap_bprm_set_security (bprm);
+}
+
+static inline int security_bprm_check (struct linux_binprm *bprm)
+{
+	return 0;
+}
+
+static inline int security_bprm_secureexec (struct linux_binprm *bprm)
+{
+	return cap_bprm_secureexec(bprm);
+}
+
+static inline int security_sb_alloc (struct super_block *sb)
+{
+	return 0;
+}
+
+static inline void security_sb_free (struct super_block *sb)
+{ }
+
+static inline int security_sb_kern_mount (struct super_block *sb)
+{
+	return 0;
+}
+
+static inline int security_sb_statfs (struct super_block *sb)
+{
+	return 0;
+}
+
+static inline int security_sb_mount (char *dev_name, struct nameidata *nd,
+				    char *type, unsigned long flags,
+				    void *data)
+{
+	return 0;
+}
+
+static inline int security_sb_check_sb (struct vfsmount *mnt,
+					struct nameidata *nd)
+{
+	return 0;
+}
+
+static inline int security_sb_umount (struct vfsmount *mnt, int flags)
+{
+	return 0;
+}
+
+static inline void security_sb_umount_close (struct vfsmount *mnt)
+{ }
+
+static inline void security_sb_umount_busy (struct vfsmount *mnt)
+{ }
+
+static inline void security_sb_post_remount (struct vfsmount *mnt,
+					     unsigned long flags, void *data)
+{ }
+
+static inline void security_sb_post_mountroot (void)
+{ }
+
+static inline void security_sb_post_addmount (struct vfsmount *mnt,
+					      struct nameidata *mountpoint_nd)
+{ }
+
+static inline int security_sb_pivotroot (struct nameidata *old_nd,
+					 struct nameidata *new_nd)
+{
+	return 0;
+}
+
+static inline void security_sb_post_pivotroot (struct nameidata *old_nd,
+					       struct nameidata *new_nd)
+{ }
+
+static inline int security_inode_alloc (struct inode *inode)
+{
+	return 0;
+}
+
+static inline void security_inode_free (struct inode *inode)
+{ }
+	
+static inline int security_inode_create (struct inode *dir,
+					 struct dentry *dentry,
+					 int mode)
+{
+	return 0;
+}
+
+static inline void security_inode_post_create (struct inode *dir,
+					       struct dentry *dentry,
+					       int mode)
+{ }
+
+static inline int security_inode_link (struct dentry *old_dentry,
+				       struct inode *dir,
+				       struct dentry *new_dentry)
+{
+	return 0;
+}
+
+static inline void security_inode_post_link (struct dentry *old_dentry,
+					     struct inode *dir,
+					     struct dentry *new_dentry)
+{ }
+
+static inline int security_inode_unlink (struct inode *dir,
+					 struct dentry *dentry)
+{
+	return 0;
+}
+
+static inline int security_inode_symlink (struct inode *dir,
+					  struct dentry *dentry,
+					  const char *old_name)
+{
+	return 0;
+}
+
+static inline void security_inode_post_symlink (struct inode *dir,
+						struct dentry *dentry,
+						const char *old_name)
+{ }
+
+static inline int security_inode_mkdir (struct inode *dir,
+					struct dentry *dentry,
+					int mode)
+{
+	return 0;
+}
+
+static inline void security_inode_post_mkdir (struct inode *dir,
+					      struct dentry *dentry,
+					      int mode)
+{ }
+
+static inline int security_inode_rmdir (struct inode *dir,
+					struct dentry *dentry)
+{
+	return 0;
+}
+
+static inline int security_inode_mknod (struct inode *dir,
+					struct dentry *dentry,
+					int mode, dev_t dev)
+{
+	return 0;
+}
+
+static inline void security_inode_post_mknod (struct inode *dir,
+					      struct dentry *dentry,
+					      int mode, dev_t dev)
+{ }
+
+static inline int security_inode_rename (struct inode *old_dir,
+					 struct dentry *old_dentry,
+					 struct inode *new_dir,
+					 struct dentry *new_dentry)
+{
+	return 0;
+}
+
+static inline void security_inode_post_rename (struct inode *old_dir,
+					       struct dentry *old_dentry,
+					       struct inode *new_dir,
+					       struct dentry *new_dentry)
+{ }
+
+static inline int security_inode_readlink (struct dentry *dentry)
+{
+	return 0;
+}
+
+static inline int security_inode_follow_link (struct dentry *dentry,
+					      struct nameidata *nd)
+{
+	return 0;
+}
+
+static inline int security_inode_permission (struct inode *inode, int mask)
+{
+	return 0;
+}
+
+static inline int security_inode_revalidate (struct dentry *dentry)
+{
+	return 0;
+}
+
+static inline int security_inode_setattr (struct dentry *dentry,
+					  struct iattr *attr)
+{
+	return 0;
+}
+
+static inline int security_inode_stat (struct inode *inode)
+{
+	return 0;
+}
+
+static inline void security_inode_delete (struct inode *inode)
+{ }
+
+static inline int security_inode_setxattr (struct dentry *dentry, char *name,
+					   void *value, size_t size, int flags)
+{
+	return 0;
+}
+
+static inline void security_inode_post_setxattr (struct dentry *dentry, char *name,
+						 void *value, size_t size, int flags)
+{ }
+
+static inline int security_inode_getxattr (struct dentry *dentry, char *name)
+{
+	return 0;
+}
+
+static inline int security_inode_listxattr (struct dentry *dentry)
+{
+	return 0;
+}
+
+static inline int security_inode_removexattr (struct dentry *dentry, char *name)
+{
+	return 0;
+}
+
+static inline int security_inode_getsecurity(struct dentry *dentry, const char *name, void *buffer, size_t size)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int security_inode_setsecurity(struct dentry *dentry, const char *name, const void *value, size_t size, int flags) 
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int security_inode_listsecurity(struct dentry *dentry, char *buffer)
+{
+	return 0;
+}
+
+static inline int security_file_permission (struct file *file, int mask)
+{
+	return 0;
+}
+
+static inline int security_file_alloc (struct file *file)
+{
+	return 0;
+}
+
+static inline void security_file_free (struct file *file)
+{ }
+
+static inline int security_file_ioctl (struct file *file, unsigned int cmd,
+				       unsigned long arg)
+{
+	return 0;
+}
+
+static inline int security_file_mmap (struct file *file, unsigned long prot,
+				      unsigned long flags)
+{
+	return 0;
+}
+
+static inline int security_file_mprotect (struct vm_area_struct *vma,
+					  unsigned long prot)
+{
+	return 0;
+}
+
+static inline int security_file_lock (struct file *file, unsigned int cmd)
+{
+	return 0;
+}
+
+static inline int security_file_fcntl (struct file *file, unsigned int cmd,
+				       unsigned long arg)
+{
+	return 0;
+}
+
+static inline int security_file_set_fowner (struct file *file)
+{
+	return 0;
+}
+
+static inline int security_file_send_sigiotask (struct task_struct *tsk,
+						struct fown_struct *fown,
+						int fd, int reason)
+{
+	return 0;
+}
+
+static inline int security_file_receive (struct file *file)
+{
+	return 0;
+}
+
+static inline int security_task_create (unsigned long clone_flags)
+{
+	return 0;
+}
+
+static inline int security_task_alloc (struct task_struct *p)
+{
+	return 0;
+}
+
+static inline void security_task_free (struct task_struct *p)
+{ }
+
+static inline int security_task_setuid (uid_t id0, uid_t id1, uid_t id2,
+					int flags)
+{
+	return 0;
+}
+
+static inline int security_task_post_setuid (uid_t old_ruid, uid_t old_euid,
+					     uid_t old_suid, int flags)
+{
+	return cap_task_post_setuid (old_ruid, old_euid, old_suid, flags);
+}
+
+static inline int security_task_setgid (gid_t id0, gid_t id1, gid_t id2,
+					int flags)
+{
+	return 0;
+}
+
+static inline int security_task_setpgid (struct task_struct *p, pid_t pgid)
+{
+	return 0;
+}
+
+static inline int security_task_getpgid (struct task_struct *p)
+{
+	return 0;
+}
+
+static inline int security_task_getsid (struct task_struct *p)
+{
+	return 0;
+}
+
+static inline int security_task_setgroups (int gidsetsize, gid_t *grouplist)
+{
+	return 0;
+}
+
+static inline int security_task_setnice (struct task_struct *p, int nice)
+{
+	return 0;
+}
+
+static inline int security_task_setrlimit (unsigned int resource,
+					   struct rlimit *new_rlim)
+{
+	return 0;
+}
+
+static inline int security_task_setscheduler (struct task_struct *p,
+					      int policy,
+					      struct sched_param *lp)
+{
+	return 0;
+}
+
+static inline int security_task_getscheduler (struct task_struct *p)
+{
+	return 0;
+}
+
+static inline int security_task_kill (struct task_struct *p,
+				      struct siginfo *info, int sig)
+{
+	return 0;
+}
+
+static inline int security_task_wait (struct task_struct *p)
+{
+	return 0;
+}
+
+static inline int security_task_prctl (int option, unsigned long arg2,
+				       unsigned long arg3,
+				       unsigned long arg4,
+				       unsigned long arg5)
+{
+	return 0;
+}
+
+static inline void security_task_kmod_set_label (void)
+{
+	cap_task_kmod_set_label ();
+}
+
+static inline void security_task_reparent_to_init (struct task_struct *p)
+{
+	cap_task_reparent_to_init (p);
+}
+
+static inline void security_task_to_inode(struct task_struct *p, struct inode *inode)
+{ }
+
+static inline int security_ipc_permission (struct kern_ipc_perm *ipcp,
+					   short flag)
+{
+	return 0;
+}
+
+static inline int security_msg_msg_alloc (struct msg_msg * msg)
+{
+	return 0;
+}
+
+static inline void security_msg_msg_free (struct msg_msg * msg)
+{ }
+
+static inline int security_msg_queue_alloc (struct msg_queue *msq)
+{
+	return 0;
+}
+
+static inline void security_msg_queue_free (struct msg_queue *msq)
+{ }
+
+static inline int security_msg_queue_associate (struct msg_queue * msq, 
+						int msqflg)
+{
+	return 0;
+}
+
+static inline int security_msg_queue_msgctl (struct msg_queue * msq, int cmd)
+{
+	return 0;
+}
+
+static inline int security_msg_queue_msgsnd (struct msg_queue * msq,
+					     struct msg_msg * msg, int msqflg)
+{
+	return 0;
+}
+
+static inline int security_msg_queue_msgrcv (struct msg_queue * msq,
+					     struct msg_msg * msg,
+					     struct task_struct * target,
+					     long type, int mode)
+{
+	return 0;
+}
+
+static inline int security_shm_alloc (struct shmid_kernel *shp)
+{
+	return 0;
+}
+
+static inline void security_shm_free (struct shmid_kernel *shp)
+{ }
+
+static inline int security_shm_associate (struct shmid_kernel * shp, 
+					  int shmflg)
+{
+	return 0;
+}
+
+static inline int security_shm_shmctl (struct shmid_kernel * shp, int cmd)
+{
+	return 0;
+}
+
+static inline int security_shm_shmat (struct shmid_kernel * shp, 
+				      char *shmaddr, int shmflg)
+{
+	return 0;
+}
+
+static inline int security_sem_alloc (struct sem_array *sma)
+{
+	return 0;
+}
+
+static inline void security_sem_free (struct sem_array *sma)
+{ }
+
+static inline int security_sem_associate (struct sem_array * sma, int semflg)
+{
+	return 0;
+}
+
+static inline int security_sem_semctl (struct sem_array * sma, int cmd)
+{
+	return 0;
+}
+
+static inline int security_sem_semop (struct sem_array * sma, 
+				      struct sembuf * sops, unsigned nsops, 
+				      int alter)
+{
+	return 0;
+}
+
+static inline void security_d_instantiate (struct dentry *dentry, struct inode *inode)
+{ }
+
+static inline int security_getprocattr(struct task_struct *p, char *name, void *value, size_t size)
+{
+	return -EINVAL;
+}
+
+static inline int security_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
+{
+	return -EINVAL;
+}
+
+#endif	/* CONFIG_SECURITY */
+
+#ifdef CONFIG_SECURITY_NETWORK
+
+static inline int security_unix_stream_connect(struct socket * sock,
+					       struct socket * other, 
+					       struct sock * newsk)
+{
+	return security_ops->unix_stream_connect(sock, other, newsk);
+}
+
+
+static inline int security_unix_may_send(struct socket * sock, 
+					 struct socket * other)
+{
+	return security_ops->unix_may_send(sock, other);
+}
+
+static inline int security_socket_create (int family, int type, int protocol)
+{
+	return security_ops->socket_create(family, type, protocol);
+}
+
+static inline void security_socket_post_create(struct socket * sock, 
+					       int family,
+					       int type, 
+					       int protocol)
+{
+	security_ops->socket_post_create(sock, family, type, protocol);
+}
+
+static inline int security_socket_bind(struct socket * sock, 
+				       struct sockaddr * address, 
+				       int addrlen)
+{
+	return security_ops->socket_bind(sock, address, addrlen);
+}
+
+static inline int security_socket_connect(struct socket * sock, 
+					  struct sockaddr * address, 
+					  int addrlen)
+{
+	return security_ops->socket_connect(sock, address, addrlen);
+}
+
+static inline int security_socket_listen(struct socket * sock, int backlog)
+{
+	return security_ops->socket_listen(sock, backlog);
+}
+
+static inline int security_socket_accept(struct socket * sock, 
+					 struct socket * newsock)
+{
+	return security_ops->socket_accept(sock, newsock);
+}
+
+static inline void security_socket_post_accept(struct socket * sock, 
+					       struct socket * newsock)
+{
+	security_ops->socket_post_accept(sock, newsock);
+}
+
+static inline int security_socket_sendmsg(struct socket * sock, 
+					  struct msghdr * msg, int size)
+{
+	return security_ops->socket_sendmsg(sock, msg, size);
+}
+
+static inline int security_socket_recvmsg(struct socket * sock, 
+					  struct msghdr * msg, int size, 
+					  int flags)
+{
+	return security_ops->socket_recvmsg(sock, msg, size, flags);
+}
+
+static inline int security_socket_getsockname(struct socket * sock)
+{
+	return security_ops->socket_getsockname(sock);
+}
+
+static inline int security_socket_getpeername(struct socket * sock)
+{
+	return security_ops->socket_getpeername(sock);
+}
+
+static inline int security_socket_getsockopt(struct socket * sock, 
+					     int level, int optname)
+{
+	return security_ops->socket_getsockopt(sock, level, optname);
+}
+
+static inline int security_socket_setsockopt(struct socket * sock, 
+					     int level, int optname)
+{
+	return security_ops->socket_setsockopt(sock, level, optname);
+}
+
+static inline int security_socket_shutdown(struct socket * sock, int how)
+{
+	return security_ops->socket_shutdown(sock, how);
+}
+
+static inline int security_sock_alloc(struct sock * sk, 
+				      int gfp_mask)
+{
+	return security_ops->socket_sock_alloc_security(sk, gfp_mask);
+}
+
+static inline void security_sock_free(struct sock * sk)
+{
+	security_ops->socket_sock_free_security(sk);
+}
+
+static inline int security_sock_rcv_skb (struct sock * sk, 
+					 struct sk_buff * skb)
+{
+	return security_ops->socket_sock_rcv_skb (sk, skb);
+}
+
+static inline int security_open_request_alloc (struct open_request * req)
+{
+	return security_ops->open_request_alloc_security (req);
+}
+
+static inline void security_open_request_free (struct open_request * req)
+{
+	security_ops->open_request_free_security (req);
+}
+
+static inline void security_tcp_connection_request(struct sock * sk, 
+						   struct sk_buff * skb,
+						   struct open_request * req)
+{
+	security_ops->tcp_connection_request(sk, skb, req);
+}
+
+static inline void security_tcp_synack(struct sock * sk, 
+				       struct sk_buff * skb, 
+				       struct open_request * req)
+{
+	security_ops->tcp_synack(sk, skb, req);
+}
+
+static inline void security_tcp_create_openreq_child(struct sock * sk, 
+						     struct sock * newsk, 
+						     struct sk_buff * skb, 
+						     struct open_request * req)
+{
+	security_ops->tcp_create_openreq_child(sk, newsk, skb, req);
+}
+
+static inline int security_skb_alloc(struct sk_buff * skb, int gfp_mask)
+{
+	return security_ops->skb_alloc_security(skb, gfp_mask);
+}
+
+static inline int security_skb_clone(struct sk_buff * newskb, 
+				     const struct sk_buff * oldskb)
+{
+	return security_ops->skb_clone(newskb, oldskb);
+}
+
+static inline void security_skb_copy(struct sk_buff * newskb, 
+				     const struct sk_buff * oldskb)
+{
+	security_ops->skb_copy(newskb, oldskb);
+}
+
+static inline void security_skb_set_owner_w (struct sk_buff * skb, 
+					     struct sock * sk)
+{
+	security_ops->skb_set_owner_w (skb, sk);
+}
+
+static inline void security_skb_recv_datagram(struct sk_buff * skb, 
+					      struct sock * sk, unsigned flags)
+{
+	security_ops->skb_recv_datagram(skb, sk, flags);
+}
+
+static inline void security_skb_free(struct sk_buff * skb)
+{
+	security_ops->skb_free_security(skb);
+}
+
+static inline void security_ip_fragment(struct sk_buff * newskb, 
+					const struct sk_buff * oldskb)
+{
+	security_ops->ip_fragment(newskb, oldskb);
+}
+
+static inline int security_ip_defragment(struct sk_buff * skb)
+{
+	return security_ops->ip_defragment(skb);
+}
+
+static inline void security_ip_encapsulate(struct sk_buff * skb)
+{
+	security_ops->ip_encapsulate(skb);
+}
+
+static inline void security_ip_decapsulate(struct sk_buff * skb)
+{
+	security_ops->ip_decapsulate(skb);
+}
+
+static inline void security_netdev_unregister(struct net_device * dev)
+{
+	security_ops->netdev_unregister(dev);
+}
+
+#else /* CONFIG_SECURITY_NETWORK */
+
+static inline int security_unix_stream_connect(struct socket * sock,
+					       struct socket * other, 
+					       struct sock * newsk)
+{
+	return 0;
+}
+
+static inline int security_unix_may_send(struct socket * sock, 
+					 struct socket * other)
+{
+	return 0;
+}
+
+static inline int security_socket_create (int family, int type, int protocol)
+{
+	return 0;
+}
+
+static inline void security_socket_post_create(struct socket * sock, 
+					       int family,
+					       int type, 
+					       int protocol)
+{
+}
+
+static inline int security_socket_bind(struct socket * sock, 
+				       struct sockaddr * address, 
+				       int addrlen)
+{
+	return 0;
+}
+
+static inline int security_socket_connect(struct socket * sock, 
+					  struct sockaddr * address, 
+					  int addrlen)
+{
+	return 0;
+}
+
+static inline int security_socket_listen(struct socket * sock, int backlog)
+{
+	return 0;
+}
+
+static inline int security_socket_accept(struct socket * sock, 
+					 struct socket * newsock)
+{
+	return 0;
+}
+
+static inline void security_socket_post_accept(struct socket * sock, 
+					       struct socket * newsock)
+{
+}
+
+static inline int security_socket_sendmsg(struct socket * sock, 
+					  struct msghdr * msg, int size)
+{
+	return 0;
+}
+
+static inline int security_socket_recvmsg(struct socket * sock, 
+					  struct msghdr * msg, int size, 
+					  int flags)
+{
+	return 0;
+}
+
+static inline int security_socket_getsockname(struct socket * sock)
+{
+	return 0;
+}
+
+static inline int security_socket_getpeername(struct socket * sock)
+{
+	return 0;
+}
+
+static inline int security_socket_getsockopt(struct socket * sock, 
+					     int level, int optname)
+{
+	return 0;
+}
+
+static inline int security_socket_setsockopt(struct socket * sock, 
+					     int level, int optname)
+{
+	return 0;
+}
+
+static inline int security_socket_shutdown(struct socket * sock, int how)
+{
+	return 0;
+}
+
+static inline int security_sock_alloc(struct sock * sk, 
+				      int gfp_mask)
+{
+	return 0;
+}
+
+static inline void security_sock_free(struct sock * sk)
+{
+}
+
+static inline int security_sock_rcv_skb (struct sock * sk, 
+					 struct sk_buff * skb)
+{
+	return 0;
+}
+
+static inline int security_open_request_alloc (struct open_request * req)
+{
+	return 0;
+}
+
+static inline void security_open_request_free (struct open_request * req)
+{
+}
+
+static inline void security_tcp_connection_request(struct sock * sk, 
+						   struct sk_buff * skb,
+						   struct open_request * req)
+{
+}
+
+static inline void security_tcp_synack(struct sock * sk, 
+				       struct sk_buff * skb, 
+				       struct open_request * req)
+{
+}
+
+static inline void security_tcp_create_openreq_child(struct sock * sk, 
+						     struct sock * newsk, 
+						     struct sk_buff * skb, 
+						     struct open_request * req)
+{
+}
+
+static inline int security_skb_alloc(struct sk_buff * skb, int gfp_mask)
+{
+	return 0;
+}
+
+static inline int security_skb_clone(struct sk_buff * newskb, 
+				     const struct sk_buff * oldskb)
+{
+	return 0;
+}
+
+static inline void security_skb_copy(struct sk_buff * newskb, 
+				     const struct sk_buff * oldskb)
+{
+}
+
+static inline void security_skb_set_owner_w (struct sk_buff * skb, 
+					     struct sock * sk)
+{
+}
+
+static inline void security_skb_recv_datagram(struct sk_buff * skb, 
+					      struct sock * sk, unsigned flags)
+{
+}
+
+static inline void security_skb_free(struct sk_buff * skb)
+{
+}
+
+static inline void security_ip_fragment(struct sk_buff * newskb, 
+					const struct sk_buff * oldskb)
+{
+}
+
+static inline int security_ip_defragment(struct sk_buff * skb)
+{
+	return 0;
+}
+
+static inline void security_ip_encapsulate(struct sk_buff * skb)
+{
+}
+
+static inline void security_ip_decapsulate(struct sk_buff * skb)
+{
+}
+
+static inline void security_netdev_unregister(struct net_device * dev)
+{
+}
+
+#endif /* CONFIG_SECURITY_NETWORK */
+
+#endif /* ! __LINUX_SECURITY_H */
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/shm.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/shm.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/shm.h	2004-03-02 19:53:09.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/shm.h	2004-03-02 23:41:24.000000000 +0200
@@ -71,6 +71,19 @@ struct shm_info {
 };
 
 #ifdef __KERNEL__
+struct shmid_kernel /* private to the kernel */
+{	
+	struct kern_ipc_perm	shm_perm;
+	struct file *		shm_file;
+	int			id;
+	unsigned long		shm_nattch;
+	unsigned long		shm_segsz;
+	time_t			shm_atim;
+	time_t			shm_dtim;
+	time_t			shm_ctim;
+	pid_t			shm_cprid;
+	pid_t			shm_lprid;
+};
 
 /* shm_mode upper byte flags */
 #define	SHM_DEST	01000	/* segment will be destroyed on last detach */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/linux/skbuff.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/skbuff.h
--- 2425sls2.ea.acl.nfsacl.sec/include/linux/skbuff.h	2004-03-02 19:52:28.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/linux/skbuff.h	2004-03-02 23:41:24.000000000 +0200
@@ -219,6 +219,9 @@ struct sk_buff {
 #ifdef CONFIG_NET_SCHED
        __u32           tc_index;               /* traffic control index */
 #endif
+#ifdef CONFIG_SECURITY_NETWORK
+	void		*lsm_security;		/* replaces the above security field */
+#endif
 };
 
 #define SK_WMEM_MAX	65535
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/net/sock.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/net/sock.h
--- 2425sls2.ea.acl.nfsacl.sec/include/net/sock.h	2004-03-02 19:55:15.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/net/sock.h	2004-03-02 23:41:24.000000000 +0200
@@ -55,6 +55,7 @@
 
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>	/* struct sk_buff */
+#include <linux/security.h>
 #include <net/protocol.h>		/* struct inet_protocol */
 #if defined(CONFIG_X25) || defined(CONFIG_X25_MODULE)
 #include <net/x25.h>
@@ -685,6 +686,11 @@ struct sock {
 
 	/* RPC layer private data */
 	void			*user_data;
+
+#ifdef CONFIG_SECURITY_NETWORK
+	/* LSM security field */
+	void 			*security;
+#endif
   
 	/* Callbacks */
 	void			(*state_change)(struct sock *sk);
@@ -697,6 +703,17 @@ struct sock {
 	void                    (*destruct)(struct sock *sk);
 };
 
+static inline void clone_sk(struct sock *newsk, struct sock *sk) {
+#ifdef CONFIG_SECURITY_NETWORK 
+	/* Save/restore the LSM security pointer around the copy */
+	void *sptr = newsk->security; 
+	memcpy(newsk, sk, sizeof(*newsk));
+	newsk->security = sptr;
+#else
+	memcpy(newsk, sk, sizeof(*newsk));
+#endif
+}
+
 /* The per-socket spinlock must be held here. */
 #define sk_add_backlog(__sk, __skb)			\
 do {	if((__sk)->backlog.tail == NULL) {		\
@@ -922,7 +939,11 @@ extern void sklist_destroy_socket(struct
 
 static inline int sk_filter(struct sock *sk, struct sk_buff *skb, int needlock)
 {
-	int err = 0;
+	int err;
+
+	err = security_sock_rcv_skb(sk, skb);
+	if (err)
+		return err;
 
 	if (sk->filter) {
 		struct sk_filter *filter;
@@ -974,7 +995,7 @@ static inline void sk_filter_charge(stru
 
 static inline int sk_filter(struct sock *sk, struct sk_buff *skb, int needlock)
 {
-	return 0;
+	return security_sock_rcv_skb(sk, skb);
 }
 
 #endif /* CONFIG_FILTER */
@@ -1172,6 +1193,7 @@ static inline void skb_set_owner_w(struc
 	skb->sk = sk;
 	skb->destructor = sock_wfree;
 	atomic_add(skb->truesize, &sk->wmem_alloc);
+	security_skb_set_owner_w(skb, sk);
 }
 
 static inline void skb_set_owner_r(struct sk_buff *skb, struct sock *sk)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/include/net/tcp.h 2425sls2.ea.acl.nfsacl.sec.selinux/include/net/tcp.h
--- 2425sls2.ea.acl.nfsacl.sec/include/net/tcp.h	2004-03-02 19:56:52.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/include/net/tcp.h	2004-03-02 23:41:24.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/tcp.h>
 #include <linux/slab.h>
 #include <linux/cache.h>
+#include <linux/security.h>
 #include <net/checksum.h>
 #include <net/sock.h>
 #include <net/snmp.h>
@@ -522,13 +523,34 @@ struct open_request {
 		struct tcp_v6_open_req v6_req;
 #endif
 	} af;
+#ifdef CONFIG_SECURITY_NETWORK
+	/* LSM security field */
+	void			*security;
+#endif
 };
 
 /* SLAB cache for open requests. */
 extern kmem_cache_t *tcp_openreq_cachep;
 
-#define tcp_openreq_alloc()		kmem_cache_alloc(tcp_openreq_cachep, SLAB_ATOMIC)
-#define tcp_openreq_fastfree(req)	kmem_cache_free(tcp_openreq_cachep, req)
+static inline struct open_request *tcp_openreq_alloc(void)
+{
+	struct open_request *req =
+		kmem_cache_alloc(tcp_openreq_cachep, SLAB_ATOMIC);
+
+	if (req != NULL) {
+		if (security_open_request_alloc(req)) {
+			kmem_cache_free(tcp_openreq_cachep, req);
+			return NULL;
+		}
+	}
+	return req;
+}
+
+static inline void tcp_openreq_fastfree(struct open_request *req)
+{
+	security_open_request_free(req);
+	kmem_cache_free(tcp_openreq_cachep, req);
+}
 
 static inline void tcp_openreq_free(struct open_request *req)
 {
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/init/do_mounts.c 2425sls2.ea.acl.nfsacl.sec.selinux/init/do_mounts.c
--- 2425sls2.ea.acl.nfsacl.sec/init/do_mounts.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/init/do_mounts.c	2004-03-02 23:41:24.000000000 +0200
@@ -8,6 +8,7 @@
 #include <linux/fd.h>
 #include <linux/tty.h>
 #include <linux/init.h>
+#include <linux/security.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
@@ -919,6 +920,7 @@ out:
 	sys_umount("/dev", 0);
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
+	security_sb_post_mountroot();
 	mount_devfs_fs ();
 }
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/init/main.c 2425sls2.ea.acl.nfsacl.sec.selinux/init/main.c
--- 2425sls2.ea.acl.nfsacl.sec/init/main.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/init/main.c	2004-03-02 23:41:24.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/bootmem.h>
 #include <linux/file.h>
 #include <linux/tty.h>
+#include <linux/security.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
@@ -415,6 +416,7 @@ asmlinkage void __init start_kernel(void
   
 	fork_init(num_mappedpages);
 	proc_caches_init();
+	security_scaffolding_startup();
 	vfs_caches_init(num_physpages);
 	buffer_init(num_physpages);
 	page_cache_init(num_physpages);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/ipc/msg.c 2425sls2.ea.acl.nfsacl.sec.selinux/ipc/msg.c
--- 2425sls2.ea.acl.nfsacl.sec/ipc/msg.c	2003-06-13 17:51:39.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/ipc/msg.c	2004-03-02 23:41:24.000000000 +0200
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 #include <linux/list.h>
+#include <linux/security.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -52,34 +53,6 @@ struct msg_msgseg {
 	struct msg_msgseg* next;
 	/* the next part of the message follows immediately */
 };
-/* one msg_msg structure for each message */
-struct msg_msg {
-	struct list_head m_list; 
-	long  m_type;          
-	int m_ts;           /* message text size */
-	struct msg_msgseg* next;
-	/* the actual message follows immediately */
-};
-
-#define DATALEN_MSG	(PAGE_SIZE-sizeof(struct msg_msg))
-#define DATALEN_SEG	(PAGE_SIZE-sizeof(struct msg_msgseg))
-
-/* one msq_queue structure for each present queue on the system */
-struct msg_queue {
-	struct kern_ipc_perm q_perm;
-	time_t q_stime;			/* last msgsnd time */
-	time_t q_rtime;			/* last msgrcv time */
-	time_t q_ctime;			/* last change time */
-	unsigned long q_cbytes;		/* current number of bytes on queue */
-	unsigned long q_qnum;		/* number of messages in queue */
-	unsigned long q_qbytes;		/* max number of bytes on queue */
-	pid_t q_lspid;			/* pid of last msgsnd */
-	pid_t q_lrpid;			/* last receive pid */
-
-	struct list_head q_messages;
-	struct list_head q_receivers;
-	struct list_head q_senders;
-};
 
 #define SEARCH_ANY		1
 #define SEARCH_EQUAL		2
@@ -117,18 +90,29 @@ void __init msg_init (void)
 static int newque (key_t key, int msgflg)
 {
 	int id;
+	int retval;
 	struct msg_queue *msq;
 
 	msq  = (struct msg_queue *) kmalloc (sizeof (*msq), GFP_KERNEL);
 	if (!msq) 
 		return -ENOMEM;
+
+	msq->q_perm.mode = (msgflg & S_IRWXUGO);
+	msq->q_perm.key = key;
+
+	msq->q_perm.security = NULL;
+	retval = security_msg_queue_alloc(msq);
+	if (retval) {
+		kfree(msq);
+		return retval;
+	}
+
 	id = ipc_addid(&msg_ids, &msq->q_perm, msg_ctlmni);
 	if(id == -1) {
+		security_msg_queue_free(msq);
 		kfree(msq);
 		return -ENOSPC;
 	}
-	msq->q_perm.mode = (msgflg & S_IRWXUGO);
-	msq->q_perm.key = key;
 
 	msq->q_stime = msq->q_rtime = 0;
 	msq->q_ctime = CURRENT_TIME;
@@ -146,6 +130,9 @@ static int newque (key_t key, int msgflg
 static void free_msg(struct msg_msg* msg)
 {
 	struct msg_msgseg* seg;
+
+	security_msg_msg_free(msg);
+
 	seg = msg->next;
 	kfree(msg);
 	while(seg != NULL) {
@@ -171,6 +158,7 @@ static struct msg_msg* load_msg(void* sr
 		return ERR_PTR(-ENOMEM);
 
 	msg->next = NULL;
+	msg->security = NULL;
 
 	if (copy_from_user(msg+1, src, alen)) {
 		err = -EFAULT;
@@ -200,6 +188,11 @@ static struct msg_msg* load_msg(void* sr
 		len -= alen;
 		src = ((char*)src)+alen;
 	}
+	
+	err = security_msg_msg_alloc(msg);
+	if (err)
+		goto out_err;
+
 	return msg;
 
 out_err:
@@ -297,6 +290,7 @@ static void freeque (int id)
 		free_msg(msg);
 	}
 	atomic_sub(msq->q_cbytes, &msg_bytes);
+	security_msg_queue_free(msq);
 	kfree(msq);
 }
 
@@ -321,8 +315,12 @@ asmlinkage long sys_msgget (key_t key, i
 			BUG();
 		if (ipcperms(&msq->q_perm, msgflg))
 			ret = -EACCES;
-		else
-			ret = msg_buildid(id, msq->q_perm.seq);
+		else {
+			int qid = msg_buildid(id, msq->q_perm.seq);
+		    	ret = security_msg_queue_associate(msq, msgflg);
+			if (!ret)
+				ret = qid;
+		}
 		msg_unlock(id);
 	}
 	up(&msg_ids.sem);
@@ -444,6 +442,11 @@ asmlinkage long sys_msgctl (int msqid, i
 		 * due to padding, it's not enough
 		 * to set all member fields.
 		 */
+
+		err = security_msg_queue_msgctl(NULL, cmd);
+		if (err)
+			return err;
+
 		memset(&msginfo,0,sizeof(msginfo));	
 		msginfo.msgmni = msg_ctlmni;
 		msginfo.msgmax = msg_ctlmax;
@@ -494,6 +497,10 @@ asmlinkage long sys_msgctl (int msqid, i
 		if (ipcperms (&msq->q_perm, S_IRUGO))
 			goto out_unlock;
 
+		err = security_msg_queue_msgctl(msq, cmd);
+		if (err)
+			goto out_unlock;
+
 		kernel_to_ipc64_perm(&msq->q_perm, &tbuf.msg_perm);
 		tbuf.msg_stime  = msq->q_stime;
 		tbuf.msg_rtime  = msq->q_rtime;
@@ -536,11 +543,16 @@ asmlinkage long sys_msgctl (int msqid, i
 	    /* We _could_ check for CAP_CHOWN above, but we don't */
 		goto out_unlock_up;
 
+	err = security_msg_queue_msgctl(msq, cmd);
+	if (err)
+		goto out_unlock_up;
+
 	switch (cmd) {
 	case IPC_SET:
 	{
 		if (setbuf.qbytes > msg_ctlmnb && !capable(CAP_SYS_RESOURCE))
 			goto out_unlock_up;
+		
 		msq->q_qbytes = setbuf.qbytes;
 
 		ipcp->uid = setbuf.uid;
@@ -606,7 +618,8 @@ static int inline pipelined_send(struct 
 		struct msg_receiver* msr;
 		msr = list_entry(tmp,struct msg_receiver,r_list);
 		tmp = tmp->next;
-		if(testmsg(msg,msr->r_msgtype,msr->r_mode)) {
+		if(testmsg(msg,msr->r_msgtype,msr->r_mode) &&
+		   !security_msg_queue_msgrcv(msq, msg, msr->r_tsk, msr->r_msgtype, msr->r_mode)) {
 			list_del(&msr->r_list);
 			if(msr->r_maxsize < msg->m_ts) {
 				msr->r_msg = ERR_PTR(-E2BIG);
@@ -657,6 +670,10 @@ retry:
 	if (ipcperms(&msq->q_perm, S_IWUGO)) 
 		goto out_unlock_free;
 
+	err = security_msg_queue_msgsnd(msq, msg, msgflg);
+	if (err)
+		goto out_unlock_free;
+
 	if(msgsz + msq->q_cbytes > msq->q_qbytes ||
 		1 + msq->q_qnum > msq->q_qbytes) {
 		struct msg_sender s;
@@ -755,7 +772,8 @@ retry:
 	found_msg=NULL;
 	while (tmp != &msq->q_messages) {
 		msg = list_entry(tmp,struct msg_msg,m_list);
-		if(testmsg(msg,msgtyp,mode)) {
+		if(testmsg(msg,msgtyp,mode) &&
+		   !security_msg_queue_msgrcv(msq, msg, current, msgtyp, mode)) {
 			found_msg = msg;
 			if(mode == SEARCH_LESSEQUAL && msg->m_type != 1) {
 				found_msg=msg;
@@ -773,6 +791,7 @@ retry:
 			err=-E2BIG;
 			goto out_unlock;
 		}
+
 		list_del(&msg->m_list);
 		msq->q_qnum--;
 		msq->q_rtime = CURRENT_TIME;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/ipc/sem.c 2425sls2.ea.acl.nfsacl.sec.selinux/ipc/sem.c
--- 2425sls2.ea.acl.nfsacl.sec/ipc/sem.c	2003-08-25 14:44:44.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/ipc/sem.c	2004-03-02 23:41:24.000000000 +0200
@@ -63,6 +63,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 #include <linux/time.h>
+#include <linux/security.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -115,6 +116,7 @@ void __init sem_init (void)
 static int newary (key_t key, int nsems, int semflg)
 {
 	int id;
+	int retval;
 	struct sem_array *sma;
 	int size;
 
@@ -129,16 +131,25 @@ static int newary (key_t key, int nsems,
 		return -ENOMEM;
 	}
 	memset (sma, 0, size);
+
+	sma->sem_perm.mode = (semflg & S_IRWXUGO);
+	sma->sem_perm.key = key;
+
+	sma->sem_perm.security = NULL;
+	retval = security_sem_alloc(sma);
+	if (retval) {
+		ipc_free(sma, size);
+		return retval;
+	}
+
 	id = ipc_addid(&sem_ids, &sma->sem_perm, sc_semmni);
 	if(id == -1) {
+		security_sem_free(sma);
 		ipc_free(sma, size);
 		return -ENOSPC;
 	}
 	used_sems += nsems;
 
-	sma->sem_perm.mode = (semflg & S_IRWXUGO);
-	sma->sem_perm.key = key;
-
 	sma->sem_base = (struct sem *) &sma[1];
 	/* sma->sem_pending = NULL; */
 	sma->sem_pending_last = &sma->sem_pending;
@@ -176,8 +187,12 @@ asmlinkage long sys_semget (key_t key, i
 			err = -EINVAL;
 		else if (ipcperms(&sma->sem_perm, semflg))
 			err = -EACCES;
-		else
-			err = sem_buildid(id, sma->sem_perm.seq);
+		else {
+			int semid = sem_buildid(id, sma->sem_perm.seq);
+			err = security_sem_associate(sma, semflg);
+			if (!err)
+				err = semid;
+		}
 		sem_unlock(id);
 	}
 
@@ -411,6 +426,7 @@ static void freeary (int id)
 
 	used_sems -= sma->sem_nsems;
 	size = sizeof (*sma) + sma->sem_nsems * sizeof (struct sem);
+	security_sem_free(sma);
 	ipc_free(sma, size);
 }
 
@@ -447,6 +463,10 @@ static int semctl_nolock(int semid, int 
 		struct seminfo seminfo;
 		int max_id;
 
+		err = security_sem_semctl(NULL, cmd);
+		if (err)
+			return err;
+		
 		memset(&seminfo,0,sizeof(seminfo));
 		seminfo.semmni = sc_semmni;
 		seminfo.semmns = sc_semmns;
@@ -488,6 +508,11 @@ static int semctl_nolock(int semid, int 
 		err = -EACCES;
 		if (ipcperms (&sma->sem_perm, S_IRUGO))
 			goto out_unlock;
+
+		err = security_sem_semctl(sma, cmd);
+		if (err)
+			goto out_unlock;
+
 		id = sem_buildid(semid, sma->sem_perm.seq);
 
 		kernel_to_ipc64_perm(&sma->sem_perm, &tbuf.sem_perm);
@@ -531,6 +556,11 @@ static int semctl_main(int semid, int se
 	if (ipcperms (&sma->sem_perm, (cmd==SETVAL||cmd==SETALL)?S_IWUGO:S_IRUGO))
 		goto out_unlock;
 
+	err = security_sem_semctl(sma, cmd);
+	if (err)
+		goto out_unlock;
+
+	err = -EACCES;
 	switch (cmd) {
 	case GETALL:
 	{
@@ -722,6 +752,10 @@ static int semctl_down(int semid, int se
 		goto out_unlock;
 	}
 
+	err = security_sem_semctl(sma, cmd);
+	if (err)
+		goto out_unlock;
+
 	switch(cmd){
 	case IPC_RMID:
 		freeary(semid);
@@ -899,6 +933,12 @@ asmlinkage long sys_semtimedop (int semi
 	error = -EACCES;
 	if (ipcperms(&sma->sem_perm, alter ? S_IWUGO : S_IRUGO))
 		goto out_unlock_free;
+
+	error = security_sem_semop(sma, sops, nsops, alter);
+	if (error)
+		goto out_unlock_free;
+	error = -EACCES;		
+
 	if (undos) {
 		/* Make sure we have an undo structure
 		 * for this process and this semaphore set.
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/ipc/shm.c 2425sls2.ea.acl.nfsacl.sec.selinux/ipc/shm.c
--- 2425sls2.ea.acl.nfsacl.sec/ipc/shm.c	2002-08-03 03:39:46.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/ipc/shm.c	2004-03-02 23:41:24.000000000 +0200
@@ -22,24 +22,11 @@
 #include <linux/file.h>
 #include <linux/mman.h>
 #include <linux/proc_fs.h>
+#include <linux/security.h>
 #include <asm/uaccess.h>
 
 #include "util.h"
 
-struct shmid_kernel /* private to the kernel */
-{	
-	struct kern_ipc_perm	shm_perm;
-	struct file *		shm_file;
-	int			id;
-	unsigned long		shm_nattch;
-	unsigned long		shm_segsz;
-	time_t			shm_atim;
-	time_t			shm_dtim;
-	time_t			shm_ctim;
-	pid_t			shm_cprid;
-	pid_t			shm_lprid;
-};
-
 #define shm_flags	shm_perm.mode
 
 static struct file_operations shm_file_operations;
@@ -125,8 +112,10 @@ static void shm_destroy (struct shmid_ke
 	shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid (shp->id);
 	shm_unlock(shp->id);
+
 	shmem_lock(shp->shm_file, 0);
 	fput (shp->shm_file);
+	security_shm_free(shp);
 	kfree (shp);
 }
 
@@ -193,6 +182,17 @@ static int newseg (key_t key, int shmflg
 	shp = (struct shmid_kernel *) kmalloc (sizeof (*shp), GFP_USER);
 	if (!shp)
 		return -ENOMEM;
+
+	shp->shm_perm.key = key;
+	shp->shm_flags = (shmflg & S_IRWXUGO);
+
+	shp->shm_perm.security = NULL;
+	error = security_shm_alloc(shp);
+	if (error) {
+		kfree(shp);
+		return error;
+	}
+
 	sprintf (name, "SYSV%08x", key);
 	file = shmem_file_setup(name, size);
 	error = PTR_ERR(file);
@@ -203,8 +203,7 @@ static int newseg (key_t key, int shmflg
 	id = shm_addid(shp);
 	if(id == -1) 
 		goto no_id;
-	shp->shm_perm.key = key;
-	shp->shm_flags = (shmflg & S_IRWXUGO);
+
 	shp->shm_cprid = current->pid;
 	shp->shm_lprid = 0;
 	shp->shm_atim = shp->shm_dtim = 0;
@@ -222,6 +221,7 @@ static int newseg (key_t key, int shmflg
 no_id:
 	fput(file);
 no_file:
+	security_shm_free(shp);
 	kfree(shp);
 	return error;
 }
@@ -249,8 +249,12 @@ asmlinkage long sys_shmget (key_t key, s
 			err = -EINVAL;
 		else if (ipcperms(&shp->shm_perm, shmflg))
 			err = -EACCES;
-		else
-			err = shm_buildid(id, shp->shm_perm.seq);
+		else {
+			int shmid = shm_buildid(id, shp->shm_perm.seq);
+			err = security_shm_associate(shp, shmflg);
+			if (!err)
+				err = shmid;
+		}
 		shm_unlock(id);
 	}
 	up(&shm_ids.sem);
@@ -388,6 +392,10 @@ asmlinkage long sys_shmctl (int shmid, i
 	{
 		struct shminfo64 shminfo;
 
+		err = security_shm_shmctl(NULL, cmd);
+		if (err)
+			return err;
+
 		memset(&shminfo,0,sizeof(shminfo));
 		shminfo.shmmni = shminfo.shmseg = shm_ctlmni;
 		shminfo.shmmax = shm_ctlmax;
@@ -406,6 +414,10 @@ asmlinkage long sys_shmctl (int shmid, i
 	{
 		struct shm_info shm_info;
 
+		err = security_shm_shmctl(NULL, cmd);
+		if (err)
+			return err;
+
 		memset(&shm_info,0,sizeof(shm_info));
 		down(&shm_ids.sem);
 		shm_lockall();
@@ -431,6 +443,7 @@ asmlinkage long sys_shmctl (int shmid, i
 		shp = shm_lock(shmid);
 		if(shp==NULL)
 			return -EINVAL;
+
 		if(cmd==SHM_STAT) {
 			err = -EINVAL;
 			if (shmid > shm_ids.max_id)
@@ -445,6 +458,11 @@ asmlinkage long sys_shmctl (int shmid, i
 		err=-EACCES;
 		if (ipcperms (&shp->shm_perm, S_IRUGO))
 			goto out_unlock;
+
+		err = security_shm_shmctl(shp, cmd);
+		if (err)
+			goto out_unlock;
+		
 		kernel_to_ipc64_perm(&shp->shm_perm, &tbuf.shm_perm);
 		tbuf.shm_segsz	= shp->shm_segsz;
 		tbuf.shm_atime	= shp->shm_atim;
@@ -473,6 +491,11 @@ asmlinkage long sys_shmctl (int shmid, i
 		err = shm_checkid(shp,shmid);
 		if(err)
 			goto out_unlock;
+
+		err = security_shm_shmctl(shp, cmd);
+		if (err)
+			goto out_unlock;
+		
 		if(cmd==SHM_LOCK) {
 			shmem_lock(shp->shm_file, 1);
 			shp->shm_flags |= SHM_LOCKED;
@@ -503,12 +526,18 @@ asmlinkage long sys_shmctl (int shmid, i
 		err = shm_checkid(shp, shmid);
 		if(err)
 			goto out_unlock_up;
+
 		if (current->euid != shp->shm_perm.uid &&
 		    current->euid != shp->shm_perm.cuid && 
 		    !capable(CAP_SYS_ADMIN)) {
 			err=-EPERM;
 			goto out_unlock_up;
 		}
+
+		err = security_shm_shmctl(shp, cmd);
+		if (err)
+			goto out_unlock_up;
+
 		if (shp->shm_nattch){
 			shp->shm_flags |= SHM_DEST;
 			/* Do not find it any more */
@@ -532,12 +561,17 @@ asmlinkage long sys_shmctl (int shmid, i
 		err = shm_checkid(shp,shmid);
 		if(err)
 			goto out_unlock_up;
+
 		err=-EPERM;
 		if (current->euid != shp->shm_perm.uid &&
 		    current->euid != shp->shm_perm.cuid && 
 		    !capable(CAP_SYS_ADMIN)) {
 			goto out_unlock_up;
 		}
+		
+		err = security_shm_shmctl(shp, cmd);
+		if (err)
+			goto out_unlock_up;
 
 		shp->shm_perm.uid = setbuf.uid;
 		shp->shm_perm.gid = setbuf.gid;
@@ -622,6 +656,13 @@ asmlinkage long sys_shmat (int shmid, ch
 		shm_unlock(shmid);
 		return -EACCES;
 	}
+
+	err = security_shm_shmat(shp, shmaddr, shmflg);
+	if (err) {
+		shm_unlock(shmid);
+		return err;
+	}
+		
 	file = shp->shm_file;
 	size = file->f_dentry->d_inode->i_size;
 	shp->shm_nattch++;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/ipc/util.c 2425sls2.ea.acl.nfsacl.sec.selinux/ipc/util.c
--- 2425sls2.ea.acl.nfsacl.sec/ipc/util.c	2003-08-25 14:44:44.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/ipc/util.c	2004-03-02 23:41:24.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
 #include <linux/highuid.h>
+#include <linux/security.h>
 
 #if defined(CONFIG_SYSVIPC)
 
@@ -263,7 +264,7 @@ int ipcperms (struct kern_ipc_perm *ipcp
 	    !capable(CAP_IPC_OWNER))
 		return -1;
 
-	return 0;
+	return security_ipc_permission(ipcp, flag);
 }
 
 /*
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/acct.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/acct.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/acct.c	2002-08-03 03:39:46.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/acct.c	2004-03-02 23:41:24.000000000 +0200
@@ -54,7 +54,7 @@
 #include <linux/smp_lock.h>
 #include <linux/file.h>
 #include <linux/tty.h>
-
+#include <linux/security.h>
 #include <asm/uaccess.h>
 
 /*
@@ -182,6 +182,10 @@ asmlinkage long sys_acct(const char *nam
 			goto out_err;
 	}
 
+	error = security_acct(file);
+	if (error)
+		goto out_err;
+
 	error = 0;
 	lock_kernel();
 	if (acct_file) {
@@ -209,7 +213,8 @@ asmlinkage long sys_acct(const char *nam
 out:
 	return error;
 out_err:
-	filp_close(file, NULL);
+	if (file)
+		filp_close(file, NULL);
 	goto out;
 }
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/capability.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/capability.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/capability.c	2000-06-24 07:06:37.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/capability.c	2004-03-02 23:41:24.000000000 +0200
@@ -6,6 +6,7 @@
  */ 
 
 #include <linux/mm.h>
+#include <linux/security.h>
 #include <asm/uaccess.h>
 
 kernel_cap_t cap_bset = CAP_INIT_EFF_SET;
@@ -57,9 +58,7 @@ asmlinkage long sys_capget(cap_user_head
      }
 
      if (!error) { 
-	     data.permitted = cap_t(target->cap_permitted);
-	     data.inheritable = cap_t(target->cap_inheritable); 
-	     data.effective = cap_t(target->cap_effective);
+	     error = security_capget(target, &data.effective, &data.inheritable, &data.permitted);
      }
 
      if (target != current)
@@ -88,9 +87,7 @@ static void cap_set_pg(int pgrp,
      for_each_task(target) {
              if (target->pgrp != pgrp)
                      continue;
-             target->cap_effective   = *effective;
-             target->cap_inheritable = *inheritable;
-             target->cap_permitted   = *permitted;
+	     security_capset_set(target, effective, inheritable, permitted);
      }
      read_unlock(&tasklist_lock);
 }
@@ -109,9 +106,7 @@ static void cap_set_all(kernel_cap_t *ef
      for_each_task(target) {
              if (target == current || target->pid == 1)
                      continue;
-             target->cap_effective   = *effective;
-             target->cap_inheritable = *inheritable;
-             target->cap_permitted   = *permitted;
+	     security_capset_set(target, effective, inheritable, permitted);
      }
      read_unlock(&tasklist_lock);
 }
@@ -168,30 +163,12 @@ asmlinkage long sys_capset(cap_user_head
              target = current;
      }
 
-
-     /* verify restrictions on target's new Inheritable set */
-     if (!cap_issubset(inheritable,
-                       cap_combine(target->cap_inheritable,
-                                   current->cap_permitted))) {
-             goto out;
-     }
-
-     /* verify restrictions on target's new Permitted set */
-     if (!cap_issubset(permitted,
-                       cap_combine(target->cap_permitted,
-                                   current->cap_permitted))) {
-             goto out;
-     }
-
-     /* verify the _new_Effective_ is a subset of the _new_Permitted_ */
-     if (!cap_issubset(effective, permitted)) {
-             goto out;
-     }
+     error = security_capset_check(target, &effective, &inheritable, &permitted);
+     if (error)
+	     goto out;
 
      /* having verified that the proposed changes are legal,
            we now put them into effect. */
-     error = 0;
-
      if (pid < 0) {
              if (pid == -1)  /* all procs other than current and init */
                      cap_set_all(&effective, &inheritable, &permitted);
@@ -200,10 +177,7 @@ asmlinkage long sys_capset(cap_user_head
                      cap_set_pg(-pid, &effective, &inheritable, &permitted);
              goto spin_out;
      } else {
-             /* FIXME: do we need to have a write lock here..? */
-             target->cap_effective   = effective;
-             target->cap_inheritable = inheritable;
-             target->cap_permitted   = permitted;
+	     security_capset_set(target, &effective, &inheritable, &permitted);
      }
 
 out:
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/exit.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/exit.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/exit.c	2002-11-29 01:53:15.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/exit.c	2004-03-02 23:41:24.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/personality.h>
 #include <linux/tty.h>
 #include <linux/namespace.h>
+#include <linux/security.h>
 #ifdef CONFIG_BSD_PROCESS_ACCT
 #include <linux/acct.h>
 #endif
@@ -47,6 +48,7 @@ static void release_task(struct task_str
 		task_unlock(p);
 #endif
 		atomic_dec(&p->user->processes);
+		security_task_free(p);
 		free_uid(p->user);
 		unhash_process(p);
 
@@ -525,6 +527,10 @@ repeat:
 			if (((p->exit_signal != SIGCHLD) ^ ((options & __WCLONE) != 0))
 			    && !(options & __WALL))
 				continue;
+
+			if (security_task_wait(p))
+				continue;
+
 			flag = 1;
 			switch (p->state) {
 			case TASK_STOPPED:
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/fork.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/fork.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/fork.c	2004-03-02 23:20:51.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/fork.c	2004-03-02 23:41:24.000000000 +0200
@@ -22,6 +22,7 @@
 #include <linux/namespace.h>
 #include <linux/personality.h>
 #include <linux/compiler.h>
+#include <linux/security.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -657,6 +658,10 @@ int do_fork(unsigned long clone_flags, u
 			goto fork_out;
 	}
 
+	retval = security_task_create(clone_flags);
+	if (retval)
+		goto fork_out;
+
 	retval = -ENOMEM;
 	p = alloc_task_struct();
 	if (!p)
@@ -738,13 +743,16 @@ int do_fork(unsigned long clone_flags, u
 #endif
 	p->lock_depth = -1;		/* -1 = no lock */
 	p->start_time = jiffies;
+	p->security = NULL;
 
 	INIT_LIST_HEAD(&p->local_pages);
 
 	retval = -ENOMEM;
+	if (security_task_alloc(p))
+		goto bad_fork_cleanup;
 	/* copy all the process information */
 	if (copy_files(clone_flags, p))
-		goto bad_fork_cleanup;
+		goto bad_fork_cleanup_security;
 	if (copy_fs(clone_flags, p))
 		goto bad_fork_cleanup_files;
 	if (copy_sighand(clone_flags, p))
@@ -833,6 +841,8 @@ bad_fork_cleanup_fs:
 	exit_fs(p); /* blocking */
 bad_fork_cleanup_files:
 	exit_files(p); /* blocking */
+bad_fork_cleanup_security:
+	security_task_free(p);
 bad_fork_cleanup:
 	put_exec_domain(p->exec_domain);
 	if (p->binfmt && p->binfmt->module)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/kmod.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/kmod.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/kmod.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/kmod.c	2004-03-02 23:41:24.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/slab.h>
 #include <linux/namespace.h>
 #include <linux/completion.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -127,7 +128,7 @@ int exec_usermodehelper(char *program_pa
 
 	curtask->ngroups = 0;
 
-	cap_set_full(curtask->cap_effective);
+	security_task_kmod_set_label();
 
 	/* Allow execve args to be in kernel space. */
 	set_fs(KERNEL_DS);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/ksyms.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/ksyms.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/ksyms.c	2004-03-02 23:29:59.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/ksyms.c	2004-03-02 23:41:24.000000000 +0200
@@ -184,7 +184,8 @@ EXPORT_SYMBOL(__mark_buffer_dirty);
 EXPORT_SYMBOL(__mark_inode_dirty);
 EXPORT_SYMBOL(fd_install);
 EXPORT_SYMBOL(get_empty_filp);
-EXPORT_SYMBOL(init_private_file);
+EXPORT_SYMBOL(open_private_file);
+EXPORT_SYMBOL(close_private_file);
 EXPORT_SYMBOL(filp_open);
 EXPORT_SYMBOL(filp_close);
 EXPORT_SYMBOL(put_filp);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/module.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/module.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/module.c	2003-08-25 14:44:44.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/module.c	2004-03-02 23:41:24.000000000 +0200
@@ -10,6 +10,7 @@
 #include <linux/slab.h>
 #include <linux/kmod.h>
 #include <linux/seq_file.h>
+#include <linux/security.h>
 
 /*
  * Originally by Anonymous (as far as I know...)
@@ -311,6 +312,12 @@ sys_create_module(const char *name_user,
 		error = -EEXIST;
 		goto err1;
 	}
+
+	/* check that we have permission to do this */
+	error = security_module_create(name, size);
+	if (error)
+		goto err1;
+
 	if ((mod = (struct module *)module_map(size)) == NULL) {
 		error = -ENOMEM;
 		goto err1;
@@ -510,6 +517,12 @@ sys_init_module(const char *name_user, s
 		goto err3;
 	}
 
+	/* check that we have permission to do this */
+	error = security_module_initialize(mod);
+	if (error)
+		goto err3;
+	error = -EINVAL;
+
 	if (module_arch_init(mod))
 		goto err3;
 
@@ -631,6 +644,12 @@ sys_delete_module(const char *name_user)
 
 		spin_lock(&unload_lock);
 		if (!__MOD_IN_USE(mod)) {
+			/* check that we have permission to do this */
+			error = security_module_delete(mod);
+			if (error) {
+				spin_unlock(&unload_lock);
+				goto out;
+			}
 			mod->flags |= MOD_DELETED;
 			spin_unlock(&unload_lock);
 			free_module(mod, 0);
@@ -659,6 +678,13 @@ restart:
 				spin_unlock(&unload_lock);
 				mod->flags &= ~MOD_VISITED;
 			} else {
+				/* check that we have permission to do this
+				 * an error is not propagated if perm fails
+				 */
+				if (security_module_delete(mod)) {
+					spin_unlock(&unload_lock);
+					continue;
+				}
 				mod->flags |= MOD_DELETED;
 				spin_unlock(&unload_lock);
 				free_module(mod, 1);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/printk.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/printk.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/printk.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/printk.c	2004-03-02 23:41:24.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/config.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -176,6 +177,10 @@ int do_syslog(int type, char * buf, int 
 	char c;
 	int error = 0;
 
+	error = security_syslog(type);
+	if (error)
+		return error;
+
 	switch (type) {
 	case 0:		/* Close log */
 		break;
@@ -298,8 +303,6 @@ out:
 
 asmlinkage long sys_syslog(int type, char * buf, int len)
 {
-	if ((type != 3) && !capable(CAP_SYS_ADMIN))
-		return -EPERM;
 	return do_syslog(type, buf, len);
 }
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/ptrace.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/ptrace.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/ptrace.c	2003-08-25 14:44:44.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/ptrace.c	2004-03-02 23:41:24.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/highmem.h>
 #include <linux/smp_lock.h>
+#include <linux/security.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -55,7 +56,9 @@ int ptrace_check_attach(struct task_stru
 
 int ptrace_attach(struct task_struct *task)
 {
+	int retval;
 	task_lock(task);
+	retval = -EPERM;
 	if (task->pid <= 1)
 		goto bad;
 	if (task == current)
@@ -67,7 +70,6 @@ int ptrace_attach(struct task_struct *ta
 	    (current->uid != task->uid) ||
  	    (current->gid != task->egid) ||
  	    (current->gid != task->sgid) ||
- 	    (!cap_issubset(task->cap_permitted, current->cap_permitted)) ||
  	    (current->gid != task->gid)) && !capable(CAP_SYS_PTRACE))
 		goto bad;
 	rmb();
@@ -76,6 +78,9 @@ int ptrace_attach(struct task_struct *ta
 	/* the same process cannot be attached many times */
 	if (task->ptrace & PT_PTRACED)
 		goto bad;
+	retval = security_ptrace(current, task);
+	if (retval)
+		goto bad;
 
 	/* Go */
 	task->ptrace |= PT_PTRACED;
@@ -96,7 +101,7 @@ int ptrace_attach(struct task_struct *ta
 
 bad:
 	task_unlock(task);
-	return -EPERM;
+	return retval;
 }
 
 int ptrace_detach(struct task_struct *child, unsigned int data)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/sched.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/sched.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/sched.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/sched.c	2004-03-02 23:41:24.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/completion.h>
 #include <linux/prefetch.h>
 #include <linux/compiler.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -899,6 +900,7 @@ void set_cpus_allowed(struct task_struct
 asmlinkage long sys_nice(int increment)
 {
 	long newprio;
+	int retval;
 
 	/*
 	 *	Setpriority might change our priority at the same moment.
@@ -919,6 +921,11 @@ asmlinkage long sys_nice(int increment)
 		newprio = -20;
 	if (newprio > 19)
 		newprio = 19;
+
+	retval = security_task_setnice(current, newprio);
+	if (retval)
+		return retval;
+	
 	current->nice = newprio;
 	return 0;
 }
@@ -988,6 +995,10 @@ static int setscheduler(pid_t pid, int p
 	    !capable(CAP_SYS_NICE))
 		goto out_unlock;
 
+	retval = security_task_setscheduler(p, policy, &lp);
+	if (retval)
+		goto out_unlock;
+
 	retval = 0;
 	p->policy = policy;
 	p->rt_priority = lp.sched_priority;
@@ -1025,8 +1036,11 @@ asmlinkage long sys_sched_getscheduler(p
 	retval = -ESRCH;
 	read_lock(&tasklist_lock);
 	p = find_process_by_pid(pid);
-	if (p)
-		retval = p->policy & ~SCHED_YIELD;
+	if (p) {
+		retval = security_task_getscheduler(p);
+		if (!retval)
+			retval = p->policy & ~SCHED_YIELD;
+	}
 	read_unlock(&tasklist_lock);
 
 out_nounlock:
@@ -1048,6 +1062,11 @@ asmlinkage long sys_sched_getparam(pid_t
 	retval = -ESRCH;
 	if (!p)
 		goto out_unlock;
+
+	retval = security_task_getscheduler(p);
+	if (retval)
+		goto out_unlock;
+
 	lp.sched_priority = p->rt_priority;
 	read_unlock(&tasklist_lock);
 
@@ -1167,14 +1186,21 @@ asmlinkage long sys_sched_rr_get_interva
 	retval = -ESRCH;
 	read_lock(&tasklist_lock);
 	p = find_process_by_pid(pid);
-	if (p)
-		jiffies_to_timespec(p->policy & SCHED_FIFO ? 0 : NICE_TO_TICKS(p->nice),
-				    &t);
+	if (!p)
+		goto out_unlock;
+
+	retval = security_task_getscheduler(p);
+	if (retval)
+		goto out_unlock;
+
+	jiffies_to_timespec(p->policy & SCHED_FIFO ? 0 : NICE_TO_TICKS(p->nice), &t);
 	read_unlock(&tasklist_lock);
-	if (p)
-		retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0;
+	retval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0;
 out_nounlock:
 	return retval;
+out_unlock:
+	read_unlock(&tasklist_lock);
+	return retval;
 }
 
 static void show_task(struct task_struct * p)
@@ -1307,10 +1333,7 @@ void reparent_to_init(void)
 	/* cpus_allowed? */
 	/* rt_priority? */
 	/* signals? */
-	this_task->cap_effective = CAP_INIT_EFF_SET;
-	this_task->cap_inheritable = CAP_INIT_INH_SET;
-	this_task->cap_permitted = CAP_FULL_SET;
-	this_task->keep_capabilities = 0;
+	security_task_reparent_to_init(this_task);
 	memcpy(this_task->rlim, init_task.rlim, sizeof(*(this_task->rlim)));
 	switch_uid(INIT_USER);
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/signal.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/signal.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/signal.c	2004-02-18 15:36:32.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/signal.c	2004-03-02 23:41:24.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -547,6 +548,9 @@ printk("SIG queue (%s:%d): %d ", t->comm
 	ret = -EPERM;
 	if (bad_signal(sig, info, t))
 		goto out_nolock;
+	ret = security_task_kill(t, info, sig);
+	if (ret)
+		goto out_nolock;
 
 	/* The null signal is a permissions and process existence probe.
 	   No signal is actually delivered.  Same goes for zombies. */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/sys.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/sys.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/sys.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/sys.c	2004-03-02 23:41:24.000000000 +0200
@@ -14,6 +14,7 @@
 #include <linux/prctl.h>
 #include <linux/init.h>
 #include <linux/highuid.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -230,6 +231,7 @@ asmlinkage long sys_setpriority(int whic
 
 	read_lock(&tasklist_lock);
 	for_each_task(p) {
+		int no_nice;
 		if (!proc_sel(p, which, who))
 			continue;
 		if (p->uid != current->euid &&
@@ -237,12 +239,18 @@ asmlinkage long sys_setpriority(int whic
 			error = -EPERM;
 			continue;
 		}
+		if (niceval < p->nice && !capable(CAP_SYS_NICE)) {
+			error = -EACCES;
+			continue;
+		}
+		no_nice = security_task_setnice(p, niceval);
+		if (no_nice) {
+			error = no_nice;
+			continue;
+		}
 		if (error == -ESRCH)
 			error = 0;
-		if (niceval < p->nice && !capable(CAP_SYS_NICE))
-			error = -EACCES;
-		else
-			p->nice = niceval;
+		p->nice = niceval;
 	}
 	read_unlock(&tasklist_lock);
 
@@ -289,11 +297,17 @@ asmlinkage long sys_getpriority(int whic
 asmlinkage long sys_reboot(int magic1, int magic2, unsigned int cmd, void * arg)
 {
 	char buffer[256];
+	int retval;
 
 	/* We only trust the superuser with rebooting the system. */
 	if (!capable(CAP_SYS_BOOT))
 		return -EPERM;
 
+	retval = security_reboot(cmd);
+	if (retval) {
+		return retval;
+	}
+
 	/* For safety, we require "magic" arguments. */
 	if (magic1 != LINUX_REBOOT_MAGIC1 ||
 	    (magic2 != LINUX_REBOOT_MAGIC2 && magic2 != LINUX_REBOOT_MAGIC2A &&
@@ -398,6 +412,11 @@ asmlinkage long sys_setregid(gid_t rgid,
 	int old_egid = current->egid;
 	int new_rgid = old_rgid;
 	int new_egid = old_egid;
+	int retval = 0;
+
+	retval = security_task_setgid(rgid, egid, (gid_t)-1, LSM_SETID_RE);
+	if (retval)
+		return retval;
 
 	if (rgid != (gid_t) -1) {
 		if ((old_rgid == rgid) ||
@@ -439,6 +458,11 @@ asmlinkage long sys_setregid(gid_t rgid,
 asmlinkage long sys_setgid(gid_t gid)
 {
 	int old_egid = current->egid;
+	int retval;
+
+	retval = security_task_setgid(gid, (gid_t)-1, (gid_t)-1, LSM_SETID_ID);
+	if (retval)
+		return retval;
 
 	if (capable(CAP_SETGID))
 	{
@@ -463,52 +487,6 @@ asmlinkage long sys_setgid(gid_t gid)
 	return 0;
 }
   
-/* 
- * cap_emulate_setxuid() fixes the effective / permitted capabilities of
- * a process after a call to setuid, setreuid, or setresuid.
- *
- *  1) When set*uiding _from_ one of {r,e,s}uid == 0 _to_ all of
- *  {r,e,s}uid != 0, the permitted and effective capabilities are
- *  cleared.
- *
- *  2) When set*uiding _from_ euid == 0 _to_ euid != 0, the effective
- *  capabilities of the process are cleared.
- *
- *  3) When set*uiding _from_ euid != 0 _to_ euid == 0, the effective
- *  capabilities are set to the permitted capabilities.
- *
- *  fsuid is handled elsewhere. fsuid == 0 and {r,e,s}uid!= 0 should 
- *  never happen.
- *
- *  -astor 
- *
- * cevans - New behaviour, Oct '99
- * A process may, via prctl(), elect to keep its capabilities when it
- * calls setuid() and switches away from uid==0. Both permitted and
- * effective sets will be retained.
- * Without this change, it was impossible for a daemon to drop only some
- * of its privilege. The call to setuid(!=0) would drop all privileges!
- * Keeping uid 0 is not an option because uid 0 owns too many vital
- * files..
- * Thanks to Olaf Kirch and Peter Benie for spotting this.
- */
-static inline void cap_emulate_setxuid(int old_ruid, int old_euid, 
-				       int old_suid)
-{
-	if ((old_ruid == 0 || old_euid == 0 || old_suid == 0) &&
-	    (current->uid != 0 && current->euid != 0 && current->suid != 0) &&
-	    !current->keep_capabilities) {
-		cap_clear(current->cap_permitted);
-		cap_clear(current->cap_effective);
-	}
-	if (old_euid == 0 && current->euid != 0) {
-		cap_clear(current->cap_effective);
-	}
-	if (old_euid != 0 && current->euid == 0) {
-		current->cap_effective = current->cap_permitted;
-	}
-}
-
 static int set_user(uid_t new_ruid, int dumpclear)
 {
 	struct user_struct *new_user;
@@ -545,6 +523,11 @@ static int set_user(uid_t new_ruid, int 
 asmlinkage long sys_setreuid(uid_t ruid, uid_t euid)
 {
 	int old_ruid, old_euid, old_suid, new_ruid, new_euid;
+	int retval;
+
+	retval = security_task_setuid(ruid, euid, (uid_t)-1, LSM_SETID_RE);
+	if (retval)
+		return retval;
 
 	new_ruid = old_ruid = current->uid;
 	new_euid = old_euid = current->euid;
@@ -581,11 +564,7 @@ asmlinkage long sys_setreuid(uid_t ruid,
 		current->suid = current->euid;
 	current->fsuid = current->euid;
 
-	if (!issecure(SECURE_NO_SETUID_FIXUP)) {
-		cap_emulate_setxuid(old_ruid, old_euid, old_suid);
-	}
-
-	return 0;
+	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RE);
 }
 
 
@@ -605,6 +584,11 @@ asmlinkage long sys_setuid(uid_t uid)
 {
 	int old_euid = current->euid;
 	int old_ruid, old_suid, new_ruid, new_suid;
+	int retval;
+
+	retval = security_task_setuid(uid, (uid_t)-1, (uid_t)-1, LSM_SETID_ID);
+	if (retval)
+		return retval;
 
 	old_ruid = new_ruid = current->uid;
 	old_suid = current->suid;
@@ -625,11 +609,7 @@ asmlinkage long sys_setuid(uid_t uid)
 	current->fsuid = current->euid = uid;
 	current->suid = new_suid;
 
-	if (!issecure(SECURE_NO_SETUID_FIXUP)) {
-		cap_emulate_setxuid(old_ruid, old_euid, old_suid);
-	}
-
-	return 0;
+	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_ID);
 }
 
 
@@ -642,6 +622,11 @@ asmlinkage long sys_setresuid(uid_t ruid
 	int old_ruid = current->uid;
 	int old_euid = current->euid;
 	int old_suid = current->suid;
+	int retval;
+
+	retval = security_task_setuid(ruid, euid, suid, LSM_SETID_RES);
+	if (retval)
+		return retval;
 
 	if (!capable(CAP_SETUID)) {
 		if ((ruid != (uid_t) -1) && (ruid != current->uid) &&
@@ -670,11 +655,7 @@ asmlinkage long sys_setresuid(uid_t ruid
 	if (suid != (uid_t) -1)
 		current->suid = suid;
 
-	if (!issecure(SECURE_NO_SETUID_FIXUP)) {
-		cap_emulate_setxuid(old_ruid, old_euid, old_suid);
-	}
-
-	return 0;
+	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RES);
 }
 
 asmlinkage long sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid)
@@ -693,6 +674,12 @@ asmlinkage long sys_getresuid(uid_t *rui
  */
 asmlinkage long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)
 {
+	int retval;
+
+	retval = security_task_setgid(rgid, egid, sgid, LSM_SETID_RES);
+	if (retval)
+		return retval;
+
 	if (!capable(CAP_SETGID)) {
 		if ((rgid != (gid_t) -1) && (rgid != current->gid) &&
 		    (rgid != current->egid) && (rgid != current->sgid))
@@ -741,6 +728,11 @@ asmlinkage long sys_getresgid(gid_t *rgi
 asmlinkage long sys_setfsuid(uid_t uid)
 {
 	int old_fsuid;
+	int retval;
+
+	retval = security_task_setuid(uid, (uid_t)-1, (uid_t)-1, LSM_SETID_FS);
+	if (retval)
+		return retval;
 
 	old_fsuid = current->fsuid;
 	if (uid == current->uid || uid == current->euid ||
@@ -755,24 +747,9 @@ asmlinkage long sys_setfsuid(uid_t uid)
 		current->fsuid = uid;
 	}
 
-	/* We emulate fsuid by essentially doing a scaled-down version
-	 * of what we did in setresuid and friends. However, we only
-	 * operate on the fs-specific bits of the process' effective
-	 * capabilities 
-	 *
-	 * FIXME - is fsuser used for all CAP_FS_MASK capabilities?
-	 *          if not, we might be a bit too harsh here.
-	 */
-	
-	if (!issecure(SECURE_NO_SETUID_FIXUP)) {
-		if (old_fsuid == 0 && current->fsuid != 0) {
-			cap_t(current->cap_effective) &= ~CAP_FS_MASK;
-		}
-		if (old_fsuid != 0 && current->fsuid == 0) {
-			cap_t(current->cap_effective) |=
-				(cap_t(current->cap_permitted) & CAP_FS_MASK);
-		}
-	}
+	retval = security_task_post_setuid(old_fsuid, (uid_t)-1, (uid_t)-1, LSM_SETID_FS);
+	if (retval)
+		return retval;
 
 	return old_fsuid;
 }
@@ -783,6 +760,11 @@ asmlinkage long sys_setfsuid(uid_t uid)
 asmlinkage long sys_setfsgid(gid_t gid)
 {
 	int old_fsgid;
+	int retval;
+
+	retval = security_task_setgid(gid, (gid_t)-1, (gid_t)-1, LSM_SETID_FS);
+	if (retval)
+		return retval;
 
 	old_fsgid = current->fsgid;
 	if (gid == current->gid || gid == current->egid ||
@@ -871,6 +853,10 @@ asmlinkage long sys_setpgid(pid_t pid, p
 	}
 
 ok_pgid:
+	err = security_task_setpgid(p, pgid);
+	if (err)
+		goto out;
+
 	p->pgrp = pgid;
 	err = 0;
 out:
@@ -891,8 +877,11 @@ asmlinkage long sys_getpgid(pid_t pid)
 		p = find_task_by_pid(pid);
 
 		retval = -ESRCH;
-		if (p)
-			retval = p->pgrp;
+		if (p) {
+			retval = security_task_getpgid(p);
+			if (!retval)
+				retval = p->pgrp;
+		}
 		read_unlock(&tasklist_lock);
 		return retval;
 	}
@@ -916,8 +905,11 @@ asmlinkage long sys_getsid(pid_t pid)
 		p = find_task_by_pid(pid);
 
 		retval = -ESRCH;
-		if(p)
-			retval = p->session;
+		if(p) {
+			retval = security_task_getsid(p);
+			if (!retval)
+				retval = p->session;
+		}
 		read_unlock(&tasklist_lock);
 		return retval;
 	}
@@ -975,12 +967,19 @@ asmlinkage long sys_getgroups(int gidset
  
 asmlinkage long sys_setgroups(int gidsetsize, gid_t *grouplist)
 {
+	gid_t groups[NGROUPS];
+	int retval;
+
 	if (!capable(CAP_SETGID))
 		return -EPERM;
 	if ((unsigned) gidsetsize > NGROUPS)
 		return -EINVAL;
-	if(copy_from_user(current->groups, grouplist, gidsetsize * sizeof(gid_t)))
+	if(copy_from_user(groups, grouplist, gidsetsize * sizeof(gid_t)))
 		return -EFAULT;
+	retval = security_task_setgroups(gidsetsize, groups);
+	if (retval)
+		return retval;
+	memcpy(current->groups, groups, gidsetsize * sizeof(gid_t));
 	current->ngroups = gidsetsize;
 	return 0;
 }
@@ -1035,22 +1034,25 @@ asmlinkage long sys_newuname(struct new_
 
 asmlinkage long sys_sethostname(char *name, int len)
 {
+	char nodename[__NEW_UTS_LEN+1];
 	int errno;
-	char tmp[__NEW_UTS_LEN];
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
+	if (copy_from_user(nodename, name, len)) 
+		return -EFAULT;
+	nodename[len] = 0;
+
+	errno = security_sethostname(nodename);
+	if (errno)
+		return errno;
+
 	down_write(&uts_sem);
-	errno = -EFAULT;
-	if (!copy_from_user(tmp, name, len)) {
-		memcpy(system_utsname.nodename, tmp, len);
-		system_utsname.nodename[len] = 0;
-		errno = 0;
-	}
+	memcpy(system_utsname.nodename, nodename, len+1);
 	up_write(&uts_sem);
-	return errno;
+	return 0;
 }
 
 asmlinkage long sys_gethostname(char *name, int len)
@@ -1076,21 +1078,23 @@ asmlinkage long sys_gethostname(char *na
  */
 asmlinkage long sys_setdomainname(char *name, int len)
 {
+	char domainname[__NEW_UTS_LEN+1];
 	int errno;
-	char tmp[__NEW_UTS_LEN];
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
+	if (copy_from_user(domainname, name, len)) 
+		return -EFAULT;
+	domainname[len] = 0;
+
+	errno = security_setdomainname(domainname);
+	if (errno)
+		return errno;
 
 	down_write(&uts_sem);
-	errno = -EFAULT;
-	if (!copy_from_user(tmp, name, len)) {
-		memcpy(system_utsname.domainname, tmp, len);
-		system_utsname.domainname[len] = 0;
-		errno = 0;
-	}
+	memcpy(system_utsname.domainname, domainname, len+1);
 	up_write(&uts_sem);
 	return errno;
 }
@@ -1129,6 +1133,7 @@ asmlinkage long sys_old_getrlimit(unsign
 asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit *rlim)
 {
 	struct rlimit new_rlim, *old_rlim;
+	int retval;
 
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
@@ -1145,6 +1150,11 @@ asmlinkage long sys_setrlimit(unsigned i
 		if (new_rlim.rlim_cur > NR_OPEN || new_rlim.rlim_max > NR_OPEN)
 			return -EPERM;
 	}
+
+	retval = security_task_setrlimit(resource, &new_rlim);
+	if (retval)
+		return retval;
+
 	*old_rlim = new_rlim;
 	return 0;
 }
@@ -1222,6 +1232,10 @@ asmlinkage long sys_prctl(int option, un
 	int error = 0;
 	int sig;
 
+	error = security_task_prctl(option, arg2, arg3, arg4, arg5);
+	if (error)
+		return error;
+
 	switch (option) {
 		case PR_SET_PDEATHSIG:
 			sig = arg2;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/sysctl.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/sysctl.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/sysctl.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/sysctl.c	2004-03-02 23:41:24.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/sysrq.h>
 #include <linux/highuid.h>
 #include <linux/swap.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -425,6 +426,10 @@ static int test_perm(int mode, int op)
 
 static inline int ctl_perm(ctl_table *table, int op)
 {
+	int error;
+	error = security_sysctl(table, op);
+	if (error)
+		return error;
 	return test_perm(table->mode, op);
 }
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/time.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/time.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/time.c	2002-11-29 01:53:15.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/time.c	2004-03-02 23:41:24.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/mm.h>
 #include <linux/timex.h>
 #include <linux/smp_lock.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -148,9 +149,15 @@ inline static void warp_clock(void)
 int do_sys_settimeofday(struct timeval *tv, struct timezone *tz)
 {
 	static int firsttime = 1;
+	int error = 0;
 
 	if (!capable(CAP_SYS_TIME))
 		return -EPERM;
+
+        /* Call the Linux Security Module to perform its checks */
+        error = security_settime(tv, tz);
+        if (error)
+                return error;
 		
 	if (tz) {
 		/* SMP safe, global irq locking makes it work. */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/kernel/uid16.c 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/uid16.c
--- 2425sls2.ea.acl.nfsacl.sec/kernel/uid16.c	2000-01-11 04:40:26.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/kernel/uid16.c	2004-03-02 23:41:24.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/prctl.h>
 #include <linux/init.h>
 #include <linux/highuid.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 
@@ -128,6 +129,7 @@ asmlinkage long sys_getgroups16(int gids
 asmlinkage long sys_setgroups16(int gidsetsize, old_gid_t *grouplist)
 {
 	old_gid_t groups[NGROUPS];
+	gid_t new_groups[NGROUPS];
 	int i;
 
 	if (!capable(CAP_SETGID))
@@ -137,7 +139,11 @@ asmlinkage long sys_setgroups16(int gids
 	if (copy_from_user(groups, grouplist, gidsetsize * sizeof(old_gid_t)))
 		return -EFAULT;
 	for (i = 0 ; i < gidsetsize ; i++)
-		current->groups[i] = (gid_t)groups[i];
+		new_groups[i] = (gid_t)groups[i];
+	i = security_task_setgroups(gidsetsize, new_groups);
+	if (i)
+		return i;
+	memcpy(current->groups, new_groups, gidsetsize * sizeof(gid_t));
 	current->ngroups = gidsetsize;
 	return 0;
 }
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/Makefile 2425sls2.ea.acl.nfsacl.sec.selinux/Makefile
--- 2425sls2.ea.acl.nfsacl.sec/Makefile	2004-03-02 19:50:22.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/Makefile	2004-03-02 23:41:23.000000000 +0200
@@ -124,11 +124,11 @@ export SVGA_MODE = -DSVGA_MODE=NORMAL_VG
 
 #export RAMDISK = -DRAMDISK=512
 
-CORE_FILES	=kernel/kernel.o mm/mm.o fs/fs.o ipc/ipc.o
+CORE_FILES	=kernel/kernel.o mm/mm.o fs/fs.o ipc/ipc.o security/vmlinux-obj.o
 NETWORKS	=net/network.o
 
 LIBS		=$(TOPDIR)/lib/lib.a
-SUBDIRS		=kernel drivers mm fs net ipc lib crypto
+SUBDIRS		=kernel drivers mm fs net ipc lib crypto security
 
 DRIVERS-n :=
 DRIVERS-y :=
@@ -259,6 +259,11 @@ MRPROPER_DIRS = \
 
 include arch/$(ARCH)/Makefile
 
+# if we have a StackGuard compiler, then we need to turn off the canary death handler stuff
+CFLAGS	+= $(shell if $(CC) -fno-canary-all-functions -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-fno-canary-all-functions"; fi)
+CFLAGS	+= $(shell if $(CC) -mno-terminator-canary -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-mno-terminator-canary"; fi)
+CFLAGS	+= $(shell if $(CC) -fno-stackguard-canary -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-fno-stackguard-canary"; fi)
+
 # Extra cflags for kbuild 2.4.  The default is to forbid includes by kernel code
 # from user space headers.  Some UML code requires user space headers, in the
 # UML Makefiles add 'kbuild_2_4_nostdinc :=' before include Rules.make.  No
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/mm/filemap.c 2425sls2.ea.acl.nfsacl.sec.selinux/mm/filemap.c
--- 2425sls2.ea.acl.nfsacl.sec/mm/filemap.c	2004-02-18 15:36:32.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/mm/filemap.c	2004-03-02 23:41:24.000000000 +0200
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/mm.h>
 #include <linux/iobuf.h>
+#include <linux/security.h>
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -1873,6 +1874,10 @@ static ssize_t common_sendfile(int out_f
 	if (retval)
 		goto fput_in;
 
+	retval = security_file_permission (in_file, MAY_READ);
+	if (retval)
+		goto fput_in;
+
 	/*
 	 * Get output file, and verify that it is ok..
 	 */
@@ -1890,6 +1895,10 @@ static ssize_t common_sendfile(int out_f
 	if (retval)
 		goto fput_out;
 
+	retval = security_file_permission (out_file, MAY_WRITE);
+	if (retval)
+		goto fput_out;
+
 	retval = 0;
 	if (count) {
 		read_descriptor_t desc;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/mm/memory.c 2425sls2.ea.acl.nfsacl.sec.selinux/mm/memory.c
--- 2425sls2.ea.acl.nfsacl.sec/mm/memory.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/mm/memory.c	2004-03-02 23:41:24.000000000 +0200
@@ -45,6 +45,7 @@
 #include <linux/highmem.h>
 #include <linux/pagemap.h>
 #include <linux/module.h>
+#include <linux/security.h>
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/mm/mmap.c 2425sls2.ea.acl.nfsacl.sec.selinux/mm/mmap.c
--- 2425sls2.ea.acl.nfsacl.sec/mm/mmap.c	2004-02-18 15:36:32.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/mm/mmap.c	2004-03-02 23:48:36.000000000 +0200
@@ -14,6 +14,7 @@
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/personality.h>
+#include <linux/security.h>
 #include <linux/mount.h>
 
 #include <asm/uaccess.h>
@@ -486,6 +487,10 @@ unsigned long do_mmap_pgoff(struct file 
 		}
 	}
 
+	error = security_file_mmap(file, prot, flags);
+	if (error)
+		return error;
+		
 	/* Clear old maps */
 munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/mm/mprotect.c 2425sls2.ea.acl.nfsacl.sec.selinux/mm/mprotect.c
--- 2425sls2.ea.acl.nfsacl.sec/mm/mprotect.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/mm/mprotect.c	2004-03-02 23:41:24.000000000 +0200
@@ -7,6 +7,7 @@
 #include <linux/smp_lock.h>
 #include <linux/shm.h>
 #include <linux/mman.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -300,6 +301,10 @@ asmlinkage long sys_mprotect(unsigned lo
 			goto out;
 		}
 
+		error = security_file_mprotect(vma, prot);
+		if (error)
+			goto out;
+
 		if (vma->vm_end > end) {
 			error = mprotect_fixup(vma, &prev, nstart, end, newflags);
 			goto out;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/mm/oom_kill.c 2425sls2.ea.acl.nfsacl.sec.selinux/mm/oom_kill.c
--- 2425sls2.ea.acl.nfsacl.sec/mm/oom_kill.c	2004-02-18 15:36:32.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/mm/oom_kill.c	2004-03-02 23:41:24.000000000 +0200
@@ -20,6 +20,7 @@
 #include <linux/swap.h>
 #include <linux/swapctl.h>
 #include <linux/timex.h>
+#include <linux/security.h>
 
 /* #define DEBUG */
 
@@ -93,7 +94,7 @@ static int badness(struct task_struct *p
 	 * Superuser processes are usually more important, so we make it
 	 * less likely that we kill those.
 	 */
-	if (cap_t(p->cap_effective) & CAP_TO_MASK(CAP_SYS_ADMIN) ||
+	if (!security_capable(p,CAP_SYS_ADMIN) ||
 				p->uid == 0 || p->euid == 0)
 		points /= 4;
 
@@ -103,7 +104,7 @@ static int badness(struct task_struct *p
 	 * tend to only have this flag set on applications they think
 	 * of as important.
 	 */
-	if (cap_t(p->cap_effective) & CAP_TO_MASK(CAP_SYS_RAWIO))
+	if (!security_capable(p,CAP_SYS_RAWIO))
 		points /= 4;
 #ifdef DEBUG
 	printk(KERN_DEBUG "OOMkill: task %d (%s) got %d points\n",
@@ -154,7 +155,7 @@ void oom_kill_task(struct task_struct *p
 	p->flags |= PF_MEMALLOC | PF_MEMDIE;
 
 	/* This process has hardware access, be more careful. */
-	if (cap_t(p->cap_effective) & CAP_TO_MASK(CAP_SYS_RAWIO)) {
+	if (!security_capable(p,CAP_SYS_RAWIO)) {
 		force_sig(SIGTERM, p);
 	} else {
 		force_sig(SIGKILL, p);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/mm/swapfile.c 2425sls2.ea.acl.nfsacl.sec.selinux/mm/swapfile.c
--- 2425sls2.ea.acl.nfsacl.sec/mm/swapfile.c	2003-08-25 14:44:44.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/mm/swapfile.c	2004-03-02 23:41:24.000000000 +0200
@@ -14,6 +14,7 @@
 #include <linux/vmalloc.h>
 #include <linux/pagemap.h>
 #include <linux/shm.h>
+#include <linux/security.h>
 
 #include <asm/pgtable.h>
 
@@ -743,6 +744,13 @@ asmlinkage long sys_swapoff(const char *
 		}
 		prev = type;
 	}
+
+	err = security_swapoff(p);
+	if (err) {
+		swap_list_unlock();
+		goto out_dput;
+	}
+
 	err = -EINVAL;
 	if (type < 0) {
 		swap_list_unlock();
@@ -921,6 +929,11 @@ asmlinkage long sys_swapon(const char * 
 	p->swap_file = nd.dentry;
 	p->swap_vfsmnt = nd.mnt;
 	swap_inode = nd.dentry->d_inode;
+
+	error = security_swapon(p);
+	if (error)
+		 goto bad_swap_2;
+
 	error = -EINVAL;
 
 	if (S_ISBLK(swap_inode->i_mode)) {
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/core/datagram.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/datagram.c
--- 2425sls2.ea.acl.nfsacl.sec/net/core/datagram.c	2001-12-21 19:42:05.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/datagram.c	2004-03-02 23:41:24.000000000 +0200
@@ -37,6 +37,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/poll.h>
 #include <linux/highmem.h>
+#include <linux/security.h>
 
 #include <net/protocol.h>
 #include <linux/skbuff.h>
@@ -164,8 +165,10 @@ struct sk_buff *skb_recv_datagram(struct
 		} else
 			skb = skb_dequeue(&sk->receive_queue);
 
-		if (skb)
+		if (skb) {
+			security_skb_recv_datagram(skb, sk, flags);
 			return skb;
+		}
 
 		/* User doesn't want to wait */
 		error = -EAGAIN;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/core/dev.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/dev.c
--- 2425sls2.ea.acl.nfsacl.sec/net/core/dev.c	2004-02-18 15:36:32.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/dev.c	2004-03-02 23:41:24.000000000 +0200
@@ -100,6 +100,7 @@
 #include <linux/init.h>
 #include <linux/kmod.h>
 #include <linux/module.h>
+#include <linux/security.h>
 #if defined(CONFIG_NET_RADIO) || defined(CONFIG_NET_PCMCIA_RADIO)
 #include <linux/wireless.h>		/* Note : will define WIRELESS_EXT */
 #include <net/iw_handler.h>
@@ -2652,6 +2653,8 @@ int unregister_netdevice(struct net_devi
 	free_divert_blk(dev);
 #endif
 
+	security_netdev_unregister(dev);
+
 	if (dev->features & NETIF_F_DYNALLOC) {
 #ifdef NET_REFCNT_DEBUG
 		if (atomic_read(&dev->refcnt) != 1)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/core/rtnetlink.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/rtnetlink.c
--- 2425sls2.ea.acl.nfsacl.sec/net/core/rtnetlink.c	2003-08-25 14:44:44.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/rtnetlink.c	2004-03-02 23:41:24.000000000 +0200
@@ -34,6 +34,7 @@
 #include <linux/capability.h>
 #include <linux/skbuff.h>
 #include <linux/init.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -316,7 +317,7 @@ rtnetlink_rcv_msg(struct sk_buff *skb, s
 	sz_idx = type>>2;
 	kind = type&3;
 
-	if (kind != 2 && !cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN)) {
+	if (kind != 2 && security_netlink_recv(skb)) {
 		*errp = -EPERM;
 		return -1;
 	}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/core/scm.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/scm.c
--- 2425sls2.ea.acl.nfsacl.sec/net/core/scm.c	2001-12-21 19:42:05.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/scm.c	2004-03-02 23:41:24.000000000 +0200
@@ -22,6 +22,7 @@
 #include <linux/net.h>
 #include <linux/interrupt.h>
 #include <linux/netdevice.h>
+#include <linux/security.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -216,6 +217,9 @@ void scm_detach_fds(struct msghdr *msg, 
 	for (i=0, cmfptr=(int*)CMSG_DATA(cm); i<fdmax; i++, cmfptr++)
 	{
 		int new_fd;
+		err = security_file_receive(fp[i]);
+		if (err)
+			break;
 		err = get_unused_fd();
 		if (err < 0)
 			break;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/core/skbuff.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/skbuff.c
--- 2425sls2.ea.acl.nfsacl.sec/net/core/skbuff.c	2003-08-25 14:44:44.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/skbuff.c	2004-03-02 23:41:24.000000000 +0200
@@ -52,6 +52,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/init.h>
 #include <linux/highmem.h>
+#include <linux/security.h>
 
 #include <net/protocol.h>
 #include <net/dst.h>
@@ -190,6 +191,11 @@ struct sk_buff *alloc_skb(unsigned int s
 	if (data == NULL)
 		goto nodata;
 
+	if (security_skb_alloc(skb, gfp_mask)) {
+ 		kfree(data);
+		goto nodata;
+	}
+
 	/* XXX: does not include slab overhead */ 
 	skb->truesize = size + sizeof(struct sk_buff);
 
@@ -250,6 +256,9 @@ static inline void skb_headerinit(void *
 #ifdef CONFIG_NET_SCHED
 	skb->tc_index = 0;
 #endif
+#ifdef CONFIG_SECURITY_NETWORK
+	skb->lsm_security = NULL;
+#endif
 }
 
 static void skb_drop_fraglist(struct sk_buff *skb)
@@ -327,6 +336,7 @@ void __kfree_skb(struct sk_buff *skb)
 #ifdef CONFIG_NETFILTER
 	nf_conntrack_put(skb->nfct);
 #endif
+	security_skb_free(skb);
 	skb_headerinit(skb, NULL, 0);  /* clean state */
 	kfree_skbmem(skb);
 }
@@ -355,6 +365,11 @@ struct sk_buff *skb_clone(struct sk_buff
 		if (!n)
 			return NULL;
 	}
+	
+	if (security_skb_clone(n, skb)) {
+		skb_head_to_pool(n);
+		return NULL;
+	}
 
 #define C(x) n->x = skb->x
 
@@ -444,6 +459,7 @@ static void copy_skb_header(struct sk_bu
 #ifdef CONFIG_NET_SCHED
 	new->tc_index = old->tc_index;
 #endif
+	security_skb_copy(new, old);
 }
 
 /**
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/core/sock.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/sock.c
--- 2425sls2.ea.acl.nfsacl.sec/net/core/sock.c	2003-06-13 17:51:39.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/core/sock.c	2004-03-02 23:41:24.000000000 +0200
@@ -110,6 +110,7 @@
 #include <linux/poll.h>
 #include <linux/tcp.h>
 #include <linux/init.h>
+#include <linux/security.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -584,10 +585,16 @@ struct sock *sk_alloc(int family, int pr
 {
 	struct sock *sk = kmem_cache_alloc(sk_cachep, priority);
 
-	if(sk && zero_it) {
-		memset(sk, 0, sizeof(struct sock));
-		sk->family = family;
-		sock_lock_init(sk);
+	if (sk) {
+		if (zero_it) {
+			memset(sk, 0, sizeof(struct sock));
+			sk->family = family;
+			sock_lock_init(sk);
+		}
+		if (security_sock_alloc(sk, priority)) {
+			kmem_cache_free(sk_cachep, sk);
+			return NULL;
+		}
 	}
 
 	return sk;
@@ -613,6 +620,8 @@ void sk_free(struct sock *sk)
 	if (atomic_read(&sk->omem_alloc))
 		printk(KERN_DEBUG "sk_free: optmem leakage (%d bytes) detected.\n", atomic_read(&sk->omem_alloc));
 
+	security_sock_free(sk);
+
 	kmem_cache_free(sk_cachep, sk);
 }
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/devinet.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/devinet.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/devinet.c	2004-02-18 15:36:32.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/devinet.c	2004-03-02 23:41:24.000000000 +0200
@@ -55,6 +55,7 @@
 #include <linux/sysctl.h>
 #endif
 #include <linux/kmod.h>
+#include <linux/security.h>
 
 #include <net/ip.h>
 #include <net/route.h>
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ip_fragment.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ip_fragment.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ip_fragment.c	2003-06-13 17:51:39.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ip_fragment.c	2004-03-02 23:41:24.000000000 +0200
@@ -41,6 +41,7 @@
 #include <linux/udp.h>
 #include <linux/inet.h>
 #include <linux/netfilter_ipv4.h>
+#include <linux/security.h>
 
 /* NOTE. Logic of IP defragmentation is parallel to corresponding IPv6
  * code now. If you change something here, _PLEASE_ update ipv6/reassembly.c
@@ -403,7 +404,11 @@ static void ip_frag_queue(struct ipq *qp
 {
 	struct sk_buff *prev, *next;
 	int flags, offset;
-	int ihl, end;
+	int ihl, end, ret;
+
+	ret = security_ip_defragment(skb);
+	if (ret)
+		goto err;
 
 	if (qp->last_in & COMPLETE)
 		goto err;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ip_gre.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ip_gre.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ip_gre.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ip_gre.c	2004-03-02 23:41:24.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/inetdevice.h>
 #include <linux/igmp.h>
 #include <linux/netfilter_ipv4.h>
+#include <linux/security.h>
 
 #include <net/sock.h>
 #include <net/ip.h>
@@ -651,6 +652,7 @@ int ipgre_rcv(struct sk_buff *skb)
 		skb->nf_debug = 0;
 #endif
 #endif
+		security_ip_decapsulate(skb);
 		ipgre_ecn_decapsulate(iph, skb);
 		netif_rx(skb);
 		read_unlock(&ipgre_lock);
@@ -883,6 +885,7 @@ static int ipgre_tunnel_xmit(struct sk_b
 	skb->nf_debug = 0;
 #endif
 #endif
+	security_ip_encapsulate(skb);
 
 	IPTUNNEL_XMIT();
 	tunnel->recursion--;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ipip.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ipip.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ipip.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ipip.c	2004-03-02 23:41:24.000000000 +0200
@@ -108,6 +108,7 @@
 #include <linux/mroute.h>
 #include <linux/init.h>
 #include <linux/netfilter_ipv4.h>
+#include <linux/security.h>
 
 #include <net/sock.h>
 #include <net/ip.h>
@@ -502,6 +503,7 @@ int ipip_rcv(struct sk_buff *skb)
 		skb->nf_debug = 0;
 #endif
 #endif
+		security_ip_decapsulate(skb);
 		ipip_ecn_decapsulate(iph, skb);
 		netif_rx(skb);
 		read_unlock(&ipip_lock);
@@ -654,6 +656,8 @@ static int ipip_tunnel_xmit(struct sk_bu
 #endif
 #endif
 
+	security_ip_encapsulate(skb);
+
 	IPTUNNEL_XMIT();
 	tunnel->recursion--;
 	return 0;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ipmr.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ipmr.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ipmr.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ipmr.c	2004-03-02 23:41:24.000000000 +0200
@@ -60,6 +60,7 @@
 #include <linux/netfilter_ipv4.h>
 #include <net/ipip.h>
 #include <net/checksum.h>
+#include <linux/security.h>
 
 #if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
 #define CONFIG_IP_PIMSM	1
@@ -1101,6 +1102,7 @@ static void ip_encap(struct sk_buff *skb
 	nf_conntrack_put(skb->nfct);
 	skb->nfct = NULL;
 #endif
+	security_ip_encapsulate(skb);
 }
 
 static inline int ipmr_forward_finish(struct sk_buff *skb)
@@ -1450,6 +1452,7 @@ int pim_rcv_v1(struct sk_buff * skb)
 	nf_conntrack_put(skb->nfct);
 	skb->nfct = NULL;
 #endif
+	security_ip_decapsulate(skb);
 	netif_rx(skb);
 	dev_put(reg_dev);
 	return 0;
@@ -1517,6 +1520,7 @@ int pim_rcv(struct sk_buff * skb)
 	nf_conntrack_put(skb->nfct);
 	skb->nfct = NULL;
 #endif
+	security_ip_decapsulate(skb);
 	netif_rx(skb);
 	dev_put(reg_dev);
 	return 0;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ip_options.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ip_options.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ip_options.c	2002-11-29 01:53:15.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ip_options.c	2004-03-02 23:41:24.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/icmp.h>
 #include <linux/netdevice.h>
 #include <linux/rtnetlink.h>
+#include <linux/security.h>
 #include <net/sock.h>
 #include <net/ip.h>
 #include <net/icmp.h>
@@ -433,7 +434,11 @@ int ip_options_compile(struct ip_options
 				opt->router_alert = optptr - iph;
 			break;
 		      case IPOPT_SEC:
+		      case IPOPT_CIPSO:
 		      case IPOPT_SID:
+		      	if (security_ip_decode_options(skb, optptr, &pp_ptr))
+				goto error;
+			break;
 		      default:
 			if (!skb && !capable(CAP_NET_RAW)) {
 				pp_ptr = optptr;
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ip_output.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ip_output.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/ip_output.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/ip_output.c	2004-03-02 23:41:24.000000000 +0200
@@ -77,6 +77,7 @@
 #include <linux/netfilter_ipv4.h>
 #include <linux/mroute.h>
 #include <linux/netlink.h>
+#include <linux/security.h>
 
 /*
  *      Shall we try to damage output packets if routing dev changes?
@@ -887,6 +888,7 @@ int ip_fragment(struct sk_buff *skb, int
 		skb2->nf_debug = skb->nf_debug;
 #endif
 #endif
+		security_ip_fragment(skb2, skb);
 
 		/*
 		 *	Put this fragment into the sending queue.
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/netfilter/ip_queue.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/netfilter/ip_queue.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/netfilter/ip_queue.c	2004-02-18 15:36:32.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/netfilter/ip_queue.c	2004-03-02 23:41:24.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/brlock.h>
 #include <linux/sysctl.h>
 #include <linux/proc_fs.h>
+#include <linux/security.h>
 #include <net/sock.h>
 #include <net/route.h>
 
@@ -500,7 +501,7 @@ ipq_rcv_skb(struct sk_buff *skb)
 	if (type <= IPQM_BASE)
 		return;
 		
-	if(!cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN))
+	if (security_netlink_recv(skb))
 		RCV_SKB_FAIL(-EPERM);
 	
 	write_lock_bh(&queue_lock);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/syncookies.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/syncookies.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/syncookies.c	2002-08-03 03:39:46.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/syncookies.c	2004-03-02 23:41:24.000000000 +0200
@@ -17,6 +17,7 @@
 #include <linux/tcp.h>
 #include <linux/slab.h>
 #include <linux/random.h>
+#include <linux/security.h>
 #include <net/tcp.h>
 
 extern int sysctl_tcp_syncookies;
@@ -179,6 +180,8 @@ struct sock *cookie_v4_check(struct sock
 		goto out; 
 	}
 
+	security_tcp_connection_request(sk, skb, req);
+
 	/* Try to redo what tcp_v4_send_synack did. */
 	req->window_clamp = rt->u.dst.window;  
 	tcp_select_initial_window(tcp_full_space(sk), req->mss,
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/tcp_ipv4.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/tcp_ipv4.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/tcp_ipv4.c	2003-11-28 20:26:21.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/tcp_ipv4.c	2004-03-02 23:41:24.000000000 +0200
@@ -58,6 +58,7 @@
 #include <linux/cache.h>
 #include <linux/jhash.h>
 #include <linux/init.h>
+#include <linux/security.h>
 
 #include <net/icmp.h>
 #include <net/tcp.h>
@@ -1310,6 +1311,8 @@ static int tcp_v4_send_synack(struct soc
 	if (skb) {
 		struct tcphdr *th = skb->h.th;
 
+		security_tcp_synack(sk, skb, req);
+
 		th->check = tcp_v4_check(th, skb->len,
 					 req->af.v4_req.loc_addr, req->af.v4_req.rmt_addr,
 					 csum_partial((char *)th, skb->len, skb->csum));
@@ -1518,6 +1521,8 @@ int tcp_v4_conn_request(struct sock *sk,
 	}
 	req->snt_isn = isn;
 
+	security_tcp_connection_request(sk, skb, req);
+
 	if (tcp_v4_send_synack(sk, req, dst))
 		goto drop_and_free;
 
@@ -1763,6 +1768,9 @@ process:
 	if(!ipsec_sk_policy(sk,skb))
 		goto discard_and_relse;
 
+	if (security_sock_rcv_skb(sk, skb))
+		goto discard_and_relse;
+
 	if (sk->state == TCP_TIME_WAIT)
 		goto do_time_wait;
 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/ipv4/tcp_minisocks.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/tcp_minisocks.c
--- 2425sls2.ea.acl.nfsacl.sec/net/ipv4/tcp_minisocks.c	2003-08-25 14:44:44.000000000 +0300
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/ipv4/tcp_minisocks.c	2004-03-02 23:41:24.000000000 +0200
@@ -23,6 +23,7 @@
 #include <linux/config.h>
 #include <linux/mm.h>
 #include <linux/sysctl.h>
+#include <linux/security.h>
 #include <net/tcp.h>
 #include <net/inet_common.h>
 
@@ -650,7 +651,8 @@ struct sock *tcp_create_openreq_child(st
 		struct sk_filter *filter;
 #endif
 
-		memcpy(newsk, sk, sizeof(*newsk));
+		clone_sk(newsk, sk);
+
 		newsk->state = TCP_SYN_RECV;
 
 		/* SANITY */
@@ -789,6 +791,8 @@ struct sock *tcp_create_openreq_child(st
 		TCP_ECN_openreq_child(newtp, req);
 
 		TCP_INC_STATS_BH(TcpPassiveOpens);
+
+		security_tcp_create_openreq_child(sk, newsk, skb, req);
 	}
 	return newsk;
 }
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/netlink/af_netlink.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/netlink/af_netlink.c
--- 2425sls2.ea.acl.nfsacl.sec/net/netlink/af_netlink.c	2004-02-18 15:36:32.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/netlink/af_netlink.c	2004-03-02 23:41:24.000000000 +0200
@@ -40,6 +40,7 @@
 #include <linux/proc_fs.h>
 #include <linux/smp_lock.h>
 #include <linux/notifier.h>
+#include <linux/security.h>
 #include <net/sock.h>
 #include <net/scm.h>
 
@@ -626,7 +627,12 @@ static int netlink_sendmsg(struct socket
 	   check them, when this message will be delivered
 	   to corresponding kernel module.   --ANK (980802)
 	 */
-	NETLINK_CB(skb).eff_cap = current->cap_effective;
+
+	err = security_netlink_send(skb);
+	if (err) {
+		kfree_skb(skb);
+		goto out;
+	}
 
 	err = -EFAULT;
 	if (memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len)) {
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/socket.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/socket.c
--- 2425sls2.ea.acl.nfsacl.sec/net/socket.c	2004-02-18 15:36:32.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/socket.c	2004-03-02 23:50:51.000000000 +0200
@@ -74,6 +74,7 @@
 #include <linux/cache.h>
 #include <linux/module.h>
 #include <linux/highmem.h>
+#include <linux/security.h>
 
 #if defined(CONFIG_KMOD) && defined(CONFIG_NET)
 #include <linux/kmod.h>
@@ -502,6 +503,10 @@ int sock_sendmsg(struct socket *sock, st
 	int err;
 	struct scm_cookie scm;
 
+	err = security_socket_sendmsg(sock, msg, size);
+	if (err)
+		return err;
+
 	err = scm_send(sock, msg, &scm);
 	if (err >= 0) {
 		err = sock->ops->sendmsg(sock, msg, size, &scm);
@@ -513,6 +518,11 @@ int sock_sendmsg(struct socket *sock, st
 int sock_recvmsg(struct socket *sock, struct msghdr *msg, int size, int flags)
 {
 	struct scm_cookie scm;
+	int err;
+
+	err = security_socket_recvmsg(sock, msg, size, flags);
+	if (err)
+		return err;
 
 	memset(&scm, 0, sizeof(scm));
 
@@ -824,6 +834,7 @@ int sock_wake_async(struct socket *sock,
 int sock_create(int family, int type, int protocol, struct socket **res)
 {
 	int i;
+	int err;
 	struct socket *sock;
 
 	/*
@@ -847,6 +858,10 @@ int sock_create(int family, int type, in
 		}
 		family = PF_PACKET;
 	}
+
+	err = security_socket_create(family, type, protocol);
+	if (err)
+		return err;
 		
 #if defined(CONFIG_KMOD) && defined(CONFIG_NET)
 	/* Attempt to load a protocol module if the find failed. 
@@ -893,6 +908,8 @@ int sock_create(int family, int type, in
 
 	*res = sock;
 
+	security_socket_post_create(sock, family, type, protocol);
+
 out:
 	net_family_read_unlock();
 	return i;
@@ -1002,8 +1019,14 @@ asmlinkage long sys_bind(int fd, struct 
 
 	if((sock = sockfd_lookup(fd,&err))!=NULL)
 	{
-		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0)
+		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
+			err = security_socket_bind(sock, (struct sockaddr *)address, addrlen);
+			if (err) {
+				sockfd_put(sock);
+				return err;
+			}
 			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
+		}
 		sockfd_put(sock);
 	}			
 	return err;
@@ -1026,6 +1049,13 @@ asmlinkage long sys_listen(int fd, int b
 	if ((sock = sockfd_lookup(fd, &err)) != NULL) {
 		if ((unsigned) backlog > sysctl_somaxconn)
 			backlog = sysctl_somaxconn;
+
+		err = security_socket_listen(sock, backlog);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+
 		err=sock->ops->listen(sock, backlog);
 		sockfd_put(sock);
 	}
@@ -1062,6 +1092,10 @@ asmlinkage long sys_accept(int fd, struc
 	newsock->type = sock->type;
 	newsock->ops = sock->ops;
 
+	err = security_socket_accept(sock, newsock);
+	if (err)
+		goto out_release;
+
 	err = sock->ops->accept(sock, newsock, sock->file->f_flags);
 	if (err < 0)
 		goto out_release;
@@ -1081,6 +1115,8 @@ asmlinkage long sys_accept(int fd, struc
 	if ((err = sock_map_fd(newsock)) < 0)
 		goto out_release;
 
+	security_socket_post_accept(sock, newsock);
+
 out_put:
 	sockfd_put(sock);
 out:
@@ -1116,8 +1152,14 @@ asmlinkage long sys_connect(int fd, stru
 	err = move_addr_to_kernel(uservaddr, addrlen, address);
 	if (err < 0)
 		goto out_put;
+
+	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
+	if (err)
+		goto out_put;
+
 	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
 				 sock->file->f_flags);
+
 out_put:
 	sockfd_put(sock);
 out:
@@ -1138,6 +1180,11 @@ asmlinkage long sys_getsockname(int fd, 
 	sock = sockfd_lookup(fd, &err);
 	if (!sock)
 		goto out;
+
+	err = security_socket_getsockname(sock);
+	if (err)
+		goto out_put;
+
 	err = sock->ops->getname(sock, (struct sockaddr *)address, &len, 0);
 	if (err)
 		goto out_put;
@@ -1162,6 +1209,12 @@ asmlinkage long sys_getpeername(int fd, 
 
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+		err = security_socket_getpeername(sock);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+
 		err = sock->ops->getname(sock, (struct sockaddr *)address, &len, 1);
 		if (!err)
 			err=move_addr_to_user(address,len, usockaddr, usockaddr_len);
@@ -1290,6 +1343,12 @@ asmlinkage long sys_setsockopt(int fd, i
 			
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+		err = security_socket_setsockopt(sock,level,optname);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+
 		if (level == SOL_SOCKET)
 			err=sock_setsockopt(sock,level,optname,optval,optlen);
 		else
@@ -1311,6 +1370,13 @@ asmlinkage long sys_getsockopt(int fd, i
 
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+		err = security_socket_getsockopt(sock, level, 
+							   optname);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+
 		if (level == SOL_SOCKET)
 			err=sock_getsockopt(sock,level,optname,optval,optlen);
 		else
@@ -1332,6 +1398,12 @@ asmlinkage long sys_shutdown(int fd, int
 
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+		err = security_socket_shutdown(sock, how);
+		if (err) {
+			sockfd_put(sock);
+			return err;
+		}
+				
 		err=sock->ops->shutdown(sock, how);
 		sockfd_put(sock);
 	}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/net/unix/af_unix.c 2425sls2.ea.acl.nfsacl.sec.selinux/net/unix/af_unix.c
--- 2425sls2.ea.acl.nfsacl.sec/net/unix/af_unix.c	2002-11-29 01:53:16.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/net/unix/af_unix.c	2004-03-02 23:41:24.000000000 +0200
@@ -109,6 +109,7 @@
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
 #include <linux/rtnetlink.h>
+#include <linux/security.h>
 
 #include <asm/checksum.h>
 
@@ -800,6 +801,11 @@ static int unix_dgram_connect(struct soc
 		err = -EPERM;
 		if (!unix_may_send(sk, other))
 			goto out_unlock;
+
+		err = security_unix_may_send(sk->socket, other->socket);
+		if (err)
+			goto out_unlock;
+
 	} else {
 		/*
 		 *	1003.1g breaking connected state with AF_UNSPEC
@@ -964,6 +970,12 @@ restart:
 		goto restart;
 	}
 
+	err = security_unix_stream_connect(sock, other->socket, newsk);
+	if (err) {
+		unix_state_wunlock(sk);
+		goto out_unlock;
+	}
+
 	/* The way is open! Fastly set all the necessary fields... */
 
 	sock_hold(sk);
@@ -1259,6 +1271,10 @@ restart:
 	if (other->shutdown&RCV_SHUTDOWN)
 		goto out_unlock;
 
+	err = security_unix_may_send(sk->socket, other->socket);
+	if (err)
+		goto out_unlock;
+
 	if (unix_peer(other) != sk &&
 	    skb_queue_len(&other->receive_queue) > other->max_ack_backlog) {
 		if (!timeo) {
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/capability.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/capability.c
--- 2425sls2.ea.acl.nfsacl.sec/security/capability.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/capability.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,408 @@
+/*
+ *  Capabilities Linux Security Module
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/security.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+
+#ifndef CONFIG_SECURITY
+asmlinkage long sys_security (unsigned int id, unsigned int call,
+			      unsigned long *args)
+{
+	return -ENOSYS;
+}
+#endif
+
+int cap_capable (struct task_struct *tsk, int cap)
+{
+	/* Derived from include/linux/sched.h:capable. */
+	if (cap_raised (tsk->cap_effective, cap))
+		return 0;
+	else
+		return -EPERM;
+}
+
+int cap_netlink_send (struct sk_buff *skb)
+{
+	NETLINK_CB (skb).eff_cap = current->cap_effective;
+	return 0;
+}
+
+int cap_netlink_recv (struct sk_buff *skb)
+{
+	if (!cap_raised (NETLINK_CB (skb).eff_cap, CAP_NET_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int cap_ptrace (struct task_struct *parent, struct task_struct *child)
+{
+	/* Derived from arch/i386/kernel/ptrace.c:sys_ptrace. */
+	if (!cap_issubset (child->cap_permitted, current->cap_permitted) &&
+	    !capable (CAP_SYS_PTRACE))
+		return -EPERM;
+	else
+		return 0;
+}
+
+int cap_capget (struct task_struct *target, kernel_cap_t *effective,
+		kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	/* Derived from kernel/capability.c:sys_capget. */
+	*effective = cap_t (target->cap_effective);
+	*inheritable = cap_t (target->cap_inheritable);
+	*permitted = cap_t (target->cap_permitted);
+	return 0;
+}
+
+int cap_capset_check (struct task_struct *target, kernel_cap_t *effective,
+		      kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	/* Derived from kernel/capability.c:sys_capset. */
+	/* verify restrictions on target's new Inheritable set */
+	if (!cap_issubset (*inheritable,
+			   cap_combine (target->cap_inheritable,
+					current->cap_permitted))) {
+		return -EPERM;
+	}
+
+	/* verify restrictions on target's new Permitted set */
+	if (!cap_issubset (*permitted,
+			   cap_combine (target->cap_permitted,
+					current->cap_permitted))) {
+		return -EPERM;
+	}
+
+	/* verify the _new_Effective_ is a subset of the _new_Permitted_ */
+	if (!cap_issubset (*effective, *permitted)) {
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+void cap_capset_set (struct task_struct *target, kernel_cap_t *effective,
+		     kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	target->cap_effective = *effective;
+	target->cap_inheritable = *inheritable;
+	target->cap_permitted = *permitted;
+}
+
+int cap_bprm_set_security (struct linux_binprm *bprm)
+{
+	/* Copied from fs/exec.c:prepare_binprm. */
+
+	/* We don't have VFS support for capabilities yet */
+	cap_clear (bprm->cap_inheritable);
+	cap_clear (bprm->cap_permitted);
+	cap_clear (bprm->cap_effective);
+
+	/*  To support inheritance of root-permissions and suid-root
+	 *  executables under compatibility mode, we raise all three
+	 *  capability sets for the file.
+	 *
+	 *  If only the real uid is 0, we only raise the inheritable
+	 *  and permitted sets of the executable file.
+	 */
+
+	if (!issecure (SECURE_NOROOT)) {
+		if (bprm->e_uid == 0 || current->uid == 0) {
+			cap_set_full (bprm->cap_inheritable);
+			cap_set_full (bprm->cap_permitted);
+		}
+		if (bprm->e_uid == 0)
+			cap_set_full (bprm->cap_effective);
+	}
+	return 0;
+}
+
+/* Copied from fs/exec.c */
+static inline int must_not_trace_exec (struct task_struct *p)
+{
+	return (p->ptrace & PT_PTRACED) && !(p->ptrace & PT_PTRACE_CAP);
+}
+
+void cap_bprm_compute_creds (struct linux_binprm *bprm)
+{
+	/* Derived from fs/exec.c:compute_creds. */
+	kernel_cap_t new_permitted, working;
+	int do_unlock = 0;
+
+	new_permitted = cap_intersect (bprm->cap_permitted, cap_bset);
+	working = cap_intersect (bprm->cap_inheritable,
+				 current->cap_inheritable);
+	new_permitted = cap_combine (new_permitted, working);
+
+	if (!cap_issubset (new_permitted, current->cap_permitted)) {
+		current->mm->dumpable = 0;
+
+		lock_kernel ();
+		if (must_not_trace_exec (current)
+		    || atomic_read (&current->fs->count) > 1
+		    || atomic_read (&current->files->count) > 1
+		    || atomic_read (&current->sig->count) > 1) {
+			if (!capable (CAP_SETPCAP)) {
+				new_permitted = cap_intersect (new_permitted,
+							       current->
+							       cap_permitted);
+			}
+		}
+		do_unlock = 1;
+	}
+
+	/* For init, we want to retain the capabilities set
+	 * in the init_task struct. Thus we skip the usual
+	 * capability rules */
+	if (current->pid != 1) {
+		current->cap_permitted = new_permitted;
+		current->cap_effective =
+		    cap_intersect (new_permitted, bprm->cap_effective);
+	}
+
+	/* AUD: Audit candidate if current->cap_effective is set */
+
+	if (do_unlock)
+		unlock_kernel ();
+
+	current->keep_capabilities = 0;
+}
+
+int cap_bprm_secureexec (struct linux_binprm *bprm)
+{
+	/* If/when this module is enhanced to incorporate capability
+	   bits on files, the test below should be extended to also perform a 
+	   test between the old and new capability sets.  For now,
+	   it simply preserves the legacy decision algorithm used by
+	   the old userland. */
+	return (current->euid != current->uid ||
+		current->egid != current->gid);
+}
+
+/* moved from kernel/sys.c. */
+/* 
+ * cap_emulate_setxuid() fixes the effective / permitted capabilities of
+ * a process after a call to setuid, setreuid, or setresuid.
+ *
+ *  1) When set*uiding _from_ one of {r,e,s}uid == 0 _to_ all of
+ *  {r,e,s}uid != 0, the permitted and effective capabilities are
+ *  cleared.
+ *
+ *  2) When set*uiding _from_ euid == 0 _to_ euid != 0, the effective
+ *  capabilities of the process are cleared.
+ *
+ *  3) When set*uiding _from_ euid != 0 _to_ euid == 0, the effective
+ *  capabilities are set to the permitted capabilities.
+ *
+ *  fsuid is handled elsewhere. fsuid == 0 and {r,e,s}uid!= 0 should 
+ *  never happen.
+ *
+ *  -astor 
+ *
+ * cevans - New behaviour, Oct '99
+ * A process may, via prctl(), elect to keep its capabilities when it
+ * calls setuid() and switches away from uid==0. Both permitted and
+ * effective sets will be retained.
+ * Without this change, it was impossible for a daemon to drop only some
+ * of its privilege. The call to setuid(!=0) would drop all privileges!
+ * Keeping uid 0 is not an option because uid 0 owns too many vital
+ * files..
+ * Thanks to Olaf Kirch and Peter Benie for spotting this.
+ */
+static inline void cap_emulate_setxuid (int old_ruid, int old_euid,
+					int old_suid)
+{
+	if ((old_ruid == 0 || old_euid == 0 || old_suid == 0) &&
+	    (current->uid != 0 && current->euid != 0 && current->suid != 0) &&
+	    !current->keep_capabilities) {
+		cap_clear (current->cap_permitted);
+		cap_clear (current->cap_effective);
+	}
+	if (old_euid == 0 && current->euid != 0) {
+		cap_clear (current->cap_effective);
+	}
+	if (old_euid != 0 && current->euid == 0) {
+		current->cap_effective = current->cap_permitted;
+	}
+}
+
+int cap_task_post_setuid (uid_t old_ruid, uid_t old_euid, uid_t old_suid,
+			  int flags)
+{
+	switch (flags) {
+	case LSM_SETID_RE:
+	case LSM_SETID_ID:
+	case LSM_SETID_RES:
+		/* Copied from kernel/sys.c:setreuid/setuid/setresuid. */
+		if (!issecure (SECURE_NO_SETUID_FIXUP)) {
+			cap_emulate_setxuid (old_ruid, old_euid, old_suid);
+		}
+		break;
+	case LSM_SETID_FS:
+		{
+			uid_t old_fsuid = old_ruid;
+
+			/* Copied from kernel/sys.c:setfsuid. */
+
+			/*
+			 * FIXME - is fsuser used for all CAP_FS_MASK capabilities?
+			 *          if not, we might be a bit too harsh here.
+			 */
+
+			if (!issecure (SECURE_NO_SETUID_FIXUP)) {
+				if (old_fsuid == 0 && current->fsuid != 0) {
+					cap_t (current->cap_effective) &=
+					    ~CAP_FS_MASK;
+				}
+				if (old_fsuid != 0 && current->fsuid == 0) {
+					cap_t (current->cap_effective) |=
+					    (cap_t (current->cap_permitted) &
+					     CAP_FS_MASK);
+				}
+			}
+			break;
+		}
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void cap_task_kmod_set_label (void)
+{
+	cap_set_full (current->cap_effective);
+	return;
+}
+
+void cap_task_reparent_to_init (struct task_struct *p)
+{
+	p->cap_effective = CAP_INIT_EFF_SET;
+	p->cap_inheritable = CAP_INIT_INH_SET;
+	p->cap_permitted = CAP_FULL_SET;
+	p->keep_capabilities = 0;
+	return;
+}
+
+int cap_syslog (int type)
+{
+	if ((type != 3) && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int cap_ip_decode_options (struct sk_buff *skb, const char *optptr,
+			   unsigned char **pp_ptr)
+{
+	if (!skb && !capable (CAP_NET_RAW)) {
+		(const unsigned char *) *pp_ptr = optptr;
+		return -EPERM;
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(cap_capable);
+EXPORT_SYMBOL(cap_ptrace);
+EXPORT_SYMBOL(cap_capget);
+EXPORT_SYMBOL(cap_capset_check);
+EXPORT_SYMBOL(cap_capset_set);
+EXPORT_SYMBOL(cap_bprm_set_security);
+EXPORT_SYMBOL(cap_bprm_compute_creds);
+EXPORT_SYMBOL(cap_bprm_secureexec);
+EXPORT_SYMBOL(cap_task_post_setuid);
+EXPORT_SYMBOL(cap_task_kmod_set_label);
+EXPORT_SYMBOL(cap_task_reparent_to_init);
+EXPORT_SYMBOL(cap_netlink_send);
+EXPORT_SYMBOL(cap_netlink_recv);
+EXPORT_SYMBOL(cap_ip_decode_options);
+EXPORT_SYMBOL(cap_syslog);
+
+#ifdef CONFIG_SECURITY
+
+static struct security_operations capability_ops = {
+	.ptrace =			cap_ptrace,
+	.capget =			cap_capget,
+	.capset_check =			cap_capset_check,
+	.capset_set =			cap_capset_set,
+	.capable =			cap_capable,
+	.netlink_send =			cap_netlink_send,
+	.netlink_recv =			cap_netlink_recv,
+
+	.bprm_compute_creds =		cap_bprm_compute_creds,
+	.bprm_set_security =		cap_bprm_set_security,
+	.bprm_secureexec =		cap_bprm_secureexec,
+
+	.task_post_setuid =		cap_task_post_setuid,
+	.task_kmod_set_label =		cap_task_kmod_set_label,
+	.task_reparent_to_init =	cap_task_reparent_to_init,
+
+	.syslog =                       cap_syslog,
+
+	.ip_decode_options =		cap_ip_decode_options,
+};
+
+#if defined(CONFIG_SECURITY_CAPABILITIES_MODULE)
+#define MY_NAME THIS_MODULE->name
+#else
+#define MY_NAME "capability"
+#endif
+
+/* flag to keep track of how we were registered */
+static int secondary;
+
+
+static int __init capability_init (void)
+{
+	/* register ourselves with the security framework */
+	if (register_security (&capability_ops)) {
+		printk (KERN_INFO
+			"Failure registering capabilities with the kernel\n");
+		/* try registering with primary module */
+		if (mod_reg_security (MY_NAME, &capability_ops)) {
+			printk (KERN_INFO "Failure registering capabilities "
+				"with primary security module.\n");
+			return -EINVAL;
+		}
+		secondary = 1;
+	}
+	printk (KERN_INFO "Capability LSM initialized\n");
+	return 0;
+}
+
+static void __exit capability_exit (void)
+{
+	/* remove ourselves from the security framework */
+	if (secondary) {
+		if (mod_unreg_security (MY_NAME, &capability_ops))
+			printk (KERN_INFO "Failure unregistering capabilities "
+				"with primary module.\n");
+		return;
+	}
+
+	if (unregister_security (&capability_ops)) {
+		printk (KERN_INFO
+			"Failure unregistering capabilities with the kernel\n");
+	}
+}
+
+security_initcall (capability_init);
+module_exit (capability_exit);
+
+MODULE_DESCRIPTION("Standard Linux Capabilities Security Module");
+MODULE_LICENSE("GPL");
+
+#endif	/* CONFIG_SECURITY */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/Config.in 2425sls2.ea.acl.nfsacl.sec.selinux/security/Config.in
--- 2425sls2.ea.acl.nfsacl.sec/security/Config.in	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/Config.in	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,12 @@
+#
+# Security configuration
+#
+mainmenu_option next_comment
+comment 'Security options'
+bool 'Enable different security models' CONFIG_SECURITY
+if [ "$CONFIG_SECURITY" != "n" ]; then
+  bool 'Socket and Networking Security Hooks' CONFIG_SECURITY_NETWORK
+  tristate 'Capabilities Support' CONFIG_SECURITY_CAPABILITIES
+  source security/selinux/Config.in
+fi
+endmenu
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/dummy.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/dummy.c
--- 2425sls2.ea.acl.nfsacl.sec/security/dummy.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/dummy.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,1155 @@
+/*
+ * Stub functions for the default security function pointers in case no
+ * security model is loaded.
+ *
+ * Copyright (C) 2001 WireX Communications, Inc <chris@wirex.com>
+ * Copyright (C) 2001-2002  Greg Kroah-Hartman <greg@kroah.com>
+ * Copyright (C) 2001 Networks Associates Technology, Inc <ssmalley@nai.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ */
+
+#undef DEBUG
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/security.h>
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+
+static int dummy_sys_security (unsigned int id, unsigned int call,
+			       unsigned long *args)
+{
+	return -ENOSYS;
+}
+
+static int dummy_nfsservctl (int cmd, struct nfsctl_arg *arg)
+{
+	return 0;
+}
+
+static int dummy_bdflush (int func, long data)
+{
+	return 0;
+}
+
+static int dummy_module_create (const char *name_user, size_t size)
+{
+	return 0;
+}
+
+static int dummy_module_initialize (struct module *mod_user)
+{
+	return 0;
+}
+
+static int dummy_module_delete (const struct module *mod)
+{
+	return 0;
+}
+
+static int dummy_sethostname (char *hostname)
+{
+	return 0;
+}
+
+static int dummy_setdomainname (char *domainname)
+{
+	return 0;
+}
+
+static int dummy_reboot (unsigned int cmd)
+{
+	return 0;
+}
+
+static int dummy_ioperm (unsigned long from, unsigned long num, int turn_on)
+{
+	return 0;
+}
+
+static int dummy_iopl (unsigned int old, unsigned int level)
+{
+	return 0;
+}
+
+static int dummy_ptrace (struct task_struct *parent, struct task_struct *child)
+{
+	return 0;
+}
+
+static int dummy_capget (struct task_struct *target, kernel_cap_t * effective,
+			 kernel_cap_t * inheritable, kernel_cap_t * permitted)
+{
+	*effective = *inheritable = *permitted = 0;
+	if (!issecure(SECURE_NOROOT)) {
+		if (target->euid == 0) {
+			*permitted |= (~0 & ~CAP_FS_MASK);
+			*effective |= (~0 & ~CAP_TO_MASK(CAP_SETPCAP) & ~CAP_FS_MASK);
+		}
+		if (target->fsuid == 0) {
+			*permitted |= CAP_FS_MASK;
+			*effective |= CAP_FS_MASK;
+		}
+	}
+	return 0;
+}
+
+static int dummy_capset_check (struct task_struct *target,
+			       kernel_cap_t * effective,
+			       kernel_cap_t * inheritable,
+			       kernel_cap_t * permitted)
+{
+	return -EPERM;
+}
+
+static void dummy_capset_set (struct task_struct *target,
+			      kernel_cap_t * effective,
+			      kernel_cap_t * inheritable,
+			      kernel_cap_t * permitted)
+{
+	return;
+}
+
+static int dummy_acct (struct file *file)
+{
+	return 0;
+}
+
+static int dummy_capable (struct task_struct *tsk, int cap)
+{
+	if (cap_is_fs_cap (cap) ? tsk->fsuid == 0 : tsk->euid == 0)
+		/* capability granted */
+		return 0;
+
+	/* capability denied */
+	return -EPERM;
+}
+
+static int dummy_sysctl (ctl_table * table, int op)
+{
+	return 0;
+}
+
+static int dummy_swapon (struct swap_info_struct *swap)
+{
+	return 0;
+}
+
+static int dummy_swapoff (struct swap_info_struct *swap)
+{
+	return 0;
+}
+
+static int dummy_quotactl (int cmds, int type, int id, struct super_block *sb)
+{
+	return 0;
+}
+
+static int dummy_quota_on (struct file *f)
+{
+	return 0;
+}
+
+static int dummy_syslog (int type)
+{
+	if ((type != 3) && current->euid)
+		return -EPERM;
+	return 0;
+}
+
+static int dummy_settime (struct timeval *tv, struct timezone *tz)
+{
+	return 0;
+}
+
+static int dummy_netlink_send (struct sk_buff *skb)
+{
+	if (current->euid == 0)
+		cap_raise (NETLINK_CB (skb).eff_cap, CAP_NET_ADMIN);
+	else
+		NETLINK_CB (skb).eff_cap = 0;
+	return 0;
+}
+
+static int dummy_netlink_recv (struct sk_buff *skb)
+{
+	if (!cap_raised (NETLINK_CB (skb).eff_cap, CAP_NET_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+static int dummy_bprm_alloc_security (struct linux_binprm *bprm)
+{
+	return 0;
+}
+
+static void dummy_bprm_free_security (struct linux_binprm *bprm)
+{
+	return;
+}
+
+static void dummy_bprm_compute_creds (struct linux_binprm *bprm)
+{
+	return;
+}
+
+static int dummy_bprm_set_security (struct linux_binprm *bprm)
+{
+	return 0;
+}
+
+static int dummy_bprm_check_security (struct linux_binprm *bprm)
+{
+	return 0;
+}
+
+static int dummy_bprm_secureexec (struct linux_binprm *bprm)
+{
+	/* The new userland will simply use the value provided
+	   in the AT_SECURE field to decide whether secure mode
+	   is required.  Hence, this logic is required to preserve
+	   the legacy decision algorithm used by the old userland. */
+	return (current->euid != current->uid ||
+		current->egid != current->gid);
+}
+
+static int dummy_sb_alloc_security (struct super_block *sb)
+{
+	return 0;
+}
+
+static void dummy_sb_free_security (struct super_block *sb)
+{
+	return;
+}
+
+static int dummy_sb_kern_mount (struct super_block *sb)
+{
+	return 0;
+}
+
+static int dummy_sb_statfs (struct super_block *sb)
+{
+	return 0;
+}
+
+static int dummy_sb_mount (char *dev_name, struct nameidata *nd, char *type,
+			   unsigned long flags, void *data)
+{
+	return 0;
+}
+
+static int dummy_sb_check_sb (struct vfsmount *mnt, struct nameidata *nd)
+{
+	return 0;
+}
+
+static int dummy_sb_umount (struct vfsmount *mnt, int flags)
+{
+	return 0;
+}
+
+static void dummy_sb_umount_close (struct vfsmount *mnt)
+{
+	return;
+}
+
+static void dummy_sb_umount_busy (struct vfsmount *mnt)
+{
+	return;
+}
+
+static void dummy_sb_post_remount (struct vfsmount *mnt, unsigned long flags,
+				   void *data)
+{
+	return;
+}
+
+
+static void dummy_sb_post_mountroot (void)
+{
+	return;
+}
+
+static void dummy_sb_post_addmount (struct vfsmount *mnt, struct nameidata *nd)
+{
+	return;
+}
+
+static int dummy_sb_pivotroot (struct nameidata *old_nd, struct nameidata *new_nd)
+{
+	return 0;
+}
+
+static void dummy_sb_post_pivotroot (struct nameidata *old_nd, struct nameidata *new_nd)
+{
+	return;
+}
+
+static int dummy_inode_alloc_security (struct inode *inode)
+{
+	return 0;
+}
+
+static void dummy_inode_free_security (struct inode *inode)
+{
+	return;
+}
+
+static int dummy_inode_create (struct inode *inode, struct dentry *dentry,
+			       int mask)
+{
+	return 0;
+}
+
+static void dummy_inode_post_create (struct inode *inode, struct dentry *dentry,
+				     int mask)
+{
+	return;
+}
+
+static int dummy_inode_link (struct dentry *old_dentry, struct inode *inode,
+			     struct dentry *new_dentry)
+{
+	return 0;
+}
+
+static void dummy_inode_post_link (struct dentry *old_dentry,
+				   struct inode *inode,
+				   struct dentry *new_dentry)
+{
+	return;
+}
+
+static int dummy_inode_unlink (struct inode *inode, struct dentry *dentry)
+{
+	return 0;
+}
+
+static int dummy_inode_symlink (struct inode *inode, struct dentry *dentry,
+				const char *name)
+{
+	return 0;
+}
+
+static void dummy_inode_post_symlink (struct inode *inode,
+				      struct dentry *dentry, const char *name)
+{
+	return;
+}
+
+static int dummy_inode_mkdir (struct inode *inode, struct dentry *dentry,
+			      int mask)
+{
+	return 0;
+}
+
+static void dummy_inode_post_mkdir (struct inode *inode, struct dentry *dentry,
+				    int mask)
+{
+	return;
+}
+
+static int dummy_inode_rmdir (struct inode *inode, struct dentry *dentry)
+{
+	return 0;
+}
+
+static int dummy_inode_mknod (struct inode *inode, struct dentry *dentry,
+			      int mode, dev_t dev)
+{
+	return 0;
+}
+
+static void dummy_inode_post_mknod (struct inode *inode, struct dentry *dentry,
+				    int mode, dev_t dev)
+{
+	return;
+}
+
+static int dummy_inode_rename (struct inode *old_inode,
+			       struct dentry *old_dentry,
+			       struct inode *new_inode,
+			       struct dentry *new_dentry)
+{
+	return 0;
+}
+
+static void dummy_inode_post_rename (struct inode *old_inode,
+				     struct dentry *old_dentry,
+				     struct inode *new_inode,
+				     struct dentry *new_dentry)
+{
+	return;
+}
+
+static int dummy_inode_readlink (struct dentry *dentry)
+{
+	return 0;
+}
+
+static int dummy_inode_follow_link (struct dentry *dentry,
+				    struct nameidata *nameidata)
+{
+	return 0;
+}
+
+static int dummy_inode_permission (struct inode *inode, int mask)
+{
+	return 0;
+}
+
+static int dummy_inode_revalidate (struct dentry *dentry)
+{
+	return 0;
+}
+
+static int dummy_inode_setattr (struct dentry *dentry, struct iattr *iattr)
+{
+	return 0;
+}
+
+static int dummy_inode_stat (struct inode *inode)
+{
+	return 0;
+}
+
+static void dummy_inode_delete (struct inode *ino)
+{
+	return;
+}
+
+static int dummy_inode_setxattr (struct dentry *dentry, char *name, void *value,
+				size_t size, int flags)
+{
+	if (strncmp(name, "security.", 9) == 0 && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+static void dummy_inode_post_setxattr (struct dentry *dentry, char *name, void *value,
+				       size_t size, int flags)
+{
+}
+
+static int dummy_inode_getxattr (struct dentry *dentry, char *name)
+{
+	return 0;
+}
+
+static int dummy_inode_listxattr (struct dentry *dentry)
+{
+	return 0;
+}
+
+static int dummy_inode_removexattr (struct dentry *dentry, char *name)
+{
+	if (strncmp(name, "security.", 9) == 0 && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+static int dummy_inode_getsecurity(struct dentry *dentry, const char *name, void *buffer, size_t size)
+{
+	return -EOPNOTSUPP;
+}
+
+static int dummy_inode_setsecurity(struct dentry *dentry, const char *name, const void *value, size_t size, int flags) 
+{
+	return -EOPNOTSUPP;
+}
+
+static int dummy_inode_listsecurity(struct dentry *dentry, char *buffer)
+{
+	return 0;
+}
+
+static int dummy_file_permission (struct file *file, int mask)
+{
+	return 0;
+}
+
+static int dummy_file_alloc_security (struct file *file)
+{
+	return 0;
+}
+
+static void dummy_file_free_security (struct file *file)
+{
+	return;
+}
+
+static int dummy_file_ioctl (struct file *file, unsigned int command,
+			     unsigned long arg)
+{
+	return 0;
+}
+
+static int dummy_file_mmap (struct file *file, unsigned long prot,
+			    unsigned long flags)
+{
+	return 0;
+}
+
+static int dummy_file_mprotect (struct vm_area_struct *vma, unsigned long prot)
+{
+	return 0;
+}
+
+static int dummy_file_lock (struct file *file, unsigned int cmd)
+{
+	return 0;
+}
+
+static int dummy_file_fcntl (struct file *file, unsigned int cmd,
+			     unsigned long arg)
+{
+	return 0;
+}
+
+static int dummy_file_set_fowner (struct file *file)
+{
+	return 0;
+}
+
+static int dummy_file_send_sigiotask (struct task_struct *tsk,
+				      struct fown_struct *fown, int fd,
+				      int reason)
+{
+	return 0;
+}
+
+static int dummy_file_receive (struct file *file)
+{
+	return 0;
+}
+
+static int dummy_task_create (unsigned long clone_flags)
+{
+	return 0;
+}
+
+static int dummy_task_alloc_security (struct task_struct *p)
+{
+	return 0;
+}
+
+static void dummy_task_free_security (struct task_struct *p)
+{
+	return;
+}
+
+static int dummy_task_setuid (uid_t id0, uid_t id1, uid_t id2, int flags)
+{
+	return 0;
+}
+
+static int dummy_task_post_setuid (uid_t id0, uid_t id1, uid_t id2, int flags)
+{
+	return 0;
+}
+
+static int dummy_task_setgid (gid_t id0, gid_t id1, gid_t id2, int flags)
+{
+	return 0;
+}
+
+static int dummy_task_setpgid (struct task_struct *p, pid_t pgid)
+{
+	return 0;
+}
+
+static int dummy_task_getpgid (struct task_struct *p)
+{
+	return 0;
+}
+
+static int dummy_task_getsid (struct task_struct *p)
+{
+	return 0;
+}
+
+static int dummy_task_setgroups (int gidsetsize, gid_t * grouplist)
+{
+	return 0;
+}
+
+static int dummy_task_setnice (struct task_struct *p, int nice)
+{
+	return 0;
+}
+
+static int dummy_task_setrlimit (unsigned int resource, struct rlimit *new_rlim)
+{
+	return 0;
+}
+
+static int dummy_task_setscheduler (struct task_struct *p, int policy,
+				    struct sched_param *lp)
+{
+	return 0;
+}
+
+static int dummy_task_getscheduler (struct task_struct *p)
+{
+	return 0;
+}
+
+static int dummy_task_wait (struct task_struct *p)
+{
+	return 0;
+}
+
+static int dummy_task_kill (struct task_struct *p, struct siginfo *info,
+			    int sig)
+{
+	return 0;
+}
+
+static int dummy_task_prctl (int option, unsigned long arg2, unsigned long arg3,
+			     unsigned long arg4, unsigned long arg5)
+{
+	return 0;
+}
+
+static void dummy_task_kmod_set_label (void)
+{
+	return;
+}
+
+static void dummy_task_reparent_to_init (struct task_struct *p)
+{
+	p->euid = p->fsuid = 0;
+	return;
+}
+
+static void dummy_task_to_inode(struct task_struct *p, struct inode *inode)
+{ }
+
+static int dummy_ipc_permission (struct kern_ipc_perm *ipcp, short flag)
+{
+	return 0;
+}
+
+static int dummy_msg_msg_alloc_security (struct msg_msg *msg)
+{
+	return 0;
+}
+
+static void dummy_msg_msg_free_security (struct msg_msg *msg)
+{
+	return;
+}
+
+static int dummy_msg_queue_alloc_security (struct msg_queue *msq)
+{
+	return 0;
+}
+
+static void dummy_msg_queue_free_security (struct msg_queue *msq)
+{
+	return;
+}
+
+static int dummy_msg_queue_associate (struct msg_queue *msq, 
+				      int msqflg)
+{
+	return 0;
+}
+
+static int dummy_msg_queue_msgctl (struct msg_queue *msq, int cmd)
+{
+	return 0;
+}
+
+static int dummy_msg_queue_msgsnd (struct msg_queue *msq, struct msg_msg *msg,
+				   int msgflg)
+{
+	return 0;
+}
+
+static int dummy_msg_queue_msgrcv (struct msg_queue *msq, struct msg_msg *msg,
+				   struct task_struct *target, long type,
+				   int mode)
+{
+	return 0;
+}
+
+static int dummy_shm_alloc_security (struct shmid_kernel *shp)
+{
+	return 0;
+}
+
+static void dummy_shm_free_security (struct shmid_kernel *shp)
+{
+	return;
+}
+
+static int dummy_shm_associate (struct shmid_kernel *shp, int shmflg)
+{
+	return 0;
+}
+
+static int dummy_shm_shmctl (struct shmid_kernel *shp, int cmd)
+{
+	return 0;
+}
+
+static int dummy_shm_shmat (struct shmid_kernel *shp, char *shmaddr,
+			    int shmflg)
+{
+	return 0;
+}
+
+static int dummy_sem_alloc_security (struct sem_array *sma)
+{
+	return 0;
+}
+
+static void dummy_sem_free_security (struct sem_array *sma)
+{
+	return;
+}
+
+static int dummy_sem_associate (struct sem_array *sma, int semflg)
+{
+	return 0;
+}
+
+static int dummy_sem_semctl (struct sem_array *sma, int cmd)
+{
+	return 0;
+}
+
+static int dummy_sem_semop (struct sem_array *sma, 
+			    struct sembuf *sops, unsigned nsops, int alter)
+{
+	return 0;
+}
+
+static int dummy_ip_decode_options (struct sk_buff *skb, const char *optptr,
+				    unsigned char **pp_ptr)
+{
+	if (!skb && !capable (CAP_NET_RAW)) {
+		(const unsigned char *) *pp_ptr = optptr;
+		return -EPERM;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_SECURITY_NETWORK
+
+static void dummy_ip_fragment (struct sk_buff *newskb,
+			       const struct sk_buff *oldskb)
+{
+	return;
+}
+
+static int dummy_ip_defragment (struct sk_buff *skb)
+{
+	return 0;
+}
+
+static void dummy_ip_decapsulate (struct sk_buff *skb)
+{
+	return;
+}
+
+static void dummy_ip_encapsulate (struct sk_buff *skb)
+{
+	return;
+}
+
+static void dummy_netdev_unregister (struct net_device *dev)
+{
+	return;
+}
+
+static int dummy_socket_create (int family, int type, int protocol)
+{
+	return 0;
+}
+
+static void dummy_socket_post_create (struct socket *sock, int family, int type,
+				      int protocol)
+{
+	return;
+}
+
+static int dummy_socket_bind (struct socket *sock, struct sockaddr *address,
+			      int addrlen)
+{
+	return 0;
+}
+
+static int dummy_socket_connect (struct socket *sock, struct sockaddr *address,
+				 int addrlen)
+{
+	return 0;
+}
+
+static int dummy_socket_listen (struct socket *sock, int backlog)
+{
+	return 0;
+}
+
+static int dummy_socket_accept (struct socket *sock, struct socket *newsock)
+{
+	return 0;
+}
+
+static void dummy_socket_post_accept (struct socket *sock, 
+				      struct socket *newsock)
+{
+	return;
+}
+
+static int dummy_socket_sendmsg (struct socket *sock, struct msghdr *msg,
+				 int size)
+{
+	return 0;
+}
+
+static int dummy_socket_recvmsg (struct socket *sock, struct msghdr *msg,
+				 int size, int flags)
+{
+	return 0;
+}
+
+static int dummy_socket_getsockname (struct socket *sock)
+{
+	return 0;
+}
+
+static int dummy_socket_getpeername (struct socket *sock)
+{
+	return 0;
+}
+
+static int dummy_socket_setsockopt (struct socket *sock, int level, int optname)
+{
+	return 0;
+}
+
+static int dummy_socket_getsockopt (struct socket *sock, int level, int optname)
+{
+	return 0;
+}
+
+static int dummy_socket_shutdown (struct socket *sock, int how)
+{
+	return 0;
+}
+
+static int dummy_socket_sock_alloc_security(struct sock *sk, int gfp_mask)
+{
+	sk->security = NULL;
+	return 0;
+}
+
+static void dummy_socket_sock_free_security(struct sock *sk)
+{
+	return;
+}
+
+static int dummy_socket_sock_rcv_skb (struct sock *sk, struct sk_buff *skb)
+{
+	return 0;
+}
+
+static int dummy_open_request_alloc_security(struct open_request * req)
+{
+	req->security = NULL;
+	return 0;
+}
+
+static void dummy_open_request_free_security(struct open_request * req)
+{
+	return;
+}
+
+static void dummy_tcp_connection_request(struct sock *sk, struct sk_buff * skb, 
+					 struct open_request *req)
+{
+	return;
+}
+
+static void dummy_tcp_synack(struct sock *sk, struct sk_buff * skb, 
+			     struct open_request *req)
+{
+	return;
+}
+
+static void dummy_tcp_create_openreq_child(struct sock *sk, struct sock *newsk, 
+					   struct sk_buff *skb,
+					   struct open_request *req)
+{
+	return;
+}
+
+static int dummy_unix_stream_connect (struct socket *sock,
+				      struct socket *other,
+				      struct sock *newsk)
+{
+	return 0;
+}
+
+static int dummy_unix_may_send (struct socket *sock,
+				struct socket *other)
+{
+	return 0;
+}
+
+static int dummy_skb_alloc_security (struct sk_buff *skb, int gfp_mask)
+{
+	return 0;
+}
+
+static int dummy_skb_clone (struct sk_buff *newskb,
+			     const struct sk_buff *oldskb)
+{
+	return 0;
+}
+
+static void dummy_skb_copy (struct sk_buff *newskb,
+			    const struct sk_buff *oldskb)
+{
+	return;
+}
+
+static void dummy_skb_set_owner_w (struct sk_buff *skb, struct sock *sk)
+{
+	return;
+}
+
+static void dummy_skb_recv_datagram (struct sk_buff *skb, struct sock *sk,
+				     unsigned flags)
+{
+	return;
+}
+
+static void dummy_skb_free_security (struct sk_buff *skb)
+{
+	return;
+}
+
+#endif
+
+static int dummy_register_security (const char *name, struct security_operations *ops)
+{
+	return -EINVAL;
+}
+
+static int dummy_unregister_security (const char *name, struct security_operations *ops)
+{
+	return -EINVAL;
+}
+
+static void dummy_d_instantiate (struct dentry *dentry, struct inode *inode)
+{
+	return;
+}
+
+static int dummy_getprocattr(struct task_struct *p, char *name, void *value, size_t size)
+{
+	return -EINVAL;
+}
+
+static int dummy_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
+{
+	return -EINVAL;
+}
+
+
+struct security_operations dummy_security_ops;
+
+#define set_to_dummy_if_null(ops, function)				\
+	do {								\
+		if (!ops->function) {					\
+			ops->function = dummy_##function;		\
+			pr_debug("Had to override the " #function	\
+				 " security operation with the dummy one.\n");\
+			}						\
+	} while (0)
+
+void security_fixup_ops (struct security_operations *ops)
+{
+	set_to_dummy_if_null(ops, sys_security);
+	set_to_dummy_if_null(ops, nfsservctl);
+	set_to_dummy_if_null(ops, bdflush);
+	set_to_dummy_if_null(ops, module_create);
+	set_to_dummy_if_null(ops, module_initialize);
+	set_to_dummy_if_null(ops, module_delete);
+	set_to_dummy_if_null(ops, ptrace);
+	set_to_dummy_if_null(ops, capget);
+	set_to_dummy_if_null(ops, capset_check);
+	set_to_dummy_if_null(ops, capset_set);
+	set_to_dummy_if_null(ops, acct);
+	set_to_dummy_if_null(ops, capable);
+	set_to_dummy_if_null(ops, quotactl);
+	set_to_dummy_if_null(ops, quota_on);
+	set_to_dummy_if_null(ops, sysctl);
+	set_to_dummy_if_null(ops, syslog);
+	set_to_dummy_if_null(ops, bprm_alloc_security);
+	set_to_dummy_if_null(ops, bprm_free_security);
+	set_to_dummy_if_null(ops, bprm_compute_creds);
+	set_to_dummy_if_null(ops, bprm_set_security);
+	set_to_dummy_if_null(ops, bprm_check_security);
+	set_to_dummy_if_null(ops, bprm_secureexec);
+	set_to_dummy_if_null(ops, sb_alloc_security);
+	set_to_dummy_if_null(ops, sb_free_security);
+	set_to_dummy_if_null(ops, sb_kern_mount);
+	set_to_dummy_if_null(ops, sb_statfs);
+	set_to_dummy_if_null(ops, sb_mount);
+	set_to_dummy_if_null(ops, sb_check_sb);
+	set_to_dummy_if_null(ops, sb_umount);
+	set_to_dummy_if_null(ops, sb_umount_close);
+	set_to_dummy_if_null(ops, sb_umount_busy);
+	set_to_dummy_if_null(ops, sb_post_remount);
+	set_to_dummy_if_null(ops, sb_post_mountroot);
+	set_to_dummy_if_null(ops, sb_post_addmount);
+	set_to_dummy_if_null(ops, sb_pivotroot);
+	set_to_dummy_if_null(ops, sb_post_pivotroot);
+	set_to_dummy_if_null(ops, inode_alloc_security);
+	set_to_dummy_if_null(ops, inode_free_security);
+	set_to_dummy_if_null(ops, inode_create);
+	set_to_dummy_if_null(ops, inode_post_create);
+	set_to_dummy_if_null(ops, inode_link);
+	set_to_dummy_if_null(ops, inode_post_link);
+	set_to_dummy_if_null(ops, inode_unlink);
+	set_to_dummy_if_null(ops, inode_symlink);
+	set_to_dummy_if_null(ops, inode_post_symlink);
+	set_to_dummy_if_null(ops, inode_mkdir);
+	set_to_dummy_if_null(ops, inode_post_mkdir);
+	set_to_dummy_if_null(ops, inode_rmdir);
+	set_to_dummy_if_null(ops, inode_mknod);
+	set_to_dummy_if_null(ops, inode_post_mknod);
+	set_to_dummy_if_null(ops, inode_rename);
+	set_to_dummy_if_null(ops, inode_post_rename);
+	set_to_dummy_if_null(ops, inode_readlink);
+	set_to_dummy_if_null(ops, inode_follow_link);
+	set_to_dummy_if_null(ops, inode_permission);
+	set_to_dummy_if_null(ops, inode_revalidate);
+	set_to_dummy_if_null(ops, inode_setattr);
+	set_to_dummy_if_null(ops, inode_stat);
+	set_to_dummy_if_null(ops, inode_delete);
+	set_to_dummy_if_null(ops, inode_setxattr);
+	set_to_dummy_if_null(ops, inode_post_setxattr);
+	set_to_dummy_if_null(ops, inode_getxattr);
+	set_to_dummy_if_null(ops, inode_listxattr);
+	set_to_dummy_if_null(ops, inode_removexattr);
+	set_to_dummy_if_null(ops, inode_getsecurity);
+	set_to_dummy_if_null(ops, inode_setsecurity);
+	set_to_dummy_if_null(ops, inode_listsecurity);
+	set_to_dummy_if_null(ops, file_permission);
+	set_to_dummy_if_null(ops, file_alloc_security);
+	set_to_dummy_if_null(ops, file_free_security);
+	set_to_dummy_if_null(ops, file_ioctl);
+	set_to_dummy_if_null(ops, file_mmap);
+	set_to_dummy_if_null(ops, file_mprotect);
+	set_to_dummy_if_null(ops, file_lock);
+	set_to_dummy_if_null(ops, file_fcntl);
+	set_to_dummy_if_null(ops, file_set_fowner);
+	set_to_dummy_if_null(ops, file_send_sigiotask);
+	set_to_dummy_if_null(ops, file_receive);
+	set_to_dummy_if_null(ops, task_create);
+	set_to_dummy_if_null(ops, task_alloc_security);
+	set_to_dummy_if_null(ops, task_free_security);
+	set_to_dummy_if_null(ops, task_setuid);
+	set_to_dummy_if_null(ops, task_post_setuid);
+	set_to_dummy_if_null(ops, task_setgid);
+	set_to_dummy_if_null(ops, task_setpgid);
+	set_to_dummy_if_null(ops, task_getpgid);
+	set_to_dummy_if_null(ops, task_getsid);
+	set_to_dummy_if_null(ops, task_setgroups);
+	set_to_dummy_if_null(ops, task_setnice);
+	set_to_dummy_if_null(ops, task_setrlimit);
+	set_to_dummy_if_null(ops, task_setscheduler);
+	set_to_dummy_if_null(ops, task_getscheduler);
+	set_to_dummy_if_null(ops, task_wait);
+	set_to_dummy_if_null(ops, task_kill);
+	set_to_dummy_if_null(ops, task_prctl);
+	set_to_dummy_if_null(ops, task_kmod_set_label);
+	set_to_dummy_if_null(ops, task_reparent_to_init);
+	set_to_dummy_if_null(ops, task_to_inode);
+	set_to_dummy_if_null(ops, ipc_permission);
+	set_to_dummy_if_null(ops, msg_msg_alloc_security);
+	set_to_dummy_if_null(ops, msg_msg_free_security);
+	set_to_dummy_if_null(ops, msg_queue_alloc_security);
+	set_to_dummy_if_null(ops, msg_queue_free_security);
+	set_to_dummy_if_null(ops, msg_queue_associate);
+	set_to_dummy_if_null(ops, msg_queue_msgctl);
+	set_to_dummy_if_null(ops, msg_queue_msgsnd);
+	set_to_dummy_if_null(ops, msg_queue_msgrcv);
+	set_to_dummy_if_null(ops, shm_alloc_security);
+	set_to_dummy_if_null(ops, shm_free_security);
+	set_to_dummy_if_null(ops, shm_associate);
+	set_to_dummy_if_null(ops, shm_shmctl);
+	set_to_dummy_if_null(ops, shm_shmat);
+	set_to_dummy_if_null(ops, sem_alloc_security);
+	set_to_dummy_if_null(ops, sem_free_security);
+	set_to_dummy_if_null(ops, sem_associate);
+	set_to_dummy_if_null(ops, sem_semctl);
+	set_to_dummy_if_null(ops, sem_semop);
+	set_to_dummy_if_null(ops, register_security);
+	set_to_dummy_if_null(ops, unregister_security);
+	set_to_dummy_if_null(ops, d_instantiate);
+	set_to_dummy_if_null(ops, getprocattr);
+ 	set_to_dummy_if_null(ops, setprocattr);
+	set_to_dummy_if_null(ops, sethostname);
+	set_to_dummy_if_null(ops, setdomainname);
+	set_to_dummy_if_null(ops, reboot);
+	set_to_dummy_if_null(ops, ioperm);
+	set_to_dummy_if_null(ops, iopl);
+	set_to_dummy_if_null(ops, swapon);
+	set_to_dummy_if_null(ops, swapoff);
+	set_to_dummy_if_null(ops, settime);
+	set_to_dummy_if_null(ops, netlink_send);
+	set_to_dummy_if_null(ops, netlink_recv);
+	set_to_dummy_if_null(ops, ip_decode_options);
+#ifdef CONFIG_SECURITY_NETWORK
+	set_to_dummy_if_null(ops, ip_fragment);
+	set_to_dummy_if_null(ops, ip_defragment);
+	set_to_dummy_if_null(ops, ip_decapsulate);
+	set_to_dummy_if_null(ops, ip_encapsulate);
+	set_to_dummy_if_null(ops, netdev_unregister);
+	set_to_dummy_if_null(ops, socket_create);
+	set_to_dummy_if_null(ops, socket_post_create);
+	set_to_dummy_if_null(ops, socket_bind);
+	set_to_dummy_if_null(ops, socket_connect);
+	set_to_dummy_if_null(ops, socket_listen);
+	set_to_dummy_if_null(ops, socket_accept);
+	set_to_dummy_if_null(ops, socket_post_accept);
+	set_to_dummy_if_null(ops, socket_sendmsg);
+	set_to_dummy_if_null(ops, socket_recvmsg);
+	set_to_dummy_if_null(ops, socket_getsockname);
+	set_to_dummy_if_null(ops, socket_getpeername);
+	set_to_dummy_if_null(ops, socket_setsockopt);
+	set_to_dummy_if_null(ops, socket_getsockopt);
+	set_to_dummy_if_null(ops, socket_shutdown);
+	set_to_dummy_if_null(ops, socket_sock_alloc_security);
+	set_to_dummy_if_null(ops, socket_sock_free_security);
+	set_to_dummy_if_null(ops, socket_sock_rcv_skb);
+	set_to_dummy_if_null(ops, open_request_alloc_security);
+	set_to_dummy_if_null(ops, open_request_free_security);
+	set_to_dummy_if_null(ops, tcp_connection_request);
+	set_to_dummy_if_null(ops, tcp_synack);
+	set_to_dummy_if_null(ops, tcp_create_openreq_child);
+	set_to_dummy_if_null(ops, unix_stream_connect);
+	set_to_dummy_if_null(ops, unix_may_send);
+	set_to_dummy_if_null(ops, skb_alloc_security);
+	set_to_dummy_if_null(ops, skb_clone);
+	set_to_dummy_if_null(ops, skb_copy);
+	set_to_dummy_if_null(ops, skb_set_owner_w);
+	set_to_dummy_if_null(ops, skb_recv_datagram);
+	set_to_dummy_if_null(ops, skb_free_security);
+#endif
+}
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/Makefile 2425sls2.ea.acl.nfsacl.sec.selinux/security/Makefile
--- 2425sls2.ea.acl.nfsacl.sec/security/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/Makefile	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,29 @@
+#
+# Makefile for the kernel security code
+#
+
+# The target object and module list name.
+O_TARGET	:= vmlinux-obj.o
+
+# subdirectory list
+subdir-$(CONFIG_SECURITY_SELINUX)	+= selinux
+
+# Objects that export symbols
+export-objs	:= security.o capability.o
+
+# if we don't select a security model, use the default capabilities
+ifneq ($(CONFIG_SECURITY),y)
+obj-y		+= capability.o
+endif
+
+# Object file lists
+obj-$(CONFIG_SECURITY)		+= security.o dummy.o
+
+# Must precede capabilities in order to stack properly.
+ifeq ($(CONFIG_SECURITY_SELINUX),y)
+	obj-$(CONFIG_SECURITY_SELINUX)	+= selinux/selinux-obj.o
+endif
+obj-$(CONFIG_SECURITY_CAPABILITIES)	+= capability.o
+obj-$(CONFIG_SECURITY_OWLSM)		+= owlsm.o
+
+include $(TOPDIR)/Rules.make
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/Makefile.in 2425sls2.ea.acl.nfsacl.sec.selinux/security/Makefile.in
--- 2425sls2.ea.acl.nfsacl.sec/security/Makefile.in	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/Makefile.in	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,29 @@
+
+# Beginnings of a kbuild-2.5 makefile --- offer@sgi.com
+
+
+
+# security.o has exportable symbols.
+expsyms(security.o)
+
+# Always build the framework
+select(security.o)
+select(dummy.o)
+
+
+# the pre-existing capabilities code.
+select(CONFIG_M CONFIG_SECURITY_CAPABILITIES capability.o)
+
+
+
+# OpenWall
+select(CONFIG_M CONFIG_SECURITY_OWLSM owlsm.o)
+
+# NSA/NAI SELinux
+link_subdirs(selinux)
+
+# Domain Type Enforcement
+link_subdirs(dte)
+
+# Linux Intrusion Detection System 
+link_subdirs(lids)
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/security.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/security.c
--- 2425sls2.ea.acl.nfsacl.sec/security/security.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/security.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,227 @@
+/*
+ * Security plug functions
+ *
+ * Copyright (C) 2001 WireX Communications, Inc <chris@wirex.com>
+ * Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>
+ * Copyright (C) 2001 Networks Associates Technology, Inc <ssmalley@nai.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/security.h>
+
+#define SECURITY_SCAFFOLD_VERSION	"1.0.0"
+
+/* things that live in dummy.c */
+extern struct security_operations dummy_security_ops;
+extern void security_fixup_ops (struct security_operations *ops);
+
+struct security_operations *security_ops;	/* Initialized to NULL */
+
+static inline int verify (struct security_operations *ops)
+{
+	/* verify the security_operations structure exists */
+	if (!ops) {
+		printk (KERN_INFO "Passed a NULL security_operations "
+			"pointer, %s failed.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	security_fixup_ops (ops);
+	return 0;
+}
+
+static void __init do_security_initcalls(void)
+{
+	initcall_t *call;
+	call = &__security_initcall_start;
+	while (call < &__security_initcall_end) {
+		(*call)();
+		call++;
+	}
+}
+
+/**
+ * security_scaffolding_startup - initialzes the security scaffolding framework
+ *
+ * This should be called early in the kernel initialization sequence.
+ */
+int __init security_scaffolding_startup (void)
+{
+	printk (KERN_INFO "Security Scaffold v" SECURITY_SCAFFOLD_VERSION
+		" initialized\n");
+
+	if (verify (&dummy_security_ops)) {
+		printk (KERN_ERR "%s could not verify "
+			"dummy_security_ops structure.\n", __FUNCTION__);
+		return -EIO;
+	}
+
+	security_ops = &dummy_security_ops;
+	do_security_initcalls();
+	return 0;
+}
+
+/**
+ * register_security - registers a security framework with the kernel
+ * @ops: a pointer to the struct security_options that is to be registered
+ *
+ * This function is to allow a security module to register itself with the
+ * kernel security subsystem.  Some rudimentary checking is done on the @ops
+ * value passed to this function.  A call to unregister_security() should be
+ * done to remove this security_options structure from the kernel.
+ *
+ * If the @ops structure does not contain function pointers for all hooks in
+ * the structure, or there is already a security module registered with the
+ * kernel, an error will be returned.  Otherwise 0 is returned on success.
+ */
+int register_security (struct security_operations *ops)
+{
+	if (verify (ops)) {
+		printk (KERN_INFO "%s could not verify "
+			"security_operations structure.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (security_ops != &dummy_security_ops) {
+		printk (KERN_INFO "There is already a security "
+			"framework initialized, %s failed.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	security_ops = ops;
+
+	return 0;
+}
+
+/**
+ * unregister_security - unregisters a security framework with the kernel
+ * @ops: a pointer to the struct security_options that is to be registered
+ *
+ * This function removes a struct security_operations variable that had
+ * previously been registered with a successful call to register_security().
+ *
+ * If @ops does not match the valued previously passed to register_security()
+ * an error is returned.  Otherwise the default security options is set to the
+ * the dummy_security_ops structure, and 0 is returned.
+ */
+int unregister_security (struct security_operations *ops)
+{
+	if (ops != security_ops) {
+		printk (KERN_INFO "%s: trying to unregister "
+			"a security_opts structure that is not "
+			"registered, failing.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	security_ops = &dummy_security_ops;
+
+	return 0;
+}
+
+/**
+ * mod_reg_security - allows security modules to be "stacked"
+ * @name: a pointer to a string with the name of the security_options to be registered
+ * @ops: a pointer to the struct security_options that is to be registered
+ *
+ * This function allows security modules to be stacked if the currently loaded
+ * security module allows this to happen.  It passes the @name and @ops to the
+ * register_security function of the currently loaded security module.
+ *
+ * The return value depends on the currently loaded security module, with 0 as
+ * success.
+ */
+int mod_reg_security (const char *name, struct security_operations *ops)
+{
+	if (verify (ops)) {
+		printk (KERN_INFO "%s could not verify "
+			"security operations.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (ops == security_ops) {
+		printk (KERN_INFO "%s security operations "
+			"already registered.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	return security_ops->register_security (name, ops);
+}
+
+/**
+ * mod_unreg_security - allows a security module registered with mod_reg_security() to be unloaded
+ * @name: a pointer to a string with the name of the security_options to be removed
+ * @ops: a pointer to the struct security_options that is to be removed
+ *
+ * This function allows security modules that have been successfully registered
+ * with a call to mod_reg_security() to be unloaded from the system.
+ * This calls the currently loaded security module's unregister_security() call
+ * with the @name and @ops variables.
+ *
+ * The return value depends on the currently loaded security module, with 0 as
+ * success.
+ */
+int mod_unreg_security (const char *name, struct security_operations *ops)
+{
+	if (ops == security_ops) {
+		printk (KERN_INFO "%s invalid attempt to unregister "
+			" primary security ops.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	return security_ops->unregister_security (name, ops);
+}
+
+/**
+ * capable - calls the currently loaded security module's capable() function with the specified capability
+ * @cap: the requested capability level.
+ *
+ * This function calls the currently loaded security module's cabable()
+ * function with a pointer to the current task and the specified @cap value.
+ *
+ * This allows the security module to implement the capable function call
+ * however it chooses to.
+ */
+int capable (int cap)
+{
+	if (security_ops->capable (current, cap)) {
+		/* capability denied */
+		return 0;
+	}
+
+	/* capability granted */
+	current->flags |= PF_SUPERPRIV;
+	return 1;
+}
+
+/**
+ * sys_security - security syscall multiplexor.
+ * @id: module id
+ * @call: call identifier
+ * @args: arg list for call
+ *
+ * Similar to sys_socketcall.  Can use id to help identify which module user
+ * app is talking to.  The recommended convention for creating the
+ * hexadecimal id value is:
+ * 'echo "Name_of_module" | md5sum | cut -c -8'.
+ * By following this convention, there's no need for a central registry.
+ */
+asmlinkage long sys_security (unsigned int id, unsigned int call,
+			      unsigned long *args)
+{
+	return security_syscall (id, call, args);
+}
+
+EXPORT_SYMBOL_GPL(register_security);
+EXPORT_SYMBOL_GPL(unregister_security);
+EXPORT_SYMBOL_GPL(mod_reg_security);
+EXPORT_SYMBOL_GPL(mod_unreg_security);
+EXPORT_SYMBOL(capable);
+EXPORT_SYMBOL(security_ops);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/avc.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/avc.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/avc.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/avc.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,1129 @@
+/*
+ * Implementation of the kernel access vector cache (AVC).
+ *
+ * Authors:  Stephen Smalley, <sds@epoch.ncsc.mil>
+ *           James Morris <jmorris@redhat.com>
+ *
+ * Copyright (C) 2003 Red Hat, Inc., James Morris <jmorris@redhat.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License version 2,
+ *      as published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/dcache.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <linux/un.h>
+#include <net/af_unix.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/tcp.h>
+#include "avc.h"
+#include "avc_ss.h"
+#include "class_to_string.h"
+#include "common_perm_to_string.h"
+#include "av_inherit.h"
+#include "av_perm_to_string.h"
+#include "objsec.h"
+#include "compatibility.h"
+
+#define AVC_CACHE_SLOTS		512
+#define AVC_CACHE_MAXNODES	410
+
+struct avc_entry {
+	u32			ssid;
+	u32			tsid;
+	u16			tclass;
+	struct av_decision	avd;
+	int			used;	/* used recently */
+};
+
+struct avc_node {
+	struct avc_entry	ae;
+	struct avc_node		*next;
+};
+
+struct avc_cache {
+	struct avc_node	*slots[AVC_CACHE_SLOTS];
+	u32		lru_hint;	/* LRU hint for reclaim scan */
+	u32		active_nodes;
+	u32		latest_notif;	/* latest revocation notification */
+};
+
+struct avc_callback_node {
+	int (*callback) (u32 event, u32 ssid, u32 tsid,
+	                 u16 tclass, u32 perms,
+	                 u32 *out_retained);
+	u32 events;
+	u32 ssid;
+	u32 tsid;
+	u16 tclass;
+	u32 perms;
+	struct avc_callback_node *next;
+};
+
+static spinlock_t avc_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t avc_log_lock = SPIN_LOCK_UNLOCKED;
+static struct avc_node *avc_node_freelist = NULL;
+static struct avc_cache avc_cache;
+static char *avc_audit_buffer = NULL;
+static unsigned avc_cache_stats[AVC_NSTATS];
+static struct avc_callback_node *avc_callbacks = NULL;
+static unsigned int avc_log_level = 4; /* default:  KERN_WARNING */
+static char avc_level_string[4] = "< >";
+
+static inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)
+{
+	return (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);
+}
+
+/**
+ * avc_dump_av - Display an access vector in human-readable form.
+ * @tclass: target security class
+ * @av: access vector
+ */
+void avc_dump_av(u16 tclass, u32 av)
+{
+	char **common_pts = 0;
+	u32 common_base = 0;
+	int i, i2, perm;
+
+	if (av == 0) {
+		printk(" null");
+		return;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(av_inherit); i++) {
+		if (av_inherit[i].tclass == tclass) {
+			common_pts = av_inherit[i].common_pts;
+			common_base = av_inherit[i].common_base;
+			break;
+		}
+	}
+
+	printk(" {");
+	i = 0;
+	perm = 1;
+	while (perm < common_base) {
+		if (perm & av)
+			printk(" %s", common_pts[i]);
+		i++;
+		perm <<= 1;
+	}
+
+	while (i < sizeof(av) * 8) {
+		if (perm & av) {
+			for (i2 = 0; i2 < ARRAY_SIZE(av_perm_to_string); i2++) {
+				if ((av_perm_to_string[i2].tclass == tclass) &&
+				    (av_perm_to_string[i2].value == perm))
+					break;
+			}
+			if (i2 < ARRAY_SIZE(av_perm_to_string))
+				printk(" %s", av_perm_to_string[i2].name);
+		}
+		i++;
+		perm <<= 1;
+	}
+
+	printk(" }");
+}
+
+/**
+ * avc_dump_query - Display a SID pair and a class in human-readable form.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ */
+void avc_dump_query(u32 ssid, u32 tsid, u16 tclass)
+{
+	int rc;
+	char *scontext;
+	u32 scontext_len;
+
+ 	rc = security_sid_to_context(ssid, &scontext, &scontext_len);
+	if (rc)
+		printk("ssid=%d", ssid);
+	else {
+		printk("scontext=%s", scontext);
+		kfree(scontext);
+	}
+
+	rc = security_sid_to_context(tsid, &scontext, &scontext_len);
+	if (rc)
+		printk(" tsid=%d", tsid);
+	else {
+		printk(" tcontext=%s", scontext);
+		kfree(scontext);
+	}
+	printk(" tclass=%s", class_to_string[tclass]);
+}
+
+/**
+ * avc_init - Initialize the AVC.
+ *
+ * Initialize the access vector cache.
+ */
+void avc_init(void)
+{
+	struct avc_node	*new;
+	int i;
+
+	for (i = 0; i < AVC_NSTATS; i++)
+		avc_cache_stats[i] = 0;
+
+	for (i = 0; i < AVC_CACHE_SLOTS; i++)
+		avc_cache.slots[i] = 0;
+	avc_cache.lru_hint = 0;
+	avc_cache.active_nodes = 0;
+	avc_cache.latest_notif = 0;
+
+	for (i = 0; i < AVC_CACHE_MAXNODES; i++) {
+		new = kmalloc(sizeof(*new), GFP_ATOMIC);
+		if (!new) {
+			printk(KERN_WARNING "avc:  only able to allocate "
+			       "%d entries\n", i);
+			break;
+		}
+		memset(new, 0, sizeof(*new));
+		new->next = avc_node_freelist;
+		avc_node_freelist = new;
+	}
+
+	avc_audit_buffer = (char *)__get_free_page(GFP_ATOMIC);
+	if (!avc_audit_buffer)
+		panic("AVC:  unable to allocate audit buffer\n");
+
+	avc_level_string[1] = '0' + avc_log_level;
+}
+
+#if 0
+static void avc_hash_eval(char *tag)
+{
+	int i, chain_len, max_chain_len, slots_used;
+	struct avc_node *node;
+	unsigned long flags;
+
+	spin_lock_irqsave(&avc_lock,flags);
+
+	slots_used = 0;
+	max_chain_len = 0;
+	for (i = 0; i < AVC_CACHE_SLOTS; i++) {
+		node = avc_cache.slots[i];
+		if (node) {
+			slots_used++;
+			chain_len = 0;
+			while (node) {
+				chain_len++;
+				node = node->next;
+			}
+			if (chain_len > max_chain_len)
+				max_chain_len = chain_len;
+		}
+	}
+
+	spin_unlock_irqrestore(&avc_lock,flags);
+
+	printk(KERN_INFO "\n");
+	printk(KERN_INFO "%s avc:  %d entries and %d/%d buckets used, longest "
+	       "chain length %d\n", tag, avc_cache.active_nodes, slots_used,
+	       AVC_CACHE_SLOTS, max_chain_len);
+}
+#else
+static inline void avc_hash_eval(char *tag)
+{ }
+#endif
+
+static inline struct avc_node *avc_reclaim_node(void)
+{
+	struct avc_node *prev, *cur;
+	int hvalue, try;
+
+	hvalue = avc_cache.lru_hint;
+	for (try = 0; try < 2; try++) {
+		do {
+			prev = NULL;
+			cur = avc_cache.slots[hvalue];
+			while (cur) {
+				if (!cur->ae.used)
+					goto found;
+
+				cur->ae.used = 0;
+
+				prev = cur;
+				cur = cur->next;
+			}
+			hvalue = (hvalue + 1) & (AVC_CACHE_SLOTS - 1);
+		} while (hvalue != avc_cache.lru_hint);
+	}
+
+	panic("avc_reclaim_node");
+
+found:
+	avc_cache.lru_hint = hvalue;
+
+	if (prev == NULL)
+		avc_cache.slots[hvalue] = cur->next;
+	else
+		prev->next = cur->next;
+
+	return cur;
+}
+
+static inline struct avc_node *avc_claim_node(u32 ssid,
+                                              u32 tsid, u16 tclass)
+{
+	struct avc_node *new;
+	int hvalue;
+
+	hvalue = avc_hash(ssid, tsid, tclass);
+	if (avc_node_freelist) {
+		new = avc_node_freelist;
+		avc_node_freelist = avc_node_freelist->next;
+		avc_cache.active_nodes++;
+	} else {
+		new = avc_reclaim_node();
+		if (!new)
+			goto out;
+	}
+
+	new->ae.used = 1;
+	new->ae.ssid = ssid;
+	new->ae.tsid = tsid;
+	new->ae.tclass = tclass;
+	new->next = avc_cache.slots[hvalue];
+	avc_cache.slots[hvalue] = new;
+
+out:
+	return new;
+}
+
+static inline struct avc_node *avc_search_node(u32 ssid, u32 tsid,
+                                               u16 tclass, int *probes)
+{
+	struct avc_node *cur;
+	int hvalue;
+	int tprobes = 1;
+
+	hvalue = avc_hash(ssid, tsid, tclass);
+	cur = avc_cache.slots[hvalue];
+	while (cur != NULL &&
+	       (ssid != cur->ae.ssid ||
+		tclass != cur->ae.tclass ||
+		tsid != cur->ae.tsid)) {
+		tprobes++;
+		cur = cur->next;
+	}
+
+	if (cur == NULL) {
+		/* cache miss */
+		goto out;
+	}
+
+	/* cache hit */
+	if (probes)
+		*probes = tprobes;
+
+	cur->ae.used = 1;
+
+out:
+	return cur;
+}
+
+/**
+ * avc_lookup - Look up an AVC entry.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ * @requested: requested permissions, interpreted based on @tclass
+ * @aeref:  AVC entry reference
+ *
+ * Look up an AVC entry that is valid for the
+ * @requested permissions between the SID pair
+ * (@ssid, @tsid), interpreting the permissions
+ * based on @tclass.  If a valid AVC entry exists,
+ * then this function updates @aeref to refer to the
+ * entry and returns %0. Otherwise, this function
+ * returns -%ENOENT.
+ */
+int avc_lookup(u32 ssid, u32 tsid, u16 tclass,
+               u32 requested, struct avc_entry_ref *aeref)
+{
+	struct avc_node *node;
+	int probes, rc = 0;
+
+	avc_cache_stats_incr(AVC_CAV_LOOKUPS);
+	node = avc_search_node(ssid, tsid, tclass,&probes);
+
+	if (node && ((node->ae.avd.decided & requested) == requested)) {
+		avc_cache_stats_incr(AVC_CAV_HITS);
+		avc_cache_stats_add(AVC_CAV_PROBES,probes);
+		aeref->ae = &node->ae;
+		goto out;
+	}
+
+	avc_cache_stats_incr(AVC_CAV_MISSES);
+	rc = -ENOENT;
+out:
+	return rc;
+}
+
+/**
+ * avc_insert - Insert an AVC entry.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ * @ae: AVC entry
+ * @aeref:  AVC entry reference
+ *
+ * Insert an AVC entry for the SID pair
+ * (@ssid, @tsid) and class @tclass.
+ * The access vectors and the sequence number are
+ * normally provided by the security server in
+ * response to a security_compute_av() call.  If the
+ * sequence number @ae->avd.seqno is not less than the latest
+ * revocation notification, then the function copies
+ * the access vectors into a cache entry, updates
+ * @aeref to refer to the entry, and returns %0.
+ * Otherwise, this function returns -%EAGAIN.
+ */
+int avc_insert(u32 ssid, u32 tsid, u16 tclass,
+               struct avc_entry *ae, struct avc_entry_ref *aeref)
+{
+	struct avc_node *node;
+	int rc = 0;
+
+	if (ae->avd.seqno < avc_cache.latest_notif) {
+		printk(KERN_WARNING "avc:  seqno %d < latest_notif %d\n",
+		       ae->avd.seqno, avc_cache.latest_notif);
+		rc = -EAGAIN;
+		goto out;
+	}
+
+	node = avc_claim_node(ssid, tsid, tclass);
+	if (!node) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	node->ae.avd.allowed = ae->avd.allowed;
+	node->ae.avd.decided = ae->avd.decided;
+	node->ae.avd.auditallow = ae->avd.auditallow;
+	node->ae.avd.auditdeny = ae->avd.auditdeny;
+	node->ae.avd.seqno = ae->avd.seqno;
+	aeref->ae = &node->ae;
+out:
+	return rc;
+}
+
+static inline void avc_print_ipv4_addr(u32 addr, u16 port, char *name1, char *name2)
+{
+	if (addr)
+		printk(" %s=%d.%d.%d.%d", name1, NIPQUAD(addr));
+	if (port)
+		printk(" %s=%d", name2, ntohs(port));
+}
+
+/*
+ * Copied from net/core/utils.c:net_ratelimit and modified for
+ * use by the AVC audit facility.
+ */
+#define AVC_MSG_COST	5*HZ
+#define AVC_MSG_BURST	10*5*HZ
+
+/*
+ * This enforces a rate limit: not more than one kernel message
+ * every 5secs to make a denial-of-service attack impossible.
+ */
+static int avc_ratelimit(void)
+{
+	static spinlock_t ratelimit_lock = SPIN_LOCK_UNLOCKED;
+	static unsigned long toks = 10*5*HZ;
+	static unsigned long last_msg;
+	static int missed, rc = 0;
+	unsigned long flags;
+	unsigned long now = jiffies;
+
+	spin_lock_irqsave(&ratelimit_lock, flags);
+	toks += now - last_msg;
+	last_msg = now;
+	if (toks > AVC_MSG_BURST)
+		toks = AVC_MSG_BURST;
+	if (toks >= AVC_MSG_COST) {
+		int lost = missed;
+		missed = 0;
+		toks -= AVC_MSG_COST;
+		spin_unlock_irqrestore(&ratelimit_lock, flags);
+		if (lost)
+			printk(KERN_WARNING "AVC: %d messages suppressed.\n",
+			       lost);
+		rc = 1;
+		goto out;
+	}
+	missed++;
+	spin_unlock_irqrestore(&ratelimit_lock, flags);
+out:
+	return rc;
+}
+
+static inline int check_avc_ratelimit(void)
+{
+	if (selinux_enforcing)
+		return avc_ratelimit();
+	else {
+		/* If permissive, then never suppress messages. */
+		return 1;
+	}
+}
+
+/**
+ * avc_audit - Audit the granting or denial of permissions.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ * @requested: requested permissions
+ * @avd: access vector decisions
+ * @result: result from avc_has_perm_noaudit
+ * @a:  auxiliary audit data
+ *
+ * Audit the granting or denial of permissions in accordance
+ * with the policy.  This function is typically called by
+ * avc_has_perm() after a permission check, but can also be
+ * called directly by callers who use avc_has_perm_noaudit()
+ * in order to separate the permission check from the auditing.
+ * For example, this separation is useful when the permission check must
+ * be performed under a lock, to allow the lock to be released
+ * before calling the auditing code.
+ */
+void avc_audit(u32 ssid, u32 tsid,
+               u16 tclass, u32 requested,
+               struct av_decision *avd, int result, struct avc_audit_data *a)
+{
+	struct task_struct *tsk = current;
+	struct inode *inode = NULL;
+	char *p;
+	u32 denied, audited;
+	unsigned long flags;
+
+	denied = requested & ~avd->allowed;
+	if (denied) {
+		audited = denied;
+		if (!(audited & avd->auditdeny))
+			return;
+	} else if (result) {
+		audited = denied = requested;
+        } else {
+		audited = requested;
+		if (!(audited & avd->auditallow))
+			return;
+	}
+
+	if (!check_avc_ratelimit())
+		return;
+
+	/* prevent overlapping printks */
+	spin_lock_irqsave(&avc_log_lock,flags);
+
+	printk("%s\n", avc_level_string);
+	printk("%savc:  %s ", avc_level_string, denied ? "denied" : "granted");
+	avc_dump_av(tclass,audited);
+	printk(" for ");
+	if (a && a->tsk)
+		tsk = a->tsk;
+	if (tsk && tsk->pid) {
+		struct mm_struct *mm;
+		struct vm_area_struct *vma;
+		printk(" pid=%d", tsk->pid);
+		if (tsk == current)
+			mm = current->mm;
+		else
+			mm = get_task_mm(tsk);
+		if (mm) {
+			if (down_read_trylock(&mm->mmap_sem)) {
+				vma = mm->mmap;
+				while (vma) {
+					if ((vma->vm_flags & VM_EXECUTABLE) &&
+					    vma->vm_file) {
+						p = d_path(vma->vm_file->f_dentry,
+							   vma->vm_file->f_vfsmnt,
+							   avc_audit_buffer,
+							   PAGE_SIZE);
+						printk(" exe=%s", p);
+						break;
+					}
+					vma = vma->vm_next;
+				}
+				up_read(&mm->mmap_sem);
+			}
+			if (tsk != current)
+				mmput(mm);
+		} else {
+			printk(" comm=%s", tsk->comm);
+		}
+	}
+	if (a) {
+		switch (a->type) {
+		case AVC_AUDIT_DATA_IPC:
+			printk(" key=%d", a->u.ipc_id);
+			break;
+		case AVC_AUDIT_DATA_CAP:
+			printk(" capability=%d", a->u.cap);
+			break;
+		case AVC_AUDIT_DATA_FS:
+			if (a->u.fs.dentry) {
+				struct dentry *dentry = a->u.fs.dentry;
+				if (a->u.fs.mnt) {
+					p = d_path(dentry,
+						   a->u.fs.mnt,
+						   avc_audit_buffer,
+						   PAGE_SIZE);
+					if (p)
+						printk(" path=%s", p);
+				} else {
+					printk(" name=%s", dentry->d_name.name);
+				}
+				inode = dentry->d_inode;
+			} else if (a->u.fs.inode) {
+				struct dentry *dentry;
+				inode = a->u.fs.inode;
+				dentry = d_find_alias(inode);
+				if (dentry) {
+					printk(" name=%s", dentry->d_name.name);
+					dput(dentry);
+				}
+			}
+			if (inode)
+				printk(" dev=%02x:%02x ino=%ld",
+				       MAJOR(inode->i_dev),
+				       MINOR(inode->i_dev), 
+				       inode->i_ino);
+			break;
+		case AVC_AUDIT_DATA_NET:
+			if (a->u.net.sk) {
+				struct sock *sk = a->u.net.sk;
+				struct unix_sock *u;
+				struct sock *inet;
+
+				switch (sk->sk_family) {
+				case AF_INET:
+					inet = inet_sk(sk);
+					avc_print_ipv4_addr(inet->rcv_saddr,
+					                    inet->sport,
+					                    "laddr", "lport");
+					avc_print_ipv4_addr(inet->daddr,
+					                    inet->dport,
+					                    "faddr", "fport");
+					break;
+				case AF_UNIX:
+					u = unix_sk(sk);
+					if (u->dentry) {
+						p = d_path(u->dentry,
+							   u->mnt,
+							   avc_audit_buffer,
+							   PAGE_SIZE);
+						printk(" path=%s", p);
+					} else if (u->addr) {
+						p = avc_audit_buffer;
+						memcpy(p,
+						       u->addr->name->sun_path,
+						       u->addr->len-sizeof(short));
+						if (*p == 0) {
+							*p = '@';
+							p += u->addr->len-sizeof(short);
+							*p = 0;
+						}
+						printk(" path=%s",
+						       avc_audit_buffer);
+					}
+					break;
+				}
+			}
+			if (a->u.net.daddr) {
+				printk(" daddr=%d.%d.%d.%d",
+				       NIPQUAD(a->u.net.daddr));
+				if (a->u.net.port)
+					printk(" dest=%d", a->u.net.port);
+			} else if (a->u.net.port)
+				printk(" port=%d", a->u.net.port);
+			if (a->u.net.skb) {
+				struct sk_buff *skb = a->u.net.skb;
+
+				if ((skb->protocol == htons(ETH_P_IP)) &&
+				     skb->nh.iph) {
+					u16 source = 0, dest = 0;
+					u8  protocol = skb->nh.iph->protocol;
+
+
+					if (protocol == IPPROTO_TCP &&
+					    skb->h.th) {
+						source = skb->h.th->source;
+						dest = skb->h.th->dest;
+					}
+					if (protocol == IPPROTO_UDP &&
+					    skb->h.uh) {
+						source = skb->h.uh->source;
+						dest = skb->h.uh->dest;
+					}
+
+					avc_print_ipv4_addr(skb->nh.iph->saddr,
+					                    source,
+					                    "saddr", "source");
+					avc_print_ipv4_addr(skb->nh.iph->daddr,
+					                    dest,
+					                    "daddr", "dest");
+				}
+			}
+			if (a->u.net.netif)
+				printk(" netif=%s", a->u.net.netif);
+			break;
+		}
+	}
+	printk(" ");
+	avc_dump_query(ssid, tsid, tclass);
+	printk("\n");
+
+	spin_unlock_irqrestore(&avc_log_lock,flags);
+}
+
+/**
+ * avc_add_callback - Register a callback for security events.
+ * @callback: callback function
+ * @events: security events
+ * @ssid: source security identifier or %SECSID_WILD
+ * @tsid: target security identifier or %SECSID_WILD
+ * @tclass: target security class
+ * @perms: permissions
+ *
+ * Register a callback function for events in the set @events
+ * related to the SID pair (@ssid, @tsid) and
+ * and the permissions @perms, interpreting
+ * @perms based on @tclass.  Returns %0 on success or
+ * -%ENOMEM if insufficient memory exists to add the callback.
+ */
+int avc_add_callback(int (*callback)(u32 event, u32 ssid, u32 tsid,
+                                     u16 tclass, u32 perms,
+                                     u32 *out_retained),
+                     u32 events, u32 ssid, u32 tsid,
+                     u16 tclass, u32 perms)
+{
+	struct avc_callback_node *c;
+	int rc = 0;
+
+	c = kmalloc(sizeof(*c), GFP_ATOMIC);
+	if (!c) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	c->callback = callback;
+	c->events = events;
+	c->ssid = ssid;
+	c->tsid = tsid;
+	c->perms = perms;
+	c->next = avc_callbacks;
+	avc_callbacks = c;
+out:
+	return rc;
+}
+
+static inline int avc_sidcmp(u32 x, u32 y)
+{
+	return (x == y || x == SECSID_WILD || y == SECSID_WILD);
+}
+
+static inline void avc_update_node(u32 event, struct avc_node *node, u32 perms)
+{
+	switch (event) {
+	case AVC_CALLBACK_GRANT:
+		node->ae.avd.allowed |= perms;
+		break;
+	case AVC_CALLBACK_TRY_REVOKE:
+	case AVC_CALLBACK_REVOKE:
+		node->ae.avd.allowed &= ~perms;
+		break;
+	case AVC_CALLBACK_AUDITALLOW_ENABLE:
+		node->ae.avd.auditallow |= perms;
+		break;
+	case AVC_CALLBACK_AUDITALLOW_DISABLE:
+		node->ae.avd.auditallow &= ~perms;
+		break;
+	case AVC_CALLBACK_AUDITDENY_ENABLE:
+		node->ae.avd.auditdeny |= perms;
+		break;
+	case AVC_CALLBACK_AUDITDENY_DISABLE:
+		node->ae.avd.auditdeny &= ~perms;
+		break;
+	}
+}
+
+static int avc_update_cache(u32 event, u32 ssid, u32 tsid,
+                            u16 tclass, u32 perms)
+{
+	struct avc_node *node;
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&avc_lock,flags);
+
+	if (ssid == SECSID_WILD || tsid == SECSID_WILD) {
+		/* apply to all matching nodes */
+		for (i = 0; i < AVC_CACHE_SLOTS; i++) {
+			for (node = avc_cache.slots[i]; node;
+			     node = node->next) {
+				if (avc_sidcmp(ssid, node->ae.ssid) &&
+				    avc_sidcmp(tsid, node->ae.tsid) &&
+				    tclass == node->ae.tclass) {
+					avc_update_node(event,node,perms);
+				}
+			}
+		}
+	} else {
+		/* apply to one node */
+		node = avc_search_node(ssid, tsid, tclass, 0);
+		if (node) {
+			avc_update_node(event,node,perms);
+		}
+	}
+
+	spin_unlock_irqrestore(&avc_lock,flags);
+
+	return 0;
+}
+
+static int avc_control(u32 event, u32 ssid, u32 tsid,
+                       u16 tclass, u32 perms,
+                       u32 seqno, u32 *out_retained)
+{
+	struct avc_callback_node *c;
+	u32 tretained = 0, cretained = 0;
+	int rc = 0;
+	unsigned long flags;
+
+	/*
+	 * try_revoke only removes permissions from the cache
+	 * state if they are not retained by the object manager.
+	 * Hence, try_revoke must wait until after the callbacks have
+	 * been invoked to update the cache state.
+	 */
+	if (event != AVC_CALLBACK_TRY_REVOKE)
+		avc_update_cache(event,ssid,tsid,tclass,perms);
+
+	for (c = avc_callbacks; c; c = c->next)
+	{
+		if ((c->events & event) &&
+		    avc_sidcmp(c->ssid, ssid) &&
+		    avc_sidcmp(c->tsid, tsid) &&
+		    c->tclass == tclass &&
+		    (c->perms & perms)) {
+			cretained = 0;
+			rc = c->callback(event, ssid, tsid, tclass,
+					 (c->perms & perms),
+					 &cretained);
+			if (rc)
+				goto out;
+			tretained |= cretained;
+		}
+	}
+
+	if (event == AVC_CALLBACK_TRY_REVOKE) {
+		/* revoke any unretained permissions */
+		perms &= ~tretained;
+		avc_update_cache(event,ssid,tsid,tclass,perms);
+		*out_retained = tretained;
+	}
+
+	spin_lock_irqsave(&avc_lock,flags);
+	if (seqno > avc_cache.latest_notif)
+		avc_cache.latest_notif = seqno;
+	spin_unlock_irqrestore(&avc_lock,flags);
+
+out:
+	return rc;
+}
+
+/**
+ * avc_ss_grant - Grant previously denied permissions.
+ * @ssid: source security identifier or %SECSID_WILD
+ * @tsid: target security identifier or %SECSID_WILD
+ * @tclass: target security class
+ * @perms: permissions to grant
+ * @seqno: policy sequence number
+ */
+int avc_ss_grant(u32 ssid, u32 tsid, u16 tclass,
+                 u32 perms, u32 seqno)
+{
+	return avc_control(AVC_CALLBACK_GRANT,
+			   ssid, tsid, tclass, perms, seqno, 0);
+}
+
+/**
+ * avc_ss_try_revoke - Try to revoke previously granted permissions.
+ * @ssid: source security identifier or %SECSID_WILD
+ * @tsid: target security identifier or %SECSID_WILD
+ * @tclass: target security class
+ * @perms: permissions to grant
+ * @seqno: policy sequence number
+ * @out_retained: subset of @perms that are retained
+ *
+ * Try to revoke previously granted permissions, but
+ * only if they are not retained as migrated permissions.
+ * Return the subset of permissions that are retained via @out_retained.
+ */
+int avc_ss_try_revoke(u32 ssid, u32 tsid, u16 tclass,
+                      u32 perms, u32 seqno, u32 *out_retained)
+{
+	return avc_control(AVC_CALLBACK_TRY_REVOKE,
+			   ssid, tsid, tclass, perms, seqno, out_retained);
+}
+
+/**
+ * avc_ss_revoke - Revoke previously granted permissions.
+ * @ssid: source security identifier or %SECSID_WILD
+ * @tsid: target security identifier or %SECSID_WILD
+ * @tclass: target security class
+ * @perms: permissions to grant
+ * @seqno: policy sequence number
+ *
+ * Revoke previously granted permissions, even if
+ * they are retained as migrated permissions.
+ */
+int avc_ss_revoke(u32 ssid, u32 tsid, u16 tclass,
+                  u32 perms, u32 seqno)
+{
+	return avc_control(AVC_CALLBACK_REVOKE,
+			   ssid, tsid, tclass, perms, seqno, 0);
+}
+
+/**
+ * avc_ss_reset - Flush the cache and revalidate migrated permissions.
+ * @seqno: policy sequence number
+ */
+int avc_ss_reset(u32 seqno)
+{
+	struct avc_callback_node *c;
+	int i, rc = 0;
+	struct avc_node *node, *tmp;
+	unsigned long flags;
+
+	avc_hash_eval("reset");
+
+	spin_lock_irqsave(&avc_lock,flags);
+
+	for (i = 0; i < AVC_CACHE_SLOTS; i++) {
+		node = avc_cache.slots[i];
+		while (node) {
+			tmp = node;
+			node = node->next;
+			tmp->ae.ssid = tmp->ae.tsid = SECSID_NULL;
+			tmp->ae.tclass = SECCLASS_NULL;
+			tmp->ae.avd.allowed = tmp->ae.avd.decided = 0;
+			tmp->ae.avd.auditallow = tmp->ae.avd.auditdeny = 0;
+			tmp->ae.used = 0;
+			tmp->next = avc_node_freelist;
+			avc_node_freelist = tmp;
+			avc_cache.active_nodes--;
+		}
+		avc_cache.slots[i] = 0;
+	}
+	avc_cache.lru_hint = 0;
+
+	spin_unlock_irqrestore(&avc_lock,flags);
+
+	for (i = 0; i < AVC_NSTATS; i++)
+		avc_cache_stats[i] = 0;
+
+	for (c = avc_callbacks; c; c = c->next) {
+		if (c->events & AVC_CALLBACK_RESET) {
+			rc = c->callback(AVC_CALLBACK_RESET,
+					 0, 0, 0, 0, 0);
+			if (rc)
+				goto out;
+		}
+	}
+
+	spin_lock_irqsave(&avc_lock,flags);
+	if (seqno > avc_cache.latest_notif)
+		avc_cache.latest_notif = seqno;
+	spin_unlock_irqrestore(&avc_lock,flags);
+out:
+	return rc;
+}
+
+/**
+ * avc_ss_set_auditallow - Enable or disable auditing of granted permissions.
+ * @ssid: source security identifier or %SECSID_WILD
+ * @tsid: target security identifier or %SECSID_WILD
+ * @tclass: target security class
+ * @perms: permissions to grant
+ * @seqno: policy sequence number
+ * @enable: enable flag.
+ */
+int avc_ss_set_auditallow(u32 ssid, u32 tsid, u16 tclass,
+                          u32 perms, u32 seqno, u32 enable)
+{
+	if (enable)
+		return avc_control(AVC_CALLBACK_AUDITALLOW_ENABLE,
+				   ssid, tsid, tclass, perms, seqno, 0);
+	else
+		return avc_control(AVC_CALLBACK_AUDITALLOW_DISABLE,
+				   ssid, tsid, tclass, perms, seqno, 0);
+}
+
+/**
+ * avc_ss_set_auditdeny - Enable or disable auditing of denied permissions.
+ * @ssid: source security identifier or %SECSID_WILD
+ * @tsid: target security identifier or %SECSID_WILD
+ * @tclass: target security class
+ * @perms: permissions to grant
+ * @seqno: policy sequence number
+ * @enable: enable flag.
+ */
+int avc_ss_set_auditdeny(u32 ssid, u32 tsid, u16 tclass,
+                         u32 perms, u32 seqno, u32 enable)
+{
+	if (enable)
+		return avc_control(AVC_CALLBACK_AUDITDENY_ENABLE,
+				   ssid, tsid, tclass, perms, seqno, 0);
+	else
+		return avc_control(AVC_CALLBACK_AUDITDENY_DISABLE,
+				   ssid, tsid, tclass, perms, seqno, 0);
+}
+
+/**
+ * avc_has_perm_noaudit - Check permissions but perform no auditing.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ * @requested: requested permissions, interpreted based on @tclass
+ * @aeref:  AVC entry reference
+ * @avd: access vector decisions
+ *
+ * Check the AVC to determine whether the @requested permissions are granted
+ * for the SID pair (@ssid, @tsid), interpreting the permissions
+ * based on @tclass, and call the security server on a cache miss to obtain
+ * a new decision and add it to the cache.  Update @aeref to refer to an AVC
+ * entry with the resulting decisions, and return a copy of the decisions
+ * in @avd.  Return %0 if all @requested permissions are granted,
+ * -%EACCES if any permissions are denied, or another -errno upon
+ * other errors.  This function is typically called by avc_has_perm(),
+ * but may also be called directly to separate permission checking from
+ * auditing, e.g. in cases where a lock must be held for the check but
+ * should be released for the auditing.
+ */
+int avc_has_perm_noaudit(u32 ssid, u32 tsid,
+                         u16 tclass, u32 requested,
+                         struct avc_entry_ref *aeref, struct av_decision *avd)
+{
+	struct avc_entry *ae;
+	int rc = 0;
+	unsigned long flags;
+	struct avc_entry entry;
+	u32 denied;
+	struct avc_entry_ref ref;
+
+	if (!aeref) {
+		avc_entry_ref_init(&ref);
+		aeref = &ref;
+	}
+
+	spin_lock_irqsave(&avc_lock, flags);
+	avc_cache_stats_incr(AVC_ENTRY_LOOKUPS);
+	ae = aeref->ae;
+	if (ae) {
+		if (ae->ssid == ssid &&
+		    ae->tsid == tsid &&
+		    ae->tclass == tclass &&
+		    ((ae->avd.decided & requested) == requested)) {
+			avc_cache_stats_incr(AVC_ENTRY_HITS);
+			ae->used = 1;
+		} else {
+			avc_cache_stats_incr(AVC_ENTRY_DISCARDS);
+			ae = 0;
+		}
+	}
+
+	if (!ae) {
+		avc_cache_stats_incr(AVC_ENTRY_MISSES);
+		rc = avc_lookup(ssid, tsid, tclass, requested, aeref);
+		if (rc) {
+			spin_unlock_irqrestore(&avc_lock,flags);
+			rc = security_compute_av(ssid,tsid,tclass,requested,&entry.avd);
+			if (rc)
+				goto out;
+			spin_lock_irqsave(&avc_lock, flags);
+			rc = avc_insert(ssid,tsid,tclass,&entry,aeref);
+			if (rc) {
+				spin_unlock_irqrestore(&avc_lock,flags);
+				goto out;
+			}
+		}
+		ae = aeref->ae;
+	}
+
+	if (avd)
+		memcpy(avd, &ae->avd, sizeof(*avd));
+
+	denied = requested & ~(ae->avd.allowed);
+
+	if (!requested || denied) {
+		if (selinux_enforcing) {
+			spin_unlock_irqrestore(&avc_lock,flags);
+			rc = -EACCES;
+			goto out;
+		} else {
+			ae->avd.allowed |= requested;
+			spin_unlock_irqrestore(&avc_lock,flags);
+			goto out;
+		}
+	}
+
+	spin_unlock_irqrestore(&avc_lock,flags);
+out:
+	return rc;
+}
+
+/**
+ * avc_has_perm - Check permissions and perform any appropriate auditing.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ * @requested: requested permissions, interpreted based on @tclass
+ * @aeref:  AVC entry reference
+ * @auditdata: auxiliary audit data
+ *
+ * Check the AVC to determine whether the @requested permissions are granted
+ * for the SID pair (@ssid, @tsid), interpreting the permissions
+ * based on @tclass, and call the security server on a cache miss to obtain
+ * a new decision and add it to the cache.  Update @aeref to refer to an AVC
+ * entry with the resulting decisions.  Audit the granting or denial of
+ * permissions in accordance with the policy.  Return %0 if all @requested
+ * permissions are granted, -%EACCES if any permissions are denied, or
+ * another -errno upon other errors.
+ */
+int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,
+                 u32 requested, struct avc_entry_ref *aeref,
+                 struct avc_audit_data *auditdata)
+{
+	struct av_decision avd;
+	int rc;
+
+	rc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, aeref, &avd);
+	avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata);
+	return rc;
+}
+
+static int __init avc_log_level_setup(char *str)
+{
+	avc_log_level = simple_strtol(str, NULL, 0);
+	if (avc_log_level > 7)
+		avc_log_level = 7;
+	return 1;
+}
+
+__setup("avc_log_level=", avc_log_level_setup);
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/Config.in 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/Config.in
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/Config.in	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/Config.in	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,10 @@
+bool 'NSA SELinux Support' CONFIG_SECURITY_SELINUX
+if [ "$CONFIG_SECURITY_SELINUX" != "n" ]; then
+   bool '  NSA SELinux boot parameter' CONFIG_SECURITY_SELINUX_BOOTPARAM
+   bool '  NSA SELinux Development Support' CONFIG_SECURITY_SELINUX_DEVELOP 
+   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+      bool '  NSA SELinux MLS policy (EXPERIMENTAL)' CONFIG_SECURITY_SELINUX_MLS
+   fi
+fi
+
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/hooks.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/hooks.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/hooks.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/hooks.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,3401 @@
+/*
+ *  NSA Security-Enhanced Linux (SELinux) security module
+ *
+ *  This file contains the SELinux hook function implementations.
+ *
+ *  Authors:  Stephen Smalley, <sds@epoch.ncsc.mil>
+ *            Chris Vance, <cvance@nai.com>
+ *            Wayne Salamon, <wsalamon@nai.com>
+ *            James Morris <jmorris@redhat.com>
+ *
+ *  Copyright (C) 2001,2002 Networks Associates Technology, Inc.
+ *  Copyright (C) 2003 Red Hat, Inc., James Morris <jmorris@redhat.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License version 2,
+ *      as published by the Free Software Foundation.
+ */
+
+#define XATTR_SECURITY_PREFIX "security."
+#define XATTR_SELINUX_SUFFIX "selinux"
+#define XATTR_NAME_SELINUX XATTR_SECURITY_PREFIX XATTR_SELINUX_SUFFIX
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/security.h>
+#include <linux/xattr.h>
+#include <linux/capability.h>
+#include <linux/unistd.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp_lock.h>
+#include <linux/spinlock.h>
+#include <linux/file.h>
+#include <linux/mount.h>
+#include <linux/ext2_fs.h>
+#include <linux/proc_fs.h>
+#include <linux/kd.h>
+#include <net/icmp.h>
+#include <net/ip.h>		/* for sysctl_local_port_range[] */
+#include <net/tcp.h>		/* struct or_callable used in sock_rcv_skb */
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+#include <asm/ioctls.h>
+#include <linux/bitops.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>	/* for network interface checks */
+#include <linux/netlink.h>
+#include <linux/tcp.h>
+#include <linux/quota.h>
+#include <linux/un.h>		/* for Unix socket types */
+#include <net/af_unix.h>	/* for Unix socket types */
+
+#include "avc.h"
+#include "objsec.h"
+#include "compatibility.h"
+
+#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
+int selinux_enforcing = 0;
+
+static int __init enforcing_setup(char *str)
+{
+	selinux_enforcing = simple_strtol(str,NULL,0);
+	return 1;
+}
+__setup("enforcing=", enforcing_setup);
+#endif
+
+#ifdef CONFIG_SECURITY_SELINUX_BOOTPARAM
+int selinux_enabled = 1;
+
+static int __init selinux_enabled_setup(char *str)
+{
+	selinux_enabled = simple_strtol(str, NULL, 0);
+	return 1;
+}
+__setup("selinux=", selinux_enabled_setup);
+#endif
+
+/* Original (dummy) security module. */
+static struct security_operations *original_ops = NULL;
+
+/* Minimal support for a secondary security module,
+   just to allow the use of the dummy or capability modules.
+   The owlsm module can alternatively be used as a secondary
+   module as long as CONFIG_OWLSM_FD is not enabled. */
+static struct security_operations *secondary_ops = NULL;
+
+/* Lists of inode and superblock security structures initialized
+   before the policy was loaded. */
+static LIST_HEAD(superblock_security_head);
+static spinlock_t sb_security_lock = SPIN_LOCK_UNLOCKED;
+
+/* Allocate and free functions for each kind of security blob. */
+
+static int task_alloc_security(struct task_struct *task)
+{
+	struct task_security_struct *tsec;
+
+	tsec = kmalloc(sizeof(struct task_security_struct), GFP_KERNEL);
+	if (!tsec)
+		return -ENOMEM;
+
+	memset(tsec, 0, sizeof(struct task_security_struct));
+	tsec->magic = SELINUX_MAGIC;
+	tsec->task = task;
+	tsec->osid = tsec->sid = SECINITSID_UNLABELED;
+	task->security = tsec;
+
+	return 0;
+}
+
+static void task_free_security(struct task_struct *task)
+{
+	struct task_security_struct *tsec = task->security;
+
+	if (!tsec || tsec->magic != SELINUX_MAGIC)
+		return;
+
+	task->security = NULL;
+	kfree(tsec);
+}
+
+static int inode_alloc_security(struct inode *inode)
+{
+	struct task_security_struct *tsec = current->security;
+	struct inode_security_struct *isec;
+
+	isec = kmalloc(sizeof(struct inode_security_struct), GFP_KERNEL);
+	if (!isec)
+		return -ENOMEM;
+
+	memset(isec, 0, sizeof(struct inode_security_struct));
+	init_MUTEX(&isec->sem);
+	INIT_LIST_HEAD(&isec->list);
+	isec->magic = SELINUX_MAGIC;
+	isec->inode = inode;
+	isec->sid = SECINITSID_UNLABELED;
+	isec->sclass = SECCLASS_FILE;
+	if (tsec && tsec->magic == SELINUX_MAGIC)
+		isec->task_sid = tsec->sid;
+	else
+		isec->task_sid = SECINITSID_UNLABELED;
+	inode->i_security = isec;
+
+	return 0;
+}
+
+static void inode_free_security(struct inode *inode)
+{
+	struct inode_security_struct *isec = inode->i_security;
+	struct superblock_security_struct *sbsec = inode->i_sb->s_security;
+
+	if (!isec || isec->magic != SELINUX_MAGIC)
+		return;
+
+	spin_lock(&sbsec->isec_lock);
+	if (!list_empty(&isec->list))
+		list_del_init(&isec->list);
+	spin_unlock(&sbsec->isec_lock);
+
+	inode->i_security = NULL;
+	kfree(isec);
+}
+
+static int file_alloc_security(struct file *file)
+{
+	struct task_security_struct *tsec = current->security;
+	struct file_security_struct *fsec;
+
+	fsec = kmalloc(sizeof(struct file_security_struct), GFP_ATOMIC);
+	if (!fsec)
+		return -ENOMEM;
+
+	memset(fsec, 0, sizeof(struct file_security_struct));
+	fsec->magic = SELINUX_MAGIC;
+	fsec->file = file;
+	if (tsec && tsec->magic == SELINUX_MAGIC) {
+		fsec->sid = tsec->sid;
+		fsec->fown_sid = tsec->sid;
+	} else {
+		fsec->sid = SECINITSID_UNLABELED;
+		fsec->fown_sid = SECINITSID_UNLABELED;
+	}
+	file->f_security = fsec;
+
+	return 0;
+}
+
+static void file_free_security(struct file *file)
+{
+	struct file_security_struct *fsec = file->f_security;
+
+	if (!fsec || fsec->magic != SELINUX_MAGIC)
+		return;
+
+	file->f_security = NULL;
+	kfree(fsec);
+}
+
+static int superblock_alloc_security(struct super_block *sb)
+{
+	struct superblock_security_struct *sbsec;
+
+	sbsec = kmalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);
+	if (!sbsec)
+		return -ENOMEM;
+
+	memset(sbsec, 0, sizeof(struct superblock_security_struct));
+	init_MUTEX(&sbsec->sem);
+	INIT_LIST_HEAD(&sbsec->list);
+	INIT_LIST_HEAD(&sbsec->isec_head);
+	spin_lock_init(&sbsec->isec_lock);
+	sbsec->magic = SELINUX_MAGIC;
+	sbsec->sb = sb;
+	sbsec->sid = SECINITSID_UNLABELED;
+	sb->s_security = sbsec;
+
+	return 0;
+}
+
+static void superblock_free_security(struct super_block *sb)
+{
+	struct superblock_security_struct *sbsec = sb->s_security;
+
+	if (!sbsec || sbsec->magic != SELINUX_MAGIC)
+		return;
+
+	spin_lock(&sb_security_lock);
+	if (!list_empty(&sbsec->list))
+		list_del_init(&sbsec->list);
+	spin_unlock(&sb_security_lock);
+
+	sb->s_security = NULL;
+	kfree(sbsec);
+}
+
+/* The security server must be initialized before
+   any labeling or access decisions can be provided. */
+extern int ss_initialized;
+
+/* The file system's label must be initialized prior to use. */
+
+static char *labeling_behaviors[5] = {
+	"uses xattr",
+	"uses transition SIDs",
+	"uses task SIDs",
+	"uses genfs_contexts",
+	"not configured for labeling"
+};
+
+static int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry);
+
+static inline int inode_doinit(struct inode *inode)
+{
+	return inode_doinit_with_dentry(inode, NULL);
+}
+
+static int superblock_doinit(struct super_block *sb)
+{
+	struct superblock_security_struct *sbsec = sb->s_security;
+	struct dentry *root = sb->s_root;
+	struct inode *inode = root->d_inode;
+	int rc = 0;
+
+	down(&sbsec->sem);
+	if (sbsec->initialized)
+		goto out;
+
+	if (!ss_initialized) {
+		/* Defer initialization until selinux_complete_init,
+		   after the initial policy is loaded and the security
+		   server is ready to handle calls. */
+		spin_lock(&sb_security_lock);
+		if (list_empty(&sbsec->list))
+			list_add(&sbsec->list, &superblock_security_head);
+		spin_unlock(&sb_security_lock);
+		goto out;
+	}
+
+	/* Determine the labeling behavior to use for this filesystem type. */
+	rc = security_fs_use(sb->s_type->name, &sbsec->behavior, &sbsec->sid);
+	if (rc) {
+		printk(KERN_WARNING "%s:  security_fs_use(%s) returned %d\n",
+		       __FUNCTION__, sb->s_type->name, rc);
+		goto out;
+	}
+
+	if (sbsec->behavior == SECURITY_FS_USE_XATTR) {
+		/* Make sure that the xattr handler exists and that no
+		   error other than -ENODATA is returned by getxattr on
+		   the root directory.  -ENODATA is ok, as this may be
+		   the first boot of the SELinux kernel before we have
+		   assigned xattr values to the filesystem. */
+		if (!inode->i_op->getxattr) {
+			printk(KERN_WARNING "SELinux: (dev %02x:%02x, type %s) "
+			       "has no xattr support\n",
+			       MAJOR(sb->s_dev),
+			       MINOR(sb->s_dev),
+			       sb->s_type->name);
+			rc = -EOPNOTSUPP;
+			goto out;
+		}
+		rc = inode->i_op->getxattr(root, XATTR_NAME_SELINUX, NULL, 0);
+		if (rc < 0 && rc != -ENODATA) {
+			if (rc == -EOPNOTSUPP)
+				printk(KERN_WARNING "SELinux: "
+				       "(dev %02x:%02x, type %s) "
+				       "has no security xattr handler\n",
+				       MAJOR(sb->s_dev),
+				       MINOR(sb->s_dev),
+				       sb->s_type->name);
+			else
+				printk(KERN_WARNING "SELinux: (dev %02x:%02x, "
+				       "type %s) getxattr errno %d\n",
+				       MAJOR(sb->s_dev),
+				       MINOR(sb->s_dev),
+				       sb->s_type->name, -rc);
+			goto out;
+		}
+	}
+
+	if (strcmp(sb->s_type->name, "proc") == 0)
+		sbsec->proc = 1;
+
+	sbsec->initialized = 1;
+
+ 	if (sbsec->behavior > ARRAY_SIZE(labeling_behaviors)) { 
+		printk(KERN_INFO "SELinux: initialized (dev %02x:%02x, type %s), unknown behavior\n",
+		       MAJOR(sb->s_dev),
+		       MINOR(sb->s_dev),
+		       sb->s_type->name);
+	} else {
+		printk(KERN_INFO "SELinux: initialized (dev %02x:%02x, type %s), %s\n",
+		       MAJOR(sb->s_dev),
+		       MINOR(sb->s_dev),
+		       sb->s_type->name,
+		       labeling_behaviors[sbsec->behavior-1]);
+	}
+
+	/* Initialize the root inode. */
+	rc = inode_doinit_with_dentry(sb->s_root->d_inode, sb->s_root);
+
+	/* Initialize any other inodes associated with the superblock, e.g.
+	   inodes created prior to initial policy load or inodes created
+	   during get_sb by a pseudo filesystem that directly 
+	   populates itself. */
+	spin_lock(&sbsec->isec_lock);
+next_inode:
+	if (!list_empty(&sbsec->isec_head)) {
+		struct inode_security_struct *isec =
+				list_entry(sbsec->isec_head.next,
+				           struct inode_security_struct, list);
+		struct inode *inode = isec->inode;
+		spin_unlock(&sbsec->isec_lock);
+		inode = igrab(inode);
+		if (inode) {
+			inode_doinit(inode);
+			iput(inode);
+		}
+		spin_lock(&sbsec->isec_lock);
+		list_del_init(&isec->list);
+		goto next_inode;
+	}
+	spin_unlock(&sbsec->isec_lock);
+out:
+	up(&sbsec->sem);
+	return rc;
+}
+
+static inline u16 inode_mode_to_security_class(umode_t mode)
+{
+	switch (mode & S_IFMT) {
+	case S_IFSOCK:
+		return SECCLASS_SOCK_FILE;
+	case S_IFLNK:
+		return SECCLASS_LNK_FILE;
+	case S_IFREG:
+		return SECCLASS_FILE;
+	case S_IFBLK:
+		return SECCLASS_BLK_FILE;
+	case S_IFDIR:
+		return SECCLASS_DIR;
+	case S_IFCHR:
+		return SECCLASS_CHR_FILE;
+	case S_IFIFO:
+		return SECCLASS_FIFO_FILE;
+
+	}
+
+	return SECCLASS_FILE;
+}
+
+static inline u16 socket_type_to_security_class(int family, int type)
+{
+	switch (family) {
+	case PF_UNIX:
+		switch (type) {
+		case SOCK_STREAM:
+			return SECCLASS_UNIX_STREAM_SOCKET;
+		case SOCK_DGRAM:
+			return SECCLASS_UNIX_DGRAM_SOCKET;
+		}
+	case PF_INET:
+	case PF_INET6:
+		switch (type) {
+		case SOCK_STREAM:
+			return SECCLASS_TCP_SOCKET;
+		case SOCK_DGRAM:
+			return SECCLASS_UDP_SOCKET;
+		case SOCK_RAW:
+			return SECCLASS_RAWIP_SOCKET;
+		}
+	case PF_NETLINK:
+		return SECCLASS_NETLINK_SOCKET;
+	case PF_PACKET:
+		return SECCLASS_PACKET_SOCKET;
+	case PF_KEY:
+		return SECCLASS_KEY_SOCKET;
+	}
+
+	return SECCLASS_SOCKET;
+}
+
+#ifdef CONFIG_PROC_FS
+static int selinux_proc_get_sid(struct proc_dir_entry *de,
+				u16 tclass,
+				u32 *sid)
+{
+	int buflen, rc;
+	char *buffer, *path, *end;
+
+	buffer = (char*)__get_free_page(GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	buflen = PAGE_SIZE;
+	end = buffer+buflen;
+	*--end = '\0';
+	buflen--;
+	path = end-1;
+	*path = '/';
+	while (de && de != de->parent) {
+		buflen -= de->namelen + 1;
+		if (buflen < 0)
+			break;
+		end -= de->namelen;
+		memcpy(end, de->name, de->namelen);
+		*--end = '/';
+		path = end;
+		de = de->parent;
+	}
+	rc = security_genfs_sid("proc", path, tclass, sid);
+	free_page((unsigned long)buffer);
+	return rc;
+}
+#else
+static int selinux_proc_get_sid(struct proc_dir_entry *de,
+				u16 tclass,
+				u32 *sid)
+{
+	return -EINVAL;
+}
+#endif
+
+/* The inode's security attributes must be initialized before first use. */
+static int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry)
+{
+	struct superblock_security_struct *sbsec = NULL;
+	struct inode_security_struct *isec = inode->i_security;
+	u32 sid;
+	struct dentry *dentry;
+#define INITCONTEXTLEN 255
+	char *context = NULL;
+	unsigned len = 0;
+	int rc = 0;
+	int hold_sem = 0;
+
+	if (isec->initialized)
+		goto out;
+
+	down(&isec->sem);
+	hold_sem = 1;
+	if (isec->initialized)
+		goto out;
+
+	sbsec = inode->i_sb->s_security;
+	if (!sbsec->initialized) {
+		/* Defer initialization until selinux_complete_init,
+		   after the initial policy is loaded and the security
+		   server is ready to handle calls. */
+		spin_lock(&sbsec->isec_lock);
+		if (list_empty(&isec->list))
+			list_add(&isec->list, &sbsec->isec_head);
+		spin_unlock(&sbsec->isec_lock);
+		goto out;
+	}
+
+	switch (sbsec->behavior) {
+	case SECURITY_FS_USE_XATTR:
+		if (!inode->i_op->getxattr) {
+			isec->sid = SECINITSID_FILE;
+			break;
+		}
+
+		/* Need a dentry, since the xattr API requires one.
+		   Life would be simpler if we could just pass the inode. */
+		if (opt_dentry) {
+			/* Called from d_instantiate or d_splice_alias. */
+			dentry = dget(opt_dentry);
+		} else {
+			/* Called from selinux_complete_init, try to find a dentry. */
+			dentry = d_find_alias(inode);
+		}
+		if (!dentry) {
+			printk(KERN_WARNING "%s:  no dentry for dev=%02x:%02x "
+			       "ino=%ld\n",
+			       __FUNCTION__,
+			       MAJOR(inode->i_dev),
+			       MINOR(inode->i_dev),
+			       inode->i_ino);
+			goto out;
+		}
+
+		len = INITCONTEXTLEN;
+		context = kmalloc(len, GFP_KERNEL);
+		if (!context) {
+			rc = -ENOMEM;
+			dput(dentry);
+			goto out;
+		}
+		rc = inode->i_op->getxattr(dentry, XATTR_NAME_SELINUX,
+					   context, len);
+		if (rc == -ERANGE) {
+			/* Need a larger buffer.  Query for the right size. */
+			rc = inode->i_op->getxattr(dentry, XATTR_NAME_SELINUX,
+						   NULL, 0);
+			if (rc < 0) {
+				dput(dentry);
+				goto out;
+			}
+			kfree(context);
+			len = rc;
+			context = kmalloc(len, GFP_KERNEL);
+			if (!context) {
+				rc = -ENOMEM;
+				dput(dentry);
+				goto out;
+			}
+			rc = inode->i_op->getxattr(dentry,
+						   XATTR_NAME_SELINUX,
+						   context, len);
+		}
+		dput(dentry);
+		if (rc < 0) {
+			if (rc != -ENODATA) {
+				printk(KERN_WARNING "%s:  getxattr returned %d "
+				       "for dev=%02x:%02x ino=%ld\n", 
+				       __FUNCTION__, -rc,
+				       MAJOR(inode->i_dev),
+				       MINOR(inode->i_dev),
+				       inode->i_ino);
+				kfree(context);
+				goto out;
+			}
+			/* Map ENODATA to the default file SID */
+			sid = SECINITSID_FILE;
+			rc = 0;
+		} else {
+			rc = security_context_to_sid(context, rc, &sid);
+			if (rc) {
+				printk(KERN_WARNING "%s:  context_to_sid(%s) "
+				       "returned %d for dev=%02x:%02x "
+				       "ino=%ld\n", 
+				       __FUNCTION__, context, -rc,
+				       MAJOR(inode->i_dev),
+				       MINOR(inode->i_dev),
+				       inode->i_ino);
+				kfree(context);
+				goto out;
+			}
+		}
+		kfree(context);
+		isec->sid = sid;
+		break;
+	case SECURITY_FS_USE_TASK:
+		isec->sid = isec->task_sid;
+		break;
+	case SECURITY_FS_USE_TRANS:
+		/* Default to the fs SID. */
+		isec->sid = sbsec->sid;
+
+		/* Try to obtain a transition SID. */
+		isec->sclass = inode_mode_to_security_class(inode->i_mode);
+		rc = security_transition_sid(isec->task_sid,
+					     sbsec->sid,
+					     isec->sclass,
+					     &sid);
+		if (rc)
+			goto out;
+		isec->sid = sid;
+		break;
+	default:
+		/* Default to the fs SID. */
+		isec->sid = sbsec->sid;
+
+		if (sbsec->proc) {
+			struct proc_inode *proci = PROC_I(inode);
+			if (proci->pde) {
+				isec->sclass = inode_mode_to_security_class(inode->i_mode);
+				rc = selinux_proc_get_sid(proci->pde,
+							  isec->sclass,
+							  &sid);
+				if (rc)
+					goto out;
+				isec->sid = sid;
+			}
+		}
+		break;
+	}
+
+	isec->initialized = 1;
+
+out:
+	if (inode->i_sock) {
+		struct socket *sock = SOCKET_I(inode);
+		if (sock->sk) {
+			isec->sclass = socket_type_to_security_class(sock->sk->sk_family,
+			                                             sock->sk->sk_type);
+		} else {
+			isec->sclass = SECCLASS_SOCKET;
+		}
+	} else {
+		isec->sclass = inode_mode_to_security_class(inode->i_mode);
+	}
+
+	if (hold_sem)
+		up(&isec->sem);
+	return rc;
+}
+
+/* Convert a Linux signal to an access vector. */
+static inline u32 signal_to_av(int sig)
+{
+	u32 perm = 0;
+
+	switch (sig) {
+	case SIGCHLD:
+		/* Commonly granted from child to parent. */
+		perm = PROCESS__SIGCHLD;
+		break;
+	case SIGKILL:
+		/* Cannot be caught or ignored */
+		perm = PROCESS__SIGKILL;
+		break;
+	case SIGSTOP:
+		/* Cannot be caught or ignored */
+		perm = PROCESS__SIGSTOP;
+		break;
+	default:
+		/* All other signals. */
+		perm = PROCESS__SIGNAL;
+		break;
+	}
+
+	return perm;
+}
+
+/* Check permission betweeen a pair of tasks, e.g. signal checks,
+   fork check, ptrace check, etc. */
+int task_has_perm(struct task_struct *tsk1,
+		  struct task_struct *tsk2,
+		  u32 perms)
+{
+	struct task_security_struct *tsec1, *tsec2;
+
+	tsec1 = tsk1->security;
+	tsec2 = tsk2->security;
+	return avc_has_perm(tsec1->sid, tsec2->sid,
+			    SECCLASS_PROCESS, perms, &tsec2->avcr, NULL);
+}
+
+/* Check whether a task is allowed to use a capability. */
+int task_has_capability(struct task_struct *tsk,
+			int cap)
+{
+	struct task_security_struct *tsec;
+	struct avc_audit_data ad;
+
+	tsec = tsk->security;
+
+	AVC_AUDIT_DATA_INIT(&ad,CAP);
+	ad.tsk = tsk;
+	ad.u.cap = cap;
+
+	return avc_has_perm(tsec->sid, tsec->sid,
+			    SECCLASS_CAPABILITY, CAP_TO_MASK(cap), NULL, &ad);
+}
+
+/* Check whether a task is allowed to use a system operation. */
+int task_has_system(struct task_struct *tsk,
+		    u32 perms)
+{
+	struct task_security_struct *tsec;
+
+	tsec = tsk->security;
+
+	return avc_has_perm(tsec->sid, SECINITSID_KERNEL,
+			    SECCLASS_SYSTEM, perms, NULL, NULL);
+}
+
+/* Check whether a task has a particular permission to an inode.
+   The 'aeref' parameter is optional and allows other AVC
+   entry references to be passed (e.g. the one in the struct file).
+   The 'adp' parameter is optional and allows other audit
+   data to be passed (e.g. the dentry). */
+int inode_has_perm(struct task_struct *tsk,
+		   struct inode *inode,
+		   u32 perms,
+		   struct avc_entry_ref *aeref,
+		   struct avc_audit_data *adp)
+{
+	struct task_security_struct *tsec;
+	struct inode_security_struct *isec;
+	struct avc_audit_data ad;
+
+	tsec = tsk->security;
+	isec = inode->i_security;
+
+	if (!adp) {
+		adp = &ad;
+		AVC_AUDIT_DATA_INIT(&ad, FS);
+		ad.u.fs.inode = inode;
+	}
+
+	return avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			    perms, aeref ? aeref : &isec->avcr, adp);
+}
+
+/* Same as inode_has_perm, but pass explicit audit data containing
+   the dentry to help the auditing code to more easily generate the
+   pathname if needed. */
+static inline int dentry_has_perm(struct task_struct *tsk,
+				  struct vfsmount *mnt,
+				  struct dentry *dentry,
+				  u32 av)
+{
+	struct inode *inode = dentry->d_inode;
+	struct avc_audit_data ad;
+	AVC_AUDIT_DATA_INIT(&ad,FS);
+	ad.u.fs.mnt = mnt;
+	ad.u.fs.dentry = dentry;
+	return inode_has_perm(tsk, inode, av, NULL, &ad);
+}
+
+/* Check whether a task can use an open file descriptor to
+   access an inode in a given way.  Check access to the
+   descriptor itself, and then use dentry_has_perm to
+   check a particular permission to the file.
+   Access to the descriptor is implicitly granted if it
+   has the same SID as the process.  If av is zero, then
+   access to the file is not checked, e.g. for cases
+   where only the descriptor is affected like seek. */
+static inline int file_has_perm(struct task_struct *tsk,
+				struct file *file,
+				u32 av)
+{
+	struct task_security_struct *tsec = tsk->security;
+	struct file_security_struct *fsec = file->f_security;
+	struct vfsmount *mnt = file->f_vfsmnt;
+	struct dentry *dentry = file->f_dentry;
+	struct inode *inode = dentry->d_inode;
+	struct avc_audit_data ad;
+	int rc;
+
+	AVC_AUDIT_DATA_INIT(&ad, FS);
+	ad.u.fs.mnt = mnt;
+	ad.u.fs.dentry = dentry;
+
+	if (tsec->sid != fsec->sid) {
+		rc = avc_has_perm(tsec->sid, fsec->sid,
+				  SECCLASS_FD,
+				  FD__USE,
+				  &fsec->avcr, &ad);
+		if (rc)
+			return rc;
+	}
+
+	/* av is zero if only checking access to the descriptor. */
+	if (av)
+		return inode_has_perm(tsk, inode, av, &fsec->inode_avcr, &ad);
+
+	return 0;
+}
+
+/* Check whether a task can create a file. */
+static int may_create(struct inode *dir,
+		      struct dentry *dentry,
+		      u16 tclass)
+{
+	struct task_security_struct *tsec;
+	struct inode_security_struct *dsec;
+	struct superblock_security_struct *sbsec;
+	u32 newsid;
+	struct avc_audit_data ad;
+	int rc;
+
+	tsec = current->security;
+	dsec = dir->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad, FS);
+	ad.u.fs.dentry = dentry;
+
+	rc = avc_has_perm(tsec->sid, dsec->sid, SECCLASS_DIR,
+			  DIR__ADD_NAME | DIR__SEARCH,
+			  &dsec->avcr, &ad);
+	if (rc)
+		return rc;
+
+	if (tsec->create_sid) {
+		newsid = tsec->create_sid;
+	} else {
+		rc = security_transition_sid(tsec->sid, dsec->sid, tclass,
+					     &newsid);
+		if (rc)
+			return rc;
+	}
+
+	rc = avc_has_perm(tsec->sid, newsid, tclass, FILE__CREATE, NULL, &ad);
+	if (rc)
+		return rc;
+
+	sbsec = dir->i_sb->s_security;
+
+	return avc_has_perm(newsid, sbsec->sid,
+			    SECCLASS_FILESYSTEM,
+			    FILESYSTEM__ASSOCIATE, NULL, &ad);
+}
+
+#define MAY_LINK   0
+#define MAY_UNLINK 1
+#define MAY_RMDIR  2
+
+/* Check whether a task can link, unlink, or rmdir a file/directory. */
+static int may_link(struct inode *dir,
+		    struct dentry *dentry,
+		    int kind)
+
+{
+	struct task_security_struct *tsec;
+	struct inode_security_struct *dsec, *isec;
+	struct avc_audit_data ad;
+	u32 av;
+	int rc;
+
+	tsec = current->security;
+	dsec = dir->i_security;
+	isec = dentry->d_inode->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad, FS);
+	ad.u.fs.dentry = dentry;
+
+	av = DIR__SEARCH;
+	av |= (kind ? DIR__REMOVE_NAME : DIR__ADD_NAME);
+	rc = avc_has_perm(tsec->sid, dsec->sid, SECCLASS_DIR,
+			  av, &dsec->avcr, &ad);
+	if (rc)
+		return rc;
+
+	switch (kind) {
+	case MAY_LINK:
+		av = FILE__LINK;
+		break;
+	case MAY_UNLINK:
+		av = FILE__UNLINK;
+		break;
+	case MAY_RMDIR:
+		av = DIR__RMDIR;
+		break;
+	default:
+		printk(KERN_WARNING "may_link:  unrecognized kind %d\n", kind);
+		return 0;
+	}
+
+	rc = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			  av, &isec->avcr, &ad);
+	return rc;
+}
+
+static inline int may_rename(struct inode *old_dir,
+			     struct dentry *old_dentry,
+			     struct inode *new_dir,
+			     struct dentry *new_dentry)
+{
+	struct task_security_struct *tsec;
+	struct inode_security_struct *old_dsec, *new_dsec, *old_isec, *new_isec;
+	struct avc_audit_data ad;
+	u32 av;
+	int old_is_dir, new_is_dir;
+	int rc;
+
+	tsec = current->security;
+	old_dsec = old_dir->i_security;
+	old_isec = old_dentry->d_inode->i_security;
+	old_is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
+	new_dsec = new_dir->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad, FS);
+
+	ad.u.fs.dentry = old_dentry;
+	rc = avc_has_perm(tsec->sid, old_dsec->sid, SECCLASS_DIR,
+			  DIR__REMOVE_NAME | DIR__SEARCH,
+			  &old_dsec->avcr, &ad);
+	if (rc)
+		return rc;
+	rc = avc_has_perm(tsec->sid, old_isec->sid,
+			  old_isec->sclass,
+			  FILE__RENAME,
+			  &old_isec->avcr, &ad);
+	if (rc)
+		return rc;
+	if (old_is_dir && new_dir != old_dir) {
+		rc = avc_has_perm(tsec->sid, old_isec->sid,
+				  old_isec->sclass,
+				  DIR__REPARENT,
+				  &old_isec->avcr, &ad);
+		if (rc)
+			return rc;
+	}
+
+	ad.u.fs.dentry = new_dentry;
+	av = DIR__ADD_NAME | DIR__SEARCH;
+	if (new_dentry->d_inode)
+		av |= DIR__REMOVE_NAME;
+	rc = avc_has_perm(tsec->sid, new_dsec->sid, SECCLASS_DIR,
+			  av,&new_dsec->avcr, &ad);
+	if (rc)
+		return rc;
+	if (new_dentry->d_inode) {
+		new_isec = new_dentry->d_inode->i_security;
+		new_is_dir = S_ISDIR(new_dentry->d_inode->i_mode);
+		rc = avc_has_perm(tsec->sid, new_isec->sid,
+				  new_isec->sclass,
+				  (new_is_dir ? DIR__RMDIR : FILE__UNLINK),
+				  &new_isec->avcr, &ad);
+		if (rc)
+			return rc;
+	}
+
+	return 0;
+}
+
+/* Check whether a task can perform a filesystem operation. */
+int superblock_has_perm(struct task_struct *tsk,
+			struct super_block *sb,
+			u32 perms,
+			struct avc_audit_data *ad)
+{
+	struct task_security_struct *tsec;
+	struct superblock_security_struct *sbsec;
+
+	tsec = tsk->security;
+	sbsec = sb->s_security;
+	return avc_has_perm(tsec->sid, sbsec->sid, SECCLASS_FILESYSTEM,
+			    perms, NULL, ad);
+}
+
+/* Convert a Linux mode and permission mask to an access vector. */
+static inline u32 file_mask_to_av(int mode, int mask)
+{
+	u32 av = 0;
+
+	if ((mode & S_IFMT) != S_IFDIR) {
+		if (mask & MAY_EXEC)
+			av |= FILE__EXECUTE;
+		if (mask & MAY_READ)
+			av |= FILE__READ;
+
+		if (mask & MAY_APPEND)
+			av |= FILE__APPEND;
+		else if (mask & MAY_WRITE)
+			av |= FILE__WRITE;
+
+	} else {
+		if (mask & MAY_EXEC)
+			av |= DIR__SEARCH;
+		if (mask & MAY_WRITE)
+			av |= DIR__WRITE;
+		if (mask & MAY_READ)
+			av |= DIR__READ;
+	}
+
+	return av;
+}
+
+/* Convert a Linux file to an access vector. */
+static inline u32 file_to_av(struct file *file)
+{
+	u32 av = 0;
+
+	if (file->f_mode & FMODE_READ)
+		av |= FILE__READ;
+	if (file->f_mode & FMODE_WRITE) {
+		if (file->f_flags & O_APPEND)
+			av |= FILE__APPEND;
+		else
+			av |= FILE__WRITE;
+	}
+
+	return av;
+}
+
+/* Set an inode's SID to a specified value. */
+int inode_security_set_sid(struct inode *inode, u32 sid)
+{
+	struct inode_security_struct *isec = inode->i_security;
+
+	down(&isec->sem);
+	isec->sclass = inode_mode_to_security_class(inode->i_mode);
+	isec->sid = sid;
+	isec->initialized = 1;
+	up(&isec->sem);
+	return 0;
+}
+
+/* Set the security attributes on a newly created file. */
+static int post_create(struct inode *dir,
+		       struct dentry *dentry)
+{
+
+	struct task_security_struct *tsec;
+	struct inode *inode;
+	struct inode_security_struct *dsec;
+	struct superblock_security_struct *sbsec;
+	u32 newsid;
+	char *context;
+	unsigned int len;
+	int rc;
+
+	tsec = current->security;
+	dsec = dir->i_security;
+
+	inode = dentry->d_inode;
+	if (!inode) {
+		/* Some file system types (e.g. NFS) may not instantiate
+		   a dentry for all create operations (e.g. symlink),
+		   so we have to check to see if the inode is non-NULL. */
+		printk(KERN_WARNING "post_create:  no inode, dir "
+		       "(dev=%02x:%02x, ino=%ld)\n",
+		       MAJOR(dir->i_sb->s_dev),
+		       MINOR(dir->i_sb->s_dev),
+		       dir->i_ino);
+		return 0;
+	}
+
+	if (tsec->create_sid) {
+		newsid = tsec->create_sid;
+	} else {
+		rc = security_transition_sid(tsec->sid, dsec->sid,
+					     inode_mode_to_security_class(inode->i_mode),
+					     &newsid);
+		if (rc) {
+			printk(KERN_WARNING "post_create:  "
+			       "security_transition_sid failed, "
+			       "rc=%d (dev=%02x:%02x ino=%ld)\n", 
+			       -rc,
+			       MAJOR(inode->i_dev), 
+			       MINOR(inode->i_dev),
+			       inode->i_ino);
+			return rc;
+		}
+	}
+
+	rc = inode_security_set_sid(inode, newsid);
+	if (rc) {
+		printk(KERN_WARNING "post_create:  "
+		       "inode_security_set_sid failed, "
+		       "rc=%d (dev=%02x:%02x ino=%ld)\n", 
+		       -rc,
+		       MAJOR(inode->i_dev),
+		       MINOR(inode->i_dev),
+		       inode->i_ino);
+		return rc;
+	}
+
+	sbsec = dir->i_sb->s_security;
+	if (!sbsec)
+		return 0;
+
+	if (sbsec->behavior == SECURITY_FS_USE_XATTR &&
+	    inode->i_op->setxattr) {
+		/* Use extended attributes. */
+		rc = security_sid_to_context(newsid, &context, &len);
+		if (rc) {
+			printk(KERN_WARNING "post_create:  sid_to_context "
+			       "failed, rc=%d (dev=%02x:%02x ino=%ld)\n", 
+			       -rc,
+			       MAJOR(inode->i_dev),
+			       MINOR(inode->i_dev),
+			       inode->i_ino);
+			return rc;
+		}
+		down(&inode->i_sem);
+		rc = inode->i_op->setxattr(dentry,
+					   XATTR_NAME_SELINUX,
+					   context, len, 0);
+		up(&inode->i_sem);
+		kfree(context);
+		if (rc < 0) {
+			printk(KERN_WARNING "post_create:  setxattr failed, "
+			       "rc=%d (dev=%02x:%02x ino=%ld)\n", 
+			       -rc,
+			       MAJOR(inode->i_dev),
+			       MINOR(inode->i_dev),
+			       inode->i_ino);
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+
+/* Hook functions begin here. */
+
+static int selinux_ptrace(struct task_struct *parent, struct task_struct *child)
+{
+	int rc;
+
+	rc = secondary_ops->ptrace(parent,child);
+	if (rc)
+		return rc;
+
+	return task_has_perm(parent, child, PROCESS__PTRACE);
+}
+
+static int selinux_capget(struct task_struct *target, kernel_cap_t *effective,
+                          kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	int error;
+
+	error = task_has_perm(current, target, PROCESS__GETCAP);
+	if (error)
+		return error;
+
+	return secondary_ops->capget(target, effective, inheritable, permitted);
+}
+
+static int selinux_capset_check(struct task_struct *target, kernel_cap_t *effective,
+                                kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	int error;
+
+	error = task_has_perm(current, target, PROCESS__SETCAP);
+	if (error)
+		return error;
+
+	return secondary_ops->capset_check(target, effective, inheritable, permitted);
+}
+
+static void selinux_capset_set(struct task_struct *target, kernel_cap_t *effective,
+                               kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	int error;
+
+	error = task_has_perm(current, target, PROCESS__SETCAP);
+	if (error)
+		return;
+
+	return secondary_ops->capset_set(target, effective, inheritable, permitted);
+}
+
+static int selinux_capable(struct task_struct *tsk, int cap)
+{
+	int rc;
+
+	rc = secondary_ops->capable(tsk, cap);
+	if (rc)
+		return rc;
+
+	return task_has_capability(tsk,cap);
+}
+
+static int selinux_sysctl(ctl_table *table, int op)
+{
+	int error = 0;
+	u32 av;
+	struct task_security_struct *tsec;
+	u32 tsid;
+	int rc;
+
+	tsec = current->security;
+
+	rc = selinux_proc_get_sid(table->de, (op == 001) ?
+	                          SECCLASS_DIR : SECCLASS_FILE, &tsid);
+	if (rc) {
+		/* Default to the well-defined sysctl SID. */
+		tsid = SECINITSID_SYSCTL;
+	}
+
+	/* The op values are "defined" in sysctl.c, thereby creating
+	 * a bad coupling between this module and sysctl.c */
+	if(op == 001) {
+		error = avc_has_perm(tsec->sid, tsid,
+				     SECCLASS_DIR, DIR__SEARCH, NULL, NULL);
+	} else {
+		av = 0;
+		if (op & 004)
+			av |= FILE__READ;
+		if (op & 002)
+			av |= FILE__WRITE;
+		if (av)
+			error = avc_has_perm(tsec->sid, tsid,
+					     SECCLASS_FILE, av, NULL, NULL);
+        }
+
+	return error;
+}
+
+static int selinux_quotactl(int cmds, int type, int id, struct super_block *sb)
+{
+	int rc = 0;
+
+	if (!sb)
+		return 0;
+
+	switch (cmds) {
+		case Q_SYNC:
+		case Q_QUOTAON:
+		case Q_QUOTAOFF:
+	        case Q_SETINFO:
+		case Q_SETQUOTA:
+			rc = superblock_has_perm(current,
+						 sb,
+						 FILESYSTEM__QUOTAMOD, NULL);
+			break;
+	        case Q_GETFMT:
+	        case Q_GETINFO:
+		case Q_GETQUOTA:
+			rc = superblock_has_perm(current,
+						 sb,
+						 FILESYSTEM__QUOTAGET, NULL);
+			break;
+		default:
+			rc = 0;  /* let the kernel handle invalid cmds */
+			break;
+	}
+	return rc;
+}
+
+static int selinux_quota_on(struct file *f)
+{
+	return file_has_perm(current, f, FILE__QUOTAON);;
+}
+
+static int selinux_syslog(int type)
+{
+	int rc;
+
+	rc = secondary_ops->syslog(type);
+	if (rc)
+		return rc;
+
+	switch (type) {
+		case 3:         /* Read last kernel messages */
+			rc = task_has_system(current, SYSTEM__SYSLOG_READ);
+			break;
+		case 6:         /* Disable logging to console */
+		case 7:         /* Enable logging to console */
+		case 8:		/* Set level of messages printed to console */
+			rc = task_has_system(current, SYSTEM__SYSLOG_CONSOLE);
+			break;
+		case 0:         /* Close log */
+		case 1:         /* Open log */
+		case 2:         /* Read from log */
+		case 4:         /* Read/clear last kernel messages */
+		case 5:         /* Clear ring buffer */
+		default:
+			rc = task_has_system(current, SYSTEM__SYSLOG_MOD);
+			break;
+	}
+	return rc;
+}
+
+static int selinux_netlink_send(struct sk_buff *skb)
+{
+	if (capable(CAP_NET_ADMIN))
+		cap_raise (NETLINK_CB (skb).eff_cap, CAP_NET_ADMIN);
+	else
+		NETLINK_CB(skb).eff_cap = 0;
+	return 0;
+}
+
+static int selinux_netlink_recv(struct sk_buff *skb)
+{
+	if (!cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+/* binprm security operations */
+
+static int selinux_bprm_alloc_security(struct linux_binprm *bprm)
+{
+	struct bprm_security_struct *bsec;
+
+	bsec = kmalloc(sizeof(struct bprm_security_struct), GFP_KERNEL);
+	if (!bsec)
+		return -ENOMEM;
+
+	memset(bsec, 0, sizeof *bsec);
+	bsec->magic = SELINUX_MAGIC;
+	bsec->bprm = bprm;
+	bsec->sid = SECINITSID_UNLABELED;
+	bsec->set = 0;
+
+	bprm->security = bsec;
+	return 0;
+}
+
+static int selinux_bprm_set_security(struct linux_binprm *bprm)
+{
+	struct task_security_struct *tsec;
+	struct inode *inode = bprm->file->f_dentry->d_inode;
+	struct inode_security_struct *isec;
+	struct bprm_security_struct *bsec;
+	u32 newsid;
+	struct avc_audit_data ad;
+	int rc;
+
+	rc = secondary_ops->bprm_set_security(bprm);
+	if (rc)
+		return rc;
+
+	bsec = bprm->security;
+
+	if (bsec->set)
+		return 0;
+
+	tsec = current->security;
+	isec = inode->i_security;
+
+	/* Default to the current task SID. */
+	bsec->sid = tsec->sid;
+
+	/* Reset create SID on execve. */
+	tsec->create_sid = 0;
+
+	if (tsec->exec_sid) {
+		newsid = tsec->exec_sid;
+		/* Reset exec SID on execve. */
+		tsec->exec_sid = 0;
+	} else {
+		/* Check for a default transition on this program. */
+		rc = security_transition_sid(tsec->sid, isec->sid,
+		                             SECCLASS_PROCESS, &newsid);
+		if (rc)
+			return rc;
+	}
+
+	AVC_AUDIT_DATA_INIT(&ad, FS);
+	ad.u.fs.mnt = bprm->file->f_vfsmnt;
+	ad.u.fs.dentry = bprm->file->f_dentry;
+
+	if (bprm->file->f_vfsmnt->mnt_flags & MNT_NOSUID)
+		newsid = tsec->sid;
+
+        if (tsec->sid == newsid) {
+		rc = avc_has_perm(tsec->sid, isec->sid,
+				  SECCLASS_FILE, FILE__EXECUTE_NO_TRANS,
+				  &isec->avcr, &ad);
+		if (rc)
+			return rc;
+	} else {
+		/* Check permissions for the transition. */
+		rc = avc_has_perm(tsec->sid, newsid,
+				  SECCLASS_PROCESS, PROCESS__TRANSITION,
+				  NULL,
+				  &ad);
+		if (rc)
+			return rc;
+
+		rc = avc_has_perm(newsid, isec->sid,
+				  SECCLASS_FILE, FILE__ENTRYPOINT,
+				  &isec->avcr, &ad);
+		if (rc)
+			return rc;
+
+		/* Set the security field to the new SID. */
+		bsec->sid = newsid;
+	}
+
+	bsec->set = 1;
+	return 0;
+}
+
+static int selinux_bprm_check_security (struct linux_binprm *bprm)
+{
+	return 0;
+}
+
+
+static int selinux_bprm_secureexec (struct linux_binprm *bprm)
+{
+	struct task_security_struct *tsec = current->security;
+	int atsecure = 0;
+
+	if (tsec->osid != tsec->sid) {
+		/* Enable secure mode for SIDs transitions unless
+		   the noatsecure permission is granted between
+		   the two SIDs, i.e. ahp returns 0. */
+		atsecure = avc_has_perm(tsec->osid, tsec->sid,
+					 SECCLASS_PROCESS,
+					 PROCESS__NOATSECURE, NULL, NULL);
+	}
+
+	/* Note that we must include the legacy uid/gid test below
+	   to retain it, as the new userland will simply use the
+	   value passed by AT_SECURE to decide whether to enable
+	   secure mode. */
+	return ( atsecure || current->euid != current->uid ||
+		current->egid != current->gid);
+}
+
+static void selinux_bprm_free_security(struct linux_binprm *bprm)
+{
+	struct bprm_security_struct *bsec = bprm->security;
+	bprm->security = NULL;
+	kfree(bsec);
+}
+
+/* Derived from fs/exec.c:flush_old_files. */
+static inline void flush_unauthorized_files(struct files_struct * files)
+{
+	struct avc_audit_data ad;
+	struct file *file;
+	long j = -1;
+
+	AVC_AUDIT_DATA_INIT(&ad,FS);
+
+	write_lock(&files->file_lock);
+	for (;;) {
+		unsigned long set, i;
+
+		j++;
+		i = j * __NFDBITS;
+		if (i >= files->max_fds || i >= files->max_fdset)
+			break;
+		set = files->open_fds->fds_bits[j];
+		if (!set)
+			continue;
+		write_unlock(&files->file_lock);
+		for ( ; set ; i++,set >>= 1) {
+			if (set & 1) {
+				file = fget(i);
+				if (!file)
+					continue;
+				if (file_has_perm(current,
+						  file,
+						  file_to_av(file)))
+					sys_close(i);
+				fput(file);
+			}
+		}
+		write_lock(&files->file_lock);
+
+	}
+	write_unlock(&files->file_lock);
+}
+
+static void selinux_bprm_compute_creds(struct linux_binprm *bprm)
+{
+	struct task_security_struct *tsec, *psec;
+	struct bprm_security_struct *bsec;
+	u32 sid;
+	struct av_decision avd;
+	int rc;
+
+	secondary_ops->bprm_compute_creds(bprm);
+
+	tsec = current->security;
+
+	bsec = bprm->security;
+	sid = bsec->sid;
+
+	tsec->osid = tsec->sid;
+	if (tsec->sid != sid) {
+		/* Check for shared state.  If not ok, leave SID
+		   unchanged and kill. */
+		if ((atomic_read(&current->fs->count) > 1 ||
+		     atomic_read(&current->files->count) > 1 ||
+		     atomic_read(&current->sighand->count) > 1)) {
+			rc = avc_has_perm(tsec->sid, sid,
+					  SECCLASS_PROCESS, PROCESS__SHARE,
+					  NULL, NULL);
+			if (rc) {
+				force_sig_specific(SIGKILL, current);
+				return;
+			}
+		}
+
+		/* Check for ptracing, and update the task SID if ok.
+		   Otherwise, leave SID unchanged and kill. */
+		task_lock(current);
+		if (current->ptrace & PT_PTRACED) {
+			psec = current->p_pptr->security;
+			rc = avc_has_perm_noaudit(psec->sid, sid,
+					  SECCLASS_PROCESS, PROCESS__PTRACE,
+					  NULL, &avd);
+			if (!rc)
+				tsec->sid = sid;
+			task_unlock(current);
+			avc_audit(psec->sid, sid, SECCLASS_PROCESS,
+				  PROCESS__PTRACE, &avd, rc, NULL);
+			if (rc) {
+				force_sig_specific(SIGKILL, current);
+				return;
+			}
+		} else {
+			tsec->sid = sid;
+			task_unlock(current);
+		}
+
+		/* Close files for which the new task SID is not authorized. */
+		flush_unauthorized_files(current->files);
+
+		/* Wake up the parent if it is waiting so that it can
+		   recheck wait permission to the new task SID. */
+		wake_up_interruptible(&current->p_pptr->wait_chldexit);
+	}
+}
+
+/* superblock security operations */
+
+static int selinux_sb_alloc_security(struct super_block *sb)
+{
+	return superblock_alloc_security(sb);
+}
+
+static void selinux_sb_free_security(struct super_block *sb)
+{
+	superblock_free_security(sb);
+}
+
+static int selinux_sb_kern_mount(struct super_block *sb)
+{
+	struct avc_audit_data ad;
+	int rc;
+
+	rc = superblock_doinit(sb);
+	if (rc)
+		return rc;
+
+	AVC_AUDIT_DATA_INIT(&ad,FS);
+	ad.u.fs.dentry = sb->s_root;
+	return superblock_has_perm(current, sb, FILESYSTEM__MOUNT, &ad);
+}
+
+static int selinux_sb_statfs(struct super_block *sb)
+{
+	struct avc_audit_data ad;
+
+	AVC_AUDIT_DATA_INIT(&ad,FS);
+	ad.u.fs.dentry = sb->s_root;
+	return superblock_has_perm(current, sb, FILESYSTEM__GETATTR, &ad);
+}
+
+static int selinux_mount(char * dev_name,
+                         struct nameidata *nd,
+                         char * type,
+                         unsigned long flags,
+                         void * data)
+{
+	if (flags & MS_REMOUNT)
+		return superblock_has_perm(current, nd->mnt->mnt_sb,
+		                           FILESYSTEM__REMOUNT, NULL);
+	else
+		return dentry_has_perm(current, nd->mnt, nd->dentry,
+		                       FILE__MOUNTON);
+}
+
+static int selinux_umount(struct vfsmount *mnt, int flags)
+{
+	return superblock_has_perm(current,mnt->mnt_sb,
+	                           FILESYSTEM__UNMOUNT,NULL);
+}
+
+/* inode security operations */
+
+static int selinux_inode_alloc_security(struct inode *inode)
+{
+	return inode_alloc_security(inode);
+}
+
+static void selinux_inode_free_security(struct inode *inode)
+{
+	inode_free_security(inode);
+}
+
+static int selinux_inode_create(struct inode *dir, struct dentry *dentry, int mask)
+{
+	return may_create(dir, dentry, SECCLASS_FILE);
+}
+
+static void selinux_inode_post_create(struct inode *dir, struct dentry *dentry, int mask)
+{
+	post_create(dir, dentry);
+}
+
+static int selinux_inode_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
+{
+	int rc;
+
+	rc = secondary_ops->inode_link(old_dentry,dir,new_dentry);
+	if (rc)
+		return rc;
+	return may_link(dir, old_dentry, MAY_LINK);
+}
+
+static void selinux_inode_post_link(struct dentry *old_dentry, struct inode *inode, struct dentry *new_dentry)
+{
+	return;
+}
+
+static int selinux_inode_unlink(struct inode *dir, struct dentry *dentry)
+{
+	return may_link(dir, dentry, MAY_UNLINK);
+}
+
+static int selinux_inode_symlink(struct inode *dir, struct dentry *dentry, const char *name)
+{
+	return may_create(dir, dentry, SECCLASS_LNK_FILE);
+}
+
+static void selinux_inode_post_symlink(struct inode *dir, struct dentry *dentry, const char *name)
+{
+	post_create(dir, dentry);
+}
+
+static int selinux_inode_mkdir(struct inode *dir, struct dentry *dentry, int mask)
+{
+	return may_create(dir, dentry, SECCLASS_DIR);
+}
+
+static void selinux_inode_post_mkdir(struct inode *dir, struct dentry *dentry, int mask)
+{
+	post_create(dir, dentry);
+}
+
+static int selinux_inode_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	return may_link(dir, dentry, MAY_RMDIR);
+}
+
+static int selinux_inode_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	return may_create(dir, dentry, inode_mode_to_security_class(mode));
+}
+
+static void selinux_inode_post_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	post_create(dir, dentry);
+}
+
+static int selinux_inode_rename(struct inode *old_inode, struct dentry *old_dentry,
+                                struct inode *new_inode, struct dentry *new_dentry)
+{
+	return may_rename(old_inode, old_dentry, new_inode, new_dentry);
+}
+
+static void selinux_inode_post_rename(struct inode *old_inode, struct dentry *old_dentry,
+                                      struct inode *new_inode, struct dentry *new_dentry)
+{
+	return;
+}
+
+static int selinux_inode_readlink(struct dentry *dentry)
+{
+	return dentry_has_perm(current, NULL, dentry, FILE__READ);
+}
+
+static int selinux_inode_follow_link(struct dentry *dentry, struct nameidata *nameidata)
+{
+	int rc;
+
+	rc = secondary_ops->inode_follow_link(dentry,nameidata);
+	if (rc)
+		return rc;
+	return dentry_has_perm(current, NULL, dentry, FILE__READ);
+}
+
+static int selinux_inode_permission(struct inode *inode, int mask)
+{
+	if (!mask) {
+		/* No permission to check.  Existence test. */
+		return 0;
+	}
+
+	return inode_has_perm(current, inode,
+			       file_mask_to_av(inode->i_mode, mask), NULL, NULL);
+}
+
+static int selinux_inode_setattr(struct dentry *dentry, struct iattr *iattr)
+{
+	if (iattr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID |
+			       ATTR_ATIME_SET | ATTR_MTIME_SET))
+		return dentry_has_perm(current, NULL, dentry, FILE__SETATTR);
+
+	return dentry_has_perm(current, NULL, dentry, FILE__WRITE);
+}
+
+static int selinux_inode_stat(struct inode *inode)
+{
+	return inode_has_perm(current, inode, FILE__GETATTR, NULL, NULL);
+}
+
+static int selinux_inode_setxattr(struct dentry *dentry, char *name, void *value, size_t size, int flags)
+{
+	struct task_security_struct *tsec = current->security;
+	struct inode *inode = dentry->d_inode;
+	struct inode_security_struct *isec = inode->i_security;
+	struct superblock_security_struct *sbsec;
+	struct avc_audit_data ad;
+	u32 newsid;
+	int rc = 0;
+
+	if (strcmp(name, XATTR_NAME_SELINUX)) {
+		if (!strncmp(name, XATTR_SECURITY_PREFIX,
+			     sizeof XATTR_SECURITY_PREFIX - 1) &&
+		    !capable(CAP_SYS_ADMIN)) {
+			/* A different attribute in the security namespace.
+			   Restrict to administrator. */
+			return -EPERM;
+		}
+
+		/* Not an attribute we recognize, so just check the
+		   ordinary setattr permission. */
+		return dentry_has_perm(current, NULL, dentry, FILE__SETATTR);
+	}
+
+	AVC_AUDIT_DATA_INIT(&ad,FS);
+	ad.u.fs.dentry = dentry;
+
+	rc = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			  FILE__RELABELFROM,
+			  &isec->avcr, &ad);
+	if (rc)
+		return rc;
+
+	rc = security_context_to_sid(value, size, &newsid);
+	if (rc)
+		return rc;
+
+	rc = avc_has_perm(tsec->sid, newsid, isec->sclass,
+			  FILE__RELABELTO, NULL, &ad);
+	if (rc)
+		return rc;
+
+	sbsec = inode->i_sb->s_security;
+	if (!sbsec)
+		return 0;
+
+	return avc_has_perm(newsid,
+			    sbsec->sid,
+			    SECCLASS_FILESYSTEM,
+			    FILESYSTEM__ASSOCIATE,
+			    NULL,
+			    &ad);
+}
+
+static void selinux_inode_post_setxattr(struct dentry *dentry, char *name,
+                                        void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	struct inode_security_struct *isec = inode->i_security;
+	u32 newsid;
+	int rc;
+
+	if (strcmp(name, XATTR_NAME_SELINUX)) {
+		/* Not an attribute we recognize, so nothing to do. */
+		return;
+	}
+
+	rc = security_context_to_sid(value, size, &newsid);
+	if (rc) {
+		printk(KERN_WARNING "%s:  unable to obtain SID for context "
+		       "%s, rc=%d\n", __FUNCTION__, (char*)value, -rc);
+		return;
+	}
+
+	isec->sid = newsid;
+	return;
+}
+
+static int selinux_inode_getxattr (struct dentry *dentry, char *name)
+{
+	return dentry_has_perm(current, NULL, dentry, FILE__GETATTR);
+}
+
+static int selinux_inode_listxattr (struct dentry *dentry)
+{
+	return dentry_has_perm(current, NULL, dentry, FILE__GETATTR);
+}
+
+static int selinux_inode_removexattr (struct dentry *dentry, char *name)
+{
+	if (strcmp(name, XATTR_NAME_SELINUX)) {
+		if (!strncmp(name, XATTR_SECURITY_PREFIX,
+			     sizeof XATTR_SECURITY_PREFIX - 1) &&
+		    !capable(CAP_SYS_ADMIN)) {
+			/* A different attribute in the security namespace.
+			   Restrict to administrator. */
+			return -EPERM;
+		}
+
+		/* Not an attribute we recognize, so just check the
+		   ordinary setattr permission. Might want a separate
+		   permission for removexattr. */
+		return dentry_has_perm(current, NULL, dentry, FILE__SETATTR);
+	}
+
+	/* No one is allowed to remove a SELinux security label.
+	   You can change the label, but all data must be labeled. */
+	return -EACCES;
+}
+
+static int selinux_inode_getsecurity(struct dentry *dentry, const char *name, void *buffer, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	struct inode_security_struct *isec = inode->i_security;
+	char *context;
+	unsigned len;
+	int rc;
+
+	/* Permission check handled by selinux_inode_getxattr hook.*/
+
+	if (strcmp(name, XATTR_SELINUX_SUFFIX))
+		return -EOPNOTSUPP;
+
+	rc = security_sid_to_context(isec->sid, &context, &len);
+	if (rc)
+		return rc;
+
+	if (!buffer || !size) {
+		kfree(context);
+		return len;
+	}
+	if (size < len) {
+		kfree(context);
+		return -ERANGE;
+	}
+	memcpy(buffer, context, len);
+	kfree(context);
+	return len;
+}
+
+static int selinux_inode_setsecurity(struct dentry *dentry, const char *name,
+                                     const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	struct inode_security_struct *isec = inode->i_security;
+	u32 newsid;
+	int rc;
+
+	if (strcmp(name, XATTR_SELINUX_SUFFIX))
+		return -EOPNOTSUPP;
+
+	if (!value || !size)
+		return -EACCES;
+
+	rc = security_context_to_sid((void*)value, size, &newsid);
+	if (rc)
+		return rc;
+
+	isec->sid = newsid;
+	return 0;
+}
+
+static int selinux_inode_listsecurity(struct dentry *dentry, char *buffer)
+{
+	const int len = sizeof(XATTR_NAME_SELINUX);
+	if (buffer)
+		memcpy(buffer, XATTR_NAME_SELINUX, len);
+	return len;
+}
+
+/* file security operations */
+
+static int selinux_file_permission(struct file *file, int mask)
+{
+	struct inode *inode = file->f_dentry->d_inode;
+
+	if (!mask) {
+		/* No permission to check.  Existence test. */
+		return 0;
+	}
+
+	/* file_mask_to_av won't add FILE__WRITE if MAY_APPEND is set */
+	if ((file->f_flags & O_APPEND) && (mask & MAY_WRITE))
+		mask |= MAY_APPEND;
+
+	return file_has_perm(current, file,
+			     file_mask_to_av(inode->i_mode, mask));
+}
+
+static int selinux_file_alloc_security(struct file *file)
+{
+	return file_alloc_security(file);
+}
+
+static void selinux_file_free_security(struct file *file)
+{
+	file_free_security(file);
+}
+
+static int selinux_file_ioctl(struct file *file, unsigned int cmd,
+			      unsigned long arg)
+{
+	int error = 0;
+
+	switch (cmd) {
+		case FIONREAD:
+		/* fall through */
+		case FIBMAP:
+		/* fall through */
+		case FIGETBSZ:
+		/* fall through */
+		case EXT2_IOC_GETFLAGS:
+		/* fall through */
+		case EXT2_IOC_GETVERSION:
+			error = file_has_perm(current, file, FILE__GETATTR);
+			break;
+
+		case EXT2_IOC_SETFLAGS:
+		/* fall through */
+		case EXT2_IOC_SETVERSION:
+			error = file_has_perm(current, file, FILE__SETATTR);
+			break;
+
+		/* sys_ioctl() checks */
+		case FIONBIO:
+		/* fall through */
+		case FIOASYNC:
+			error = file_has_perm(current, file, 0);
+			break;
+
+	        case KDSKBENT:
+	        case KDSKBSENT:
+			error = task_has_capability(current,CAP_SYS_TTY_CONFIG);
+			break;
+
+		/* default case assumes that the command will go
+		 * to the file's ioctl() function.
+		 */
+		default:
+			error = file_has_perm(current, file, FILE__IOCTL);
+
+	}
+	return error;
+}
+
+static int selinux_file_mmap(struct file *file, unsigned long prot, unsigned long flags)
+{
+	u32 av;
+
+	if (file) {
+		/* read access is always possible with a mapping */
+		av = FILE__READ;
+
+		/* write access only matters if the mapping is shared */
+		if ((flags & MAP_TYPE) == MAP_SHARED && (prot & PROT_WRITE))
+			av |= FILE__WRITE;
+
+		if (prot & PROT_EXEC)
+			av |= FILE__EXECUTE;
+
+		return file_has_perm(current, file, av);
+	}
+	return 0;
+}
+
+static int selinux_file_mprotect(struct vm_area_struct *vma,
+				 unsigned long prot)
+{
+	return selinux_file_mmap(vma->vm_file, prot, vma->vm_flags);
+}
+
+static int selinux_file_lock(struct file *file, unsigned int cmd)
+{
+	return file_has_perm(current, file, FILE__LOCK);
+}
+
+static int selinux_file_fcntl(struct file *file, unsigned int cmd,
+			      unsigned long arg)
+{
+	int err = 0;
+
+	switch (cmd) {
+	        case F_SETFL:
+			if (!file->f_dentry || !file->f_dentry->d_inode) {
+				err = -EINVAL;
+				break;
+			}
+
+			if ((file->f_flags & O_APPEND) && !(arg & O_APPEND)) {
+				err = file_has_perm(current, file,FILE__WRITE);
+				break;
+			}
+			/* fall through */
+	        case F_SETOWN:
+	        case F_SETSIG:
+	        case F_GETFL:
+	        case F_GETOWN:
+	        case F_GETSIG:
+			/* Just check FD__USE permission */
+			err = file_has_perm(current, file, 0);
+			break;
+		case F_GETLK:
+		case F_SETLK:
+	        case F_SETLKW:
+#if BITS_PER_LONG == 32
+	        case F_GETLK64:
+		case F_SETLK64:
+	        case F_SETLKW64:
+#endif
+			if (!file->f_dentry || !file->f_dentry->d_inode) {
+				err = -EINVAL;
+				break;
+			}
+			err = file_has_perm(current, file, FILE__LOCK);
+			break;
+	}
+
+	return err;
+}
+
+static int selinux_file_set_fowner(struct file *file)
+{
+	struct task_security_struct *tsec;
+	struct file_security_struct *fsec;
+
+	tsec = current->security;
+	fsec = file->f_security;
+	fsec->fown_sid = tsec->sid;
+
+	return 0;
+}
+
+static int selinux_file_send_sigiotask(struct task_struct *tsk,
+				       struct fown_struct *fown,
+				       int fd, int reason)
+{
+        struct file *file;
+	u32 perm;
+	struct task_security_struct *tsec;
+	struct file_security_struct *fsec;
+
+	/* struct fown_struct is never outside the context of a struct file */
+        file = (struct file *)((long)fown - offsetof(struct file,f_owner));
+
+	tsec = tsk->security;
+	fsec = file->f_security;
+
+	if (!fown->signum)
+		perm = signal_to_av(SIGIO); /* as per send_sigio_to_task */
+	else
+		perm = signal_to_av(fown->signum);
+
+	return avc_has_perm(fsec->fown_sid, tsec->sid,
+			    SECCLASS_PROCESS, perm, NULL, NULL);
+}
+
+static int selinux_file_receive(struct file *file)
+{
+	return file_has_perm(current, file, file_to_av(file));
+}
+
+/* task security operations */
+
+static int selinux_task_create(unsigned long clone_flags)
+{
+	return task_has_perm(current, current, PROCESS__FORK);
+}
+
+static int selinux_task_alloc_security(struct task_struct *tsk)
+{
+	struct task_security_struct *tsec1, *tsec2;
+	int rc;
+
+	tsec1 = current->security;
+
+	rc = task_alloc_security(tsk);
+	if (rc)
+		return rc;
+	tsec2 = tsk->security;
+
+	tsec2->osid = tsec1->osid;
+	tsec2->sid = tsec1->sid;
+
+	/* Retain the exec and create SIDs across fork */
+	tsec2->exec_sid = tsec1->exec_sid;
+	tsec2->create_sid = tsec1->create_sid;
+
+	return 0;
+}
+
+static void selinux_task_free_security(struct task_struct *tsk)
+{
+	task_free_security(tsk);
+}
+
+static int selinux_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
+{
+	/* Since setuid only affects the current process, and
+	   since the SELinux controls are not based on the Linux
+	   identity attributes, SELinux does not need to control
+	   this operation.  However, SELinux does control the use
+	   of the CAP_SETUID and CAP_SETGID capabilities using the
+	   capable hook. */
+	return 0;
+}
+
+static int selinux_task_post_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
+{
+	return secondary_ops->task_post_setuid(id0,id1,id2,flags);
+}
+
+static int selinux_task_setgid(gid_t id0, gid_t id1, gid_t id2, int flags)
+{
+	/* See the comment for setuid above. */
+	return 0;
+}
+
+static int selinux_task_setpgid(struct task_struct *p, pid_t pgid)
+{
+	return task_has_perm(current, p, PROCESS__SETPGID);
+}
+
+static int selinux_task_getpgid(struct task_struct *p)
+{
+	return task_has_perm(current, p, PROCESS__GETPGID);
+}
+
+static int selinux_task_getsid(struct task_struct *p)
+{
+	return task_has_perm(current, p, PROCESS__GETSESSION);
+}
+
+static int selinux_task_setgroups(int gidsetsize, gid_t *grouplist)
+{
+	/* See the comment for setuid above. */
+	return 0;
+}
+
+static int selinux_task_setnice(struct task_struct *p, int nice)
+{
+	return task_has_perm(current,p, PROCESS__SETSCHED);
+}
+
+static int selinux_task_setrlimit(unsigned int resource, struct rlimit *new_rlim)
+{
+	/* SELinux does not currently provide a process
+	   resource limit policy based on security contexts.
+	   It does control the use of the CAP_SYS_RESOURCE capability
+	   using the capable hook. */
+	return 0;
+}
+
+static int selinux_task_setscheduler(struct task_struct *p, int policy, struct sched_param *lp)
+{
+	struct task_security_struct *tsec1, *tsec2;
+
+	tsec1 = current->security;
+	tsec2 = p->security;
+
+	/* No auditing from the setscheduler hook, since the runqueue lock
+	   is held and the system will deadlock if we try to log an audit
+	   message. */
+	return avc_has_perm_noaudit(tsec1->sid, tsec2->sid,
+				    SECCLASS_PROCESS, PROCESS__SETSCHED,
+				    &tsec2->avcr, NULL);
+}
+
+static int selinux_task_getscheduler(struct task_struct *p)
+{
+	return task_has_perm(current, p, PROCESS__GETSCHED);
+}
+
+static int selinux_task_kill(struct task_struct *p, struct siginfo *info, int sig)
+{
+	u32 perm;
+
+	if (info && ((unsigned long)info == 1 ||
+	             (unsigned long)info == 2 || SI_FROMKERNEL(info)))
+		return 0;
+
+	if (!sig)
+		perm = PROCESS__SIGNULL; /* null signal; existence test */
+	else
+		perm = signal_to_av(sig);
+
+	return task_has_perm(current, p, perm);
+}
+
+static int selinux_task_prctl(int option,
+			      unsigned long arg2,
+			      unsigned long arg3,
+			      unsigned long arg4,
+			      unsigned long arg5)
+{
+	/* The current prctl operations do not appear to require
+	   any SELinux controls since they merely observe or modify
+	   the state of the current process. */
+	return 0;
+}
+
+static int selinux_task_wait(struct task_struct *p)
+{
+	u32 perm;
+
+	perm = signal_to_av(p->exit_signal);
+
+	return task_has_perm(p, current, perm);
+}
+
+static void selinux_task_kmod_set_label(void)
+{
+  	struct task_security_struct *tsec;
+
+	secondary_ops->task_kmod_set_label();
+
+	tsec = current->security;
+	tsec->osid = tsec->sid;
+	tsec->sid = SECINITSID_KERNEL;
+	tsec->exec_sid = 0;
+	tsec->create_sid = 0;
+	return;
+}
+
+static void selinux_task_reparent_to_init(struct task_struct *p)
+{
+  	struct task_security_struct *tsec;
+
+	secondary_ops->task_reparent_to_init(p);
+
+	tsec = p->security;
+	tsec->osid = tsec->sid;
+	tsec->sid = SECINITSID_KERNEL;
+	return;
+}
+
+static void selinux_task_to_inode(struct task_struct *p,
+				  struct inode *inode)
+{
+	struct task_security_struct *tsec = p->security;
+	struct inode_security_struct *isec = inode->i_security;
+
+	isec->sid = tsec->sid;
+	isec->initialized = 1;
+	return;
+}
+
+#ifdef CONFIG_SECURITY_NETWORK
+
+/* socket security operations */
+static int socket_has_perm(struct task_struct *task, struct socket *sock,
+			   u32 perms)
+{
+	struct inode_security_struct *isec;
+	struct task_security_struct *tsec;
+	struct avc_audit_data ad;
+	int err;
+
+	tsec = task->security;
+	isec = SOCK_INODE(sock)->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad,NET);
+	ad.u.net.sk = sock->sk;
+	err = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			   perms, &isec->avcr, &ad);
+
+	return err;
+}
+
+static int selinux_socket_create(int family, int type, int protocol)
+{
+	int err;
+	struct task_security_struct *tsec;
+
+	tsec = current->security;
+
+	err = avc_has_perm(tsec->sid, tsec->sid,
+			   socket_type_to_security_class(family, type),
+			   SOCKET__CREATE, NULL, NULL);
+
+	return err;
+}
+
+static void selinux_socket_post_create(struct socket *sock, int family, int type, int protocol)
+{
+	int err;
+	struct inode_security_struct *isec;
+	struct task_security_struct *tsec;
+
+	err = inode_doinit(SOCK_INODE(sock));
+	if (err < 0)
+		return;
+	isec = SOCK_INODE(sock)->i_security;
+
+	tsec = current->security;
+	isec->sclass = socket_type_to_security_class(family, type);
+	isec->sid = tsec->sid;
+
+	return;
+}
+
+/* Range of port numbers used to automatically bind.
+   Need to determine whether we should perform a name_bind
+   permission check between the socket and the port number. */
+#define ip_local_port_range_0 sysctl_local_port_range[0]
+#define ip_local_port_range_1 sysctl_local_port_range[1]
+
+static int selinux_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+	int err;
+
+	err = socket_has_perm(current, sock, SOCKET__BIND);
+	if (err)
+		return err;
+
+	/*
+	 * If PF_INET, check name_bind permission for the port.
+	 */
+	if (sock->sk->sk_family == PF_INET) {
+		struct inode_security_struct *isec;
+		struct task_security_struct *tsec;
+		struct avc_audit_data ad;
+		struct sockaddr_in *addr = (struct sockaddr_in *)address;
+		unsigned short snum = ntohs(addr->sin_port);
+		struct sock *sk = sock->sk;
+		u32 sid;
+
+		tsec = current->security;
+		isec = SOCK_INODE(sock)->i_security;
+
+		if (snum&&(snum < max(PROT_SOCK,ip_local_port_range_0) ||
+			   snum > ip_local_port_range_1)) {
+			err = security_port_sid(sk->sk_family, sk->sk_type,
+						sk->sk_protocol, snum, &sid);
+			if (err)
+				return err;
+			AVC_AUDIT_DATA_INIT(&ad,NET);
+			ad.u.net.port = snum;
+			err = avc_has_perm(isec->sid, sid,
+					   isec->sclass,
+					   SOCKET__NAME_BIND, NULL, &ad);
+			if (err)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static int selinux_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+	int err;
+	struct sock *sk = sock->sk;
+	struct avc_audit_data ad;
+	struct task_security_struct *tsec;
+	struct inode_security_struct *isec;
+
+	isec = SOCK_INODE(sock)->i_security;
+
+	tsec = current->security;
+
+	AVC_AUDIT_DATA_INIT(&ad, NET);
+	ad.u.net.sk = sk;
+	err = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			   SOCKET__CONNECT, &isec->avcr, &ad);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int selinux_socket_listen(struct socket *sock, int backlog)
+{
+	int err;
+	struct task_security_struct *tsec;
+	struct inode_security_struct *isec;
+	struct avc_audit_data ad;
+
+	tsec = current->security;
+
+	isec = SOCK_INODE(sock)->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad, NET);
+	ad.u.net.sk = sock->sk;
+
+	err = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			   SOCKET__LISTEN, &isec->avcr, &ad);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int selinux_socket_accept(struct socket *sock, struct socket *newsock)
+{
+	int err;
+	struct task_security_struct *tsec;
+	struct inode_security_struct *isec;
+	struct inode_security_struct *newisec;
+	struct avc_audit_data ad;
+
+	tsec = current->security;
+
+	isec = SOCK_INODE(sock)->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad, NET);
+	ad.u.net.sk = sock->sk;
+
+	err = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			   SOCKET__ACCEPT, &isec->avcr, &ad);
+	if (err)
+		return err;
+
+	err = inode_doinit(SOCK_INODE(newsock));
+	if (err < 0)
+		return err;
+	newisec = SOCK_INODE(newsock)->i_security;
+
+	newisec->sclass = isec->sclass;
+	newisec->sid = isec->sid;
+
+	return 0;
+}
+
+static int selinux_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+ 				  int size)
+{
+	struct task_security_struct *tsec;
+	struct inode_security_struct *isec;
+	struct avc_audit_data ad;
+	struct sock *sk;
+	int err;
+
+	isec = SOCK_INODE(sock)->i_security;
+
+	tsec = current->security;
+
+	sk = sock->sk;
+
+	AVC_AUDIT_DATA_INIT(&ad, NET);
+	ad.u.net.sk = sk;
+	err = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			   SOCKET__WRITE, &isec->avcr, &ad);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int selinux_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+				  int size, int flags)
+{
+	struct inode_security_struct *isec;
+	struct task_security_struct *tsec;
+	struct avc_audit_data ad;
+	int err;
+
+	isec = SOCK_INODE(sock)->i_security;
+	tsec = current->security;
+
+	AVC_AUDIT_DATA_INIT(&ad,NET);
+	ad.u.net.sk = sock->sk;
+	err = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			   SOCKET__READ, &isec->avcr, &ad);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int selinux_socket_getsockname(struct socket *sock)
+{
+	struct inode_security_struct *isec;
+	struct task_security_struct *tsec;
+	struct avc_audit_data ad;
+	int err;
+
+	tsec = current->security;
+	isec = SOCK_INODE(sock)->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad,NET);
+	ad.u.net.sk = sock->sk;
+	err = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			   SOCKET__GETATTR, &isec->avcr, &ad);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int selinux_socket_getpeername(struct socket *sock)
+{
+	struct inode_security_struct *isec;
+	struct task_security_struct *tsec;
+	struct avc_audit_data ad;
+	int err;
+
+	tsec = current->security;
+	isec = SOCK_INODE(sock)->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad,NET);
+	ad.u.net.sk = sock->sk;
+	err = avc_has_perm(tsec->sid, isec->sid, isec->sclass,
+			   SOCKET__GETATTR, &isec->avcr, &ad);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int selinux_socket_setsockopt(struct socket *sock,int level,int optname)
+{
+	return socket_has_perm(current, sock, SOCKET__SETOPT);
+}
+
+static int selinux_socket_getsockopt(struct socket *sock, int level,
+				     int optname)
+{
+	return socket_has_perm(current, sock, SOCKET__GETOPT);
+}
+
+static int selinux_socket_shutdown(struct socket *sock, int how)
+{
+	return socket_has_perm(current, sock, SOCKET__SHUTDOWN);
+}
+
+static int selinux_socket_unix_stream_connect(struct socket *sock,
+					      struct socket *other,
+					      struct sock *newsk)
+{
+	struct inode_security_struct *isec;
+	struct inode_security_struct *other_isec;
+	struct avc_audit_data ad;
+	int err;
+
+	isec = SOCK_INODE(sock)->i_security;
+	other_isec = SOCK_INODE(other)->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad,NET);
+	ad.u.net.sk = other->sk;
+
+	err = avc_has_perm(isec->sid, other_isec->sid,
+			   isec->sclass,
+			   UNIX_STREAM_SOCKET__CONNECTTO,
+			   &other_isec->avcr, &ad);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int selinux_socket_unix_may_send(struct socket *sock,
+					struct socket *other)
+{
+	struct inode_security_struct *isec;
+	struct inode_security_struct *other_isec;
+	struct avc_audit_data ad;
+	int err;
+
+	isec = SOCK_INODE(sock)->i_security;
+	other_isec = SOCK_INODE(other)->i_security;
+
+	AVC_AUDIT_DATA_INIT(&ad,NET);
+	ad.u.net.sk = other->sk;
+
+	err = avc_has_perm(isec->sid, other_isec->sid,
+			   isec->sclass,
+			   SOCKET__SENDTO,
+			   &other_isec->avcr, &ad);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+#endif
+
+static int ipc_alloc_security(struct task_struct *task,
+			      struct kern_ipc_perm *perm,
+			      u16 sclass)
+{
+	struct task_security_struct *tsec = task->security;
+	struct ipc_security_struct *isec;
+
+	isec = kmalloc(sizeof(struct ipc_security_struct), GFP_KERNEL);
+	if (!isec)
+		return -ENOMEM;
+
+	memset(isec, 0, sizeof(struct ipc_security_struct));
+	isec->magic = SELINUX_MAGIC;
+	isec->sclass = sclass;
+	isec->ipc_perm = perm;
+	if (tsec) {
+		isec->sid = tsec->sid;
+	} else {
+		isec->sid = SECINITSID_UNLABELED;
+	}
+	perm->security = isec;
+
+	return 0;
+}
+
+static void ipc_free_security(struct kern_ipc_perm *perm)
+{
+	struct ipc_security_struct *isec = perm->security;
+	if (!isec || isec->magic != SELINUX_MAGIC)
+		return;
+
+	perm->security = NULL;
+	kfree(isec);
+}
+
+static int msg_msg_alloc_security(struct msg_msg *msg)
+{
+	struct msg_security_struct *msec;
+
+	msec = kmalloc(sizeof(struct msg_security_struct), GFP_KERNEL);
+	if (!msec)
+		return -ENOMEM;
+
+	memset(msec, 0, sizeof(struct msg_security_struct));
+	msec->magic = SELINUX_MAGIC;
+	msec->msg = msg;
+	msec->sid = SECINITSID_UNLABELED;
+	msg->security = msec;
+
+	return 0;
+}
+
+static void msg_msg_free_security(struct msg_msg *msg)
+{
+	struct msg_security_struct *msec = msg->security;
+	if (!msec || msec->magic != SELINUX_MAGIC)
+		return;
+
+	msg->security = NULL;
+	kfree(msec);
+}
+
+static int ipc_has_perm(struct kern_ipc_perm *ipc_perms,
+			u16 sclass, u32 perms)
+{
+	struct task_security_struct *tsec;
+	struct ipc_security_struct *isec;
+	struct avc_audit_data ad;
+
+	tsec = current->security;
+	isec = ipc_perms->security;
+
+	AVC_AUDIT_DATA_INIT(&ad, IPC);
+	ad.u.ipc_id = ipc_perms->key;
+
+	return avc_has_perm(tsec->sid, isec->sid, sclass,
+			    perms, &isec->avcr, &ad);
+}
+
+static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
+{
+	return msg_msg_alloc_security(msg);
+}
+
+static void selinux_msg_msg_free_security(struct msg_msg *msg)
+{
+	return msg_msg_free_security(msg);
+}
+
+/* message queue security operations */
+static int selinux_msg_queue_alloc_security(struct msg_queue *msq)
+{
+	struct task_security_struct *tsec;
+	struct ipc_security_struct *isec;
+	struct avc_audit_data ad;
+	int rc;
+
+	rc = ipc_alloc_security(current, &msq->q_perm, SECCLASS_MSGQ);
+	if (rc)
+		return rc;
+
+	tsec = current->security;
+	isec = msq->q_perm.security;
+
+	AVC_AUDIT_DATA_INIT(&ad, IPC);
+ 	ad.u.ipc_id = msq->q_perm.key;
+
+	rc = avc_has_perm(tsec->sid, isec->sid, SECCLASS_MSGQ,
+			  MSGQ__CREATE, &isec->avcr, &ad);
+	if (rc) {
+		ipc_free_security(&msq->q_perm);
+		return rc;
+	}
+	return 0;
+}
+
+static void selinux_msg_queue_free_security(struct msg_queue *msq)
+{
+	ipc_free_security(&msq->q_perm);
+}
+
+static int selinux_msg_queue_associate(struct msg_queue *msq, int msqflg)
+{
+	struct task_security_struct *tsec;
+	struct ipc_security_struct *isec;
+	struct avc_audit_data ad;
+
+	tsec = current->security;
+	isec = msq->q_perm.security;
+
+	AVC_AUDIT_DATA_INIT(&ad, IPC);
+	ad.u.ipc_id = msq->q_perm.key;
+
+	return avc_has_perm(tsec->sid, isec->sid, SECCLASS_MSGQ,
+			    MSGQ__ASSOCIATE, &isec->avcr, &ad);
+}
+
+static int selinux_msg_queue_msgctl(struct msg_queue *msq, int cmd)
+{
+	int err;
+	int perms;
+
+	switch(cmd) {
+	case IPC_INFO:
+	case MSG_INFO:
+		/* No specific object, just general system-wide information. */
+		return task_has_system(current, SYSTEM__IPC_INFO);
+	case IPC_STAT:
+	case MSG_STAT:
+		perms = MSGQ__GETATTR | MSGQ__ASSOCIATE;
+		break;
+	case IPC_SET:
+		perms = MSGQ__SETATTR;
+		break;
+	case IPC_RMID:
+		perms = MSGQ__DESTROY;
+		break;
+	default:
+		return 0;
+	}
+
+	err = ipc_has_perm(&msq->q_perm, SECCLASS_MSGQ, perms);
+	return err;
+}
+
+static int selinux_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg, int msqflg)
+{
+	struct task_security_struct *tsec;
+	struct ipc_security_struct *isec;
+	struct msg_security_struct *msec;
+	struct avc_audit_data ad;
+	int rc;
+
+	tsec = current->security;
+	isec = msq->q_perm.security;
+	msec = msg->security;
+
+	/*
+	 * First time through, need to assign label to the message
+	 */
+	if (msec->sid == SECINITSID_UNLABELED) {
+		/*
+		 * Compute new sid based on current process and
+		 * message queue this message will be stored in
+		 */
+		rc = security_transition_sid(tsec->sid,
+					     isec->sid,
+					     SECCLASS_MSG,
+					     &msec->sid);
+		if (rc)
+			return rc;
+	}
+
+	AVC_AUDIT_DATA_INIT(&ad, IPC);
+	ad.u.ipc_id = msq->q_perm.key;
+
+	/* Can this process write to the queue? */
+	rc = avc_has_perm(tsec->sid, isec->sid, SECCLASS_MSGQ,
+			  MSGQ__WRITE, &isec->avcr, &ad);
+	if (!rc)
+		/* Can this process send the message */
+		rc = avc_has_perm(tsec->sid, msec->sid,
+				  SECCLASS_MSG, MSG__SEND,
+				  &msec->avcr, &ad);
+	if (!rc)
+		/* Can the message be put in the queue? */
+		rc = avc_has_perm(msec->sid, isec->sid,
+				  SECCLASS_MSGQ, MSGQ__ENQUEUE,
+				  &isec->avcr, &ad);
+
+	return rc;
+}
+
+static int selinux_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+				    struct task_struct *target,
+				    long type, int mode)
+{
+	struct task_security_struct *tsec;
+	struct ipc_security_struct *isec;
+	struct msg_security_struct *msec;
+	struct avc_audit_data ad;
+	int rc;
+
+	tsec = target->security;
+	isec = msq->q_perm.security;
+	msec = msg->security;
+
+	AVC_AUDIT_DATA_INIT(&ad, IPC);
+ 	ad.u.ipc_id = msq->q_perm.key;
+
+	rc = avc_has_perm(tsec->sid, isec->sid,
+			  SECCLASS_MSGQ, MSGQ__READ,
+			  &isec->avcr, &ad);
+	if (!rc)
+		rc = avc_has_perm(tsec->sid, msec->sid,
+				  SECCLASS_MSG, MSG__RECEIVE,
+				  &msec->avcr, &ad);
+	return rc;
+}
+
+/* Shared Memory security operations */
+static int selinux_shm_alloc_security(struct shmid_kernel *shp)
+{
+	struct task_security_struct *tsec;
+	struct ipc_security_struct *isec;
+	struct avc_audit_data ad;
+	int rc;
+
+	rc = ipc_alloc_security(current, &shp->shm_perm, SECCLASS_SHM);
+	if (rc)
+		return rc;
+
+	tsec = current->security;
+	isec = shp->shm_perm.security;
+
+	AVC_AUDIT_DATA_INIT(&ad, IPC);
+ 	ad.u.ipc_id = shp->shm_perm.key;
+
+	rc = avc_has_perm(tsec->sid, isec->sid, SECCLASS_SHM,
+			  SHM__CREATE, &isec->avcr, &ad);
+	if (rc) {
+		ipc_free_security(&shp->shm_perm);
+		return rc;
+	}
+	return 0;
+}
+
+static void selinux_shm_free_security(struct shmid_kernel *shp)
+{
+	ipc_free_security(&shp->shm_perm);
+}
+
+static int selinux_shm_associate(struct shmid_kernel *shp, int shmflg)
+{
+	struct task_security_struct *tsec;
+	struct ipc_security_struct *isec;
+	struct avc_audit_data ad;
+
+	tsec = current->security;
+	isec = shp->shm_perm.security;
+
+	AVC_AUDIT_DATA_INIT(&ad, IPC);
+	ad.u.ipc_id = shp->shm_perm.key;
+
+	return avc_has_perm(tsec->sid, isec->sid, SECCLASS_SHM,
+			    SHM__ASSOCIATE, &isec->avcr, &ad);
+}
+
+/* Note, at this point, shp is locked down */
+static int selinux_shm_shmctl(struct shmid_kernel *shp, int cmd)
+{
+	int perms;
+	int err;
+
+	switch(cmd) {
+	case IPC_INFO:
+	case SHM_INFO:
+		/* No specific object, just general system-wide information. */
+		return task_has_system(current, SYSTEM__IPC_INFO);
+	case IPC_STAT:
+	case SHM_STAT:
+		perms = SHM__GETATTR | SHM__ASSOCIATE;
+		break;
+	case IPC_SET:
+		perms = SHM__SETATTR;
+		break;
+	case SHM_LOCK:
+	case SHM_UNLOCK:
+		perms = SHM__LOCK;
+		break;
+	case IPC_RMID:
+		perms = SHM__DESTROY;
+		break;
+	default:
+		return 0;
+	}
+
+	err = ipc_has_perm(&shp->shm_perm, SECCLASS_SHM, perms);
+	return err;
+}
+
+static int selinux_shm_shmat(struct shmid_kernel *shp,
+			     char *shmaddr, int shmflg)
+{
+	u32 perms;
+
+	if (shmflg & SHM_RDONLY)
+		perms = SHM__READ;
+	else
+		perms = SHM__READ | SHM__WRITE;
+
+	return ipc_has_perm(&shp->shm_perm, SECCLASS_SHM, perms);
+}
+
+/* Semaphore security operations */
+static int selinux_sem_alloc_security(struct sem_array *sma)
+{
+	struct task_security_struct *tsec;
+	struct ipc_security_struct *isec;
+	struct avc_audit_data ad;
+	int rc;
+
+	rc = ipc_alloc_security(current, &sma->sem_perm, SECCLASS_SEM);
+	if (rc)
+		return rc;
+
+	tsec = current->security;
+	isec = sma->sem_perm.security;
+
+	AVC_AUDIT_DATA_INIT(&ad, IPC);
+ 	ad.u.ipc_id = sma->sem_perm.key;
+
+	rc = avc_has_perm(tsec->sid, isec->sid, SECCLASS_SEM,
+			  SEM__CREATE, &isec->avcr, &ad);
+	if (rc) {
+		ipc_free_security(&sma->sem_perm);
+		return rc;
+	}
+	return 0;
+}
+
+static void selinux_sem_free_security(struct sem_array *sma)
+{
+	ipc_free_security(&sma->sem_perm);
+}
+
+static int selinux_sem_associate(struct sem_array *sma, int semflg)
+{
+	struct task_security_struct *tsec;
+	struct ipc_security_struct *isec;
+	struct avc_audit_data ad;
+
+	tsec = current->security;
+	isec = sma->sem_perm.security;
+
+	AVC_AUDIT_DATA_INIT(&ad, IPC);
+	ad.u.ipc_id = sma->sem_perm.key;
+
+	return avc_has_perm(tsec->sid, isec->sid, SECCLASS_SEM,
+			    SEM__ASSOCIATE, &isec->avcr, &ad);
+}
+
+/* Note, at this point, sma is locked down */
+static int selinux_sem_semctl(struct sem_array *sma, int cmd)
+{
+	int err;
+	u32 perms;
+
+	switch(cmd) {
+	case IPC_INFO:
+	case SEM_INFO:
+		/* No specific object, just general system-wide information. */
+		return task_has_system(current, SYSTEM__IPC_INFO);
+	case GETPID:
+	case GETNCNT:
+	case GETZCNT:
+		perms = SEM__GETATTR;
+		break;
+	case GETVAL:
+	case GETALL:
+		perms = SEM__READ;
+		break;
+	case SETVAL:
+	case SETALL:
+		perms = SEM__WRITE;
+		break;
+	case IPC_RMID:
+		perms = SEM__DESTROY;
+		break;
+	case IPC_SET:
+		perms = SEM__SETATTR;
+		break;
+	case IPC_STAT:
+	case SEM_STAT:
+		perms = SEM__GETATTR | SEM__ASSOCIATE;
+		break;
+	default:
+		return 0;
+	}
+
+	err = ipc_has_perm(&sma->sem_perm, SECCLASS_SEM, perms);
+	return err;
+}
+
+static int selinux_sem_semop(struct sem_array *sma,
+			     struct sembuf *sops, unsigned nsops, int alter)
+{
+	u32 perms;
+
+	if (alter)
+		perms = SEM__READ | SEM__WRITE;
+	else
+		perms = SEM__READ;
+
+	return ipc_has_perm(&sma->sem_perm, SECCLASS_SEM, perms);
+}
+
+static int selinux_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
+{
+	struct ipc_security_struct *isec = ipcp->security;
+	u16 sclass = SECCLASS_IPC;
+	u32 av = 0;
+
+	if (isec && isec->magic == SELINUX_MAGIC)
+		sclass = isec->sclass;
+
+	av = 0;
+	if (flag & S_IRUGO)
+		av |= IPC__UNIX_READ;
+	if (flag & S_IWUGO)
+		av |= IPC__UNIX_WRITE;
+
+	if (av == 0)
+		return 0;
+
+	return ipc_has_perm(ipcp, sclass, av);
+}
+
+/* module stacking operations */
+int selinux_register_security (const char *name, struct security_operations *ops)
+{
+	if (secondary_ops != original_ops) {
+		printk(KERN_INFO "%s:  There is already a secondary security "
+		       "module registered.\n", __FUNCTION__);
+		return -EINVAL;
+ 	}
+
+	secondary_ops = ops;
+
+	printk(KERN_INFO "%s:  Registering secondary module %s\n",
+	       __FUNCTION__,
+	       name);
+
+	return 0;
+}
+
+int selinux_unregister_security (const char *name, struct security_operations *ops)
+{
+	if (ops != secondary_ops) {
+		printk (KERN_INFO "%s:  trying to unregister a security module "
+		        "that is not registered.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	secondary_ops = original_ops;
+
+	return 0;
+}
+
+static void selinux_d_instantiate (struct dentry *dentry, struct inode *inode)
+{
+	if (inode)
+		inode_doinit_with_dentry(inode, dentry);
+}
+
+static int selinux_getprocattr(struct task_struct *p,
+			       char *name, void *value, size_t size)
+{
+	struct task_security_struct *tsec;
+	u32 sid, len;
+	char *context;
+	int error;
+
+	if (current != p) {
+		error = task_has_perm(current, p, PROCESS__GETATTR);
+		if (error)
+			return error;
+	}
+
+	if (!size)
+		return -ERANGE;
+
+	tsec = p->security;
+
+	if (!strcmp(name, "current"))
+		sid = tsec->sid;
+	else if (!strcmp(name, "prev"))
+		sid = tsec->osid;
+	else if (!strcmp(name, "exec"))
+		sid = tsec->exec_sid;
+	else if (!strcmp(name, "fscreate"))
+		sid = tsec->create_sid;
+	else
+		return -EINVAL;
+
+	if (!sid)
+		return 0;
+
+	error = security_sid_to_context(sid, &context, &len);
+	if (error)
+		return error;
+	if (len > size) {
+		kfree(context);
+		return -ERANGE;
+	}
+	memcpy(value, context, len);
+	kfree(context);
+	return len;
+}
+
+static int selinux_setprocattr(struct task_struct *p,
+			       char *name, void *value, size_t size)
+{
+	struct task_security_struct *tsec;
+	u32 sid = 0;
+	int error;
+
+	if (current != p || !strcmp(name, "current")) {
+		/* SELinux only allows a process to change its own
+		   security attributes, and it only allows the process
+		   current SID to change via exec. */
+		return -EACCES;
+	}
+
+	/*
+	 * Basic control over ability to set these attributes at all.
+	 * current == p, but we'll pass them separately in case the
+	 * above restriction is ever removed.
+	 */
+	if (!strcmp(name, "exec"))
+		error = task_has_perm(current, p, PROCESS__SETEXEC);
+	else if (!strcmp(name, "fscreate"))
+		error = task_has_perm(current, p, PROCESS__SETFSCREATE);
+	else
+		error = -EINVAL;
+	if (error)
+		return error;
+
+	/* Obtain a SID for the context, if one was specified. */
+	if (size) {
+		int error;
+		error = security_context_to_sid(value, size, &sid);
+		if (error)
+			return error;
+	}
+
+	/* Permission checking based on the specified context is
+	   performed during the actual operation (execve,
+	   open/mkdir/...), when we know the full context of the
+	   operation.  See selinux_bprm_set_security for the execve
+	   checks and may_create for the file creation checks. The
+	   operation will then fail if the context is not permitted. */
+	tsec = p->security;
+	if (!strcmp(name, "exec"))
+		tsec->exec_sid = sid;
+	else if (!strcmp(name, "fscreate"))
+		tsec->create_sid = sid;
+	else
+		return -EINVAL;
+
+	return size;
+}
+
+struct security_operations selinux_ops = {
+	.ptrace =			selinux_ptrace,
+	.capget =			selinux_capget,
+	.capset_check =			selinux_capset_check,
+	.capset_set =			selinux_capset_set,
+	.sysctl =			selinux_sysctl,
+	.capable =			selinux_capable,
+	.quotactl =			selinux_quotactl,
+	.quota_on =			selinux_quota_on,
+	.syslog =			selinux_syslog,
+	
+	.netlink_send =			selinux_netlink_send,
+        .netlink_recv =			selinux_netlink_recv,
+
+	.bprm_alloc_security =		selinux_bprm_alloc_security,
+	.bprm_free_security =		selinux_bprm_free_security,
+	.bprm_compute_creds =		selinux_bprm_compute_creds,
+	.bprm_set_security =		selinux_bprm_set_security,
+	.bprm_check_security =		selinux_bprm_check_security,
+	.bprm_secureexec =		selinux_bprm_secureexec,
+
+	.sb_alloc_security =		selinux_sb_alloc_security,
+	.sb_free_security =		selinux_sb_free_security,
+	.sb_kern_mount =	        selinux_sb_kern_mount,
+	.sb_statfs =			selinux_sb_statfs,
+	.sb_mount =			selinux_mount,
+	.sb_umount =			selinux_umount,
+
+	.inode_alloc_security =		selinux_inode_alloc_security,
+	.inode_free_security =		selinux_inode_free_security,
+	.inode_create =			selinux_inode_create,
+	.inode_post_create =		selinux_inode_post_create,
+	.inode_link =			selinux_inode_link,
+	.inode_post_link =		selinux_inode_post_link,
+	.inode_unlink =			selinux_inode_unlink,
+	.inode_symlink =		selinux_inode_symlink,
+	.inode_post_symlink =		selinux_inode_post_symlink,
+	.inode_mkdir =			selinux_inode_mkdir,
+	.inode_post_mkdir =		selinux_inode_post_mkdir,
+	.inode_rmdir =			selinux_inode_rmdir,
+	.inode_mknod =			selinux_inode_mknod,
+	.inode_post_mknod =		selinux_inode_post_mknod,
+	.inode_rename =			selinux_inode_rename,
+	.inode_post_rename =		selinux_inode_post_rename,
+	.inode_readlink =		selinux_inode_readlink,
+	.inode_follow_link =		selinux_inode_follow_link,
+	.inode_permission =		selinux_inode_permission,
+	.inode_setattr =		selinux_inode_setattr,
+	.inode_stat =			selinux_inode_stat,
+	.inode_setxattr =		selinux_inode_setxattr,
+	.inode_post_setxattr =		selinux_inode_post_setxattr,
+	.inode_getxattr =		selinux_inode_getxattr,
+	.inode_listxattr =		selinux_inode_listxattr,
+	.inode_removexattr =		selinux_inode_removexattr,
+	.inode_getsecurity =            selinux_inode_getsecurity,
+	.inode_setsecurity =            selinux_inode_setsecurity,
+	.inode_listsecurity =           selinux_inode_listsecurity,
+
+	.file_permission =		selinux_file_permission,
+	.file_alloc_security =		selinux_file_alloc_security,
+	.file_free_security =		selinux_file_free_security,
+	.file_ioctl =			selinux_file_ioctl,
+	.file_mmap =			selinux_file_mmap,
+	.file_mprotect =		selinux_file_mprotect,
+	.file_lock =			selinux_file_lock,
+	.file_fcntl =			selinux_file_fcntl,
+	.file_set_fowner =		selinux_file_set_fowner,
+	.file_send_sigiotask =		selinux_file_send_sigiotask,
+	.file_receive =			selinux_file_receive,
+
+	.task_create =			selinux_task_create,
+	.task_alloc_security =		selinux_task_alloc_security,
+	.task_free_security =		selinux_task_free_security,
+	.task_setuid =			selinux_task_setuid,
+	.task_post_setuid =		selinux_task_post_setuid,
+	.task_setgid =			selinux_task_setgid,
+	.task_setpgid =			selinux_task_setpgid,
+	.task_getpgid =			selinux_task_getpgid,
+	.task_getsid =		        selinux_task_getsid,
+	.task_setgroups =		selinux_task_setgroups,
+	.task_setnice =			selinux_task_setnice,
+	.task_setrlimit =		selinux_task_setrlimit,
+	.task_setscheduler =		selinux_task_setscheduler,
+	.task_getscheduler =		selinux_task_getscheduler,
+	.task_kill =			selinux_task_kill,
+	.task_wait =			selinux_task_wait,
+	.task_prctl =			selinux_task_prctl,
+	.task_kmod_set_label =		selinux_task_kmod_set_label,
+	.task_reparent_to_init =	selinux_task_reparent_to_init,
+	.task_to_inode =                selinux_task_to_inode,
+
+	.ipc_permission =		selinux_ipc_permission,
+
+	.msg_msg_alloc_security =	selinux_msg_msg_alloc_security,
+	.msg_msg_free_security =	selinux_msg_msg_free_security,
+
+	.msg_queue_alloc_security =	selinux_msg_queue_alloc_security,
+	.msg_queue_free_security =	selinux_msg_queue_free_security,
+	.msg_queue_associate =		selinux_msg_queue_associate,
+	.msg_queue_msgctl =		selinux_msg_queue_msgctl,
+	.msg_queue_msgsnd =		selinux_msg_queue_msgsnd,
+	.msg_queue_msgrcv =		selinux_msg_queue_msgrcv,
+
+	.shm_alloc_security =		selinux_shm_alloc_security,
+	.shm_free_security =		selinux_shm_free_security,
+	.shm_associate =		selinux_shm_associate,
+	.shm_shmctl =			selinux_shm_shmctl,
+	.shm_shmat =			selinux_shm_shmat,
+
+	.sem_alloc_security = 		selinux_sem_alloc_security,
+	.sem_free_security =  		selinux_sem_free_security,
+	.sem_associate =		selinux_sem_associate,
+	.sem_semctl =			selinux_sem_semctl,
+	.sem_semop =			selinux_sem_semop,
+
+	.register_security =		selinux_register_security,
+	.unregister_security =		selinux_unregister_security,
+
+	.d_instantiate =                selinux_d_instantiate,
+
+	.getprocattr =                  selinux_getprocattr,
+	.setprocattr =                  selinux_setprocattr,
+
+#ifdef CONFIG_SECURITY_NETWORK
+        .unix_stream_connect =		selinux_socket_unix_stream_connect,
+	.unix_may_send =		selinux_socket_unix_may_send,
+
+	.socket_create =		selinux_socket_create,
+	.socket_post_create =		selinux_socket_post_create,
+	.socket_bind =			selinux_socket_bind,
+	.socket_connect =		selinux_socket_connect,
+	.socket_listen =		selinux_socket_listen,
+	.socket_accept =		selinux_socket_accept,
+	.socket_sendmsg =		selinux_socket_sendmsg,
+	.socket_recvmsg =		selinux_socket_recvmsg,
+	.socket_getsockname =		selinux_socket_getsockname,
+	.socket_getpeername =		selinux_socket_getpeername,
+	.socket_getsockopt =		selinux_socket_getsockopt,
+	.socket_setsockopt =		selinux_socket_setsockopt,
+	.socket_shutdown =		selinux_socket_shutdown,
+#endif
+};
+
+__init int selinux_init(void)
+{
+	struct task_security_struct *tsec;
+
+	if (!selinux_enabled) {
+		printk(KERN_INFO "SELinux:  Disabled at boot.\n");
+		return 0;
+	}
+
+	printk(KERN_INFO "SELinux:  Initializing.\n");
+
+	/* Set the security state for the initial task. */
+	if (task_alloc_security(current))
+		panic("SELinux:  Failed to initialize initial task.\n");
+	tsec = current->security;
+	tsec->osid = tsec->sid = SECINITSID_KERNEL;
+
+	avc_init();
+
+	original_ops = secondary_ops = security_ops;
+	if (!secondary_ops)
+		panic ("SELinux: No initial security operations\n");
+	if (register_security (&selinux_ops))
+		panic("SELinux: Unable to register with kernel.\n");
+
+	if (selinux_enforcing) {
+		printk(KERN_INFO "SELinux:  Starting in enforcing mode\n");
+	} else {
+		printk(KERN_INFO "SELinux:  Starting in permissive mode\n");
+	}
+	return 0;
+}
+
+void selinux_complete_init(void)
+{
+	printk(KERN_INFO "SELinux:  Completing initialization.\n");
+
+	/* Set up any superblocks initialized prior to the policy load. */
+	printk(KERN_INFO "SELinux:  Setting up existing superblocks.\n");
+	spin_lock(&sb_security_lock);
+next_sb:
+	if (!list_empty(&superblock_security_head)) {
+		struct superblock_security_struct *sbsec =
+				list_entry(superblock_security_head.next,
+				           struct superblock_security_struct,
+				           list);
+		struct super_block *sb = sbsec->sb;
+		spin_lock(&sb_lock);
+		sb->s_count++;
+		spin_unlock(&sb_lock);
+		spin_unlock(&sb_security_lock);
+		down_read(&sb->s_umount);
+		if (sb->s_root)
+			superblock_doinit(sb);
+		drop_super(sb);
+		spin_lock(&sb_security_lock);
+		list_del_init(&sbsec->list);
+		goto next_sb;
+	}
+	spin_unlock(&sb_security_lock);
+}
+
+/* SELinux requires early initialization in order to label
+   all processes and objects when they are created. */
+security_initcall(selinux_init);
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/avc.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/avc.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/avc.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/avc.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,159 @@
+/*
+ * Access vector cache interface for object managers.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SELINUX_AVC_H_
+#define _SELINUX_AVC_H_
+
+#include <linux/stddef.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/kdev_t.h>
+#include <linux/spinlock.h>
+#include <asm/system.h>
+#include "flask.h"
+#include "av_permissions.h"
+#include "security.h"
+
+#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
+extern int selinux_enforcing;
+#else
+#define selinux_enforcing 1
+#endif
+
+/*
+ * An entry in the AVC.
+ */
+struct avc_entry;
+
+/*
+ * A reference to an AVC entry.
+ */
+struct avc_entry_ref {
+	struct avc_entry *ae;
+};
+
+/* Initialize an AVC entry reference before first use. */
+static inline void avc_entry_ref_init(struct avc_entry_ref *h)
+{
+	h->ae = NULL;
+}
+
+struct task_struct;
+struct vfsmount;
+struct dentry;
+struct inode;
+struct sock;
+struct sk_buff;
+
+/* Auxiliary data to use in generating the audit record. */
+struct avc_audit_data {
+	char    type;
+#define AVC_AUDIT_DATA_FS   1
+#define AVC_AUDIT_DATA_NET  2
+#define AVC_AUDIT_DATA_CAP  3
+#define AVC_AUDIT_DATA_IPC  4
+	struct task_struct *tsk;
+	union 	{
+		struct {
+			struct vfsmount *mnt;
+			struct dentry *dentry;
+			struct inode *inode;
+		} fs;
+		struct {
+			char *netif;
+			struct sk_buff *skb;
+			struct sock *sk;
+			u16 port;
+			u32 daddr;
+		} net;
+		int cap;
+		int ipc_id;
+	} u;
+};
+
+/* Initialize an AVC audit data structure. */
+#define AVC_AUDIT_DATA_INIT(_d,_t) \
+        { memset((_d), 0, sizeof(struct avc_audit_data)); (_d)->type = AVC_AUDIT_DATA_##_t; }
+
+/*
+ * AVC statistics
+ */
+#define AVC_ENTRY_LOOKUPS        0
+#define AVC_ENTRY_HITS	         1
+#define AVC_ENTRY_MISSES         2
+#define AVC_ENTRY_DISCARDS       3
+#define AVC_CAV_LOOKUPS          4
+#define AVC_CAV_HITS             5
+#define AVC_CAV_PROBES           6
+#define AVC_CAV_MISSES           7
+#define AVC_NSTATS               8
+extern unsigned avc_cache_stats[AVC_NSTATS];
+
+#ifdef AVC_CACHE_STATS
+static inline void avc_cache_stats_incr(int type)
+{
+	avc_cache_stats[type]++;
+}
+
+static inline void avc_cache_stats_add(int type, unsigned val)
+{
+	avc_cache_stats[type] += val;
+}
+#else
+static inline void avc_cache_stats_incr(int type)
+{ }
+
+static inline void avc_cache_stats_add(int type, unsigned val)
+{ }
+#endif
+
+/*
+ * AVC display support
+ */
+void avc_dump_av(u16 tclass, u32 av);
+void avc_dump_query(u32 ssid, u32 tsid, u16 tclass);
+void avc_dump_cache(char *tag);
+
+/*
+ * AVC operations
+ */
+
+void avc_init(void);
+
+int avc_lookup(u32 ssid, u32 tsid, u16 tclass,
+               u32 requested, struct avc_entry_ref *aeref);
+
+int avc_insert(u32 ssid, u32 tsid, u16 tclass,
+               struct avc_entry *ae, struct avc_entry_ref *out_aeref);
+
+void avc_audit(u32 ssid, u32 tsid,
+               u16 tclass, u32 requested,
+               struct av_decision *avd, int result, struct avc_audit_data *auditdata);
+
+int avc_has_perm_noaudit(u32 ssid, u32 tsid,
+                         u16 tclass, u32 requested,
+                         struct avc_entry_ref *aeref, struct av_decision *avd);
+
+int avc_has_perm(u32 ssid, u32 tsid,
+                 u16 tclass, u32 requested,
+                 struct avc_entry_ref *aeref, struct avc_audit_data *auditdata);
+
+#define AVC_CALLBACK_GRANT		1
+#define AVC_CALLBACK_TRY_REVOKE		2
+#define AVC_CALLBACK_REVOKE		4
+#define AVC_CALLBACK_RESET		8
+#define AVC_CALLBACK_AUDITALLOW_ENABLE	16
+#define AVC_CALLBACK_AUDITALLOW_DISABLE	32
+#define AVC_CALLBACK_AUDITDENY_ENABLE	64
+#define AVC_CALLBACK_AUDITDENY_DISABLE	128
+
+int avc_add_callback(int (*callback)(u32 event, u32 ssid, u32 tsid,
+                                     u16 tclass, u32 perms,
+				     u32 *out_retained),
+		     u32 events, u32 ssid, u32 tsid,
+		     u16 tclass, u32 perms);
+
+#endif /* _SELINUX_AVC_H_ */
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/avc_ss.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/avc_ss.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/avc_ss.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/avc_ss.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,27 @@
+/*
+ * Access vector cache interface for the security server.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SELINUX_AVC_SS_H_
+#define _SELINUX_AVC_SS_H_
+
+#include "flask.h"
+
+int avc_ss_grant(u32 ssid, u32 tsid, u16 tclass, u32 perms, u32 seqno);
+
+int avc_ss_try_revoke(u32 ssid, u32 tsid, u16 tclass, u32 perms, u32 seqno,
+		      u32 *out_retained);
+
+int avc_ss_revoke(u32 ssid, u32 tsid, u16 tclass, u32 perms, u32 seqno);
+
+int avc_ss_reset(u32 seqno);
+
+int avc_ss_set_auditallow(u32 ssid, u32 tsid, u16 tclass, u32 perms,
+			  u32 seqno, u32 enable);
+
+int avc_ss_set_auditdeny(u32 ssid, u32 tsid, u16 tclass, u32 perms,
+			 u32 seqno, u32 enable);
+
+#endif /* _SELINUX_AVC_SS_H_ */
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/av_inherit.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/av_inherit.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/av_inherit.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/av_inherit.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,35 @@
+/* This file is automatically generated.  Do not edit. */
+/* FLASK */
+
+struct av_inherit
+{
+    u16 tclass;
+    char **common_pts;
+    u32 common_base;
+};
+
+static struct av_inherit av_inherit[] = {
+   { SECCLASS_DIR, common_file_perm_to_string, 0x00020000UL },
+   { SECCLASS_FILE, common_file_perm_to_string, 0x00020000UL },
+   { SECCLASS_LNK_FILE, common_file_perm_to_string, 0x00020000UL },
+   { SECCLASS_CHR_FILE, common_file_perm_to_string, 0x00020000UL },
+   { SECCLASS_BLK_FILE, common_file_perm_to_string, 0x00020000UL },
+   { SECCLASS_SOCK_FILE, common_file_perm_to_string, 0x00020000UL },
+   { SECCLASS_FIFO_FILE, common_file_perm_to_string, 0x00020000UL },
+   { SECCLASS_SOCKET, common_socket_perm_to_string, 0x00400000UL },
+   { SECCLASS_TCP_SOCKET, common_socket_perm_to_string, 0x00400000UL },
+   { SECCLASS_UDP_SOCKET, common_socket_perm_to_string, 0x00400000UL },
+   { SECCLASS_RAWIP_SOCKET, common_socket_perm_to_string, 0x00400000UL },
+   { SECCLASS_NETLINK_SOCKET, common_socket_perm_to_string, 0x00400000UL },
+   { SECCLASS_PACKET_SOCKET, common_socket_perm_to_string, 0x00400000UL },
+   { SECCLASS_KEY_SOCKET, common_socket_perm_to_string, 0x00400000UL },
+   { SECCLASS_UNIX_STREAM_SOCKET, common_socket_perm_to_string, 0x00400000UL },
+   { SECCLASS_UNIX_DGRAM_SOCKET, common_socket_perm_to_string, 0x00400000UL },
+   { SECCLASS_IPC, common_ipc_perm_to_string, 0x00000200UL },
+   { SECCLASS_SEM, common_ipc_perm_to_string, 0x00000200UL },
+   { SECCLASS_MSGQ, common_ipc_perm_to_string, 0x00000200UL },
+   { SECCLASS_SHM, common_ipc_perm_to_string, 0x00000200UL },
+};
+
+
+/* FLASK */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/av_permissions.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/av_permissions.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/av_permissions.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/av_permissions.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,550 @@
+/* This file is automatically generated.  Do not edit. */
+/* FLASK */
+
+#define COMMON_FILE__IOCTL                               0x00000001UL
+#define COMMON_FILE__READ                                0x00000002UL
+#define COMMON_FILE__WRITE                               0x00000004UL
+#define COMMON_FILE__CREATE                              0x00000008UL
+#define COMMON_FILE__GETATTR                             0x00000010UL
+#define COMMON_FILE__SETATTR                             0x00000020UL
+#define COMMON_FILE__LOCK                                0x00000040UL
+#define COMMON_FILE__RELABELFROM                         0x00000080UL
+#define COMMON_FILE__RELABELTO                           0x00000100UL
+#define COMMON_FILE__APPEND                              0x00000200UL
+#define COMMON_FILE__UNLINK                              0x00000400UL
+#define COMMON_FILE__LINK                                0x00000800UL
+#define COMMON_FILE__RENAME                              0x00001000UL
+#define COMMON_FILE__EXECUTE                             0x00002000UL
+#define COMMON_FILE__SWAPON                              0x00004000UL
+#define COMMON_FILE__QUOTAON                             0x00008000UL
+#define COMMON_FILE__MOUNTON                             0x00010000UL
+
+#define COMMON_SOCKET__IOCTL                             0x00000001UL
+#define COMMON_SOCKET__READ                              0x00000002UL
+#define COMMON_SOCKET__WRITE                             0x00000004UL
+#define COMMON_SOCKET__CREATE                            0x00000008UL
+#define COMMON_SOCKET__GETATTR                           0x00000010UL
+#define COMMON_SOCKET__SETATTR                           0x00000020UL
+#define COMMON_SOCKET__LOCK                              0x00000040UL
+#define COMMON_SOCKET__RELABELFROM                       0x00000080UL
+#define COMMON_SOCKET__RELABELTO                         0x00000100UL
+#define COMMON_SOCKET__APPEND                            0x00000200UL
+#define COMMON_SOCKET__BIND                              0x00000400UL
+#define COMMON_SOCKET__CONNECT                           0x00000800UL
+#define COMMON_SOCKET__LISTEN                            0x00001000UL
+#define COMMON_SOCKET__ACCEPT                            0x00002000UL
+#define COMMON_SOCKET__GETOPT                            0x00004000UL
+#define COMMON_SOCKET__SETOPT                            0x00008000UL
+#define COMMON_SOCKET__SHUTDOWN                          0x00010000UL
+#define COMMON_SOCKET__RECVFROM                          0x00020000UL
+#define COMMON_SOCKET__SENDTO                            0x00040000UL
+#define COMMON_SOCKET__RECV_MSG                          0x00080000UL
+#define COMMON_SOCKET__SEND_MSG                          0x00100000UL
+#define COMMON_SOCKET__NAME_BIND                         0x00200000UL
+
+#define COMMON_IPC__CREATE                               0x00000001UL
+#define COMMON_IPC__DESTROY                              0x00000002UL
+#define COMMON_IPC__GETATTR                              0x00000004UL
+#define COMMON_IPC__SETATTR                              0x00000008UL
+#define COMMON_IPC__READ                                 0x00000010UL
+#define COMMON_IPC__WRITE                                0x00000020UL
+#define COMMON_IPC__ASSOCIATE                            0x00000040UL
+#define COMMON_IPC__UNIX_READ                            0x00000080UL
+#define COMMON_IPC__UNIX_WRITE                           0x00000100UL
+
+#define FILESYSTEM__MOUNT                         0x00000001UL
+#define FILESYSTEM__REMOUNT                       0x00000002UL
+#define FILESYSTEM__UNMOUNT                       0x00000004UL
+#define FILESYSTEM__GETATTR                       0x00000008UL
+#define FILESYSTEM__RELABELFROM                   0x00000010UL
+#define FILESYSTEM__RELABELTO                     0x00000020UL
+#define FILESYSTEM__TRANSITION                    0x00000040UL
+#define FILESYSTEM__ASSOCIATE                     0x00000080UL
+#define FILESYSTEM__QUOTAMOD                      0x00000100UL
+#define FILESYSTEM__QUOTAGET                      0x00000200UL
+
+#define DIR__EXECUTE                              0x00002000UL
+#define DIR__UNLINK                               0x00000400UL
+#define DIR__SETATTR                              0x00000020UL
+#define DIR__QUOTAON                              0x00008000UL
+#define DIR__RELABELFROM                          0x00000080UL
+#define DIR__LINK                                 0x00000800UL
+#define DIR__WRITE                                0x00000004UL
+#define DIR__IOCTL                                0x00000001UL
+#define DIR__RELABELTO                            0x00000100UL
+#define DIR__READ                                 0x00000002UL
+#define DIR__RENAME                               0x00001000UL
+#define DIR__APPEND                               0x00000200UL
+#define DIR__LOCK                                 0x00000040UL
+#define DIR__SWAPON                               0x00004000UL
+#define DIR__GETATTR                              0x00000010UL
+#define DIR__MOUNTON                              0x00010000UL
+#define DIR__CREATE                               0x00000008UL
+
+#define DIR__ADD_NAME                             0x00020000UL
+#define DIR__REMOVE_NAME                          0x00040000UL
+#define DIR__REPARENT                             0x00080000UL
+#define DIR__SEARCH                               0x00100000UL
+#define DIR__RMDIR                                0x00200000UL
+
+#define FILE__EXECUTE                             0x00002000UL
+#define FILE__UNLINK                              0x00000400UL
+#define FILE__SETATTR                             0x00000020UL
+#define FILE__QUOTAON                             0x00008000UL
+#define FILE__RELABELFROM                         0x00000080UL
+#define FILE__LINK                                0x00000800UL
+#define FILE__WRITE                               0x00000004UL
+#define FILE__IOCTL                               0x00000001UL
+#define FILE__RELABELTO                           0x00000100UL
+#define FILE__READ                                0x00000002UL
+#define FILE__RENAME                              0x00001000UL
+#define FILE__APPEND                              0x00000200UL
+#define FILE__LOCK                                0x00000040UL
+#define FILE__SWAPON                              0x00004000UL
+#define FILE__GETATTR                             0x00000010UL
+#define FILE__MOUNTON                             0x00010000UL
+#define FILE__CREATE                              0x00000008UL
+
+#define FILE__EXECUTE_NO_TRANS                    0x00020000UL
+#define FILE__ENTRYPOINT                          0x00040000UL
+
+#define LNK_FILE__EXECUTE                         0x00002000UL
+#define LNK_FILE__UNLINK                          0x00000400UL
+#define LNK_FILE__SETATTR                         0x00000020UL
+#define LNK_FILE__QUOTAON                         0x00008000UL
+#define LNK_FILE__RELABELFROM                     0x00000080UL
+#define LNK_FILE__LINK                            0x00000800UL
+#define LNK_FILE__WRITE                           0x00000004UL
+#define LNK_FILE__IOCTL                           0x00000001UL
+#define LNK_FILE__RELABELTO                       0x00000100UL
+#define LNK_FILE__READ                            0x00000002UL
+#define LNK_FILE__RENAME                          0x00001000UL
+#define LNK_FILE__APPEND                          0x00000200UL
+#define LNK_FILE__LOCK                            0x00000040UL
+#define LNK_FILE__SWAPON                          0x00004000UL
+#define LNK_FILE__GETATTR                         0x00000010UL
+#define LNK_FILE__MOUNTON                         0x00010000UL
+#define LNK_FILE__CREATE                          0x00000008UL
+
+#define CHR_FILE__EXECUTE                         0x00002000UL
+#define CHR_FILE__UNLINK                          0x00000400UL
+#define CHR_FILE__SETATTR                         0x00000020UL
+#define CHR_FILE__QUOTAON                         0x00008000UL
+#define CHR_FILE__RELABELFROM                     0x00000080UL
+#define CHR_FILE__LINK                            0x00000800UL
+#define CHR_FILE__WRITE                           0x00000004UL
+#define CHR_FILE__IOCTL                           0x00000001UL
+#define CHR_FILE__RELABELTO                       0x00000100UL
+#define CHR_FILE__READ                            0x00000002UL
+#define CHR_FILE__RENAME                          0x00001000UL
+#define CHR_FILE__APPEND                          0x00000200UL
+#define CHR_FILE__LOCK                            0x00000040UL
+#define CHR_FILE__SWAPON                          0x00004000UL
+#define CHR_FILE__GETATTR                         0x00000010UL
+#define CHR_FILE__MOUNTON                         0x00010000UL
+#define CHR_FILE__CREATE                          0x00000008UL
+
+#define BLK_FILE__EXECUTE                         0x00002000UL
+#define BLK_FILE__UNLINK                          0x00000400UL
+#define BLK_FILE__SETATTR                         0x00000020UL
+#define BLK_FILE__QUOTAON                         0x00008000UL
+#define BLK_FILE__RELABELFROM                     0x00000080UL
+#define BLK_FILE__LINK                            0x00000800UL
+#define BLK_FILE__WRITE                           0x00000004UL
+#define BLK_FILE__IOCTL                           0x00000001UL
+#define BLK_FILE__RELABELTO                       0x00000100UL
+#define BLK_FILE__READ                            0x00000002UL
+#define BLK_FILE__RENAME                          0x00001000UL
+#define BLK_FILE__APPEND                          0x00000200UL
+#define BLK_FILE__LOCK                            0x00000040UL
+#define BLK_FILE__SWAPON                          0x00004000UL
+#define BLK_FILE__GETATTR                         0x00000010UL
+#define BLK_FILE__MOUNTON                         0x00010000UL
+#define BLK_FILE__CREATE                          0x00000008UL
+
+#define SOCK_FILE__EXECUTE                        0x00002000UL
+#define SOCK_FILE__UNLINK                         0x00000400UL
+#define SOCK_FILE__SETATTR                        0x00000020UL
+#define SOCK_FILE__QUOTAON                        0x00008000UL
+#define SOCK_FILE__RELABELFROM                    0x00000080UL
+#define SOCK_FILE__LINK                           0x00000800UL
+#define SOCK_FILE__WRITE                          0x00000004UL
+#define SOCK_FILE__IOCTL                          0x00000001UL
+#define SOCK_FILE__RELABELTO                      0x00000100UL
+#define SOCK_FILE__READ                           0x00000002UL
+#define SOCK_FILE__RENAME                         0x00001000UL
+#define SOCK_FILE__APPEND                         0x00000200UL
+#define SOCK_FILE__LOCK                           0x00000040UL
+#define SOCK_FILE__SWAPON                         0x00004000UL
+#define SOCK_FILE__GETATTR                        0x00000010UL
+#define SOCK_FILE__MOUNTON                        0x00010000UL
+#define SOCK_FILE__CREATE                         0x00000008UL
+
+#define FIFO_FILE__EXECUTE                        0x00002000UL
+#define FIFO_FILE__UNLINK                         0x00000400UL
+#define FIFO_FILE__SETATTR                        0x00000020UL
+#define FIFO_FILE__QUOTAON                        0x00008000UL
+#define FIFO_FILE__RELABELFROM                    0x00000080UL
+#define FIFO_FILE__LINK                           0x00000800UL
+#define FIFO_FILE__WRITE                          0x00000004UL
+#define FIFO_FILE__IOCTL                          0x00000001UL
+#define FIFO_FILE__RELABELTO                      0x00000100UL
+#define FIFO_FILE__READ                           0x00000002UL
+#define FIFO_FILE__RENAME                         0x00001000UL
+#define FIFO_FILE__APPEND                         0x00000200UL
+#define FIFO_FILE__LOCK                           0x00000040UL
+#define FIFO_FILE__SWAPON                         0x00004000UL
+#define FIFO_FILE__GETATTR                        0x00000010UL
+#define FIFO_FILE__MOUNTON                        0x00010000UL
+#define FIFO_FILE__CREATE                         0x00000008UL
+
+#define FD__USE                                   0x00000001UL
+
+#define SOCKET__RELABELTO                         0x00000100UL
+#define SOCKET__RECV_MSG                          0x00080000UL
+#define SOCKET__RELABELFROM                       0x00000080UL
+#define SOCKET__SETOPT                            0x00008000UL
+#define SOCKET__APPEND                            0x00000200UL
+#define SOCKET__SETATTR                           0x00000020UL
+#define SOCKET__SENDTO                            0x00040000UL
+#define SOCKET__GETOPT                            0x00004000UL
+#define SOCKET__READ                              0x00000002UL
+#define SOCKET__SHUTDOWN                          0x00010000UL
+#define SOCKET__LISTEN                            0x00001000UL
+#define SOCKET__BIND                              0x00000400UL
+#define SOCKET__WRITE                             0x00000004UL
+#define SOCKET__ACCEPT                            0x00002000UL
+#define SOCKET__CONNECT                           0x00000800UL
+#define SOCKET__LOCK                              0x00000040UL
+#define SOCKET__IOCTL                             0x00000001UL
+#define SOCKET__CREATE                            0x00000008UL
+#define SOCKET__NAME_BIND                         0x00200000UL
+#define SOCKET__SEND_MSG                          0x00100000UL
+#define SOCKET__RECVFROM                          0x00020000UL
+#define SOCKET__GETATTR                           0x00000010UL
+
+#define TCP_SOCKET__RELABELTO                     0x00000100UL
+#define TCP_SOCKET__RECV_MSG                      0x00080000UL
+#define TCP_SOCKET__RELABELFROM                   0x00000080UL
+#define TCP_SOCKET__SETOPT                        0x00008000UL
+#define TCP_SOCKET__APPEND                        0x00000200UL
+#define TCP_SOCKET__SETATTR                       0x00000020UL
+#define TCP_SOCKET__SENDTO                        0x00040000UL
+#define TCP_SOCKET__GETOPT                        0x00004000UL
+#define TCP_SOCKET__READ                          0x00000002UL
+#define TCP_SOCKET__SHUTDOWN                      0x00010000UL
+#define TCP_SOCKET__LISTEN                        0x00001000UL
+#define TCP_SOCKET__BIND                          0x00000400UL
+#define TCP_SOCKET__WRITE                         0x00000004UL
+#define TCP_SOCKET__ACCEPT                        0x00002000UL
+#define TCP_SOCKET__CONNECT                       0x00000800UL
+#define TCP_SOCKET__LOCK                          0x00000040UL
+#define TCP_SOCKET__IOCTL                         0x00000001UL
+#define TCP_SOCKET__CREATE                        0x00000008UL
+#define TCP_SOCKET__NAME_BIND                     0x00200000UL
+#define TCP_SOCKET__SEND_MSG                      0x00100000UL
+#define TCP_SOCKET__RECVFROM                      0x00020000UL
+#define TCP_SOCKET__GETATTR                       0x00000010UL
+
+#define TCP_SOCKET__CONNECTTO                     0x00400000UL
+#define TCP_SOCKET__NEWCONN                       0x00800000UL
+#define TCP_SOCKET__ACCEPTFROM                    0x01000000UL
+
+#define UDP_SOCKET__RELABELTO                     0x00000100UL
+#define UDP_SOCKET__RECV_MSG                      0x00080000UL
+#define UDP_SOCKET__RELABELFROM                   0x00000080UL
+#define UDP_SOCKET__SETOPT                        0x00008000UL
+#define UDP_SOCKET__APPEND                        0x00000200UL
+#define UDP_SOCKET__SETATTR                       0x00000020UL
+#define UDP_SOCKET__SENDTO                        0x00040000UL
+#define UDP_SOCKET__GETOPT                        0x00004000UL
+#define UDP_SOCKET__READ                          0x00000002UL
+#define UDP_SOCKET__SHUTDOWN                      0x00010000UL
+#define UDP_SOCKET__LISTEN                        0x00001000UL
+#define UDP_SOCKET__BIND                          0x00000400UL
+#define UDP_SOCKET__WRITE                         0x00000004UL
+#define UDP_SOCKET__ACCEPT                        0x00002000UL
+#define UDP_SOCKET__CONNECT                       0x00000800UL
+#define UDP_SOCKET__LOCK                          0x00000040UL
+#define UDP_SOCKET__IOCTL                         0x00000001UL
+#define UDP_SOCKET__CREATE                        0x00000008UL
+#define UDP_SOCKET__NAME_BIND                     0x00200000UL
+#define UDP_SOCKET__SEND_MSG                      0x00100000UL
+#define UDP_SOCKET__RECVFROM                      0x00020000UL
+#define UDP_SOCKET__GETATTR                       0x00000010UL
+
+#define RAWIP_SOCKET__RELABELTO                   0x00000100UL
+#define RAWIP_SOCKET__RECV_MSG                    0x00080000UL
+#define RAWIP_SOCKET__RELABELFROM                 0x00000080UL
+#define RAWIP_SOCKET__SETOPT                      0x00008000UL
+#define RAWIP_SOCKET__APPEND                      0x00000200UL
+#define RAWIP_SOCKET__SETATTR                     0x00000020UL
+#define RAWIP_SOCKET__SENDTO                      0x00040000UL
+#define RAWIP_SOCKET__GETOPT                      0x00004000UL
+#define RAWIP_SOCKET__READ                        0x00000002UL
+#define RAWIP_SOCKET__SHUTDOWN                    0x00010000UL
+#define RAWIP_SOCKET__LISTEN                      0x00001000UL
+#define RAWIP_SOCKET__BIND                        0x00000400UL
+#define RAWIP_SOCKET__WRITE                       0x00000004UL
+#define RAWIP_SOCKET__ACCEPT                      0x00002000UL
+#define RAWIP_SOCKET__CONNECT                     0x00000800UL
+#define RAWIP_SOCKET__LOCK                        0x00000040UL
+#define RAWIP_SOCKET__IOCTL                       0x00000001UL
+#define RAWIP_SOCKET__CREATE                      0x00000008UL
+#define RAWIP_SOCKET__NAME_BIND                   0x00200000UL
+#define RAWIP_SOCKET__SEND_MSG                    0x00100000UL
+#define RAWIP_SOCKET__RECVFROM                    0x00020000UL
+#define RAWIP_SOCKET__GETATTR                     0x00000010UL
+
+#define NODE__TCP_RECV                            0x00000001UL
+#define NODE__TCP_SEND                            0x00000002UL
+#define NODE__UDP_RECV                            0x00000004UL
+#define NODE__UDP_SEND                            0x00000008UL
+#define NODE__RAWIP_RECV                          0x00000010UL
+#define NODE__RAWIP_SEND                          0x00000020UL
+#define NODE__ENFORCE_DEST                        0x00000040UL
+
+#define NETIF__TCP_RECV                           0x00000001UL
+#define NETIF__TCP_SEND                           0x00000002UL
+#define NETIF__UDP_RECV                           0x00000004UL
+#define NETIF__UDP_SEND                           0x00000008UL
+#define NETIF__RAWIP_RECV                         0x00000010UL
+#define NETIF__RAWIP_SEND                         0x00000020UL
+
+#define NETLINK_SOCKET__RELABELTO                 0x00000100UL
+#define NETLINK_SOCKET__RECV_MSG                  0x00080000UL
+#define NETLINK_SOCKET__RELABELFROM               0x00000080UL
+#define NETLINK_SOCKET__SETOPT                    0x00008000UL
+#define NETLINK_SOCKET__APPEND                    0x00000200UL
+#define NETLINK_SOCKET__SETATTR                   0x00000020UL
+#define NETLINK_SOCKET__SENDTO                    0x00040000UL
+#define NETLINK_SOCKET__GETOPT                    0x00004000UL
+#define NETLINK_SOCKET__READ                      0x00000002UL
+#define NETLINK_SOCKET__SHUTDOWN                  0x00010000UL
+#define NETLINK_SOCKET__LISTEN                    0x00001000UL
+#define NETLINK_SOCKET__BIND                      0x00000400UL
+#define NETLINK_SOCKET__WRITE                     0x00000004UL
+#define NETLINK_SOCKET__ACCEPT                    0x00002000UL
+#define NETLINK_SOCKET__CONNECT                   0x00000800UL
+#define NETLINK_SOCKET__LOCK                      0x00000040UL
+#define NETLINK_SOCKET__IOCTL                     0x00000001UL
+#define NETLINK_SOCKET__CREATE                    0x00000008UL
+#define NETLINK_SOCKET__NAME_BIND                 0x00200000UL
+#define NETLINK_SOCKET__SEND_MSG                  0x00100000UL
+#define NETLINK_SOCKET__RECVFROM                  0x00020000UL
+#define NETLINK_SOCKET__GETATTR                   0x00000010UL
+
+#define PACKET_SOCKET__RELABELTO                  0x00000100UL
+#define PACKET_SOCKET__RECV_MSG                   0x00080000UL
+#define PACKET_SOCKET__RELABELFROM                0x00000080UL
+#define PACKET_SOCKET__SETOPT                     0x00008000UL
+#define PACKET_SOCKET__APPEND                     0x00000200UL
+#define PACKET_SOCKET__SETATTR                    0x00000020UL
+#define PACKET_SOCKET__SENDTO                     0x00040000UL
+#define PACKET_SOCKET__GETOPT                     0x00004000UL
+#define PACKET_SOCKET__READ                       0x00000002UL
+#define PACKET_SOCKET__SHUTDOWN                   0x00010000UL
+#define PACKET_SOCKET__LISTEN                     0x00001000UL
+#define PACKET_SOCKET__BIND                       0x00000400UL
+#define PACKET_SOCKET__WRITE                      0x00000004UL
+#define PACKET_SOCKET__ACCEPT                     0x00002000UL
+#define PACKET_SOCKET__CONNECT                    0x00000800UL
+#define PACKET_SOCKET__LOCK                       0x00000040UL
+#define PACKET_SOCKET__IOCTL                      0x00000001UL
+#define PACKET_SOCKET__CREATE                     0x00000008UL
+#define PACKET_SOCKET__NAME_BIND                  0x00200000UL
+#define PACKET_SOCKET__SEND_MSG                   0x00100000UL
+#define PACKET_SOCKET__RECVFROM                   0x00020000UL
+#define PACKET_SOCKET__GETATTR                    0x00000010UL
+
+#define KEY_SOCKET__RELABELTO                     0x00000100UL
+#define KEY_SOCKET__RECV_MSG                      0x00080000UL
+#define KEY_SOCKET__RELABELFROM                   0x00000080UL
+#define KEY_SOCKET__SETOPT                        0x00008000UL
+#define KEY_SOCKET__APPEND                        0x00000200UL
+#define KEY_SOCKET__SETATTR                       0x00000020UL
+#define KEY_SOCKET__SENDTO                        0x00040000UL
+#define KEY_SOCKET__GETOPT                        0x00004000UL
+#define KEY_SOCKET__READ                          0x00000002UL
+#define KEY_SOCKET__SHUTDOWN                      0x00010000UL
+#define KEY_SOCKET__LISTEN                        0x00001000UL
+#define KEY_SOCKET__BIND                          0x00000400UL
+#define KEY_SOCKET__WRITE                         0x00000004UL
+#define KEY_SOCKET__ACCEPT                        0x00002000UL
+#define KEY_SOCKET__CONNECT                       0x00000800UL
+#define KEY_SOCKET__LOCK                          0x00000040UL
+#define KEY_SOCKET__IOCTL                         0x00000001UL
+#define KEY_SOCKET__CREATE                        0x00000008UL
+#define KEY_SOCKET__NAME_BIND                     0x00200000UL
+#define KEY_SOCKET__SEND_MSG                      0x00100000UL
+#define KEY_SOCKET__RECVFROM                      0x00020000UL
+#define KEY_SOCKET__GETATTR                       0x00000010UL
+
+#define UNIX_STREAM_SOCKET__RELABELTO             0x00000100UL
+#define UNIX_STREAM_SOCKET__RECV_MSG              0x00080000UL
+#define UNIX_STREAM_SOCKET__RELABELFROM           0x00000080UL
+#define UNIX_STREAM_SOCKET__SETOPT                0x00008000UL
+#define UNIX_STREAM_SOCKET__APPEND                0x00000200UL
+#define UNIX_STREAM_SOCKET__SETATTR               0x00000020UL
+#define UNIX_STREAM_SOCKET__SENDTO                0x00040000UL
+#define UNIX_STREAM_SOCKET__GETOPT                0x00004000UL
+#define UNIX_STREAM_SOCKET__READ                  0x00000002UL
+#define UNIX_STREAM_SOCKET__SHUTDOWN              0x00010000UL
+#define UNIX_STREAM_SOCKET__LISTEN                0x00001000UL
+#define UNIX_STREAM_SOCKET__BIND                  0x00000400UL
+#define UNIX_STREAM_SOCKET__WRITE                 0x00000004UL
+#define UNIX_STREAM_SOCKET__ACCEPT                0x00002000UL
+#define UNIX_STREAM_SOCKET__CONNECT               0x00000800UL
+#define UNIX_STREAM_SOCKET__LOCK                  0x00000040UL
+#define UNIX_STREAM_SOCKET__IOCTL                 0x00000001UL
+#define UNIX_STREAM_SOCKET__CREATE                0x00000008UL
+#define UNIX_STREAM_SOCKET__NAME_BIND             0x00200000UL
+#define UNIX_STREAM_SOCKET__SEND_MSG              0x00100000UL
+#define UNIX_STREAM_SOCKET__RECVFROM              0x00020000UL
+#define UNIX_STREAM_SOCKET__GETATTR               0x00000010UL
+
+#define UNIX_STREAM_SOCKET__CONNECTTO             0x00400000UL
+#define UNIX_STREAM_SOCKET__NEWCONN               0x00800000UL
+#define UNIX_STREAM_SOCKET__ACCEPTFROM            0x01000000UL
+
+#define UNIX_DGRAM_SOCKET__RELABELTO              0x00000100UL
+#define UNIX_DGRAM_SOCKET__RECV_MSG               0x00080000UL
+#define UNIX_DGRAM_SOCKET__RELABELFROM            0x00000080UL
+#define UNIX_DGRAM_SOCKET__SETOPT                 0x00008000UL
+#define UNIX_DGRAM_SOCKET__APPEND                 0x00000200UL
+#define UNIX_DGRAM_SOCKET__SETATTR                0x00000020UL
+#define UNIX_DGRAM_SOCKET__SENDTO                 0x00040000UL
+#define UNIX_DGRAM_SOCKET__GETOPT                 0x00004000UL
+#define UNIX_DGRAM_SOCKET__READ                   0x00000002UL
+#define UNIX_DGRAM_SOCKET__SHUTDOWN               0x00010000UL
+#define UNIX_DGRAM_SOCKET__LISTEN                 0x00001000UL
+#define UNIX_DGRAM_SOCKET__BIND                   0x00000400UL
+#define UNIX_DGRAM_SOCKET__WRITE                  0x00000004UL
+#define UNIX_DGRAM_SOCKET__ACCEPT                 0x00002000UL
+#define UNIX_DGRAM_SOCKET__CONNECT                0x00000800UL
+#define UNIX_DGRAM_SOCKET__LOCK                   0x00000040UL
+#define UNIX_DGRAM_SOCKET__IOCTL                  0x00000001UL
+#define UNIX_DGRAM_SOCKET__CREATE                 0x00000008UL
+#define UNIX_DGRAM_SOCKET__NAME_BIND              0x00200000UL
+#define UNIX_DGRAM_SOCKET__SEND_MSG               0x00100000UL
+#define UNIX_DGRAM_SOCKET__RECVFROM               0x00020000UL
+#define UNIX_DGRAM_SOCKET__GETATTR                0x00000010UL
+
+#define PROCESS__FORK                             0x00000001UL
+#define PROCESS__TRANSITION                       0x00000002UL
+#define PROCESS__SIGCHLD                          0x00000004UL
+#define PROCESS__SIGKILL                          0x00000008UL
+#define PROCESS__SIGSTOP                          0x00000010UL
+#define PROCESS__SIGNULL                          0x00000020UL
+#define PROCESS__SIGNAL                           0x00000040UL
+#define PROCESS__PTRACE                           0x00000080UL
+#define PROCESS__GETSCHED                         0x00000100UL
+#define PROCESS__SETSCHED                         0x00000200UL
+#define PROCESS__GETSESSION                       0x00000400UL
+#define PROCESS__GETPGID                          0x00000800UL
+#define PROCESS__SETPGID                          0x00001000UL
+#define PROCESS__GETCAP                           0x00002000UL
+#define PROCESS__SETCAP                           0x00004000UL
+#define PROCESS__SHARE                            0x00008000UL
+#define PROCESS__GETATTR                          0x00010000UL
+#define PROCESS__SETEXEC                          0x00020000UL
+#define PROCESS__SETFSCREATE                      0x00040000UL
+#define PROCESS__NOATSECURE                       0x00080000UL
+
+#define IPC__SETATTR                              0x00000008UL
+#define IPC__READ                                 0x00000010UL
+#define IPC__ASSOCIATE                            0x00000040UL
+#define IPC__DESTROY                              0x00000002UL
+#define IPC__UNIX_WRITE                           0x00000100UL
+#define IPC__CREATE                               0x00000001UL
+#define IPC__UNIX_READ                            0x00000080UL
+#define IPC__GETATTR                              0x00000004UL
+#define IPC__WRITE                                0x00000020UL
+
+#define SEM__SETATTR                              0x00000008UL
+#define SEM__READ                                 0x00000010UL
+#define SEM__ASSOCIATE                            0x00000040UL
+#define SEM__DESTROY                              0x00000002UL
+#define SEM__UNIX_WRITE                           0x00000100UL
+#define SEM__CREATE                               0x00000001UL
+#define SEM__UNIX_READ                            0x00000080UL
+#define SEM__GETATTR                              0x00000004UL
+#define SEM__WRITE                                0x00000020UL
+
+#define MSGQ__SETATTR                             0x00000008UL
+#define MSGQ__READ                                0x00000010UL
+#define MSGQ__ASSOCIATE                           0x00000040UL
+#define MSGQ__DESTROY                             0x00000002UL
+#define MSGQ__UNIX_WRITE                          0x00000100UL
+#define MSGQ__CREATE                              0x00000001UL
+#define MSGQ__UNIX_READ                           0x00000080UL
+#define MSGQ__GETATTR                             0x00000004UL
+#define MSGQ__WRITE                               0x00000020UL
+
+#define MSGQ__ENQUEUE                             0x00000200UL
+
+#define MSG__SEND                                 0x00000001UL
+#define MSG__RECEIVE                              0x00000002UL
+
+#define SHM__SETATTR                              0x00000008UL
+#define SHM__READ                                 0x00000010UL
+#define SHM__ASSOCIATE                            0x00000040UL
+#define SHM__DESTROY                              0x00000002UL
+#define SHM__UNIX_WRITE                           0x00000100UL
+#define SHM__CREATE                               0x00000001UL
+#define SHM__UNIX_READ                            0x00000080UL
+#define SHM__GETATTR                              0x00000004UL
+#define SHM__WRITE                                0x00000020UL
+
+#define SHM__LOCK                                 0x00000200UL
+
+#define SECURITY__COMPUTE_AV                      0x00000001UL
+#define SECURITY__COMPUTE_CREATE                  0x00000002UL
+#define SECURITY__COMPUTE_MEMBER                  0x00000004UL
+#define SECURITY__CHECK_CONTEXT                   0x00000008UL
+#define SECURITY__LOAD_POLICY                     0x00000010UL
+#define SECURITY__COMPUTE_RELABEL                 0x00000020UL
+#define SECURITY__COMPUTE_USER                    0x00000040UL
+#define SECURITY__SETENFORCE                      0x00000080UL
+
+#define SYSTEM__IPC_INFO                          0x00000001UL
+#define SYSTEM__SYSLOG_READ                       0x00000002UL
+#define SYSTEM__SYSLOG_MOD                        0x00000004UL
+#define SYSTEM__SYSLOG_CONSOLE                    0x00000008UL
+
+#define CAPABILITY__CHOWN                         0x00000001UL
+#define CAPABILITY__DAC_OVERRIDE                  0x00000002UL
+#define CAPABILITY__DAC_READ_SEARCH               0x00000004UL
+#define CAPABILITY__FOWNER                        0x00000008UL
+#define CAPABILITY__FSETID                        0x00000010UL
+#define CAPABILITY__KILL                          0x00000020UL
+#define CAPABILITY__SETGID                        0x00000040UL
+#define CAPABILITY__SETUID                        0x00000080UL
+#define CAPABILITY__SETPCAP                       0x00000100UL
+#define CAPABILITY__LINUX_IMMUTABLE               0x00000200UL
+#define CAPABILITY__NET_BIND_SERVICE              0x00000400UL
+#define CAPABILITY__NET_BROADCAST                 0x00000800UL
+#define CAPABILITY__NET_ADMIN                     0x00001000UL
+#define CAPABILITY__NET_RAW                       0x00002000UL
+#define CAPABILITY__IPC_LOCK                      0x00004000UL
+#define CAPABILITY__IPC_OWNER                     0x00008000UL
+#define CAPABILITY__SYS_MODULE                    0x00010000UL
+#define CAPABILITY__SYS_RAWIO                     0x00020000UL
+#define CAPABILITY__SYS_CHROOT                    0x00040000UL
+#define CAPABILITY__SYS_PTRACE                    0x00080000UL
+#define CAPABILITY__SYS_PACCT                     0x00100000UL
+#define CAPABILITY__SYS_ADMIN                     0x00200000UL
+#define CAPABILITY__SYS_BOOT                      0x00400000UL
+#define CAPABILITY__SYS_NICE                      0x00800000UL
+#define CAPABILITY__SYS_RESOURCE                  0x01000000UL
+#define CAPABILITY__SYS_TIME                      0x02000000UL
+#define CAPABILITY__SYS_TTY_CONFIG                0x04000000UL
+#define CAPABILITY__MKNOD                         0x08000000UL
+#define CAPABILITY__LEASE                         0x10000000UL
+
+#define PASSWD__PASSWD                            0x00000001UL
+#define PASSWD__CHFN                              0x00000002UL
+#define PASSWD__CHSH                              0x00000004UL
+
+
+/* FLASK */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/av_perm_to_string.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/av_perm_to_string.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/av_perm_to_string.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/av_perm_to_string.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,120 @@
+/* This file is automatically generated.  Do not edit. */
+/* FLASK */
+
+struct av_perm_to_string
+{
+    u16 tclass;
+    u32 value;
+    char *name;
+};
+
+static struct av_perm_to_string av_perm_to_string[] = {
+   { SECCLASS_FILESYSTEM, FILESYSTEM__MOUNT, "mount" },
+   { SECCLASS_FILESYSTEM, FILESYSTEM__REMOUNT, "remount" },
+   { SECCLASS_FILESYSTEM, FILESYSTEM__UNMOUNT, "unmount" },
+   { SECCLASS_FILESYSTEM, FILESYSTEM__GETATTR, "getattr" },
+   { SECCLASS_FILESYSTEM, FILESYSTEM__RELABELFROM, "relabelfrom" },
+   { SECCLASS_FILESYSTEM, FILESYSTEM__RELABELTO, "relabelto" },
+   { SECCLASS_FILESYSTEM, FILESYSTEM__TRANSITION, "transition" },
+   { SECCLASS_FILESYSTEM, FILESYSTEM__ASSOCIATE, "associate" },
+   { SECCLASS_FILESYSTEM, FILESYSTEM__QUOTAMOD, "quotamod" },
+   { SECCLASS_FILESYSTEM, FILESYSTEM__QUOTAGET, "quotaget" },
+   { SECCLASS_DIR, DIR__ADD_NAME, "add_name" },
+   { SECCLASS_DIR, DIR__REMOVE_NAME, "remove_name" },
+   { SECCLASS_DIR, DIR__REPARENT, "reparent" },
+   { SECCLASS_DIR, DIR__SEARCH, "search" },
+   { SECCLASS_DIR, DIR__RMDIR, "rmdir" },
+   { SECCLASS_FILE, FILE__EXECUTE_NO_TRANS, "execute_no_trans" },
+   { SECCLASS_FILE, FILE__ENTRYPOINT, "entrypoint" },
+   { SECCLASS_FD, FD__USE, "use" },
+   { SECCLASS_TCP_SOCKET, TCP_SOCKET__CONNECTTO, "connectto" },
+   { SECCLASS_TCP_SOCKET, TCP_SOCKET__NEWCONN, "newconn" },
+   { SECCLASS_TCP_SOCKET, TCP_SOCKET__ACCEPTFROM, "acceptfrom" },
+   { SECCLASS_NODE, NODE__TCP_RECV, "tcp_recv" },
+   { SECCLASS_NODE, NODE__TCP_SEND, "tcp_send" },
+   { SECCLASS_NODE, NODE__UDP_RECV, "udp_recv" },
+   { SECCLASS_NODE, NODE__UDP_SEND, "udp_send" },
+   { SECCLASS_NODE, NODE__RAWIP_RECV, "rawip_recv" },
+   { SECCLASS_NODE, NODE__RAWIP_SEND, "rawip_send" },
+   { SECCLASS_NODE, NODE__ENFORCE_DEST, "enforce_dest" },
+   { SECCLASS_NETIF, NETIF__TCP_RECV, "tcp_recv" },
+   { SECCLASS_NETIF, NETIF__TCP_SEND, "tcp_send" },
+   { SECCLASS_NETIF, NETIF__UDP_RECV, "udp_recv" },
+   { SECCLASS_NETIF, NETIF__UDP_SEND, "udp_send" },
+   { SECCLASS_NETIF, NETIF__RAWIP_RECV, "rawip_recv" },
+   { SECCLASS_NETIF, NETIF__RAWIP_SEND, "rawip_send" },
+   { SECCLASS_UNIX_STREAM_SOCKET, UNIX_STREAM_SOCKET__CONNECTTO, "connectto" },
+   { SECCLASS_UNIX_STREAM_SOCKET, UNIX_STREAM_SOCKET__NEWCONN, "newconn" },
+   { SECCLASS_UNIX_STREAM_SOCKET, UNIX_STREAM_SOCKET__ACCEPTFROM, "acceptfrom" },
+   { SECCLASS_PROCESS, PROCESS__FORK, "fork" },
+   { SECCLASS_PROCESS, PROCESS__TRANSITION, "transition" },
+   { SECCLASS_PROCESS, PROCESS__SIGCHLD, "sigchld" },
+   { SECCLASS_PROCESS, PROCESS__SIGKILL, "sigkill" },
+   { SECCLASS_PROCESS, PROCESS__SIGSTOP, "sigstop" },
+   { SECCLASS_PROCESS, PROCESS__SIGNULL, "signull" },
+   { SECCLASS_PROCESS, PROCESS__SIGNAL, "signal" },
+   { SECCLASS_PROCESS, PROCESS__PTRACE, "ptrace" },
+   { SECCLASS_PROCESS, PROCESS__GETSCHED, "getsched" },
+   { SECCLASS_PROCESS, PROCESS__SETSCHED, "setsched" },
+   { SECCLASS_PROCESS, PROCESS__GETSESSION, "getsession" },
+   { SECCLASS_PROCESS, PROCESS__GETPGID, "getpgid" },
+   { SECCLASS_PROCESS, PROCESS__SETPGID, "setpgid" },
+   { SECCLASS_PROCESS, PROCESS__GETCAP, "getcap" },
+   { SECCLASS_PROCESS, PROCESS__SETCAP, "setcap" },
+   { SECCLASS_PROCESS, PROCESS__SHARE, "share" },
+   { SECCLASS_PROCESS, PROCESS__GETATTR, "getattr" },
+   { SECCLASS_PROCESS, PROCESS__SETEXEC, "setexec" },
+   { SECCLASS_PROCESS, PROCESS__SETFSCREATE, "setfscreate" },
+   { SECCLASS_PROCESS, PROCESS__NOATSECURE, "noatsecure" },
+   { SECCLASS_MSGQ, MSGQ__ENQUEUE, "enqueue" },
+   { SECCLASS_MSG, MSG__SEND, "send" },
+   { SECCLASS_MSG, MSG__RECEIVE, "receive" },
+   { SECCLASS_SHM, SHM__LOCK, "lock" },
+   { SECCLASS_SECURITY, SECURITY__COMPUTE_AV, "compute_av" },
+   { SECCLASS_SECURITY, SECURITY__COMPUTE_CREATE, "compute_create" },
+   { SECCLASS_SECURITY, SECURITY__COMPUTE_MEMBER, "compute_member" },
+   { SECCLASS_SECURITY, SECURITY__CHECK_CONTEXT, "check_context" },
+   { SECCLASS_SECURITY, SECURITY__LOAD_POLICY, "load_policy" },
+   { SECCLASS_SECURITY, SECURITY__COMPUTE_RELABEL, "compute_relabel" },
+   { SECCLASS_SECURITY, SECURITY__COMPUTE_USER, "compute_user" },
+   { SECCLASS_SECURITY, SECURITY__SETENFORCE, "setenforce" },
+   { SECCLASS_SYSTEM, SYSTEM__IPC_INFO, "ipc_info" },
+   { SECCLASS_SYSTEM, SYSTEM__SYSLOG_READ, "syslog_read" },
+   { SECCLASS_SYSTEM, SYSTEM__SYSLOG_MOD, "syslog_mod" },
+   { SECCLASS_SYSTEM, SYSTEM__SYSLOG_CONSOLE, "syslog_console" },
+   { SECCLASS_CAPABILITY, CAPABILITY__CHOWN, "chown" },
+   { SECCLASS_CAPABILITY, CAPABILITY__DAC_OVERRIDE, "dac_override" },
+   { SECCLASS_CAPABILITY, CAPABILITY__DAC_READ_SEARCH, "dac_read_search" },
+   { SECCLASS_CAPABILITY, CAPABILITY__FOWNER, "fowner" },
+   { SECCLASS_CAPABILITY, CAPABILITY__FSETID, "fsetid" },
+   { SECCLASS_CAPABILITY, CAPABILITY__KILL, "kill" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SETGID, "setgid" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SETUID, "setuid" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SETPCAP, "setpcap" },
+   { SECCLASS_CAPABILITY, CAPABILITY__LINUX_IMMUTABLE, "linux_immutable" },
+   { SECCLASS_CAPABILITY, CAPABILITY__NET_BIND_SERVICE, "net_bind_service" },
+   { SECCLASS_CAPABILITY, CAPABILITY__NET_BROADCAST, "net_broadcast" },
+   { SECCLASS_CAPABILITY, CAPABILITY__NET_ADMIN, "net_admin" },
+   { SECCLASS_CAPABILITY, CAPABILITY__NET_RAW, "net_raw" },
+   { SECCLASS_CAPABILITY, CAPABILITY__IPC_LOCK, "ipc_lock" },
+   { SECCLASS_CAPABILITY, CAPABILITY__IPC_OWNER, "ipc_owner" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_MODULE, "sys_module" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_RAWIO, "sys_rawio" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_CHROOT, "sys_chroot" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_PTRACE, "sys_ptrace" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_PACCT, "sys_pacct" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_ADMIN, "sys_admin" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_BOOT, "sys_boot" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_NICE, "sys_nice" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_RESOURCE, "sys_resource" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_TIME, "sys_time" },
+   { SECCLASS_CAPABILITY, CAPABILITY__SYS_TTY_CONFIG, "sys_tty_config" },
+   { SECCLASS_CAPABILITY, CAPABILITY__MKNOD, "mknod" },
+   { SECCLASS_CAPABILITY, CAPABILITY__LEASE, "lease" },
+   { SECCLASS_PASSWD, PASSWD__PASSWD, "passwd" },
+   { SECCLASS_PASSWD, PASSWD__CHFN, "chfn" },
+   { SECCLASS_PASSWD, PASSWD__CHSH, "chsh" },
+};
+
+
+/* FLASK */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/class_to_string.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/class_to_string.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/class_to_string.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/class_to_string.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,39 @@
+/* This file is automatically generated.  Do not edit. */
+/*
+ * Security object class definitions
+ */
+static char *class_to_string[] =
+{
+    "null",
+    "security",
+    "process",
+    "system",
+    "capability",
+    "filesystem",
+    "file",
+    "dir",
+    "fd",
+    "lnk_file",
+    "chr_file",
+    "blk_file",
+    "sock_file",
+    "fifo_file",
+    "socket",
+    "tcp_socket",
+    "udp_socket",
+    "rawip_socket",
+    "node",
+    "netif",
+    "netlink_socket",
+    "packet_socket",
+    "key_socket",
+    "unix_stream_socket",
+    "unix_dgram_socket",
+    "sem",
+    "msg",
+    "msgq",
+    "shm",
+    "ipc",
+    "passwd",
+};
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/common_perm_to_string.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/common_perm_to_string.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/common_perm_to_string.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/common_perm_to_string.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,65 @@
+/* This file is automatically generated.  Do not edit. */
+/* FLASK */
+
+static char *common_file_perm_to_string[] =
+{
+    "ioctl",
+    "read",
+    "write",
+    "create",
+    "getattr",
+    "setattr",
+    "lock",
+    "relabelfrom",
+    "relabelto",
+    "append",
+    "unlink",
+    "link",
+    "rename",
+    "execute",
+    "swapon",
+    "quotaon",
+    "mounton",
+};
+
+static char *common_socket_perm_to_string[] =
+{
+    "ioctl",
+    "read",
+    "write",
+    "create",
+    "getattr",
+    "setattr",
+    "lock",
+    "relabelfrom",
+    "relabelto",
+    "append",
+    "bind",
+    "connect",
+    "listen",
+    "accept",
+    "getopt",
+    "setopt",
+    "shutdown",
+    "recvfrom",
+    "sendto",
+    "recv_msg",
+    "send_msg",
+    "name_bind",
+};
+
+static char *common_ipc_perm_to_string[] =
+{
+    "create",
+    "destroy",
+    "getattr",
+    "setattr",
+    "read",
+    "write",
+    "associate",
+    "unix_read",
+    "unix_write",
+};
+
+
+/* FLASK */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/compatibility.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/compatibility.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/compatibility.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/compatibility.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,46 @@
+/*
+ * Provide compatibility with the 2.5 version of SELinux
+ *
+ * Author:  James Carter, <jwcart2@epoch.ncsc.mil>
+ */
+
+#ifndef _SELINUX_COMPATIBILITY_H
+#define _SELINUX_COMPATIBILITY_H
+
+#define unix_sock unix_opt
+#define sk_family family
+#define sk_type type
+#define sk_protocol protocol
+#define proc_inode inode
+#define pde u.generic_ip
+#define sighand sig
+#define force_sig_specific force_sig
+
+#define inet_sk(sk) sk
+#define unix_sk(sk) &((sk)->protinfo.af_unix)
+#define PROC_I(inode) inode
+#define SOCKET_I(inode) &((inode)->u.socket_i)
+
+/**
+ * Copied from the 2.5 tree - include/linux/sched.
+ *
+ * get_task_mm - acquire a reference to the task's mm
+ *
+ * Returns %NULL if the task has no mm. User must release
+ * the mm via mmput() after use.
+ */
+static inline struct mm_struct * get_task_mm(struct task_struct * task)
+{
+	struct mm_struct * mm;
+ 
+	task_lock(task);
+	mm = task->mm;
+	if (mm)
+		atomic_inc(&mm->mm_users);
+	task_unlock(task);
+
+	return mm;
+}
+
+#endif /* _SELINUX_COMPATIBILITY_H */
+ 
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/flask.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/flask.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/flask.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/flask.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,71 @@
+/* This file is automatically generated.  Do not edit. */
+#ifndef _SELINUX_FLASK_H_
+#define _SELINUX_FLASK_H_
+
+/*
+ * Security object class definitions
+ */
+#define SECCLASS_SECURITY                                1
+#define SECCLASS_PROCESS                                 2
+#define SECCLASS_SYSTEM                                  3
+#define SECCLASS_CAPABILITY                              4
+#define SECCLASS_FILESYSTEM                              5
+#define SECCLASS_FILE                                    6
+#define SECCLASS_DIR                                     7
+#define SECCLASS_FD                                      8
+#define SECCLASS_LNK_FILE                                9
+#define SECCLASS_CHR_FILE                                10
+#define SECCLASS_BLK_FILE                                11
+#define SECCLASS_SOCK_FILE                               12
+#define SECCLASS_FIFO_FILE                               13
+#define SECCLASS_SOCKET                                  14
+#define SECCLASS_TCP_SOCKET                              15
+#define SECCLASS_UDP_SOCKET                              16
+#define SECCLASS_RAWIP_SOCKET                            17
+#define SECCLASS_NODE                                    18
+#define SECCLASS_NETIF                                   19
+#define SECCLASS_NETLINK_SOCKET                          20
+#define SECCLASS_PACKET_SOCKET                           21
+#define SECCLASS_KEY_SOCKET                              22
+#define SECCLASS_UNIX_STREAM_SOCKET                      23
+#define SECCLASS_UNIX_DGRAM_SOCKET                       24
+#define SECCLASS_SEM                                     25
+#define SECCLASS_MSG                                     26
+#define SECCLASS_MSGQ                                    27
+#define SECCLASS_SHM                                     28
+#define SECCLASS_IPC                                     29
+#define SECCLASS_PASSWD                                  30
+
+/*
+ * Security identifier indices for initial entities
+ */
+#define SECINITSID_KERNEL                               1
+#define SECINITSID_SECURITY                             2
+#define SECINITSID_UNLABELED                            3
+#define SECINITSID_FS                                   4
+#define SECINITSID_FILE                                 5
+#define SECINITSID_FILE_LABELS                          6
+#define SECINITSID_INIT                                 7
+#define SECINITSID_ANY_SOCKET                           8
+#define SECINITSID_PORT                                 9
+#define SECINITSID_NETIF                                10
+#define SECINITSID_NETMSG                               11
+#define SECINITSID_NODE                                 12
+#define SECINITSID_IGMP_PACKET                          13
+#define SECINITSID_ICMP_SOCKET                          14
+#define SECINITSID_TCP_SOCKET                           15
+#define SECINITSID_SYSCTL_MODPROBE                      16
+#define SECINITSID_SYSCTL                               17
+#define SECINITSID_SYSCTL_FS                            18
+#define SECINITSID_SYSCTL_KERNEL                        19
+#define SECINITSID_SYSCTL_NET                           20
+#define SECINITSID_SYSCTL_NET_UNIX                      21
+#define SECINITSID_SYSCTL_VM                            22
+#define SECINITSID_SYSCTL_DEV                           23
+#define SECINITSID_KMOD                                 24
+#define SECINITSID_POLICY                               25
+#define SECINITSID_SCMP_PACKET                          26
+
+#define SECINITSID_NUM                                  26
+
+#endif
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/initial_sid_to_string.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/initial_sid_to_string.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/initial_sid_to_string.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/initial_sid_to_string.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,32 @@
+/* This file is automatically generated.  Do not edit. */
+static char *initial_sid_to_string[] =
+{
+    "null",
+    "kernel",
+    "security",
+    "unlabeled",
+    "fs",
+    "file",
+    "file_labels",
+    "init",
+    "any_socket",
+    "port",
+    "netif",
+    "netmsg",
+    "node",
+    "igmp_packet",
+    "icmp_socket",
+    "tcp_socket",
+    "sysctl_modprobe",
+    "sysctl",
+    "sysctl_fs",
+    "sysctl_kernel",
+    "sysctl_net",
+    "sysctl_net_unix",
+    "sysctl_vm",
+    "sysctl_dev",
+    "kmod",
+    "policy",
+    "scmp_packet",
+};
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/libfs.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/libfs.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/libfs.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/libfs.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,15 @@
+/*
+ * security/selinux/include/libfs.h
+ *
+ * Author:  James Carter, <jwcart2@epoch.ncsc.mil>
+ */
+
+#ifndef _SELINUX_LIBFS_H
+#define _SELINUX_LIBFS_H
+
+/* Copied from 2.5 tree - include/linux/fs.h */
+struct tree_descr { char *name; struct file_operations *ops; int mode; };
+
+extern struct super_block *simple_fill_super(struct super_block *, int, struct tree_descr *);
+
+#endif /* _SELINUX_LIBFS_H */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/objsec.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/objsec.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/objsec.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/objsec.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,97 @@
+/*
+ *  NSA Security-Enhanced Linux (SELinux) security module
+ *
+ *  This file contains the SELinux security data structures for kernel objects.
+ *
+ *  Author(s):  Stephen Smalley, <sds@epoch.ncsc.mil>
+ *              Chris Vance, <cvance@nai.com>
+ *              Wayne Salamon, <wsalamon@nai.com>
+ *              James Morris <jmorris@redhat.com>
+ *
+ *  Copyright (C) 2001,2002 Networks Associates Technology, Inc.
+ *  Copyright (C) 2003 Red Hat, Inc., James Morris <jmorris@redhat.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License version 2,
+ *      as published by the Free Software Foundation.
+ */
+#ifndef _SELINUX_OBJSEC_H_
+#define _SELINUX_OBJSEC_H_
+
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/in.h>
+#include "flask.h"
+#include "avc.h"
+
+struct task_security_struct {
+        unsigned long magic;           /* magic number for this module */
+	struct task_struct *task;      /* back pointer to task object */
+	u32 osid;            /* SID prior to last execve */
+	u32 sid;             /* current SID */
+	u32 exec_sid;        /* exec SID */
+	u32 create_sid;      /* fscreate SID */
+        struct avc_entry_ref avcr;     /* reference to process permissions */
+};
+
+struct inode_security_struct {
+	unsigned long magic;           /* magic number for this module */
+        struct inode *inode;           /* back pointer to inode object */
+	struct list_head list;         /* list of inode_security_struct */
+	u32 task_sid;        /* SID of creating task */
+	u32 sid;             /* SID of this object */
+	u16 sclass;       /* security class of this object */
+	struct avc_entry_ref avcr;     /* reference to object permissions */
+	unsigned char initialized;     /* initialization flag */
+	struct semaphore sem;
+	unsigned char inherit;         /* inherit SID from parent entry */
+};
+
+struct file_security_struct {
+	unsigned long magic;            /* magic number for this module */
+	struct file *file;              /* back pointer to file object */
+	u32 sid;              /* SID of open file description */
+	u32 fown_sid;         /* SID of file owner (for SIGIO) */
+	struct avc_entry_ref avcr;	/* reference to fd permissions */
+	struct avc_entry_ref inode_avcr;     /* reference to object permissions */
+};
+
+struct superblock_security_struct {
+	unsigned long magic;            /* magic number for this module */
+	struct super_block *sb;         /* back pointer to sb object */
+	struct list_head list;          /* list of superblock_security_struct */
+	u32 sid;              /* SID of file system */
+	unsigned int behavior;          /* labeling behavior */
+	unsigned char initialized;      /* initialization flag */
+	unsigned char proc;             /* proc fs */
+	struct semaphore sem;
+	struct list_head isec_head;
+	spinlock_t isec_lock;
+};
+
+struct msg_security_struct {
+        unsigned long magic;		/* magic number for this module */
+	struct msg_msg *msg;		/* back pointer */
+	u32 sid;              /* SID of message */
+        struct avc_entry_ref avcr;	/* reference to permissions */
+};
+
+struct ipc_security_struct {
+        unsigned long magic;		/* magic number for this module */
+	struct kern_ipc_perm *ipc_perm; /* back pointer */
+	u16 sclass;	/* security class of this object */
+	u32 sid;              /* SID of IPC resource */
+        struct avc_entry_ref avcr;	/* reference to permissions */
+};
+
+struct bprm_security_struct {
+	unsigned long magic;           /* magic number for this module */
+	struct linux_binprm *bprm;     /* back pointer to bprm object */
+	u32 sid;                       /* SID for transformed process */
+	unsigned char set;             
+};
+
+extern int inode_security_set_sid(struct inode *inode, u32 sid);
+
+#endif /* _SELINUX_OBJSEC_H_ */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/security.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/security.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/include/security.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/include/security.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,77 @@
+/*
+ * Security server interface.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SELINUX_SECURITY_H_
+#define _SELINUX_SECURITY_H_
+
+#include "flask.h"
+
+#define SECSID_NULL			0x00000000 /* unspecified SID */
+#define SECSID_WILD			0xffffffff /* wildcard SID */
+#define SECCLASS_NULL			0x0000 /* no class */
+
+#define SELINUX_MAGIC 0xf97cff8c
+#define POLICYDB_VERSION 15
+
+#ifdef CONFIG_SECURITY_SELINUX_BOOTPARAM
+extern int selinux_enabled;
+#else
+#define selinux_enabled 1
+#endif
+
+int security_load_policy(void * data, size_t len);
+
+struct av_decision {
+	u32 allowed;
+	u32 decided;
+	u32 auditallow;
+	u32 auditdeny;
+	u32 seqno;
+};
+
+int security_compute_av(u32 ssid, u32 tsid,
+	u16 tclass, u32 requested,
+	struct av_decision *avd);
+
+int security_transition_sid(u32 ssid, u32 tsid,
+	u16 tclass, u32 *out_sid);
+
+int security_member_sid(u32 ssid, u32 tsid,
+	u16 tclass, u32 *out_sid);
+
+int security_change_sid(u32 ssid, u32 tsid,
+	u16 tclass, u32 *out_sid);
+
+int security_sid_to_context(u32 sid, char **scontext,
+	u32 *scontext_len);
+
+int security_context_to_sid(char *scontext, u32 scontext_len,
+	u32 *out_sid);
+
+int security_get_user_sids(u32 callsid, char *username,
+			   u32 **sids, u32 *nel);
+
+int security_port_sid(u16 domain, u16 type, u8 protocol, u16 port,
+	u32 *out_sid);
+
+int security_netif_sid(char *name, u32 *if_sid,
+	u32 *msg_sid);
+
+int security_node_sid(u16 domain, void *addr, u32 addrlen,
+	u32 *out_sid);
+
+#define SECURITY_FS_USE_XATTR 1 /* use xattr */
+#define SECURITY_FS_USE_TRANS 2 /* use transition SIDs, e.g. devpts/tmpfs */
+#define SECURITY_FS_USE_TASK  3 /* use task SIDs, e.g. pipefs/sockfs */
+#define SECURITY_FS_USE_GENFS 4 /* use the genfs support */
+#define SECURITY_FS_USE_NONE  5 /* no labeling support */
+int security_fs_use(const char *fstype, unsigned int *behavior,
+	u32 *sid);
+
+int security_genfs_sid(const char *fstype, char *name, u16 sclass,
+	u32 *sid);
+
+#endif /* _SELINUX_SECURITY_H_ */
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/libfs.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/libfs.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/libfs.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/libfs.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,100 @@
+/*
+ * security/selinux/libfs.c
+ *
+ * From fs/libfs.c in the 2.5 kernel
+ * Many functions removed, the remainder slightly modified.
+ *
+ */
+
+#include <linux/pagemap.h>
+
+#include "libfs.h"
+
+int simple_statfs(struct super_block *sb, struct statfs *buf)
+{
+	buf->f_type = sb->s_magic;
+	buf->f_bsize = PAGE_CACHE_SIZE;
+	buf->f_namelen = NAME_MAX;
+	return 0;
+}
+
+/*
+ * Lookup the data. This is trivial - if the dentry didn't already
+ * exist, we know it is negative.
+ */
+
+struct dentry *simple_lookup(struct inode *dir, struct dentry *dentry)
+{
+	d_add(dentry, NULL);
+	return NULL;
+}
+
+struct file_operations simple_dir_operations = {
+	.open		= dcache_dir_open,
+	.release	= dcache_dir_close,
+	.llseek		= dcache_dir_lseek,
+	.read		= generic_read_dir,
+	.readdir	= dcache_readdir,
+};
+
+struct inode_operations simple_dir_inode_operations = {
+	.lookup		= simple_lookup,
+};
+
+struct super_block *simple_fill_super(struct super_block *s, int magic, struct tree_descr *files)
+{
+	static struct super_operations s_ops = {statfs:simple_statfs};
+	struct inode *inode;
+	struct dentry *root;
+	struct dentry *dentry;
+	int i;
+
+	s->s_blocksize = PAGE_CACHE_SIZE;
+	s->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	s->s_magic = magic;
+	s->s_op = &s_ops;
+
+	inode = new_inode(s);
+	if (!inode)
+		return NULL;
+	inode->i_mode = S_IFDIR | 0755;
+	inode->i_uid = inode->i_gid = 0;
+	inode->i_blksize = PAGE_CACHE_SIZE;
+	inode->i_blocks = 0;
+	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	inode->i_op = &simple_dir_inode_operations;
+	inode->i_fop = &simple_dir_operations;
+	root = d_alloc_root(inode);
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	for (i = 0; !files->name || files->name[0]; i++, files++) {
+		struct qstr name;
+		if (!files->name)
+			continue;
+		name.name = files->name;
+		name.len = strlen(name.name);
+		name.hash = full_name_hash(name.name, name.len);
+		dentry = d_alloc(root, &name);
+		if (!dentry)
+			goto out;
+		inode = new_inode(s);
+		if (!inode)
+			goto out;
+		inode->i_mode = S_IFREG | files->mode;
+		inode->i_uid = inode->i_gid = 0;
+		inode->i_blksize = PAGE_CACHE_SIZE;
+		inode->i_blocks = 0;
+		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		inode->i_fop = files->ops;
+		inode->i_ino = i;
+		d_add(dentry, inode);
+	}
+	s->s_root = root;
+	return s;
+out:
+	d_genocide(root);
+	dput(root);
+	return NULL;
+}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/Makefile 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/Makefile
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/Makefile	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,18 @@
+#
+# Makefile for building the SELinux module as part of the kernel tree.
+#
+
+O_TARGET := selinux-obj.o
+
+subdir-$(CONFIG_SECURITY_SELINUX) := ss
+
+selinux-objs := avc.o hooks.o libfs.o selinuxfs.o ss/ss.o 
+
+obj-y := $(selinux-objs)
+
+EXTRA_CFLAGS += -Iinclude 
+
+include $(TOPDIR)/Rules.make
+
+ss/ss.o:
+	make -C ss ss.o
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/selinuxfs.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/selinuxfs.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/selinuxfs.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/selinuxfs.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,649 @@
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/security.h>
+#include <asm/uaccess.h>
+#include <linux/module.h>
+
+/* selinuxfs pseudo filesystem for exporting the security policy API.
+   Based on the proc code and the fs/nfsd/nfsctl.c code. */
+
+#include "flask.h"
+#include "avc.h"
+#include "avc_ss.h"
+#include "security.h"
+#include "objsec.h"
+#include "compatibility.h"
+#include "libfs.h"
+
+/* Check whether a task is allowed to use a security operation. */
+int task_has_security(struct task_struct *tsk,
+		      u32 perms)
+{
+	struct task_security_struct *tsec;
+
+	tsec = tsk->security;
+
+	return avc_has_perm(tsec->sid, SECINITSID_SECURITY,
+			    SECCLASS_SECURITY, perms, NULL, NULL);
+}
+
+enum sel_inos {
+	SEL_ROOT_INO = 2,
+	SEL_LOAD,	/* load policy */
+	SEL_ENFORCE,	/* get or set enforcing status */
+	SEL_CONTEXT,	/* validate context */
+	SEL_ACCESS,	/* compute access decision */
+	SEL_CREATE,	/* compute create labeling decision */
+	SEL_RELABEL,	/* compute relabeling decision */
+	SEL_USER,	/* compute reachable user contexts */
+	SEL_POLICYVERS	/* return policy version for this kernel */
+};
+
+static ssize_t sel_read_enforce(struct file *filp, char *buf,
+				size_t count, loff_t *ppos)
+{
+	char *page;
+	ssize_t length;
+	ssize_t end;
+
+	if (count < 0 || count > PAGE_SIZE)
+		return -EINVAL;
+	if (!(page = (char*)__get_free_page(GFP_KERNEL)))
+		return -ENOMEM;
+	memset(page, 0, PAGE_SIZE);
+
+	length = snprintf(page, PAGE_SIZE, "%d", selinux_enforcing);
+	if (length < 0) {
+		free_page((unsigned long)page);
+		return length;
+	}
+
+	if (*ppos >= length) {
+		free_page((unsigned long)page);
+		return 0;
+	}
+	if (count + *ppos > length)
+		count = length - *ppos;
+	end = count + *ppos;
+	if (copy_to_user(buf, (char *) page + *ppos, count)) {
+		count = -EFAULT;
+		goto out;
+	}
+	*ppos = end;
+out:
+	free_page((unsigned long)page);
+	return count;
+}
+
+#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
+static ssize_t sel_write_enforce(struct file * file, const char * buf,
+				 size_t count, loff_t *ppos)
+
+{
+	char *page;
+	ssize_t length;
+	int new_value;
+
+	if (count < 0 || count >= PAGE_SIZE)
+		return -ENOMEM;
+	if (*ppos != 0) {
+		/* No partial writes. */
+		return -EINVAL;
+	}
+	page = (char*)__get_free_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+	memset(page, 0, PAGE_SIZE);
+	length = -EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out;
+
+	length = -EINVAL;
+	if (sscanf(page, "%d", &new_value) != 1)
+		goto out;
+
+	if (new_value != selinux_enforcing) {
+		length = task_has_security(current, SECURITY__SETENFORCE);
+		if (length)
+			goto out;
+		selinux_enforcing = new_value;
+		if (selinux_enforcing)
+			avc_ss_reset(0);
+	}
+	length = count;
+out:
+	free_page((unsigned long) page);
+	return length;
+}
+#else
+#define sel_write_enforce NULL
+#endif
+
+static struct file_operations sel_enforce_ops = {
+	.read		= sel_read_enforce,
+	.write		= sel_write_enforce,
+};
+
+static ssize_t sel_read_policyvers(struct file *filp, char *buf,
+                                   size_t count, loff_t *ppos)
+{
+	char *page;
+	ssize_t length;
+	ssize_t end;
+
+	if (count < 0 || count > PAGE_SIZE)
+		return -EINVAL;
+	if (!(page = (char*)__get_free_page(GFP_KERNEL)))
+		return -ENOMEM;
+	memset(page, 0, PAGE_SIZE);
+
+	length = snprintf(page, PAGE_SIZE, "%u", POLICYDB_VERSION);
+	if (length < 0) {
+		free_page((unsigned long)page);
+		return length;
+	}
+
+	if (*ppos >= length) {
+		free_page((unsigned long)page);
+		return 0;
+	}
+	if (count + *ppos > length)
+		count = length - *ppos;
+	end = count + *ppos;
+	if (copy_to_user(buf, (char *) page + *ppos, count)) {
+		count = -EFAULT;
+		goto out;
+	}
+	*ppos = end;
+out:
+	free_page((unsigned long)page);
+	return count;
+}
+
+static struct file_operations sel_policyvers_ops = {
+	.read		= sel_read_policyvers,
+};
+
+static ssize_t sel_write_load(struct file * file, const char * buf,
+			      size_t count, loff_t *ppos)
+
+{
+	ssize_t length;
+	void *data;
+
+	length = task_has_security(current, SECURITY__LOAD_POLICY);
+	if (length)
+		return length;
+
+	if (*ppos != 0) {
+		/* No partial writes. */
+		return -EINVAL;
+	}
+
+	if ((count < 0) || (count > 64 * 1024 * 1024) || (data = vmalloc(count)) == NULL)
+		return -ENOMEM;
+
+	length = -EFAULT;
+	if (copy_from_user(data, buf, count) != 0)
+		goto out;
+
+	length = security_load_policy(data, count);
+	if (length)
+		goto out;
+
+	length = count;
+out:
+	vfree(data);
+	return length;
+}
+
+static struct file_operations sel_load_ops = {
+	.write		= sel_write_load,
+};
+
+
+static ssize_t sel_write_context(struct file * file, const char * buf,
+				 size_t count, loff_t *ppos)
+
+{
+	char *page;
+	u32 sid;
+	ssize_t length;
+
+	length = task_has_security(current, SECURITY__CHECK_CONTEXT);
+	if (length)
+		return length;
+
+	if (count < 0 || count >= PAGE_SIZE)
+		return -ENOMEM;
+	if (*ppos != 0) {
+		/* No partial writes. */
+		return -EINVAL;
+	}
+	page = (char*)__get_free_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+	memset(page, 0, PAGE_SIZE);
+	length = -EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out;
+
+	length = security_context_to_sid(page, count, &sid);
+	if (length < 0)
+		goto out;
+
+	length = count;
+out:
+	free_page((unsigned long) page);
+	return length;
+}
+
+static struct file_operations sel_context_ops = {
+	.write		= sel_write_context,
+};
+
+
+/*
+ * Remaining nodes use transaction based IO methods like nfsd/nfsctl.c
+ */
+static ssize_t sel_write_access(struct file * file, char *buf, size_t size);
+static ssize_t sel_write_create(struct file * file, char *buf, size_t size);
+static ssize_t sel_write_relabel(struct file * file, char *buf, size_t size);
+static ssize_t sel_write_user(struct file * file, char *buf, size_t size);
+
+static ssize_t (*write_op[])(struct file *, char *, size_t) = {
+	[SEL_ACCESS] = sel_write_access,
+	[SEL_CREATE] = sel_write_create,
+	[SEL_RELABEL] = sel_write_relabel,
+	[SEL_USER] = sel_write_user,
+};
+
+/* an argresp is stored in an allocated page and holds the
+ * size of the argument or response, along with its content
+ */
+struct argresp {
+	ssize_t size;
+	char data[0];
+};
+
+#define PAYLOAD_SIZE (PAGE_SIZE - sizeof(struct argresp))
+
+/*
+ * transaction based IO methods.
+ * The file expects a single write which triggers the transaction, and then
+ * possibly a read which collects the result - which is stored in a
+ * file-local buffer.
+ */
+static ssize_t TA_write(struct file *file, const char *buf, size_t size, loff_t *pos)
+{
+	ino_t ino =  file->f_dentry->d_inode->i_ino;
+	struct argresp *ar;
+	ssize_t rv = 0;
+
+	if (ino >= sizeof(write_op)/sizeof(write_op[0]) || !write_op[ino])
+		return -EINVAL;
+	if (file->private_data)
+		return -EINVAL; /* only one write allowed per open */
+	if (size > PAYLOAD_SIZE - 1) /* allow one byte for null terminator */
+		return -EFBIG;
+
+	ar = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!ar)
+		return -ENOMEM;
+	memset(ar, 0, PAGE_SIZE); /* clear buffer, particularly last byte */
+	ar->size = 0;
+	down(&file->f_dentry->d_inode->i_sem);
+	if (file->private_data)
+		rv = -EINVAL;
+	else
+		file->private_data = ar;
+	up(&file->f_dentry->d_inode->i_sem);
+	if (rv) {
+		kfree(ar);
+		return rv;
+	}
+	if (copy_from_user(ar->data, buf, size))
+		return -EFAULT;
+
+	rv =  write_op[ino](file, ar->data, size);
+	if (rv>0) {
+		ar->size = rv;
+		rv = size;
+	}
+	return rv;
+}
+
+static ssize_t TA_read(struct file *file, char *buf, size_t size, loff_t *pos)
+{
+	struct argresp *ar;
+	ssize_t rv = 0;
+
+	if (file->private_data == NULL)
+		rv = TA_write(file, buf, 0, pos);
+	if (rv < 0)
+		return rv;
+
+	ar = file->private_data;
+	if (!ar)
+		return 0;
+	if (*pos >= ar->size)
+		return 0;
+	if (*pos + size > ar->size)
+		size = ar->size - *pos;
+	if (copy_to_user(buf, ar->data + *pos, size))
+		return -EFAULT;
+	*pos += size;
+	return size;
+}
+
+static int TA_open(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+static int TA_release(struct inode *inode, struct file *file)
+{
+	void *p = file->private_data;
+	file->private_data = NULL;
+	kfree(p);
+	return 0;
+}
+
+static struct file_operations transaction_ops = {
+	.write		= TA_write,
+	.read		= TA_read,
+	.open		= TA_open,
+	.release	= TA_release,
+};
+
+/*
+ * payload - write methods
+ * If the method has a response, the response should be put in buf,
+ * and the length returned.  Otherwise return 0 or and -error.
+ */
+
+static ssize_t sel_write_access(struct file * file, char *buf, size_t size)
+{
+	char *scon, *tcon;
+	u32 ssid, tsid;
+	u16 tclass;
+	u32 req;
+	struct av_decision avd;
+	ssize_t length;
+
+	length = task_has_security(current, SECURITY__COMPUTE_AV);
+	if (length)
+		return length;
+
+	length = -ENOMEM;
+	scon = kmalloc(size+1, GFP_KERNEL);
+	if (!scon)
+		return length;
+	memset(scon, 0, size+1);
+
+	tcon = kmalloc(size+1, GFP_KERNEL);
+	if (!tcon)
+		goto out;
+	memset(tcon, 0, size+1);
+
+	length = -EINVAL;
+	if (sscanf(buf, "%s %s %hu %x", scon, tcon, &tclass, &req) != 4)
+		goto out2;
+
+	length = security_context_to_sid(scon, strlen(scon)+1, &ssid);
+	if (length < 0)
+		goto out2;
+	length = security_context_to_sid(tcon, strlen(tcon)+1, &tsid);
+	if (length < 0)
+		goto out2;
+
+	length = security_compute_av(ssid, tsid, tclass, req, &avd);
+	if (length < 0)
+		goto out2;
+
+	length = snprintf(buf, PAYLOAD_SIZE, "%x %x %x %x %u",
+			  avd.allowed, avd.decided,
+			  avd.auditallow, avd.auditdeny,
+			  avd.seqno);
+out2:
+	kfree(tcon);
+out:
+	kfree(scon);
+	return length;
+}
+
+static ssize_t sel_write_create(struct file * file, char *buf, size_t size)
+{
+	char *scon, *tcon;
+	u32 ssid, tsid, newsid;
+	u16 tclass;
+	ssize_t length;
+	char *newcon;
+	u32 len;
+
+	length = task_has_security(current, SECURITY__COMPUTE_CREATE);
+	if (length)
+		return length;
+
+	length = -ENOMEM;
+	scon = kmalloc(size+1, GFP_KERNEL);
+	if (!scon)
+		return length;
+	memset(scon, 0, size+1);
+
+	tcon = kmalloc(size+1, GFP_KERNEL);
+	if (!tcon)
+		goto out;
+	memset(tcon, 0, size+1);
+
+	length = -EINVAL;
+	if (sscanf(buf, "%s %s %hu", scon, tcon, &tclass) != 3)
+		goto out2;
+
+	length = security_context_to_sid(scon, strlen(scon)+1, &ssid);
+	if (length < 0)
+		goto out2;
+	length = security_context_to_sid(tcon, strlen(tcon)+1, &tsid);
+	if (length < 0)
+		goto out2;
+
+	length = security_transition_sid(ssid, tsid, tclass, &newsid);
+	if (length < 0)
+		goto out2;
+
+	length = security_sid_to_context(newsid, &newcon, &len);
+	if (length < 0)
+		goto out2;
+
+	if (len > PAYLOAD_SIZE) {
+		printk(KERN_ERR "%s:  context size (%u) exceeds payload "
+		       "max\n", __FUNCTION__, len);
+		length = -ERANGE;
+		goto out3;
+	}
+
+	memcpy(buf, newcon, len);
+	length = len;
+out3:
+	kfree(newcon);
+out2:
+	kfree(tcon);
+out:
+	kfree(scon);
+	return length;
+}
+
+static ssize_t sel_write_relabel(struct file * file, char *buf, size_t size)
+{
+	char *scon, *tcon;
+	u32 ssid, tsid, newsid;
+	u16 tclass;
+	ssize_t length;
+	char *newcon;
+	u32 len;
+
+	length = task_has_security(current, SECURITY__COMPUTE_RELABEL);
+	if (length)
+		return length;
+
+	length = -ENOMEM;
+	scon = kmalloc(size+1, GFP_KERNEL);
+	if (!scon)
+		return length;
+	memset(scon, 0, size+1);
+
+	tcon = kmalloc(size+1, GFP_KERNEL);
+	if (!tcon)
+		goto out;
+	memset(tcon, 0, size+1);
+
+	length = -EINVAL;
+	if (sscanf(buf, "%s %s %hu", scon, tcon, &tclass) != 3)
+		goto out2;
+
+	length = security_context_to_sid(scon, strlen(scon)+1, &ssid);
+	if (length < 0)
+		goto out2;
+	length = security_context_to_sid(tcon, strlen(tcon)+1, &tsid);
+	if (length < 0)
+		goto out2;
+
+	length = security_change_sid(ssid, tsid, tclass, &newsid);
+	if (length < 0)
+		goto out2;
+
+	length = security_sid_to_context(newsid, &newcon, &len);
+	if (length < 0)
+		goto out2;
+
+	if (len > PAYLOAD_SIZE) {
+		length = -ERANGE;
+		goto out3;
+	}
+
+	memcpy(buf, newcon, len);
+	length = len;
+out3:
+	kfree(newcon);
+out2:
+	kfree(tcon);
+out:
+	kfree(scon);
+	return length;
+}
+
+static ssize_t sel_write_user(struct file * file, char *buf, size_t size)
+{
+	char *con, *user, *ptr;
+	u32 sid, *sids;
+	ssize_t length;
+	char *newcon;
+	int i, rc;
+	u32 len, nsids;
+
+	length = task_has_security(current, SECURITY__COMPUTE_USER);
+	if (length)
+		return length;
+
+	length = -ENOMEM;
+	con = kmalloc(size+1, GFP_KERNEL);
+	if (!con)
+		return length;
+	memset(con, 0, size+1);
+
+	user = kmalloc(size+1, GFP_KERNEL);
+	if (!user)
+		goto out;
+	memset(user, 0, size+1);
+
+	length = -EINVAL;
+	if (sscanf(buf, "%s %s", con, user) != 2)
+		goto out2;
+
+	length = security_context_to_sid(con, strlen(con)+1, &sid);
+	if (length < 0)
+		goto out2;
+
+	length = security_get_user_sids(sid, user, &sids, &nsids);
+	if (length < 0)
+		goto out2;
+
+	length = sprintf(buf, "%u", nsids) + 1;
+	ptr = buf + length;
+	for (i = 0; i < nsids; i++) {
+		rc = security_sid_to_context(sids[i], &newcon, &len);
+		if (rc) {
+			length = rc;
+			goto out3;
+		}
+		if ((length + len) >= PAYLOAD_SIZE) {
+			kfree(newcon);
+			length = -ERANGE;
+			goto out3;
+		}
+		memcpy(ptr, newcon, len);
+		kfree(newcon);
+		ptr += len;
+		length += len;
+	}
+out3:
+	kfree(sids);
+out2:
+	kfree(user);
+out:
+	kfree(con);
+	return length;
+}
+
+static struct super_block *sel_fill_super(struct super_block * sb, 
+					  void * data, int silent)
+{
+	static struct tree_descr selinux_files[] = {
+		[SEL_LOAD] = {"load", &sel_load_ops, S_IRUSR|S_IWUSR},
+		[SEL_ENFORCE] = {"enforce", &sel_enforce_ops, S_IRUSR|S_IWUSR},
+		[SEL_CONTEXT] = {"context", &sel_context_ops, S_IRUGO|S_IWUGO},
+		[SEL_ACCESS] = {"access", &transaction_ops, S_IRUGO|S_IWUGO},
+		[SEL_CREATE] = {"create", &transaction_ops, S_IRUGO|S_IWUGO},
+		[SEL_RELABEL] = {"relabel", &transaction_ops, S_IRUGO|S_IWUGO},
+		[SEL_USER] = {"user", &transaction_ops, S_IRUGO|S_IWUGO},
+		[SEL_POLICYVERS] = {"policyvers", &sel_policyvers_ops, S_IRUGO},
+		/* last one */ {""}
+	};
+	return simple_fill_super(sb, SELINUX_MAGIC, selinux_files);
+}
+
+static struct super_block *sel_read_sb(struct super_block * s, void *data, 
+				       int flags)
+{
+	return sel_fill_super(s, data, flags);
+}
+
+DECLARE_FSTYPE(sel_fs_type, "selinuxfs", sel_read_sb, FS_SINGLE);
+
+struct vfsmount *selinuxfs_mount;
+
+static int __init init_sel_fs(void)
+{
+	int err;
+
+	if (!selinux_enabled)
+		return 0;
+	err = register_filesystem(&sel_fs_type);
+	if (!err) {
+		selinuxfs_mount = kern_mount(&sel_fs_type);
+		if (IS_ERR(selinuxfs_mount)) {
+			printk(KERN_ERR "selinuxfs:  could not mount!\n");
+			err = PTR_ERR(selinuxfs_mount);
+			selinuxfs_mount = NULL;
+		}
+	}
+	return err;
+}
+
+__initcall(init_sel_fs);
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/avtab.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/avtab.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/avtab.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/avtab.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,268 @@
+/*
+ * Implementation of the access vector table type.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include "avtab.h"
+#include "policydb.h"
+
+#define AVTAB_HASH(keyp) \
+((keyp->target_class + \
+ (keyp->target_type << 2) + \
+ (keyp->source_type << 9)) & \
+ AVTAB_HASH_MASK)
+
+int avtab_insert(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)
+{
+	int hvalue;
+	struct avtab_node *prev, *cur, *newnode;
+
+	if (!h)
+		return -EINVAL;
+
+	hvalue = AVTAB_HASH(key);
+	for (prev = NULL, cur = h->htable[hvalue];
+	     cur;
+	     prev = cur, cur = cur->next) {
+		if (key->source_type == cur->key.source_type &&
+		    key->target_type == cur->key.target_type &&
+		    key->target_class == cur->key.target_class &&
+		    (datum->specified & cur->datum.specified))
+			return -EEXIST;
+		if (key->source_type < cur->key.source_type)
+			break;
+		if (key->source_type == cur->key.source_type &&
+		    key->target_type < cur->key.target_type)
+			break;
+		if (key->source_type == cur->key.source_type &&
+		    key->target_type == cur->key.target_type &&
+		    key->target_class < cur->key.target_class)
+			break;
+	}
+
+	newnode = kmalloc(sizeof(*newnode), GFP_KERNEL);
+	if (newnode == NULL)
+		return -ENOMEM;
+	memset(newnode, 0, sizeof(*newnode));
+	newnode->key = *key;
+	newnode->datum = *datum;
+	if (prev) {
+		newnode->next = prev->next;
+		prev->next = newnode;
+	} else {
+		newnode->next = h->htable[hvalue];
+		h->htable[hvalue] = newnode;
+	}
+
+	h->nel++;
+	return 0;
+}
+
+
+struct avtab_datum *avtab_search(struct avtab *h, struct avtab_key *key, int specified)
+{
+	int hvalue;
+	struct avtab_node *cur;
+
+	if (!h)
+		return NULL;
+
+	hvalue = AVTAB_HASH(key);
+	for (cur = h->htable[hvalue]; cur; cur = cur->next) {
+		if (key->source_type == cur->key.source_type &&
+		    key->target_type == cur->key.target_type &&
+		    key->target_class == cur->key.target_class &&
+		    (specified & cur->datum.specified))
+			return &cur->datum;
+
+		if (key->source_type < cur->key.source_type)
+			break;
+		if (key->source_type == cur->key.source_type &&
+		    key->target_type < cur->key.target_type)
+			break;
+		if (key->source_type == cur->key.source_type &&
+		    key->target_type == cur->key.target_type &&
+		    key->target_class < cur->key.target_class)
+			break;
+	}
+
+	return NULL;
+}
+
+void avtab_destroy(struct avtab *h)
+{
+	int i;
+	struct avtab_node *cur, *temp;
+
+	if (!h)
+		return;
+
+	for (i = 0; i < AVTAB_SIZE; i++) {
+		cur = h->htable[i];
+		while (cur != NULL) {
+			temp = cur;
+			cur = cur->next;
+			kfree(temp);
+		}
+		h->htable[i] = NULL;
+	}
+	vfree(h->htable);
+}
+
+
+int avtab_map(struct avtab *h,
+	      int (*apply) (struct avtab_key *k,
+			    struct avtab_datum *d,
+			    void *args),
+	      void *args)
+{
+	int i, ret;
+	struct avtab_node *cur;
+
+	if (!h)
+		return 0;
+
+	for (i = 0; i < AVTAB_SIZE; i++) {
+		cur = h->htable[i];
+		while (cur != NULL) {
+			ret = apply(&cur->key, &cur->datum, args);
+			if (ret)
+				return ret;
+			cur = cur->next;
+		}
+	}
+	return 0;
+}
+
+int avtab_init(struct avtab *h)
+{
+	int i;
+
+	h->htable = vmalloc(sizeof(*(h->htable)) * AVTAB_SIZE);
+	if (!h->htable)
+		return -ENOMEM;
+	for (i = 0; i < AVTAB_SIZE; i++)
+		h->htable[i] = NULL;
+	h->nel = 0;
+	return 0;
+}
+
+void avtab_hash_eval(struct avtab *h, char *tag)
+{
+	int i, chain_len, slots_used, max_chain_len;
+	struct avtab_node *cur;
+
+	slots_used = 0;
+	max_chain_len = 0;
+	for (i = 0; i < AVTAB_SIZE; i++) {
+		cur = h->htable[i];
+		if (cur) {
+			slots_used++;
+			chain_len = 0;
+			while (cur) {
+				chain_len++;
+				cur = cur->next;
+			}
+
+			if (chain_len > max_chain_len)
+				max_chain_len = chain_len;
+		}
+	}
+
+	printk(KERN_INFO "%s:  %d entries and %d/%d buckets used, longest "
+	       "chain length %d\n", tag, h->nel, slots_used, AVTAB_SIZE,
+	       max_chain_len);
+}
+
+int avtab_read(struct avtab *a, void *fp, u32 config)
+{
+	int i, rc = -EINVAL;
+	struct avtab_key avkey;
+	struct avtab_datum avdatum;
+	u32 *buf;
+	u32 nel, items, items2;
+
+
+	buf = next_entry(fp, sizeof(u32));
+	if (!buf) {
+		printk(KERN_ERR "security: avtab: truncated table\n");
+		goto bad;
+	}
+	nel = le32_to_cpu(buf[0]);
+	if (!nel) {
+		printk(KERN_ERR "security: avtab: table is empty\n");
+		goto bad;
+	}
+	for (i = 0; i < nel; i++) {
+		memset(&avkey, 0, sizeof(avkey));
+		memset(&avdatum, 0, sizeof(avdatum));
+
+		buf = next_entry(fp, sizeof(u32));
+		if (!buf) {
+			printk(KERN_ERR "security: avtab: truncated entry\n");
+			goto bad;
+		}
+		items2 = le32_to_cpu(buf[0]);
+		buf = next_entry(fp, sizeof(u32)*items2);
+		if (!buf) {
+			printk(KERN_ERR "security: avtab: truncated entry\n");
+			goto bad;
+		}
+		items = 0;
+		avkey.source_type = le32_to_cpu(buf[items++]);
+		avkey.target_type = le32_to_cpu(buf[items++]);
+		avkey.target_class = le32_to_cpu(buf[items++]);
+		avdatum.specified = le32_to_cpu(buf[items++]);
+		if (!(avdatum.specified & (AVTAB_AV | AVTAB_TYPE))) {
+			printk(KERN_ERR "security: avtab: null entry\n");
+			goto bad;
+		}
+		if ((avdatum.specified & AVTAB_AV) &&
+		    (avdatum.specified & AVTAB_TYPE)) {
+			printk(KERN_ERR "security: avtab: entry has both "
+			       "access vectors and types\n");
+			goto bad;
+		}
+		if (avdatum.specified & AVTAB_AV) {
+			if (avdatum.specified & AVTAB_ALLOWED)
+				avtab_allowed(&avdatum) = le32_to_cpu(buf[items++]);
+			if (avdatum.specified & AVTAB_AUDITDENY)
+				avtab_auditdeny(&avdatum) = le32_to_cpu(buf[items++]);
+			if (avdatum.specified & AVTAB_AUDITALLOW)
+				avtab_auditallow(&avdatum) = le32_to_cpu(buf[items++]);
+		} else {
+			if (avdatum.specified & AVTAB_TRANSITION)
+				avtab_transition(&avdatum) = le32_to_cpu(buf[items++]);
+			if (avdatum.specified & AVTAB_CHANGE)
+				avtab_change(&avdatum) = le32_to_cpu(buf[items++]);
+			if (avdatum.specified & AVTAB_MEMBER)
+				avtab_member(&avdatum) = le32_to_cpu(buf[items++]);
+		}
+		if (items != items2) {
+			printk(KERN_ERR "security: avtab: entry only had %d "
+			       "items, expected %d\n", items2, items);
+			goto bad;
+		}
+		rc = avtab_insert(a, &avkey, &avdatum);
+		if (rc) {
+			if (rc == -ENOMEM)
+				printk(KERN_ERR "security: avtab: out of memory\n");
+			if (rc == -EEXIST)
+				printk(KERN_ERR "security: avtab: duplicate entry\n");
+			goto bad;
+		}
+	}
+
+	rc = 0;
+out:
+	return rc;
+
+bad:
+	avtab_destroy(a);
+	goto out;
+}
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/avtab.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/avtab.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/avtab.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/avtab.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+ * An access vector table (avtab) is a hash table
+ * of access vectors and transition types indexed
+ * by a type pair and a class.  An access vector
+ * table is used to represent the type enforcement
+ * tables.
+ *
+ *  Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_AVTAB_H_
+#define _SS_AVTAB_H_
+
+struct avtab_key {
+	u32 source_type;	/* source type */
+	u32 target_type;	/* target type */
+	u32 target_class;	/* target object class */
+};
+
+struct avtab_datum {
+#define AVTAB_ALLOWED     1
+#define AVTAB_AUDITALLOW  2
+#define AVTAB_AUDITDENY   4
+#define AVTAB_AV         (AVTAB_ALLOWED | AVTAB_AUDITALLOW | AVTAB_AUDITDENY)
+#define AVTAB_TRANSITION 16
+#define AVTAB_MEMBER     32
+#define AVTAB_CHANGE     64
+#define AVTAB_TYPE       (AVTAB_TRANSITION | AVTAB_MEMBER | AVTAB_CHANGE)
+	u32 specified;	/* what fields are specified */
+	u32 data[3];	/* access vectors or types */
+#define avtab_allowed(x) (x)->data[0]
+#define avtab_auditdeny(x) (x)->data[1]
+#define avtab_auditallow(x) (x)->data[2]
+#define avtab_transition(x) (x)->data[0]
+#define avtab_change(x) (x)->data[1]
+#define avtab_member(x) (x)->data[2]
+};
+
+struct avtab_node {
+	struct avtab_key key;
+	struct avtab_datum datum;
+	struct avtab_node *next;
+};
+
+struct avtab {
+	struct avtab_node **htable;
+	u32 nel;	/* number of elements */
+};
+
+int avtab_init(struct avtab *);
+int avtab_insert(struct avtab *h, struct avtab_key *k, struct avtab_datum *d);
+struct avtab_datum *avtab_search(struct avtab *h, struct avtab_key *k, int specified);
+void avtab_destroy(struct avtab *h);
+int avtab_map(struct avtab *h,
+	      int (*apply) (struct avtab_key *k,
+			    struct avtab_datum *d,
+			    void *args),
+	      void *args);
+void avtab_hash_eval(struct avtab *h, char *tag);
+int avtab_read(struct avtab *a, void *fp, u32 config);
+
+#define AVTAB_HASH_BITS 15
+#define AVTAB_HASH_BUCKETS (1 << AVTAB_HASH_BITS)
+#define AVTAB_HASH_MASK (AVTAB_HASH_BUCKETS-1)
+
+#define AVTAB_SIZE AVTAB_HASH_BUCKETS
+
+#endif	/* _SS_AVTAB_H_ */
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/constraint.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/constraint.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/constraint.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/constraint.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * A constraint is a condition that must be satisfied in
+ * order for one or more permissions to be granted.
+ * Constraints are used to impose additional restrictions
+ * beyond the type-based rules in `te' or the role-based
+ * transition rules in `rbac'.  Constraints are typically
+ * used to prevent a process from transitioning to a new user
+ * identity or role unless it is in a privileged type.
+ * Constraints are likewise typically used to prevent a
+ * process from labeling an object with a different user
+ * identity.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_CONSTRAINT_H_
+#define _SS_CONSTRAINT_H_
+
+#include "ebitmap.h"
+
+#define CEXPR_MAXDEPTH 5
+
+struct constraint_expr {
+#define CEXPR_NOT		1 /* not expr */
+#define CEXPR_AND		2 /* expr and expr */
+#define CEXPR_OR		3 /* expr or expr */
+#define CEXPR_ATTR		4 /* attr op attr */
+#define CEXPR_NAMES		5 /* attr op names */
+	u32 expr_type;		/* expression type */
+
+#define CEXPR_USER 1		/* user */
+#define CEXPR_ROLE 2		/* role */
+#define CEXPR_TYPE 4		/* type */
+#define CEXPR_TARGET 8		/* target if set, source otherwise */
+	u32 attr;		/* attribute */
+
+#define CEXPR_EQ     1		/* == or eq */
+#define CEXPR_NEQ    2		/* != */
+#define CEXPR_DOM    3		/* dom */
+#define CEXPR_DOMBY  4		/* domby  */
+#define CEXPR_INCOMP 5		/* incomp */
+	u32 op;			/* operator */
+
+	struct ebitmap names;	/* names */
+
+	struct constraint_expr *next;   /* next expression */
+};
+
+struct constraint_node {
+	u32 permissions;	/* constrained permissions */
+	struct constraint_expr *expr;	/* constraint on permissions */
+	struct constraint_node *next;	/* next constraint */
+};
+
+#endif	/* _SS_CONSTRAINT_H_ */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/context.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/context.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/context.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/context.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,117 @@
+/*
+ * A security context is a set of security attributes
+ * associated with each subject and object controlled
+ * by the security policy.  Security contexts are
+  * externally represented as variable-length strings
+ * that can be interpreted by a user or application
+ * with an understanding of the security policy.
+ * Internally, the security server uses a simple
+ * structure.  This structure is private to the
+ * security server and can be changed without affecting
+ * clients of the security server.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_CONTEXT_H_
+#define _SS_CONTEXT_H_
+
+#include "ebitmap.h"
+#include "mls_types.h"
+
+/*
+ * A security context consists of an authenticated user
+ * identity, a role, a type and a MLS range.
+ */
+struct context {
+	u32 user;
+	u32 role;
+	u32 type;
+#ifdef CONFIG_SECURITY_SELINUX_MLS
+	struct mls_range range;
+#endif
+};
+
+#ifdef CONFIG_SECURITY_SELINUX_MLS
+
+static inline void mls_context_init(struct context *c)
+{
+	memset(&c->range, 0, sizeof(c->range));
+}
+
+static inline int mls_context_cpy(struct context *dst, struct context *src)
+{
+	int rc;
+
+	dst->range.level[0].sens = src->range.level[0].sens;
+	rc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[0].cat);
+	if (rc)
+		goto out;
+
+	dst->range.level[1].sens = src->range.level[1].sens;
+	rc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[1].cat);
+	if (rc)
+		ebitmap_destroy(&dst->range.level[0].cat);
+out:
+	return rc;
+}
+
+static inline int mls_context_cmp(struct context *c1, struct context *c2)
+{
+	return ((c1->range.level[0].sens == c2->range.level[0].sens) &&
+		ebitmap_cmp(&c1->range.level[0].cat,&c2->range.level[0].cat) &&
+		(c1->range.level[1].sens == c2->range.level[1].sens) &&
+		ebitmap_cmp(&c1->range.level[1].cat,&c2->range.level[1].cat));
+}
+
+static inline void mls_context_destroy(struct context *c)
+{
+	ebitmap_destroy(&c->range.level[0].cat);
+	ebitmap_destroy(&c->range.level[1].cat);
+	mls_context_init(c);
+}
+
+#else
+
+static inline void mls_context_init(struct context *c)
+{ }
+
+static inline int mls_context_cpy(struct context *dst, struct context *src)
+{ return 0; }
+
+static inline int mls_context_cmp(struct context *c1, struct context *c2)
+{ return 1; }
+
+static inline void mls_context_destroy(struct context *c)
+{ }
+
+#endif
+
+static inline void context_init(struct context *c)
+{
+	memset(c, 0, sizeof(*c));
+}
+
+static inline int context_cpy(struct context *dst, struct context *src)
+{
+	dst->user = src->user;
+	dst->role = src->role;
+	dst->type = src->type;
+	return mls_context_cpy(dst, src);
+}
+
+static inline void context_destroy(struct context *c)
+{
+	c->user = c->role = c->type = 0;
+	mls_context_destroy(c);
+}
+
+static inline int context_cmp(struct context *c1, struct context *c2)
+{
+	return ((c1->user == c2->user) &&
+		(c1->role == c2->role) &&
+		(c1->type == c2->type) &&
+		mls_context_cmp(c1, c2));
+}
+
+#endif	/* _SS_CONTEXT_H_ */
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/ebitmap.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/ebitmap.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/ebitmap.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/ebitmap.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,335 @@
+/*
+ * Implementation of the extensible bitmap type.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include "ebitmap.h"
+#include "policydb.h"
+
+int ebitmap_or(struct ebitmap *dst, struct ebitmap *e1, struct ebitmap *e2)
+{
+	struct ebitmap_node *n1, *n2, *new, *prev;
+
+	ebitmap_init(dst);
+
+	n1 = e1->node;
+	n2 = e2->node;
+	prev = 0;
+	while (n1 || n2) {
+		new = kmalloc(sizeof(*new), GFP_ATOMIC);
+		if (!new) {
+			ebitmap_destroy(dst);
+			return -ENOMEM;
+		}
+		memset(new, 0, sizeof(*new));
+		if (n1 && n2 && n1->startbit == n2->startbit) {
+			new->startbit = n1->startbit;
+			new->map = n1->map | n2->map;
+			n1 = n1->next;
+			n2 = n2->next;
+		} else if (!n2 || (n1 && n1->startbit < n2->startbit)) {
+			new->startbit = n1->startbit;
+			new->map = n1->map;
+			n1 = n1->next;
+		} else {
+			new->startbit = n2->startbit;
+			new->map = n2->map;
+			n2 = n2->next;
+		}
+
+		new->next = 0;
+		if (prev)
+			prev->next = new;
+		else
+			dst->node = new;
+		prev = new;
+	}
+
+	dst->highbit = (e1->highbit > e2->highbit) ? e1->highbit : e2->highbit;
+	return 0;
+}
+
+int ebitmap_cmp(struct ebitmap *e1, struct ebitmap *e2)
+{
+	struct ebitmap_node *n1, *n2;
+
+	if (e1->highbit != e2->highbit)
+		return 0;
+
+	n1 = e1->node;
+	n2 = e2->node;
+	while (n1 && n2 &&
+	       (n1->startbit == n2->startbit) &&
+	       (n1->map == n2->map)) {
+		n1 = n1->next;
+		n2 = n2->next;
+	}
+
+	if (n1 || n2)
+		return 0;
+
+	return 1;
+}
+
+int ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)
+{
+	struct ebitmap_node *n, *new, *prev;
+
+	ebitmap_init(dst);
+	n = src->node;
+	prev = 0;
+	while (n) {
+		new = kmalloc(sizeof(*new), GFP_ATOMIC);
+		if (!new) {
+			ebitmap_destroy(dst);
+			return -ENOMEM;
+		}
+		memset(new, 0, sizeof(*new));
+		new->startbit = n->startbit;
+		new->map = n->map;
+		new->next = 0;
+		if (prev)
+			prev->next = new;
+		else
+			dst->node = new;
+		prev = new;
+		n = n->next;
+	}
+
+	dst->highbit = src->highbit;
+	return 0;
+}
+
+int ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2)
+{
+	struct ebitmap_node *n1, *n2;
+
+	if (e1->highbit < e2->highbit)
+		return 0;
+
+	n1 = e1->node;
+	n2 = e2->node;
+	while (n1 && n2 && (n1->startbit <= n2->startbit)) {
+		if (n1->startbit < n2->startbit) {
+			n1 = n1->next;
+			continue;
+		}
+		if ((n1->map & n2->map) != n2->map)
+			return 0;
+
+		n1 = n1->next;
+		n2 = n2->next;
+	}
+
+	if (n2)
+		return 0;
+
+	return 1;
+}
+
+int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)
+{
+	struct ebitmap_node *n;
+
+	if (e->highbit < bit)
+		return 0;
+
+	n = e->node;
+	while (n && (n->startbit <= bit)) {
+		if ((n->startbit + MAPSIZE) > bit) {
+			if (n->map & (MAPBIT << (bit - n->startbit)))
+				return 1;
+			else
+				return 0;
+		}
+		n = n->next;
+	}
+
+	return 0;
+}
+
+int ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)
+{
+	struct ebitmap_node *n, *prev, *new;
+
+	prev = 0;
+	n = e->node;
+	while (n && n->startbit <= bit) {
+		if ((n->startbit + MAPSIZE) > bit) {
+			if (value) {
+				n->map |= (MAPBIT << (bit - n->startbit));
+			} else {
+				n->map &= ~(MAPBIT << (bit - n->startbit));
+				if (!n->map) {
+					/* drop this node from the bitmap */
+
+					if (!n->next) {
+						/*
+						 * this was the highest map
+						 * within the bitmap
+						 */
+						if (prev)
+							e->highbit = prev->startbit + MAPSIZE;
+						else
+							e->highbit = 0;
+					}
+					if (prev)
+						prev->next = n->next;
+					else
+						e->node = n->next;
+
+					kfree(n);
+				}
+			}
+			return 0;
+		}
+		prev = n;
+		n = n->next;
+	}
+
+	if (!value)
+		return 0;
+
+	new = kmalloc(sizeof(*new), GFP_ATOMIC);
+	if (!new)
+		return -ENOMEM;
+	memset(new, 0, sizeof(*new));
+
+	new->startbit = bit & ~(MAPSIZE - 1);
+	new->map = (MAPBIT << (bit - new->startbit));
+
+	if (!n)
+		/* this node will be the highest map within the bitmap */
+		e->highbit = new->startbit + MAPSIZE;
+
+	if (prev) {
+		new->next = prev->next;
+		prev->next = new;
+	} else {
+		new->next = e->node;
+		e->node = new;
+	}
+
+	return 0;
+}
+
+void ebitmap_destroy(struct ebitmap *e)
+{
+	struct ebitmap_node *n, *temp;
+
+	if (!e)
+		return;
+
+	n = e->node;
+	while (n) {
+		temp = n;
+		n = n->next;
+		kfree(temp);
+	}
+
+	e->highbit = 0;
+	e->node = 0;
+	return;
+}
+
+int ebitmap_read(struct ebitmap *e, void *fp)
+{
+	int rc = -EINVAL;
+	struct ebitmap_node *n, *l;
+	u32 *buf, mapsize, count, i;
+	u64 map;
+
+	ebitmap_init(e);
+
+	buf = next_entry(fp, sizeof(u32)*3);
+	if (!buf)
+		goto out;
+
+	mapsize = le32_to_cpu(buf[0]);
+	e->highbit = le32_to_cpu(buf[1]);
+	count = le32_to_cpu(buf[2]);
+
+	if (mapsize != MAPSIZE) {
+		printk(KERN_ERR "security: ebitmap: map size %u does not "
+		       "match my size %Zd (high bit was %d)\n", mapsize,
+		       MAPSIZE, e->highbit);
+		goto out;
+	}
+	if (!e->highbit) {
+		e->node = NULL;
+		goto ok;
+	}
+	if (e->highbit & (MAPSIZE - 1)) {
+		printk(KERN_ERR "security: ebitmap: high bit (%d) is not a "
+		       "multiple of the map size (%Zd)\n", e->highbit, MAPSIZE);
+		goto bad;
+	}
+	l = NULL;
+	for (i = 0; i < count; i++) {
+		buf = next_entry(fp, sizeof(u32));
+		if (!buf) {
+			printk(KERN_ERR "security: ebitmap: truncated map\n");
+			goto bad;
+		}
+		n = kmalloc(sizeof(*n), GFP_KERNEL);
+		if (!n) {
+			printk(KERN_ERR "security: ebitmap: out of memory\n");
+			rc = -ENOMEM;
+			goto bad;
+		}
+		memset(n, 0, sizeof(*n));
+
+		n->startbit = le32_to_cpu(buf[0]);
+
+		if (n->startbit & (MAPSIZE - 1)) {
+			printk(KERN_ERR "security: ebitmap start bit (%d) is "
+			       "not a multiple of the map size (%Zd)\n",
+			       n->startbit, MAPSIZE);
+			goto bad_free;
+		}
+		if (n->startbit > (e->highbit - MAPSIZE)) {
+			printk(KERN_ERR "security: ebitmap start bit (%d) is "
+			       "beyond the end of the bitmap (%Zd)\n",
+			       n->startbit, (e->highbit - MAPSIZE));
+			goto bad_free;
+		}
+		buf = next_entry(fp, sizeof(u64));
+		if (!buf) {
+			printk(KERN_ERR "security: ebitmap: truncated map\n");
+			goto bad_free;
+		}
+		memcpy(&map, buf, sizeof(u64));
+		n->map = le64_to_cpu(map);
+
+		if (!n->map) {
+			printk(KERN_ERR "security: ebitmap: null map in "
+			       "ebitmap (startbit %d)\n", n->startbit);
+			goto bad_free;
+		}
+		if (l) {
+			if (n->startbit <= l->startbit) {
+				printk(KERN_ERR "security: ebitmap: start "
+				       "bit %d comes after start bit %d\n",
+				       n->startbit, l->startbit);
+				goto bad_free;
+			}
+			l->next = n;
+		} else
+			e->node = n;
+
+		l = n;
+	}
+
+ok:
+	rc = 0;
+out:
+	return rc;
+bad_free:
+	kfree(n);
+bad:
+	ebitmap_destroy(e);
+	goto out;
+}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/ebitmap.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/ebitmap.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/ebitmap.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/ebitmap.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * An extensible bitmap is a bitmap that supports an
+ * arbitrary number of bits.  Extensible bitmaps are
+ * used to represent sets of values, such as types,
+ * roles, categories, and classes.
+ *
+ * Each extensible bitmap is implemented as a linked
+ * list of bitmap nodes, where each bitmap node has
+ * an explicitly specified starting bit position within
+ * the total bitmap.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_EBITMAP_H_
+#define _SS_EBITMAP_H_
+
+#define MAPTYPE u64			/* portion of bitmap in each node */
+#define MAPSIZE (sizeof(MAPTYPE) * 8)	/* number of bits in node bitmap */
+#define MAPBIT  1ULL			/* a bit in the node bitmap */
+
+struct ebitmap_node {
+	u32 startbit;		/* starting position in the total bitmap */
+	MAPTYPE map;		/* this node's portion of the bitmap */
+	struct ebitmap_node *next;
+};
+
+struct ebitmap {
+	struct ebitmap_node *node;	/* first node in the bitmap */
+	u32 highbit;	/* highest position in the total bitmap */
+};
+
+#define ebitmap_length(e) ((e)->highbit)
+#define ebitmap_startbit(e) ((e)->node ? (e)->node->startbit : 0)
+
+static inline void ebitmap_init(struct ebitmap *e)
+{
+	memset(e, 0, sizeof(*e));
+}
+
+int ebitmap_cmp(struct ebitmap *e1, struct ebitmap *e2);
+int ebitmap_or(struct ebitmap *dst, struct ebitmap *e1, struct ebitmap *e2);
+int ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src);
+int ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2);
+int ebitmap_get_bit(struct ebitmap *e, unsigned long bit);
+int ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value);
+void ebitmap_destroy(struct ebitmap *e);
+int ebitmap_read(struct ebitmap *e, void *fp);
+
+#endif	/* _SS_EBITMAP_H_ */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/hashtab.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/hashtab.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/hashtab.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/hashtab.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,280 @@
+/*
+ * Implementation of the hash table type.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include "hashtab.h"
+
+struct hashtab *hashtab_create(u32 (*hash_value)(struct hashtab *h, void *key),
+                               int (*keycmp)(struct hashtab *h, void *key1, void *key2),
+                               u32 size)
+{
+	struct hashtab *p;
+	u32 i;
+
+	p = kmalloc(sizeof(*p), GFP_KERNEL);
+	if (p == NULL)
+		return p;
+
+	memset(p, 0, sizeof(*p));
+	p->size = size;
+	p->nel = 0;
+	p->hash_value = hash_value;
+	p->keycmp = keycmp;
+	p->htable = kmalloc(sizeof(*(p->htable)) * size, GFP_KERNEL);
+	if (p->htable == NULL) {
+		kfree(p);
+		return NULL;
+	}
+
+	for (i = 0; i < size; i++)
+		p->htable[i] = NULL;
+
+	return p;
+}
+
+int hashtab_insert(struct hashtab *h, void *key, void *datum)
+{
+	u32 hvalue;
+	struct hashtab_node *prev, *cur, *newnode;
+
+	if (!h || h->nel == HASHTAB_MAX_NODES)
+		return -EINVAL;
+
+	hvalue = h->hash_value(h, key);
+	prev = NULL;
+	cur = h->htable[hvalue];
+	while (cur && h->keycmp(h, key, cur->key) > 0) {
+		prev = cur;
+		cur = cur->next;
+	}
+
+	if (cur && (h->keycmp(h, key, cur->key) == 0))
+		return -EEXIST;
+
+	newnode = kmalloc(sizeof(*newnode), GFP_KERNEL);
+	if (newnode == NULL)
+		return -ENOMEM;
+	memset(newnode, 0, sizeof(*newnode));
+	newnode->key = key;
+	newnode->datum = datum;
+	if (prev) {
+		newnode->next = prev->next;
+		prev->next = newnode;
+	} else {
+		newnode->next = h->htable[hvalue];
+		h->htable[hvalue] = newnode;
+	}
+
+	h->nel++;
+	return 0;
+}
+
+int hashtab_remove(struct hashtab *h, void *key,
+		   void (*destroy)(void *k, void *d, void *args),
+		   void *args)
+{
+	u32 hvalue;
+	struct hashtab_node *cur, *last;
+
+	if (!h)
+		return -EINVAL;
+
+	hvalue = h->hash_value(h, key);
+	last = NULL;
+	cur = h->htable[hvalue];
+	while (cur != NULL && h->keycmp(h, key, cur->key) > 0) {
+		last = cur;
+		cur = cur->next;
+	}
+
+	if (cur == NULL || (h->keycmp(h, key, cur->key) != 0))
+		return -ENOENT;
+
+	if (last == NULL)
+		h->htable[hvalue] = cur->next;
+	else
+		last->next = cur->next;
+
+	if (destroy)
+		destroy(cur->key, cur->datum, args);
+	kfree(cur);
+	h->nel--;
+	return 0;
+}
+
+int hashtab_replace(struct hashtab *h, void *key, void *datum,
+		    void (*destroy)(void *k, void *d, void *args),
+		    void *args)
+{
+	u32 hvalue;
+	struct hashtab_node *prev, *cur, *newnode;
+
+	if (!h)
+		return -EINVAL;
+
+	hvalue = h->hash_value(h, key);
+	prev = NULL;
+	cur = h->htable[hvalue];
+	while (cur != NULL && h->keycmp(h, key, cur->key) > 0) {
+		prev = cur;
+		cur = cur->next;
+	}
+
+	if (cur && (h->keycmp(h, key, cur->key) == 0)) {
+		if (destroy)
+			destroy(cur->key, cur->datum, args);
+		cur->key = key;
+		cur->datum = datum;
+	} else {
+		newnode = kmalloc(sizeof(*newnode), GFP_KERNEL);
+		if (newnode == NULL)
+			return -ENOMEM;
+		memset(newnode, 0, sizeof(*newnode));
+		newnode->key = key;
+		newnode->datum = datum;
+		if (prev) {
+			newnode->next = prev->next;
+			prev->next = newnode;
+		} else {
+			newnode->next = h->htable[hvalue];
+			h->htable[hvalue] = newnode;
+		}
+	}
+
+	return 0;
+}
+
+void *hashtab_search(struct hashtab *h, void *key)
+{
+	u32 hvalue;
+	struct hashtab_node *cur;
+
+	if (!h)
+		return NULL;
+
+	hvalue = h->hash_value(h, key);
+	cur = h->htable[hvalue];
+	while (cur != NULL && h->keycmp(h, key, cur->key) > 0)
+		cur = cur->next;
+
+	if (cur == NULL || (h->keycmp(h, key, cur->key) != 0))
+		return NULL;
+
+	return cur->datum;
+}
+
+void hashtab_destroy(struct hashtab *h)
+{
+	u32 i;
+	struct hashtab_node *cur, *temp;
+
+	if (!h)
+		return;
+
+	for (i = 0; i < h->size; i++) {
+		cur = h->htable[i];
+		while (cur != NULL) {
+			temp = cur;
+			cur = cur->next;
+			kfree(temp);
+		}
+		h->htable[i] = NULL;
+	}
+
+	kfree(h->htable);
+	h->htable = NULL;
+
+	kfree(h);
+}
+
+int hashtab_map(struct hashtab *h,
+		int (*apply)(void *k, void *d, void *args),
+		void *args)
+{
+	u32 i;
+	int ret;
+	struct hashtab_node *cur;
+
+	if (!h)
+		return 0;
+
+	for (i = 0; i < h->size; i++) {
+		cur = h->htable[i];
+		while (cur != NULL) {
+			ret = apply(cur->key, cur->datum, args);
+			if (ret)
+				return ret;
+			cur = cur->next;
+		}
+	}
+	return 0;
+}
+
+
+void hashtab_map_remove_on_error(struct hashtab *h,
+                                 int (*apply)(void *k, void *d, void *args),
+                                 void (*destroy)(void *k, void *d, void *args),
+                                 void *args)
+{
+	u32 i;
+	int ret;
+	struct hashtab_node *last, *cur, *temp;
+
+	if (!h)
+		return;
+
+	for (i = 0; i < h->size; i++) {
+		last = NULL;
+		cur = h->htable[i];
+		while (cur != NULL) {
+			ret = apply(cur->key, cur->datum, args);
+			if (ret) {
+				if (last)
+					last->next = cur->next;
+				else
+					h->htable[i] = cur->next;
+
+				temp = cur;
+				cur = cur->next;
+				if (destroy)
+					destroy(temp->key, temp->datum, args);
+				kfree(temp);
+				h->nel--;
+			} else {
+				last = cur;
+				cur = cur->next;
+			}
+		}
+	}
+	return;
+}
+
+void hashtab_stat(struct hashtab *h, struct hashtab_info *info)
+{
+	u32 i, chain_len, slots_used, max_chain_len;
+	struct hashtab_node *cur;
+
+	slots_used = 0;
+	max_chain_len = 0;
+	for (slots_used = max_chain_len = i = 0; i < h->size; i++) {
+		cur = h->htable[i];
+		if (cur) {
+			slots_used++;
+			chain_len = 0;
+			while (cur) {
+				chain_len++;
+				cur = cur->next;
+			}
+
+			if (chain_len > max_chain_len)
+				max_chain_len = chain_len;
+		}
+	}
+
+	info->slots_used = slots_used;
+	info->max_chain_len = max_chain_len;
+}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/hashtab.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/hashtab.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/hashtab.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/hashtab.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,125 @@
+/*
+ * A hash table (hashtab) maintains associations between
+ * key values and datum values.  The type of the key values
+ * and the type of the datum values is arbitrary.  The
+ * functions for hash computation and key comparison are
+ * provided by the creator of the table.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_HASHTAB_H_
+#define _SS_HASHTAB_H_
+
+#define HASHTAB_MAX_NODES	0xffffffff
+
+struct hashtab_node {
+	void *key;
+	void *datum;
+	struct hashtab_node *next;
+};
+
+struct hashtab {
+	struct hashtab_node **htable;	/* hash table */
+	u32 size;			/* number of slots in hash table */
+	u32 nel;			/* number of elements in hash table */
+	u32 (*hash_value)(struct hashtab *h, void *key);
+					/* hash function */
+	int (*keycmp)(struct hashtab *h, void *key1, void *key2);
+					/* key comparison function */
+};
+
+struct hashtab_info {
+	u32 slots_used;
+	u32 max_chain_len;
+};
+
+/*
+ * Creates a new hash table with the specified characteristics.
+ *
+ * Returns NULL if insufficent space is available or
+ * the new hash table otherwise.
+ */
+struct hashtab *hashtab_create(u32 (*hash_value)(struct hashtab *h, void *key),
+                               int (*keycmp)(struct hashtab *h, void *key1, void *key2),
+                               u32 size);
+
+/*
+ * Inserts the specified (key, datum) pair into the specified hash table.
+ *
+ * Returns -ENOMEM on memory allocation error,
+ * -EEXIST if there is already an entry with the same key,
+ * -EINVAL for general errors or
+ * 0 otherwise.
+ */
+int hashtab_insert(struct hashtab *h, void *k, void *d);
+
+/*
+ * Removes the entry with the specified key from the hash table.
+ * Applies the specified destroy function to (key,datum,args) for
+ * the entry.
+ *
+ * Returns -ENOENT if no entry has the specified key,
+ * -EINVAL for general errors or
+ *0 otherwise.
+ */
+int hashtab_remove(struct hashtab *h, void *k,
+		   void (*destroy)(void *k, void *d, void *args),
+		   void *args);
+
+/*
+ * Insert or replace the specified (key, datum) pair in the specified
+ * hash table.  If an entry for the specified key already exists,
+ * then the specified destroy function is applied to (key,datum,args)
+ * for the entry prior to replacing the entry's contents.
+ *
+ * Returns -ENOMEM if insufficient space is available,
+ * -EINVAL for general errors or
+ * 0 otherwise.
+ */
+int hashtab_replace(struct hashtab *h, void *k, void *d,
+		    void (*destroy)(void *k, void *d, void *args),
+		    void *args);
+
+/*
+ * Searches for the entry with the specified key in the hash table.
+ *
+ * Returns NULL if no entry has the specified key or
+ * the datum of the entry otherwise.
+ */
+void *hashtab_search(struct hashtab *h, void *k);
+
+/*
+ * Destroys the specified hash table.
+ */
+void hashtab_destroy(struct hashtab *h);
+
+/*
+ * Applies the specified apply function to (key,datum,args)
+ * for each entry in the specified hash table.
+ *
+ * The order in which the function is applied to the entries
+ * is dependent upon the internal structure of the hash table.
+ *
+ * If apply returns a non-zero status, then hashtab_map will cease
+ * iterating through the hash table and will propagate the error
+ * return to its caller.
+ */
+int hashtab_map(struct hashtab *h,
+		int (*apply)(void *k, void *d, void *args),
+		void *args);
+
+/*
+ * Same as hashtab_map, except that if apply returns a non-zero status,
+ * then the (key,datum) pair will be removed from the hashtab and the
+ * destroy function will be applied to (key,datum,args).
+ */
+void hashtab_map_remove_on_error(struct hashtab *h,
+                                 int (*apply)(void *k, void *d, void *args),
+                                 void (*destroy)(void *k, void *d, void *args),
+                                 void *args);
+
+
+/* Fill info with some hash table statistics */
+void hashtab_stat(struct hashtab *h, struct hashtab_info *info);
+
+#endif	/* _SS_HASHTAB_H */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/Makefile 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/Makefile
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/Makefile	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,21 @@
+#
+# Makefile for building the SELinux security server as part of the kernel tree.
+#
+
+EXTRA_CFLAGS += -I../include -I..
+
+O_TARGET := ss.o
+
+obj-y := ebitmap.o hashtab.o symtab.o sidtab.o avtab.o policydb.o services.o
+#obj-m := $(O_TARGET)
+
+ifeq ($(CONFIG_SECURITY_SELINUX_MLS),y)
+obj-y += mls.o
+endif
+
+all: $(O_TARGET) 
+
+clean:
+	rm -f $(O_TARGET) $(O_OBJS) 
+
+include $(TOPDIR)/Rules.make
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/mls.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/mls.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/mls.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/mls.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,754 @@
+/*
+ * Implementation of the multi-level security (MLS) policy.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include "mls.h"
+#include "policydb.h"
+#include "services.h"
+
+/*
+ * Remove any permissions from `allowed' that are
+ * denied by the MLS policy.
+ */
+void mls_compute_av(struct context *scontext,
+		    struct context *tcontext,
+		    struct class_datum *tclass,
+		    u32 *allowed)
+{
+	unsigned int rel[2];
+	int l;
+
+	for (l = 0; l < 2; l++)
+		rel[l] = mls_level_relation(scontext->range.level[l],
+					    tcontext->range.level[l]);
+
+	if (rel[1] != MLS_RELATION_EQ) {
+		if (rel[1] != MLS_RELATION_DOM &&
+		    !ebitmap_get_bit(&policydb.trustedreaders, scontext->type - 1) &&
+		    !ebitmap_get_bit(&policydb.trustedobjects, tcontext->type - 1)) {
+			/* read(s,t) = (s.high >= t.high) = False */
+			*allowed = (*allowed) & ~(tclass->mlsperms.read);
+		}
+		if (rel[1] != MLS_RELATION_DOMBY &&
+		    !ebitmap_get_bit(&policydb.trustedreaders, tcontext->type - 1) &&
+		    !ebitmap_get_bit(&policydb.trustedobjects, scontext->type - 1)) {
+			/* readby(s,t) = read(t,s) = False */
+			*allowed = (*allowed) & ~(tclass->mlsperms.readby);
+		}
+	}
+	if (((rel[0] != MLS_RELATION_DOMBY && rel[0] != MLS_RELATION_EQ) ||
+	    ((!mls_level_eq(tcontext->range.level[0],
+			    tcontext->range.level[1])) &&
+	     (rel[1] != MLS_RELATION_DOM && rel[1] != MLS_RELATION_EQ))) &&
+	    !ebitmap_get_bit(&policydb.trustedwriters, scontext->type - 1) &&
+	    !ebitmap_get_bit(&policydb.trustedobjects, tcontext->type - 1)) {
+		/*
+		 * write(s,t) = ((s.low <= t.low = t.high) or (s.low
+		 * <= t.low <= t.high <= s.high)) = False
+		 */
+		*allowed = (*allowed) & ~(tclass->mlsperms.write);
+	}
+
+	if (((rel[0] != MLS_RELATION_DOM && rel[0] != MLS_RELATION_EQ) ||
+	    ((!mls_level_eq(scontext->range.level[0],
+			    scontext->range.level[1])) &&
+	     (rel[1] != MLS_RELATION_DOMBY && rel[1] != MLS_RELATION_EQ))) &&
+	    !ebitmap_get_bit(&policydb.trustedwriters, tcontext->type - 1) &&
+	    !ebitmap_get_bit(&policydb.trustedobjects, scontext->type - 1)) {
+		/* writeby(s,t) = write(t,s) = False */
+		*allowed = (*allowed) & ~(tclass->mlsperms.writeby);
+	}
+}
+
+/*
+ * Return the length in bytes for the MLS fields of the
+ * security context string representation of `context'.
+ */
+int mls_compute_context_len(struct context * context)
+{
+	int i, l, len;
+
+
+	len = 0;
+	for (l = 0; l < 2; l++) {
+		len += strlen(policydb.p_sens_val_to_name[context->range.level[l].sens - 1]) + 1;
+
+		for (i = 1; i <= ebitmap_length(&context->range.level[l].cat); i++)
+			if (ebitmap_get_bit(&context->range.level[l].cat, i - 1))
+				len += strlen(policydb.p_cat_val_to_name[i - 1]) + 1;
+
+		if (mls_level_relation(context->range.level[0], context->range.level[1])
+				== MLS_RELATION_EQ)
+			break;
+	}
+
+	return len;
+}
+
+/*
+ * Write the security context string representation of
+ * the MLS fields of `context' into the string `*scontext'.
+ * Update `*scontext' to point to the end of the MLS fields.
+ */
+int mls_sid_to_context(struct context *context,
+		       char **scontext)
+{
+	char *scontextp;
+	int i, l;
+
+	scontextp = *scontext;
+
+	for (l = 0; l < 2; l++) {
+		strcpy(scontextp,
+		       policydb.p_sens_val_to_name[context->range.level[l].sens - 1]);
+		scontextp += strlen(policydb.p_sens_val_to_name[context->range.level[l].sens - 1]);
+		*scontextp = ':';
+		scontextp++;
+		for (i = 1; i <= ebitmap_length(&context->range.level[l].cat); i++)
+			if (ebitmap_get_bit(&context->range.level[l].cat, i - 1)) {
+				strcpy(scontextp, policydb.p_cat_val_to_name[i - 1]);
+				scontextp += strlen(policydb.p_cat_val_to_name[i - 1]);
+				*scontextp = ',';
+				scontextp++;
+			}
+		if (mls_level_relation(context->range.level[0], context->range.level[1])
+				!= MLS_RELATION_EQ) {
+			scontextp--;
+			sprintf(scontextp, "-");
+			scontextp++;
+
+		} else {
+			break;
+		}
+	}
+
+	*scontext = scontextp;
+	return 0;
+}
+
+/*
+ * Return 1 if the MLS fields in the security context
+ * structure `c' are valid.  Return 0 otherwise.
+ */
+int mls_context_isvalid(struct policydb *p, struct context *c)
+{
+	unsigned int relation;
+	struct level_datum *levdatum;
+	struct user_datum *usrdatum;
+	struct mls_range_list *rnode;
+	int i, l;
+
+	/*
+	 * MLS range validity checks: high must dominate low, low level must
+	 * be valid (category set <-> sensitivity check), and high level must
+	 * be valid (category set <-> sensitivity check)
+	 */
+	relation = mls_level_relation(c->range.level[1],
+				      c->range.level[0]);
+	if (!(relation & (MLS_RELATION_DOM | MLS_RELATION_EQ)))
+		/* High does not dominate low. */
+		return 0;
+
+	for (l = 0; l < 2; l++) {
+		if (!c->range.level[l].sens || c->range.level[l].sens > p->p_levels.nprim)
+			return 0;
+		levdatum = hashtab_search(p->p_levels.table,
+			p->p_sens_val_to_name[c->range.level[l].sens - 1]);
+		if (!levdatum)
+			return 0;
+
+		for (i = 1; i <= ebitmap_length(&c->range.level[l].cat); i++) {
+			if (ebitmap_get_bit(&c->range.level[l].cat, i - 1)) {
+				if (i > p->p_cats.nprim)
+					return 0;
+				if (!ebitmap_get_bit(&levdatum->level->cat, i - 1))
+					/*
+					 * Category may not be associated with
+					 * sensitivity in low level.
+					 */
+					return 0;
+			}
+		}
+	}
+
+	if (c->role == OBJECT_R_VAL)
+		return 1;
+
+	/*
+	 * User must be authorized for the MLS range.
+	 */
+	if (!c->user || c->user > p->p_users.nprim)
+		return 0;
+	usrdatum = p->user_val_to_struct[c->user - 1];
+	for (rnode = usrdatum->ranges; rnode; rnode = rnode->next) {
+		if (mls_range_contains(rnode->range, c->range))
+			break;
+	}
+	if (!rnode)
+		/* user may not be associated with range */
+		return 0;
+
+	return 1;
+}
+
+
+/*
+ * Set the MLS fields in the security context structure
+ * `context' based on the string representation in
+ * the string `*scontext'.  Update `*scontext' to
+ * point to the end of the string representation of
+ * the MLS fields.
+ *
+ * This function modifies the string in place, inserting
+ * NULL characters to terminate the MLS fields.
+ */
+int mls_context_to_sid(char oldc,
+		       char **scontext,
+		       struct context *context)
+{
+
+	char delim;
+	char *scontextp, *p;
+	struct level_datum *levdatum;
+	struct cat_datum *catdatum;
+	int l, rc = -EINVAL;
+
+	if (!oldc) {
+		/* No MLS component to the security context.  Try
+		   to use a default 'unclassified' value. */
+		levdatum = hashtab_search(policydb.p_levels.table,
+		                          "unclassified");
+		if (!levdatum)
+			goto out;
+		context->range.level[0].sens = levdatum->level->sens;
+		context->range.level[1].sens = context->range.level[0].sens;
+		rc = 0;
+		goto out;
+	}
+
+	/* Extract low sensitivity. */
+	scontextp = p = *scontext;
+	while (*p && *p != ':' && *p != '-')
+		p++;
+
+	delim = *p;
+	if (delim != 0)
+		*p++ = 0;
+
+	for (l = 0; l < 2; l++) {
+		levdatum = hashtab_search(policydb.p_levels.table, scontextp);
+		if (!levdatum)
+			goto out;
+
+		context->range.level[l].sens = levdatum->level->sens;
+
+		if (delim == ':') {
+			/* Extract low category set. */
+			while (1) {
+				scontextp = p;
+				while (*p && *p != ',' && *p != '-')
+					p++;
+				delim = *p;
+				if (delim != 0)
+					*p++ = 0;
+
+				catdatum = hashtab_search(policydb.p_cats.table,
+				                          scontextp);
+				if (!catdatum)
+					goto out;
+
+				rc = ebitmap_set_bit(&context->range.level[l].cat,
+				                     catdatum->value - 1, 1);
+				if (rc)
+					goto out;
+				if (delim != ',')
+					break;
+			}
+		}
+		if (delim == '-') {
+			/* Extract high sensitivity. */
+			scontextp = p;
+			while (*p && *p != ':')
+				p++;
+
+			delim = *p;
+			if (delim != 0)
+				*p++ = 0;
+		} else
+			break;
+	}
+
+	if (l == 0) {
+		context->range.level[1].sens = context->range.level[0].sens;
+		rc = ebitmap_cpy(&context->range.level[1].cat,
+				 &context->range.level[0].cat);
+		if (rc)
+			goto out;
+	}
+	*scontext = p;
+	rc = 0;
+out:
+	return rc;
+}
+
+/*
+ * Copies the MLS range from `src' into `dst'.
+ */
+static inline int mls_copy_context(struct context *dst,
+				   struct context *src)
+{
+	int l, rc = 0;
+
+	/* Copy the MLS range from the source context */
+	for (l = 0; l < 2; l++) {
+
+		dst->range.level[l].sens = src->range.level[l].sens;
+		rc = ebitmap_cpy(&dst->range.level[l].cat,
+				 &src->range.level[l].cat);
+		if (rc)
+			break;
+	}
+
+	return rc;
+}
+
+/*
+ * Convert the MLS fields in the security context
+ * structure `c' from the values specified in the
+ * policy `oldp' to the values specified in the policy `newp'.
+ */
+int mls_convert_context(struct policydb *oldp,
+			struct policydb *newp,
+			struct context *c)
+{
+	struct level_datum *levdatum;
+	struct cat_datum *catdatum;
+	struct ebitmap bitmap;
+	int l, i;
+
+	for (l = 0; l < 2; l++) {
+		levdatum = hashtab_search(newp->p_levels.table,
+			oldp->p_sens_val_to_name[c->range.level[l].sens - 1]);
+
+		if (!levdatum)
+			return -EINVAL;
+		c->range.level[l].sens = levdatum->level->sens;
+
+		ebitmap_init(&bitmap);
+		for (i = 1; i <= ebitmap_length(&c->range.level[l].cat); i++) {
+			if (ebitmap_get_bit(&c->range.level[l].cat, i - 1)) {
+				int rc;
+
+				catdatum = hashtab_search(newp->p_cats.table,
+				         	oldp->p_cat_val_to_name[i - 1]);
+				if (!catdatum)
+					return -EINVAL;
+				rc = ebitmap_set_bit(&bitmap, catdatum->value - 1, 1);
+				if (rc)
+					return rc;
+			}
+		}
+		ebitmap_destroy(&c->range.level[l].cat);
+		c->range.level[l].cat = bitmap;
+	}
+
+	return 0;
+}
+
+int mls_compute_sid(struct context *scontext,
+		    struct context *tcontext,
+		    u16 tclass,
+		    u32 specified,
+		    struct context *newcontext)
+{
+	switch (specified) {
+	case AVTAB_TRANSITION:
+	case AVTAB_CHANGE:
+		/* Use the process MLS attributes. */
+		return mls_copy_context(newcontext, scontext);
+	case AVTAB_MEMBER:
+		/* Only polyinstantiate the MLS attributes if
+		   the type is being polyinstantiated */
+		if (newcontext->type != tcontext->type) {
+			/* Use the process MLS attributes. */
+			return mls_copy_context(newcontext, scontext);
+		} else {
+			/* Use the related object MLS attributes. */
+			return mls_copy_context(newcontext, tcontext);
+		}
+	default:
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+void mls_user_destroy(struct user_datum *usrdatum)
+{
+	struct mls_range_list *rnode, *rtmp;
+	rnode = usrdatum->ranges;
+	while (rnode) {
+		rtmp = rnode;
+		rnode = rnode->next;
+		ebitmap_destroy(&rtmp->range.level[0].cat);
+		ebitmap_destroy(&rtmp->range.level[1].cat);
+		kfree(rtmp);
+	}
+}
+
+int mls_read_perm(struct perm_datum *perdatum, void *fp)
+{
+	u32 *buf;
+
+	buf = next_entry(fp, sizeof(u32));
+	if (!buf)
+		return -EINVAL;
+	perdatum->base_perms = le32_to_cpu(buf[0]);
+	return 0;
+}
+
+/*
+ * Read a MLS level structure from a policydb binary
+ * representation file.
+ */
+struct mls_level *mls_read_level(void *fp)
+{
+	struct mls_level *l;
+	u32 *buf;
+
+	l = kmalloc(sizeof(*l), GFP_ATOMIC);
+	if (!l) {
+		printk(KERN_ERR "security: mls: out of memory\n");
+		return NULL;
+	}
+	memset(l, 0, sizeof(*l));
+
+	buf = next_entry(fp, sizeof(u32));
+	if (!buf) {
+		printk(KERN_ERR "security: mls: truncated level\n");
+		goto bad;
+	}
+	l->sens = cpu_to_le32(buf[0]);
+
+	if (ebitmap_read(&l->cat, fp)) {
+		printk(KERN_ERR "security: mls:  error reading level "
+		       "categories\n");
+		goto bad;
+	}
+	return l;
+
+bad:
+	kfree(l);
+	return NULL;
+}
+
+
+/*
+ * Read a MLS range structure from a policydb binary
+ * representation file.
+ */
+static int mls_read_range_helper(struct mls_range *r, void *fp)
+{
+	u32 *buf;
+	int items, rc = -EINVAL;
+
+	buf = next_entry(fp, sizeof(u32));
+	if (!buf)
+		goto out;
+
+	items = le32_to_cpu(buf[0]);
+	buf = next_entry(fp, sizeof(u32) * items);
+	if (!buf) {
+		printk(KERN_ERR "security: mls:  truncated range\n");
+		goto out;
+	}
+	r->level[0].sens = le32_to_cpu(buf[0]);
+	if (items > 1) {
+		r->level[1].sens = le32_to_cpu(buf[1]);
+	} else {
+		r->level[1].sens = r->level[0].sens;
+	}
+
+	rc = ebitmap_read(&r->level[0].cat, fp);
+	if (rc) {
+		printk(KERN_ERR "security: mls:  error reading low "
+		       "categories\n");
+		goto out;
+	}
+	if (items > 1) {
+		rc = ebitmap_read(&r->level[1].cat, fp);
+		if (rc) {
+			printk(KERN_ERR "security: mls:  error reading high "
+			       "categories\n");
+			goto bad_high;
+		}
+	} else {
+		rc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);
+		if (rc) {
+			printk(KERN_ERR "security: mls:  out of memory\n");
+			goto bad_high;
+		}
+	}
+
+	rc = 0;
+out:
+	return rc;
+bad_high:
+	ebitmap_destroy(&r->level[0].cat);
+	goto out;
+}
+
+int mls_read_range(struct context *c, void *fp)
+{
+	return mls_read_range_helper(&c->range, fp);
+}
+
+
+/*
+ * Read a MLS perms structure from a policydb binary
+ * representation file.
+ */
+int mls_read_class(struct class_datum *cladatum, void *fp)
+{
+	struct mls_perms *p = &cladatum->mlsperms;
+	u32 *buf;
+
+	buf = next_entry(fp, sizeof(u32)*4);
+	if (!buf) {
+		printk(KERN_ERR "security: mls:  truncated mls permissions\n");
+		return -EINVAL;
+	}
+	p->read = le32_to_cpu(buf[0]);
+	p->readby = le32_to_cpu(buf[1]);
+	p->write = le32_to_cpu(buf[2]);
+	p->writeby = le32_to_cpu(buf[3]);
+	return 0;
+}
+
+int mls_read_user(struct user_datum *usrdatum, void *fp)
+{
+	struct mls_range_list *r, *l;
+	int rc = 0;
+	u32 nel, i;
+	u32 *buf;
+
+	buf = next_entry(fp, sizeof(u32));
+	if (!buf) {
+		rc = -EINVAL;
+		goto out;
+	}
+	nel = le32_to_cpu(buf[0]);
+	l = NULL;
+	for (i = 0; i < nel; i++) {
+		r = kmalloc(sizeof(*r), GFP_ATOMIC);
+		if (!r) {
+			rc = -ENOMEM;
+			goto out;
+		}
+		memset(r, 0, sizeof(*r));
+
+		rc = mls_read_range_helper(&r->range, fp);
+		if (rc) {
+			kfree(r);
+			goto out;
+		}
+
+		if (l)
+			l->next = r;
+		else
+			usrdatum->ranges = r;
+		l = r;
+	}
+out:
+	return rc;
+}
+
+int mls_read_nlevels(struct policydb *p, void *fp)
+{
+	u32 *buf;
+
+	buf = next_entry(fp, sizeof(u32));
+	if (!buf)
+		return -EINVAL;
+	p->nlevels = le32_to_cpu(buf[0]);
+	return 0;
+}
+
+int mls_read_trusted(struct policydb *p, void *fp)
+{
+	int rc = 0;
+
+	rc = ebitmap_read(&p->trustedreaders, fp);
+	if (rc)
+		goto out;
+	rc = ebitmap_read(&p->trustedwriters, fp);
+	if (rc)
+		goto bad;
+	rc = ebitmap_read(&p->trustedobjects, fp);
+	if (rc)
+		goto bad2;
+out:
+	return rc;
+bad2:
+	ebitmap_destroy(&p->trustedwriters);
+bad:
+	ebitmap_destroy(&p->trustedreaders);
+	goto out;
+}
+
+int sens_index(void *key, void *datum, void *datap)
+{
+	struct policydb *p;
+	struct level_datum *levdatum;
+
+
+	levdatum = datum;
+	p = datap;
+
+	if (!levdatum->isalias)
+		p->p_sens_val_to_name[levdatum->level->sens - 1] = key;
+
+	return 0;
+}
+
+int cat_index(void *key, void *datum, void *datap)
+{
+	struct policydb *p;
+	struct cat_datum *catdatum;
+
+
+	catdatum = datum;
+	p = datap;
+
+
+	if (!catdatum->isalias)
+		p->p_cat_val_to_name[catdatum->value - 1] = key;
+
+	return 0;
+}
+
+int sens_destroy(void *key, void *datum, void *p)
+{
+	struct level_datum *levdatum;
+
+	kfree(key);
+	levdatum = datum;
+	if (!levdatum->isalias) {
+		ebitmap_destroy(&levdatum->level->cat);
+		kfree(levdatum->level);
+	}
+	kfree(datum);
+	return 0;
+}
+
+int cat_destroy(void *key, void *datum, void *p)
+{
+	kfree(key);
+	kfree(datum);
+	return 0;
+}
+
+int sens_read(struct policydb *p, struct hashtab *h, void *fp)
+{
+	char *key = 0;
+	struct level_datum *levdatum;
+	int rc;
+	u32 *buf, len;
+
+	levdatum = kmalloc(sizeof(*levdatum), GFP_ATOMIC);
+	if (!levdatum) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	memset(levdatum, 0, sizeof(*levdatum));
+
+	buf = next_entry(fp, sizeof(u32)*2);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+
+	len = le32_to_cpu(buf[0]);
+	levdatum->isalias = le32_to_cpu(buf[1]);
+
+	buf = next_entry(fp, len);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	key = kmalloc(len + 1,GFP_ATOMIC);
+	if (!key) {
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memcpy(key, buf, len);
+	key[len] = 0;
+
+	levdatum->level = mls_read_level(fp);
+	if (!levdatum->level) {
+		rc = -EINVAL;
+		goto bad;
+	}
+
+	rc = hashtab_insert(h, key, levdatum);
+	if (rc)
+		goto bad;
+out:
+	return rc;
+bad:
+	sens_destroy(key, levdatum, NULL);
+	goto out;
+}
+
+
+int cat_read(struct policydb *p, struct hashtab *h, void *fp)
+{
+	char *key = 0;
+	struct cat_datum *catdatum;
+	int rc;
+	u32 *buf, len;
+
+	catdatum = kmalloc(sizeof(*catdatum), GFP_ATOMIC);
+	if (!catdatum) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	memset(catdatum, 0, sizeof(*catdatum));
+
+	buf = next_entry(fp, sizeof(u32)*3);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+
+	len = le32_to_cpu(buf[0]);
+	catdatum->value = le32_to_cpu(buf[1]);
+	catdatum->isalias = le32_to_cpu(buf[2]);
+
+	buf = next_entry(fp, len);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	key = kmalloc(len + 1,GFP_ATOMIC);
+	if (!key) {
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memcpy(key, buf, len);
+	key[len] = 0;
+
+	rc = hashtab_insert(h, key, catdatum);
+	if (rc)
+		goto bad;
+out:
+	return rc;
+
+bad:
+	cat_destroy(key, catdatum, NULL);
+	goto out;
+}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/mls.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/mls.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/mls.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/mls.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,99 @@
+/*
+ * Multi-level security (MLS) policy operations.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_MLS_H_
+#define _SS_MLS_H_
+
+#include "context.h"
+#include "policydb.h"
+
+#ifdef CONFIG_SECURITY_SELINUX_MLS
+
+void mls_compute_av(struct context *scontext,
+		    struct context *tcontext,
+		    struct class_datum *tclass,
+		    u32 *allowed);
+
+int mls_compute_context_len(struct context *context);
+int mls_sid_to_context(struct context *context, char **scontext);
+int mls_context_isvalid(struct policydb *p, struct context *c);
+
+int mls_context_to_sid(char oldc,
+	               char **scontext,
+		       struct context *context);
+
+int mls_convert_context(struct policydb *oldp,
+			struct policydb *newp,
+			struct context *context);
+
+int mls_compute_sid(struct context *scontext,
+		    struct context *tcontext,
+		    u16 tclass,
+		    u32 specified,
+		    struct context *newcontext);
+
+int sens_index(void *key, void *datum, void *datap);
+int cat_index(void *key, void *datum, void *datap);
+int sens_destroy(void *key, void *datum, void *p);
+int cat_destroy(void *key, void *datum, void *p);
+int sens_read(struct policydb *p, struct hashtab *h, void *fp);
+int cat_read(struct policydb *p, struct hashtab *h, void *fp);
+
+#define mls_for_user_ranges(user, usercon) { \
+struct mls_range_list *__ranges; \
+for (__ranges = user->ranges; __ranges; __ranges = __ranges->next) { \
+usercon.range = __ranges->range;
+
+#define mls_end_user_ranges } }
+
+#define mls_symtab_names , "levels", "categories"
+#define mls_symtab_sizes , 16, 16
+#define mls_index_f ,sens_index, cat_index
+#define mls_destroy_f ,sens_destroy, cat_destroy
+#define mls_read_f ,sens_read, cat_read
+#define mls_write_f ,sens_write, cat_write
+#define mls_policydb_index_others(p) printk(", %d levels", p->nlevels);
+
+#define mls_set_config(config) config |= POLICYDB_CONFIG_MLS
+
+void mls_user_destroy(struct user_datum *usrdatum);
+int mls_read_range(struct context *c, void *fp);
+int mls_read_perm(struct perm_datum *perdatum, void *fp);
+int mls_read_class(struct class_datum *cladatum,  void *fp);
+int mls_read_user(struct user_datum *usrdatum, void *fp);
+int mls_read_nlevels(struct policydb *p, void *fp);
+int mls_read_trusted(struct policydb *p, void *fp);
+
+#else
+
+#define	mls_compute_av(scontext, tcontext, tclass_datum, allowed)
+#define mls_compute_context_len(context) 0
+#define	mls_sid_to_context(context, scontextpp)
+#define mls_context_isvalid(p, c) 1
+#define	mls_context_to_sid(oldc, context_str, context) 0
+#define mls_convert_context(oldp, newp, c) 0
+#define mls_compute_sid(scontext, tcontext, tclass, specified, newcontextp) 0
+#define mls_for_user_ranges(user, usercon)
+#define mls_end_user_ranges
+#define mls_symtab_names
+#define mls_symtab_sizes
+#define mls_index_f
+#define mls_destroy_f
+#define mls_read_f
+#define mls_write_f
+#define mls_policydb_index_others(p)
+#define mls_set_config(config)
+#define mls_user_destroy(usrdatum)
+#define mls_read_range(c, fp) 0
+#define mls_read_perm(p, fp) 0
+#define mls_read_class(c, fp) 0
+#define mls_read_user(u, fp) 0
+#define mls_read_nlevels(p, fp) 0
+#define mls_read_trusted(p, fp) 0
+
+#endif
+
+#endif	/* _SS_MLS_H */
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/mls_types.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/mls_types.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/mls_types.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/mls_types.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ * Type definitions for the multi-level security (MLS) policy.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_MLS_TYPES_H_
+#define _SS_MLS_TYPES_H_
+
+struct mls_level {
+	u32 sens;		/* sensitivity */
+	struct ebitmap cat;	/* category set */
+};
+
+struct mls_range {
+	struct mls_level level[2]; /* low == level[0], high == level[1] */
+};
+
+struct mls_range_list {
+	struct mls_range range;
+	struct mls_range_list *next;
+};
+
+#define MLS_RELATION_DOM	1 /* source dominates */
+#define MLS_RELATION_DOMBY	2 /* target dominates */
+#define MLS_RELATION_EQ		4 /* source and target are equivalent */
+#define MLS_RELATION_INCOMP	8 /* source and target are incomparable */
+
+#define mls_level_eq(l1,l2) \
+(((l1).sens == (l2).sens) && ebitmap_cmp(&(l1).cat,&(l2).cat))
+
+#define mls_level_relation(l1,l2) ( \
+(((l1).sens == (l2).sens) && ebitmap_cmp(&(l1).cat,&(l2).cat)) ? \
+				    MLS_RELATION_EQ : \
+(((l1).sens >= (l2).sens) && ebitmap_contains(&(l1).cat, &(l2).cat)) ? \
+				    MLS_RELATION_DOM : \
+(((l2).sens >= (l1).sens) && ebitmap_contains(&(l2).cat, &(l1).cat)) ? \
+				    MLS_RELATION_DOMBY : \
+				    MLS_RELATION_INCOMP )
+
+#define mls_range_contains(r1,r2) \
+((mls_level_relation((r1).level[0], (r2).level[0]) & \
+	  (MLS_RELATION_EQ | MLS_RELATION_DOMBY)) && \
+	 (mls_level_relation((r1).level[1], (r2).level[1]) & \
+	  (MLS_RELATION_EQ | MLS_RELATION_DOM)))
+
+/*
+ * Every access vector permission is mapped to a set of MLS base
+ * permissions, based on the flow properties of the corresponding
+ * operation.
+ */
+struct mls_perms {
+	u32 read;     /* permissions that map to `read' */
+	u32 readby;   /* permissions that map to `readby' */
+	u32 write;    /* permissions that map to `write' */
+	u32 writeby;  /* permissions that map to `writeby' */
+};
+
+#endif	/* _SS_MLS_TYPES_H_ */
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/policydb.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/policydb.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/policydb.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/policydb.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,1438 @@
+/*
+ * Implementation of the policy database.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include "security.h"
+#include "policydb.h"
+#include "mls.h"
+
+#define _DEBUG_HASHES
+
+#ifdef DEBUG_HASHES
+static char *symtab_name[SYM_NUM] = {
+	"common prefixes",
+	"classes",
+	"roles",
+	"types",
+	"users"
+	mls_symtab_names
+};
+#endif
+
+static unsigned int symtab_sizes[SYM_NUM] = {
+	2,
+	32,
+	16,
+	512,
+	128
+	mls_symtab_sizes
+};
+
+/*
+ * Initialize the role table.
+ */
+int roles_init(struct policydb *p)
+{
+	char *key = 0;
+	int rc;
+	struct role_datum *role;
+
+	role = kmalloc(sizeof(*role), GFP_KERNEL);
+	if (!role) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	memset(role, 0, sizeof(*role));
+	role->value = ++p->p_roles.nprim;
+	if (role->value != OBJECT_R_VAL) {
+		rc = -EINVAL;
+		goto out_free_role;
+	}
+	key = kmalloc(strlen(OBJECT_R)+1,GFP_KERNEL);
+	if (!key) {
+		rc = -ENOMEM;
+		goto out_free_role;
+	}
+	strcpy(key, OBJECT_R);
+	rc = hashtab_insert(p->p_roles.table, key, role);
+	if (rc)
+		goto out_free_key;
+out:
+	return rc;
+
+out_free_key:
+	kfree(key);
+out_free_role:
+	kfree(role);
+	goto out;
+}
+
+/*
+ * Initialize a policy database structure.
+ */
+int policydb_init(struct policydb *p)
+{
+	int i, rc;
+
+	memset(p, 0, sizeof(*p));
+
+	for (i = 0; i < SYM_NUM; i++) {
+		rc = symtab_init(&p->symtab[i], symtab_sizes[i]);
+		if (rc)
+			goto out_free_symtab;
+	}
+
+	rc = avtab_init(&p->te_avtab);
+	if (rc)
+		goto out_free_symtab;
+
+	rc = roles_init(p);
+	if (rc)
+		goto out_free_avtab;
+
+out:
+	return rc;
+
+out_free_avtab:
+	avtab_destroy(&p->te_avtab);
+
+out_free_symtab:
+	for (i = 0; i < SYM_NUM; i++)
+		hashtab_destroy(p->symtab[i].table);
+	goto out;
+}
+
+/*
+ * The following *_index functions are used to
+ * define the val_to_name and val_to_struct arrays
+ * in a policy database structure.  The val_to_name
+ * arrays are used when converting security context
+ * structures into string representations.  The
+ * val_to_struct arrays are used when the attributes
+ * of a class, role, or user are needed.
+ */
+
+static int common_index(void *key, void *datum, void *datap)
+{
+	struct policydb *p;
+	struct common_datum *comdatum;
+
+	comdatum = datum;
+	p = datap;
+	p->p_common_val_to_name[comdatum->value - 1] = key;
+	return 0;
+}
+
+static int class_index(void *key, void *datum, void *datap)
+{
+	struct policydb *p;
+	struct class_datum *cladatum;
+
+	cladatum = datum;
+	p = datap;
+	p->p_class_val_to_name[cladatum->value - 1] = key;
+	p->class_val_to_struct[cladatum->value - 1] = cladatum;
+	return 0;
+}
+
+static int role_index(void *key, void *datum, void *datap)
+{
+	struct policydb *p;
+	struct role_datum *role;
+
+	role = datum;
+	p = datap;
+	p->p_role_val_to_name[role->value - 1] = key;
+	p->role_val_to_struct[role->value - 1] = role;
+	return 0;
+}
+
+static int type_index(void *key, void *datum, void *datap)
+{
+	struct policydb *p;
+	struct type_datum *typdatum;
+
+	typdatum = datum;
+	p = datap;
+
+	if (typdatum->primary)
+		p->p_type_val_to_name[typdatum->value - 1] = key;
+
+	return 0;
+}
+
+static int user_index(void *key, void *datum, void *datap)
+{
+	struct policydb *p;
+	struct user_datum *usrdatum;
+
+	usrdatum = datum;
+	p = datap;
+	p->p_user_val_to_name[usrdatum->value - 1] = key;
+	p->user_val_to_struct[usrdatum->value - 1] = usrdatum;
+	return 0;
+}
+
+static int (*index_f[SYM_NUM]) (void *key, void *datum, void *datap) =
+{
+	common_index,
+	class_index,
+	role_index,
+	type_index,
+	user_index
+	mls_index_f
+};
+
+/*
+ * Define the common val_to_name array and the class
+ * val_to_name and val_to_struct arrays in a policy
+ * database structure.
+ *
+ * Caller must clean up upon failure.
+ */
+int policydb_index_classes(struct policydb *p)
+{
+	int rc;
+
+	p->p_common_val_to_name =
+		kmalloc(p->p_commons.nprim * sizeof(char *), GFP_KERNEL);
+	if (!p->p_common_val_to_name) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	rc = hashtab_map(p->p_commons.table, common_index, p);
+	if (rc)
+		goto out;
+
+	p->class_val_to_struct =
+		kmalloc(p->p_classes.nprim * sizeof(*(p->class_val_to_struct)), GFP_KERNEL);
+	if (!p->class_val_to_struct) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	p->p_class_val_to_name =
+		kmalloc(p->p_classes.nprim * sizeof(char *), GFP_KERNEL);
+	if (!p->p_class_val_to_name) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	rc = hashtab_map(p->p_classes.table, class_index, p);
+out:
+	return rc;
+}
+
+#ifdef DEBUG_HASHES
+static void symtab_hash_eval(struct symtab *s)
+{
+	int i;
+
+	for (i = 0; i < SYM_NUM; i++) {
+		struct hashtab *h = s[i].table;
+		struct hashtab_info info;
+
+		hashtab_stat(h, &info);
+		printk(KERN_INFO "%s:  %d entries and %d/%d buckets used, "
+		       "longest chain length %d\n", symtab_name[i], h->nel,
+		       info.slots_used, h->size, info.max_chain_len);
+	}
+}
+#endif
+
+/*
+ * Define the other val_to_name and val_to_struct arrays
+ * in a policy database structure.
+ *
+ * Caller must clean up on failure.
+ */
+int policydb_index_others(struct policydb *p)
+{
+	int i, rc = 0;
+
+	printk(KERN_INFO "security:  %d users, %d roles, %d types",
+	       p->p_users.nprim, p->p_roles.nprim, p->p_types.nprim);
+	mls_policydb_index_others(p);
+	printk("\n");
+
+	printk(KERN_INFO "security:  %d classes, %d rules\n",
+	       p->p_classes.nprim, p->te_avtab.nel);
+
+#ifdef DEBUG_HASHES
+	avtab_hash_eval(&p->te_avtab, "rules");
+	symtab_hash_eval(p->symtab);
+#endif
+
+	p->role_val_to_struct =
+		kmalloc(p->p_roles.nprim * sizeof(*(p->role_val_to_struct)),
+		        GFP_KERNEL);
+	if (!p->role_val_to_struct) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	p->user_val_to_struct =
+		kmalloc(p->p_users.nprim * sizeof(*(p->user_val_to_struct)),
+		        GFP_KERNEL);
+	if (!p->user_val_to_struct) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	for (i = SYM_ROLES; i < SYM_NUM; i++) {
+		p->sym_val_to_name[i] =
+			kmalloc(p->symtab[i].nprim * sizeof(char *), GFP_KERNEL);
+		if (!p->sym_val_to_name[i]) {
+			rc = -ENOMEM;
+			goto out;
+		}
+		rc = hashtab_map(p->symtab[i].table, index_f[i], p);
+		if (rc)
+			goto out;
+	}
+
+out:
+	return rc;
+}
+
+/*
+ * The following *_destroy functions are used to
+ * free any memory allocated for each kind of
+ * symbol data in the policy database.
+ */
+
+static int perm_destroy(void *key, void *datum, void *p)
+{
+	kfree(key);
+	kfree(datum);
+	return 0;
+}
+
+static int common_destroy(void *key, void *datum, void *p)
+{
+	struct common_datum *comdatum;
+
+	kfree(key);
+	comdatum = datum;
+	hashtab_map(comdatum->permissions.table, perm_destroy, 0);
+	hashtab_destroy(comdatum->permissions.table);
+	kfree(datum);
+	return 0;
+}
+
+static int class_destroy(void *key, void *datum, void *p)
+{
+	struct class_datum *cladatum;
+	struct constraint_node *constraint, *ctemp;
+	struct constraint_expr *e, *etmp;
+
+	kfree(key);
+	cladatum = datum;
+	hashtab_map(cladatum->permissions.table, perm_destroy, 0);
+	hashtab_destroy(cladatum->permissions.table);
+	constraint = cladatum->constraints;
+	while (constraint) {
+		e = constraint->expr;
+		while (e) {
+			ebitmap_destroy(&e->names);
+			etmp = e;
+			e = e->next;
+			kfree(etmp);
+		}
+		ctemp = constraint;
+		constraint = constraint->next;
+		kfree(ctemp);
+	}
+	kfree(cladatum->comkey);
+	kfree(datum);
+	return 0;
+}
+
+static int role_destroy(void *key, void *datum, void *p)
+{
+	struct role_datum *role;
+
+	kfree(key);
+	role = datum;
+	ebitmap_destroy(&role->dominates);
+	ebitmap_destroy(&role->types);
+	kfree(datum);
+	return 0;
+}
+
+static int type_destroy(void *key, void *datum, void *p)
+{
+	kfree(key);
+	kfree(datum);
+	return 0;
+}
+
+static int user_destroy(void *key, void *datum, void *p)
+{
+	struct user_datum *usrdatum;
+
+	kfree(key);
+	usrdatum = datum;
+	ebitmap_destroy(&usrdatum->roles);
+	mls_user_destroy(usrdatum);
+	kfree(datum);
+	return 0;
+}
+
+static int (*destroy_f[SYM_NUM]) (void *key, void *datum, void *datap) =
+{
+	common_destroy,
+	class_destroy,
+	role_destroy,
+	type_destroy,
+	user_destroy
+	mls_destroy_f
+};
+
+void ocontext_destroy(struct ocontext *c, int i)
+{
+	context_destroy(&c->context[0]);
+	context_destroy(&c->context[1]);
+	if (i == OCON_ISID || i == OCON_FS ||
+	    i == OCON_NETIF || i == OCON_FSUSE)
+		kfree(c->u.name);
+	kfree(c);
+}
+
+/*
+ * Free any memory allocated by a policy database structure.
+ */
+void policydb_destroy(struct policydb *p)
+{
+	struct ocontext *c, *ctmp;
+	struct genfs *g, *gtmp;
+	int i;
+
+	for (i = 0; i < SYM_NUM; i++) {
+		hashtab_map(p->symtab[i].table, destroy_f[i], 0);
+		hashtab_destroy(p->symtab[i].table);
+	}
+
+	for (i = 0; i < SYM_NUM; i++) {
+		if (p->sym_val_to_name[i])
+			kfree(p->sym_val_to_name[i]);
+	}
+
+	if (p->class_val_to_struct)
+		kfree(p->class_val_to_struct);
+	if (p->role_val_to_struct)
+		kfree(p->role_val_to_struct);
+	if (p->user_val_to_struct)
+		kfree(p->user_val_to_struct);
+
+	avtab_destroy(&p->te_avtab);
+
+	for (i = 0; i < OCON_NUM; i++) {
+		c = p->ocontexts[i];
+		while (c) {
+			ctmp = c;
+			c = c->next;
+			ocontext_destroy(ctmp,i);
+		}
+	}
+
+	g = p->genfs;
+	while (g) {
+		kfree(g->fstype);
+		c = g->head;
+		while (c) {
+			ctmp = c;
+			c = c->next;
+			ocontext_destroy(ctmp,OCON_FSUSE);
+		}
+		gtmp = g;
+		g = g->next;
+		kfree(gtmp);
+	}
+
+	return;
+}
+
+/*
+ * Load the initial SIDs specified in a policy database
+ * structure into a SID table.
+ */
+int policydb_load_isids(struct policydb *p, struct sidtab *s)
+{
+	struct ocontext *head, *c;
+	int rc;
+
+	rc = sidtab_init(s);
+	if (rc) {
+		printk(KERN_ERR "security:  out of memory on SID table init\n");
+		goto out;
+	}
+
+	head = p->ocontexts[OCON_ISID];
+	for (c = head; c; c = c->next) {
+		if (!c->context[0].user) {
+			printk(KERN_ERR "security:  SID %s was never "
+			       "defined.\n", c->u.name);
+			rc = -EINVAL;
+			goto out;
+		}
+		if (sidtab_insert(s, c->sid[0], &c->context[0])) {
+			printk(KERN_ERR "security:  unable to load initial "
+			       "SID %s.\n", c->u.name);
+			rc = -EINVAL;
+			goto out;
+		}
+	}
+out:
+	return rc;
+}
+
+/*
+ * Return 1 if the fields in the security context
+ * structure `c' are valid.  Return 0 otherwise.
+ */
+int policydb_context_isvalid(struct policydb *p, struct context *c)
+{
+	struct role_datum *role;
+	struct user_datum *usrdatum;
+
+	/*
+	 * Role must be authorized for the type.
+	 */
+	if (!c->role || c->role > p->p_roles.nprim)
+		return 0;
+
+	if (c->role != OBJECT_R_VAL) {
+		role = p->role_val_to_struct[c->role - 1];
+		if (!ebitmap_get_bit(&role->types,
+				     c->type - 1))
+			/* role may not be associated with type */
+			return 0;
+
+		/*
+		 * User must be authorized for the role.
+		 */
+		if (!c->user || c->user > p->p_users.nprim)
+			return 0;
+		usrdatum = p->user_val_to_struct[c->user - 1];
+		if (!usrdatum)
+			return 0;
+
+		if (!ebitmap_get_bit(&usrdatum->roles,
+				     c->role - 1))
+			/* user may not be associated with role */
+			return 0;
+	}
+
+	if (!mls_context_isvalid(p, c))
+		return 0;
+
+	return 1;
+}
+
+/*
+ * Read and validate a security context structure
+ * from a policydb binary representation file.
+ */
+static int context_read_and_validate(struct context *c,
+				     struct policydb *p,
+				     void *fp)
+{
+	u32 *buf;
+	int rc = 0;
+
+	buf = next_entry(fp, sizeof(u32)*3);
+	if (!buf) {
+		printk(KERN_ERR "security: context truncated\n");
+		rc = -EINVAL;
+		goto out;
+	}
+	c->user = le32_to_cpu(buf[0]);
+	c->role = le32_to_cpu(buf[1]);
+	c->type = le32_to_cpu(buf[2]);
+	if (mls_read_range(c, fp)) {
+		printk(KERN_ERR "security: error reading MLS range of "
+		       "context\n");
+		rc = -EINVAL;
+		goto out;
+	}
+
+	if (!policydb_context_isvalid(p, c)) {
+		printk(KERN_ERR "security:  invalid security context\n");
+		context_destroy(c);
+		rc = -EINVAL;
+	}
+out:
+	return rc;
+}
+
+/*
+ * The following *_read functions are used to
+ * read the symbol data from a policy database
+ * binary representation file.
+ */
+
+static int perm_read(struct policydb *p, struct hashtab *h, void *fp)
+{
+	char *key = 0;
+	struct perm_datum *perdatum;
+	int rc;
+	u32 *buf, len;
+
+	perdatum = kmalloc(sizeof(*perdatum), GFP_KERNEL);
+	if (!perdatum) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	memset(perdatum, 0, sizeof(*perdatum));
+
+	buf = next_entry(fp, sizeof(u32)*2);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+
+	len = le32_to_cpu(buf[0]);
+	perdatum->value = le32_to_cpu(buf[1]);
+	rc = mls_read_perm(perdatum, fp);
+	if (rc)
+		goto bad;
+
+	buf = next_entry(fp, len);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	key = kmalloc(len + 1,GFP_KERNEL);
+	if (!key) {
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memcpy(key, buf, len);
+	key[len] = 0;
+
+	rc = hashtab_insert(h, key, perdatum);
+	if (rc)
+		goto bad;
+out:
+	return rc;
+bad:
+	perm_destroy(key, perdatum, NULL);
+	goto out;
+}
+
+static int common_read(struct policydb *p, struct hashtab *h, void *fp)
+{
+	char *key = 0;
+	struct common_datum *comdatum;
+	u32 *buf, len, nel;
+	int i, rc;
+
+	comdatum = kmalloc(sizeof(*comdatum), GFP_KERNEL);
+	if (!comdatum) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	memset(comdatum, 0, sizeof(*comdatum));
+
+	buf = next_entry(fp, sizeof(u32)*4);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+
+	len = le32_to_cpu(buf[0]);
+	comdatum->value = le32_to_cpu(buf[1]);
+
+	rc = symtab_init(&comdatum->permissions, PERM_SYMTAB_SIZE);
+	if (rc)
+		goto bad;
+	comdatum->permissions.nprim = le32_to_cpu(buf[2]);
+	nel = le32_to_cpu(buf[3]);
+
+	buf = next_entry(fp, len);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	key = kmalloc(len + 1,GFP_KERNEL);
+	if (!key) {
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memcpy(key, buf, len);
+	key[len] = 0;
+
+	for (i = 0; i < nel; i++) {
+		rc = perm_read(p, comdatum->permissions.table, fp);
+		if (rc)
+			goto bad;
+	}
+
+	rc = hashtab_insert(h, key, comdatum);
+	if (rc)
+		goto bad;
+out:
+	return rc;
+bad:
+	common_destroy(key, comdatum, NULL);
+	goto out;
+}
+
+static int class_read(struct policydb *p, struct hashtab *h, void *fp)
+{
+	char *key = 0;
+	struct class_datum *cladatum;
+	struct constraint_node *c, *lc;
+	struct constraint_expr *e, *le;
+	u32 *buf, len, len2, ncons, nexpr, nel;
+	int i, j, depth, rc;
+
+	cladatum = kmalloc(sizeof(*cladatum), GFP_KERNEL);
+	if (!cladatum) {
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memset(cladatum, 0, sizeof(*cladatum));
+
+	buf = next_entry(fp, sizeof(u32)*6);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+
+	len = le32_to_cpu(buf[0]);
+	len2 = le32_to_cpu(buf[1]);
+	cladatum->value = le32_to_cpu(buf[2]);
+
+	rc = symtab_init(&cladatum->permissions, PERM_SYMTAB_SIZE);
+	if (rc)
+		goto bad;
+	cladatum->permissions.nprim = le32_to_cpu(buf[3]);
+	nel = le32_to_cpu(buf[4]);
+
+	ncons = le32_to_cpu(buf[5]);
+
+	buf = next_entry(fp, len);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	key = kmalloc(len + 1,GFP_KERNEL);
+	if (!key) {
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memcpy(key, buf, len);
+	key[len] = 0;
+
+	if (len2) {
+		cladatum->comkey = kmalloc(len2 + 1,GFP_KERNEL);
+		if (!cladatum->comkey) {
+			rc = -ENOMEM;
+			goto bad;
+		}
+		buf = next_entry(fp, len2);
+		if (!buf) {
+			rc = -EINVAL;
+			goto bad;
+		}
+		memcpy(cladatum->comkey, buf, len2);
+		cladatum->comkey[len2] = 0;
+
+		cladatum->comdatum = hashtab_search(p->p_commons.table,
+						    cladatum->comkey);
+		if (!cladatum->comdatum) {
+			printk(KERN_ERR "security:  unknown common %s\n",
+			       cladatum->comkey);
+			rc = -EINVAL;
+			goto bad;
+		}
+	}
+	for (i = 0; i < nel; i++) {
+		rc = perm_read(p, cladatum->permissions.table, fp);
+		if (rc)
+			goto bad;
+	}
+
+	lc = NULL;
+	rc = -EINVAL;
+	for (i = 0; i < ncons; i++) {
+		c = kmalloc(sizeof(*c), GFP_KERNEL);
+		if (!c) {
+			rc = -ENOMEM;
+			goto bad;
+		}
+		memset(c, 0, sizeof(*c));
+
+		if (lc) {
+			lc->next = c;
+		} else {
+			cladatum->constraints = c;
+		}
+
+		buf = next_entry(fp, sizeof(u32)*2);
+		if (!buf)
+			goto bad;
+		c->permissions = le32_to_cpu(buf[0]);
+		nexpr = le32_to_cpu(buf[1]);
+		le = NULL;
+		depth = -1;
+		for (j = 0; j < nexpr; j++) {
+			e = kmalloc(sizeof(*e), GFP_KERNEL);
+			if (!e) {
+				rc = -ENOMEM;
+				goto bad;
+			}
+			memset(e, 0, sizeof(*e));
+
+			if (le) {
+				le->next = e;
+			} else {
+				c->expr = e;
+			}
+
+			buf = next_entry(fp, sizeof(u32)*3);
+			if (!buf)
+				goto bad;
+			e->expr_type = le32_to_cpu(buf[0]);
+			e->attr = le32_to_cpu(buf[1]);
+			e->op = le32_to_cpu(buf[2]);
+
+			switch (e->expr_type) {
+			case CEXPR_NOT:
+				if (depth < 0)
+					goto bad;
+				break;
+			case CEXPR_AND:
+			case CEXPR_OR:
+				if (depth < 1)
+					goto bad;
+				depth--;
+				break;
+			case CEXPR_ATTR:
+				if (depth == (CEXPR_MAXDEPTH-1))
+					goto bad;
+				depth++;
+				break;
+			case CEXPR_NAMES:
+				if (depth == (CEXPR_MAXDEPTH-1))
+					goto bad;
+				depth++;
+				if (ebitmap_read(&e->names, fp))
+					goto bad;
+				break;
+			default:
+				goto bad;
+			}
+			le = e;
+		}
+		if (depth != 0)
+			goto bad;
+		lc = c;
+	}
+
+	rc = mls_read_class(cladatum, fp);
+	if (rc)
+		goto bad;
+
+	rc = hashtab_insert(h, key, cladatum);
+	if (rc)
+		goto bad;
+out:
+	return rc;
+bad:
+	class_destroy(key, cladatum, NULL);
+	goto out;
+}
+
+static int role_read(struct policydb *p, struct hashtab *h, void *fp)
+{
+	char *key = 0;
+	struct role_datum *role;
+	int rc;
+	u32 *buf, len;
+
+	role = kmalloc(sizeof(*role), GFP_KERNEL);
+	if (!role) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	memset(role, 0, sizeof(*role));
+
+	buf = next_entry(fp, sizeof(u32)*2);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+
+	len = le32_to_cpu(buf[0]);
+	role->value = le32_to_cpu(buf[1]);
+
+	buf = next_entry(fp, len);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	key = kmalloc(len + 1,GFP_KERNEL);
+	if (!key) {
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memcpy(key, buf, len);
+	key[len] = 0;
+
+	rc = ebitmap_read(&role->dominates, fp);
+	if (rc)
+		goto bad;
+
+	rc = ebitmap_read(&role->types, fp);
+	if (rc)
+		goto bad;
+
+	if (strcmp(key, OBJECT_R) == 0) {
+		if (role->value != OBJECT_R_VAL) {
+			printk(KERN_ERR "Role %s has wrong value %d\n",
+			       OBJECT_R, role->value);
+			rc = -EINVAL;
+			goto bad;
+		}
+		rc = 0;
+		goto bad;
+	}
+
+	rc = hashtab_insert(h, key, role);
+	if (rc)
+		goto bad;
+out:
+	return rc;
+bad:
+	role_destroy(key, role, NULL);
+	goto out;
+}
+
+static int type_read(struct policydb *p, struct hashtab *h, void *fp)
+{
+	char *key = 0;
+	struct type_datum *typdatum;
+	int rc;
+	u32 *buf, len;
+
+	typdatum = kmalloc(sizeof(*typdatum),GFP_KERNEL);
+	if (!typdatum) {
+		rc = -ENOMEM;
+		return rc;
+	}
+	memset(typdatum, 0, sizeof(*typdatum));
+
+	buf = next_entry(fp, sizeof(u32)*3);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+
+	len = le32_to_cpu(buf[0]);
+	typdatum->value = le32_to_cpu(buf[1]);
+	typdatum->primary = le32_to_cpu(buf[2]);
+
+	buf = next_entry(fp, len);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	key = kmalloc(len + 1,GFP_KERNEL);
+	if (!key) {
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memcpy(key, buf, len);
+	key[len] = 0;
+
+	rc = hashtab_insert(h, key, typdatum);
+	if (rc)
+		goto bad;
+out:
+	return rc;
+bad:
+	type_destroy(key, typdatum, NULL);
+	goto out;
+}
+
+static int user_read(struct policydb *p, struct hashtab *h, void *fp)
+{
+	char *key = 0;
+	struct user_datum *usrdatum;
+	int rc;
+	u32 *buf, len;
+
+
+	usrdatum = kmalloc(sizeof(*usrdatum), GFP_KERNEL);
+	if (!usrdatum) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	memset(usrdatum, 0, sizeof(*usrdatum));
+
+	buf = next_entry(fp, sizeof(u32)*2);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+
+	len = le32_to_cpu(buf[0]);
+	usrdatum->value = le32_to_cpu(buf[1]);
+
+	buf = next_entry(fp, len);
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	key = kmalloc(len + 1,GFP_KERNEL);
+	if (!key) {
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memcpy(key, buf, len);
+	key[len] = 0;
+
+	rc = ebitmap_read(&usrdatum->roles, fp);
+	if (rc)
+		goto bad;
+
+	rc = mls_read_user(usrdatum, fp);
+	if (rc)
+		goto bad;
+
+	rc = hashtab_insert(h, key, usrdatum);
+	if (rc)
+		goto bad;
+out:
+	return rc;
+bad:
+	user_destroy(key, usrdatum, NULL);
+	goto out;
+}
+
+static int (*read_f[SYM_NUM]) (struct policydb *p, struct hashtab *h, void *fp) =
+{
+	common_read,
+	class_read,
+	role_read,
+	type_read,
+	user_read
+	mls_read_f
+};
+
+#define mls_config(x) \
+       ((x) & POLICYDB_CONFIG_MLS) ? "mls" : "no_mls"
+
+/*
+ * Read the configuration data from a policy database binary
+ * representation file into a policy database structure.
+ */
+int policydb_read(struct policydb *p, void *fp)
+{
+	struct role_allow *ra, *lra;
+	struct role_trans *tr, *ltr;
+	struct ocontext *l, *c, *newc;
+	struct genfs *genfs_p, *genfs, *newgenfs;
+	int i, j, rc;
+	u32 *buf, len, len2, config, nprim, nel, nel2;
+	char *policydb_str;
+
+	config = 0;
+	mls_set_config(config);
+
+	rc = policydb_init(p);
+	if (rc)
+		goto out;
+
+	rc = -EINVAL;
+	/* Read the magic number and string length. */
+	buf = next_entry(fp, sizeof(u32)* 2);
+	if (!buf)
+		goto bad;
+
+	for (i = 0; i < 2; i++)
+		buf[i] = le32_to_cpu(buf[i]);
+
+	if (buf[0] != POLICYDB_MAGIC) {
+		printk(KERN_ERR "security:  policydb magic number 0x%x does "
+		       "not match expected magic number 0x%x\n",
+		       buf[0], POLICYDB_MAGIC);
+		goto bad;
+	}
+
+	len = buf[1];
+	if (len != strlen(POLICYDB_STRING)) {
+		printk(KERN_ERR "security:  policydb string length %d does not "
+		       "match expected length %Zd\n",
+		       len, strlen(POLICYDB_STRING));
+		goto bad;
+	}
+	buf = next_entry(fp, len);
+	if (!buf) {
+		printk(KERN_ERR "security:  truncated policydb string identifier\n");
+		goto bad;
+	}
+	policydb_str = kmalloc(len + 1,GFP_KERNEL);
+	if (!policydb_str) {
+		printk(KERN_ERR "security:  unable to allocate memory for policydb "
+		       "string of length %d\n", len);
+		rc = -ENOMEM;
+		goto bad;
+	}
+	memcpy(policydb_str, buf, len);
+	policydb_str[len] = 0;
+	if (strcmp(policydb_str, POLICYDB_STRING)) {
+		printk(KERN_ERR "security:  policydb string %s does not match "
+		       "my string %s\n", policydb_str, POLICYDB_STRING);
+		kfree(policydb_str);
+		goto bad;
+	}
+	/* Done with policydb_str. */
+	kfree(policydb_str);
+	policydb_str = NULL;
+
+	/* Read the version, config, and table sizes. */
+	buf = next_entry(fp, sizeof(u32)*4);
+	if (!buf)
+		goto bad;
+	for (i = 0; i < 4; i++)
+		buf[i] = le32_to_cpu(buf[i]);
+
+	if (buf[0] != POLICYDB_VERSION) {
+		printk(KERN_ERR "security:  policydb version %d does not match "
+		       "my version %d\n", buf[0], POLICYDB_VERSION);
+		goto bad;
+	}
+	if (buf[1] != config) {
+		printk(KERN_ERR "security:  policydb configuration (%s) does "
+		       "not match my configuration (%s)\n",
+		       mls_config(buf[1]),
+		       mls_config(config));
+		goto bad;
+	}
+	if (buf[2] != SYM_NUM || buf[3] != OCON_NUM) {
+		printk(KERN_ERR "security:  policydb table sizes (%d,%d) do "
+		       "not match mine (%d,%d)\n",
+		       buf[2], buf[3], SYM_NUM, OCON_NUM);
+		goto bad;
+	}
+
+	rc = mls_read_nlevels(p, fp);
+	if (rc)
+		goto bad;
+
+	for (i = 0; i < SYM_NUM; i++) {
+		buf = next_entry(fp, sizeof(u32)*2);
+		if (!buf) {
+			rc = -EINVAL;
+			goto bad;
+		}
+		nprim = le32_to_cpu(buf[0]);
+		nel = le32_to_cpu(buf[1]);
+		for (j = 0; j < nel; j++) {
+			rc = read_f[i](p, p->symtab[i].table, fp);
+			if (rc)
+				goto bad;
+		}
+
+		p->symtab[i].nprim = nprim;
+	}
+
+	rc = avtab_read(&p->te_avtab, fp, config);
+	if (rc)
+		goto bad;
+
+	buf = next_entry(fp, sizeof(u32));
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	nel = le32_to_cpu(buf[0]);
+	ltr = NULL;
+	for (i = 0; i < nel; i++) {
+		tr = kmalloc(sizeof(*tr), GFP_KERNEL);
+		if (!tr) {
+			rc = -ENOMEM;
+			goto bad;
+		}
+		memset(tr, 0, sizeof(*tr));
+		if (ltr) {
+			ltr->next = tr;
+		} else {
+			p->role_tr = tr;
+		}
+		buf = next_entry(fp, sizeof(u32)*3);
+		if (!buf) {
+			rc = -EINVAL;
+			goto bad;
+		}
+		tr->role = le32_to_cpu(buf[0]);
+		tr->type = le32_to_cpu(buf[1]);
+		tr->new_role = le32_to_cpu(buf[2]);
+		ltr = tr;
+	}
+
+	buf = next_entry(fp, sizeof(u32));
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	nel = le32_to_cpu(buf[0]);
+	lra = NULL;
+	for (i = 0; i < nel; i++) {
+		ra = kmalloc(sizeof(*ra), GFP_KERNEL);
+		if (!ra) {
+			rc = -ENOMEM;
+			goto bad;
+		}
+		memset(ra, 0, sizeof(*ra));
+		if (lra) {
+			lra->next = ra;
+		} else {
+			p->role_allow = ra;
+		}
+		buf = next_entry(fp, sizeof(u32)*2);
+		if (!buf) {
+			rc = -EINVAL;
+			goto bad;
+		}
+		ra->role = le32_to_cpu(buf[0]);
+		ra->new_role = le32_to_cpu(buf[1]);
+		lra = ra;
+	}
+
+	rc = policydb_index_classes(p);
+	if (rc)
+		goto bad;
+
+	rc = policydb_index_others(p);
+	if (rc)
+		goto bad;
+
+	for (i = 0; i < OCON_NUM; i++) {
+		buf = next_entry(fp, sizeof(u32));
+		if (!buf) {
+			rc = -EINVAL;
+			goto bad;
+		}
+		nel = le32_to_cpu(buf[0]);
+		l = NULL;
+		for (j = 0; j < nel; j++) {
+			c = kmalloc(sizeof(*c), GFP_KERNEL);
+			if (!c) {
+				rc = -ENOMEM;
+				goto bad;
+			}
+			memset(c, 0, sizeof(*c));
+			if (l) {
+				l->next = c;
+			} else {
+				p->ocontexts[i] = c;
+			}
+			l = c;
+			rc = -EINVAL;
+			switch (i) {
+			case OCON_ISID:
+				buf = next_entry(fp, sizeof(u32));
+				if (!buf)
+					goto bad;
+				c->sid[0] = le32_to_cpu(buf[0]);
+				rc = context_read_and_validate(&c->context[0], p, fp);
+				if (rc)
+					goto bad;
+				break;
+			case OCON_FS:
+			case OCON_NETIF:
+				buf = next_entry(fp, sizeof(u32));
+				if (!buf)
+					goto bad;
+				len = le32_to_cpu(buf[0]);
+				buf = next_entry(fp, len);
+				if (!buf)
+					goto bad;
+				c->u.name = kmalloc(len + 1,GFP_KERNEL);
+				if (!c->u.name) {
+					rc = -ENOMEM;
+					goto bad;
+				}
+				memcpy(c->u.name, buf, len);
+				c->u.name[len] = 0;
+				rc = context_read_and_validate(&c->context[0], p, fp);
+				if (rc)
+					goto bad;
+				rc = context_read_and_validate(&c->context[1], p, fp);
+				if (rc)
+					goto bad;
+				break;
+			case OCON_PORT:
+				buf = next_entry(fp, sizeof(u32)*3);
+				if (!buf)
+					goto bad;
+				c->u.port.protocol = le32_to_cpu(buf[0]);
+				c->u.port.low_port = le32_to_cpu(buf[1]);
+				c->u.port.high_port = le32_to_cpu(buf[2]);
+				rc = context_read_and_validate(&c->context[0], p, fp);
+				if (rc)
+					goto bad;
+				break;
+			case OCON_NODE:
+				buf = next_entry(fp, sizeof(u32)* 2);
+				if (!buf)
+					goto bad;
+				c->u.node.addr = le32_to_cpu(buf[0]);
+				c->u.node.mask = le32_to_cpu(buf[1]);
+				rc = context_read_and_validate(&c->context[0], p, fp);
+				if (rc)
+					goto bad;
+				break;
+			case OCON_FSUSE:
+				buf = next_entry(fp, sizeof(u32)*2);
+				if (!buf)
+					goto bad;
+				c->v.behavior = le32_to_cpu(buf[0]);
+				if (c->v.behavior > SECURITY_FS_USE_NONE)
+					goto bad;
+				len = le32_to_cpu(buf[1]);
+				buf = next_entry(fp, len);
+				if (!buf)
+					goto bad;
+				c->u.name = kmalloc(len + 1,GFP_KERNEL);
+				if (!c->u.name) {
+					rc = -ENOMEM;
+					goto bad;
+				}
+				memcpy(c->u.name, buf, len);
+				c->u.name[len] = 0;
+				rc = context_read_and_validate(&c->context[0], p, fp);
+				if (rc)
+					goto bad;
+				break;
+			}
+		}
+	}
+
+	buf = next_entry(fp, sizeof(u32));
+	if (!buf) {
+		rc = -EINVAL;
+		goto bad;
+	}
+	nel = le32_to_cpu(buf[0]);
+	genfs_p = NULL;
+	rc = -EINVAL;
+	for (i = 0; i < nel; i++) {
+		buf = next_entry(fp, sizeof(u32));
+		if (!buf)
+			goto bad;
+		len = le32_to_cpu(buf[0]);
+		buf = next_entry(fp, len);
+		if (!buf)
+			goto bad;
+		newgenfs = kmalloc(sizeof(*newgenfs), GFP_KERNEL);
+		if (!newgenfs) {
+			rc = -ENOMEM;
+			goto bad;
+		}
+		memset(newgenfs, 0, sizeof(*newgenfs));
+
+		newgenfs->fstype = kmalloc(len + 1,GFP_KERNEL);
+		if (!newgenfs->fstype) {
+			rc = -ENOMEM;
+			kfree(newgenfs);
+			goto bad;
+		}
+		memcpy(newgenfs->fstype, buf, len);
+		newgenfs->fstype[len] = 0;
+		for (genfs_p = NULL, genfs = p->genfs; genfs;
+		     genfs_p = genfs, genfs = genfs->next) {
+			if (strcmp(newgenfs->fstype, genfs->fstype) == 0) {
+				printk(KERN_ERR "security:  dup genfs "
+				       "fstype %s\n", newgenfs->fstype);
+				kfree(newgenfs->fstype);
+				kfree(newgenfs);
+				goto bad;
+			}
+			if (strcmp(newgenfs->fstype, genfs->fstype) < 0)
+				break;
+		}
+		newgenfs->next = genfs;
+		if (genfs_p)
+			genfs_p->next = newgenfs;
+		else
+			p->genfs = newgenfs;
+		buf = next_entry(fp, sizeof(u32));
+		if (!buf)
+			goto bad;
+		nel2 = le32_to_cpu(buf[0]);
+		for (j = 0; j < nel2; j++) {
+			buf = next_entry(fp, sizeof(u32));
+			if (!buf)
+				goto bad;
+			len = le32_to_cpu(buf[0]);
+			buf = next_entry(fp, len);
+			if (!buf)
+				goto bad;
+
+			newc = kmalloc(sizeof(*newc), GFP_KERNEL);
+			if (!newc) {
+				rc = -ENOMEM;
+				goto bad;
+			}
+			memset(newc, 0, sizeof(*newc));
+
+			newc->u.name = kmalloc(len + 1,GFP_KERNEL);
+			if (!newc->u.name) {
+				rc = -ENOMEM;
+				goto bad_newc;
+			}
+			memcpy(newc->u.name, buf, len);
+			newc->u.name[len] = 0;
+			buf = next_entry(fp, sizeof(u32));
+			if (!buf)
+				goto bad_newc;
+			newc->v.sclass = le32_to_cpu(buf[0]);
+			if (context_read_and_validate(&newc->context[0], p, fp))
+				goto bad_newc;
+			for (l = NULL, c = newgenfs->head; c;
+			     l = c, c = c->next) {
+				if (!strcmp(newc->u.name, c->u.name) &&
+				    (!c->v.sclass || !newc->v.sclass ||
+				     newc->v.sclass == c->v.sclass)) {
+					printk(KERN_ERR "security:  dup genfs "
+					       "entry (%s,%s)\n",
+					       newgenfs->fstype, c->u.name);
+					goto bad_newc;
+				}
+				len = strlen(newc->u.name);
+				len2 = strlen(c->u.name);
+				if (len > len2)
+					break;
+			}
+
+			newc->next = c;
+			if (l)
+				l->next = newc;
+			else
+				newgenfs->head = newc;
+		}
+	}
+
+	rc = mls_read_trusted(p, fp);
+	if (rc)
+		goto bad;
+out:
+	return rc;
+bad_newc:
+	ocontext_destroy(newc,OCON_FSUSE);
+bad:
+	policydb_destroy(p);
+	goto out;
+}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/policydb.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/policydb.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/policydb.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/policydb.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,255 @@
+/*
+ * A policy database (policydb) specifies the
+ * configuration data for the security policy.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_POLICYDB_H_
+#define _SS_POLICYDB_H_
+
+#include "symtab.h"
+#include "avtab.h"
+#include "sidtab.h"
+#include "context.h"
+#include "constraint.h"
+
+/*
+ * A datum type is defined for each kind of symbol
+ * in the configuration data:  individual permissions,
+ * common prefixes for access vectors, classes,
+ * users, roles, types, sensitivities, categories, etc.
+ */
+
+/* Permission attributes */
+struct perm_datum {
+	u32 value;		/* permission bit + 1 */
+#ifdef CONFIG_SECURITY_SELINUX_MLS
+#define MLS_BASE_READ    1	/* MLS base permission `read' */
+#define MLS_BASE_WRITE   2	/* MLS base permission `write' */
+#define MLS_BASE_READBY  4	/* MLS base permission `readby' */
+#define MLS_BASE_WRITEBY 8	/* MLS base permission `writeby' */
+	u32 base_perms;		/* MLS base permission mask */
+#endif
+};
+
+/* Attributes of a common prefix for access vectors */
+struct common_datum {
+	u32 value;			/* internal common value */
+	struct symtab permissions;	/* common permissions */
+};
+
+/* Class attributes */
+struct class_datum {
+	u32 value;			/* class value */
+	char *comkey;			/* common name */
+	struct common_datum *comdatum;	/* common datum */
+	struct symtab permissions;	/* class-specific permission symbol table */
+	struct constraint_node *constraints;	/* constraints on class permissions */
+#ifdef CONFIG_SECURITY_SELINUX_MLS
+	struct mls_perms mlsperms;	/* MLS base permission masks */
+#endif
+};
+
+/* Role attributes */
+struct role_datum {
+	u32 value;			/* internal role value */
+	struct ebitmap dominates;	/* set of roles dominated by this role */
+	struct ebitmap types;		/* set of authorized types for role */
+};
+
+struct role_trans {
+	u32 role;		/* current role */
+	u32 type;		/* program executable type */
+	u32 new_role;		/* new role */
+	struct role_trans *next;
+};
+
+struct role_allow {
+	u32 role;		/* current role */
+	u32 new_role;		/* new role */
+	struct role_allow *next;
+};
+
+/* Type attributes */
+struct type_datum {
+	u32 value;		/* internal type value */
+	unsigned char primary;	/* primary name? */
+};
+
+/* User attributes */
+struct user_datum {
+	u32 value;			/* internal user value */
+	struct ebitmap roles;		/* set of authorized roles for user */
+#ifdef CONFIG_SECURITY_SELINUX_MLS
+	struct mls_range_list *ranges;	/* list of authorized MLS ranges for user */
+#endif
+};
+
+
+#ifdef CONFIG_SECURITY_SELINUX_MLS
+/* Sensitivity attributes */
+struct level_datum {
+	struct mls_level *level;	/* sensitivity and associated categories */
+	unsigned char isalias;	/* is this sensitivity an alias for another? */
+};
+
+/* Category attributes */
+struct cat_datum {
+	u32 value;		/* internal category bit + 1 */
+	unsigned char isalias;  /* is this category an alias for another? */
+};
+#endif
+
+
+/*
+ * The configuration data includes security contexts for
+ * initial SIDs, unlabeled file systems, TCP and UDP port numbers,
+ * network interfaces, and nodes.  This structure stores the
+ * relevant data for one such entry.  Entries of the same kind
+ * (e.g. all initial SIDs) are linked together into a list.
+ */
+struct ocontext {
+	union {
+		char *name;	/* name of initial SID, fs, netif, fstype, path */
+		struct {
+			u8 protocol;
+			u16 low_port;
+			u16 high_port;
+		} port;		/* TCP or UDP port information */
+		struct {
+			u32 addr;
+			u32 mask;
+		} node;		/* node information */
+	} u;
+	union {
+		u32 sclass;  /* security class for genfs */
+		u32 behavior;  /* labeling behavior for fs_use */
+	} v;
+	struct context context[2];	/* security context(s) */
+	u32 sid[2];	/* SID(s) */
+	struct ocontext *next;
+};
+
+struct genfs {
+	char *fstype;
+	struct ocontext *head;
+	struct genfs *next;
+};
+
+/* symbol table array indices */
+#define SYM_COMMONS 0
+#define SYM_CLASSES 1
+#define SYM_ROLES   2
+#define SYM_TYPES   3
+#define SYM_USERS   4
+#ifdef CONFIG_SECURITY_SELINUX_MLS
+#define SYM_LEVELS  5
+#define SYM_CATS    6
+#define SYM_NUM     7
+#else
+#define SYM_NUM     5
+#endif
+
+/* object context array indices */
+#define OCON_ISID  0	/* initial SIDs */
+#define OCON_FS    1	/* unlabeled file systems */
+#define OCON_PORT  2	/* TCP and UDP port numbers */
+#define OCON_NETIF 3	/* network interfaces */
+#define OCON_NODE  4	/* nodes */
+#define OCON_FSUSE 5	/* fs_use */
+#define OCON_NUM   6
+
+/* The policy database */
+struct policydb {
+	/* symbol tables */
+	struct symtab symtab[SYM_NUM];
+#define p_commons symtab[SYM_COMMONS]
+#define p_classes symtab[SYM_CLASSES]
+#define p_roles symtab[SYM_ROLES]
+#define p_types symtab[SYM_TYPES]
+#define p_users symtab[SYM_USERS]
+#define p_levels symtab[SYM_LEVELS]
+#define p_cats symtab[SYM_CATS]
+
+	/* symbol names indexed by (value - 1) */
+	char **sym_val_to_name[SYM_NUM];
+#define p_common_val_to_name sym_val_to_name[SYM_COMMONS]
+#define p_class_val_to_name sym_val_to_name[SYM_CLASSES]
+#define p_role_val_to_name sym_val_to_name[SYM_ROLES]
+#define p_type_val_to_name sym_val_to_name[SYM_TYPES]
+#define p_user_val_to_name sym_val_to_name[SYM_USERS]
+#define p_sens_val_to_name sym_val_to_name[SYM_LEVELS]
+#define p_cat_val_to_name sym_val_to_name[SYM_CATS]
+
+	/* class, role, and user attributes indexed by (value - 1) */
+	struct class_datum **class_val_to_struct;
+	struct role_datum **role_val_to_struct;
+	struct user_datum **user_val_to_struct;
+
+	/* type enforcement access vectors and transitions */
+	struct avtab te_avtab;
+
+	/* role transitions */
+	struct role_trans *role_tr;
+
+	/* role allows */
+	struct role_allow *role_allow;
+
+	/* security contexts of initial SIDs, unlabeled file systems,
+	   TCP or UDP port numbers, network interfaces and nodes */
+	struct ocontext *ocontexts[OCON_NUM];
+
+        /* security contexts for files in filesystems that cannot support
+	   a persistent label mapping or use another
+	   fixed labeling behavior. */
+  	struct genfs *genfs;
+
+#ifdef CONFIG_SECURITY_SELINUX_MLS
+	/* number of legitimate MLS levels */
+	u32 nlevels;
+
+	struct ebitmap trustedreaders;
+	struct ebitmap trustedwriters;
+	struct ebitmap trustedobjects;
+#endif
+};
+
+extern int policydb_init(struct policydb *p);
+extern int policydb_index_classes(struct policydb *p);
+extern int policydb_index_others(struct policydb *p);
+extern int constraint_expr_destroy(struct constraint_expr *expr);
+extern void policydb_destroy(struct policydb *p);
+extern int policydb_load_isids(struct policydb *p, struct sidtab *s);
+extern int policydb_context_isvalid(struct policydb *p, struct context *c);
+extern int policydb_read(struct policydb *p, void *fp);
+
+#define PERM_SYMTAB_SIZE 32
+
+#define POLICYDB_CONFIG_MLS    1
+
+#define OBJECT_R "object_r"
+#define OBJECT_R_VAL 1
+
+#define POLICYDB_MAGIC SELINUX_MAGIC
+#define POLICYDB_STRING "SE Linux"
+
+struct policy_file {
+	char *data;
+	size_t len;
+};
+
+static inline void *next_entry(struct policy_file *fp, size_t bytes)
+{
+	void *buf;
+
+	if (bytes > fp->len)
+		return NULL;
+
+	buf = fp->data;
+	fp->data += bytes;
+	fp->len -= bytes;
+	return buf;
+}
+
+#endif	/* _SS_POLICYDB_H_ */
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/services.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/services.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/services.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/services.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,1426 @@
+/*
+ * Implementation of the security services.
+ *
+ * Authors : Stephen Smalley, <sds@epoch.ncsc.mil>
+ *           James Morris <jmorris@redhat.com>
+ *
+ *  Copyright (C) 2003 Red Hat, Inc., James Morris <jmorris@redhat.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License version 2,
+ *      as published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <asm/semaphore.h>
+#include "flask.h"
+#include "avc.h"
+#include "avc_ss.h"
+#include "security.h"
+#include "context.h"
+#include "policydb.h"
+#include "sidtab.h"
+#include "services.h"
+#include "mls.h"
+
+static rwlock_t policy_rwlock = RW_LOCK_UNLOCKED;
+#define POLICY_RDLOCK read_lock(&policy_rwlock)
+#define POLICY_WRLOCK write_lock_irq(&policy_rwlock)
+#define POLICY_RDUNLOCK read_unlock(&policy_rwlock)
+#define POLICY_WRUNLOCK write_unlock_irq(&policy_rwlock)
+
+static DECLARE_MUTEX(load_sem);
+#define LOAD_LOCK down(&load_sem)
+#define LOAD_UNLOCK up(&load_sem)
+
+struct sidtab sidtab;
+struct policydb policydb;
+int ss_initialized = 0;
+
+/*
+ * The largest sequence number that has been used when
+ * providing an access decision to the access vector cache.
+ * The sequence number only changes when a policy change
+ * occurs.
+ */
+static u32 latest_granting = 0;
+
+/*
+ * Return the boolean value of a constraint expression
+ * when it is applied to the specified source and target
+ * security contexts.
+ */
+static int constraint_expr_eval(struct context *scontext,
+				struct context *tcontext,
+				struct constraint_expr *cexpr)
+{
+	u32 val1, val2;
+	struct context *c;
+	struct role_datum *r1, *r2;
+	struct constraint_expr *e;
+	int s[CEXPR_MAXDEPTH];
+	int sp = -1;
+
+	for (e = cexpr; e; e = e->next) {
+		switch (e->expr_type) {
+		case CEXPR_NOT:
+			BUG_ON(sp < 0);
+			s[sp] = !s[sp];
+			break;
+		case CEXPR_AND:
+			BUG_ON(sp < 1);
+			sp--;
+			s[sp] &= s[sp+1];
+			break;
+		case CEXPR_OR:
+			BUG_ON(sp < 1);
+			sp--;
+			s[sp] |= s[sp+1];
+			break;
+		case CEXPR_ATTR:
+			if (sp == (CEXPR_MAXDEPTH-1))
+				return 0;
+			switch (e->attr) {
+			case CEXPR_USER:
+				val1 = scontext->user;
+				val2 = tcontext->user;
+				break;
+			case CEXPR_TYPE:
+				val1 = scontext->type;
+				val2 = tcontext->type;
+				break;
+			case CEXPR_ROLE:
+				val1 = scontext->role;
+				val2 = tcontext->role;
+				r1 = policydb.role_val_to_struct[val1 - 1];
+				r2 = policydb.role_val_to_struct[val2 - 1];
+				switch (e->op) {
+				case CEXPR_DOM:
+					s[++sp] = ebitmap_get_bit(&r1->dominates,
+								  val2 - 1);
+					continue;
+				case CEXPR_DOMBY:
+					s[++sp] = ebitmap_get_bit(&r2->dominates,
+								  val1 - 1);
+					continue;
+				case CEXPR_INCOMP:
+					s[++sp] = ( !ebitmap_get_bit(&r1->dominates,
+								     val2 - 1) &&
+						    !ebitmap_get_bit(&r2->dominates,
+								     val1 - 1) );
+					continue;
+				default:
+					break;
+				}
+				break;
+			default:
+				BUG();
+				return 0;
+			}
+
+			switch (e->op) {
+			case CEXPR_EQ:
+				s[++sp] = (val1 == val2);
+				break;
+			case CEXPR_NEQ:
+				s[++sp] = (val1 != val2);
+				break;
+			default:
+				BUG();
+				return 0;
+			}
+			break;
+		case CEXPR_NAMES:
+			if (sp == (CEXPR_MAXDEPTH-1))
+				return 0;
+			c = scontext;
+			if (e->attr & CEXPR_TARGET)
+				c = tcontext;
+			if (e->attr & CEXPR_USER)
+				val1 = c->user;
+			else if (e->attr & CEXPR_ROLE)
+				val1 = c->role;
+			else if (e->attr & CEXPR_TYPE)
+				val1 = c->type;
+			else {
+				BUG();
+				return 0;
+			}
+
+			switch (e->op) {
+			case CEXPR_EQ:
+				s[++sp] = ebitmap_get_bit(&e->names, val1 - 1);
+				break;
+			case CEXPR_NEQ:
+				s[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);
+				break;
+			default:
+				BUG();
+				return 0;
+			}
+			break;
+		default:
+			BUG();
+			return 0;
+		}
+	}
+
+	BUG_ON(sp != 0);
+	return s[0];
+}
+
+/*
+ * Compute access vectors based on a context structure pair for
+ * the permissions in a particular class.
+ */
+static int context_struct_compute_av(struct context *scontext,
+				     struct context *tcontext,
+				     u16 tclass,
+				     u32 requested,
+				     struct av_decision *avd)
+{
+	struct constraint_node *constraint;
+	struct role_allow *ra;
+	struct avtab_key avkey;
+	struct avtab_datum *avdatum;
+	struct class_datum *tclass_datum;
+
+	if (!tclass || tclass > policydb.p_classes.nprim) {
+		printk(KERN_ERR "security_compute_av:  unrecognized class %d\n",
+		       tclass);
+		return -EINVAL;
+	}
+	tclass_datum = policydb.class_val_to_struct[tclass - 1];
+
+	/*
+	 * Initialize the access vectors to the default values.
+	 */
+	avd->allowed = 0;
+	avd->decided = 0xffffffff;
+	avd->auditallow = 0;
+	avd->auditdeny = 0xffffffff;
+	avd->seqno = latest_granting;
+
+	/*
+	 * If a specific type enforcement rule was defined for
+	 * this permission check, then use it.
+	 */
+	avkey.source_type = scontext->type;
+	avkey.target_type = tcontext->type;
+	avkey.target_class = tclass;
+	avdatum = avtab_search(&policydb.te_avtab, &avkey, AVTAB_AV);
+	if (avdatum) {
+		if (avdatum->specified & AVTAB_ALLOWED)
+			avd->allowed = avtab_allowed(avdatum);
+		if (avdatum->specified & AVTAB_AUDITDENY)
+			avd->auditdeny = avtab_auditdeny(avdatum);
+		if (avdatum->specified & AVTAB_AUDITALLOW)
+			avd->auditallow = avtab_auditallow(avdatum);
+	}
+
+	/*
+	 * Remove any permissions prohibited by the MLS policy.
+	 */
+	mls_compute_av(scontext, tcontext, tclass_datum, &avd->allowed);
+
+	/*
+	 * Remove any permissions prohibited by a constraint.
+	 */
+	constraint = tclass_datum->constraints;
+	while (constraint) {
+		if ((constraint->permissions & (avd->allowed)) &&
+		    !constraint_expr_eval(scontext, tcontext,
+					  constraint->expr)) {
+			avd->allowed = (avd->allowed) & ~(constraint->permissions);
+		}
+		constraint = constraint->next;
+	}
+
+	/*
+	 * If checking process transition permission and the
+	 * role is changing, then check the (current_role, new_role)
+	 * pair.
+	 */
+	if (tclass == SECCLASS_PROCESS &&
+	    avd->allowed && PROCESS__TRANSITION &&
+	    scontext->role != tcontext->role) {
+		for (ra = policydb.role_allow; ra; ra = ra->next) {
+			if (scontext->role == ra->role &&
+			    tcontext->role == ra->new_role)
+				break;
+		}
+		if (!ra)
+			avd->allowed = (avd->allowed) & ~(PROCESS__TRANSITION);
+	}
+
+	return 0;
+}
+
+/**
+ * security_compute_av - Compute access vector decisions.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ * @requested: requested permissions
+ * @avd: access vector decisions
+ *
+ * Compute a set of access vector decisions based on the
+ * SID pair (@ssid, @tsid) for the permissions in @tclass.
+ * Return -%EINVAL if any of the parameters are invalid or %0
+ * if the access vector decisions were computed successfully.
+ */
+int security_compute_av(u32 ssid,
+			u32 tsid,
+			u16 tclass,
+			u32 requested,
+			struct av_decision *avd)
+{
+	struct context *scontext = 0, *tcontext = 0;
+	int rc = 0;
+
+	if (!ss_initialized) {
+		avd->allowed = requested;
+		avd->decided = requested;
+		avd->auditallow = 0;
+		avd->auditdeny = 0xffffffff;
+		avd->seqno = latest_granting;
+		return 0;
+	}
+
+	POLICY_RDLOCK;
+
+	scontext = sidtab_search(&sidtab, ssid);
+	if (!scontext) {
+		printk(KERN_ERR "security_compute_av:  unrecognized SID %d\n",
+		       ssid);
+		rc = -EINVAL;
+		goto out;
+	}
+	tcontext = sidtab_search(&sidtab, tsid);
+	if (!tcontext) {
+		printk(KERN_ERR "security_compute_av:  unrecognized SID %d\n",
+		       tsid);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	rc = context_struct_compute_av(scontext, tcontext, tclass,
+				       requested, avd);
+out:
+	POLICY_RDUNLOCK;
+	return rc;
+}
+
+/*
+ * Write the security context string representation of
+ * the context structure `context' into a dynamically
+ * allocated string of the correct size.  Set `*scontext'
+ * to point to this string and set `*scontext_len' to
+ * the length of the string.
+ */
+int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)
+{
+	char *scontextp;
+
+	*scontext = 0;
+	*scontext_len = 0;
+
+	/* Compute the size of the context. */
+	*scontext_len += strlen(policydb.p_user_val_to_name[context->user - 1]) + 1;
+	*scontext_len += strlen(policydb.p_role_val_to_name[context->role - 1]) + 1;
+	*scontext_len += strlen(policydb.p_type_val_to_name[context->type - 1]) + 1;
+	*scontext_len += mls_compute_context_len(context);
+
+	/* Allocate space for the context; caller must free this space. */
+	scontextp = kmalloc(*scontext_len+1,GFP_ATOMIC);
+	if (!scontextp) {
+		return -ENOMEM;
+	}
+	*scontext = scontextp;
+
+	/*
+	 * Copy the user name, role name and type name into the context.
+	 */
+	sprintf(scontextp, "%s:%s:%s:",
+		policydb.p_user_val_to_name[context->user - 1],
+		policydb.p_role_val_to_name[context->role - 1],
+		policydb.p_type_val_to_name[context->type - 1]);
+	scontextp += strlen(policydb.p_user_val_to_name[context->user - 1]) +
+	             1 + strlen(policydb.p_role_val_to_name[context->role - 1]) +
+	             1 + strlen(policydb.p_type_val_to_name[context->type - 1]) + 1;
+
+	mls_sid_to_context(context, &scontextp);
+
+	scontextp--;
+	*scontextp = 0;
+
+	return 0;
+}
+
+#include "initial_sid_to_string.h"
+
+/**
+ * security_sid_to_context - Obtain a context for a given SID.
+ * @sid: security identifier, SID
+ * @scontext: security context
+ * @scontext_len: length in bytes
+ *
+ * Write the string representation of the context associated with @sid
+ * into a dynamically allocated string of the correct size.  Set @scontext
+ * to point to this string and set @scontext_len to the length of the string.
+ */
+int security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)
+{
+	struct context *context;
+	int rc = 0;
+
+	if (!ss_initialized) {
+		if (sid <= SECINITSID_NUM) {
+			char *scontextp;
+
+			*scontext_len = strlen(initial_sid_to_string[sid]) + 1;
+			scontextp = kmalloc(*scontext_len,GFP_KERNEL);
+			strcpy(scontextp, initial_sid_to_string[sid]);
+			*scontext = scontextp;
+			goto out;
+		}
+		printk(KERN_ERR "security_sid_to_context:  called before initial "
+		       "load_policy on unknown SID %d\n", sid);
+		rc = -EINVAL;
+		goto out;
+	}
+	POLICY_RDLOCK;
+	context = sidtab_search(&sidtab, sid);
+	if (!context) {
+		printk(KERN_ERR "security_sid_to_context:  unrecognized SID "
+		       "%d\n", sid);
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+	rc = context_struct_to_string(context, scontext, scontext_len);
+out_unlock:
+	POLICY_RDUNLOCK;
+out:
+	return rc;
+
+}
+
+/**
+ * security_context_to_sid - Obtain a SID for a given security context.
+ * @scontext: security context
+ * @scontext_len: length in bytes
+ * @sid: security identifier, SID
+ *
+ * Obtains a SID associated with the security context that
+ * has the string representation specified by @scontext.
+ * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient
+ * memory is available, or 0 on success.
+ */
+int security_context_to_sid(char *scontext, u32 scontext_len, u32 *sid)
+{
+	char *scontext2;
+	struct context context;
+	struct role_datum *role;
+	struct type_datum *typdatum;
+	struct user_datum *usrdatum;
+	char *scontextp, *p, oldc;
+	int rc = 0;
+
+	if (!ss_initialized) {
+		int i;
+
+		for (i = 1; i < SECINITSID_NUM; i++) {
+			if (!strcmp(initial_sid_to_string[i], scontext)) {
+				*sid = i;
+				goto out;
+			}
+		}
+		printk(KERN_ERR "security_context_to_sid: called before "
+		       "initial load_policy on unknown context %s\n", scontext);
+		rc = -EINVAL;
+		goto out;
+	}
+	*sid = SECSID_NULL;
+
+	/* Copy the string so that we can modify the copy as we parse it.
+	   The string should already by null terminated, but we append a
+	   null suffix to the copy to avoid problems with the existing
+	   attr package, which doesn't view the null terminator as part
+	   of the attribute value. */
+	scontext2 = kmalloc(scontext_len+1,GFP_KERNEL);
+	if (!scontext2) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	memcpy(scontext2, scontext, scontext_len);
+	scontext2[scontext_len] = 0;
+
+	context_init(&context);
+	*sid = SECSID_NULL;
+
+	POLICY_RDLOCK;
+
+	/* Parse the security context. */
+
+	rc = -EINVAL;
+	scontextp = (char *) scontext2;
+
+	/* Extract the user. */
+	p = scontextp;
+	while (*p && *p != ':')
+		p++;
+
+	if (*p == 0)
+		goto out_unlock;
+
+	*p++ = 0;
+
+	usrdatum = hashtab_search(policydb.p_users.table, scontextp);
+	if (!usrdatum)
+		goto out_unlock;
+
+	context.user = usrdatum->value;
+
+	/* Extract role. */
+	scontextp = p;
+	while (*p && *p != ':')
+		p++;
+
+	if (*p == 0)
+		goto out_unlock;
+
+	*p++ = 0;
+
+	role = hashtab_search(policydb.p_roles.table, scontextp);
+	if (!role)
+		goto out_unlock;
+	context.role = role->value;
+
+	/* Extract type. */
+	scontextp = p;
+	while (*p && *p != ':')
+		p++;
+	oldc = *p;
+	*p++ = 0;
+
+	typdatum = hashtab_search(policydb.p_types.table, scontextp);
+	if (!typdatum)
+		goto out_unlock;
+
+	context.type = typdatum->value;
+
+	rc = mls_context_to_sid(oldc, &p, &context);
+	if (rc)
+		goto out_unlock;
+
+	/* Check the validity of the new context. */
+	if (!policydb_context_isvalid(&policydb, &context)) {
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+	/* Obtain the new sid. */
+	rc = sidtab_context_to_sid(&sidtab, &context, sid);
+out_unlock:
+	POLICY_RDUNLOCK;
+	context_destroy(&context);
+	kfree(scontext2);
+out:
+	return rc;
+}
+
+static inline int compute_sid_handle_invalid_context(
+	struct context *scontext,
+	struct context *tcontext,
+	u16 tclass,
+	struct context *newcontext)
+{
+	int rc = 0;
+
+	if (selinux_enforcing) {
+		rc = -EACCES;
+	} else {
+		char *s, *t, *n;
+		u32 slen, tlen, nlen;
+
+		context_struct_to_string(scontext, &s, &slen);
+		context_struct_to_string(tcontext, &t, &tlen);
+		context_struct_to_string(newcontext, &n, &nlen);
+		printk(KERN_ERR "security_compute_sid:  invalid context %s", n);
+		printk(" for scontext=%s", s);
+		printk(" tcontext=%s", t);
+		printk(" tclass=%s\n", policydb.p_class_val_to_name[tclass-1]);
+		kfree(s);
+		kfree(t);
+		kfree(n);
+	}
+	return rc;
+}
+
+static int security_compute_sid(u32 ssid,
+				u32 tsid,
+				u16 tclass,
+				u32 specified,
+				u32 *out_sid)
+{
+	struct context *scontext = 0, *tcontext = 0, newcontext;
+	struct role_trans *roletr = 0;
+	struct avtab_key avkey;
+	struct avtab_datum *avdatum;
+	unsigned int type_change = 0;
+	int rc = 0;
+
+	if (!ss_initialized) {
+		switch (tclass) {
+		case SECCLASS_PROCESS:
+			*out_sid = ssid;
+			break;
+		default:
+			*out_sid = tsid;
+			break;
+		}
+		goto out;
+	}
+
+	POLICY_RDLOCK;
+
+	scontext = sidtab_search(&sidtab, ssid);
+	if (!scontext) {
+		printk(KERN_ERR "security_compute_sid:  unrecognized SID %d\n",
+		       ssid);
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+	tcontext = sidtab_search(&sidtab, tsid);
+	if (!tcontext) {
+		printk(KERN_ERR "security_compute_sid:  unrecognized SID %d\n",
+		       tsid);
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+
+	context_init(&newcontext);
+
+	/* Set the user identity. */
+	switch (specified) {
+	case AVTAB_TRANSITION:
+	case AVTAB_CHANGE:
+		/* Use the process user identity. */
+		newcontext.user = scontext->user;
+		break;
+	case AVTAB_MEMBER:
+		/* Use the related object owner. */
+		newcontext.user = tcontext->user;
+		break;
+	}
+
+	/* Set the role and type to default values. */
+	switch (tclass) {
+	case SECCLASS_PROCESS:
+		/* Use the current role and type of process. */
+		newcontext.role = scontext->role;
+		newcontext.type = scontext->type;
+		break;
+	default:
+		/* Use the well-defined object role. */
+		newcontext.role = OBJECT_R_VAL;
+		/* Use the type of the related object. */
+		newcontext.type = tcontext->type;
+	}
+
+	/* Look for a type transition/member/change rule. */
+	avkey.source_type = scontext->type;
+	avkey.target_type = tcontext->type;
+	avkey.target_class = tclass;
+	avdatum = avtab_search(&policydb.te_avtab, &avkey, AVTAB_TYPE);
+	type_change = (avdatum && (avdatum->specified & specified));
+	if (type_change) {
+		/* Use the type from the type transition/member/change rule. */
+		switch (specified) {
+		case AVTAB_TRANSITION:
+			newcontext.type = avtab_transition(avdatum);
+			break;
+		case AVTAB_MEMBER:
+			newcontext.type = avtab_member(avdatum);
+			break;
+		case AVTAB_CHANGE:
+			newcontext.type = avtab_change(avdatum);
+			break;
+		}
+	}
+
+	/* Check for class-specific changes. */
+	switch (tclass) {
+	case SECCLASS_PROCESS:
+		if (specified & AVTAB_TRANSITION) {
+			/* Look for a role transition rule. */
+			for (roletr = policydb.role_tr; roletr;
+			     roletr = roletr->next) {
+				if (roletr->role == scontext->role &&
+				    roletr->type == tcontext->type) {
+					/* Use the role transition rule. */
+					newcontext.role = roletr->new_role;
+					break;
+				}
+			}
+		}
+
+		if (!type_change && !roletr) {
+			/* No change in process role or type. */
+			*out_sid = ssid;
+			goto out_unlock;
+
+		}
+		break;
+	default:
+		if (!type_change &&
+		    (newcontext.user == tcontext->user) &&
+		    mls_context_cmp(scontext, tcontext)) {
+                        /* No change in object type, owner,
+			   or MLS attributes. */
+			*out_sid = tsid;
+			goto out_unlock;
+		}
+		break;
+	}
+
+	/* Set the MLS attributes.
+	   This is done last because it may allocate memory. */
+	rc = mls_compute_sid(scontext, tcontext, tclass, specified, &newcontext);
+	if (rc)
+		goto out_unlock;
+
+	/* Check the validity of the context. */
+	if (!policydb_context_isvalid(&policydb, &newcontext)) {
+		rc = compute_sid_handle_invalid_context(scontext,
+							tcontext,
+							tclass,
+							&newcontext);
+		if (rc)
+			goto out_unlock;
+	}
+	/* Obtain the sid for the context. */
+	rc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);
+out_unlock:
+	POLICY_RDUNLOCK;
+	context_destroy(&newcontext);
+out:
+	return rc;
+}
+
+/**
+ * security_transition_sid - Compute the SID for a new subject/object.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ * @out_sid: security identifier for new subject/object
+ *
+ * Compute a SID to use for labeling a new subject or object in the
+ * class @tclass based on a SID pair (@ssid, @tsid).
+ * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM
+ * if insufficient memory is available, or %0 if the new SID was
+ * computed successfully.
+ */
+int security_transition_sid(u32 ssid,
+			    u32 tsid,
+			    u16 tclass,
+			    u32 *out_sid)
+{
+	return security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION, out_sid);
+}
+
+/**
+ * security_member_sid - Compute the SID for member selection.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ * @out_sid: security identifier for selected member
+ *
+ * Compute a SID to use when selecting a member of a polyinstantiated
+ * object of class @tclass based on a SID pair (@ssid, @tsid).
+ * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM
+ * if insufficient memory is available, or %0 if the SID was
+ * computed successfully.
+ */
+int security_member_sid(u32 ssid,
+			u32 tsid,
+			u16 tclass,
+			u32 *out_sid)
+{
+	return security_compute_sid(ssid, tsid, tclass, AVTAB_MEMBER, out_sid);
+}
+
+/**
+ * security_change_sid - Compute the SID for object relabeling.
+ * @ssid: source security identifier
+ * @tsid: target security identifier
+ * @tclass: target security class
+ * @out_sid: security identifier for selected member
+ *
+ * Compute a SID to use for relabeling an object of class @tclass
+ * based on a SID pair (@ssid, @tsid).
+ * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM
+ * if insufficient memory is available, or %0 if the SID was
+ * computed successfully.
+ */
+int security_change_sid(u32 ssid,
+			u32 tsid,
+			u16 tclass,
+			u32 *out_sid)
+{
+	return security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, out_sid);
+}
+
+/*
+ * Verify that each permission that is defined under the
+ * existing policy is still defined with the same value
+ * in the new policy.
+ */
+static int validate_perm(void *key, void *datum, void *p)
+{
+	struct hashtab *h;
+	struct perm_datum *perdatum, *perdatum2;
+	int rc = 0;
+
+
+	h = p;
+	perdatum = datum;
+
+	perdatum2 = hashtab_search(h, key);
+	if (!perdatum2) {
+		printk(KERN_ERR "security:  permission %s disappeared",
+		       (char *)key);
+		rc = -ENOENT;
+		goto out;
+	}
+	if (perdatum->value != perdatum2->value) {
+		printk(KERN_ERR "security:  the value of permission %s changed",
+		       (char *)key);
+		rc = -EINVAL;
+	}
+out:
+	return rc;
+}
+
+/*
+ * Verify that each class that is defined under the
+ * existing policy is still defined with the same
+ * attributes in the new policy.
+ */
+static int validate_class(void *key, void *datum, void *p)
+{
+	struct policydb *newp;
+	struct class_datum *cladatum, *cladatum2;
+	int rc;
+
+	newp = p;
+	cladatum = datum;
+
+	cladatum2 = hashtab_search(newp->p_classes.table, key);
+	if (!cladatum2) {
+		printk(KERN_ERR "security:  class %s disappeared\n",
+		       (char *)key);
+		rc = -ENOENT;
+		goto out;
+	}
+	if (cladatum->value != cladatum2->value) {
+		printk(KERN_ERR "security:  the value of class %s changed\n",
+		       (char *)key);
+		rc = -EINVAL;
+		goto out;
+	}
+	if ((cladatum->comdatum && !cladatum2->comdatum) ||
+	    (!cladatum->comdatum && cladatum2->comdatum)) {
+		printk(KERN_ERR "security:  the inherits clause for the access "
+		       "vector definition for class %s changed\n", (char *)key);
+		rc = -EINVAL;
+		goto out;
+	}
+	if (cladatum->comdatum) {
+		rc = hashtab_map(cladatum->comdatum->permissions.table, validate_perm,
+		                 cladatum2->comdatum->permissions.table);
+		if (rc) {
+			printk(" in the access vector definition for class "
+			       "%s\n", (char *)key);
+			goto out;
+		}
+	}
+	rc = hashtab_map(cladatum->permissions.table, validate_perm,
+	                 cladatum2->permissions.table);
+	if (rc)
+		printk(" in access vector definition for class %s\n",
+		       (char *)key);
+out:
+	return rc;
+}
+
+/* Clone the SID into the new SID table. */
+static int clone_sid(u32 sid,
+		     struct context *context,
+		     void *arg)
+{
+	struct sidtab *s = arg;
+
+	return sidtab_insert(s, sid, context);
+}
+
+static inline int convert_context_handle_invalid_context(struct context *context)
+{
+	int rc = 0;
+
+	if (selinux_enforcing) {
+		rc = -EINVAL;
+	} else {
+		char *s;
+		u32 len;
+
+		context_struct_to_string(context, &s, &len);
+		printk(KERN_ERR "security:  context %s is invalid\n", s);
+		kfree(s);
+	}
+	return rc;
+}
+
+struct convert_context_args {
+	struct policydb *oldp;
+	struct policydb *newp;
+};
+
+/*
+ * Convert the values in the security context
+ * structure `c' from the values specified
+ * in the policy `p->oldp' to the values specified
+ * in the policy `p->newp'.  Verify that the
+ * context is valid under the new policy.
+ */
+static int convert_context(u32 key,
+			   struct context *c,
+			   void *p)
+{
+	struct convert_context_args *args;
+	struct context oldc;
+	struct role_datum *role;
+	struct type_datum *typdatum;
+	struct user_datum *usrdatum;
+	char *s;
+	u32 len;
+	int rc;
+
+	args = p;
+
+	rc = context_cpy(&oldc, c);
+	if (rc)
+		goto out;
+
+	rc = -EINVAL;
+
+	/* Convert the user. */
+	usrdatum = hashtab_search(args->newp->p_users.table,
+	                          args->oldp->p_user_val_to_name[c->user - 1]);
+	if (!usrdatum) {
+		goto bad;
+	}
+	c->user = usrdatum->value;
+
+	/* Convert the role. */
+	role = hashtab_search(args->newp->p_roles.table,
+	                      args->oldp->p_role_val_to_name[c->role - 1]);
+	if (!role) {
+		goto bad;
+	}
+	c->role = role->value;
+
+	/* Convert the type. */
+	typdatum = hashtab_search(args->newp->p_types.table,
+	                          args->oldp->p_type_val_to_name[c->type - 1]);
+	if (!typdatum) {
+		goto bad;
+	}
+	c->type = typdatum->value;
+
+	rc = mls_convert_context(args->oldp, args->newp, c);
+	if (rc)
+		goto bad;
+
+	/* Check the validity of the new context. */
+	if (!policydb_context_isvalid(args->newp, c)) {
+		rc = convert_context_handle_invalid_context(&oldc);
+		if (rc)
+			goto bad;
+	}
+
+	context_destroy(&oldc);
+out:
+	return rc;
+bad:
+	context_struct_to_string(&oldc, &s, &len);
+	context_destroy(&oldc);
+	printk(KERN_ERR "security:  invalidating context %s\n", s);
+	kfree(s);
+	goto out;
+}
+
+extern void selinux_complete_init(void);
+
+/**
+ * security_load_policy - Load a security policy configuration.
+ * @data: binary policy data
+ * @len: length of data in bytes
+ *
+ * Load a new set of security policy configuration data,
+ * validate it and convert the SID table as necessary.
+ * This function will flush the access vector cache after
+ * loading the new policy.
+ */
+int security_load_policy(void *data, size_t len)
+{
+	struct policydb oldpolicydb, newpolicydb;
+	struct sidtab oldsidtab, newsidtab;
+	struct convert_context_args args;
+	u32 seqno;
+	int rc = 0;
+	struct policy_file file = { data, len }, *fp = &file;
+
+	LOAD_LOCK;
+
+	if (!ss_initialized) {
+		if (policydb_read(&policydb, fp)) {
+			LOAD_UNLOCK;
+			return -EINVAL;
+		}
+		if (policydb_load_isids(&policydb, &sidtab)) {
+			LOAD_UNLOCK;
+			policydb_destroy(&policydb);
+			return -EINVAL;
+		}
+		ss_initialized = 1;
+		LOAD_UNLOCK;
+		selinux_complete_init();
+		return 0;
+	}
+
+#if 0
+	sidtab_hash_eval(&sidtab, "sids");
+#endif
+
+	if (policydb_read(&newpolicydb, fp)) {
+		LOAD_UNLOCK;
+		return -EINVAL;
+	}
+
+	sidtab_init(&newsidtab);
+
+	/* Verify that the existing classes did not change. */
+	if (hashtab_map(policydb.p_classes.table, validate_class, &newpolicydb)) {
+		printk(KERN_ERR "security:  the definition of an existing "
+		       "class changed\n");
+		rc = -EINVAL;
+		goto err;
+	}
+
+	/* Clone the SID table. */
+	sidtab_shutdown(&sidtab);
+	if (sidtab_map(&sidtab, clone_sid, &newsidtab)) {
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	/* Convert the internal representations of contexts
+	   in the new SID table and remove invalid SIDs. */
+	args.oldp = &policydb;
+	args.newp = &newpolicydb;
+	sidtab_map_remove_on_error(&newsidtab, convert_context, &args);
+
+	/* Save the old policydb and SID table to free later. */
+	memcpy(&oldpolicydb, &policydb, sizeof policydb);
+	sidtab_set(&oldsidtab, &sidtab);
+
+	/* Install the new policydb and SID table. */
+	POLICY_WRLOCK;
+	memcpy(&policydb, &newpolicydb, sizeof policydb);
+	sidtab_set(&sidtab, &newsidtab);
+	seqno = ++latest_granting;
+	POLICY_WRUNLOCK;
+	LOAD_UNLOCK;
+
+	/* Free the old policydb and SID table. */
+	policydb_destroy(&oldpolicydb);
+	sidtab_destroy(&oldsidtab);
+
+	avc_ss_reset(seqno);
+
+	return 0;
+
+err:
+	LOAD_UNLOCK;
+	sidtab_destroy(&newsidtab);
+	policydb_destroy(&newpolicydb);
+	return rc;
+
+}
+
+/**
+ * security_port_sid - Obtain the SID for a port.
+ * @domain: communication domain aka address family
+ * @type: socket type
+ * @protocol: protocol number
+ * @port: port number
+ * @out_sid: security identifier
+ */
+int security_port_sid(u16 domain,
+		      u16 type,
+		      u8 protocol,
+		      u16 port,
+		      u32 *out_sid)
+{
+	struct ocontext *c;
+	int rc = 0;
+
+	POLICY_RDLOCK;
+
+	c = policydb.ocontexts[OCON_PORT];
+	while (c) {
+		if (c->u.port.protocol == protocol &&
+		    c->u.port.low_port <= port &&
+		    c->u.port.high_port >= port)
+			break;
+		c = c->next;
+	}
+
+	if (c) {
+		if (!c->sid[0]) {
+			rc = sidtab_context_to_sid(&sidtab,
+						   &c->context[0],
+						   &c->sid[0]);
+			if (rc)
+				goto out;
+		}
+		*out_sid = c->sid[0];
+	} else {
+		*out_sid = SECINITSID_PORT;
+	}
+
+out:
+	POLICY_RDUNLOCK;
+	return rc;
+}
+
+/**
+ * security_netif_sid - Obtain the SID for a network interface.
+ * @name: interface name
+ * @if_sid: interface SID
+ * @msg_sid: default SID for received packets
+ */
+int security_netif_sid(char *name,
+		       u32 *if_sid,
+		       u32 *msg_sid)
+{
+	int rc = 0;
+	struct ocontext *c;
+
+	POLICY_RDLOCK;
+
+	c = policydb.ocontexts[OCON_NETIF];
+	while (c) {
+		if (strcmp(name, c->u.name) == 0)
+			break;
+		c = c->next;
+	}
+
+	if (c) {
+		if (!c->sid[0] || !c->sid[1]) {
+			rc = sidtab_context_to_sid(&sidtab,
+						  &c->context[0],
+						  &c->sid[0]);
+			if (rc)
+				goto out;
+			rc = sidtab_context_to_sid(&sidtab,
+						   &c->context[1],
+						   &c->sid[1]);
+			if (rc)
+				goto out;
+		}
+		*if_sid = c->sid[0];
+		*msg_sid = c->sid[1];
+	} else {
+		*if_sid = SECINITSID_NETIF;
+		*msg_sid = SECINITSID_NETMSG;
+	}
+
+out:
+	POLICY_RDUNLOCK;
+	return rc;
+}
+
+
+/**
+ * security_node_sid - Obtain the SID for a node (host).
+ * @domain: communication domain aka address family
+ * @addrp: address
+ * @addrlen: address length in bytes
+ * @out_sid: security identifier
+ */
+int security_node_sid(u16 domain,
+		      void *addrp,
+		      u32 addrlen,
+		      u32 *out_sid)
+{
+	int rc = 0;
+	u32 addr;
+	struct ocontext *c;
+
+	POLICY_RDLOCK;
+
+	if (domain != AF_INET || addrlen != sizeof(u32)) {
+		*out_sid = SECINITSID_NODE;
+		goto out;
+	}
+	addr = *((u32 *)addrp);
+
+	c = policydb.ocontexts[OCON_NODE];
+	while (c) {
+		if (c->u.node.addr == (addr & c->u.node.mask))
+			break;
+		c = c->next;
+	}
+
+	if (c) {
+		if (!c->sid[0]) {
+			rc = sidtab_context_to_sid(&sidtab,
+						   &c->context[0],
+						   &c->sid[0]);
+			if (rc)
+				goto out;
+		}
+		*out_sid = c->sid[0];
+	} else {
+		*out_sid = SECINITSID_NODE;
+	}
+
+out:
+	POLICY_RDUNLOCK;
+	return rc;
+}
+
+#define SIDS_NEL 25
+
+/**
+ * security_get_user_sids - Obtain reachable SIDs for a user.
+ * @fromsid: starting SID
+ * @username: username
+ * @sids: array of reachable SIDs for user
+ * @nel: number of elements in @sids
+ *
+ * Generate the set of SIDs for legal security contexts
+ * for a given user that can be reached by @fromsid.
+ * Set *@sids to point to a dynamically allocated
+ * array containing the set of SIDs.  Set *@nel to the
+ * number of elements in the array.
+ */
+
+int security_get_user_sids(u32 fromsid,
+	                   char *username,
+			   u32 **sids,
+			   u32 *nel)
+{
+	struct context *fromcon, usercon;
+	u32 *mysids, *mysids2, sid;
+	u32 mynel = 0, maxnel = SIDS_NEL;
+	struct user_datum *user;
+	struct role_datum *role;
+	struct av_decision avd;
+	int rc = 0, i, j;
+
+	if (!ss_initialized) {
+		*sids = NULL;
+		*nel = 0;
+		goto out;
+	}
+
+	POLICY_RDLOCK;
+
+	fromcon = sidtab_search(&sidtab, fromsid);
+	if (!fromcon) {
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+
+	user = hashtab_search(policydb.p_users.table, username);
+	if (!user) {
+		rc = -EINVAL;
+		goto out_unlock;
+	}
+	usercon.user = user->value;
+
+	mysids = kmalloc(maxnel*sizeof(*mysids), GFP_ATOMIC);
+	if (!mysids) {
+		rc = -ENOMEM;
+		goto out_unlock;
+	}
+	memset(mysids, 0, maxnel*sizeof(*mysids));
+
+	for (i = ebitmap_startbit(&user->roles); i < ebitmap_length(&user->roles); i++) {
+		if (!ebitmap_get_bit(&user->roles, i))
+			continue;
+		role = policydb.role_val_to_struct[i];
+		usercon.role = i+1;
+		for (j = ebitmap_startbit(&role->types); j < ebitmap_length(&role->types); j++) {
+			if (!ebitmap_get_bit(&role->types, j))
+				continue;
+			usercon.type = j+1;
+			if (usercon.type == fromcon->type)
+				continue;
+			mls_for_user_ranges(user,usercon) {
+				rc = context_struct_compute_av(fromcon, &usercon,
+							       SECCLASS_PROCESS,
+							       PROCESS__TRANSITION,
+							       &avd);
+				if (rc ||  !(avd.allowed & PROCESS__TRANSITION))
+					continue;
+				rc = sidtab_context_to_sid(&sidtab, &usercon, &sid);
+				if (rc) {
+					kfree(mysids);
+					goto out_unlock;
+				}
+				if (mynel < maxnel) {
+					mysids[mynel++] = sid;
+				} else {
+					maxnel += SIDS_NEL;
+					mysids2 = kmalloc(maxnel*sizeof(*mysids2), GFP_ATOMIC);
+					if (!mysids2) {
+						rc = -ENOMEM;
+						kfree(mysids);
+						goto out_unlock;
+					}
+					memset(mysids2, 0, maxnel*sizeof(*mysids2));
+					memcpy(mysids2, mysids, mynel * sizeof(*mysids2));
+					kfree(mysids);
+					mysids = mysids2;
+					mysids[mynel++] = sid;
+				}
+			}
+			mls_end_user_ranges;
+		}
+	}
+
+	*sids = mysids;
+	*nel = mynel;
+
+out_unlock:
+	POLICY_RDUNLOCK;
+out:
+	return rc;
+}
+
+/**
+ * security_genfs_sid - Obtain a SID for a file in a filesystem
+ * @fstype: filesystem type
+ * @path: path from root of mount
+ * @sclass: file security class
+ * @sid: SID for path
+ *
+ * Obtain a SID to use for a file in a filesystem that
+ * cannot support xattr or use a fixed labeling behavior like
+ * transition SIDs or task SIDs.
+ */
+int security_genfs_sid(const char *fstype,
+	               char *path,
+		       u16 sclass,
+		       u32 *sid)
+{
+	int len;
+	struct genfs *genfs;
+	struct ocontext *c;
+	int rc = 0, cmp = 0;
+
+	POLICY_RDLOCK;
+
+	for (genfs = policydb.genfs; genfs; genfs = genfs->next) {
+		cmp = strcmp(fstype, genfs->fstype);
+		if (cmp <= 0)
+			break;
+	}
+
+	if (!genfs || cmp) {
+		*sid = SECINITSID_UNLABELED;
+		rc = -ENOENT;
+		goto out;
+	}
+
+	for (c = genfs->head; c; c = c->next) {
+		len = strlen(c->u.name);
+		if ((!c->v.sclass || sclass == c->v.sclass) &&
+		    (strncmp(c->u.name, path, len) == 0))
+			break;
+	}
+
+	if (!c) {
+		*sid = SECINITSID_UNLABELED;
+		rc = -ENOENT;
+		goto out;
+	}
+
+	if (!c->sid[0]) {
+		rc = sidtab_context_to_sid(&sidtab,
+					   &c->context[0],
+					   &c->sid[0]);
+		if (rc)
+			goto out;
+	}
+
+	*sid = c->sid[0];
+out:
+	POLICY_RDUNLOCK;
+	return rc;
+}
+
+/**
+ * security_fs_use - Determine how to handle labeling for a filesystem.
+ * @fstype: filesystem type
+ * @behavior: labeling behavior
+ * @sid: SID for filesystem (superblock)
+ */
+int security_fs_use(
+	const char *fstype,
+	unsigned int *behavior,
+	u32 *sid)
+{
+	int rc = 0;
+	struct ocontext *c;
+
+	POLICY_RDLOCK;
+
+	c = policydb.ocontexts[OCON_FSUSE];
+	while (c) {
+		if (strcmp(fstype, c->u.name) == 0)
+			break;
+		c = c->next;
+	}
+
+	if (c) {
+		*behavior = c->v.behavior;
+		if (!c->sid[0]) {
+			rc = sidtab_context_to_sid(&sidtab,
+						   &c->context[0],
+						   &c->sid[0]);
+			if (rc)
+				goto out;
+		}
+		*sid = c->sid[0];
+	} else {
+		rc = security_genfs_sid(fstype, "/", SECCLASS_DIR, sid);
+		if (rc) {
+			*behavior = SECURITY_FS_USE_NONE;
+			rc = 0;
+		} else {
+			*behavior = SECURITY_FS_USE_GENFS;
+		}
+	}
+
+out:
+	POLICY_RDUNLOCK;
+	return rc;
+}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/services.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/services.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/services.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/services.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,21 @@
+/*
+ * Implementation of the security services.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_SERVICES_H_
+#define _SS_SERVICES_H_
+
+#include "policydb.h"
+#include "sidtab.h"
+
+/*
+ * The security server uses two global data structures
+ * when providing its services:  the SID table (sidtab)
+ * and the policy database (policydb).
+ */
+extern struct sidtab sidtab;
+extern struct policydb policydb;
+
+#endif	/* _SS_SERVICES_H_ */
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/sidtab.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/sidtab.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/sidtab.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/sidtab.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,335 @@
+/*
+ * Implementation of the SID table type.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include "flask.h"
+#include "security.h"
+#include "sidtab.h"
+
+#define SIDTAB_HASH(sid) \
+(sid & SIDTAB_HASH_MASK)
+
+#define INIT_SIDTAB_LOCK(s) spin_lock_init(&s->lock)
+#define SIDTAB_LOCK(s) spin_lock_irq(&s->lock)
+#define SIDTAB_UNLOCK(s) spin_unlock_irq(&s->lock)
+
+int sidtab_init(struct sidtab *s)
+{
+	int i;
+
+	s->htable = kmalloc(sizeof(*(s->htable)) * SIDTAB_SIZE, GFP_ATOMIC);
+	if (!s->htable)
+		return -ENOMEM;
+	for (i = 0; i < SIDTAB_SIZE; i++)
+		s->htable[i] = NULL;
+	s->nel = 0;
+	s->next_sid = 1;
+	s->shutdown = 0;
+	INIT_SIDTAB_LOCK(s);
+	return 0;
+}
+
+int sidtab_insert(struct sidtab *s, u32 sid, struct context *context)
+{
+	int hvalue, rc = 0;
+	struct sidtab_node *prev, *cur, *newnode;
+
+	if (!s) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	hvalue = SIDTAB_HASH(sid);
+	prev = NULL;
+	cur = s->htable[hvalue];
+	while (cur != NULL && sid > cur->sid) {
+		prev = cur;
+		cur = cur->next;
+	}
+
+	if (cur && sid == cur->sid) {
+		rc = -EEXIST;
+		goto out;
+	}
+
+	newnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);
+	if (newnode == NULL) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	newnode->sid = sid;
+	if (context_cpy(&newnode->context, context)) {
+		kfree(newnode);
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	if (prev) {
+		newnode->next = prev->next;
+		wmb();
+		prev->next = newnode;
+	} else {
+		newnode->next = s->htable[hvalue];
+		wmb();
+		s->htable[hvalue] = newnode;
+	}
+
+	s->nel++;
+	if (sid >= s->next_sid)
+		s->next_sid = sid + 1;
+out:
+	return rc;
+}
+
+int sidtab_remove(struct sidtab *s, u32 sid)
+{
+	int hvalue, rc = 0;
+	struct sidtab_node *cur, *last;
+
+	if (!s) {
+		rc = -ENOENT;
+		goto out;
+	}
+
+	hvalue = SIDTAB_HASH(sid);
+	last = NULL;
+	cur = s->htable[hvalue];
+	while (cur != NULL && sid > cur->sid) {
+		last = cur;
+		cur = cur->next;
+	}
+
+	if (cur == NULL || sid != cur->sid) {
+		rc = -ENOENT;
+		goto out;
+	}
+
+	if (last == NULL)
+		s->htable[hvalue] = cur->next;
+	else
+		last->next = cur->next;
+
+	context_destroy(&cur->context);
+
+	kfree(cur);
+	s->nel--;
+out:
+	return rc;
+}
+
+struct context *sidtab_search(struct sidtab *s, u32 sid)
+{
+	int hvalue;
+	struct sidtab_node *cur;
+
+	if (!s)
+		return NULL;
+
+	hvalue = SIDTAB_HASH(sid);
+	cur = s->htable[hvalue];
+	while (cur != NULL && sid > cur->sid)
+		cur = cur->next;
+
+	if (cur == NULL || sid != cur->sid) {
+		/* Remap invalid SIDs to the unlabeled SID. */
+		sid = SECINITSID_UNLABELED;
+		hvalue = SIDTAB_HASH(sid);
+		cur = s->htable[hvalue];
+		while (cur != NULL && sid > cur->sid)
+			cur = cur->next;
+		if (!cur || sid != cur->sid)
+			return NULL;
+	}
+
+	return &cur->context;
+}
+
+int sidtab_map(struct sidtab *s,
+	       int (*apply) (u32 sid,
+			     struct context *context,
+			     void *args),
+	       void *args)
+{
+	int i, rc = 0;
+	struct sidtab_node *cur;
+
+	if (!s)
+		goto out;
+
+	for (i = 0; i < SIDTAB_SIZE; i++) {
+		cur = s->htable[i];
+		while (cur != NULL) {
+			rc = apply(cur->sid, &cur->context, args);
+			if (rc)
+				goto out;
+			cur = cur->next;
+		}
+	}
+out:
+	return rc;
+}
+
+void sidtab_map_remove_on_error(struct sidtab *s,
+				int (*apply) (u32 sid,
+					      struct context *context,
+					      void *args),
+				void *args)
+{
+	int i, ret;
+	struct sidtab_node *last, *cur, *temp;
+
+	if (!s)
+		return;
+
+	for (i = 0; i < SIDTAB_SIZE; i++) {
+		last = NULL;
+		cur = s->htable[i];
+		while (cur != NULL) {
+			ret = apply(cur->sid, &cur->context, args);
+			if (ret) {
+				if (last) {
+					last->next = cur->next;
+				} else {
+					s->htable[i] = cur->next;
+				}
+
+				temp = cur;
+				cur = cur->next;
+				context_destroy(&temp->context);
+				kfree(temp);
+				s->nel--;
+			} else {
+				last = cur;
+				cur = cur->next;
+			}
+		}
+	}
+
+	return;
+}
+
+static inline u32 sidtab_search_context(struct sidtab *s,
+						  struct context *context)
+{
+	int i;
+	struct sidtab_node *cur;
+
+	for (i = 0; i < SIDTAB_SIZE; i++) {
+		cur = s->htable[i];
+		while (cur != NULL) {
+			if (context_cmp(&cur->context, context))
+				return cur->sid;
+			cur = cur->next;
+		}
+	}
+	return 0;
+}
+
+int sidtab_context_to_sid(struct sidtab *s,
+			  struct context *context,
+			  u32 *out_sid)
+{
+	u32 sid;
+	int ret = 0;
+
+	*out_sid = SECSID_NULL;
+
+	sid = sidtab_search_context(s, context);
+	if (!sid) {
+		SIDTAB_LOCK(s);
+		/* Rescan now that we hold the lock. */
+		sid = sidtab_search_context(s, context);
+		if (sid)
+			goto unlock_out;
+		/* No SID exists for the context.  Allocate a new one. */
+		if (s->next_sid == UINT_MAX || s->shutdown) {
+			ret = -ENOMEM;
+			goto unlock_out;
+		}
+		sid = s->next_sid++;
+		ret = sidtab_insert(s, sid, context);
+		if (ret)
+			s->next_sid--;
+unlock_out:
+		SIDTAB_UNLOCK(s);
+	}
+
+	if (ret)
+		return ret;
+
+	*out_sid = sid;
+	return 0;
+}
+
+void sidtab_hash_eval(struct sidtab *h, char *tag)
+{
+	int i, chain_len, slots_used, max_chain_len;
+	struct sidtab_node *cur;
+
+	slots_used = 0;
+	max_chain_len = 0;
+	for (i = 0; i < SIDTAB_SIZE; i++) {
+		cur = h->htable[i];
+		if (cur) {
+			slots_used++;
+			chain_len = 0;
+			while (cur) {
+				chain_len++;
+				cur = cur->next;
+			}
+
+			if (chain_len > max_chain_len)
+				max_chain_len = chain_len;
+		}
+	}
+
+	printk(KERN_INFO "%s:  %d entries and %d/%d buckets used, longest "
+	       "chain length %d\n", tag, h->nel, slots_used, SIDTAB_SIZE,
+	       max_chain_len);
+}
+
+void sidtab_destroy(struct sidtab *s)
+{
+	int i;
+	struct sidtab_node *cur, *temp;
+
+	if (!s)
+		return;
+
+	for (i = 0; i < SIDTAB_SIZE; i++) {
+		cur = s->htable[i];
+		while (cur != NULL) {
+			temp = cur;
+			cur = cur->next;
+			context_destroy(&temp->context);
+			kfree(temp);
+		}
+		s->htable[i] = NULL;
+	}
+	kfree(s->htable);
+	s->htable = NULL;
+	s->nel = 0;
+	s->next_sid = 1;
+}
+
+void sidtab_set(struct sidtab *dst, struct sidtab *src)
+{
+	SIDTAB_LOCK(src);
+	dst->htable = src->htable;
+	dst->nel = src->nel;
+	dst->next_sid = src->next_sid;
+	dst->shutdown = 0;
+	SIDTAB_UNLOCK(src);
+}
+
+void sidtab_shutdown(struct sidtab *s)
+{
+	SIDTAB_LOCK(s);
+	s->shutdown = 1;
+	SIDTAB_UNLOCK(s);
+}
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/sidtab.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/sidtab.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/sidtab.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/sidtab.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ * A security identifier table (sidtab) is a hash table
+ * of security context structures indexed by SID value.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_SIDTAB_H_
+#define _SS_SIDTAB_H_
+
+#include "context.h"
+
+struct sidtab_node {
+	u32 sid;		/* security identifier */
+	struct context context;	/* security context structure */
+	struct sidtab_node *next;
+};
+
+#define SIDTAB_HASH_BITS 7
+#define SIDTAB_HASH_BUCKETS (1 << SIDTAB_HASH_BITS)
+#define SIDTAB_HASH_MASK (SIDTAB_HASH_BUCKETS-1)
+
+#define SIDTAB_SIZE SIDTAB_HASH_BUCKETS
+
+struct sidtab {
+	struct sidtab_node **htable;
+	unsigned int nel;	/* number of elements */
+	unsigned int next_sid;	/* next SID to allocate */
+	unsigned char shutdown;
+	spinlock_t lock;
+};
+
+int sidtab_init(struct sidtab *s);
+int sidtab_insert(struct sidtab *s, u32 sid, struct context *context);
+struct context *sidtab_search(struct sidtab *s, u32 sid);
+
+int sidtab_map(struct sidtab *s,
+	       int (*apply) (u32 sid,
+			     struct context *context,
+			     void *args),
+	       void *args);
+
+void sidtab_map_remove_on_error(struct sidtab *s,
+				int (*apply) (u32 sid,
+					      struct context *context,
+					      void *args),
+				void *args);
+
+int sidtab_context_to_sid(struct sidtab *s,
+			  struct context *context,
+			  u32 *sid);
+
+void sidtab_hash_eval(struct sidtab *h, char *tag);
+void sidtab_destroy(struct sidtab *s);
+void sidtab_set(struct sidtab *dst, struct sidtab *src);
+void sidtab_shutdown(struct sidtab *s);
+
+#endif	/* _SS_SIDTAB_H_ */
+
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/symtab.c 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/symtab.c
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/symtab.c	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/symtab.c	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ * Implementation of the symbol table type.
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include "symtab.h"
+
+static unsigned int symhash(struct hashtab *h, void *key)
+{
+	char *p, *keyp;
+	unsigned int size;
+	unsigned int val;
+
+	val = 0;
+	keyp = key;
+	size = strlen(keyp);
+	for (p = keyp; (p - keyp) < size; p++)
+		val = (val << 4 | (val >> (8*sizeof(unsigned int)-4))) ^ (*p);
+	return val & (h->size - 1);
+}
+
+static int symcmp(struct hashtab *h, void *key1, void *key2)
+{
+	char *keyp1, *keyp2;
+
+	keyp1 = key1;
+	keyp2 = key2;
+	return strcmp(keyp1, keyp2);
+}
+
+
+int symtab_init(struct symtab *s, unsigned int size)
+{
+	s->table = hashtab_create(symhash, symcmp, size);
+	if (!s->table)
+		return -1;
+	s->nprim = 0;
+	return 0;
+}
+
diff -Nurp -X /Devel/dontdiff 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/symtab.h 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/symtab.h
--- 2425sls2.ea.acl.nfsacl.sec/security/selinux/ss/symtab.h	1970-01-01 02:00:00.000000000 +0200
+++ 2425sls2.ea.acl.nfsacl.sec.selinux/security/selinux/ss/symtab.h	2004-03-02 23:41:24.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ * A symbol table (symtab) maintains associations between symbol
+ * strings and datum values.  The type of the datum values
+ * is arbitrary.  The symbol table type is implemented
+ * using the hash table type (hashtab).
+ *
+ * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
+ */
+#ifndef _SS_SYMTAB_H_
+#define _SS_SYMTAB_H_
+
+#include "hashtab.h"
+
+struct symtab {
+	struct hashtab *table;	/* hash table (keyed on a string) */
+	u32 nprim;		/* number of primary names in table */
+};
+
+int symtab_init(struct symtab *s, unsigned int size);
+
+#endif	/* _SS_SYMTAB_H_ */
+
+
