--- dietlibc-0.22/librpc/clnt_tcp.c.rpc64	2002-02-25 15:50:06.000000000 +0100
+++ dietlibc-0.22/librpc/clnt_tcp.c	2003-08-19 10:59:11.000000000 +0200
@@ -160,6 +160,7 @@ unsigned int recvsz;
 						sizeof(*raddr)) < 0)) {
 			rpc_createerr.cf_stat = RPC_SYSTEMERROR;
 			rpc_createerr.cf_error.re_errno = errno;
+			if (*sockp >= 0)
 			(void) close(*sockp);
 			goto fooy;
 		}
@@ -236,7 +237,7 @@ struct timeval timeout;
 	register XDR *xdrs = &(ct->ct_xdrs);
 	struct rpc_msg reply_msg;
 	unsigned long x_id;
-	unsigned long *msg_x_id = (unsigned long *) (ct->ct_mcall);	/* yuk */
+	uint32_t *msg_x_id = (uint32_t *) (ct->ct_mcall);	/* yuk */
 	register bool_t shipnow;
 	int refreshes = 2;
 
@@ -289,7 +290,7 @@ struct timeval timeout;
 				continue;
 			return (ct->ct_error.re_status);
 		}
-		if (reply_msg.rm_xid == x_id)
+		if ((uint32_t)reply_msg.rm_xid == (uint32_t)x_id)
 			break;
 	}
 
--- dietlibc-0.22/librpc/clnt_udp.c.rpc64	2002-02-25 15:50:06.000000000 +0100
+++ dietlibc-0.22/librpc/clnt_udp.c	2003-08-19 10:59:11.000000000 +0200
@@ -250,7 +250,7 @@ struct timeval utimeout;		/* seconds to 
 	/*
 	 * the transaction is the first thing in the out buffer
 	 */
-	(*(unsigned short *) (cu->cu_outbuf))++;
+	(*(uint32_t *) (cu->cu_outbuf))++;
 	if ((!XDR_PUTLONG(xdrs, (long *) &proc)) ||
 		(!AUTH_MARSHALL(cl->cl_auth, xdrs)) || (!(*xargs) (xdrs, argsp)))
 		return (cu->cu_error.re_status = RPC_CANTENCODEARGS);
@@ -324,10 +324,10 @@ struct timeval utimeout;		/* seconds to 
 			cu->cu_error.re_errno = errno;
 			return (cu->cu_error.re_status = RPC_CANTRECV);
 		}
-		if (inlen < sizeof(unsigned long))
+		if (inlen < 4)
 			continue;
 		/* see if reply transaction id matches sent id */
-		if (*((unsigned long *) (cu->cu_inbuf)) != *((unsigned long *) (cu->cu_outbuf)))
+		if (*((uint32_t *) (cu->cu_inbuf)) != *((uint32_t *) (cu->cu_outbuf)))
 			continue;
 		/* we now assume we have the proper reply */
 		break;
--- dietlibc-0.22/librpc/xdr.c.rpc64	2001-06-15 18:14:51.000000000 +0200
+++ dietlibc-0.22/librpc/xdr.c	2003-08-19 10:59:11.000000000 +0200
@@ -87,17 +87,25 @@ bool_t xdr_void( /* xdrs, addr */ )
  */
 bool_t xdr_int(XDR* xdrs, int* ip)
 {
-
-#ifdef lint
-	(void) (xdr_short(xdrs, (short *) ip));
-	return (xdr_long(xdrs, (long *) ip));
-#else
 	if (sizeof(int) == sizeof(long)) {
 		return (xdr_long(xdrs, (long *) ip));
+	} else if (sizeof(int) < sizeof(long)) {
+	  long l;
+	  switch (xdrs->x_op) {
+	  case XDR_ENCODE:
+		l = (long) *ip;
+		return XDR_PUTLONG(xdrs, &l);
+	  case XDR_DECODE:
+		if (!XDR_GETLONG(xdrs, &l))
+		  return FALSE;
+		*ip = (int) l;
+	  case XDR_FREE:
+		return TRUE;
+	  }
+	  return FALSE;
 	} else {
 		return (xdr_short(xdrs, (short *) ip));
 	}
-#endif
 }
 
 /*
@@ -105,17 +113,25 @@ bool_t xdr_int(XDR* xdrs, int* ip)
  */
 bool_t xdr_u_int(XDR* xdrs, unsigned int* up)
 {
-
-#ifdef lint
-	(void) (xdr_short(xdrs, (short *) up));
-	return (xdr_u_long(xdrs, (unsigned long *) up));
-#else
 	if (sizeof(unsigned int) == sizeof(unsigned long)) {
 		return (xdr_u_long(xdrs, (unsigned long *) up));
+	} else if (sizeof(unsigned int) < sizeof(unsigned long)) {
+	  unsigned long l;
+	  switch (xdrs->x_op) {
+	  case XDR_ENCODE:
+		l = (unsigned long) *up;
+		return XDR_PUTLONG(xdrs, &l);
+	  case XDR_DECODE:
+		if (!XDR_GETLONG(xdrs, &l))
+		  return FALSE;
+		*up = (unsigned int) l;
+	  case XDR_FREE:
+		return TRUE;
+	  }
+	  return FALSE;
 	} else {
 		return (xdr_short(xdrs, (short *) up));
 	}
-#endif
 }
 
 /*
@@ -125,7 +141,9 @@ bool_t xdr_u_int(XDR* xdrs, unsigned int
 bool_t xdr_long(XDR* xdrs, long* lp)
 {
 
-	if (xdrs->x_op == XDR_ENCODE)
+	if (xdrs->x_op == XDR_ENCODE
+		&& (sizeof(int32_t) == sizeof(long)
+			|| (int32_t) *lp == *lp))
 		return (XDR_PUTLONG(xdrs, lp));
 
 	if (xdrs->x_op == XDR_DECODE)
@@ -144,12 +162,25 @@ bool_t xdr_long(XDR* xdrs, long* lp)
 bool_t xdr_u_long(XDR* xdrs, unsigned long* ulp)
 {
 
-	if (xdrs->x_op == XDR_DECODE)
-		return (XDR_GETLONG(xdrs, (long *) ulp));
-	if (xdrs->x_op == XDR_ENCODE)
+  if (xdrs->x_op == XDR_DECODE) {
+	long l;
+	if (XDR_GETLONG(xdrs, &l) == FALSE)
+	  return FALSE;
+	*ulp = (uint32_t) l;
+	return TRUE;
+  }
+
+  if (xdrs->x_op == XDR_ENCODE) {
+	if (sizeof(uint32_t) != sizeof(unsigned long)
+		&& (uint32_t) *ulp != *ulp)
+	  return FALSE;
+
 		return (XDR_PUTLONG(xdrs, (long *) ulp));
+  }
+
 	if (xdrs->x_op == XDR_FREE)
 		return (TRUE);
+
 	return (FALSE);
 }
 
@@ -271,7 +302,6 @@ bool_t xdr_enum(xdrs, ep)
 XDR *xdrs;
 enum_t *ep;
 {
-#ifndef lint
 	enum sizecheck { SIZEVAL };	/* used to find the size of an enum */
 
 	/*
@@ -279,15 +309,25 @@ enum_t *ep;
 	 */
 	if (sizeof(enum sizecheck) == sizeof(long)) {
 		return (xdr_long(xdrs, (long *) ep));
+	} else if (sizeof(enum sizecheck) == sizeof(int)) {
+	  long l;
+	  switch (xdrs->x_op) {
+	  case XDR_ENCODE:
+		l = *ep;
+		return XDR_PUTLONG(xdrs, &l);
+	  case XDR_DECODE:
+		if (!XDR_GETLONG(xdrs, &l))
+		  return FALSE;
+		*ep = l;
+	  case XDR_FREE:
+		return TRUE;
+	  }
+	  return FALSE;
 	} else if (sizeof(enum sizecheck) == sizeof(short)) {
 		return (xdr_short(xdrs, (short *) ep));
 	} else {
 		return (FALSE);
 	}
-#else
-	(void) (xdr_short(xdrs, (short *) ep));
-	return (xdr_long(xdrs, (long *) ep));
-#endif
 }
 
 /*
--- dietlibc-0.22/librpc/xdr_mem.c.rpc64	2003-08-19 09:21:12.000000000 +0200
+++ dietlibc-0.22/librpc/xdr_mem.c	2003-08-19 10:59:11.000000000 +0200
@@ -42,20 +42,20 @@ static char sccsid[] = "@(#)xdr_mem.c 1.
  *
  */
 
-
 #include <rpc/types.h>
 #include <rpc/xdr.h>
 #include <netinet/in.h>
 #include <string.h>
+#include <limits.h>
 
-static bool_t xdrmem_getlong(XDR*, long*);
-static bool_t xdrmem_putlong(XDR*, const long*);
-static bool_t xdrmem_getbytes();
-static bool_t xdrmem_putbytes();
-static unsigned int xdrmem_getpos();
-static bool_t xdrmem_setpos();
-static int32_t *xdrmem_inline(XDR*, unsigned int);
-static void xdrmem_destroy();
+static bool_t xdrmem_getlong (XDR *, long *);
+static bool_t xdrmem_putlong (XDR *, const long *);
+static bool_t xdrmem_getbytes (XDR *, char *, unsigned int);
+static bool_t xdrmem_putbytes (XDR *, const char *, unsigned int);
+static unsigned int xdrmem_getpos (const XDR *);
+static bool_t xdrmem_setpos (XDR *, unsigned int);
+static int32_t *xdrmem_inline (XDR *, unsigned int);
+static void xdrmem_destroy (XDR *);
 
 static struct xdr_ops xdrmem_ops = {
 	xdrmem_getlong,
@@ -73,27 +73,22 @@ static struct xdr_ops xdrmem_ops = {
  * The procedure xdrmem_create initializes a stream descriptor for a
  * memory buffer.  
  */
-void xdrmem_create(xdrs, addr, size, op)
-register XDR *xdrs;
-const char* addr;
-unsigned int size;
-enum xdr_op op;
+void
+xdrmem_create (XDR *xdrs, const char* addr, unsigned int size, enum xdr_op op)
 {
-
 	xdrs->x_op = op;
 	xdrs->x_ops = &xdrmem_ops;
 	xdrs->x_private = xdrs->x_base = (char*)addr;
 	xdrs->x_handy = size;
 }
 
-static void xdrmem_destroy( /*xdrs */ )
-	/*XDR *xdrs; */
+static void
+xdrmem_destroy (XDR *xdrs)
 {
 }
 
-static bool_t xdrmem_getlong(xdrs, lp)
-register XDR *xdrs;
-long *lp;
+static bool_t
+xdrmem_getlong (XDR *xdrs, long *lp)
 {
   if (xdrs->x_handy < 4) return FALSE;
   xdrs->x_handy -= 4;
@@ -103,18 +98,19 @@ long *lp;
   return TRUE;
 }
 
-static bool_t xdrmem_putlong(XDR* xdrs, const long* lp)
+static bool_t
+xdrmem_putlong (XDR *xdrs, const long *lp)
 {
   if (xdrs->x_handy < 4) return FALSE;
   xdrs->x_handy -= 4;
 
   *(int32_t *) xdrs->x_private = htonl(*lp);
-  xdrs->x_private += sizeof(long);
-
+  xdrs->x_private += 4;
   return (TRUE);
 }
 
-static bool_t xdrmem_getbytes(XDR* xdrs, char* addr, unsigned int len)
+static bool_t
+xdrmem_getbytes (XDR *xdrs, char *addr, unsigned int len)
 {
   if (xdrs->x_handy < len) return FALSE;
   xdrs->x_handy -= len;
@@ -123,7 +119,8 @@ static bool_t xdrmem_getbytes(XDR* xdrs,
   return TRUE;
 }
 
-static bool_t xdrmem_putbytes(XDR* xdrs, char* addr, unsigned int len)
+static bool_t
+xdrmem_putbytes (XDR *xdrs, const char *addr, unsigned int len)
 {
   if (xdrs->x_handy < len) return FALSE;
   xdrs->x_handy -= len;
@@ -132,11 +129,10 @@ static bool_t xdrmem_putbytes(XDR* xdrs,
   return (TRUE);
 }
 
-static unsigned int xdrmem_getpos(xdrs)
-register XDR *xdrs;
+static unsigned int
+xdrmem_getpos (const XDR *xdrs)
 {
-
-	return ((unsigned int) xdrs->x_private - (unsigned int) xdrs->x_base);
+	return ((unsigned long) xdrs->x_private - (unsigned long) xdrs->x_base);
 }
 
 static bool_t xdrmem_setpos(xdrs, pos)
@@ -146,16 +142,17 @@ unsigned int pos;
   register char* newaddr = xdrs->x_base + pos;
   register char* lastaddr = xdrs->x_private + xdrs->x_handy;
 
-  if ((long) newaddr > (long) lastaddr || (long)newaddr<(long)xdrs->x_base)
+  if ((long) newaddr > (long) lastaddr
+	  || (UINT_MAX < LONG_MAX
+		  && (long) UINT_MAX < (long) lastaddr - (long) newaddr))
 	  return (FALSE);
   xdrs->x_private = newaddr;
-  xdrs->x_handy = (int) lastaddr - (int) newaddr;
+  xdrs->x_handy = (long) lastaddr - (long) newaddr;
   return (TRUE);
 }
 
-static int32_t *xdrmem_inline(xdrs, len)
-register XDR *xdrs;
-unsigned int len;
+static int32_t *
+xdrmem_inline (XDR *xdrs, unsigned int len)
 {
 	int32_t *buf = 0;
 
--- dietlibc-0.22/librpc/xdr_rec.c.rpc64	2003-08-19 09:21:12.000000000 +0200
+++ dietlibc-0.22/librpc/xdr_rec.c	2003-08-19 10:59:11.000000000 +0200
@@ -53,19 +53,18 @@ static char sccsid[] = "@(#)xdr_rec.c 1.
 #include <rpc/xdr.h>
 #include <netinet/in.h>
 #include <string.h>
+#include <unistd.h>
 
-extern long lseek();
+static unsigned int fix_buf_size (unsigned int);
 
-static unsigned int fix_buf_size();
-
-static bool_t xdrrec_getlong();
-static bool_t xdrrec_putlong();
-static bool_t xdrrec_getbytes();
-static bool_t xdrrec_putbytes();
-static unsigned int xdrrec_getpos();
-static bool_t xdrrec_setpos();
-static int32_t *xdrrec_inline();
-static void xdrrec_destroy();
+static bool_t xdrrec_getlong (XDR *, long *);
+static bool_t xdrrec_putlong (XDR *, const long *);
+static bool_t xdrrec_getbytes (XDR *, char *, unsigned int);
+static bool_t xdrrec_putbytes (XDR *, const char *, unsigned int);
+static unsigned int xdrrec_getpos (const XDR *);
+static bool_t xdrrec_setpos (XDR *, unsigned int);
+static int32_t *xdrrec_inline (XDR *, unsigned int);
+static void xdrrec_destroy (XDR *);
 
 static struct xdr_ops xdrrec_ops = {
 	xdrrec_getlong,
@@ -100,16 +99,16 @@ typedef struct rec_strm {
 	/*
 	 * out-goung bits
 	 */
-	int (*writeit) ();
+    int (*writeit) (char *, char *, int);
 	char* out_base;			/* output buffer (points to frag header) */
 	char* out_finger;			/* next output position */
 	char* out_boundry;		/* data cannot up to this address */
-	unsigned long *frag_header;		/* beginning of curren fragment */
+	uint32_t *frag_header;		/* beginning of curren fragment */
 	bool_t frag_sent;			/* true if buffer sent in middle of record */
 	/*
 	 * in-coming bits
 	 */
-	int (*readit) ();
+    int (*readit) (char *, char *, int);
 	unsigned long in_size;				/* fixed size of the input buffer */
 	char* in_base;
 	char* in_finger;			/* location of next byte to be had */
@@ -130,13 +129,11 @@ typedef struct rec_strm {
  * write respectively.   They are like the system
  * calls expect that they take an opaque handle rather than an fd.
  */
-void xdrrec_create(xdrs, sendsize, recvsize, tcp_handle, readit, writeit)
-register XDR *xdrs;
-register unsigned int sendsize;
-register unsigned int recvsize;
-char* tcp_handle;
-int (*readit) ();				/* like read, but pass it a tcp_handle, not sock */
-int (*writeit) ();				/* like write, but pass it a tcp_handle, not sock */
+void
+xdrrec_create (XDR *xdrs, unsigned int sendsize,
+	       unsigned int recvsize, char *tcp_handle,
+	       int (*readit) (char *, char *, int),
+	       int (*writeit) (char *, char *, int))
 {
 	register RECSTREAM *rstrm = (RECSTREAM *) mem_alloc(sizeof(RECSTREAM));
 
@@ -172,8 +169,8 @@ int (*writeit) ();				/* like write, but
 	rstrm->readit = readit;
 	rstrm->writeit = writeit;
 	rstrm->out_finger = rstrm->out_boundry = rstrm->out_base;
-	rstrm->frag_header = (unsigned long *) rstrm->out_base;
-	rstrm->out_finger += sizeof(unsigned long);
+	rstrm->frag_header = (uint32_t *) rstrm->out_base;
+	rstrm->out_finger += 4;
 	rstrm->out_boundry += sendsize;
 	rstrm->frag_sent = FALSE;
 	rstrm->in_size = recvsize;
@@ -189,25 +186,24 @@ int (*writeit) ();				/* like write, but
  * xdr handle filled in by xdrrec_create.
  */
 
-static bool_t xdrrec_getlong(xdrs, lp)
-XDR *xdrs;
-long *lp;
+static bool_t
+xdrrec_getlong (XDR *xdrs, long *lp)
 {
 	register RECSTREAM *rstrm = (RECSTREAM *) (xdrs->x_private);
-	register long *buflp = (long *) (rstrm->in_finger);
-	long mylong;
+	register int32_t *buflp = (int32_t *) (rstrm->in_finger);
+	int32_t mylong;
 
 	/* first try the inline, fast case */
-	if ((rstrm->fbtbc >= sizeof(long)) &&
-		(((long) rstrm->in_boundry - (long) buflp) >= sizeof(long))) {
-		*lp = (long) ntohl((unsigned long) (*buflp));
-		rstrm->fbtbc -= sizeof(long);
-		rstrm->in_finger += sizeof(long);
+	if ((rstrm->fbtbc >= BYTES_PER_XDR_UNIT) &&
+		((rstrm->in_boundry - (char *) buflp) >= BYTES_PER_XDR_UNIT)) {
+		*lp = (int32_t) ntohl(*buflp);
+		rstrm->fbtbc -= BYTES_PER_XDR_UNIT;
+		rstrm->in_finger += BYTES_PER_XDR_UNIT;
 	} else {
-		if (!xdrrec_getbytes(xdrs, (char*) & mylong, sizeof(long)))
+		if (!xdrrec_getbytes(xdrs, (char*) & mylong, BYTES_PER_XDR_UNIT))
 			return (FALSE);
 
-		*lp = (long) ntohl((unsigned long) mylong);
+		*lp = (int32_t) ntohl(mylong);
 	}
 	return (TRUE);
 }
@@ -218,16 +214,17 @@ long *lp;
 static bool_t flush_out(RECSTREAM* rstrm, bool_t eor)
 {
 	register unsigned long eormask = (eor == TRUE) ? LAST_FRAG : 0;
-	register unsigned long len = (unsigned long) (rstrm->out_finger) -
-		(unsigned long) (rstrm->frag_header) - sizeof(unsigned long);
+	register unsigned long len = (rstrm->out_finger
+								  - (char *) rstrm->frag_header
+								  - BYTES_PER_XDR_UNIT);
 
 	*(rstrm->frag_header) = htonl(len | eormask);
-	len = (unsigned long) (rstrm->out_finger) - (unsigned long) (rstrm->out_base);
+	len = rstrm->out_finger - rstrm->out_base;
 	if ((*(rstrm->writeit)) (rstrm->tcp_handle, rstrm->out_base, (int) len)
 		!= (int) len)
 		return (FALSE);
-	rstrm->frag_header = (unsigned long *) rstrm->out_base;
-	rstrm->out_finger = (char*) rstrm->out_base + sizeof(unsigned long);
+	rstrm->frag_header = (uint32_t *) rstrm->out_base;
+	rstrm->out_finger = (char*) rstrm->out_base + BYTES_PER_XDR_UNIT;
 	return (TRUE);
 }
 
@@ -262,7 +259,7 @@ register int len;
 	register int current;
 
 	while (len > 0) {
-		current = (long) rstrm->in_boundry - (long) rstrm->in_finger;
+		current = rstrm->in_boundry - rstrm->in_finger;
 		if (current == 0) {
 			if (!fill_input_buf(rstrm))
 				return (FALSE);
@@ -282,12 +279,24 @@ static bool_t
 set_input_fragment(rstrm)
 register RECSTREAM *rstrm;
 {
-	unsigned long header;
+	uint32_t header;
 
 	if (!get_input_bytes(rstrm, (char*) & header, sizeof(header)))
 		return (FALSE);
-	header = (long) ntohl(header);
+	header = ntohl(header);
 	rstrm->last_frag = ((header & LAST_FRAG) == 0) ? FALSE : TRUE;
+	/*
+	 * Sanity check. Try not to accept wildly incorrect fragment
+	 * sizes. Unfortunately, only a size of zero can be identified as
+	 * 'wildely incorrect', and this only, if it is not the last
+	 * fragment of a message. Ridiculously large fragment sizes may look
+	 * wrong, but we don't have any way to be certain that they aren't
+	 * what the client actually intended to send us. Many existing RPC
+	 * implementations may sent a fragment of size zero as the last
+	 * fragment of a message.
+	 */
+	if (header == 0)
+	  return FALSE;
 	rstrm->fbtbc = header & (~LAST_FRAG);
 	return (TRUE);
 }
@@ -301,7 +310,7 @@ long cnt;
 	register int current;
 
 	while (cnt > 0) {
-		current = (long) rstrm->in_boundry - (long) rstrm->in_finger;
+		current = rstrm->in_boundry - rstrm->in_finger;
 		if (current == 0) {
 			if (!fill_input_buf(rstrm))
 				return (FALSE);
@@ -314,47 +323,43 @@ long cnt;
 	return (TRUE);
 }
 
-static unsigned int fix_buf_size(s)
-register unsigned int s;
+static unsigned int
+fix_buf_size (unsigned int s)
 {
 
 	if (s < 100)
 		s = 4000;
 	return (RNDUP(s));
 }
-static bool_t xdrrec_putlong(xdrs, lp)
-XDR *xdrs;
-long *lp;
+
+static bool_t
+xdrrec_putlong (XDR *xdrs, const long *lp)
 {
 	register RECSTREAM *rstrm = (RECSTREAM *) (xdrs->x_private);
-	register long *dest_lp = ((long *) (rstrm->out_finger));
+	register int32_t *dest_lp = (int32_t *) rstrm->out_finger;
 
-	if ((rstrm->out_finger += sizeof(long)) > rstrm->out_boundry) {
+	if ((rstrm->out_finger += BYTES_PER_XDR_UNIT) > rstrm->out_boundry) {
 		/*
 		 * this case should almost never happen so the code is
 		 * inefficient
 		 */
-		rstrm->out_finger -= sizeof(long);
+		rstrm->out_finger -= BYTES_PER_XDR_UNIT;
 
 		rstrm->frag_sent = TRUE;
 		if (!flush_out(rstrm, FALSE))
 			return (FALSE);
-		dest_lp = ((long *) (rstrm->out_finger));
-		rstrm->out_finger += sizeof(long);
+		dest_lp = ((int32_t *) (rstrm->out_finger));
+		rstrm->out_finger += BYTES_PER_XDR_UNIT;
 	}
-	*dest_lp = (long) htonl((unsigned long) (*lp));
+	*dest_lp = htonl(*lp);
 	return (TRUE);
 }
 
-static bool_t
-/* must manage buffers, fragments, and records */
-xdrrec_getbytes(xdrs, addr, len)
-XDR *xdrs;
-register char* addr;
-register unsigned int len;
+static bool_t	   /* must manage buffers, fragments, and records */
+xdrrec_getbytes (XDR *xdrs, char *addr, unsigned int len)
 {
 	register RECSTREAM *rstrm = (RECSTREAM *) (xdrs->x_private);
-	register int current;
+	register unsigned int current;
 
 	while (len > 0) {
 		current = rstrm->fbtbc;
@@ -375,16 +380,14 @@ register unsigned int len;
 	return (TRUE);
 }
 
-static bool_t xdrrec_putbytes(xdrs, addr, len)
-XDR *xdrs;
-register char* addr;
-register unsigned int len;
+static bool_t
+xdrrec_putbytes (XDR *xdrs, const char *addr, unsigned int len)
 {
 	register RECSTREAM *rstrm = (RECSTREAM *) (xdrs->x_private);
-	register int current;
+	register unsigned int current;
 
 	while (len > 0) {
-		current = (unsigned long) rstrm->out_boundry - (unsigned long) rstrm->out_finger;
+		current = rstrm->out_boundry - rstrm->out_finger;
 		current = (len < current) ? len : current;
 		memmove(rstrm->out_finger, addr, current);
 		rstrm->out_finger += current;
@@ -399,8 +402,8 @@ register unsigned int len;
 	return (TRUE);
 }
 
-static unsigned int xdrrec_getpos(xdrs)
-register XDR *xdrs;
+static unsigned int
+xdrrec_getpos (const XDR *xdrs)
 {
 	register RECSTREAM *rstrm = (RECSTREAM *) xdrs->x_private;
 	register long pos;
@@ -424,9 +427,8 @@ register XDR *xdrs;
 	return ((unsigned int) pos);
 }
 
-static bool_t xdrrec_setpos(xdrs, pos)
-register XDR *xdrs;
-unsigned int pos;
+static bool_t
+xdrrec_setpos (XDR *xdrs, unsigned int pos)
 {
 	register RECSTREAM *rstrm = (RECSTREAM *) xdrs->x_private;
 	unsigned int currpos = xdrrec_getpos(xdrs);
@@ -485,8 +487,8 @@ static int32_t *xdrrec_inline(XDR* xdrs,
 	return (buf);
 }
 
-static void xdrrec_destroy(xdrs)
-register XDR *xdrs;
+static void
+xdrrec_destroy (XDR *xdrs)
 {
 	register RECSTREAM *rstrm = (RECSTREAM *) xdrs->x_private;
 
@@ -556,16 +558,15 @@ bool_t sendnow;
 	register unsigned long len;		/* fragment length */
 
 	if (sendnow || rstrm->frag_sent ||
-		((unsigned long) rstrm->out_finger + sizeof(unsigned long) >=
-		 (unsigned long) rstrm->out_boundry)) {
+		(rstrm->out_finger + BYTES_PER_XDR_UNIT >= rstrm->out_boundry)) {
 		rstrm->frag_sent = FALSE;
 		return (flush_out(rstrm, TRUE));
 	}
-	len = (unsigned long) (rstrm->out_finger) - (unsigned long) (rstrm->frag_header) -
-		sizeof(unsigned long);
+	len = rstrm->out_finger - (char *)rstrm->frag_header -
+		BYTES_PER_XDR_UNIT;
 	*(rstrm->frag_header) = htonl((unsigned long) len | LAST_FRAG);
-	rstrm->frag_header = (unsigned long *) rstrm->out_finger;
-	rstrm->out_finger += sizeof(unsigned long);
+	rstrm->frag_header = (uint32_t *) rstrm->out_finger;
+	rstrm->out_finger += BYTES_PER_XDR_UNIT;
 	return (TRUE);
 }
 
