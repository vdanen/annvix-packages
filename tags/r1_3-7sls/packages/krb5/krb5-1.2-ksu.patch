Implement some access checking on files the user should already own, to make
sure that no useful information is revealed to would-be attackers.  There may
be other problems in ksu that we aren't catching here (the MIT team seems to
think there might be others lurking in here, and I have no reason to disagree).

diff -uNr krb5-1.2/src/clients/ksu/ccache.c krb5-1.2/src/clients/ksu/ccache.c
--- krb5-1.2/src/clients/ksu/ccache.c	Mon Apr 10 19:27:45 2000
+++ krb5-1.2/src/clients/ksu/ccache.c	Tue Apr 25 17:46:36 2000
@@ -76,7 +76,7 @@
     cc_other_name = krb5_cc_get_name(context, *cc_other);    
 
 
-    if ( ! stat(cc_def_name, &st_temp)){
+    if ( ! access(cc_def_name, R_OK) && ! stat(cc_def_name, &st_temp)){
 	if((retval = krb5_get_nonexp_tkts(context,cc_def,&cc_def_creds_arr))){
 		return retval;
 	}
diff -uNr krb5-1.2/src/clients/ksu/heuristic.c krb5-1.2/src/clients/ksu/heuristic.c
--- krb5-1.2/src/clients/ksu/heuristic.c	Mon Apr 10 19:27:45 2000
+++ krb5-1.2/src/clients/ksu/heuristic.c	Tue Apr 25 17:47:26 2000
@@ -403,7 +403,7 @@
 
     cc_source_name = krb5_cc_get_name(context, cc);
 
-    if ( ! stat(cc_source_name, &st_temp)){
+    if ( ! access(cc_source_name, F_OK | R_OK) && ! stat(cc_source_name, &st_temp)){
 
 	if (retval = find_ticket(context, cc, client, end_server, &temp_found))
 	    return retval;
@@ -558,7 +558,7 @@
     cc_source_name = krb5_cc_get_name(context, cc_source);
 
 	
-    if (! stat(cc_source_name, &st_temp))
+    if (! access(cc_source_name, F_OK | R_OK) && ! stat(cc_source_name, &st_temp))
 	if (retval = krb5_cc_get_principal(context, cc_source, &cc_def_princ))
 	    return retval;
 
@@ -603,7 +603,7 @@
     }
     
     /* if .k5users and .k5login do not exist */  	
-    if (stat(k5login_path, &tb) && stat(k5users_path, &tb) ){
+    if ( stat(k5login_path, &tb) && stat(k5users_path, &tb) ){
 	*client = target_client;
 
 	if (cmd)
