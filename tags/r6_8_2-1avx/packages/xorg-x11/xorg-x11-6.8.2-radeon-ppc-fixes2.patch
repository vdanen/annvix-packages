--- xc-old/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c	2005-06-13 13:25:02.000000000 +0200
+++ xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c	2005-06-13 13:29:30.000000000 +0200
@@ -118,6 +118,7 @@
 static void RADEONGetMergedFBOptions(ScrnInfoPtr pScrn);
 static int RADEONValidateMergeModes(ScrnInfoPtr pScrn);
 static void RADEONSetDynamicClock(ScrnInfoPtr pScrn, int mode);
+static void RADEONUpdatePanelSize(ScrnInfoPtr pScrn);
 
 /* psuedo xinerama support */
 
@@ -165,6 +166,8 @@
 #endif
     OPTION_SHOWCACHE,
     OPTION_VGA_ACCESS,
+    OPTION_REVERSE_DDC,
+    OPTION_LVDS_PROBE_PLL,
     OPTION_DYNAMIC_CLOCKS
 } RADEONOpts;
 
@@ -211,6 +214,8 @@
     { OPTION_SHOWCACHE,      "ShowCache",        OPTV_BOOLEAN, {0}, FALSE },
     { OPTION_DYNAMIC_CLOCKS, "DynamicClocks",    OPTV_BOOLEAN, {0}, FALSE },
     { OPTION_VGA_ACCESS,     "VGAAccess",        OPTV_BOOLEAN, {0}, TRUE  },
+    { OPTION_REVERSE_DDC,    "ReverseDDC",       OPTV_BOOLEAN, {0}, FALSE },
+    { OPTION_LVDS_PROBE_PLL, "LVDSProbePLL",     OPTV_BOOLEAN, {0}, FALSE },
     { -1,                    NULL,               OPTV_NONE,    {0}, FALSE }
 };
 
@@ -686,24 +691,49 @@
     return TRUE;
 }
 
-/* This function is required to workaround a hardware bug in some (all?)
- * revisions of the R300.  This workaround should be called after every
- * CLOCK_CNTL_INDEX register access.  If not, register reads afterward
- * may not be correct.
- */
-void R300CGWorkaround(ScrnInfoPtr pScrn) {
-    RADEONInfoPtr  info       = RADEONPTR(pScrn);
+void RADEONPllErrataAfterIndex(RADEONInfoPtr info)
+{
+    unsigned char *RADEONMMIO = info->MMIO;
+	
+    if (!(info->ChipErrata & CHIP_ERRATA_PLL_DUMMYREADS))
+	return;
+
+    /* This workaround is necessary on rv200 and RS200 or PLL
+     * reads may return garbage (among others...)
+     */
+    (void)INREG(RADEON_CLOCK_CNTL_DATA);
+    (void)INREG(RADEON_CRTC_GEN_CNTL);
+}
+
+void RADEONPllErrataAfterData(RADEONInfoPtr info)
+{
     unsigned char *RADEONMMIO = info->MMIO;
-    CARD32         save, tmp;
 
-    save = INREG(RADEON_CLOCK_CNTL_INDEX);
-    tmp = save & ~(0x3f | RADEON_PLL_WR_EN);
-    OUTREG(RADEON_CLOCK_CNTL_INDEX, tmp);
-    tmp = INREG(RADEON_CLOCK_CNTL_DATA);
-    OUTREG(RADEON_CLOCK_CNTL_INDEX, save);
+    /* This workarounds is necessary on RV100, RS100 and RS200 chips
+     * or the chip could hang on a subsequent access
+     */
+    if (info->ChipErrata & CHIP_ERRATA_PLL_DELAY) {
+	/* we can't deal with posted writes here ... */
+	usleep(5000);
+    }
+
+    /* This function is required to workaround a hardware bug in some (all?)
+     * revisions of the R300.  This workaround should be called after every
+     * CLOCK_CNTL_INDEX register access.  If not, register reads afterward
+     * may not be correct.
+     */
+    if (info->ChipErrata & CHIP_ERRATA_R300_CG) {
+	CARD32         save, tmp;
+
+	save = INREG(RADEON_CLOCK_CNTL_INDEX);
+	tmp = save & ~(0x3f | RADEON_PLL_WR_EN);
+	OUTREG(RADEON_CLOCK_CNTL_INDEX, tmp);
+	tmp = INREG(RADEON_CLOCK_CNTL_DATA);
+	OUTREG(RADEON_CLOCK_CNTL_INDEX, save);
+    }
 }
 
-/* Read PLL information */
+/* Read PLL register */
 unsigned RADEONINPLL(ScrnInfoPtr pScrn, int addr)
 {
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
@@ -711,12 +741,27 @@
     CARD32         data;
 
     OUTREG8(RADEON_CLOCK_CNTL_INDEX, addr & 0x3f);
+    RADEONPllErrataAfterIndex(info);
     data = INREG(RADEON_CLOCK_CNTL_DATA);
-    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
+    RADEONPllErrataAfterData(info);
 
     return data;
 }
 
+/* Write PLL information */
+void RADEONOUTPLL(ScrnInfoPtr pScrn, int addr, CARD32 data)
+{
+    RADEONInfoPtr  info       = RADEONPTR(pScrn);
+    unsigned char *RADEONMMIO = info->MMIO;
+
+    OUTREG8(RADEON_CLOCK_CNTL_INDEX, (((addr) & 0x3f) |
+				      RADEON_PLL_WR_EN));
+    RADEONPllErrataAfterIndex(info);
+    OUTREG(RADEON_CLOCK_CNTL_DATA, data);
+    RADEONPllErrataAfterData(info);
+}
+
+
 #if 0
 /* Read PAL information (only used for debugging) */
 static int RADEONINPAL(int idx)
@@ -1265,6 +1310,7 @@
      }
 
     ppll_div_sel = INREG8(RADEON_CLOCK_CNTL_INDEX + 1) & 0x3;
+    RADEONPllErrataAfterIndex(info);
 
     n = (INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel) & 0x7ff);
     m = (INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x3ff);
@@ -1413,7 +1459,25 @@
 	info->PanelXRes = 640;
 	info->PanelYRes = 480;
     }
-    
+
+    if (xf86ReturnOptValBool(info->Options, OPTION_LVDS_PROBE_PLL, TRUE)) {
+           CARD32 ppll_div_sel, ppll_val;
+
+           ppll_div_sel = INREG8(RADEON_CLOCK_CNTL_INDEX + 1) & 0x3;
+	   RADEONPllErrataAfterIndex(info);
+	   ppll_val = INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel);
+           if ((ppll_val & 0x000707ff) == 0x1bb)
+		   goto noprobe;
+	   info->FeedbackDivider = ppll_val & 0x7ff;
+	   info->PostDivider = (ppll_val >> 16) & 0x7;
+	   info->RefDivider = info->pll.reference_div;
+	   info->UseBiosDividers = TRUE;
+
+           xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                      "Existing panel PLL dividers will be used.\n");
+    }
+ noprobe:
+
     xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
 	       "Panel size %dx%d is derived, this may not be correct.\n"
 		   "If not, use PanelSize option to overwrite this setting\n",
@@ -1427,17 +1491,24 @@
     if (!RADEONGetLVDSInfoFromBIOS(pScrn))
         RADEONGetPanelInfoFromReg(pScrn);
 
+    /* The panel size we collected from BIOS may not be the
+     * maximum size supported by the panel.  If not, we update
+     * it now.  These will be used if no matching mode can be
+     * found from EDID data.
+     */
+    RADEONUpdatePanelSize(pScrn);
+
+    /* No timing information for the native mode,
+     * use whatever specified in the Modeline.
+     * If no Modeline specified, we'll just pick
+     * the VESA mode at 60Hz refresh rate which
+     * is likely to be the best for a flat panel.
+     */
     if (info->DotClock == 0) {
         RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
         DisplayModePtr  tmp_mode = NULL;
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                    "No valid timing info from BIOS.\n");
-        /* No timing information for the native mode,
-           use whatever specified in the Modeline.
-           If no Modeline specified, we'll just pick
-           the VESA mode at 60Hz refresh rate which
-           is likely to be the best for a flat panel.
-	*/
         tmp_mode = pScrn->monitor->Modes;
         while(tmp_mode) {
             if ((tmp_mode->HDisplay == info->PanelXRes) &&
@@ -1508,6 +1579,8 @@
             RADEONGetTMDSInfo(pScrn);
             if (!pScrn->monitor->DDC)
                 RADEONGetHardCodedEDIDFromBIOS(pScrn);
+            else if (!info->IsSecondary)
+               RADEONUpdatePanelSize(pScrn);
         }
     }
 }
@@ -1709,6 +1782,14 @@
 	pRADEONEnt->PortInfo[1].DACType = DAC_PRIMARY;
 	pRADEONEnt->PortInfo[1].TMDSType = TMDS_EXT;
 	pRADEONEnt->PortInfo[1].ConnectorType = CONNECTOR_CRT;
+
+       /* Some cards have the DDC lines swapped and we have no way to
+        * detect it yet (Mac cards)
+        */
+       if (xf86ReturnOptValBool(info->Options, OPTION_REVERSE_DDC, FALSE)) {
+           pRADEONEnt->PortInfo[0].DDCType = DDC_VGA;
+           pRADEONEnt->PortInfo[1].DDCType = DDC_DVI;
+        }
     }
 
     /* always make TMDS_INT port first*/
@@ -2499,10 +2580,22 @@
 	info1->MergedFB = FALSE;
     }
 
-    info->R300CGWorkaround =
-	(info->ChipFamily == CHIP_FAMILY_R300 &&
-	 (INREG(RADEON_CONFIG_CNTL) & RADEON_CFG_ATI_REV_ID_MASK)
-	 == RADEON_CFG_ATI_REV_A11);
+    /* Check chip errata */
+    info->ChipErrata = 0;
+
+    if (info->ChipFamily == CHIP_FAMILY_R300 &&
+	(INREG(RADEON_CONFIG_CNTL) & RADEON_CFG_ATI_REV_ID_MASK)
+	== RADEON_CFG_ATI_REV_A11)
+	    info->ChipErrata |= CHIP_ERRATA_R300_CG;
+
+    if (info->ChipFamily == CHIP_FAMILY_RV200 ||
+	info->ChipFamily == CHIP_FAMILY_RS200)
+	    info->ChipErrata |= CHIP_ERRATA_PLL_DUMMYREADS;
+
+    if (info->ChipFamily == CHIP_FAMILY_RV100 ||
+	info->ChipFamily == CHIP_FAMILY_RS100 ||
+	info->ChipFamily == CHIP_FAMILY_RS200)
+	    info->ChipErrata |= CHIP_ERRATA_PLL_DELAY;
 
     info->MemCntl            = INREG(RADEON_SDRAM_MODE_REG);
     info->BusCntl            = INREG(RADEON_BUS_CNTL);
@@ -2698,16 +2791,35 @@
     xf86MonPtr      ddc  = pScrn->monitor->DDC;
     DisplayModePtr  p;
 
+    if (info->UseBiosDividers && info->DotClock != 0)
+       return;
+
     /* Go thru detailed timing table first */
     for (j = 0; j < 4; j++) {
 	if (ddc->det_mon[j].type == 0) {
 	    struct detailed_timings *d_timings =
 		&ddc->det_mon[j].section.d_timings;
-	    if (info->PanelXRes <= d_timings->h_active &&
-		info->PanelYRes <= d_timings->v_active) {
+           int match = 0;
 
-		if (info->DotClock) continue; /* Timings already inited */
+           /* If we didn't get a panel clock or guessed one, try to match the
+            * mode with the panel size. We do that because we _need_ a panel
+            * clock, or ValidateFPModes will fail, even when UseBiosDividers
+            * is set.
+            */
+           if (info->DotClock == 0 &&
+               info->PanelXRes == d_timings->h_active &&
+               info->PanelYRes == d_timings->v_active)
+               match = 1;
 
+           /* If we don't have a BIOS provided panel data with fixed dividers,
+            * check for a larger panel size
+            */
+	    if (info->PanelXRes < d_timings->h_active &&
+               info->PanelYRes < d_timings->v_active &&
+               !info->UseBiosDividers)
+               match = 1;
+
+             if (match) {
 		info->PanelXRes  = d_timings->h_active;
 		info->PanelYRes  = d_timings->v_active;
 		info->DotClock   = d_timings->clock / 1000;
@@ -2717,10 +2829,24 @@
 		info->VOverPlus  = d_timings->v_sync_off;
 		info->VSyncWidth = d_timings->v_sync_width;
 		info->VBlank     = d_timings->v_blanking;
+                info->Flags      = (d_timings->interlaced ? V_INTERLACE : 0);
+                if (d_timings->sync == 3) {
+                   switch (d_timings->misc) {
+                   case 0: info->Flags |= V_NHSYNC | V_NVSYNC; break;
+                   case 1: info->Flags |= V_PHSYNC | V_NVSYNC; break;
+                   case 2: info->Flags |= V_NHSYNC | V_PVSYNC; break;
+                   case 3: info->Flags |= V_PHSYNC | V_PVSYNC; break;
+                   }
+                }
+                xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Panel infos found from DDC detailed: %dx%d\n",
+                           info->PanelXRes, info->PanelYRes);
 	    }
 	}
     }
 
+    if (info->UseBiosDividers && info->DotClock != 0)
+       return;
+
     /* Search thru standard VESA modes from EDID */
     for (j = 0; j < 8; j++) {
 	if ((info->PanelXRes < ddc->timings2[j].hsize) &&
@@ -2742,26 +2868,14 @@
 			info->VOverPlus  = p->VSyncStart - p->VDisplay;
 			info->VSyncWidth = p->VSyncEnd - p->VSyncStart;
 			info->DotClock   = p->Clock;
-			info->Flags      =
-			    (ddc->det_mon[j].section.d_timings.interlaced
-			     ? V_INTERLACE
-			     : 0);
-			if (ddc->det_mon[j].section.d_timings.sync == 3) {
-			    switch (ddc->det_mon[j].section.d_timings.misc) {
-			    case 0: info->Flags |= V_NHSYNC | V_NVSYNC; break;
-			    case 1: info->Flags |= V_PHSYNC | V_NVSYNC; break;
-			    case 2: info->Flags |= V_NHSYNC | V_PVSYNC; break;
-			    case 3: info->Flags |= V_PHSYNC | V_PVSYNC; break;
-			    }
-			}
+                        info->Flags      = p->Flags;
+                        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Panel infos found from DDC VESA/EDID: %dx%d\n",
+                                   info->PanelXRes, info->PanelYRes);
 		    }
 		}
 	    }
 	}
     }
-
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Panel size found from DDC: %dx%d\n",
-	       info->PanelXRes, info->PanelYRes);
 }
 
 /* This function will sort all modes according to their resolution.
@@ -2882,6 +2996,8 @@
 
     /* Search thru standard VESA modes from EDID */
     for (j = 0; j < 8; j++) {
+        if (ddc->timings2[j].hsize == 0 || ddc->timings2[j].vsize == 0)
+               continue;
 	for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
 	    /* Ignore all double scan modes */
 	    if ((ddc->timings2[j].hsize == p->HDisplay) &&
@@ -2971,19 +3087,10 @@
     pScrn->virtualX = pScrn1->display->virtualX;
     pScrn->virtualY = pScrn1->display->virtualY;
 
-    if (pScrn->monitor->DDC && !info->UseBiosDividers) {
+    if (pScrn->monitor->DDC) {
 	int  maxVirtX = pScrn->virtualX;
 	int  maxVirtY = pScrn->virtualY;
 
-	if ((DisplayType != MT_CRT) && (!info->IsSecondary) && (!crtc2)) {
-	    /* The panel size we collected from BIOS may not be the
-	     * maximum size supported by the panel.  If not, we update
-	     * it now.  These will be used if no matching mode can be
-	     * found from EDID data.
-	     */
-	    RADEONUpdatePanelSize(pScrn);
-	}
-
 	/* Collect all of the DDC modes */
 	first = last = ddcModes = RADEONDDCModes(pScrn);
 
@@ -3675,7 +3782,8 @@
 		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
 			   "Invalid PanelSize value: %s\n", s);
 	    }
-	}
+        } else
+            RADEONGetPanelInfo(pScrn);
     }
 
     if (pScrn->monitor->DDC) {
@@ -4354,7 +4462,6 @@
     RADEONGetBIOSInfo(pScrn, pInt10);
     if (!RADEONQueryConnectedMonitors(pScrn))    goto fail;
     RADEONGetClockInfo(pScrn);
-    RADEONGetPanelInfo(pScrn);
 
     /* collect MergedFB options */
     /* only parse mergedfb options on the primary head. 
@@ -5329,7 +5436,7 @@
 
 	if (info->IsMobility || info->IsIGP) {
 	    if (!(restore->lvds_gen_cntl & RADEON_LVDS_ON)) {
-		OUTPLL(RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
+		OUTPLL(pScrn, RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
 	    }
 	}
     }
@@ -5407,6 +5514,7 @@
 	    OUTREGP(RADEON_CLOCK_CNTL_INDEX,
 		    RADEON_PLL_DIV_SEL,
 		    ~(RADEON_PLL_DIV_SEL));
+	    RADEONPllErrataAfterIndex(info);
 	    return;
 	}
     }
@@ -5427,6 +5535,7 @@
     OUTREGP(RADEON_CLOCK_CNTL_INDEX,
 	    RADEON_PLL_DIV_SEL,
 	    ~(RADEON_PLL_DIV_SEL));
+    RADEONPllErrataAfterIndex(info);
 
     if (IS_R300_VARIANT ||
 	(info->ChipFamily == CHIP_FAMILY_RS300)) {
@@ -5460,7 +5569,7 @@
     RADEONPLLWriteUpdate(pScrn);
     RADEONPLLWaitForReadUpdateComplete(pScrn);
 
-    OUTPLL(RADEON_HTOTAL_CNTL, restore->htotal_cntl);
+    OUTPLL(pScrn, RADEON_HTOTAL_CNTL, restore->htotal_cntl);
 
     OUTPLLP(pScrn, RADEON_PPLL_CNTL,
 	    0,
@@ -5522,7 +5631,7 @@
     RADEONPLL2WriteUpdate(pScrn);
     RADEONPLL2WaitForReadUpdateComplete(pScrn);
 
-    OUTPLL(RADEON_HTOTAL2_CNTL, restore->htotal_cntl2);
+    OUTPLL(pScrn, RADEON_HTOTAL2_CNTL, restore->htotal_cntl2);
 
     OUTPLLP(pScrn, RADEON_P2PLL_CNTL,
 	    0,
@@ -5882,7 +5991,7 @@
 	save->dp_datatype      = INREG(RADEON_DP_DATATYPE);
 	save->rbbm_soft_reset  = INREG(RADEON_RBBM_SOFT_RESET);
 	save->clock_cntl_index = INREG(RADEON_CLOCK_CNTL_INDEX);
-	if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
+	RADEONPllErrataAfterIndex(info);
     }
 
     RADEONSaveMode(pScrn, save);
@@ -5909,7 +6018,7 @@
     RADEONBlank(pScrn);
 
     OUTREG(RADEON_CLOCK_CNTL_INDEX, restore->clock_cntl_index);
-    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
+    RADEONPllErrataAfterIndex(info);
     OUTREG(RADEON_RBBM_SOFT_RESET,  restore->rbbm_soft_reset);
     OUTREG(RADEON_DP_DATATYPE,      restore->dp_datatype);
     OUTREG(RADEON_GRPH_BUFFER_CNTL, restore->grph_buffer_cntl);
@@ -7739,7 +7848,7 @@
 			     ~(RADEON_LVDS_BLON | RADEON_LVDS_ON));
 
 		    if (info->IsMobility || info->IsIGP) {
-			OUTPLL(RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
+			OUTPLL(pScrn, RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
 		    }
 		} else if (info->DisplayType == MT_CRT) {
 		    if ((pRADEONEnt->HasSecondary) || info->MergedFB) {
@@ -7960,14 +8069,14 @@
 			RADEON_SCLK_FORCE_RE   | RADEON_SCLK_FORCE_PB  |
 			RADEON_SCLK_FORCE_TAM  | RADEON_SCLK_FORCE_TDM |
                         RADEON_SCLK_FORCE_RB);
-                OUTPLL(RADEON_SCLK_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_SCLK_CNTL, tmp);
             } else if (info->ChipFamily == CHIP_FAMILY_RV350) {
                 /* for RV350/M10, no delays are required. */
                 tmp = INPLL(pScrn, R300_SCLK_CNTL2);
                 tmp |= (R300_SCLK_FORCE_TCL |
                         R300_SCLK_FORCE_GA  |
 			R300_SCLK_FORCE_CBA);
-                OUTPLL(R300_SCLK_CNTL2, tmp);
+                OUTPLL(pScrn, R300_SCLK_CNTL2, tmp);
 
                 tmp = INPLL(pScrn, RADEON_SCLK_CNTL);
                 tmp |= (RADEON_SCLK_FORCE_DISP2 | RADEON_SCLK_FORCE_CP      |
@@ -7978,11 +8087,11 @@
 			R300_SCLK_FORCE_PX      | R300_SCLK_FORCE_TX        |
 			R300_SCLK_FORCE_US      | RADEON_SCLK_FORCE_TV_SCLK |
                         R300_SCLK_FORCE_SU      | RADEON_SCLK_FORCE_OV0);
-                OUTPLL(RADEON_SCLK_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_SCLK_CNTL, tmp);
 
                 tmp = INPLL(pScrn, RADEON_SCLK_MORE_CNTL);
                 tmp |= RADEON_SCLK_MORE_FORCEON;
-                OUTPLL(RADEON_SCLK_MORE_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_SCLK_MORE_CNTL, tmp);
 
                 tmp = INPLL(pScrn, RADEON_MCLK_CNTL);
                 tmp |= (RADEON_FORCEON_MCLKA |
@@ -7990,13 +8099,13 @@
                         RADEON_FORCEON_YCLKA |
 			RADEON_FORCEON_YCLKB |
                         RADEON_FORCEON_MC);
-                OUTPLL(RADEON_MCLK_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_MCLK_CNTL, tmp);
 
                 tmp = INPLL(pScrn, RADEON_VCLK_ECP_CNTL);
                 tmp &= ~(RADEON_PIXCLK_ALWAYS_ONb  | 
                          RADEON_PIXCLK_DAC_ALWAYS_ONb | 
 			 R300_DISP_DAC_PIXCLK_DAC_BLANK_OFF); 
-                OUTPLL(RADEON_VCLK_ECP_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_VCLK_ECP_CNTL, tmp);
 
                 tmp = INPLL(pScrn, RADEON_PIXCLKS_CNTL);
                 tmp &= ~(RADEON_PIX2CLK_ALWAYS_ONb         | 
@@ -8013,7 +8122,7 @@
 			 R300_P2G2CLK_ALWAYS_ONb            | 
 			 R300_P2G2CLK_ALWAYS_ONb           | 
 			 R300_DISP_DAC_PIXCLK_DAC2_BLANK_OFF); 
-                OUTPLL(RADEON_PIXCLKS_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_PIXCLKS_CNTL, tmp);
             }  else {
                 tmp = INPLL(pScrn, RADEON_SCLK_CNTL);
                 tmp |= (RADEON_SCLK_FORCE_CP | RADEON_SCLK_FORCE_E2);
@@ -8050,7 +8159,7 @@
                     tmp |= ( R300_SCLK_FORCE_TCL |
 			     R300_SCLK_FORCE_GA  |
 			     R300_SCLK_FORCE_CBA);
-                    OUTPLL(R300_SCLK_CNTL2, tmp);
+                    OUTPLL(pScrn, R300_SCLK_CNTL2, tmp);
 		    usleep(16000);
 		}
 
@@ -8067,7 +8176,7 @@
 		    (info->ChipFamily == CHIP_FAMILY_RV280)) {
                     tmp = INPLL(pScrn, RADEON_SCLK_MORE_CNTL);
 		    tmp |= RADEON_SCLK_MORE_FORCEON;
-                    OUTPLL(RADEON_SCLK_MORE_CNTL, tmp);
+                    OUTPLL(pScrn, RADEON_SCLK_MORE_CNTL, tmp);
 		    usleep(16000);
 		}
 
@@ -8086,7 +8195,7 @@
                 tmp = INPLL(pScrn, RADEON_VCLK_ECP_CNTL);
                 tmp &= ~(RADEON_PIXCLK_ALWAYS_ONb  |
 			 RADEON_PIXCLK_DAC_ALWAYS_ONb); 
-                OUTPLL(RADEON_VCLK_ECP_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_VCLK_ECP_CNTL, tmp);
 	    }
 	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Dynamic Clock Scaling Disabled\n");
             break;
@@ -8102,7 +8211,7 @@
 			 RADEON_SCLK_FORCE_IDCT | RADEON_SCLK_FORCE_RE   |
 			 RADEON_SCLK_FORCE_PB   | RADEON_SCLK_FORCE_TAM  |
 			 RADEON_SCLK_FORCE_TDM);
-                OUTPLL (RADEON_SCLK_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_SCLK_CNTL, tmp);
 	    } else if ((info->ChipFamily == CHIP_FAMILY_R300) ||
 		       (info->ChipFamily == CHIP_FAMILY_R350) ||
 		       (info->ChipFamily == CHIP_FAMILY_RV350)) {
@@ -8114,7 +8223,7 @@
 		    tmp |=  (R300_SCLK_TCL_MAX_DYN_STOP_LAT |
 			     R300_SCLK_GA_MAX_DYN_STOP_LAT  |
 			     R300_SCLK_CBA_MAX_DYN_STOP_LAT);
-		    OUTPLL(R300_SCLK_CNTL2, tmp);
+		    OUTPLL(pScrn, R300_SCLK_CNTL2, tmp);
 
 		    tmp = INPLL(pScrn, RADEON_SCLK_CNTL);
 		    tmp &= ~(RADEON_SCLK_FORCE_DISP2 | RADEON_SCLK_FORCE_CP      |
@@ -8126,17 +8235,17 @@
 			     R300_SCLK_FORCE_US      | RADEON_SCLK_FORCE_TV_SCLK |
 			     R300_SCLK_FORCE_SU      | RADEON_SCLK_FORCE_OV0);
 		    tmp |=  RADEON_DYN_STOP_LAT_MASK;
-		    OUTPLL(RADEON_SCLK_CNTL, tmp);
+		    OUTPLL(pScrn, RADEON_SCLK_CNTL, tmp);
 
 		    tmp = INPLL(pScrn, RADEON_SCLK_MORE_CNTL);
 		    tmp &= ~RADEON_SCLK_MORE_FORCEON;
 		    tmp |=  RADEON_SCLK_MORE_MAX_DYN_STOP_LAT;
-		    OUTPLL(RADEON_SCLK_MORE_CNTL, tmp);
+		    OUTPLL(pScrn, RADEON_SCLK_MORE_CNTL, tmp);
 
 		    tmp = INPLL(pScrn, RADEON_VCLK_ECP_CNTL);
 		    tmp |= (RADEON_PIXCLK_ALWAYS_ONb |
 			    RADEON_PIXCLK_DAC_ALWAYS_ONb);   
-		    OUTPLL(RADEON_VCLK_ECP_CNTL, tmp);
+		    OUTPLL(pScrn, RADEON_VCLK_ECP_CNTL, tmp);
 
 		    tmp = INPLL(pScrn, RADEON_PIXCLKS_CNTL);
 		    tmp |= (RADEON_PIX2CLK_ALWAYS_ONb         |
@@ -8152,12 +8261,12 @@
 			    R300_PIXCLK_TVO_ALWAYS_ONb        |
 			    R300_P2G2CLK_ALWAYS_ONb           |
 			    R300_P2G2CLK_ALWAYS_ONb);
-		    OUTPLL(RADEON_PIXCLKS_CNTL, tmp);
+		    OUTPLL(pScrn, RADEON_PIXCLKS_CNTL, tmp);
 
 		    tmp = INPLL(pScrn, RADEON_MCLK_MISC);
 		    tmp |= (RADEON_MC_MCLK_DYN_ENABLE |
 			    RADEON_IO_MCLK_DYN_ENABLE);
-		    OUTPLL(RADEON_MCLK_MISC, tmp);
+		    OUTPLL(pScrn, RADEON_MCLK_MISC, tmp);
 
 		    tmp = INPLL(pScrn, RADEON_MCLK_CNTL);
 		    tmp |= (RADEON_FORCEON_MCLKA |
@@ -8186,19 +8295,19 @@
 			}
 		    }
 
-		    OUTPLL(RADEON_MCLK_CNTL, tmp);
+		    OUTPLL(pScrn, RADEON_MCLK_CNTL, tmp);
 		} else {
 		    tmp = INPLL(pScrn, RADEON_SCLK_CNTL);
 		    tmp &= ~(R300_SCLK_FORCE_VAP);
 		    tmp |= RADEON_SCLK_FORCE_CP;
-		    OUTPLL(RADEON_SCLK_CNTL, tmp);
+		    OUTPLL(pScrn, RADEON_SCLK_CNTL, tmp);
 		    usleep(15000);
 
 		    tmp = INPLL(pScrn, R300_SCLK_CNTL2);
 		    tmp &= ~(R300_SCLK_FORCE_TCL |
 			     R300_SCLK_FORCE_GA  |
 			     R300_SCLK_FORCE_CBA);
-		    OUTPLL(R300_SCLK_CNTL2, tmp);
+		    OUTPLL(pScrn, R300_SCLK_CNTL2, tmp);
 		}
 	    } else {
                 tmp = INPLL(pScrn, RADEON_CLK_PWRMGT_CNTL);
@@ -8209,12 +8318,12 @@
 
                 tmp |= (RADEON_ENGIN_DYNCLK_MODE |
 			(0x01 << RADEON_ACTIVE_HILO_LAT_SHIFT));
-                OUTPLL(RADEON_CLK_PWRMGT_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_CLK_PWRMGT_CNTL, tmp);
 		usleep(15000);
 
                 tmp = INPLL(pScrn, RADEON_CLK_PIN_CNTL);
                 tmp |= RADEON_SCLK_DYN_START_CNTL; 
-                OUTPLL(RADEON_CLK_PIN_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_CLK_PIN_CNTL, tmp);
 		usleep(15000);
 
 		/* When DRI is enabled, setting DYN_STOP_LAT to zero can cause some R200 
@@ -8235,7 +8344,7 @@
                     tmp |= RADEON_SCLK_FORCE_VIP;
                 }
 
-                OUTPLL(RADEON_SCLK_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_SCLK_CNTL, tmp);
 
 		if ((info->ChipFamily == CHIP_FAMILY_RV200) ||
 		    (info->ChipFamily == CHIP_FAMILY_RV250) ||
@@ -8250,7 +8359,7 @@
 			 RADEON_CFG_ATI_REV_A13)) {
                         tmp |= RADEON_SCLK_MORE_FORCEON;
 		    }
-                    OUTPLL(RADEON_SCLK_MORE_CNTL, tmp);
+                    OUTPLL(pScrn, RADEON_SCLK_MORE_CNTL, tmp);
 		    usleep(15000);
                 }
 
@@ -8275,14 +8384,14 @@
 			 RADEON_PIXCLK_LVDS_ALWAYS_ONb     |
 			 RADEON_PIXCLK_TMDS_ALWAYS_ONb);
 
-		OUTPLL(RADEON_PIXCLKS_CNTL, tmp);
+		OUTPLL(pScrn, RADEON_PIXCLKS_CNTL, tmp);
 		usleep(15000);
 
 		tmp = INPLL(pScrn, RADEON_VCLK_ECP_CNTL);
 		tmp |= (RADEON_PIXCLK_ALWAYS_ONb  |
 		        RADEON_PIXCLK_DAC_ALWAYS_ONb); 
 
-                OUTPLL(RADEON_VCLK_ECP_CNTL, tmp);
+                OUTPLL(pScrn, RADEON_VCLK_ECP_CNTL, tmp);
 		usleep(15000);
             }    
 	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Dynamic Clock Scaling Enabled\n");
--- xc-old/programs/Xserver/hw/xfree86/drivers/ati/radeon.man	2005-06-13 13:25:08.000000000 +0200
+++ xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.man	2005-06-13 13:28:44.000000000 +0200
@@ -505,6 +505,23 @@
 .B on
 on other architectures.
 .TP
+.BI "Option \*qReverseDDC\*q \*q" boolean \*q
+When BIOS connector informations aren't available, use this option to
+reverse the mapping of the 2 main DDC ports. Use this if the X serve
+obviously detects the wrong display for each connector. This is
+typically needed on the Radeon 9600 cards bundled with Apple G5s. The
+default is
+.B off.
+.TP
+.BI "Option \*qLVDSProbePLL\*q \*q" boolean \*q
+When BIOS panel informations aren't available (like on PowerBooks), it
+may still be necessary to use the firmware provided PLL values for the
+panel or flickering will happen. This option will force probing of
+the current value programmed in the chip when X is launched in that
+case.  This is only useful for LVDS panels (laptop internal panels).
+The default is
+.B on.
+.TP
 
 .SH SEE ALSO
 __xservername__(__appmansuffix__), __xconfigfile__(__filemansuffix__), xorgconfig(__appmansuffix__), Xserver(__appmansuffix__), X(__miscmansuffix__)
--- xc-old/programs/Xserver/hw/xfree86/drivers/ati/radeon.h	2005-06-13 13:25:01.000000000 +0200
+++ xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h	2005-06-13 13:29:30.000000000 +0200
@@ -273,6 +273,16 @@
         (info->ChipFamily == CHIP_FAMILY_RV380) ||  \
         (info->ChipFamily == CHIP_FAMILY_R420))
 
+/*
+ * Errata workarounds
+ */
+typedef enum {
+       CHIP_ERRATA_R300_CG             = 0x00000001,
+       CHIP_ERRATA_PLL_DUMMYREADS      = 0x00000002,
+       CHIP_ERRATA_PLL_DELAY           = 0x00000004
+} RADEONErrata;
+
+
 
 typedef struct {
     CARD32 freq;
@@ -285,6 +295,7 @@
     PCITAG            PciTag;
     int               Chipset;
     RADEONChipFamily  ChipFamily;
+    RADEONErrata      ChipErrata;
 
     Bool              FBDev;
 
@@ -623,6 +634,8 @@
 extern void        RADEONEngineRestore(ScrnInfoPtr pScrn);
 
 extern unsigned    RADEONINPLL(ScrnInfoPtr pScrn, int addr);
+extern void        RADEONOUTPLL(ScrnInfoPtr pScrn, int addr, CARD32 data);
+
 extern void        RADEONWaitForVerticalSync(ScrnInfoPtr pScrn);
 extern void        RADEONWaitForVerticalSync2(ScrnInfoPtr pScrn);
 
@@ -640,6 +653,9 @@
 extern void        RADEONResetVideo(ScrnInfoPtr pScrn);
 extern void        R300CGWorkaround(ScrnInfoPtr pScrn);
 
+extern void        RADEONPllErrataAfterIndex(RADEONInfoPtr info);
+extern void        RADEONPllErrataAfterData(RADEONInfoPtr info);
+
 #ifdef XF86DRI
 extern void        RADEONAccelInitCP(ScreenPtr pScreen, XAAInfoRecPtr a);
 extern Bool        RADEONDRIScreenInit(ScreenPtr pScreen);
--- xc-old/programs/Xserver/hw/xfree86/drivers/ati/radeon_macros.h	2005-06-13 13:25:09.000000000 +0200
+++ xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_macros.h	2005-06-13 13:29:30.000000000 +0200
@@ -84,19 +84,14 @@
 
 #define INPLL(pScrn, addr) RADEONINPLL(pScrn, addr)
 
-#define OUTPLL(addr, val)						\
-do {									\
-    OUTREG8(RADEON_CLOCK_CNTL_INDEX, (((addr) & 0x3f) |			\
-				      RADEON_PLL_WR_EN));		\
-    OUTREG(RADEON_CLOCK_CNTL_DATA, val);				\
-} while (0)
+#define OUTPLL(pScrn, addr, val) RADEONOUTPLL(pScrn, addr, val)
 
 #define OUTPLLP(pScrn, addr, val, mask)					\
 do {									\
     CARD32 tmp_ = INPLL(pScrn, addr);					\
     tmp_ &= (mask);							\
     tmp_ |= (val);							\
-    OUTPLL(addr, tmp_);							\
+    OUTPLL(pScrn, addr, tmp_);						\
 } while (0)
 
 #define OUTPAL_START(idx)						\
@@ -138,5 +133,4 @@
     }									\
 } while (0)
 
-
 #endif
--- xc-old/programs/Xserver/hw/xfree86/drivers/ati/radeon_video.c	2005-06-13 13:25:01.000000000 +0200
+++ xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_video.c	2005-06-13 13:29:30.000000000 +0200
@@ -877,8 +877,8 @@
     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Dotclock is %g Mhz, setting ecp_div to %d\n", info->ModeReg.dot_clock_freq/100.0, pPriv->ecp_div);
 #endif
 
-    OUTPLL(RADEON_VCLK_ECP_CNTL, (INPLL(pScrn, RADEON_VCLK_ECP_CNTL) &
-				  0xfffffCff) | (pPriv->ecp_div << 8));
+    OUTPLL(pScrn, RADEON_VCLK_ECP_CNTL, (INPLL(pScrn, RADEON_VCLK_ECP_CNTL) &
+					 0xfffffCff) | (pPriv->ecp_div << 8));
 
     /* I suspect we may need a usleep after writing to the PLL.  if you play a video too soon
        after switching crtcs in mergedfb clone mode you get a temporary one pixel line of colorkey 
@@ -890,7 +890,8 @@
 	(info->ChipFamily == CHIP_FAMILY_RS300)) {
         /* Force the overlay clock on for integrated chips
 	 */
-        OUTPLL(RADEON_VCLK_ECP_CNTL, (INPLL(pScrn, RADEON_VCLK_ECP_CNTL) | (1<<18)));
+        OUTPLL(pScrn, RADEON_VCLK_ECP_CNTL,
+	       (INPLL(pScrn, RADEON_VCLK_ECP_CNTL) | (1<<18)));
     }
 
     info->adaptor = adapt;
@@ -1312,7 +1313,7 @@
     else
 	ecp_div = 1;
 
-    OUTPLL(RADEON_VCLK_ECP_CNTL, (INPLL(pScrn, RADEON_VCLK_ECP_CNTL) & 0xfffffCff) | (ecp_div << 8));
+    OUTPLL(pScrn, RADEON_VCLK_ECP_CNTL, (INPLL(pScrn, RADEON_VCLK_ECP_CNTL) & 0xfffffCff) | (ecp_div << 8));
 
     /* I suspect we may need a usleep after writing to the PLL.  if you play a video too soon
        after switching crtcs in mergedfb clone mode you get a temporary one pixel line of colorkey 
--- xc-old/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c	2005-06-13 13:25:01.000000000 +0200
+++ xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c	2005-06-13 13:29:30.000000000 +0200
@@ -171,7 +171,7 @@
     RADEONEngineFlush(pScrn);
 
     clock_cntl_index = INREG(RADEON_CLOCK_CNTL_INDEX);
-    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
+    RADEONPllErrataAfterIndex(info);
 
 #if 0 /* taken care of by new PM code */
     /* Some ASICs have bugs with dynamic-on feature, which are
@@ -249,8 +249,8 @@
 	OUTREG(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);
 
     OUTREG(RADEON_CLOCK_CNTL_INDEX, clock_cntl_index);
-    OUTPLL(RADEON_MCLK_CNTL, mclk_cntl);
-    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
+    RADEONPllErrataAfterIndex(info);
+    OUTPLL(pScrn, RADEON_MCLK_CNTL, mclk_cntl);
 }
 
 /* Restore the acceleration hardware to its previous state */
