diff -uNp t1/arch/i386/kernel/dmi_scan.c.dm04.orig t1/arch/i386/kernel/dmi_scan.c
--- t1/arch/i386/kernel/dmi_scan.c.dm04.orig	2003-10-07 17:07:42.000000000 +0200
+++ t1/arch/i386/kernel/dmi_scan.c	2003-10-07 17:11:48.000000000 +0200
@@ -372,6 +372,24 @@ static int __init local_apic_kills_bios(
 }
 
 /*
+ * FOSA 340S report APM bios 1.2, but it really has 1.1 BIOS.
+ */
+static int __init force_apm_version_1_1(struct dmi_blacklist *d)
+{
+#ifdef CONFIG_APM
+	extern int broken_apm_0x102_version;
+	if ((apm_info.bios.version == 0x102) && !broken_apm_0x102_version) {
+		broken_apm_0x102_version = 1;
+		printk(KERN_WARNING "%s with broken BIOS detected. "
+		       "Forcing 1.1 version BIOS.\n",
+		       d->ident);
+	}
+#endif
+	return 0;
+}
+
+
+/*
  *  Check for clue free BIOS implementations who use
  *  the following QA technique
  *
@@ -585,6 +603,11 @@ static __initdata struct dmi_blacklist d
 			MATCH(DMI_BIOS_VENDOR,"Intel Corp."),
 			MATCH(DMI_BIOS_VERSION,"A11")
 			} },
+{ force_apm_version_1_1, "FOSA 340S", {
+			MATCH(DMI_BOARD_VENDOR, "American Megatrends Inc."),
+			MATCH(DMI_BOARD_NAME, "340S8"),
+			NO_MATCH, NO_MATCH 
+			} },
 	{ set_apm_ints, "Dell Inspiron", {	/* Allow interrupts during suspend on Dell Inspiron laptops*/
 			MATCH(DMI_SYS_VENDOR, "Dell Computer Corporation"),
 			MATCH(DMI_PRODUCT_NAME, "Inspiron 4000"),
diff -up t2/arch/i386/kernel/apm.c.orig t2/arch/i386/kernel/apm.c
--- t2/arch/i386/kernel/apm.c.orig	2002-09-06 11:51:25.000000000 +0200
+++ t2/arch/i386/kernel/apm.c	2002-09-06 12:05:52.000000000 +0200
@@ -1828,6 +1828,11 @@ static struct miscdevice apm_device = {
 	&apm_bios_fops
 };
 
+/* Some FOSA 340S and friends report 0x102 version, but they are
+ * really 0x101 version */
+
+int broken_apm_0x102_version;
+
 /*
  * Just start the APM thread. We do NOT want to do APM BIOS
  * calls from anything but the APM thread, if for no other reason
@@ -1874,6 +1879,9 @@ static int __init apm_init(void)
 	if (apm_info.bios.version == 0x001)
 		apm_info.bios.version = 0x100;
 
+	if (broken_apm_0x102_version)
+		apm_info.bios.version = 0x101;
+
 	/* BIOS < 1.2 doesn't set cseg_16_len */
 	if (apm_info.bios.version < 0x102)
 		apm_info.bios.cseg_16_len = 0; /* 64k */
