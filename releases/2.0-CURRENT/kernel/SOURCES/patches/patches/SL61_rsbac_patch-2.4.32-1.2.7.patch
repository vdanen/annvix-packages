diff -urN -x rsbac trunk/arch/alpha/config.in linux-2.4.32-rsbac-1.2.7/arch/alpha/config.in
--- trunk/arch/alpha/config.in	2006-06-01 10:31:15.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/alpha/config.in	2006-06-01 10:32:43.000000000 +0200
@@ -333,6 +333,15 @@
 fi
 
 mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'ATA/IDE/MFM/RLL support'
 
 tristate 'ATA/IDE/MFM/RLL support' CONFIG_IDE
diff -urN -x rsbac trunk/arch/alpha/defconfig linux-2.4.32-rsbac-1.2.7/arch/alpha/defconfig
--- trunk/arch/alpha/defconfig	2006-06-01 10:31:15.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/alpha/defconfig	2006-06-01 10:32:43.000000000 +0200
@@ -86,6 +86,192 @@
 # CONFIG_MTD is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Plug and Play configuration
 #
 CONFIG_PNP=y
diff -urN -x rsbac trunk/arch/alpha/kernel/entry.S linux-2.4.32-rsbac-1.2.7/arch/alpha/kernel/entry.S
--- trunk/arch/alpha/kernel/entry.S	2006-06-01 10:31:15.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/alpha/kernel/entry.S	2006-06-01 10:32:43.000000000 +0200
@@ -1152,7 +1152,11 @@
 	.quad sys_getdents64
 	.quad sys_gettid
 	.quad sys_readahead
+#ifdef CONFIG_RSBAC
+	.quad sys_rsbac				/* 380, sys_security */
+#else
 	.quad sys_ni_syscall			/* 380, sys_security */
+#endif
 	.quad sys_tkill
 
 /* Remember to update everything, kids.  */
diff -urN -x rsbac trunk/arch/alpha/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/alpha/kernel/ptrace.c
--- trunk/arch/alpha/kernel/ptrace.c	2006-06-01 10:31:15.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/alpha/kernel/ptrace.c	2006-06-01 10:32:43.000000000 +0200
@@ -19,6 +19,11 @@
 #include <asm/system.h>
 #include <asm/fpu.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #include "proto.h"
 
 #define DEBUG	DBG_MEM
@@ -252,6 +257,12 @@
 	struct task_struct *child;
 	long ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	DBG(DBG_MEM, ("request=%ld pid=%ld addr=0x%lx data=0x%lx\n",
 		      request, pid, addr, data));
@@ -260,6 +271,26 @@
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out_notsk;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process ptrace flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -275,6 +306,26 @@
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out_notsk;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out;
diff -urN -x rsbac trunk/arch/arm/config.in linux-2.4.32-rsbac-1.2.7/arch/arm/config.in
--- trunk/arch/arm/config.in	2006-06-01 10:31:06.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/arm/config.in	2006-06-01 10:32:37.000000000 +0200
@@ -578,6 +578,15 @@
 fi
 
 mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'ATA/ATAPI/MFM/RLL support'
 
 tristate 'ATA/ATAPI/MFM/RLL support' CONFIG_IDE
diff -urN -x rsbac trunk/arch/arm/defconfig linux-2.4.32-rsbac-1.2.7/arch/arm/defconfig
--- trunk/arch/arm/defconfig	2006-06-01 10:31:05.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/arm/defconfig	2006-06-01 10:32:36.000000000 +0200
@@ -100,6 +100,192 @@
 # CONFIG_PARPORT is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
diff -urN -x rsbac trunk/arch/arm/kernel/calls.S linux-2.4.32-rsbac-1.2.7/arch/arm/kernel/calls.S
--- trunk/arch/arm/kernel/calls.S	2006-06-01 10:31:05.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/arm/kernel/calls.S	2006-06-01 10:32:36.000000000 +0200
@@ -237,7 +237,11 @@
 /* 220 */	.long	SYMBOL_NAME(sys_madvise)
 		.long	SYMBOL_NAME(sys_fcntl64)
 		.long	SYMBOL_NAME(sys_ni_syscall) /* TUX */
+#ifdef CONFIG_RSBAC
+		.long	SYMBOL_NAME(sys_rsbac) /* Security */
+#else
 		.long	SYMBOL_NAME(sys_ni_syscall) /* Security */
+#endif
 		.long	SYMBOL_NAME(sys_gettid)
 /* 225 */	.long	SYMBOL_NAME(sys_readahead)
 		.long	SYMBOL_NAME(sys_ni_syscall) /* setxattr */
diff -urN -x rsbac trunk/arch/arm/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/arm/kernel/ptrace.c
--- trunk/arch/arm/kernel/ptrace.c	2006-06-01 10:31:05.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/arm/kernel/ptrace.c	2006-06-01 10:32:36.000000000 +0200
@@ -23,6 +23,11 @@
 #include <asm/pgtable.h>
 #include <asm/system.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #include "ptrace.h"
 
 #define REG_PC	15
@@ -696,12 +701,38 @@
 	struct task_struct *child;
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -720,6 +751,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/cris/config.in linux-2.4.32-rsbac-1.2.7/arch/cris/config.in
--- trunk/arch/cris/config.in	2006-06-01 10:31:20.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/cris/config.in	2006-06-01 10:32:47.000000000 +0200
@@ -177,6 +177,15 @@
 source drivers/telephony/Config.in
 
 mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'ATA/IDE/MFM/RLL support'
 
 tristate 'ATA/IDE/MFM/RLL support' CONFIG_IDE
diff -urN -x rsbac trunk/arch/cris/defconfig linux-2.4.32-rsbac-1.2.7/arch/cris/defconfig
--- trunk/arch/cris/defconfig	2006-06-01 10:31:20.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/cris/defconfig	2006-06-01 10:32:47.000000000 +0200
@@ -121,6 +121,192 @@
 # CONFIG_ETRAX_DS1302 is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
diff -urN -x rsbac trunk/arch/cris/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/cris/kernel/ptrace.c
--- trunk/arch/cris/kernel/ptrace.c	2006-06-01 10:31:20.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/cris/kernel/ptrace.c	2006-06-01 10:32:46.000000000 +0200
@@ -49,6 +49,11 @@
 #include <asm/system.h>
 #include <asm/processor.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * does not yet catch signals sent when the child dies.
  * in exit.c or in signal.c.
@@ -105,12 +110,38 @@
 	struct task_struct *child;
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -127,6 +158,26 @@
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/i386/config.in linux-2.4.32-rsbac-1.2.7/arch/i386/config.in
--- trunk/arch/i386/config.in	2006-06-01 10:31:17.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/i386/config.in	2006-06-01 10:32:44.000000000 +0200
@@ -351,6 +351,15 @@
 
 source drivers/parport/Config.in
 
+mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
 source drivers/pnp/Config.in
 
 source drivers/block/Config.in
diff -urN -x rsbac trunk/arch/i386/defconfig linux-2.4.32-rsbac-1.2.7/arch/i386/defconfig
--- trunk/arch/i386/defconfig	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/i386/defconfig	2006-06-01 10:32:44.000000000 +0200
@@ -139,6 +139,192 @@
 # CONFIG_PARPORT is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Plug and Play configuration
 #
 CONFIG_PNP=y
diff -urN -x rsbac trunk/arch/i386/kernel/entry.S linux-2.4.32-rsbac-1.2.7/arch/i386/kernel/entry.S
--- trunk/arch/i386/kernel/entry.S	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/i386/kernel/entry.S	2006-06-01 10:32:44.000000000 +0200
@@ -627,7 +627,11 @@
 	.long SYMBOL_NAME(sys_getdents64)	/* 220 */
 	.long SYMBOL_NAME(sys_fcntl64)
 	.long SYMBOL_NAME(sys_ni_syscall)	/* reserved for TUX */
+#ifdef CONFIG_RSBAC
+	.long SYMBOL_NAME(sys_rsbac)		/* Reserved for Security */
+#else
 	.long SYMBOL_NAME(sys_ni_syscall)	/* Reserved for Security */
+#endif
 	.long SYMBOL_NAME(sys_gettid)
 	.long SYMBOL_NAME(sys_readahead)	/* 225 */
 	.long SYMBOL_NAME(sys_setxattr)
diff -urN -x rsbac trunk/arch/i386/kernel/ioport.c linux-2.4.32-rsbac-1.2.7/arch/i386/kernel/ioport.c
--- trunk/arch/i386/kernel/ioport.c	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/i386/kernel/ioport.c	2006-06-01 10:32:44.000000000 +0200
@@ -15,6 +15,11 @@
 #include <linux/smp_lock.h>
 #include <linux/stddef.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, short base, short extent, int new_value)
 {
@@ -57,10 +62,35 @@
 	struct thread_struct * t = &current->thread;
 	struct tss_struct * tss = init_tss + smp_processor_id();
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_SIZE*32))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
 		return -EPERM;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ioperm(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_ioports;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -105,13 +135,38 @@
 	unsigned int level = regs->ebx;
 	unsigned int old = (regs->eflags >> 12) & 3;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (level > 3)
 		return -EINVAL;
+
 	/* Trying to gain more privileges? */
 	if (level > old) {
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
 	}
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_iopl(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_ioports;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	regs->eflags = (regs->eflags & 0xffffcfff) | (level << 12);
 	return 0;
 }
diff -urN -x rsbac trunk/arch/i386/kernel/process.c linux-2.4.32-rsbac-1.2.7/arch/i386/kernel/process.c
--- trunk/arch/i386/kernel/process.c	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/i386/kernel/process.c	2006-06-01 10:32:44.000000000 +0200
@@ -499,7 +499,11 @@
 		:"=&a" (retval), "=&S" (d0)
 		:"0" (__NR_clone), "i" (__NR_exit),
 		 "r" (arg), "r" (fn),
+#ifdef CONFIG_RSBAC
+		 "b" (flags | CLONE_VM | CLONE_KTHREAD)
+#else
 		 "b" (flags | CLONE_VM)
+#endif
 		: "memory");
 
 	return retval;
diff -urN -x rsbac trunk/arch/i386/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/i386/kernel/ptrace.c
--- trunk/arch/i386/kernel/ptrace.c	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/i386/kernel/ptrace.c	2006-06-01 10:32:44.000000000 +0200
@@ -21,6 +21,11 @@
 #include <asm/i387.h>
 #include <asm/debugreg.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * does not yet catch signals sent when the child dies.
  * in exit.c or in signal.c.
@@ -153,12 +158,37 @@
 	struct user * dummy = NULL;
 	int i, ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -177,6 +207,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/ia64/config.in linux-2.4.32-rsbac-1.2.7/arch/ia64/config.in
--- trunk/arch/ia64/config.in	2006-06-01 10:31:23.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ia64/config.in	2006-06-01 10:32:51.000000000 +0200
@@ -188,6 +188,15 @@
 fi # HP_SIM
 
 mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'SCSI support'
 
 tristate 'SCSI support' CONFIG_SCSI
diff -urN -x rsbac trunk/arch/ia64/defconfig linux-2.4.32-rsbac-1.2.7/arch/ia64/defconfig
--- trunk/arch/ia64/defconfig	2006-06-01 10:31:21.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ia64/defconfig	2006-06-01 10:32:49.000000000 +0200
@@ -214,6 +214,192 @@
 # CONFIG_FUSION_LAN is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # ATA/IDE/MFM/RLL support
 #
 CONFIG_IDE=y
diff -urN -x rsbac trunk/arch/ia64/kernel/entry.S linux-2.4.32-rsbac-1.2.7/arch/ia64/kernel/entry.S
--- trunk/arch/ia64/kernel/entry.S	2006-06-01 10:31:21.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ia64/kernel/entry.S	2006-06-01 10:32:48.000000000 +0200
@@ -1446,7 +1446,12 @@
 	data8 ia64_ni_syscall
 	data8 ia64_ni_syscall
 	data8 ia64_ni_syscall
+#ifdef CONFIG_RSBAC
+	/* we use 1270, until sys_security gets defined here */
+	data8 sys_rsbac				// 1270
+#else
 	data8 ia64_ni_syscall			// 1270
+#endif
 	data8 ia64_ni_syscall
 	data8 ia64_ni_syscall
 	data8 ia64_ni_syscall
diff -urN -x rsbac trunk/arch/ia64/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/ia64/kernel/ptrace.c
--- trunk/arch/ia64/kernel/ptrace.c	2006-06-01 10:31:21.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ia64/kernel/ptrace.c	2006-06-01 10:32:48.000000000 +0200
@@ -28,6 +28,11 @@
 #include <asm/perfmon.h>
 #endif
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #define offsetof(type,field)    ((unsigned long) &((type *) 0)->field)
 
 /*
@@ -1274,12 +1279,38 @@
 	struct switch_stack *sw;
 	long ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
 		goto out;
@@ -1299,6 +1330,25 @@
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/m68k/config.in linux-2.4.32-rsbac-1.2.7/arch/m68k/config.in
--- trunk/arch/m68k/config.in	2006-06-01 10:31:15.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/m68k/config.in	2006-06-01 10:32:42.000000000 +0200
@@ -178,6 +178,15 @@
 fi
 
 mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'ATA/IDE/MFM/RLL support'
 
 tristate 'ATA/IDE/MFM/RLL support' CONFIG_IDE
diff -urN -x rsbac trunk/arch/m68k/defconfig linux-2.4.32-rsbac-1.2.7/arch/m68k/defconfig
--- trunk/arch/m68k/defconfig	2006-06-01 10:31:13.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/m68k/defconfig	2006-06-01 10:32:41.000000000 +0200
@@ -60,6 +60,192 @@
 # CONFIG_MODULES is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
diff -urN -x rsbac trunk/arch/m68k/kernel/entry.S linux-2.4.32-rsbac-1.2.7/arch/m68k/kernel/entry.S
--- trunk/arch/m68k/kernel/entry.S	2006-06-01 10:31:13.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/m68k/kernel/entry.S	2006-06-01 10:32:41.000000000 +0200
@@ -654,6 +654,13 @@
 	.long SYMBOL_NAME(sys_removexattr)
 	.long SYMBOL_NAME(sys_lremovexattr)
 	.long SYMBOL_NAME(sys_fremovexattr)
+#ifdef CONFIG_RSBAC
+	/* we use 240, until sys_security gets defined here */
+	.rept 239-234
+		.long sys_ni_syscall
+	.endr
+	.long sys_rsbac
+#endif
 
 	.rept NR_syscalls-(.-SYMBOL_NAME(sys_call_table))/4
 		.long SYMBOL_NAME(sys_ni_syscall)
diff -urN -x rsbac trunk/arch/m68k/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/m68k/kernel/ptrace.c
--- trunk/arch/m68k/kernel/ptrace.c	2006-06-01 10:31:13.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/m68k/kernel/ptrace.c	2006-06-01 10:32:41.000000000 +0200
@@ -26,6 +26,11 @@
 #include <asm/system.h>
 #include <asm/processor.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * does not yet catch signals sent when the child dies.
  * in exit.c or in signal.c.
@@ -105,12 +110,38 @@
 	struct task_struct *child;
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -129,6 +160,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/mips/defconfig linux-2.4.32-rsbac-1.2.7/arch/mips/defconfig
--- trunk/arch/mips/defconfig	2006-06-01 10:31:26.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/mips/defconfig	2006-06-01 10:32:54.000000000 +0200
@@ -168,6 +168,192 @@
 # CONFIG_ISAPNP is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
diff -urN -x rsbac trunk/arch/mips/kernel/irix5sys.h linux-2.4.32-rsbac-1.2.7/arch/mips/kernel/irix5sys.h
--- trunk/arch/mips/kernel/irix5sys.h	2006-06-01 10:31:25.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/mips/kernel/irix5sys.h	2006-06-01 10:32:54.000000000 +0200
@@ -261,7 +261,11 @@
 SYS(irix_unimp, 0)
 SYS(irix_unimp, 0)
 SYS(irix_unimp, 0)
+#ifdef CONFIG_RSBAC
+SYS(sys_rsbac, 2) 			/* 1240 */
+#else
 SYS(irix_unimp, 0)
+#endif
 SYS(irix_unimp, 0)
 SYS(irix_unimp, 0)
 SYS(irix_unimp, 0)
diff -urN -x rsbac trunk/arch/mips/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/mips/kernel/ptrace.c
--- trunk/arch/mips/kernel/ptrace.c	2006-06-01 10:31:25.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/mips/kernel/ptrace.c	2006-06-01 10:32:54.000000000 +0200
@@ -29,6 +29,11 @@
 #include <asm/cpu.h>
 #include <asm/fpu.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Called by kernel/ptrace.c when detaching..
  *
@@ -44,6 +49,12 @@
 	struct task_struct *child;
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 #if 0
 	printk("ptrace(r=%d,pid=%d,addr=%08lx,data=%08lx)\n",
@@ -56,6 +67,25 @@
 			ret = -EPERM;
 			goto out;
 		}
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -74,6 +104,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/mips/kernel/syscalls.h linux-2.4.32-rsbac-1.2.7/arch/mips/kernel/syscalls.h
--- trunk/arch/mips/kernel/syscalls.h	2006-06-01 10:31:25.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/mips/kernel/syscalls.h	2006-06-01 10:32:54.000000000 +0200
@@ -235,7 +235,11 @@
 SYS(sys_madvise, 3)
 SYS(sys_getdents64, 3)
 SYS(sys_fcntl64, 3)				/* 4220 */
-SYS(sys_ni_syscall, 0)
+#ifdef CONFIG_RSBAC
+SYS(sys_rsbac, 2)				/* Security */
+#else
+SYS(sys_ni_syscall, 0)				/* Security */
+#endif
 SYS(sys_gettid, 0)
 SYS(sys_readahead, 5)
 SYS(sys_setxattr, 5)
diff -urN -x rsbac trunk/arch/mips64/defconfig linux-2.4.32-rsbac-1.2.7/arch/mips64/defconfig
--- trunk/arch/mips64/defconfig	2006-06-01 10:31:10.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/mips64/defconfig	2006-06-01 10:32:40.000000000 +0200
@@ -161,6 +161,192 @@
 # CONFIG_MTD is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Parallel port support
 #
 # CONFIG_PARPORT is not set
diff -urN -x rsbac trunk/arch/mips64/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/mips64/kernel/ptrace.c
--- trunk/arch/mips64/kernel/ptrace.c	2006-06-01 10:31:10.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/mips64/kernel/ptrace.c	2006-06-01 10:32:40.000000000 +0200
@@ -31,6 +31,11 @@
 #include <asm/uaccess.h>
 #include <asm/bootinfo.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Called by kernel/ptrace.c when detaching..
  *
@@ -289,6 +294,12 @@
 	struct task_struct *child;
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 #if 0
 	printk("ptrace(r=%d,pid=%d,addr=%08lx,data=%08lx)\n",
@@ -300,6 +311,26 @@
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -318,6 +349,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/mips64/kernel/scall_64.S linux-2.4.32-rsbac-1.2.7/arch/mips64/kernel/scall_64.S
--- trunk/arch/mips64/kernel/scall_64.S	2006-06-01 10:31:10.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/mips64/kernel/scall_64.S	2006-06-01 10:32:40.000000000 +0200
@@ -312,7 +312,11 @@
 	PTR	sys_ni_syscall			/* res. for getpmsg */
 	PTR	sys_ni_syscall			/* 5175  for putpmsg */
 	PTR	sys_ni_syscall			/* res. for afs_syscall */
-	PTR	sys_ni_syscall			/* res. for security */
+#ifdef CONFIG_RSBAC
+	PTR	sys_rsbac			/* Security */
+#else
+	PTR	sys_ni_syscall			/* Security */
+#endif
 	PTR	sys_gettid
 	PTR	sys_readahead
 	PTR	sys_setxattr			/* 5180 */
diff -urN -x rsbac trunk/arch/mips64/kernel/scall_o32.S linux-2.4.32-rsbac-1.2.7/arch/mips64/kernel/scall_o32.S
--- trunk/arch/mips64/kernel/scall_o32.S	2006-06-01 10:31:10.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/mips64/kernel/scall_o32.S	2006-06-01 10:32:40.000000000 +0200
@@ -545,7 +545,11 @@
 	sys	sys_madvise	3
 	sys	sys_getdents64	3
 	sys	sys32_fcntl64	3			/* 4220 */
-	sys	sys_ni_syscall	0
+#ifdef CONFIG_RSBAC
+	sys	sys_rsbac	2		/* Security */
+#else
+	sys	sys_ni_syscall	0		/* Security */
+#endif
 	sys	sys_gettid	0
 	sys	sys32_readahead	5
 	sys	sys_setxattr	5
diff -urN -x rsbac trunk/arch/parisc/config.in linux-2.4.32-rsbac-1.2.7/arch/parisc/config.in
--- trunk/arch/parisc/config.in	2006-06-01 10:31:08.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/parisc/config.in	2006-06-01 10:32:38.000000000 +0200
@@ -131,6 +131,15 @@
 fi
 endmenu
 
+mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
 if [ "$CONFIG_NET" = "y" ]; then
    mainmenu_option next_comment
    comment 'Network device support'
diff -urN -x rsbac trunk/arch/parisc/defconfig linux-2.4.32-rsbac-1.2.7/arch/parisc/defconfig
--- trunk/arch/parisc/defconfig	2006-06-01 10:31:08.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/parisc/defconfig	2006-06-01 10:32:38.000000000 +0200
@@ -61,6 +61,192 @@
 # CONFIG_PM is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Parallel port support
 #
 CONFIG_PARPORT=y
diff -urN -x rsbac trunk/arch/parisc/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/parisc/kernel/ptrace.c
--- trunk/arch/parisc/kernel/ptrace.c	2006-06-01 10:31:07.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/parisc/kernel/ptrace.c	2006-06-01 10:32:37.000000000 +0200
@@ -22,6 +22,11 @@
 #include <asm/processor.h>
 #include <asm/offset.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /* These are used in entry.S, syscall_restore_rfi.  We need to record the
  * current stepping mode somewhere other than in PSW, because there is no
  * concept of saving and restoring the users PSW over a syscall.  We choose
@@ -95,12 +100,38 @@
 	long oaddr=addr, odata=data;
 #endif
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -119,6 +150,25 @@
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/parisc/kernel/syscall.S linux-2.4.32-rsbac-1.2.7/arch/parisc/kernel/syscall.S
--- trunk/arch/parisc/kernel/syscall.S	2006-06-01 10:31:07.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/parisc/kernel/syscall.S	2006-06-01 10:32:38.000000000 +0200
@@ -606,6 +606,14 @@
 	ENTRY_SAME(readahead)          
 	ENTRY_SAME(tkill)
 
+#ifdef CONFIG_RSBAC
+	/* we use 220, until sys_security gets defined here */
+	.rept 219-197
+		ENTRY_SAME(ni_syscall)
+	.endr
+	ENTRY_SAME(rsbac)
+#endif
+
 .end
 
 	/* Make sure nothing else is placed on this page */
diff -urN -x rsbac trunk/arch/ppc/config.in linux-2.4.32-rsbac-1.2.7/arch/ppc/config.in
--- trunk/arch/ppc/config.in	2006-06-01 10:31:10.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ppc/config.in	2006-06-01 10:32:40.000000000 +0200
@@ -470,6 +470,15 @@
 fi
 
 mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'ATA/IDE/MFM/RLL support'
 
 tristate 'ATA/IDE/MFM/RLL support' CONFIG_IDE
diff -urN -x rsbac trunk/arch/ppc/defconfig linux-2.4.32-rsbac-1.2.7/arch/ppc/defconfig
--- trunk/arch/ppc/defconfig	2006-06-01 10:31:09.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ppc/defconfig	2006-06-01 10:32:39.000000000 +0200
@@ -84,6 +84,192 @@
 CONFIG_CMDLINE="console=ttyS0,9600 console=tty0 root=/dev/sda2"
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
diff -urN -x rsbac trunk/arch/ppc/kernel/misc.S linux-2.4.32-rsbac-1.2.7/arch/ppc/kernel/misc.S
--- trunk/arch/ppc/kernel/misc.S	2006-06-01 10:31:09.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ppc/kernel/misc.S	2006-06-01 10:32:39.000000000 +0200
@@ -1010,7 +1010,10 @@
  */
 _GLOBAL(arch_kernel_thread)
 	mr	r6,r3		/* function */
-	ori	r3,r5,CLONE_VM	/* flags */
+	ori     r3,r5,CLONE_VM  /* flags*/
+#ifdef CONFIG_RSBAC
+	oris    r3,r3,CLONE_KTHREAD>>16
+#endif
 	li	r0,__NR_clone
 	sc
 	cmpi	0,r3,0		/* parent or child? */
@@ -1284,7 +1287,11 @@
 	.long sys_ni_syscall 	/*	reserved for sys_futex */
 	.long sys_ni_syscall 	/*	reserved for sys_sched_setaffinity */
 	.long sys_ni_syscall 	/*	reserved for sys_sched_getaffinity */
+#ifdef CONFIG_RSBAC
+	.long sys_rsbac 	/*	reserved for sys_security */
+#else
 	.long sys_ni_syscall 	/*	reserved for sys_security */
+#endif
 	.long sys_ni_syscall 	/* 225	reserved for Tux */
 	.long sys_ni_syscall 	/*	reserved for sys_sendfile64 */
 	.long sys_ni_syscall 	/*	reserved for sys_io_setup */
diff -urN -x rsbac trunk/arch/ppc/kernel/mk_defs.c linux-2.4.32-rsbac-1.2.7/arch/ppc/kernel/mk_defs.c
--- trunk/arch/ppc/kernel/mk_defs.c	2006-06-01 10:31:08.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ppc/kernel/mk_defs.c	2006-06-01 10:32:38.000000000 +0200
@@ -120,6 +120,9 @@
 	DEFINE(RESULT, STACK_FRAME_OVERHEAD+offsetof(struct pt_regs, result));
 	DEFINE(TRAP, STACK_FRAME_OVERHEAD+offsetof(struct pt_regs, trap));
 	DEFINE(CLONE_VM, CLONE_VM);
+#ifdef CONFIG_RSBAC
+	DEFINE(CLONE_KTHREAD, CLONE_KTHREAD);
+#endif
 	DEFINE(MM_PGD, offsetof(struct mm_struct, pgd));
 
 	/* About the CPU features table */
diff -urN -x rsbac trunk/arch/ppc/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/ppc/kernel/ptrace.c
--- trunk/arch/ppc/kernel/ptrace.c	2006-06-01 10:31:09.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ppc/kernel/ptrace.c	2006-06-01 10:32:39.000000000 +0200
@@ -30,6 +30,11 @@
 #include <asm/pgtable.h>
 #include <asm/system.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Set of msr bits that gdb can change on behalf of a process.
  */
@@ -172,11 +177,37 @@
 	struct task_struct *child;
 	int ret = -EPERM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -195,6 +226,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/ppc64/config.in linux-2.4.32-rsbac-1.2.7/arch/ppc64/config.in
--- trunk/arch/ppc64/config.in	2006-06-01 10:31:18.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ppc64/config.in	2006-06-01 10:32:45.000000000 +0200
@@ -115,6 +115,15 @@
 fi
 
 mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'ATA/IDE/MFM/RLL support'
 
 tristate 'ATA/IDE/MFM/RLL support' CONFIG_IDE
diff -urN -x rsbac trunk/arch/ppc64/defconfig linux-2.4.32-rsbac-1.2.7/arch/ppc64/defconfig
--- trunk/arch/ppc64/defconfig	2006-06-01 10:31:18.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ppc64/defconfig	2006-06-01 10:32:45.000000000 +0200
@@ -124,6 +124,192 @@
 # CONFIG_KHTTPD is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 #    SCTP Configuration (EXPERIMENTAL)
 #
 CONFIG_IPV6_SCTP__=y
diff -urN -x rsbac trunk/arch/ppc64/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/ppc64/kernel/ptrace.c
--- trunk/arch/ppc64/kernel/ptrace.c	2006-06-01 10:31:18.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/ppc64/kernel/ptrace.c	2006-06-01 10:32:45.000000000 +0200
@@ -31,6 +31,11 @@
 #include <asm/pgtable.h>
 #include <asm/system.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Set of msr bits that gdb can change on behalf of a process.
  */
@@ -121,11 +126,37 @@
 	struct task_struct *child;
 	int ret = -EPERM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -144,6 +175,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/s390/config.in linux-2.4.32-rsbac-1.2.7/arch/s390/config.in
--- trunk/arch/s390/config.in	2006-06-01 10:31:19.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/s390/config.in	2006-06-01 10:32:46.000000000 +0200
@@ -64,6 +64,15 @@
 bool 'VM shared kernel support' CONFIG_SHARED_KERNEL
 endmenu
 
+mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
 source drivers/s390/Config.in
 
 if [ "$CONFIG_NET" = "y" ]; then
diff -urN -x rsbac trunk/arch/s390/defconfig linux-2.4.32-rsbac-1.2.7/arch/s390/defconfig
--- trunk/arch/s390/defconfig	2006-06-01 10:31:19.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/s390/defconfig	2006-06-01 10:32:46.000000000 +0200
@@ -52,6 +52,192 @@
 # CONFIG_SHARED_KERNEL is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Block device drivers
 #
 CONFIG_BLK_DEV_LOOP=y
diff -urN -x rsbac trunk/arch/s390/kernel/entry.S linux-2.4.32-rsbac-1.2.7/arch/s390/kernel/entry.S
--- trunk/arch/s390/kernel/entry.S	2006-06-01 10:31:19.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/s390/kernel/entry.S	2006-06-01 10:32:45.000000000 +0200
@@ -572,9 +572,20 @@
 	.long  sys_ni_syscall		 /* 235 - reserved for fremovexattr */
 	.long  sys_gettid
 	.long  sys_tkill
+#ifdef CONFIG_RSBAC
+	/* we use 250, until sys_security gets defined here */
+	.rept 249-237
+		.long sys_ni_syscall
+ 	.endr
+	.long sys_rsbac
+	.rept  255-250
+	.long  sys_ni_syscall
+	.endr
+#else
 	.rept  255-237
 	.long  sys_ni_syscall
 	.endr
+#endif
 
 /*
  * Program check handler routine
diff -urN -x rsbac trunk/arch/s390/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/s390/kernel/ptrace.c
--- trunk/arch/s390/kernel/ptrace.c	2006-06-01 10:31:19.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/s390/kernel/ptrace.c	2006-06-01 10:32:45.000000000 +0200
@@ -38,6 +38,11 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 
 void FixPerRegisters(struct task_struct *task)
 {
@@ -222,12 +227,38 @@
 	int copied;
 	ptrace_area   parea; 
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	if (request == PTRACE_TRACEME) 
 	{
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -244,6 +275,26 @@
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) 
 	{
 		ret = ptrace_attach(child);
diff -urN -x rsbac trunk/arch/s390x/config.in linux-2.4.32-rsbac-1.2.7/arch/s390x/config.in
--- trunk/arch/s390x/config.in	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/s390x/config.in	2006-06-01 10:32:44.000000000 +0200
@@ -68,6 +68,15 @@
 endmenu
 
 
+mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
 source drivers/s390/Config.in
 
 if [ "$CONFIG_NET" = "y" ]; then
diff -urN -x rsbac trunk/arch/s390x/defconfig linux-2.4.32-rsbac-1.2.7/arch/s390x/defconfig
--- trunk/arch/s390x/defconfig	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/s390x/defconfig	2006-06-01 10:32:44.000000000 +0200
@@ -53,6 +53,192 @@
 # CONFIG_SHARED_KERNEL is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Block device drivers
 #
 CONFIG_BLK_DEV_LOOP=y
diff -urN -x rsbac trunk/arch/s390x/kernel/entry.S linux-2.4.32-rsbac-1.2.7/arch/s390x/kernel/entry.S
--- trunk/arch/s390x/kernel/entry.S	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/s390x/kernel/entry.S	2006-06-01 10:32:44.000000000 +0200
@@ -605,9 +605,20 @@
 	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 235 - reserved for fremovexattr */
 	.long  SYSCALL(sys_gettid,sys_gettid)
 	.long  SYSCALL(sys_tkill,sys_tkill)
+#ifdef CONFIG_RSBAC
+	/* we use 250, until sys_security gets defined here */
+	.rept 249-237
+		.long SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.endr
+	.long  SYSCALL(sys_rsbac,sys32_rsbac_wrapper)
+	.rept  255-250
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
+	.endr
+#else
 	.rept  255-237
 	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
 	.endr
+#endif
 
 /*
  * Program check handler routine
diff -urN -x rsbac trunk/arch/s390x/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/s390x/kernel/ptrace.c
--- trunk/arch/s390x/kernel/ptrace.c	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/s390x/kernel/ptrace.c	2006-06-01 10:32:44.000000000 +0200
@@ -44,6 +44,11 @@
 #define parent_31bit 0
 #endif
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 
 void FixPerRegisters(struct task_struct *task)
 {
@@ -431,12 +436,39 @@
 #define sizeof_parent_long 8
 #define dataptr (u8 *)&data
 #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	if (request == PTRACE_TRACEME) 
 	{
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -453,6 +485,26 @@
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) 
 	{
 		ret = ptrace_attach(child);
diff -urN -x rsbac trunk/arch/s390x/kernel/wrapper32.S linux-2.4.32-rsbac-1.2.7/arch/s390x/kernel/wrapper32.S
--- trunk/arch/s390x/kernel/wrapper32.S	2006-06-01 10:31:16.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/s390x/kernel/wrapper32.S	2006-06-01 10:32:44.000000000 +0200
@@ -1098,6 +1098,15 @@
 	llgfr	%r4,%r4			# long
 	jg	sys32_fstat64		# branch to system call
 
+ 
+#ifdef CONFIG_RSBAC
+	.globl	sys32_rsbac_wrapper
+sys32_rsbac_wrapper:
+	llgfr	%r2,%r2			# unsigned int
+	llgtr	%r3,%r3			# void *
+	jg	sys_rsbac		# branch to system call
+#endif
+ 
 	.globl	sys32_stime_wrapper
 sys32_stime_wrapper:
 	llgtr	%r2,%r2			# int *
diff -urN -x rsbac trunk/arch/sh/config.in linux-2.4.32-rsbac-1.2.7/arch/sh/config.in
--- trunk/arch/sh/config.in	2006-06-01 10:31:29.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sh/config.in	2006-06-01 10:32:55.000000000 +0200
@@ -302,6 +302,15 @@
 fi
 
 mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'ATA/IDE/MFM/RLL support'
 
 tristate 'ATA/IDE/MFM/RLL support' CONFIG_IDE
diff -urN -x rsbac trunk/arch/sh/defconfig linux-2.4.32-rsbac-1.2.7/arch/sh/defconfig
--- trunk/arch/sh/defconfig	2006-06-01 10:31:28.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sh/defconfig	2006-06-01 10:32:55.000000000 +0200
@@ -61,6 +61,192 @@
 # CONFIG_MTD is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
diff -urN -x rsbac trunk/arch/sh/kernel/entry.S linux-2.4.32-rsbac-1.2.7/arch/sh/kernel/entry.S
--- trunk/arch/sh/kernel/entry.S	2006-06-01 10:31:28.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sh/kernel/entry.S	2006-06-01 10:32:55.000000000 +0200
@@ -1385,6 +1385,14 @@
  	.long SYMBOL_NAME(sys_tkill)
 	.long SYMBOL_NAME(sys_ni_syscall)
 	.long SYMBOL_NAME(sys_readahead)	/* 225 */
+#ifdef CONFIG_RSBAC
+	/* we use 250, until sys_security gets defined here */
+	.rept 249-225
+		.long SYMBOL_NAME(sys_ni_syscall)
+ 	.endr
+	.long SYMBOL_NAME(sys_rsbac)
+#endif
+
 	/*
 	 * NOTE!! This doesn't have to be exact - we just have
 	 * to make sure we have _enough_ of the "sys_ni_syscall"
diff -urN -x rsbac trunk/arch/sh/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/sh/kernel/ptrace.c
--- trunk/arch/sh/kernel/ptrace.c	2006-06-01 10:31:28.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sh/kernel/ptrace.c	2006-06-01 10:32:55.000000000 +0200
@@ -27,6 +27,11 @@
 #include <asm/processor.h>
 #include <asm/mmu_context.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * does not yet catch signals sent when the child dies.
  * in exit.c or in signal.c.
@@ -145,12 +150,38 @@
 	struct user * dummy = NULL;
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -169,6 +200,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/sh64/config.in linux-2.4.32-rsbac-1.2.7/arch/sh64/config.in
--- trunk/arch/sh64/config.in	2006-06-01 10:31:13.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sh64/config.in	2006-06-01 10:32:41.000000000 +0200
@@ -263,6 +263,15 @@
    source drivers/char/pcmcia/Config.in
 fi
 
+mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
 source fs/Config.in
 
 source drivers/media/Config.in
diff -urN -x rsbac trunk/arch/sh64/defconfig linux-2.4.32-rsbac-1.2.7/arch/sh64/defconfig
--- trunk/arch/sh64/defconfig	2006-06-01 10:31:13.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sh64/defconfig	2006-06-01 10:32:41.000000000 +0200
@@ -319,6 +319,192 @@
 # CONFIG_WATCHDOG is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # File systems
 #
 # CONFIG_QUOTA is not set
diff -urN -x rsbac trunk/arch/sh64/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/sh64/kernel/ptrace.c
--- trunk/arch/sh64/kernel/ptrace.c	2006-06-01 10:31:13.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sh64/kernel/ptrace.c	2006-06-01 10:32:41.000000000 +0200
@@ -33,6 +33,11 @@
 #include <asm/processor.h>
 #include <asm/mmu_context.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /* This mask defines the bits of the SR which the user is not allowed to
    change, which are everything except S, Q, M, PR, SZ, FR. */
 #define SR_MASK      (0xffff8cfd)
@@ -123,12 +128,38 @@
 	struct task_struct *child, *tsk = current;
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    ret = -EPERM;
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -147,6 +178,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/arch/sparc/config.in linux-2.4.32-rsbac-1.2.7/arch/sparc/config.in
--- trunk/arch/sparc/config.in	2006-06-01 10:31:23.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sparc/config.in	2006-06-01 10:32:52.000000000 +0200
@@ -95,6 +95,15 @@
 fi
 
 mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
+mainmenu_option next_comment
 comment 'Block devices'
 
 bool 'Normal floppy disk support' CONFIG_BLK_DEV_FD
diff -urN -x rsbac trunk/arch/sparc/defconfig linux-2.4.32-rsbac-1.2.7/arch/sparc/defconfig
--- trunk/arch/sparc/defconfig	2006-06-01 10:31:23.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sparc/defconfig	2006-06-01 10:32:51.000000000 +0200
@@ -94,6 +94,192 @@
 # CONFIG_MTD is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Misc Linux/SPARC drivers
 #
 CONFIG_SUN_OPENPROMIO=m
diff -urN -x rsbac trunk/arch/sparc/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/sparc/kernel/ptrace.c
--- trunk/arch/sparc/kernel/ptrace.c	2006-06-01 10:31:23.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sparc/kernel/ptrace.c	2006-06-01 10:32:51.000000000 +0200
@@ -22,6 +22,11 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #define MAGIC_CONSTANT 0x80000000
 
 
@@ -263,6 +268,12 @@
 	unsigned long addr2 = regs->u_regs[UREG_I4];
 	struct task_struct *child;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 #ifdef DEBUG_PTRACE
 	{
@@ -287,6 +298,24 @@
 			pt_error_return(regs, EPERM);
 			goto out;
 		}
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "do_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		pt_succ_return(regs, 0);
@@ -310,6 +339,25 @@
 		goto out;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "do_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            pt_error_return(regs, EPERM);
+            goto out_tsk;
+          }
+        #endif
+
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
 		if (ptrace_attach(child)) {
diff -urN -x rsbac trunk/arch/sparc/kernel/systbls.S linux-2.4.32-rsbac-1.2.7/arch/sparc/kernel/systbls.S
--- trunk/arch/sparc/kernel/systbls.S	2006-06-01 10:31:23.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sparc/kernel/systbls.S	2006-06-01 10:32:51.000000000 +0200
@@ -72,6 +72,14 @@
 /*250*/	.long sparc_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
 /*255*/	.long sys_nis_syscall, sys_nis_syscall
 
+#ifdef CONFIG_RSBAC
+	/* we use 270, until sys_security gets defined here */
+	.rept 269-255
+		.long sys_nis_syscall
+	.endr
+	.long sys_rsbac
+#endif
+
 #ifdef CONFIG_SUNOS_EMUL
 	/* Now the SunOS syscall table. */
 
diff -urN -x rsbac trunk/arch/sparc64/config.in linux-2.4.32-rsbac-1.2.7/arch/sparc64/config.in
--- trunk/arch/sparc64/config.in	2006-06-01 10:31:11.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sparc64/config.in	2006-06-01 10:32:41.000000000 +0200
@@ -104,6 +104,16 @@
 source drivers/sbus/char/Config.in
 source drivers/sbus/audio/Config.in
 source drivers/mtd/Config.in
+
+mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
 mainmenu_option next_comment
 comment 'Block devices'
 
diff -urN -x rsbac trunk/arch/sparc64/defconfig linux-2.4.32-rsbac-1.2.7/arch/sparc64/defconfig
--- trunk/arch/sparc64/defconfig	2006-06-01 10:31:11.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sparc64/defconfig	2006-06-01 10:32:40.000000000 +0200
@@ -105,6 +105,192 @@
 CONFIG_PROM_CONSOLE=y
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Frame-buffer support
 #
 CONFIG_FB=y
diff -urN -x rsbac trunk/arch/sparc64/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/sparc64/kernel/ptrace.c
--- trunk/arch/sparc64/kernel/ptrace.c	2006-06-01 10:31:11.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sparc64/kernel/ptrace.c	2006-06-01 10:32:40.000000000 +0200
@@ -27,6 +27,11 @@
 #include <asm/visasm.h>
 #include <asm/spitfire.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #define MAGIC_CONSTANT 0x80000000
 
 /* Returning from ptrace is a bit tricky because the syscall return
@@ -109,6 +114,12 @@
 	unsigned long addr2 = regs->u_regs[UREG_I4];
 	struct task_struct *child;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (current->thread.flags & SPARC_FLAG_32BIT) {
 		addr &= 0xffffffffUL;
 		data &= 0xffffffffUL;
@@ -138,6 +149,25 @@
 			pt_error_return(regs, EPERM);
 			goto out;
 		}
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "do_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		pt_succ_return(regs, 0);
@@ -161,6 +191,26 @@
 		goto out;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            pt_error_return(regs, EPERM);
+            goto out_tsk;
+          }
+        #endif
+
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
 		if (ptrace_attach(child)) {
diff -urN -x rsbac trunk/arch/sparc64/kernel/systbls.S linux-2.4.32-rsbac-1.2.7/arch/sparc64/kernel/systbls.S
--- trunk/arch/sparc64/kernel/systbls.S	2006-06-01 10:31:11.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/sparc64/kernel/systbls.S	2006-06-01 10:32:40.000000000 +0200
@@ -66,7 +66,11 @@
 /*220*/	.word sys32_sigprocmask, sys32_create_module, sys32_delete_module, sys32_get_kernel_syms, sys_getpgid
 	.word sys32_bdflush, sys32_sysfs, sys_nis_syscall, sys32_setfsuid16, sys32_setfsgid16
 /*230*/	.word sys32_select, sys_time, sys_nis_syscall, sys_stime, sys_nis_syscall
+#ifdef CONFIG_RSBAC
+	.word sys_rsbac, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
+#else
 	.word sys_nis_syscall, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
+#endif
 /*240*/	.word sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 	.word sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys32_sched_rr_get_interval, sys32_nanosleep
 /*250*/	.word sys32_mremap, sys32_sysctl, sys_getsid, sys_fdatasync, sys32_nfsservctl
@@ -125,7 +129,11 @@
 /*220*/	.word sys_nis_syscall, sys_create_module, sys_delete_module, sys_get_kernel_syms, sys_getpgid
 	.word sys_bdflush, sys_sysfs, sys_nis_syscall, sys_setfsuid, sys_setfsgid
 /*230*/	.word sys_select, sys_nis_syscall, sys_nis_syscall, sys_stime, sys_nis_syscall
+#ifdef CONFIG_RSBAC
+	.word sys_rsbac, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
+#else
 	.word sys_nis_syscall, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
+#endif
 /*240*/	.word sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 	.word sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys_sched_rr_get_interval, sys_nanosleep
 /*250*/	.word sys64_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
diff -urN -x rsbac trunk/arch/x86_64/config.in linux-2.4.32-rsbac-1.2.7/arch/x86_64/config.in
--- trunk/arch/x86_64/config.in	2006-06-01 10:31:19.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/x86_64/config.in	2006-06-01 10:32:46.000000000 +0200
@@ -132,6 +132,15 @@
 
 source drivers/parport/Config.in
 
+mainmenu_option next_comment
+comment 'Rule Set Based Access Control (RSBAC)'
+
+bool 'Rule Set Based Access Control' CONFIG_RSBAC
+if [ "$CONFIG_RSBAC" = "y" ]; then
+  source rsbac/Config.in
+fi
+endmenu
+
 source drivers/block/Config.in
 
 source drivers/md/Config.in
diff -urN -x rsbac trunk/arch/x86_64/defconfig linux-2.4.32-rsbac-1.2.7/arch/x86_64/defconfig
--- trunk/arch/x86_64/defconfig	2006-06-01 10:31:19.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/x86_64/defconfig	2006-06-01 10:32:46.000000000 +0200
@@ -105,6 +105,192 @@
 # CONFIG_PARPORT is not set
 
 #
+# Rule Set Based Access Control (RSBAC)
+#
+CONFIG_RSBAC=y
+
+#
+# General RSBAC options
+#
+# CONFIG_RSBAC_INIT_THREAD is not set
+CONFIG_RSBAC_PROC=y
+CONFIG_RSBAC_INIT_CHECK=y
+# CONFIG_RSBAC_NO_WRITE is not set
+# CONFIG_RSBAC_MSDOS_WRITE is not set
+CONFIG_RSBAC_AUTO_WRITE=5
+CONFIG_RSBAC_LIST_TRANS=y
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL=3600
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA=y
+CONFIG_RSBAC_DEBUG=y
+# CONFIG_RSBAC_DEV_USER_BACKUP is not set
+CONFIG_RSBAC_SECOFF_UID=400
+# CONFIG_RSBAC_INIT_DELAY is not set
+
+#
+# User Management
+#
+# CONFIG_RSBAC_UM is not set
+CONFIG_RSBAC_UM_DIGEST=y
+# CONFIG_RSBAC_UM_EXCL is not set
+CONFIG_RSBAC_UM_USER_MIN=2000
+CONFIG_RSBAC_UM_GROUP_MIN=2000
+
+#
+# RSBAC networking options
+#
+CONFIG_RSBAC_NET=y
+CONFIG_RSBAC_NET_DEV=y
+# CONFIG_RSBAC_NET_DEV_VIRT is not set
+CONFIG_RSBAC_IND_NETDEV_LOG=y
+CONFIG_RSBAC_NET_OBJ=y
+# CONFIG_RSBAC_NET_OBJ_UNIX is not set
+# CONFIG_RSBAC_NET_OBJ_RW is not set
+CONFIG_RSBAC_IND_NETOBJ_LOG=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAINT is not set
+
+#
+# -------------------------
+#
+
+#
+# Decision module (policy) options
+#
+CONFIG_RSBAC_REG=y
+CONFIG_RSBAC_REG_SAMPLES=y
+
+#
+# -------------------------
+#
+# CONFIG_RSBAC_MAC is not set
+# CONFIG_RSBAC_FC is not set
+# CONFIG_RSBAC_SIM is not set
+# CONFIG_RSBAC_PM is not set
+# CONFIG_RSBAC_DAZ is not set
+CONFIG_RSBAC_FF=y
+
+#
+# FF Policy Options
+#
+# CONFIG_RSBAC_FF_AUTH_PROT is not set
+# CONFIG_RSBAC_FF_GEN_PROT is not set
+CONFIG_RSBAC_RC=y
+
+#
+# RC Policy Options
+#
+CONFIG_RSBAC_RC_AUTH_PROT=y
+CONFIG_RSBAC_RC_GEN_PROT=y
+# CONFIG_RSBAC_RC_BACKUP is not set
+CONFIG_RSBAC_RC_NET_DEV_PROT=y
+CONFIG_RSBAC_RC_NET_OBJ_PROT=y
+CONFIG_RSBAC_RC_NR_P_LISTS=4
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE=999999
+CONFIG_RSBAC_AUTH=y
+
+#
+# AUTH Policy Options
+#
+CONFIG_RSBAC_AUTH_AUTH_PROT=y
+# CONFIG_RSBAC_AUTH_DAC_OWNER is not set
+# CONFIG_RSBAC_AUTH_GROUP is not set
+# CONFIG_RSBAC_AUTH_LEARN is not set
+CONFIG_RSBAC_ACL=y
+
+#
+# ACL Policy Options
+#
+# CONFIG_RSBAC_ACL_SUPER_FILTER is not set
+CONFIG_RSBAC_ACL_AUTH_PROT=y
+CONFIG_RSBAC_ACL_GEN_PROT=y
+# CONFIG_RSBAC_ACL_BACKUP is not set
+# CONFIG_RSBAC_ACL_LEARN is not set
+CONFIG_RSBAC_ACL_NET_DEV_PROT=y
+CONFIG_RSBAC_ACL_NET_OBJ_PROT=y
+CONFIG_RSBAC_CAP=y
+
+#
+# CAP Policy Options
+#
+CONFIG_RSBAC_CAP_PROC_HIDE=y
+# CONFIG_RSBAC_CAP_AUTH_PROT is not set
+CONFIG_RSBAC_JAIL=y
+
+#
+# JAIL Policy Options
+#
+CONFIG_RSBAC_JAIL_NET_ADJUST=y
+CONFIG_RSBAC_JAIL_NET_DEV_PROT=y
+CONFIG_RSBAC_JAIL_NR_P_LISTS=4
+CONFIG_RSBAC_PAX=y
+
+#
+# PAX Policy Options
+#
+# CONFIG_RSBAC_PAX_AUTH_PROT is not set
+# CONFIG_RSBAC_PAX_DEFAULT is not set
+CONFIG_RSBAC_RES=y
+
+#
+# RES Policy Options
+#
+# CONFIG_RSBAC_RES_AUTH_PROT is not set
+
+#
+# ----------------
+#
+
+#
+# Softmode and switching
+#
+CONFIG_RSBAC_SWITCH=y
+CONFIG_RSBAC_SOFTMODE=y
+# CONFIG_RSBAC_SOFTMODE_SYSRQ is not set
+CONFIG_RSBAC_SOFTMODE_IND=y
+
+#
+# Logging
+#
+CONFIG_RSBAC_IND_LOG=y
+CONFIG_RSBAC_IND_USER_LOG=y
+CONFIG_RSBAC_IND_PROG_LOG=y
+CONFIG_RSBAC_LOG_PROGRAM_FILE=y
+CONFIG_RSBAC_LOG_FULL_PATH=y
+CONFIG_RSBAC_MAX_PATH_LEN=512
+# CONFIG_RSBAC_LOG_PSEUDO is not set
+CONFIG_RSBAC_RMSG=y
+CONFIG_RSBAC_RMSG_NOSYSLOG=y
+
+#
+# ----------------
+#
+# CONFIG_RSBAC_LOG_REMOTE is not set
+# CONFIG_RSBAC_SYM_REDIR is not set
+# CONFIG_RSBAC_SYM_REDIR_UID is not set
+# CONFIG_RSBAC_SYM_REDIR_RC is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+# CONFIG_RSBAC_ALLOW_DAC_DISABLE is not set
+
+#
+# Other RSBAC options
+#
+# CONFIG_RSBAC_SECDEL is not set
+# CONFIG_RSBAC_RW is not set
+# CONFIG_RSBAC_IPC_SEM is not set
+# CONFIG_RSBAC_DAC_OWNER is not set
+# CONFIG_RSBAC_PROC_HIDE is not set
+CONFIG_RSBAC_FREEZE=y
+# CONFIG_RSBAC_SYSLOG is not set
+# CONFIG_RSBAC_DAT_VISIBLE is not set
+# CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT is not set
+# CONFIG_RSBAC_USER_MOD_IOPERM is not set
+# CONFIG_RSBAC_FAKE_ROOT_UID is not set
+CONFIG_RSBAC_XSTATS=y
+
+#
 # Block devices
 #
 CONFIG_BLK_DEV_FD=y
diff -urN -x rsbac trunk/arch/x86_64/ia32/ia32entry.S linux-2.4.32-rsbac-1.2.7/arch/x86_64/ia32/ia32entry.S
--- trunk/arch/x86_64/ia32/ia32entry.S	2006-06-01 10:31:19.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/x86_64/ia32/ia32entry.S	2006-06-01 10:32:46.000000000 +0200
@@ -353,7 +353,11 @@
 	.quad sys_getdents64	/* 220 getdents64 */ 
 	.quad sys32_fcntl64	
 	.quad sys_ni_syscall	/* tux */
+#ifdef CONFIG_RSBAC
+	.quad sys_rsbac		/* security */
+#else
 	.quad sys_ni_syscall    /* security */
+#endif
 	.quad sys_gettid	
 	.quad sys_readahead	/* 225 */ 
 	.quad quiet_ni_syscall  /* xattr syscalls 226-237 */
diff -urN -x rsbac trunk/arch/x86_64/kernel/ioport.c linux-2.4.32-rsbac-1.2.7/arch/x86_64/kernel/ioport.c
--- trunk/arch/x86_64/kernel/ioport.c	2006-06-01 10:31:19.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/x86_64/kernel/ioport.c	2006-06-01 10:32:46.000000000 +0200
@@ -16,6 +16,11 @@
 #include <linux/smp_lock.h>
 #include <linux/stddef.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, short base, short extent, int new_value)
 {
@@ -36,10 +41,35 @@
 	struct thread_struct * t = &current->thread;
 	struct tss_struct * tss = init_tss + smp_processor_id();
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_SIZE*32))
 		return -EINVAL;
 	if (turn_on && !capable(CAP_SYS_RAWIO))
 		return -EPERM;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ioperm(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_ioports;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
 	 * IO bitmap up. ioperm() is much less timing critical than clone(),
@@ -85,6 +115,12 @@
 {
 	unsigned int old = (regs.eflags >> 12) & 3;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (level > 3)
 		return -EINVAL;
 	/* Trying to gain more privileges? */
@@ -92,6 +128,24 @@
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
 	}
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_iopl(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_ioports;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	regs.eflags = (regs.eflags & 0xffffffffffffcfff) | (level << 12);
 	return 0;
 }
diff -urN -x rsbac trunk/arch/x86_64/kernel/ptrace.c linux-2.4.32-rsbac-1.2.7/arch/x86_64/kernel/ptrace.c
--- trunk/arch/x86_64/kernel/ptrace.c	2006-06-01 10:31:19.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/arch/x86_64/kernel/ptrace.c	2006-06-01 10:32:46.000000000 +0200
@@ -23,6 +23,11 @@
 #include <asm/i387.h>
 #include <asm/debugreg.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * does not yet catch signals sent when the child dies.
  * in exit.c or in signal.c.
@@ -181,6 +186,12 @@
 	struct user * dummy = NULL;
 	long i, ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* This lock_kernel fixes a subtle race with suid exec */
 	lock_kernel();
 	ret = -EPERM;
@@ -188,6 +199,25 @@
 		/* are we already being traced? */
 		if (current->ptrace & PT_PTRACED)
 			goto out;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.trace_request = request;
+                if (!rsbac_adf_request(R_TRACE,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_trace_request,
+                                       rsbac_attribute_value))
+                  {
+                    goto out;
+                  }
+                #endif
+
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
 		ret = 0;
@@ -206,6 +236,25 @@
 	if (pid == 1)		/* you may not mess with init */
 		goto out_tsk;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_ptrace(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.trace_request = request;
+        if (!rsbac_adf_request(R_TRACE,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_trace_request,
+                               rsbac_attribute_value))
+          {
+            ret = -EPERM;
+            goto out_tsk;
+          }
+        #endif
+
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
 		goto out_tsk;
diff -urN -x rsbac trunk/Documentation/Configure.help linux-2.4.32-rsbac-1.2.7/Documentation/Configure.help
--- trunk/Documentation/Configure.help	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/Documentation/Configure.help	2006-06-01 10:32:35.000000000 +0200
@@ -63,6 +63,1516 @@
 # 1995-2000 by Axel Boldt and many others and are governed by the GNU
 # General Public License.
 
+Rule Set Based Access Control (RSBAC)
+CONFIG_RSBAC
+  RSBAC adds 'real' access control to the kernel. Currently there are
+  the following policies supported: Mandatory Access Control, Functional
+  Control, Security Information Modification, Privacy Model, Malware Scan,
+  File Flags, Role Compatibility, Authentication Enforcement,
+  Access Control Lists, Linux Capabilities and Jail.
+
+  Additionally, you can add your own policies, e.g. as kernel module
+  (see Module Registration (REG)).
+
+  Since RSBAC only uses the virtual file system, files on all mounted
+  filesystems are monitored. Still, on some filesystems no access
+  control information is stored, although it is kept in kernel memory.
+  These file system types are currently PROC, NFS, CODAFS, SMBFS, NCPFS,
+  ISO9660 and (configurable below) all MSDOS types (inodes may change
+  between boots). You can make attribute backups and restore them on
+  each boot to keep them persistent.
+
+  RSBAC will increase your (uncompressed) kernel size by up to 700K with
+  all options turned on, plus allocated memory for dynamical data
+  structures. If you are tight on memory, it is generally a good idea
+  to turn off those features you do not need.
+
+  Please read the RSBAC docs in Documentation/rsbac before installing
+  an RSBAC enabled kernel, since you can easily make your system
+  unaccessible when changing RSBAC configuration...
+
+Initialize RSBAC in separate kernel thread
+CONFIG_RSBAC_INIT_THREAD
+  Some people experienced system hangs, oopses etc. during RSBAC
+  initialization. If you experience this, enabling this option might
+  help.
+
+  At least, init can be timed out and the system more or less comes up
+   - if you are in softmode or maintenance mode, that is...
+
+Initialization timeout in seconds
+CONFIG_RSBAC_MAX_INIT_TIME
+  Maximum time in seconds the init process waits for rsbac_initd to
+  complete the RSBAC initialization process via rsbac_do_init(). After
+  this time, RSBAC initialization is considered as failed and
+  rsbac_initd is killed.
+
+RSBAC proc support
+CONFIG_RSBAC_PROC
+  If enabled, RSBAC adds one directory to the main proc dir, called
+  rsbac-info.
+  The files in rsbac-info give read access to RSBAC statistics and
+  read and write access to many RSBAC settings.
+
+  This option is strongly recommended.
+
+  See README-proc in Documentation/rsbac for rsbac-info dir entries.
+
+Check on init
+CONFIG_RSBAC_INIT_CHECK
+  Check RSBAC attribute consistency at boot time.
+
+  Note: This cannot check attributes on other than the root filesystem.
+        You should run rsbac_check regularly, e.g. once per day from cron.
+
+Disable RSBAC writing to disk
+CONFIG_RSBAC_NO_WRITE
+  If enabled, RSBAC treats all file system types as read-only. No
+  attributes are saved and all settings are only kept in memory.
+  If off, only PROC, NFS, CODAFS, SMBFS, NCPFS, ISO9660 and all MSDOS
+  filesystems are read-only.
+
+  If you only want to turn off automatical writing, but keep the
+  syscall sys_rsbac_write() to write by hand, set auto write to 0
+  instead.
+
+  This switch is intended for testing purposes only and off by
+  default.
+
+RSBAC auto writing to disk
+CONFIG_RSBAC_AUTO_WRITE
+  If not 0, a kernel daemon saves all changed RSBAC attributes to disk
+  every n seconds. You can also initiate each saving by syscall
+  sys_rsbac_write(). The interval can be changed via proc interface.
+
+Allow attribute writing on MSDOS filesystems
+CONFIG_RSBAC_MSDOS_WRITE
+  This setting allows attribute writing on MSDOS filesystems, like FAT,
+  VFAT, UMSDOS. Turning it on makes these attributes persistent through
+  reboots.
+  Unfortunately, MSDOS filesystems do not guarantee reproducable inode
+  numbers on reboots - so attributes might be applied to wrong files or
+  get lost. Watch for warning messages from rsbac_check.
+
+  Use with care, thus turned off by default.
+
+  As a more reliable solution turn it off, make regular attribute backups
+  and restore after mounting the disk.
+
+Support transactions
+CONFIG_RSBAC_LIST_TRANS
+  This option enables support for RSBAC configuration transactions.
+
+  Any user can start a transaction with the rsbac_list_ta() syscall
+  (e.g. via the rsbac_list_ta admin tool) and use the returned
+  transaction number for further administration calls to collect a set
+  of allowed changes.
+
+  When finished, a simple commit applies all these changes atomically
+  to the system, while the forget command or a transaction timeout
+  (see next option) remove the complete set of proposes changes.
+
+  The number of transactions in parallel is not limited, but each list,
+  which has been changed by one transaction, is locked against changes
+  by all other transactions. Such change attempts return the error
+  -RSBAC_EBUSY, while using invalid transaction numbers returns the
+  error -RSBAC_EINVALIDTRANSACTION. This means that when using
+  transactions both error codes should be checked for each call. When
+  a list is BUSY, it is the user's choice to retry later, forget all
+  changes or leave it as it is.
+
+  Changes with transaction number 0 (no transaction) and automatic
+  changes by the system always affect both the real lists and all
+  transaction lists.
+
+Maximum transaction time in seconds
+CONFIG_RSBAC_LIST_TRANS_MAX_TTL
+  When starting a transaction, the ttl parameter sets its maximum
+  lifetime, after which it will be automatically removed, if
+  it has not been renewed in time.
+  This option sets the maximum allowed lifetime for any transaction in
+  seconds. The default value is 3600, one hour.
+
+Randomize transaction numbers
+CONFIG_RSBAC_LIST_TRANS_RANDOM_TA
+  Usually, transaction numbers start with one and increase with every
+  new transaction. With this option, they will be randomized to make
+  it a bit more difficult to tamper with other admins' transactions.
+
+  However, this is no real protection and makes transactions less human
+  friendly because of large numbers - use the transaction key or the
+  user limit to get more security for transaction handling.
+
+RSBAC debugging support
+CONFIG_RSBAC_DEBUG
+  This option enables many debugging switches to examine RSBAC internals
+  as well as request sanity checks.
+  Most of the debugging switches can be set with rsbac_debug_* kernel
+  parameters or via proc interface at /proc/rsbac-info/debug (see
+  Documentation/rsbac/README-proc).
+
+  This option is recommended to be on, but you may as well turn it off,
+  if performance really matters and your RSBAC system runs without
+  problems.
+
+Provide DEV and USER backup files
+CONFIG_RSBAC_DEV_USER_BACKUP
+  If on, you will find images of the USER and DEV target general attribute
+  list files in /proc/rsbac-info/backup. Since attribute backup should be
+  done with tools, this is usually not needed and thus off by default.
+
+RSBAC default security officer user ID
+CONFIG_RSBAC_SECOFF_UID
+  The number n given here specifies, which user IDs should be used for the
+  Security Officer/Role Admin/Supervisor (n), the PM model Data Protection
+  Officer (n+1) and the PM model TP Manager (n+2) in the default
+  configuration at the first boot.
+
+  Warning: This value should only be changed, if you have a severe
+           conflict with the default values of 400 to 402. After the first
+           boot the defaults are set and saved, and changes to this option
+           will not have any effect.
+
+Delayed init for initial ramdisk
+CONFIG_RSBAC_INIT_DELAY
+  This option allows to delay RSBAC initialization until the first mount
+  of a real disk partition (major number > 1). It is intended to be used
+  with initial ramdisks, which mount the final root partition during
+  boot.
+
+  You can trigger initialization at a specific partition mount with the
+  kernel parameter rsbac_delayed_root=major:minor. If the given partition
+  is not mounted and thus RSBAC not initialized, you can also call the
+  rsbac_init() system call at any time, e.g. with the rsbac_init admin
+  tool.
+
+  To disable delayed init, you have to use the kernel parameter
+  rsbac_no_delay_init. This will force the standard initialization after
+  the first root mount. If this is your initrd, the RSBAC setup in there
+  will be used instead of the configuration on your real root device.
+
+  Warning: The delayed init option requires the RSBAC init code to be
+           kept in memory all the time, which increases your kernel
+           memory usage by a few 10s of KB. It should only be used in
+           combination with an initial ramdisk.
+
+User management
+CONFIG_RSBAC_UM
+  Enable RSBAC User Management, a fully passwd/shadow compatible, but
+  kernel based user and Linux group database. All changes are access
+  controlled with USER and GROUP targets.
+
+  You will need the PAM and NSS modules from the RSBAC admin tools
+  contrib section to make transparent use of this feature.
+
+  If the SHA1 algorithm is available through the crypto API, passwords
+  can also optionally be encrypted (next option).
+
+Use Crypto API Digest SHA1
+CONFIG_RSBAC_UM_DIGEST
+  If enabled, all passwords are hashed with SHA1 digests. To make the
+  resulting hash values unique, the password functions add a 32 Bit salt
+  value to the password string before hashing.
+
+Exclusive user management
+CONFIG_RSBAC_UM_EXCL
+  With this option, RSBAC makes sure that only user and group IDs it knows
+  about can be used within the system. The User Management component will
+  only make consistency checks, but the AUTH module will enforce the
+  exclusive use.
+
+Minimum auto user ID
+CONFIG_RSBAC_UM_USER_MIN
+  When users get added without giving a desired ID, the system picks the
+  lowest available number starting from the value.
+
+Minimum auto group ID
+CONFIG_RSBAC_UM_GROUP_MIN
+  When groups get added without giving a desired ID, the system picks the
+  lowest available number starting from the value.
+
+RSBAC Maintenance Kernel (Use with care!)
+CONFIG_RSBAC_MAINT
+  A maintenance kernel is useful, if the system got unaccessible,
+  e.g. because the user attributes for Administrator (root), Security
+  Officer (400) or Data Protection Officer (401, PM only) got lost and
+  have to be reset.
+  However, in most cases enabling softmode can have the same effect for
+  you, but gives the additional benefit of logging the usually denied
+  accesses.
+
+  This option turns some of the RSBAC configuration options below
+  off and disables all access control. Still, you should keep those
+  modules turned on, which you would like to administrate in
+  maintenance mode, because only then their data structures are
+  accessible.
+
+RSBAC net support
+CONFIG_RSBAC_NET
+  The net support switch adds generic network device, network template
+  and network object attribute support.
+
+  Also, general settings of IPv4 (INET) networks are controlled through
+  the SCD targets 'network' and 'firewall'.
+
+  To get network device or object access control, you have to enable the
+  conditional switches below, as well as the individual model switches
+  for network access control.
+
+Net device control
+CONFIG_RSBAC_NET_DEV
+  With this option turned on, reading and modifying network device
+  settings, like binding addresses to devices etc., are controlled as
+  NETDEV targets. NETDEV objects are identified by their device name.
+
+Treat virtual devices as individuals
+CONFIG_RSBAC_NET_DEV_VIRT
+  Turn this on, if you want to access control virtual devices
+  independently from their base device. Due to the possible number of
+  virtual devices, be careful with this option.
+
+Individual network device logging
+CONFIG_RSBAC_IND_NETDEV_LOG
+  Enable individual log levels for every request type for network
+  devices. Log levels are none, denied requests, full, request based.
+  Default value is request based for all request types.
+
+  If this option is off, only general log levels for requests are used
+  (same as individual logging for all objects set to request based).
+
+Net object control (sockets)
+CONFIG_RSBAC_NET_OBJ
+  This option enables access control for all socket based communication,
+  except the UNIX address family (controlled by extra option).
+
+  Access control is based on network object (NETOBJ) targets. Default
+  values for NETOBJ attributes are derived from the network template
+  (NETTEMP object), whose description matches this particular network
+  object.
+  
+  Matching is performed from lowest to highest template number. If no
+  template matches, general NETOBJ default values will be used.
+  Note: The behaviour in this case is model dependent!
+
+  Socket system calls are matched to special request types with matching
+  names.
+   
+  NETTEMP objects themselves are protected as NETTEMP targets with
+  repective requests.
+
+Control UNIX address family
+CONFIG_RSBAC_NET_OBJ_UNIX
+  The UNIX address family is used by many programs for host internal
+  communication, resulting in very many requests.
+  
+  Turn this option on, if you want full control, and off, if you want
+  better system performance and easier setup.
+
+Also intercept network object read and write
+CONFIG_RSBAC_NET_OBJ_RW
+  If on, READ and WRITE requests on sockets are also checked.
+
+Individual network object logging
+CONFIG_RSBAC_IND_NETOBJ_LOG
+  Enable individual log levels for every request type for network objects.
+  Log levels are none, denied requests, full, request based.
+  Default value is request based for all request types.
+
+  For easier setup, the log levels are set on the network templates, not
+  the individual network objects.
+
+  If this option is off, only general log levels for requests are used
+  (same as individual logging for all objects set to request based).
+
+Support for Registration of decision modules (REG)
+CONFIG_RSBAC_REG
+  If enabled, RSBAC supports runtime registering and unregistering of
+  additional decision module functions, e.g. from kernel modules.
+
+  Possible functions are for decision, notification and file contents
+  overwrite decisions and for write-to-disk notifications.
+
+  Additionally, syscall functions can be registered to the REG syscall
+  dispatcher.
+
+  See Documentation/rsbac/README-reg, Documentation/rsbac/html/reg.htm
+  and the module examples in Documentation/rsbac/reg_sample for details.
+
+Build REG sample modules
+CONFIG_RSBAC_REG_SAMPLES
+  Build the REG sample kernel modules. These modules show how to use the
+  RSBAC infrastructure, but do not perform any access control.
+  
+  The modules will be named reg_sample1, reg_sample2 and reg_sample3.
+
+RSBAC support for MAC policy
+CONFIG_RSBAC_MAC
+  Mandatory Access Control follows the Bell-LaPadula security model,
+  in which all users and resources are classified in levels of
+  confidentiality. Additionally, each subject and object has a set out
+  of 64 categories.
+
+  To read from a resource, a user's level must be at least as high as
+  that of the resource, and the user's category set must be a superset
+  of the category set of the resource.
+  To write to a resource, it must be at least as confidential as the
+  user, and its category set must be a superset of the user's.
+
+  Please read the extended MAC model documentation in
+  Documentation/rsbac/html/models.htm.
+
+MAC inherit as default
+CONFIG_RSBAC_MAC_DEF_INHERIT
+  If enabled, the inheritable attributes security_level and
+  mac_categories for files, fifos and directories get the default value
+  'inherit' instead of the old style real value. This reduces the amount
+  of attributes to be set significantly, because files, fifos and dirs
+  inherit their parent dir's attribute values automatically. Inheritance
+  ends at root dir /.
+
+  This setting should be kept constant between different RSBAC kernels
+  in use to avoid confusion for administrators/security officers,
+  rsbac_check() and backup.
+
+  Please note that inheritance is not conforming to the Bell-LaPadula
+  model, where all objects must be individually labeled.
+
+Smart inherit
+CONFIG_RSBAC_MAC_SMART_INHERIT
+  If enabled, the MAC model checks whether the values of attributes
+  security_level and mac_categories for new objects would already be in
+  effect via inheritance. Only if the inherited value differs, the new
+  values are set explicitely. Otherwise the default value 'inherit' is
+  automatically applied.
+
+  This option largely reduces the amount of new attribute objects needed
+  for whole created directory trees with same values. It thus saves
+  memory and CPU cycles.
+
+  However, inheritance is not conforming to the Bell-LaPadula model,
+  where all objects must be individually labeled - here we are even
+  denying explicit labeling of new objects. Use with care.
+
+MAC protection for AUTH module
+CONFIG_RSBAC_MAC_AUTH_PROT
+  This option makes MAC care for AUTH module settings, e.g. attributes
+  auth_may_setuid, auth_may_set_cap and the kernel-only pseudo attributes
+  auth_add_f_cap, auth_remove_f_cap, auth_get_caplist. Those settings
+  are treated like MAC settings.
+
+  See AUTH model description for details.
+
+MAC protection for User Management
+CONFIG_RSBAC_MAC_UM_PROT
+  This option makes MAC care for User Management settings, e.g. creation,
+  change or deletion of users or groups.
+
+  See User Management description for details.
+
+MAC protection for GENeral attributes
+CONFIG_RSBAC_MAC_GEN_PROT
+  If on, MAC protects general attributes (GEN module) like its own, i.e.,
+  only security officers may change them.
+
+Light MAC edition
+CONFIG_RSBAC_MAC_LIGHT
+  This option makes MAC easier to use, but a bit less conforming to the
+  Bell-LaPadula model.
+   1. Allow R_CREATE of new files WITHOUT any checking. This way, higher
+      level objects can be created in a lower level directory.
+   2. Allow R_MOUNT and R_UMOUNT to ANY user (only Administrator in base
+      MAC version).
+
+Give trusted processes full read access
+CONFIG_RSBAC_MAC_TRUSTED_READ
+  Normally, a mac_trusted process may only violate *-property, i.e., it
+  may write to any level within its owner's level range from
+  min_security_level to security_level, regardless of its current level
+  and the max_read boundary. This makes a user's trusted flag equivalent
+  to the combination of write_up and write_down flag.
+
+  With this option turned on, a trusted process may also read from any
+  such level despite its current level and the min_write boundary. This
+  adds the meaning of the read_up flag to the trusted flag.
+
+  Please note that the mac_auto privilege with automatic current level
+  and read/write boundary adjustment as well as the object mac_shared
+  flag are always tried before trusted, write_up, write_down and read_up.
+
+Reset current level on each execute
+RSBAC_MAC_RESET_CURR
+  If enabled, the current process level is reset to the user's initial
+  level on every execute.
+
+Log all automatic changes to current level
+CONFIG_RSBAC_MAC_LOG_LEVEL_CHANGE
+  If both the effective mac_auto flag at an executable and the
+  mac_allow_auto flag at the user executing it are set, current levels
+  may be automatically adjusted to allow access, where it would otherwise
+  be denied.
+
+  This option logs each such automatic change to the process current
+  level, because it means a change to the current access rights.
+
+MAC network device protection
+CONFIG_RSBAC_MAC_NET_DEV_PROT
+  If on, protect network devices: Only System Administrators may configure
+  them.
+
+MAC network object protection
+CONFIG_RSBAC_MAC_NET_OBJ_PROT
+  Turn this on to have real MAC access control on network objects based
+  on security levels and categories.
+  
+  The default attribute values are derived from those of the matching
+  network template.
+
+MAC number of process lists
+CONFIG_RSBAC_MAC_NR_P_LISTS
+  When using MAC model, every process in the system will get individual
+  attributes set. This means that with many active processes, the list
+  lookups will become slower.
+
+  To speed them up, RSBAC uses a hash table to split the MAC process
+  attribute lists into several shorter ones. This option sets the number
+  of these lists.
+
+  In most cases, the default of 4 will be sufficient. However, if you
+  plan to have very many processes, a higher value will reduce lookup
+  time at the cost of additional list headers.
+
+RSBAC support for FC policy
+CONFIG_RSBAC_FC
+  The Functional Control classifies users as general, system
+  administrator and security administrator and objects as general,
+  system and security. General users are only allowed to *access*
+  general objects, system administrators general and system objects
+  and security administrators general and security objects.
+
+FC protection for AUTH module
+CONFIG_RSBAC_FC_AUTH_PROT
+  This option makes FC care for AUTH module settings, e.g. attributes
+  auth_may_setuid, auth_may_set_cap and the kernel-only pseudo attributes
+  auth_add_f_cap, auth_remove_f_cap, auth_get_caplist. Those settings
+  are treated like FC settings.
+
+  See AUTH model description for details.
+
+FC protection for GENeral attributes
+CONFIG_RSBAC_FC_GEN_PROT
+  If on, FC protects general attributes (GEN module) like its own, i.e.,
+  only security officers may change them.
+
+FC network device protection
+CONFIG_RSBAC_FC_NET_DEV_PROT
+  If on, protect network devices: Only System Administrators may configure
+  them.
+
+FC network object protection
+CONFIG_RSBAC_FC_NET_OBJ_PROT
+  Turn this on to have real FC access control on network objects based
+  on FC object_categories.
+
+  The default attribute values are derived from those of the matching
+  network template.
+
+RSBAC support for SIM policy
+CONFIG_RSBAC_SIM
+  The Security Information Modification classifies objects as
+  security information and none-security information. Only users
+  classified as security administrators (see FC policy) are allowed
+  to *modify* security information.
+
+SIM protection for AUTH module
+CONFIG_RSBAC_SIM_AUTH_PROT
+  This option makes SIM care for AUTH module settings, e.g. attributes
+  auth_may_setuid, auth_may_set_cap and the kernel-only pseudo attributes
+  auth_add_f_cap, auth_remove_f_cap, auth_get_caplist. Those settings
+  are treated like SIM settings.
+
+  See AUTH model description for details.
+
+SIM protection for GENeral attributes
+CONFIG_RSBAC_SIM_GEN_PROT
+  If on, SIM protects general attributes (GEN module) like its own, i.e.,
+  only security officers may change them.
+
+SIM network device protection
+CONFIG_RSBAC_SIM_NET_DEV_PROT
+  If on, protect network devices: Only System Administrators may configure
+  them.
+
+SIM network object protection
+CONFIG_RSBAC_SIM_NET_OBJ_PROT
+  Turn this on to have real SIM access control on network objects based
+  on the SIM data type.
+
+  The default attribute values are derived from those of the matching
+  network template.
+
+RSBAC support for PM policy
+CONFIG_RSBAC_PM
+  The Privacy Model defines tasks, for which personal data of certain
+  classes has been collected. Similar to the Clark Wilson Model it
+  defines Transformation Procedures to be applied by authorised users
+  to data classes performing tasks they are authorised for. In
+  addition, the TP's task must match the tasks data in this class was
+  collected for.
+  Also, users are classified as general, security administrator
+  and privacy agent with appropriate access rights.
+
+  See Documentation/rsbac for details.
+
+PM protection for AUTH module
+CONFIG_RSBAC_PM_AUTH_PROT
+  This option makes PM care for AUTH module settings, e.g. attributes
+  auth_may_setuid, auth_may_set_cap and the kernel-only pseudo attributes
+  auth_add_f_cap, auth_remove_f_cap, auth_get_caplist. Those settings
+  are treated like PM settings.
+
+  Real AUTH attributes can only be set with PM tickets and sys_rsbac_pm
+  system call, which calls all other decision modules before setting.
+
+  See AUTH model description for details.
+
+PM protection for GENeral attributes
+CONFIG_RSBAC_PM_GEN_PROT
+  If on, PM protects general attributes (GEN module) so that only
+  security officers may change them.
+
+RSBAC support for DAZuko policy
+CONFIG_RSBAC_DAZ
+  The Dazuko policy provides the Dazuko malware scanning interface.
+  Scanning results may optionally be cached, see CONFIG_RSBAC_DAZ_CACHE
+  below.
+
+  Only programs marked as scanners may connect to the Dazuko interface,
+  and only DAZ security administrators are allowed to modify daz_scanner
+  or daz_scanned.
+
+Cache scanning results
+CONFIG_RSBAC_DAZ_CACHE
+  With this option, all scanning results get cached for the time
+  specified below.
+
+Scanning result lifetime in seconds
+CONFIG_RSBAC_DAZ_TTL
+  Specify the time in seconds a scanning result is kept. After this time
+  the object will be rescanned on the next access.
+
+  Use 0 for unlimited, default is 86400 (1 day). Set to 1 to force a
+  fast rescan.
+
+Keep scanning results over reboot
+CONFIG_RSBAC_DAZ_PERSIST
+  If on, file scanning results, which are younger than their life time
+  limit, are kept persistently during reboots.
+
+  Using this option can reduce the amount of scanning, but it cannot
+  protect against file modifications while another kernel is booted.
+
+Dazuko device major number
+CONFIG_RSBAC_DAZ_DEV_MAJOR
+  Specify the major char device number for /dev/dazuko,
+  which is used for scanner registration and communication.
+
+  Use 0 to let the system pick one.
+
+RSBAC support for FF policy
+CONFIG_RSBAC_FF
+  The File Flag module adds some flags for files and dirs to the
+  system. Current flags are:
+
+  execute_only (files): Only request EXECUTE is granted
+
+  read_only (files and dirs): Only non-modifying requests are granted
+
+  search_only (dirs): All file/subdir accesses need full path, no
+    listing or modification of dir is granted.
+
+  write_only (files): Only writing requests are granted, useful for
+    logging etc. Specially good if inherited to new files from a dir.
+
+  no_execute (files): No execution of this file allowed.
+
+  add_inherited (files and dirs): Add (or) flags of parent dir to own
+    flags. This last flag makes the file flags powerful: simply set
+    a file flag for a dir (e.g. no_execute on /home), and the whole
+    subtree is affected.
+
+  no_rename_or_delete (files and dirs, not inherited): Prevents renaming
+    or deleting an object, e.g to keep a directory structure fixed.
+
+  append_only (files): the only write access allowed is APPEND_OPEN. Good
+    for log files.
+
+FF protection for AUTH module
+CONFIG_RSBAC_FF_AUTH_PROT
+  This option makes FF care for AUTH module settings, e.g. attributes
+  auth_may_setuid, auth_may_set_cap and the kernel-only pseudo attributes
+  auth_add_f_cap, auth_remove_f_cap, auth_get_caplist. Those settings
+  are treated like FF settings.
+
+  See AUTH model description for details.
+
+FF protection for User Management
+CONFIG_RSBAC_FF_UM_PROT
+  This option makes FF care for User Management settings, e.g. creation,
+  change or deletion of users or groups.
+
+  See User Management description for details.
+
+FF protection for GENeral attributes
+CONFIG_RSBAC_FF_GEN_PROT
+  If on, FF protects general attributes (GEN module) like its own, i.e.,
+  only security officers may change them.
+
+RSBAC support for RC policy
+CONFIG_RSBAC_RC
+  The Role Compatibility model is a powerful and flexible role based
+  model. It supports an unlimited number of roles and types. Types are
+  grouped per target type. Each role definition has compatibility
+  vectors for all types and other roles.
+
+  Additionally, there are default create/chown/execute types and several
+  special values for inheritance options.
+  Roles can also be forced by executable file attributes, similar to
+  the setuid/setgid mechanism in Unix file systems.
+
+  For Details see Documentation/rsbac/html/models.htm.
+
+Provide RC backup files
+CONFIG_RSBAC_RC_BACKUP
+  If on, RC provides its binary ACI data files in /proc/rsbac-info/backup.
+  Because of better backup options with admin tools, this is off by
+  default.
+
+RC protection for AUTH module
+CONFIG_RSBAC_RC_AUTH_PROT
+  This option makes RC care for AUTH module settings, e.g. attributes
+  auth_may_setuid, auth_may_set_cap and the kernel-only pseudo attributes
+  auth_add_f_cap, auth_remove_f_cap, auth_get_caplist.
+
+  These settings are protected by SCD type compatibility with type
+  auth_administration, which is set for default role 1 (Role Admin).
+
+  See AUTH model description for details.
+
+RC protection for User Management
+CONFIG_RSBAC_RC_UM_PROT
+  This option makes RC care for User Management settings, e.g. creation,
+  change or deletion of users or groups.
+
+  See User Management description for details.
+
+RC protection for GENeral attributes
+CONFIG_RSBAC_RC_GEN_PROT
+  If on, RC protects general attributes (GEN module) like its own, e.g.,
+  in default setup only Role Admins may change them.
+
+RC network device protection
+CONFIG_RSBAC_RC_NET_DEV_PROT
+  If on, protect network devices based on RC NETDEV type compatibilities.
+
+RC network object protection
+CONFIG_RSBAC_RC_NET_OBJ_PROT
+  Turn this on to have real RC access control on network objects based
+  on RC type compatibilities.
+
+  The NETOBJ default type values are derived from those of the matching
+  network template.
+
+  Templates themselves are protected through their own template type
+  in attribute rc_type_nt and the nettemp type compatibility settings.
+
+RC check access to UNIX partner process
+CONFIG_RSBAC_RC_NET_OBJ_UNIX_PROCESS
+  This option enables additional checks for UNIX sockets: If a peer
+  process is known (via peer credential), the requesting process also
+  needs the same right as in the NETOBJ request to the RC type of the
+  other process.
+
+  Affected request types are CONNECT, ACCEPT, SEND and RECEIVE. If
+  READ and WRITE checking of network sockets is enabled, these request
+  types are checked as RECEIVE and SEND to avoid possible confusion
+  about read and write accesses to processes.
+
+RC number of process lists
+CONFIG_RSBAC_RC_NR_P_LISTS
+  When using RC model, every process in the system will get individual
+  attributes set. This means that with many active processes, the list
+  lookups will become slower.
+
+  To speed them up, RSBAC uses a hash table to split the RC process
+  attribute lists into several shorter ones. This option sets the number
+  of these lists.
+
+  In most cases, the default of 4 will be sufficient. However, if you
+  plan to have very many processes, a higher value will reduce lookup
+  time at the cost of additional list headers.
+
+RC kernel process type
+CONFIG_RSBAC_RC_KERNEL_PROCESS_TYPE
+  This is the type being assigned to all kernel processes, despite the
+  initiating process owner role's def_process_create_type.
+
+  The default value is 999999. It should only be changed, if you have
+  role number conflicts with your existing configuration.
+
+RSBAC support for AUTH policy
+CONFIG_RSBAC_AUTH
+  This module can be seen as a support module for all others. It
+  restricts CHANGE_OWNER on process targets (setuid) for a process: the
+  request is only granted, if the process has either the auth_may_setuid
+  flag set or the target user ID is in its capability set.
+  The auth_may_setuid flag and the capability set are inherited on
+  execute from the program file.
+
+  Those file capabilities can be set, if all modules grant a
+  MODIFY_ATTRIBUTE request for A_auth_add_f_cap or A_auth_remove_f_cap.
+  Process capabilities can only be added by other processes that have the
+  auth_may_set_cap flag set, which is also inherited from the executed
+  file.
+
+  This way an enforcement of daemon based authentification is possible,
+  as well as a restriction of system daemons to a set of user IDs.
+
+  Warning: If enabled without a login program having auth_may_setuid or a
+           capability set and without a capability setting daemon, you
+           will not be able to login to your system!
+           Use kernel parameter rsbac_auth_enable_login in emergencies or
+           at the first boot to set auth_may_setuid for /bin/login.
+
+  Also see AUTH model description in Documentation/rsbac/html/models.htm.
+
+AUTH module and attribute protection
+CONFIG_RSBAC_AUTH_AUTH_PROT
+  Only, if this option is on, the AUTH module cares for its own
+  protection, otherwise it fully depends on other modules
+  (CONFIG_RSBAC_XX_AUTH_PROT).
+  This is meant for more sophisticated access control than a simple
+  system_role setting to security_officer.
+
+  As a special effect, capability sets are cleared on every write access
+  to reduce system access after tampering.
+
+  See AUTH model description for details.
+
+Protect switching of other modules
+CONFIG_RSBAC_AUTH_OTHER_PROT
+  This option makes AUTH care for the switching of other modules.
+  Useful if you want to prevent switching a module back on,
+  because it cannot protect itself in this case.
+
+AUTH protection for User Management
+CONFIG_RSBAC_AUTH_UM_PROT
+  This option makes AUTH care for User Management settings, e.g. creation,
+  change or deletion of users or groups.
+
+  See User Management description for details.
+
+Always allow setting to same id
+CONFIG_RSBAC_AUTH_ALLOW_SAME
+  Normally, AUTH restricts all setuid and setgid calls, including those
+  to the same uid. This option allows to always change to the same id.
+
+AUTH support for effective and fs owner control
+CONFIG_RSBAC_AUTH_DAC_OWNER
+  If enabled, AUTH also controls the requests CHANGE_DAC_EFF_OWNER
+  (change process effective owner) and CHANGE_DAC_FS_OWNER (change
+  process filesystem owner) on process targets. Changes to these Linux
+  DAC model owner settings do not affect RSBAC, so this option is off
+  by default.
+
+  This option also requires the 'Control DAC process owner (seteuid,
+  setfsuid)' option from the 'Other options', which enables the requests
+  mentioned above.
+
+AUTH support for Linux group control
+CONFIG_RSBAC_AUTH_GROUP
+  If enabled, AUTH also controls the request CHANGE_GROUP
+  (change process group) on process targets. Changes to these Linux
+  DAC model group settings do not affect RSBAC, so this option is off
+  by default.
+
+AUTH support for effective and fs group control
+CONFIG_RSBAC_AUTH_DAC_GROUP
+  If enabled, AUTH also controls the requests CHANGE_DAC_EFF_GROUP
+  (change process effective group) and CHANGE_DAC_FS_GROUP (change
+  process filesystem group) on process targets. Changes to these Linux
+  DAC model owner settings do not affect RSBAC, so this option is off
+  by default.
+
+  This option also requires the 'Control DAC process group (setegid,
+  setfsgid)' option from the 'Other options', which enables the requests
+  mentioned above.
+
+AUTH learning mode support
+CONFIG_RSBAC_AUTH_LEARN
+  With this option, the kernel parameter rsbac_auth_learn makes the AUTH
+  module add all missing capabilities to processes and programs instead
+  of denying the CHANGE_OWNER request.
+
+  Warning: This option is useful, but dangerous, so it should be off on
+           production systems.
+
+RSBAC support for ACL policy
+CONFIG_RSBAC_ACL
+  This turns on the Access Control List module. ACLs are kept on all
+  targets but those of type USER, though for IPC and PROCESS targets
+  there is only one default ACL each.
+
+  Each ACL entry contains subject type (user, rc_role, acl_group),
+  subject id and the rights this subject has. Also, rights are inherited
+  from parents and from a target specific default ACL.
+
+  Most settings have a time-to-live (TTL) option, which automatically
+  removes them after a certain amount of time.
+
+  See Documentation/rsbac/html/models.htm for details.
+
+Allow masking out of SUPERVISOR rights
+CONFIG_RSBAC_ACL_SUPER_FILTER
+  Normally, inheritance masks can never filter out the SUPERVISOR right
+  (which contains all other rights) - it is always inherited.
+
+  If this switch is on, SUPERVISOR *can* be filtered out. This allows
+  separation of duties and privacy, but is also dangerous, because
+  administration can easily become impossible. In this case, you have to
+  reboot into a maintenance kernel to regain access.
+
+  For safety reasons, you must have a USER ACL entry at the target
+  containing the SUPERVISOR right to set a new mask without SUPERVISOR.
+
+ACL protection for AUTH module
+CONFIG_RSBAC_ACL_AUTH_PROT
+  This option makes ACL care for AUTH module settings, e.g. attributes
+  auth_may_setuid, auth_may_set_cap and the kernel-only pseudo attributes
+  auth_add_f_cap, auth_remove_f_cap, auth_get_caplist. Those settings
+  are protected by SCD 'auth_administration' ACL.
+
+  See AUTH model description for AUTH details.
+
+ACL protection for User Management
+CONFIG_RSBAC_ACL_UM_PROT
+  This option makes ACL care for User Management settings, e.g. creation,
+  change or deletion of users or groups.
+
+  See User Management description for details.
+
+ACL protection for GENeral attributes
+CONFIG_RSBAC_ACL_GEN_PROT
+  If on, ACL protects general attributes (GEN module) through
+  the MODIFY_ATTRIBUTE right.
+  In default setup, only user 400 may change them.
+
+Provide ACL backup files
+CONFIG_RSBAC_ACL_BACKUP
+  If on, ACL provides its binary group and group membership data files in
+  /proc/rsbac-info/backup.
+
+ACL learning mode support
+CONFIG_RSBAC_ACL_LEARN
+  If set, you can enable ACL learning mode with rsbac_acl_learn or
+  rsbac_acl_learn_fd kernel parameter. In learning mode, ACL module will
+  automatically add all missing acl entries for filesystem objects.
+
+  Warning: This option is useful, but dangerous, so it should be off on
+           production systems.
+
+ACL network device protection
+CONFIG_RSBAC_ACL_NET_DEV_PROT
+  If on, protect network devices based on individual and default ACLs.
+
+ACL network object protection
+CONFIG_RSBAC_ACL_NET_OBJ_PROT
+  Turn this on to have real ACL access control on network objects based
+  on inherited ACLs.
+
+  When determining a subject's right to a network object (NETOBJ), the
+  following inheritance scheme is used:
+  - If there is an ACL entry at the NETOBJ itself, use it, else
+  - If there is an ACL entry at the matching template, use that, but
+    filter through individual mask, else
+  - If there is an ACL entry in the NETOBJ default ACL, use that, but
+    filter through individual mask and matching template's mask.
+
+  Certainly, user, role and group rights are accumulated as usual.
+
+  Templates themselves are protected through their own individual and
+  default ACLs, which are configured using the NETTEMP_NT target.
+
+RSBAC support for Linux Caps (CAP) policy
+CONFIG_RSBAC_CAP
+  The Linux Capability (CAP) module allows to set minimum and maximum
+  Linux capability sets for single users and programs. These boundaries
+  are applied at CHANGE_OWNER on processes (setuid) and EXECUTE.
+
+  Minimum settings have precedence over maximums, and program settings
+  have precedence over user settings.
+
+  Use this module to run programs that need root privileges from normal
+  user accounts, e.g. file server daemons, or to restrict programs run
+  by root, e.g. certain mail daemons.
+
+  If softmode is enabled and turned on, only the minimum sets are
+  applied.
+
+Support CAP process hiding
+CONFIG_RSBAC_CAP_PROC_HIDE
+  If enabled, you can hide the process properties shown in /proc from
+  other users, e.g. command line and current state. The hiding level is
+  set with the cap_process_hiding process attribute. There are three
+  possible values:
+  0 / off: no hiding.
+  1 / from other users: only processes running for the same user, a CAP
+      security officer or a CAP system admin may read the properties.
+  2 / full: only this process and CAP security officers may read the
+      properties.
+
+  The kernel command line switch rsbac_cap_process_hiding changes the
+  default value from 0 to 1. Thus, every normal user can only see her
+  own process properties.
+
+Support freezing of RSBAC configuration
+CONFIG_RSBAC_FREEZE
+  If enabled, the kernel parameter rsbac_freeze disables all
+  administrative system calls, which change settings.
+
+Also freeze User Management
+CONFIG_RSBAC_FREEZE_UM
+  If enabled, the RSBAC User Management gets frozen, too.
+
+CAP protection for AUTH module
+CONFIG_RSBAC_CAP_AUTH_PROT
+  This option makes CAP care for AUTH module settings, e.g. attributes
+  auth_may_setuid, auth_may_set_cap and the kernel-only pseudo attributes
+  auth_add_f_cap, auth_remove_f_cap, auth_get_caplist. Those settings
+  are protected by the cap_roles admin (read) and security officer (rw).
+
+  See AUTH model description for AUTH details.
+
+Log missing capabilities in capable()
+CONFIG_RSBAC_CAP_LOG_MISSING
+  If checked, the Linux capability check function capable() can log
+  all queries for capabilities, which are missing from the effective
+  set. Enable with rsbac_cap_log_missing kernel parameter or at
+  runtime via proc interface.
+
+  Background: If you limit Linux capabilities for users or programs
+  with the CAP module, some programs fail in secure mode without
+  "NOT_GRANTED" RSBAC log messages, because this Linux internal check
+  failed.
+
+  Please check http://www.rsbac.org/documentation/models.php#cap for
+  more info about how the CAP module works.
+
+RSBAC support for JAIL policy
+CONFIG_RSBAC_JAIL
+  The JAIL module gives you an extended chroot facility, similar to
+  FreeBSD Jails. To put a process into a jail, start it with the
+  rsbac_jail wrapper or make it call the sys_rsbac_jail syscall directly. 
+
+  With RSBAC network object support, jailed processes can only use a
+  designated IP address (if designated address is not 0.0.0.0), and UNIX
+  or INET sockets of type STREAM, DGRAM or RDM. All other families and
+  types, e.g. RAW network access, are generally prohibited.
+
+  From within a jail, only processes and IPC objects of the same jail
+  can be accessed. Jails can be created from within jails, but get
+  limited to the parent jail's filesystem root, IP and flags.
+
+  Additionally, most kernel based administration tasks are forbidden,
+  e.g. creating device special files, setting network addresses, getting
+  or setting RSBAC attributes, changing system settings like name or
+  rlimits etc.
+
+  Several sys_rsbac_jail flags change the jail behaviour:
+  - allow_external_ipc: allow to access IPC objects outside this jail
+  - allow_rlimit: allow to change rlimit
+  - allow_all_net_family: allow to use all network families, not only
+    UNIX and INET (IPv4)
+  - allow_inet_raw: allow to use RAW INET sockets, e.g. for ping
+  - auto_adjust_inet_any: also allow to bind to INET ANY address
+    (0.0.0.0), but always change it to specified address
+    (requires CONFIG_RSBAC_JAIL_NET_ADJUST)
+
+JAIL allow to auto-adjust INET ANY (0.0.0.0) address
+CONFIG_RSBAC_JAIL_NET_ADJUST
+  Turn this option on to allow automatic adjusting of the INET ANY
+  address 0.0.0.0 to the specified address with the
+  auto_adjust_inet_any syscall flag.
+
+JAIL network device protection
+CONFIG_RSBAC_JAIL_NET_DEV_PROT
+  Only with this option enabled, the JAIL module prevents network device
+  configuration from within a jail. Recommended.
+
+JAIL number of process lists
+CONFIG_RSBAC_JAIL_NR_P_LISTS
+  When using JAIL model, every process in the system will get individual
+  attributes set. This means that with many active processes, the list
+  lookups will become slower.
+
+  To speed them up, RSBAC uses a hash table to split the JAIL process
+  attribute lists into several shorter ones. This option sets the number
+  of these lists.
+
+  In most cases, the default of 4 will be sufficient. However, if you
+  plan to have very many processes, a higher value will reduce lookup
+  time at the cost of additional list headers.
+
+Log missing capabilities in capable()
+CONFIG_RSBAC_JAIL_LOG_MISSING
+  If checked, the Linux capability check function capable() can log
+  all queries for capabilities, which are missing from the effective
+  set. Enable with rsbac_jail_log_missing kernel parameter or at
+  runtime via proc interface.
+
+  Background: If you limit Linux capabilities for users or programs
+  within a JAIL, some programs fail in secure mode without
+  "NOT_GRANTED" RSBAC log messages, because this Linux internal check
+  failed.
+
+  Please check http://www.rsbac.org/documentation/models.php#jail for
+  more info about how the JAIL module works.
+
+RSBAC support for PAX policy
+CONFIG_RSBAC_PAX
+  The PAX module allows to administrate the PaX flags of programs and
+  processes. To get these flags enforced, you need to enable
+  "direct" MAC integration in the PaX config menu under the main
+  kernel menu.
+
+  PaX is a separate Linux kernel patch available at pax.grsecurity.net.
+  Please have a look at its homepage to get some more info.
+
+Change PAX default flags (PeMRxS)
+CONFIG_RSBAC_PAX_DEFAULT
+  This option allows to change the PaX default flags for all files from
+  PeMRxS to any other value.
+  Please be careful, if you change this setting, specially with existing
+  configurations - unexpected failures of previously running programs
+  might happen. Nothing you could not fix by reconfiguration, though.
+
+RSBAC support for Linux Resources (RES) policy
+CONFIG_RSBAC_RES
+  The Linux Resources (RES) module allows to set minimum and maximum
+  Linux resource sets for single users and programs. These boundaries
+  are applied at CHANGE_OWNER on processes (setuid) and EXECUTE.
+
+  Minimum settings have precedence over maximums, and program settings
+  have precedence over user settings.
+
+  Default values for all users can be set at user RSBAC_ALL_USER with
+  uid 4294967292 ((rsbac_uid_t) -4).
+
+  If softmode is enabled and turned on, only the minimum sets are
+  applied.
+
+
+RSBAC policies switchable
+CONFIG_RSBAC_SWITCH
+  If enabled, the configured policies can be switched on or off by
+  syscall sys_rsbac_switch().
+
+  Of course, switching modules off is performed under their own control.
+
+  Warning: Though switching off is access controlled itself, a way to
+  switch off access control is always dangerous!
+
+Allow to switch stateful modules back on
+CONFIG_RSBAC_SWITCH_ON
+  Some modules must be active all the time to keep their state intact,
+  e.g. to have correct process roles or security levels. This means
+  that after turning such a module off, it is in an inconsistent state
+  and can block the whole system when turned back on. Most prominent
+  examples are RC and MAC. Some modules only loose part of their
+  ability to protect the system, e.g. JAIL does not jail new processes.
+
+  By default, modules that can block the system may never be turned on,
+  only off. Enable this switch to be able to turn them back on - you
+  have been warned!
+
+RSBAC softmode
+CONFIG_RSBAC_SOFTMODE
+  This option enables RSBAC softmode support. In softmode, all
+  decisions and logging are performed, but the result that is returned to
+  enforcement is always DO_NOT_CARE. This means that access control is
+  effectively off!
+
+  Single exception: even in softmode, all access to rsbac attribute dirs
+  is always NOT_GRANTED.
+
+  After boot, softmode will be off, unless kernel parameter
+  'rsbac_softmode' has been given. It can be turned on via proc interface
+  with
+  echo debug softmode <value> > /proc/rsbac-info/debug,
+  where <value> is 1 (on) or 0 (off).
+  If policy switching is enabled, you can also use sys_rsbac_switch, e.g.
+  via switch_module command line tool.
+
+  Switching softmode on or off is access controlled with an ADF request
+  SWITCH_MODULE for module SOFTMODE. The RSBAC builtin modules only allow
+  softmode under the same conditions as switching themselves off.
+
+  Warning: For security reasons, this option should only be used for
+  debugging of your RSBAC administration settings!
+
+  Additionally, you might get strange effects during the notification
+  call rsbac_adf_set_attr(), because the request should not have been
+  granted in the first place. Unexpected access decisions might occur,
+  because attributes might have misleading values!
+
+Toggle softmode with SysRq-X
+CONFIG_RSBAC_SOFTMODE_SYSRQ
+  If this setting and kernel SysRq are enabled, you can toggle softmode
+  with SysRq-X (char can be changed in rsbac/debug.h).
+  This makes debugging of your RSBAC administration settings much easier,
+  but:
+
+  WARNING: This is dangerous, because everyone with physical access to
+           your keyboard can effectively turn off access control!
+
+  Do not use in production systems!
+
+Individual module softmode support
+CONFIG_RSBAC_SOFTMODE_IND
+  If on, you can toggle softmode individually for each module.
+
+  Softmode for a module can be switched via proc interface with
+
+  echo debug ind_softmode <module> <value> > /proc/rsbac-info/debug,
+
+  where <module> is the module short name in capitals, e.g. RC, and
+  <value> is 1 (on) or 0 (off).
+  If policy switching is enabled, you can also use sys_rsbac_switch, e.g.
+  via switch_module command line tool.
+
+Allow disabling of Linux filesystem access control (DANGEROUS!)
+CONFIG_RSBAC_ALLOW_DAC_DISABLE
+  Turn this on to get access to Linux DAC disabling switches.
+
+Allow full disabling (DANGEROUS!)'
+CONFIG_RSBAC_ALLOW_DAC_DISABLE_FULL
+  With this option you can allow turning off Linux discretionary access
+  control for all filesystem objects, except where the filesystem
+  provides its own access control function.
+
+  In most cases it should be sufficient to set the DAC_OVERRIDE Linux
+  capability with the DAC module for single users or programs instead.
+
+  To disable Linux access control, use the kernel param
+  rsbac_dac_disable, syscall sys_rsbac_switch (admin tool switch_module)
+  for switch target DAC_DISABLE or
+  echo debug dac_disable 1 >/proc/rsbac-info/debug.
+
+  For security reasons, Linux access control is still enabled by default,
+  even with this option active!
+
+  DANGER! Do not use, unless you really know what you are doing!
+
+Allow partial (dir tree based) disabling
+CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+  If enabled, you can turn off Linux discretionary access control for
+  individual filesystem objects and directory trees.
+  
+  This option is useful, if you want to rely on RSBAC access control
+  instead of standard Linux style, without giving full access in case
+  RSBAC is not running.
+  
+  Note: You can use the linux2acl command line tool to get your old Linux
+        rights converted to ACL settings.
+
+Support secure delete
+CONFIG_RSBAC_SECDEL
+  This option enables secure deletion and truncation of all files.
+  The decision whether to overwrite is dispatched to all modules,
+  if one says yes, the file is overwritten. Currently only FF and PM
+  support this.
+
+  FF returns yes, if file is marked with ff_flag secure_delete. This
+  flag can, as usual, be inherited from parent dir, if flag
+  add_inherited is set (default, if option 'Inherit as default' has been
+  chosen).
+
+  PM returns yes for all files marked as personal data and no otherwise.
+
+  Secure deletion and truncation is currently done by overwriting once
+  with zeros, because this is enough against hackers and standard level
+  analysers. Against well-fed organisations who got hold of your disk
+  there is no protection anyway.
+
+  This mechanism is currently only supported for ext2, ext3, minix,
+  msdos and vfat, but could be extended to other file systems, if needed.
+
+No decision on net mounts
+CONFIG_RSBAC_NO_DECISION_ON_NETMOUNT
+  If this option is turned on, no decisions are made and no attributes
+  are set for all accesses to files and dirs on network mounts. For these
+  targets, RSBAC behaves like a maintenance kernel. So even Malware
+  Scanning is turned off. Attribute saving or restoring is not done
+  anyway.
+
+  Use this option, if you cannot access your network files properly,
+  and keep it off otherwise.
+
+RSBAC check sys_syslog
+CONFIG_RSBAC_SYSLOG
+  If enabled, the syscall sys_syslog() for system log is also checked,
+  leading to less performance for a minor security issue.
+
+RSBAC symlink redirection
+CONFIG_RSBAC_SYM_REDIR
+  This feature optionally changes the contents of a symlink, based on
+  the owner ID, the current MAC security level or the current RC role ID
+  of the process accessing it.
+
+  Note: For technical reasons, all numeric characters at the end of the
+        original symlink contents will be replaced, not appended to.
+        This can be used to e.g. get the uid itself as final name and
+        the parent dir (or nothing...), if redirection is off.
+
+Add remote IP address
+CONFIG_RSBAC_SYM_REDIR_REMOTE_IP
+  With this option enabled, every read from a symlink, which has a
+  symlink_add_remote_ip value > 0, gets this number of bytes added
+  in dot notation, e.g. 192.168.0 with value 3.
+
+  This option is e.g. useful, if you want to provide different user
+  shells, depending on the origin of a connection:
+  Set user shell to /bin/linkshell. Make this a symlink to
+  /bin/usershell-, provide /bin/usershell-192.168.0 for users from
+  that network and /bin/usershell-0.0.0 for local users.
+
+  As a side effect, users connecting from other networks have no
+  valid shell at all.
+
+Add user ID number
+CONFIG_RSBAC_SYM_REDIR_UID
+  With this option enabled, every read from a symlink, which has the
+  symlink_add_uid flag set, gets the caller uid added in decimal
+  notation.
+
+  This feature can e.g. be used to setup individual /tmp dirs for all
+  users: As root call
+  cd /
+  mkdir tmpdirs && chmod 777 tmpdirs && chmod o+t tmpdirs
+  # stay compatible, if redirection is off, by reusing old /tmp
+  mv tmp tmpdirs
+  ln -s tmpdirs/tmp tmp
+  mkdir tmpdirs/tmp0 ; chmod 700 tmpdirs/tmp0
+  echo 'mkdir /tmpdirs/tmp$UID && chmod 700 /tmpdirs/tmp$UID' \
+    >>/etc/profile
+
+  As user with modify right for general attributes (e.g. user 400), set
+  symlink_add_uid to on for /tmp:
+  attr_set_file_dir SYMLINK /tmp symlink_add_uid 1
+
+  From now on, root accesses to /tmp show /tmpdirs/tmp0, user 400
+  accesses show /tmpdir/tmp400, etc. It is of course advisable to protect
+  the individual dirs against root.
+
+Add MAC current security level
+CONFIG_RSBAC_SYM_REDIR_MAC
+  With this option enabled, every read from a symlink, which has the
+  symlink_add_mac_level flag set, gets the calling process's current MAC
+  security level added in decimal notation.
+
+  It can be used to e.g. provide separate /tmp dirs for all MAC levels
+  and thus avoid unwanted flow of information.
+  See 'Add user ID number' help to get an idea of how to do this.
+
+Also add MAC current category vector
+CONFIG_RSBAC_SYM_REDIR_MAC_CAT
+  If enabled, the redirected symlink contents will not only contain the
+  process current MAC security level, but also its current category set
+  as the usual string of 0 and 1, separated by a colon.
+
+  Warning: This will result in more possible values than your filesystem
+           can handle names and inodes, so please be careful.
+
+Add RC role number
+CONFIG_RSBAC_SYM_REDIR_RC
+  With this option enabled, every read from a symlink, which has the
+  symlink_add_rc_role flag set, gets the calling process's current RC
+  role ID added in decimal notation.
+
+  It can be used to e.g. provide individual /tmp dirs for all roles.
+  See 'Add user ID number' help to get an idea of how to do this.
+
+X support (normal user MODIFY_PERM access to ST_ioports)
+CONFIG_RSBAC_USER_MOD_IOPERM
+  Normally, MODIFY_PERMISSIONS_DATA access to SCD target ST_ioports is
+  not granted for normal users, because this would allow direct hardware
+  access. Unfortunately, X servers depend on this. So if you need X on
+  your system, enable this, otherwise keep it off.
+
+  This switch enables the following changes:
+  - MAC, FC, SIM and AUTH hardwired policies are adjusted to allow this
+    access type for every user.
+  - RC and ACL default settings are adjusted accordingly, but existing or
+    later settings are not affected.
+
+Individual file/dir/dev object logging
+CONFIG_RSBAC_IND_LOG
+  Enable individual log levels for every request type for every file,
+  dir and device. Log levels are none, denied requests, full, request
+  based. Default value is request based for all request types.
+
+  If this option is off, only general log levels for requests are used
+  (same as individual logging for all objects set to request based).
+
+Individual user logging
+CONFIG_RSBAC_IND_USER_LOG
+  When enabled, you can specify for every single user, which request
+  type(s) will always be logged.
+
+Individual program logging
+CONFIG_RSBAC_IND_PROG_LOG
+  When enabled, you can specify for every single program file, which
+  request type(s) will always be logged.
+
+Log program file
+CONFIG_RSBAC_LOG_PROGRAM_FILE
+  Enable this option to get the full program file path logged together
+  with the process name.
+
+Log full path
+CONFIG_RSBAC_LOG_FULL_PATH
+  If this is turned on, logging messages for file and dir targets will
+  contain the full path. This makes the log significantly longer and
+  takes some extra CPU time, but also increases log usability.
+
+Maximum path length (256 - ?)
+CONFIG_RSBAC_MAX_PATH_LEN
+  If the full path is longer than CONFIG_RSBAC_MAX_PATH_LEN, the leading
+  dirnames will be left out until it fits. The bigger this value, the
+  more memory will be allocated in the logging routine.
+
+Pseudonymious logging support
+CONFIG_RSBAC_LOG_PSEUDO
+  Enable to get pseudo values for users honoured in all request logging
+  entries. If a pseudo value is not 0, it is logged instead of the uid.
+
+Pseudonymize filesystem objects
+CONFIG_RSBAC_LOG_PSEUDO_FS
+  If enabled, the logging code exchanges filesystem object names with
+  their owner's pseudo, if the pseudo value is not 0 and the parent
+  object has another owner.
+
+RSBAC own logging facility
+CONFIG_RSBAC_RMSG
+  Add logging of requests with extra facility, which is basically a
+  clone of printk/sys_syslog. If proc is supported, a file rmsg appears
+  in rsbac-info and can be used like kmsg, e.g. with a patched klogd,
+  cat or tail -f.
+  This file is protected by RSBAC with object type SCD/rsbac_log.
+  A new syscall sys_rsbac_log, similar to sys_syslog, also gives access
+  to logging stuff.
+
+Do not log to syslog
+CONFIG_RSBAC_RMSG_EXCL
+  Turn off logging requests to syslog. They will only appear in rmsg.
+
+Allow to disable logging to syslog
+CONFIG_RSBAC_RMSG_NOSYSLOG
+  When on, you can temporarily disable logging to syslog with kernel
+  parameter rsbac_nosyslog or via /proc/rsbac-info/debug. Useful for
+  initial configuration on system installation or if you need a clean
+  separation.
+
+Make RSBAC data files visible
+CONFIG_RSBAC_DAT_VISIBLE
+  By default, the rsbac.dat directories containing the list data backups
+  are unreadable for any user. Unfortunately, some programs must be able
+  to read all directories, e.g. the quota tools.
+
+  This option enables read and status access to the rsbac.dat
+  directories, but the files themselves are kept unreadable.
+
+Hide processes in /proc
+CONFIG_RSBAC_PROC_HIDE
+  If enabled, a process is also hidden in /proc listing, if the reading
+  process has no GET_STATUS_DATA right to it.
+  This option adds a significant amount of requests, when reading /proc,
+  so it is off by default.
+
+Faked root uid
+CONFIG_RSBAC_FAKE_ROOT_UID
+  With this turned on, programs can optionally get uid 0 returned from
+  every getuid() and/or geteuid() call.
+
+  Some programs check, whether they really run as root, although they
+  already have sufficient rights to do their jobs. This forces users
+  to keep them running under the dangerous root account.
+
+RSBAC extra statistics
+CONFIG_RSBAC_XSTATS
+  If enabled, extended RSBAC statistics are collected. Currently these
+  are mostly count matrices of adf_request and adf_set_attr calls by
+  target type and request type. These matrices give a detailed overview
+  of the request and thus the system call behaviour.
+
+  Also, there is an access count for calls to data structures by target
+  type.
+
+  The extra data can be read from another proc file called xstats.
+
+Intercept sys_read and sys_write
+CONFIG_RSBAC_RW
+  If enabled, the syscalls sys_read() and sys_write() for reading from
+  and writing to opened files, fifos and devices are also intercepted.
+  This slows down the system a bit, but allows more control of object
+  accesses to adapt to configuration changes.
+
+  Please note that the interception for sockets only takes place, if
+  net support and socket read/write interception are also enabled
+  (CONFIG_RSBAC_NET and CONFIG_RSBAC_NET_RW).
+
+Intercept Semaphore IPC operations
+CONFIG_RSBAC_IPC_SEM
+  If on, System V IPC Semaphores are also protected. As there is no
+  direct data flow over semaphores, they can mostly be misused for
+  denial of service attacks. Turn on for special needs, keep off
+  otherwise.
+
+Control DAC process owner (seteuid, setfsuid)
+CONFIG_RSBAC_DAC_OWNER
+  Usually, only set*uid calls, which affect the real user ID used for
+  RSBAC decisions, issue a decision request CHANGE_OWNER for processes.
+  With this option, changes to the effective (CHANGE_DAC_EFF_OWNER) and
+  the filesystem (CHANGE_DAC_FS_OWNER) owner are also controlled.
+
+  Please also see AUTH option 'AUTH support for effective and fs owner
+  control'.
+
+Control DAC process group (setegid, setfsgid)
+CONFIG_RSBAC_DAC_GROUP
+  Usually, set*gid calls issue only the decision request CHANGE_GROUP
+  for changes to the process group.
+  With this option, changes to the effective (CHANGE_DAC_EFF_GROUP) and
+  the filesystem (CHANGE_DAC_FS_GROUP) group are also controlled.
+
+  Please also see AUTH option 'AUTH support for effective and fs group
+  control'.
+
+Number of GEN process lists
+CONFIG_RSBAC_GEN_NR_P_LISTS
+  When using network support, every process in the system accepting a
+  network connection and all its sub-processes will get individual
+  attributes set. This means that with many active processes, the list
+  lookups will become slower.
+
+  To speed them up, RSBAC uses a hash table to split the GENeral process
+  attribute lists into several shorter ones. This option sets the number
+  of these lists.
+
+  In most cases, the default of 4 will be sufficient. However, if you
+  plan to have very many processes, a higher value will reduce lookup
+  time at the cost of additional list headers.
+
+
 Prompt for development and/or incomplete code/drivers
 CONFIG_EXPERIMENTAL
   Some of the various things that Linux supports (such as network
diff -urN -x rsbac trunk/drivers/block/loop.c linux-2.4.32-rsbac-1.2.7/drivers/block/loop.c
--- trunk/drivers/block/loop.c	2006-06-01 10:31:56.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/drivers/block/loop.c	2006-06-01 10:33:16.000000000 +0200
@@ -76,6 +76,11 @@
 
 #include <linux/loop.h>		
 
+/* RSBAC: including adf-calls*/
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #define MAJOR_NR LOOP_MAJOR
 
 static int max_loop = 8;
@@ -626,6 +631,13 @@
 	int		error;
 	int		bs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	MOD_INC_USE_COUNT;
 
 	error = -EBUSY;
@@ -667,6 +679,63 @@
 	} else
 		goto out_putf;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "loop_set_fd() [lo_ioctl()]: calling ADF for FILE/DEV\n");
+#endif
+        if(S_ISREG(inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.dir.device = inode->i_dev;
+            rsbac_target_id.dir.inode  = inode->i_ino;
+            rsbac_target_id.dir.dentry_p = file->f_dentry;
+          }
+        else
+          { /* must be block */
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(inode->i_rdev);
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            if(rsbac_target == T_DEV)
+              goto out;
+            else
+              goto out_putf;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "loop_set_fd() [lo_ioctl()]: calling ADF for DEV\n");
+#endif
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(dev);
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            if(rsbac_target == T_DEV)
+              goto out;
+            else
+              goto out_putf;
+          }
+        #endif
+
 	get_file(file);
 
 	if (IS_RDONLY (inode) || is_read_only(lo_device)
@@ -741,6 +810,13 @@
 	struct file *filp = lo->lo_backing_file;
 	int gfp = lo->old_gfp_mask;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (lo->lo_state != Lo_bound)
 		return -ENXIO;
 	if (lo->lo_refcnt > 1)	/* we needed one fd for the ioctl */
@@ -748,6 +824,55 @@
 	if (filp==NULL)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "loop_clr_fd() [lo_ioctl()]: calling ADF for FILE/DEV\n");
+#endif
+        if(S_ISREG(filp->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.dir.device = filp->f_dentry->d_inode->i_dev;
+            rsbac_target_id.dir.inode  = filp->f_dentry->d_inode->i_ino;
+            rsbac_target_id.dir.dentry_p = filp->f_dentry;
+          }
+        else
+          { /* must be block dev */
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "loop_clr_fd() [lo_ioctl()]: calling ADF for DEV\n");
+#endif
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = LOOP_MAJOR;
+        rsbac_target_id.dev.minor = lo->lo_number;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	spin_lock_irq(&lo->lo_lock);
 	lo->lo_state = Lo_rundown;
 	if (atomic_dec_and_test(&lo->lo_pending))
diff -urN -x rsbac trunk/drivers/char/mem.c linux-2.4.32-rsbac-1.2.7/drivers/char/mem.c
--- trunk/drivers/char/mem.c	2006-06-01 10:31:44.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/drivers/char/mem.c	2006-06-01 10:33:05.000000000 +0200
@@ -43,6 +43,11 @@
 extern void tapechar_init(void);
 #endif
      
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 static ssize_t do_write_mem(struct file * file, void *p, unsigned long realp,
 			    const char * buf, size_t count, loff_t *ppos)
 {
@@ -525,7 +530,32 @@
 
 static int open_port(struct inode * inode, struct file * filp)
 {
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+
+	if(!capable(CAP_SYS_RAWIO))
+	  return -EPERM;
+
+        rsbac_target_id.scd = ST_kmem;
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "open_port(): calling ADF\n");
+#endif
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          return -EPERM;
+        else
+          return 0;
+#else
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
+#endif
 }
 
 struct page *kmem_vm_nopage(struct vm_area_struct *vma, unsigned long address, int write)
diff -urN -x rsbac trunk/drivers/char/sysrq.c linux-2.4.32-rsbac-1.2.7/drivers/char/sysrq.c
--- trunk/drivers/char/sysrq.c	2006-06-01 10:31:46.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/drivers/char/sysrq.c	2006-06-01 10:33:08.000000000 +0200
@@ -32,6 +32,11 @@
 
 #include <asm/ptrace.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/types.h>
+#include <rsbac/debug.h>
+#endif
+
 extern void reset_vc(unsigned int);
 extern struct list_head super_blocks;
 
@@ -317,6 +322,40 @@
 	action_msg:	"Kill All Tasks",
 };
 
+#if  (defined(CONFIG_RSBAC_AUTO_WRITE) && (CONFIG_RSBAC_AUTO_WRITE > 0)) \
+   || defined(CONFIG_RSBAC_INIT_THREAD)
+static void sysrq_handle_rsbac_wakeup(int key, struct pt_regs *pt_regs,
+		struct kbd_struct *kbd, struct tty_struct *tty) {
+	rsbac_printk(KERN_WARNING "SysRq: Emergency rsbacd/init wake-up!\n");
+	wakeup_rsbacd(0);
+}
+static struct sysrq_key_op sysrq_rsbac_wakeup_op = {
+	handler:	sysrq_handle_rsbac_wakeup,
+	help_msg:	"rsbac_emergency_Wakeup",
+	action_msg:	"Emergency rsbacd/init wake-up!\n",
+};
+#endif
+#ifdef CONFIG_RSBAC_SOFTMODE_SYSRQ
+static void sysrq_handle_rsbac_softmode(int key, struct pt_regs *pt_regs,
+		struct kbd_struct *kbd, struct tty_struct *tty) {
+	if(rsbac_softmode)
+	  {
+	    rsbac_printk(KERN_WARNING "Soft mode disabled via SysRq!\n");
+	    rsbac_softmode = 0;
+	  }
+	else
+	  {
+	    rsbac_printk(KERN_WARNING "Soft mode enabled via SysRq!\n");
+	    rsbac_softmode = 1;
+	  }
+}
+static struct sysrq_key_op sysrq_rsbac_softmode_op = {
+	handler:	sysrq_handle_rsbac_softmode,
+	help_msg:	"rsbac_toggle_softmode_X",
+	action_msg:	"RSBAC toggle softmode\n",
+};
+#endif
+
 /* END SIGNAL SYSRQ HANDLERS BLOCK */
 
 
@@ -363,8 +402,17 @@
 /* t */	&sysrq_showstate_op,
 /* u */	&sysrq_mountro_op,
 /* v */	NULL,
+#if  (defined(CONFIG_RSBAC_AUTO_WRITE) && (CONFIG_RSBAC_AUTO_WRITE > 0)) \
+   || defined(CONFIG_RSBAC_INIT_THREAD)
+/* w */	&sysrq_rsbac_wakeup_op,
+#else
 /* w */	NULL,
+#endif
+#ifdef CONFIG_RSBAC_SOFTMODE_SYSRQ
+/* x */	&sysrq_rsbac_softmode_op,
+#else
 /* x */	NULL,
+#endif
 /* y */	NULL,
 /* z */	NULL
 };
diff -urN -x rsbac trunk/drivers/char/tty_io.c linux-2.4.32-rsbac-1.2.7/drivers/char/tty_io.c
--- trunk/drivers/char/tty_io.c	2006-06-01 10:31:45.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/drivers/char/tty_io.c	2006-06-01 10:33:06.000000000 +0200
@@ -100,6 +100,11 @@
 #include <linux/selection.h>
 #include <linux/devfs_fs_kernel.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #include <linux/kmod.h>
 
 #ifdef CONFIG_VT
@@ -1882,10 +1887,38 @@
 	char ch, mbz = 0;
 	struct tty_ldisc *ld;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if ((current->tty != tty) && !suser())
 		return -EPERM;
 	if (get_user(ch, arg))
 		return -EFAULT;
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "tiocsti(): calling ADF\n");
+#endif
+        rsbac_target_id.dev.type = D_char;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(tty->device);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(tty->device);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_SEND,
+			       current->pid,
+			       T_DEV,
+			       rsbac_target_id,
+			       A_none,
+			       rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	ld = tty_ldisc_ref_wait(tty);
 	ld->receive_buf(tty, &ch, &mbz, 1);
 	tty_ldisc_deref(ld);
diff -urN -x rsbac trunk/drivers/char/tty_ioctl.c linux-2.4.32-rsbac-1.2.7/drivers/char/tty_ioctl.c
--- trunk/drivers/char/tty_ioctl.c	2006-06-01 10:31:46.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/drivers/char/tty_ioctl.c	2006-06-01 10:33:07.000000000 +0200
@@ -25,6 +25,11 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #undef TTY_DEBUG_WAIT_UNTIL_SENT
 
 #undef	DEBUG
@@ -388,12 +393,61 @@
 	int retval;
 	struct tty_ldisc *ld;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (tty->driver.type == TTY_DRIVER_TYPE_PTY &&
 	    tty->driver.subtype == PTY_TYPE_MASTER)
 		real_tty = tty->link;
 	else
 		real_tty = tty;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "n_tty_ioctl(): calling ADF\n");
+#endif
+	switch (cmd) {
+#ifdef TIOCGETP
+		case TIOCGETP:
+#endif
+#ifdef TIOCGETC
+		case TIOCGETC:
+#endif
+#ifdef TIOCGLTC
+		case TIOCGLTC:
+#endif
+		case TCGETS:
+		case TCGETA:
+		case TIOCOUTQ:
+		case TIOCINQ:
+		case TIOCGLCKTRMIOS:
+		case TIOCGSOFTCAR:
+		  rsbac_request = R_GET_PERMISSIONS_DATA;
+		  break;
+		default:
+		  rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+	}
+        rsbac_target_id.dev.type = D_char;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(real_tty->device);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(real_tty->device);
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+			       current->pid,
+			       T_DEV,
+			       rsbac_target_id,
+			       A_none,
+			       rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	switch (cmd) {
 #ifdef TIOCGETP
 		case TIOCGETP:
diff -urN -x rsbac trunk/drivers/ide/ide.c linux-2.4.32-rsbac-1.2.7/drivers/ide/ide.c
--- trunk/drivers/ide/ide.c	2006-06-01 10:31:56.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/drivers/ide/ide.c	2006-06-01 10:33:17.000000000 +0200
@@ -159,6 +159,11 @@
 
 #include <linux/kmod.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /* default maximum number of failures */
 #define IDE_DEFAULT_MAX_FAILURES 	1
 
@@ -1728,6 +1733,13 @@
 	ide_settings_t *setting;
 	int force = 0;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!inode || !(dev = inode->i_rdev))
 		return -EINVAL;
 		
@@ -1744,6 +1756,61 @@
 	if ((drive = ide_info_ptr(inode->i_rdev, force)) == NULL)
 		return -ENODEV;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "ide_ioctl(): calling ADF\n");
+#endif
+        /* values taken from include/linux/fs.h and hdreg.h */
+	switch (cmd) {
+	 	case BLKGETSIZE:   /* Return device size */
+	 	case BLKGETSIZE64:
+		case BLKROGET:
+		case BLKRAGET:
+		case BLKFRAGET:
+		case BLKSECTGET:
+		case BLKSSZGET:
+		case BLKELVGET:
+		case BLKBSZGET:
+		case HDIO_GETGEO:
+		case HDIO_GETGEO_BIG:
+		case HDIO_GETGEO_BIG_RAW:
+		case HDIO_OBSOLETE_IDENTITY:
+		case HDIO_GET_UNMASKINTR:
+		case HDIO_GET_IDENTITY:
+		case HDIO_GET_NICE:
+		case HDIO_GET_BUSSTATE:
+		case HDIO_GET_QDMA:
+		case HDIO_GET_MULTCOUNT:
+		case HDIO_GET_KEEPSETTINGS:
+		case HDIO_GET_32BIT:
+		case HDIO_GET_NOWERR:
+		case HDIO_GET_DMA:
+		case HDIO_GET_WCACHE:
+		case HDIO_GET_ACOUSTIC:
+		case HDIO_GET_ADDRESS:
+		  rsbac_request = R_GET_STATUS_DATA;
+		  break;
+
+		default:
+		  rsbac_request = R_MODIFY_SYSTEM_DATA;
+	}
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(inode->i_rdev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(inode->i_rdev);
+        rsbac_attribute_value.ioctl_cmd = cmd;
+        if (!rsbac_adf_request(rsbac_request,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_ioctl_cmd,
+                               rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	down(&ide_setting_sem);
 	if ((setting = ide_find_setting_by_ioctl(drive, cmd)) != NULL) {
 		if (cmd == setting->read_ioctl) {
diff -urN -x rsbac trunk/fs/buffer.c linux-2.4.32-rsbac-1.2.7/fs/buffer.c
--- trunk/fs/buffer.c	2006-06-01 10:30:57.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/buffer.c	2006-06-01 10:32:31.000000000 +0200
@@ -53,6 +53,11 @@
 #include <asm/bitops.h>
 #include <asm/mmu_context.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #define NR_RESERVED (10*MAX_BUF_PER_PAGE)
 #define MAX_UNUSED_BUFFERS NR_RESERVED+20 /* don't ever have more than this 
 					     number of unused buffer heads */
@@ -2995,6 +3000,37 @@
 	if (func >= 2) {
 		int i = (func-2) >> 1;
 		if (i >= 0 && i < N_PARAM) {
+			/* RSBAC */
+			#ifdef CONFIG_RSBAC
+			enum  rsbac_adf_request_t     rsbac_request;
+			union rsbac_target_id_t       rsbac_target_id;
+			union rsbac_attribute_value_t rsbac_attribute_value;
+			#endif
+
+			/* RSBAC */
+			#ifdef CONFIG_RSBAC
+			if(func & 1)
+			  rsbac_request = R_MODIFY_SYSTEM_DATA;
+			else
+			  rsbac_request = R_GET_STATUS_DATA;
+        
+			rsbac_target_id.scd = ST_other;
+			rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+			if (rsbac_debug_aef)
+			  rsbac_printk(KERN_DEBUG "sys_bdflush: calling ADF\n");
+#endif
+			if(!rsbac_adf_request(rsbac_request,
+					current->pid,
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+			  {
+			    return -EPERM;
+			  }
+			#endif
+
 			if ((func & 1) == 0)
 				return put_user(bdf_prm.data[i], (int*)data);
 
diff -urN -x rsbac trunk/fs/exec.c linux-2.4.32-rsbac-1.2.7/fs/exec.c
--- trunk/fs/exec.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/exec.c	2006-06-01 10:32:29.000000000 +0200
@@ -53,6 +53,11 @@
 int core_setuid_ok = 0;
 /* The maximal length of core_pattern is also specified in sysctl.c */ 
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 static struct linux_binfmt *formats;
 static rwlock_t binfmt_lock = RW_LOCK_UNLOCKED;
 
@@ -113,6 +118,12 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk(library, &nd);
 	if (error)
 		goto out;
@@ -121,10 +132,42 @@
 	if (!S_ISREG(nd.dentry->d_inode->i_mode))
 		goto exit;
 
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+	if(rsbac_dac_part_disabled(nd.dentry))
+	  error = 0;
+	else
+#endif
 	error = permission(nd.dentry->d_inode, MAY_READ | MAY_EXEC);
 	if (error)
 		goto exit;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_uselib(): calling ADF\n");
+#endif
+        rsbac_target_id.file.device = nd.dentry->d_inode->i_dev;
+        rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MAP_EXEC,
+                               current->pid,
+                               T_FILE,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_uselib(): request not granted, my PID: %i\n",
+                     current->pid);
+#endif
+            error = -EPERM;
+            goto exit;
+          }
+        #endif
+
 	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
 	error = PTR_ERR(file);
 	if (IS_ERR(file))
@@ -150,6 +193,33 @@
 		read_unlock(&binfmt_lock);
 	}
 	fput(file);
+
+        /* RSBAC: notify ADF of mapped segment */
+        #ifdef CONFIG_RSBAC
+        if(!error)
+          {
+            union rsbac_target_id_t rsbac_new_target_id;
+
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_uselib(): calling ADF_set_attr\n");
+#endif
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_MAP_EXEC,
+                                   current->pid,
+                                   T_FILE,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_uselib(): rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 out:
   	return error;
 exit:
@@ -386,7 +456,14 @@
 		file = ERR_PTR(-EACCES);
 		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
 		    S_ISREG(inode->i_mode)) {
-			int err = permission(inode, MAY_EXEC);
+			int err;
+
+                        #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+                        if(rsbac_dac_part_disabled(nd.dentry))
+                          err = 0;
+                        else
+                        #endif
+			err = permission(inode, MAY_EXEC);
 			if (!err && !(inode->i_mode & 0111))
 				err = -EACCES;
 			file = ERR_PTR(err);
@@ -935,6 +1012,13 @@
 	int retval;
 	int i;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	file = open_exec(filename);
 
 	retval = PTR_ERR(file);
@@ -961,6 +1045,34 @@
 		return bprm.envc;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_execve() [sys_execve()]: calling ADF\n");
+#endif
+        rsbac_target_id.file.device = file->f_dentry->d_inode->i_dev;
+        rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = file->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_EXECUTE,
+                               current->pid,
+                               T_FILE,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "do_execve() [sys_execve()]: request not granted, my PID: %i\n",
+                     current->pid);
+#endif
+            allow_write_access(file);
+            fput(file);
+            return -EPERM;
+          }
+        #endif
+
 	retval = prepare_binprm(&bprm);
 	if (retval < 0) 
 		goto out; 
@@ -981,7 +1093,31 @@
 	retval = search_binary_handler(&bprm,regs);
 	if (retval >= 0)
 		/* execve success */
+          {
+            /* RSBAC: notify ADF of changed program in this process */
+            /*        Most structures are already filled            */
+            #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "do_execve() [sys_execve()]: calling ADF_set_attr\n");
+#endif
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_EXECUTE,
+                                   current->pid,
+                                   T_FILE,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "do_execve() [sys_execve]: rsbac_adf_set_attr() returned error\n");
+              }
+            #endif
+
 		return retval;
+	  }
 
 out:
 	/* Something went wrong, return the inode and free the argument pages*/
diff -urN -x rsbac trunk/fs/ext2/ioctl.c linux-2.4.32-rsbac-1.2.7/fs/ext2/ioctl.c
--- trunk/fs/ext2/ioctl.c	2006-06-01 10:30:55.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/ext2/ioctl.c	2006-06-01 10:32:31.000000000 +0200
@@ -12,12 +12,88 @@
 #include <linux/sched.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
 
 int ext2_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
 		unsigned long arg)
 {
 	unsigned int flags;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "ext2_ioctl(): calling ADF\n");
+#endif
+        switch (cmd)
+          {
+            case EXT2_IOC_GETFLAGS:
+            case EXT2_IOC_GETVERSION:
+              rsbac_request = R_GET_PERMISSIONS_DATA;
+              break;
+            case EXT2_IOC_SETFLAGS:
+            case EXT2_IOC_SETVERSION:
+              rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+              break;
+            default:
+              rsbac_request = R_NONE;
+	  }
+        if(S_ISSOCK(inode->i_mode))
+          {
+            #ifdef CONFIG_RSBAC_NET_OBJ
+            #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+            if(   inode->u.socket_i.ops
+               && (inode->u.socket_i.ops->family != AF_UNIX)
+              )
+            #endif
+              {
+                rsbac_target = T_NETOBJ;
+                rsbac_target_id.netobj.sock_p
+                  = &inode->u.socket_i;
+                rsbac_target_id.netobj.local_addr = NULL;
+                rsbac_target_id.netobj.local_len = 0;
+                rsbac_target_id.netobj.remote_addr = NULL;
+                rsbac_target_id.netobj.remote_len = 0;
+              }
+            #endif
+          }
+        else
+          {
+            if (S_ISDIR(inode->i_mode))
+              rsbac_target = T_DIR;
+            else if (S_ISFIFO(inode->i_mode))
+              rsbac_target = T_FIFO;
+            else if (S_ISLNK(inode->i_mode))
+              rsbac_target = T_SYMLINK;
+            else
+              rsbac_target = T_FILE;
+            rsbac_target_id.file.device = inode->i_dev;
+            rsbac_target_id.file.inode  = inode->i_ino;
+            rsbac_target_id.file.dentry_p = filp->f_dentry;
+	  }
+        rsbac_attribute_value.ioctl_cmd = cmd;
+        if(   (rsbac_request != R_NONE)
+           && !rsbac_adf_request(rsbac_request,
+                                 current->pid,
+                                 rsbac_target,
+                                 rsbac_target_id,
+                                 A_ioctl_cmd,
+                                 rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	ext2_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
diff -urN -x rsbac trunk/fs/ext2/namei.c linux-2.4.32-rsbac-1.2.7/fs/ext2/namei.c
--- trunk/fs/ext2/namei.c	2006-06-01 10:30:55.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/ext2/namei.c	2006-06-01 10:32:31.000000000 +0200
@@ -33,6 +33,11 @@
 #include <linux/ext2_fs.h>
 #include <linux/pagemap.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_SECDEL
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Couple of helper functions - make the code slightly cleaner.
  */
@@ -234,6 +239,12 @@
 	if (err)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+        if(inode->i_nlink == 1)
+          rsbac_sec_del(dentry);
+        #endif
+
 	inode->i_ctime = dir->i_ctime;
 	ext2_dec_count(inode);
 	err = 0;
@@ -291,6 +302,13 @@
 		new_de = ext2_find_entry (new_dir, new_dentry, &new_page);
 		if (!new_de)
 			goto out_dir;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_SECDEL
+                if(new_inode->i_nlink == 1)
+                  rsbac_sec_del(new_dentry);
+                #endif
+
 		ext2_inc_count(old_inode);
 		ext2_set_link(new_dir, new_de, new_page, old_inode);
 		new_inode->i_ctime = CURRENT_TIME;
@@ -322,6 +340,10 @@
 	}
 	return 0;
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_SECDEL
+#include <rsbac/adf.h>
+#endif
 
 out_dir:
 	if (dir_de) {
diff -urN -x rsbac trunk/fs/ext2/symlink.c linux-2.4.32-rsbac-1.2.7/fs/ext2/symlink.c
--- trunk/fs/ext2/symlink.c	2006-06-01 10:30:55.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/ext2/symlink.c	2006-06-01 10:32:31.000000000 +0200
@@ -20,15 +20,49 @@
 #include <linux/fs.h>
 #include <linux/ext2_fs.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_SYM_REDIR
+#include <linux/slab.h>
+#include <rsbac/adf.h>
+#endif
+
 static int ext2_readlink(struct dentry *dentry, char *buffer, int buflen)
 {
 	char *s = (char *)dentry->d_inode->u.ext2_i.i_data;
+#ifdef CONFIG_RSBAC_SYM_REDIR
+        char * rsbac_name;
+        int res;
+
+	/* copying is ugly, but we must not change the const */
+        rsbac_name = rsbac_symlink_redirect(dentry, s, PAGE_SIZE);
+        if(rsbac_name)
+          {
+            res = vfs_readlink(dentry, buffer, buflen, rsbac_name);
+            kfree(rsbac_name);
+            return res;
+          }
+        else
+#endif
 	return vfs_readlink(dentry, buffer, buflen, s);
 }
 
 static int ext2_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
 	char *s = (char *)dentry->d_inode->u.ext2_i.i_data;
+#ifdef CONFIG_RSBAC_SYM_REDIR
+        char * rsbac_name;
+        int res;
+
+	/* copying is ugly, but we must not change the const */
+        rsbac_name = rsbac_symlink_redirect(dentry, s, PAGE_SIZE);
+        if(rsbac_name)
+          {
+            res = vfs_follow_link(nd, rsbac_name);
+            kfree(rsbac_name);
+            return res;
+          }
+        else
+#endif
 	return vfs_follow_link(nd, s);
 }
 
diff -urN -x rsbac trunk/fs/ext3/ioctl.c linux-2.4.32-rsbac-1.2.7/fs/ext3/ioctl.c
--- trunk/fs/ext3/ioctl.c	2006-06-01 10:30:56.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/ext3/ioctl.c	2006-06-01 10:32:31.000000000 +0200
@@ -14,12 +14,93 @@
 #include <linux/sched.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
 
 int ext3_ioctl (struct inode * inode, struct file * filp, unsigned int cmd,
 		unsigned long arg)
 {
 	unsigned int flags;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "ext3_ioctl(): calling ADF\n");
+#endif
+        switch (cmd)
+          {
+#ifdef CONFIG_JBD_DEBUG
+            case EXT3_IOC_WAIT_FOR_READONLY:
+#endif
+            case EXT3_IOC_GETFLAGS:
+            case EXT3_IOC_GETVERSION:
+            case EXT3_IOC_GETVERSION_OLD:
+              rsbac_request = R_GET_PERMISSIONS_DATA;
+              break;
+            case EXT3_IOC_SETFLAGS:
+            case EXT3_IOC_SETVERSION:
+            case EXT3_IOC_SETVERSION_OLD:
+              rsbac_request = R_MODIFY_PERMISSIONS_DATA;
+              break;
+            default:
+              rsbac_request = R_NONE;
+	  }
+        if(S_ISSOCK(inode->i_mode))
+          {
+            #ifdef CONFIG_RSBAC_NET_OBJ
+            #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+            if(   inode->u.socket_i.ops
+               && (inode->u.socket_i.ops->family != AF_UNIX)
+              )
+            #endif
+              {
+                rsbac_target = T_NETOBJ;
+                rsbac_target_id.netobj.sock_p
+                  = &inode->u.socket_i;
+                rsbac_target_id.netobj.local_addr = NULL;
+                rsbac_target_id.netobj.local_len = 0;
+                rsbac_target_id.netobj.remote_addr = NULL;
+                rsbac_target_id.netobj.remote_len = 0;
+              }
+            #endif
+          }
+        else
+          {
+            if (S_ISDIR(inode->i_mode))
+              rsbac_target = T_DIR;
+            else if (S_ISFIFO(inode->i_mode))
+              rsbac_target = T_FIFO;
+            else if (S_ISLNK(inode->i_mode))
+              rsbac_target = T_SYMLINK;
+            else
+              rsbac_target = T_FILE;
+            rsbac_target_id.file.device = inode->i_dev;
+            rsbac_target_id.file.inode  = inode->i_ino;
+            rsbac_target_id.file.dentry_p = filp->f_dentry;
+	  }
+        rsbac_attribute_value.ioctl_cmd = cmd;
+        if(   (rsbac_request != R_NONE)
+           && !rsbac_adf_request(rsbac_request,
+                                 current->pid,
+                                 rsbac_target,
+                                 rsbac_target_id,
+                                 A_ioctl_cmd,
+                                 rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	ext3_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
diff -urN -x rsbac trunk/fs/ext3/namei.c linux-2.4.32-rsbac-1.2.7/fs/ext3/namei.c
--- trunk/fs/ext3/namei.c	2006-06-01 10:30:56.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/ext3/namei.c	2006-06-01 10:32:31.000000000 +0200
@@ -29,6 +29,11 @@
 #include <linux/locks.h>
 #include <linux/quotaops.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_SECDEL
+#include <rsbac/adf.h>
+#endif
+
 
 /*
  * define how far ahead to read directories while searching them.
@@ -878,6 +883,13 @@
 	retval = ext3_delete_entry(handle, dir, de, bh);
 	if (retval)
 		goto end_unlink;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+        if(inode->i_nlink == 1)
+          rsbac_sec_del(dentry);
+        #endif
+
 	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
 	dir->u.ext3_i.i_flags &= ~EXT3_INDEX_FL;
 	ext3_mark_inode_dirty(handle, dir);
@@ -1021,6 +1033,12 @@
 			new_bh = NULL;
 		} else {
 			DQUOT_INIT(new_inode);
+
+                        /* RSBAC */
+                        #ifdef CONFIG_RSBAC_SECDEL
+                        if(new_inode->i_nlink == 1)
+                          rsbac_sec_del(new_dentry);
+                        #endif
 		}
 	}
 	if (S_ISDIR(old_inode->i_mode)) {
diff -urN -x rsbac trunk/fs/ext3/symlink.c linux-2.4.32-rsbac-1.2.7/fs/ext3/symlink.c
--- trunk/fs/ext3/symlink.c	2006-06-01 10:30:56.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/ext3/symlink.c	2006-06-01 10:32:31.000000000 +0200
@@ -21,15 +21,49 @@
 #include <linux/jbd.h>
 #include <linux/ext3_fs.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_SYM_REDIR
+#include <linux/slab.h>
+#include <rsbac/adf.h>
+#endif
+
 static int ext3_readlink(struct dentry *dentry, char *buffer, int buflen)
 {
 	char *s = (char *)dentry->d_inode->u.ext3_i.i_data;
+#ifdef CONFIG_RSBAC_SYM_REDIR
+        char * rsbac_name;
+        int res;
+
+	/* copying is ugly, but we must not change the const */
+        rsbac_name = rsbac_symlink_redirect(dentry, s, PAGE_SIZE);
+        if(rsbac_name)
+          {
+            res = vfs_readlink(dentry, buffer, buflen, rsbac_name);
+            kfree(rsbac_name);
+            return res;
+          }
+        else
+#endif
 	return vfs_readlink(dentry, buffer, buflen, s);
 }
 
 static int ext3_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
 	char *s = (char *)dentry->d_inode->u.ext3_i.i_data;
+#ifdef CONFIG_RSBAC_SYM_REDIR
+        char * rsbac_name;
+        int res;
+
+	/* copying is ugly, but we must not change the const */
+        rsbac_name = rsbac_symlink_redirect(dentry, s, PAGE_SIZE);
+        if(rsbac_name)
+          {
+            res = vfs_follow_link(nd, rsbac_name);
+            kfree(rsbac_name);
+            return res;
+          }
+        else
+#endif
 	return vfs_follow_link(nd, s);
 }
 
diff -urN -x rsbac trunk/fs/fcntl.c linux-2.4.32-rsbac-1.2.7/fs/fcntl.c
--- trunk/fs/fcntl.c	2006-06-01 10:30:54.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/fcntl.c	2006-06-01 10:32:30.000000000 +0200
@@ -17,6 +17,11 @@
 #include <asm/siginfo.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 extern int sock_fcntl (struct file *, unsigned int cmd, unsigned long arg);
 extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
@@ -256,6 +261,12 @@
 {
 	long err = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	switch (cmd) {
 		case F_DUPFD:
 			if (arg < NR_OPEN) {
@@ -297,6 +308,25 @@
 			force_successful_syscall_return();
 			break;
 		case F_SETOWN:
+                        /* RSBAC */
+                        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                        if (rsbac_debug_aef)
+                          rsbac_printk(KERN_DEBUG "do_fcntl(): calling ADF\n");
+#endif
+                        rsbac_target_id.process = arg;
+                        rsbac_attribute_value.dummy = 0;
+                        if(!rsbac_adf_request(R_SEND_SIGNAL,
+                                              current->pid,
+                                              T_PROCESS,
+                                              rsbac_target_id,
+                                              A_none,
+                                              rsbac_attribute_value))
+                          {
+                            return -EPERM;
+                          }
+                        #endif
+
 			lock_kernel();
 			filp->f_owner.pid = arg;
 			filp->f_owner.uid = current->uid;
diff -urN -x rsbac trunk/fs/ioctl.c linux-2.4.32-rsbac-1.2.7/fs/ioctl.c
--- trunk/fs/ioctl.c	2006-06-01 10:30:50.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/ioctl.c	2006-06-01 10:32:27.000000000 +0200
@@ -11,6 +11,11 @@
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_IOCTL
+#include <rsbac/adf.h>
+#endif
+
 static int file_ioctl(struct file *filp,unsigned int cmd,unsigned long arg)
 {
 	int error;
@@ -115,8 +120,69 @@
 			error = -ENOTTY;
 			if (S_ISREG(filp->f_dentry->d_inode->i_mode))
 				error = file_ioctl(filp, cmd, arg);
-			else if (filp->f_op && filp->f_op->ioctl)
+			else if (filp->f_op && filp->f_op->ioctl) {
+			        /* RSBAC */
+			        #ifdef CONFIG_RSBAC_IOCTL
+			        enum  rsbac_target_t          rsbac_target;
+			        union rsbac_target_id_t       rsbac_target_id;
+			        union rsbac_attribute_value_t rsbac_attribute_value;
+			        #endif
+
+				/* RSBAC */
+				#ifdef CONFIG_RSBAC_IOCTL
+				if(S_ISBLK(filp->f_dentry->d_inode->i_mode))
+				  {
+				    rsbac_target = T_DEV;
+				    rsbac_target_id.dev.type = D_block;
+				    rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+				    rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+				  }
+				else
+				if(S_ISCHR(filp->f_dentry->d_inode->i_mode))
+				  {
+				    rsbac_target = T_DEV;
+				    rsbac_target_id.dev.type = D_char;
+				    rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+				    rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+				  }
+				else
+                                #ifdef CONFIG_RSBAC_NET_OBJ
+				if(S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+				  {
+				    rsbac_target = T_NETOBJ;
+                                    rsbac_target_id.netobj.sock_p
+                                     = &filp->f_dentry->d_inode->u.socket_i;
+                                    rsbac_target_id.netobj.local_addr = NULL;
+                                    rsbac_target_id.netobj.local_len = 0;
+                                    rsbac_target_id.netobj.remote_addr = NULL;
+                                    rsbac_target_id.netobj.remote_len = 0;
+				  }
+				else
+				#endif
+				  rsbac_target = T_NONE;
+				if(rsbac_target != T_NONE)
+				  {
+				    #ifdef CONFIG_RSBAC_DEBUG
+				    if (rsbac_debug_aef)
+				      rsbac_printk(KERN_DEBUG "sys_ioctl(): calling ADF\n");
+				    #endif
+				    rsbac_attribute_value.ioctl_cmd = cmd;
+				    if (!rsbac_adf_request(R_IOCTL,
+				                           current->pid,
+				                           rsbac_target,
+				                           rsbac_target_id,
+				                           A_ioctl_cmd,
+				                           rsbac_attribute_value))
+				      {
+					unlock_kernel();
+					fput(filp);
+				        return -EPERM;
+				      }
+				  }
+				#endif
+
 				error = filp->f_op->ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+			}
 	}
 	unlock_kernel();
 	fput(filp);
diff -urN -x rsbac trunk/fs/locks.c linux-2.4.32-rsbac-1.2.7/fs/locks.c
--- trunk/fs/locks.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/locks.c	2006-06-01 10:32:29.000000000 +0200
@@ -126,6 +126,11 @@
 #include <asm/semaphore.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 int leases_enable = 1;
 int lease_break_time = 45;
 
@@ -1376,6 +1381,13 @@
 	struct file *filp;
 	int error, type;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -EBADF;
 	filp = fget(fd);
 	if (!filp)
@@ -1394,6 +1406,35 @@
 		&& !(filp->f_mode & 3))
 		goto out_putf;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_flock(): calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = filp->f_dentry->d_inode->i_dev;
+        rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out_putf;
+          }
+        #endif
+
 	lock_kernel();
 	error = flock_lock_file(filp, type,
 				(cmd & (LOCK_UN | LOCK_NB)) ? 0 : 1);
@@ -1415,6 +1456,13 @@
 	struct flock flock;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -EFAULT;
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
@@ -1431,6 +1479,35 @@
 	if (error)
 		goto out_putf;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "fcntl_getlk() [sys_fcntl()]: calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = filp->f_dentry->d_inode->i_dev;
+        rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out_putf;
+          }
+        #endif
+
 	if (filp->f_op && filp->f_op->lock) {
 		error = filp->f_op->lock(filp, F_GETLK, &file_lock);
 		if (error < 0)
@@ -1486,6 +1563,13 @@
 	struct inode *inode;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (file_lock == NULL)
 		return -ENOLCK;
 
@@ -1524,6 +1608,35 @@
 	if (error)
 		goto out_putf;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "fcntl_setlk() [sys_fcntl()]: calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = inode->i_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out_putf;
+          }
+        #endif
+
 	error = -EBADF;
 	switch (flock.l_type) {
 	case F_RDLCK:
@@ -1583,6 +1696,13 @@
 	struct flock64 flock;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -EFAULT;
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
@@ -1599,6 +1719,35 @@
 	if (error)
 		goto out_putf;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "fcntl_getlk64() [sys_fcntl()]: calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(filp->f_dentry->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = filp->f_dentry->d_inode->i_dev;
+        rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out_putf;
+          }
+        #endif
+
 	if (filp->f_op && filp->f_op->lock) {
 		error = filp->f_op->lock(filp, F_GETLK, &file_lock);
 		if (error < 0)
@@ -1642,6 +1791,13 @@
 	struct inode *inode;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (file_lock == NULL)
 		return -ENOLCK;
 
@@ -1680,6 +1836,35 @@
 	if (error)
 		goto out_putf;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "fcntl_setlk64() [sys_fcntl()]: calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = inode->i_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = filp->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out_putf;
+          }
+        #endif
+
 	error = -EBADF;
 	switch (flock.l_type) {
 	case F_RDLCK:
diff -urN -x rsbac trunk/fs/minix/namei.c linux-2.4.32-rsbac-1.2.7/fs/minix/namei.c
--- trunk/fs/minix/namei.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/minix/namei.c	2006-06-01 10:32:29.000000000 +0200
@@ -8,6 +8,11 @@
 #include <linux/minix_fs.h>
 #include <linux/pagemap.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_SECDEL
+#include <rsbac/adf.h>
+#endif
+
 static inline void inc_count(struct inode *inode)
 {
 	inode->i_nlink++;
@@ -200,6 +205,12 @@
 	if (err)
 		goto end_unlink;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+        if(inode->i_nlink == 1)
+          rsbac_sec_del(dentry);
+        #endif
+
 	inode->i_ctime = dir->i_ctime;
 	dec_count(inode);
 end_unlink:
@@ -256,6 +267,13 @@
 		new_de = minix_find_entry(new_dentry, &new_page);
 		if (!new_de)
 			goto out_dir;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_SECDEL
+                if(new_inode->i_nlink == 1)
+                  rsbac_sec_del(new_dentry);
+                #endif
+
 		inc_count(old_inode);
 		minix_set_link(new_de, new_page, old_inode);
 		new_inode->i_ctime = CURRENT_TIME;
diff -urN -x rsbac trunk/fs/msdos/namei.c linux-2.4.32-rsbac-1.2.7/fs/msdos/namei.c
--- trunk/fs/msdos/namei.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/msdos/namei.c	2006-06-01 10:32:29.000000000 +0200
@@ -17,6 +17,11 @@
 
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_SECDEL
+#include <rsbac/adf.h>
+#endif
+
 #define MSDOS_DEBUG 0
 #define PRINTK(x)
 
@@ -431,6 +436,12 @@
 	fat_brelse(sb, bh);
 	inode->i_nlink = 0;
 	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+        rsbac_sec_del(dentry);
+        #endif
+
 	mark_inode_dirty(inode);
 	mark_inode_dirty(dir);
 	res = 0;
@@ -486,7 +497,15 @@
 	/* There we go */
 
 	if (new_inode)
+	      {
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_SECDEL
+                if(new_inode->i_nlink == 1)
+                  rsbac_sec_del(new_dentry);
+                #endif
+
 		fat_detach(new_inode);
+	      }
 	old_de->name[0] = DELETED_FLAG;
 	fat_mark_buffer_dirty(sb, old_bh);
 	fat_detach(old_inode);
diff -urN -x rsbac trunk/fs/namei.c linux-2.4.32-rsbac-1.2.7/fs/namei.c
--- trunk/fs/namei.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/namei.c	2006-06-01 10:32:29.000000000 +0200
@@ -26,6 +26,15 @@
 #include <asm/namei.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#include <rsbac/fs.h>
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_FULL
+#include <rsbac/debug.h>
+#endif
+#endif
+
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 
 /* [Feb-1997 T. Schoebel-Theuer]
@@ -198,6 +207,11 @@
 
 int permission(struct inode * inode,int mask)
 {
+#ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_FULL
+	if(rsbac_dac_disable)
+	  return 0;
+#endif
+
 	if (inode->i_op && inode->i_op->permission) {
 		int retval;
 		lock_kernel();
@@ -335,6 +349,13 @@
 static inline int do_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
 	int err;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (current->link_count >= 5)
 		goto loop;
 	if (current->total_link_count >= 40)
@@ -343,6 +364,30 @@
 		current->state = TASK_RUNNING;
 		schedule();
 	}
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+/* too much...
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_follow_link(): calling ADF\n");
+#endif
+*/
+        rsbac_target_id.dir.device = dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_SEARCH,
+                               current->pid,
+                               T_SYMLINK,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+             path_release(nd);
+             return -EPERM;
+          }
+        #endif
+
 	current->link_count++;
 	current->total_link_count++;
 	UPDATE_ATIME(dentry->d_inode);
@@ -454,6 +499,12 @@
 	int err;
 	unsigned int lookup_flags = nd->flags;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	while (*name=='/')
 		name++;
 	if (!*name)
@@ -469,11 +520,41 @@
 		struct qstr this;
 		unsigned int c;
 
+                #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+                if(rsbac_dac_part_disabled(nd->dentry))
+                  err = 0;
+                else
+                #endif
 		err = permission(inode, MAY_EXEC);
 		dentry = ERR_PTR(err);
  		if (err)
 			break;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+/* too much...
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "link_path_walk(): calling ADF\n");
+#endif
+*/
+                rsbac_target_id.dir.device = inode->i_dev;
+                rsbac_target_id.dir.inode  = inode->i_ino;
+                rsbac_target_id.dir.dentry_p = nd->dentry;
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_SEARCH,
+                                       current->pid,
+                                       T_DIR,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    dentry = ERR_PTR(err);
+                    break;
+                  }
+                #endif
+
 		this.name = name;
 		c = *(const unsigned char *)name;
 
@@ -779,12 +860,49 @@
 	struct inode *inode;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	inode = base->d_inode;
+
+        #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+        if(rsbac_dac_part_disabled(base))
+          err = 0;
+        else
+        #endif
 	err = permission(inode, MAY_EXEC);
 	dentry = ERR_PTR(err);
 	if (err)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+/*
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+                    rsbac_printk(KERN_DEBUG "lookup_hash(): calling ADF\n");
+#endif
+*/
+        rsbac_target_id.dir.device = inode->i_dev;
+        rsbac_target_id.dir.inode  = inode->i_ino;
+        rsbac_target_id.dir.dentry_p = base;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_SEARCH,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            err = -EPERM;
+            dentry = ERR_PTR(err);
+            goto out;
+          }
+        #endif
+
 	/*
 	 * See if the low-level filesystem might want
 	 * to use its own hash..
@@ -840,6 +958,79 @@
 	return ERR_PTR(-EACCES);
 }
 
+/* RSBAC *
+ * I hate to put new functions into this file, but even more I hate removing
+ * all statics from all the lookup helpers in here...
+ * Still, I need some form of RSBAC bypass for internal file access.
+ * Amon Ott <ao@rsbac.org>
+ */
+#ifdef CONFIG_RSBAC
+struct dentry * rsbac_lookup_hash(struct qstr *name, struct dentry * base)
+{
+	struct dentry * dentry;
+	struct inode *inode;
+	int err;
+
+	inode = base->d_inode;
+	err = 0;
+	dentry = ERR_PTR(err);
+
+	/*
+	 * See if the low-level filesystem might want
+	 * to use its own hash..
+	 */
+	if (base->d_op && base->d_op->d_hash) {
+		err = base->d_op->d_hash(base, name);
+		dentry = ERR_PTR(err);
+		if (err < 0)
+			goto out;
+	}
+
+	dentry = cached_lookup(base, name, 0);
+	if (!dentry) {
+		struct dentry *new = d_alloc(base, name);
+		dentry = ERR_PTR(-ENOMEM);
+		if (!new)
+			goto out;
+		lock_kernel();
+		dentry = inode->i_op->lookup(inode, new);
+		unlock_kernel();
+		if (!dentry)
+			dentry = new;
+		else
+			dput(new);
+	}
+out:
+	return dentry;
+}
+
+/* SMP-safe */
+struct dentry * rsbac_lookup_one_len(const char * name, struct dentry * base, int len)
+{
+	unsigned long hash;
+	struct qstr this;
+	unsigned int c;
+
+	this.name = name;
+	this.len = len;
+	if (!len)
+		goto access;
+
+	hash = init_name_hash();
+	while (len--) {
+		c = *(const unsigned char *)name++;
+		if (c == '/' || c == '\0')
+			goto access;
+		hash = partial_name_hash(c, hash);
+	}
+	this.hash = end_name_hash(hash);
+
+	return rsbac_lookup_hash(&this, base);
+access:
+	return ERR_PTR(-EACCES);
+}
+#endif
+
 /*
  *	namei()
  *
@@ -903,6 +1094,12 @@
 	int error;
 	if (!victim->d_inode || victim->d_parent->d_inode != dir)
 		return -ENOENT;
+
+        #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+        if(rsbac_dac_part_disabled(victim))
+          error = 0;
+        else
+        #endif
 	error = permission(dir,MAY_WRITE | MAY_EXEC);
 	if (error)
 		return error;
@@ -936,6 +1133,12 @@
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
+
+        #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+        if(rsbac_dac_part_disabled(child->d_parent))
+          return 0;
+        else
+        #endif
 	return permission(dir,MAY_WRITE | MAY_EXEC);
 }
 
@@ -965,6 +1168,15 @@
 {
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        enum  rsbac_target_t          rsbac_new_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	mode &= S_IALLUGO;
 	mode |= S_IFREG;
 
@@ -977,10 +1189,60 @@
 	if (!dir->i_op || !dir->i_op->create)
 		goto exit_lock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "vfs_create() [open_namei() [filp_open() [do_open() [sys_open()]]]]: calling ADF\n");
+#endif
+        rsbac_target = T_DIR;
+        rsbac_target_id.dir.device = dir->i_dev;
+        rsbac_target_id.dir.inode  = dir->i_ino;
+        rsbac_target_id.dir.dentry_p = dentry->d_parent;
+        rsbac_attribute_value.create_data.target = T_FILE;
+        rsbac_attribute_value.create_data.dentry_p = dentry;
+        rsbac_attribute_value.create_data.mode = mode;
+        rsbac_attribute_value.create_data.device = 0;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_create_data,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto exit_lock;
+          }
+        #endif
+
 	DQUOT_INIT(dir);
 	lock_kernel();
 	error = dir->i_op->create(dir, dentry, mode);
 	unlock_kernel();
+
+        /* RSBAC: notify ADF of new file */
+        #ifdef CONFIG_RSBAC
+        if (!error)
+          {
+            rsbac_new_target = T_FILE;
+            rsbac_new_target_id.file.device = dentry->d_inode->i_dev;
+            rsbac_new_target_id.file.inode  = dentry->d_inode->i_ino;
+            rsbac_new_target_id.file.dentry_p = dentry;
+            if (rsbac_adf_set_attr(R_CREATE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   rsbac_new_target,
+                                   rsbac_new_target_id,
+                                   A_create_data,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "vfs_create() [open_namei() [filp_open() [do_open() [sys_open()]]]]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 exit_lock:
 	up(&dir->i_zombie);
 	if (!error)
@@ -1011,6 +1273,15 @@
 	struct dentry *dir;
 	int count = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_adf_req;
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	acc_mode = ACC_MODE(flag);
 
 	/*
@@ -1106,6 +1377,12 @@
 	if (S_ISDIR(inode->i_mode) && (flag & FMODE_WRITE))
 		goto exit;
 
+
+        #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+        if(rsbac_dac_part_disabled(dentry))
+          error = 0;
+        else
+        #endif
 	error = permission(inode,acc_mode);
 	if (error)
 		goto exit;
@@ -1146,6 +1423,97 @@
 	if (error)
 		goto exit;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "open_namei() [filp_open() [do_open() [sys_open()]]]: calling ADF\n");
+#endif
+        /* get target type and id clear */
+        if(   S_ISBLK(inode->i_mode)
+           || S_ISCHR(inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            if(S_ISBLK(inode->i_mode))
+              rsbac_target_id.dev.type = D_block;
+            else
+              rsbac_target_id.dev.type = D_char;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(inode->i_rdev);
+          }
+        else
+        if(S_ISSOCK(inode->i_mode))
+          {
+          }
+        else /* must be file, dir or fifo */
+          {
+            if(S_ISDIR(inode->i_mode))
+              {
+                rsbac_target = T_DIR;
+                rsbac_target_id.dir.device = inode->i_dev;
+                rsbac_target_id.dir.inode  = inode->i_ino;
+                rsbac_target_id.dir.dentry_p = dentry;
+	      }
+            else if(S_ISFIFO(inode->i_mode))
+              {
+                if(inode->i_sb->s_magic != PIPEFS_MAGIC)
+                  {
+                    rsbac_target = T_FIFO;
+                    rsbac_target_id.dir.device = inode->i_dev;
+                    rsbac_target_id.dir.inode  = inode->i_ino;
+                    rsbac_target_id.dir.dentry_p = dentry;
+                  }
+                else
+                  {
+                    rsbac_target = T_IPC;
+                    rsbac_target_id.ipc.type = I_anonpipe;
+                    rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+                  }
+              }
+            else
+              {
+                rsbac_target = T_FILE;
+                rsbac_target_id.file.device = inode->i_dev;
+                rsbac_target_id.file.inode  = inode->i_ino;
+                rsbac_target_id.file.dentry_p = dentry;
+              }
+          }
+        /* determine request type */
+        rsbac_adf_req = R_NONE;
+        if (flag & O_APPEND)
+          rsbac_adf_req = R_APPEND_OPEN;
+        else
+          if ((flag & FMODE_WRITE) && (flag & FMODE_READ))
+            rsbac_adf_req = R_READ_WRITE_OPEN;
+          else
+            if (flag & FMODE_WRITE)
+              rsbac_adf_req = R_WRITE_OPEN;
+            else
+              if (flag & FMODE_READ)
+                {
+                  if(rsbac_target == T_DIR)
+                    rsbac_adf_req = R_READ;
+                  else
+                    rsbac_adf_req = R_READ_OPEN;
+                }
+        if (   (rsbac_adf_req != R_NONE)
+            && (rsbac_target != T_NONE)
+           )
+          {
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(rsbac_adf_req,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                error = -EPERM;
+                goto exit;
+              }
+          }
+        #endif /* CONFIG_RSBAC */
+
 	if (flag & O_TRUNC) {
 		error = get_write_access(inode);
 		if (error)
@@ -1157,7 +1525,7 @@
 		error = locks_verify_locked(inode);
 		if (!error) {
 			DQUOT_INIT(inode);
-			
+
 			error = do_truncate(dentry, 0);
 		}
 		put_write_access(inode);
@@ -1167,6 +1535,28 @@
 		if (flag & FMODE_WRITE)
 			DQUOT_INIT(inode);
 
+        /* RSBAC: notify adf of opened file */
+        #ifdef CONFIG_RSBAC
+        if (   (rsbac_adf_req != R_NONE)
+            && (rsbac_target != T_NONE)
+           )
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(rsbac_adf_req,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "open_namei() [filp_open() [do_open() [sys_open()]]]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 	return 0;
 
 exit_dput:
@@ -1189,6 +1579,30 @@
 	 * stored in nd->last.name and we will have to putname() it when we
 	 * are done. Procfs-like symlinks just set LAST_BIND.
 	 */
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+/* too much...
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "open_namei() [filp_open() [do_open() [sys_open()]]]: calling ADF\n");
+#endif
+*/
+        rsbac_target_id.dir.device = nd->dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd->dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_SEARCH,
+                               current->pid,
+                               T_SYMLINK,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+             error = -EPERM;
+             goto exit_dput;
+          }
+        #endif
+
 	UPDATE_ATIME(dentry->d_inode);
 	mnt = mntget(nd->mnt);
 	error = dentry->d_inode->i_op->follow_link(dentry, nd);
@@ -1245,6 +1659,14 @@
 {
 	int error = -EPERM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        enum  rsbac_target_t          rsbac_new_target;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	down(&dir->i_zombie);
 	if ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))
 		goto exit_lock;
@@ -1257,10 +1679,68 @@
 	if (!dir->i_op || !dir->i_op->mknod)
 		goto exit_lock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "vfs_mknod() [sys_mknod()]: calling ADF\n");
+#endif
+        rsbac_target_id.dir.device = dir->i_dev;
+        rsbac_target_id.dir.inode  = dir->i_ino;
+        rsbac_target_id.dir.dentry_p = dentry->d_parent;
+        rsbac_attribute_value.create_data.target = T_FILE;
+        rsbac_attribute_value.create_data.dentry_p = dentry;
+        rsbac_attribute_value.create_data.mode = mode;
+        rsbac_attribute_value.create_data.device = dev;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_create_data,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto exit_lock;
+          }
+        #endif
+
 	DQUOT_INIT(dir);
 	lock_kernel();
 	error = dir->i_op->mknod(dir, dentry, mode, dev);
 	unlock_kernel();
+
+        /* RSBAC: notify ADF of new dir entry */
+        #ifdef CONFIG_RSBAC
+        if (!error)
+          {
+            if(S_ISFIFO(dentry->d_inode->i_mode))
+              rsbac_new_target = T_FIFO;
+            else
+            if(S_ISLNK(dentry->d_inode->i_mode))
+              rsbac_new_target = T_SYMLINK;
+            else
+              rsbac_new_target = T_FILE;
+            rsbac_new_target_id.dir.device = dentry->d_inode->i_dev;
+            rsbac_new_target_id.dir.inode  = dentry->d_inode->i_ino;
+            rsbac_new_target_id.dir.dentry_p = dentry;
+            if (rsbac_adf_set_attr(R_CREATE,
+                                   current->pid,
+                                   T_DIR,
+                                   rsbac_target_id,
+                                   rsbac_new_target,
+                                   rsbac_new_target_id,
+                                   A_create_data,
+                                   rsbac_attribute_value))
+              {
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG
+                         "vfs_mknod() [do_mknod(), sys_mknod()]: rsbac_adf_set_attr() returned error");
+#endif
+              }
+          }
+        #endif
+
 exit_lock:
 	up(&dir->i_zombie);
 	if (!error)
@@ -1316,6 +1796,13 @@
 {
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	down(&dir->i_zombie);
 	error = may_create(dir, dentry);
 	if (error)
@@ -1325,12 +1812,59 @@
 	if (!dir->i_op || !dir->i_op->mkdir)
 		goto exit_lock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "vfs_mkdir() [sys_mkdir()]: calling ADF\n");
+#endif
+        rsbac_target_id.dir.device = dir->i_dev;
+        rsbac_target_id.dir.inode  = dir->i_ino;
+        rsbac_target_id.dir.dentry_p = dentry->d_parent;
+        rsbac_attribute_value.create_data.target = T_DIR;
+        rsbac_attribute_value.create_data.dentry_p = dentry;
+        rsbac_attribute_value.create_data.mode = mode;
+        rsbac_attribute_value.create_data.device = 0;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_create_data,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto exit_lock;
+          }
+        #endif
+
 	DQUOT_INIT(dir);
 	mode &= (S_IRWXUGO|S_ISVTX);
 	lock_kernel();
 	error = dir->i_op->mkdir(dir, dentry, mode);
 	unlock_kernel();
 
+        /* RSBAC: notify ADF of new dir */
+        #ifdef CONFIG_RSBAC
+        if (!error)
+          {
+            rsbac_new_target_id.dir.device = dentry->d_inode->i_dev;
+            rsbac_new_target_id.dir.inode  = dentry->d_inode->i_ino;
+            rsbac_new_target_id.dir.dentry_p = dentry;
+            if (rsbac_adf_set_attr(R_CREATE,
+                                   current->pid,
+                                   T_DIR,
+                                   rsbac_target_id,
+                                   T_DIR,
+                                   rsbac_new_target_id,
+                                   A_create_data,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "vfs_mkdir() [sys_mkdir()]: rsbac_adf_set_attr() returned error");
+              }
+          }
+        #endif
+
 exit_lock:
 	up(&dir->i_zombie);
 	if (!error)
@@ -1404,6 +1938,13 @@
 {
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = may_delete(dir, dentry, 1);
 	if (error)
 		return error;
@@ -1411,6 +1952,27 @@
 	if (!dir->i_op || !dir->i_op->rmdir)
 		return -EPERM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "vfs_rmdir() [sys_rmdir()]: calling ADF\n");
+#endif
+        rsbac_target_id.dir.device = dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_DELETE,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	DQUOT_INIT(dir);
 
 	double_down(&dir->i_zombie, &dentry->d_inode->i_zombie);
@@ -1429,8 +1991,28 @@
 		inode_dir_notify(dir, DN_DELETE);
 		d_delete(dentry);
 	}
-	dput(dentry);
 
+        /* RSBAC: notify ADF of deleted dir */
+        #ifdef CONFIG_RSBAC
+        if (!error)
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_DELETE,
+                                   current->pid,
+                                   T_DIR,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "vfs_rmdir() [sys_rmdir()]: rsbac_adf_set_attr() returned error");
+              }
+          }
+        #endif
+
+	dput(dentry);
 	return error;
 }
 
@@ -1479,6 +2061,14 @@
 {
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	down(&dir->i_zombie);
 	error = may_delete(dir, dentry, 0);
 	if (!error) {
@@ -1488,9 +2078,62 @@
 			if (d_mountpoint(dentry))
 				error = -EBUSY;
 			else {
+                                /* RSBAC */
+                                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                                if (rsbac_debug_aef)
+                                  rsbac_printk(KERN_DEBUG "vfs_unlink() [do_unlink() [sys_unlink()]]: calling ADF\n");
+#endif
+                                if(S_ISDIR(dentry->d_inode->i_mode))
+                                  rsbac_target = T_DIR;
+                                else
+                                if(S_ISFIFO(dentry->d_inode->i_mode))
+                                  rsbac_target = T_FIFO;
+                                else
+                                if(S_ISLNK(dentry->d_inode->i_mode))
+                                  rsbac_target = T_SYMLINK;
+                                else
+                                  rsbac_target = T_FILE;
+                                rsbac_target_id.file.device = dentry->d_inode->i_dev;
+                                rsbac_target_id.file.inode  = dentry->d_inode->i_ino;
+                                rsbac_target_id.file.dentry_p = dentry;
+                                rsbac_attribute_value.nlink = dentry->d_inode->i_nlink;
+                                if (!rsbac_adf_request(R_DELETE,
+                                                       current->pid,
+                                                       rsbac_target,
+                                                       rsbac_target_id,
+                                                       A_nlink,
+                                                       rsbac_attribute_value))
+                                  {
+                                    up(&dir->i_zombie);
+                                    return(-EPERM);
+                                  }
+                                #endif
+ 
 				lock_kernel();
 				error = dir->i_op->unlink(dir, dentry);
 				unlock_kernel();
+
+                                /* RSBAC: notify ADF of deleted file */
+                                #ifdef CONFIG_RSBAC
+                                if (!error)
+                                  {
+                                    rsbac_new_target_id.dummy = 0;
+                                    if (rsbac_adf_set_attr(R_DELETE,
+                                                           current->pid,
+                                                           rsbac_target,
+                                                           rsbac_target_id,
+                                                           T_NONE,
+                                                           rsbac_new_target_id,
+                                                           A_nlink,
+                                                           rsbac_attribute_value))
+                                      {
+                                        rsbac_printk(KERN_WARNING
+                                               "vfs_unlink() [do_unlink() [sys_unlink()]]: rsbac_adf_set_attr() returned error\n");
+                                      }
+                                  }
+                                #endif
+
 				if (!error)
 					d_delete(dentry);
 			}
@@ -1548,6 +2191,13 @@
 {
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	down(&dir->i_zombie);
 	error = may_create(dir, dentry);
 	if (error)
@@ -1557,11 +2207,58 @@
 	if (!dir->i_op || !dir->i_op->symlink)
 		goto exit_lock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "vfs_symlink() [sys_symlink()]: calling ADF\n");
+#endif
+        rsbac_target_id.dir.device = dir->i_dev;
+        rsbac_target_id.dir.inode  = dir->i_ino;
+        rsbac_target_id.dir.dentry_p = dentry->d_parent;
+        rsbac_attribute_value.create_data.target = T_SYMLINK;
+        rsbac_attribute_value.create_data.dentry_p = dentry;
+        rsbac_attribute_value.create_data.mode = 0;
+        rsbac_attribute_value.create_data.device = 0;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_create_data,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto exit_lock;
+          }
+        #endif
+
 	DQUOT_INIT(dir);
 	lock_kernel();
 	error = dir->i_op->symlink(dir, dentry, oldname);
 	unlock_kernel();
 
+        /* RSBAC: notify ADF of new file */
+        #ifdef CONFIG_RSBAC
+        if (!error && dentry->d_inode)
+          {
+            rsbac_new_target_id.file.device = dentry->d_inode->i_dev;
+            rsbac_new_target_id.file.inode  = dentry->d_inode->i_ino;
+            rsbac_new_target_id.file.dentry_p = dentry;
+            if (rsbac_adf_set_attr(R_CREATE,
+                                   current->pid,
+                                   T_DIR,
+                                   rsbac_target_id,
+                                   T_SYMLINK,
+                                   rsbac_new_target_id,
+                                   A_create_data,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "vfs_symlink() [sys_symlink()]: rsbac_adf_set_attr() returned error");
+              }
+          }
+        #endif
+
 exit_lock:
 	up(&dir->i_zombie);
 	if (!error)
@@ -1607,6 +2304,13 @@
 	struct inode *inode;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	down(&dir->i_zombie);
 	error = -ENOENT;
 	inode = old_dentry->d_inode;
@@ -1630,6 +2334,35 @@
 	if (!dir->i_op || !dir->i_op->link)
 		goto exit_lock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "vfs_link() [sys_link()]: calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR (old_dentry->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO (old_dentry->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK (old_dentry->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.dir.device = old_dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = old_dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = old_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_LINK_HARD,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto exit_lock;
+          }
+        #endif
+
 	DQUOT_INIT(dir);
 	lock_kernel();
 	error = dir->i_op->link(old_dentry, dir, new_dentry);
@@ -1745,6 +2478,11 @@
 	 * we'll need to flip '..'.
 	 */
 	if (new_dir != old_dir) {
+                #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+                if(rsbac_dac_part_disabled(old_dentry))
+                  error = 0;
+                else
+                #endif
 		error = permission(old_dentry->d_inode, MAY_WRITE);
 	}
 	if (error)
@@ -1861,6 +2599,15 @@
 	struct dentry * old_dentry, *new_dentry;
 	struct nameidata oldnd, newnd;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        rsbac_boolean_t target_exists = FALSE;
+        #endif
+
 	error = path_lookup(oldname, LOOKUP_PARENT, &oldnd);
 	if (error)
 		goto exit;
@@ -1905,11 +2652,113 @@
 	if (IS_ERR(new_dentry))
 		goto exit4;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG
+                 "do_rename() [sys_rename()]: calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(old_dentry->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO (old_dentry->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK (old_dentry->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = old_dentry->d_inode->i_dev;
+        rsbac_target_id.file.inode  = old_dentry->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = old_dentry;
+        rsbac_attribute_value.new_dir_dentry_p = new_dir;
+        if (!rsbac_adf_request(R_RENAME,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_new_dir_dentry_p,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            dput(new_dentry);
+            goto exit4;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG
+                 "do_rename() [sys_rename()]: calling ADF for WRITE on new_dir\n");
+#endif
+        rsbac_target_id.dir.device = new_dir->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = new_dir->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = new_dir;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_WRITE,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            dput(new_dentry);
+            goto exit4;
+          }
+        if(new_dentry->d_inode)
+          {
+            target_exists = TRUE;
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG
+                     "do_rename() [sys_rename()]: calling ADF for DELETE on existing target\n");
+#endif
+            rsbac_target = T_FILE;
+            if (S_ISDIR(new_dentry->d_inode->i_mode))
+              rsbac_target = T_DIR;
+            else if (S_ISFIFO (new_dentry->d_inode->i_mode))
+              rsbac_target = T_FIFO;
+            else if (S_ISLNK (new_dentry->d_inode->i_mode))
+              rsbac_target = T_SYMLINK;
+            rsbac_target_id.file.device = new_dentry->d_inode->i_dev;
+            rsbac_target_id.file.inode  = new_dentry->d_inode->i_ino;
+            rsbac_target_id.file.dentry_p = new_dentry;
+            rsbac_attribute_value.nlink = new_dentry->d_inode->i_nlink;
+            if (!rsbac_adf_request(R_DELETE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   A_nlink,
+                                   rsbac_attribute_value))
+              {
+                error = -EPERM;
+                dput(new_dentry);
+                goto exit4;
+              }
+          }
+        #endif /* CONFIG_RSBAC */
+
 	lock_kernel();
 	error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+        /* RSBAC: notify ADF of deleted file */
+        #ifdef CONFIG_RSBAC
+        if (target_exists && !error)
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_DELETE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_nlink,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "do_rename() [sys_rename()]: rsbac_adf_set_attr() returned error");
+              }
+          }
+        #endif
+
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2027,7 +2876,21 @@
 {
 	struct page *page = NULL;
 	char *s = page_getlink(dentry, &page);
-	int res = vfs_readlink(dentry,buffer,buflen,s);
+	int res;
+#ifdef CONFIG_RSBAC_SYM_REDIR
+	char * rsbac_name;
+#endif
+
+#ifdef CONFIG_RSBAC_SYM_REDIR
+        rsbac_name = rsbac_symlink_redirect(dentry, s, PAGE_SIZE);
+        if(rsbac_name)
+          {
+            res = vfs_readlink(dentry,buffer,buflen,rsbac_name);
+            kfree(rsbac_name);
+          }
+        else
+#endif
+	res = vfs_readlink(dentry,buffer,buflen,s);
 	if (page) {
 		kunmap(page);
 		page_cache_release(page);
@@ -2039,7 +2902,22 @@
 {
 	struct page *page = NULL;
 	char *s = page_getlink(dentry, &page);
-	int res = __vfs_follow_link(nd, s);
+	int res;
+#ifdef CONFIG_RSBAC_SYM_REDIR
+	char * rsbac_name;
+#endif
+
+#ifdef CONFIG_RSBAC_SYM_REDIR
+        rsbac_name = rsbac_symlink_redirect(dentry, s, PAGE_SIZE);
+        if(rsbac_name)
+          {
+            res = __vfs_follow_link(nd, rsbac_name);
+            kfree(rsbac_name);
+          }
+        else
+#endif
+	res = __vfs_follow_link(nd, s);
+
 	if (page) {
 		kunmap(page);
 		page_cache_release(page);
diff -urN -x rsbac trunk/fs/namespace.c linux-2.4.32-rsbac-1.2.7/fs/namespace.c
--- trunk/fs/namespace.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/namespace.c	2006-06-01 10:32:29.000000000 +0200
@@ -21,6 +21,12 @@
 #include <linux/seq_file.h>
 #include <linux/namespace.h>
 
+/* RSBAC: including rsbac_mount/umount declaration and adf-calls*/
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#include <rsbac/adf.h>
+#endif
+
 struct vfsmount *do_kern_mount(const char *type, int flags, char *name, void *data);
 int do_remount_sb(struct super_block *sb, int flags, void * data);
 void kill_super(struct super_block *sb);
@@ -291,6 +297,12 @@
 	struct super_block * sb = mnt->mnt_sb;
 	int retval = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/*
 	 * If we may have to abort operations to get out of this
 	 * mount, and they will themselves hold resources we must
@@ -320,6 +332,45 @@
 		 * Special case for "unmounting" root ...
 		 * we just try to remount it readonly.
 		 */
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                    rsbac_printk(KERN_DEBUG "do_umount(): calling ADF for DIR\n");
+#endif
+                rsbac_target_id.dir.device = sb->s_root->d_inode->i_dev;
+                rsbac_target_id.dir.inode  = sb->s_root->d_inode->i_ino;
+                rsbac_target_id.dir.dentry_p = sb->s_root;
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_UMOUNT,
+                                       current->pid,
+                                       T_DIR,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "do_umount(): calling ADF for DEV\n");
+#endif
+                rsbac_target_id.dev.type = D_block;
+                rsbac_target_id.dev.major = RSBAC_MAJOR(sb->s_dev);
+                rsbac_target_id.dev.minor = RSBAC_MINOR(sb->s_dev);
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_UMOUNT,
+                                       current->pid,
+                                       T_DEV,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
+
 		down_write(&sb->s_umount);
 		if (!(sb->s_flags & MS_RDONLY)) {
 			lock_kernel();
@@ -331,6 +382,57 @@
 	}
 
 	down_write(&current->namespace->sem);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_umount(): calling ADF for DIR\n");
+#endif
+        rsbac_target_id.dir.device = sb->s_root->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = sb->s_root->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = sb->s_root;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            up_write(&current->namespace->sem);
+            return -EPERM;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_umount(): calling ADF for DEV\n");
+#endif
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(sb->s_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(sb->s_dev);
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            up_write(&current->namespace->sem);
+            return -EPERM;
+          }
+        #endif
+
+        /* RSBAC: removing data structures for this fs from memory */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_ds)
+          rsbac_printk(KERN_DEBUG "do_umount() [sys_umount()]: calling rsbac_umount for Device %02u:%02u\n",
+                       MAJOR(mnt->mnt_sb->s_dev), MINOR(mnt->mnt_sb->s_dev));
+#endif
+        rsbac_umount(mnt->mnt_sb, mnt->mnt_mountpoint);
+        #endif
+
 	spin_lock(&dcache_lock);
 
 	if (atomic_read(&sb->s_active) == 1) {
@@ -349,6 +451,18 @@
 		retval = 0;
 	}
 	spin_unlock(&dcache_lock);
+
+        #ifdef CONFIG_RSBAC
+        /* RSBAC: umount failed, so reread data structures for this fs from disk */
+        if(retval)
+          {
+            rsbac_printk(KERN_WARNING
+                   "do_umount() [sys_umount()]: umount failed -> calling rsbac_mount for Device %02u:%02u\n",
+                   MAJOR(mnt->mnt_sb->s_dev),MINOR(mnt->mnt_sb->s_dev));
+            rsbac_mount(mnt->mnt_sb, mnt->mnt_mountpoint);
+          }
+        #endif
+
 	up_write(&current->namespace->sem);
 	return retval;
 }
@@ -489,6 +603,14 @@
 	struct nameidata old_nd;
 	struct vfsmount *mnt = NULL;
 	int err = mount_is_safe(nd);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (err)
 		return err;
 	if (!old_name || !*old_name)
@@ -497,6 +619,62 @@
 	if (err)
 		return err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_loopback() [do_mount() [sys_mount()]]: calling ADF for DIR\n");
+#endif
+        rsbac_target_id.dir.device = nd->dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd->dentry;
+        rsbac_attribute_value.mode = recurse;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_loopback() [do_mount() [sys_mount()]]: calling ADF for DEV\n");
+#endif
+        if(S_ISBLK(old_nd.dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(old_nd.dentry->d_inode->i_dev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(old_nd.dentry->d_inode->i_dev);
+          }
+        else
+        if(S_ISDIR(old_nd.dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_DIR;
+            rsbac_target_id.dir.device = old_nd.dentry->d_inode->i_dev;
+            rsbac_target_id.dir.inode  = old_nd.dentry->d_inode->i_ino;
+            rsbac_target_id.dir.dentry_p = old_nd.dentry;
+          }
+        else
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.file.device = old_nd.dentry->d_inode->i_dev;
+            rsbac_target_id.file.inode  = old_nd.dentry->d_inode->i_ino;
+            rsbac_target_id.file.dentry_p = old_nd.dentry;
+          }
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&current->namespace->sem);
 	err = -EINVAL;
 	if (check_mnt(nd->mnt) && (!recurse || check_mnt(old_nd.mnt))) {
@@ -509,6 +687,20 @@
 
 	if (mnt) {
 		err = graft_tree(mnt, nd);
+
+                /* RSBAC: initialising data structures for this fs (not root fs) */
+                #ifdef CONFIG_RSBAC
+                if(!err)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_ds)
+                      rsbac_printk(KERN_DEBUG "do_loopback() [do_mount() [sys_mount()]]: calling rsbac_mount for Device %02u:%02u\n",
+                                   MAJOR(mnt->mnt_sb->s_dev), MINOR(mnt->mnt_sb->s_dev));
+#endif
+                    rsbac_mount(mnt->mnt_sb, mnt->mnt_mountpoint);
+                  }
+                #endif
+
 		if (err) {
 			spin_lock(&dcache_lock);
 			umount_tree(mnt);
@@ -533,6 +725,12 @@
 	int err;
 	struct super_block * sb = nd->mnt->mnt_sb;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
@@ -542,6 +740,43 @@
 	if (nd->dentry != nd->mnt->mnt_root)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_remount() [do_mount() [sys_mount()]]: calling ADF for DIR\n");
+#endif
+        rsbac_target_id.dir.device = nd->dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd->dentry;
+        rsbac_attribute_value.mode = flags;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_remount() [do_mount() [sys_mount()]]: calling ADF for DEV\n");
+#endif
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(sb->s_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(sb->s_dev);
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&sb->s_umount);
 	err = do_remount_sb(sb, flags, data);
 	if (!err)
@@ -555,6 +790,13 @@
 	struct nameidata old_nd, parent_nd;
 	struct vfsmount *p;
 	int err = 0;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (!old_name || !*old_name)
@@ -563,6 +805,77 @@
 	if (err)
 		return err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_move_mount() [do_mount() [sys_mount()]]: calling ADF for UMOUNT on old DIR\n");
+#endif
+        rsbac_target_id.dir.device = old_nd.dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = old_nd.dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = old_nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            path_release(&old_nd);
+            return -EPERM;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_move_mount() [do_mount() [sys_mount()]]: calling ADF for MOUNT on new DIR\n");
+#endif
+        rsbac_target_id.dir.device = nd->dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd->dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            path_release(&old_nd);
+            return -EPERM;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_move_mount() [do_mount() [sys_mount()]]: calling ADF for UMOUNT on DEV\n");
+#endif
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(old_nd.dentry->d_sb->s_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(old_nd.dentry->d_sb->s_dev);
+        if (!rsbac_adf_request(R_UMOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            path_release(&old_nd);
+            return -EPERM;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_move_mount() [do_mount() [sys_mount()]]: calling ADF for MOUNT on DEV\n");
+#endif
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            path_release(&old_nd);
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&current->namespace->sem);
 	while(d_mountpoint(nd->dentry) && follow_down(&nd->mnt, &nd->dentry))
 		;
@@ -616,6 +929,12 @@
 	struct vfsmount *mnt;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!type || !memchr(type, 0, PAGE_SIZE))
 		return -EINVAL;
 
@@ -641,8 +960,62 @@
 	if (nd->mnt->mnt_sb == mnt->mnt_sb && nd->mnt->mnt_root == nd->dentry)
 		goto unlock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_add_mount() [do_mount() [sys_mount()]]: calling ADF for DIR\n");
+#endif
+        rsbac_target_id.dir.device = nd->dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = nd->dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd->dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            err = -EPERM;
+            goto unlock;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_add_mount() [do_mount() [sys_mount()]]: calling ADF for DEV\n");
+#endif
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(mnt->mnt_sb->s_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(mnt->mnt_sb->s_dev);
+        rsbac_attribute_value.mode = flags;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            err = -EPERM;
+            goto unlock;
+          }
+        #endif
+
 	mnt->mnt_flags = mnt_flags;
 	err = graft_tree(mnt, nd);
+
+        /* RSBAC: initialising data structures for this fs (not root fs) */
+        #ifdef CONFIG_RSBAC
+        if(!err)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_ds)
+              rsbac_printk(KERN_DEBUG "do_add_mount() [do_mount() [sys_mount()]]: calling rsbac_mount for Device %02u:%02u\n",
+                           MAJOR(mnt->mnt_sb->s_dev), MINOR(mnt->mnt_sb->s_dev));
+#endif
+            rsbac_mount(mnt->mnt_sb, mnt->mnt_mountpoint);
+          }
+        #endif
+
 unlock:
 	up_write(&current->namespace->sem);
 	mntput(mnt);
@@ -909,6 +1282,12 @@
 	struct nameidata new_nd, old_nd, parent_nd, root_parent, user_nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
@@ -925,6 +1304,51 @@
 	if (error)
 		goto out1;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_pivot_root(): calling ADF for MOUNT on put_old\n");
+#endif
+        rsbac_target_id.dir.device = old_nd.dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = old_nd.dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = old_nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            path_release(&old_nd);
+            path_release(&new_nd);
+            return -EPERM;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_pivot_root(): calling ADF for MOUNT on root DIR\n");
+#endif
+        rsbac_target_id.dir.device = current->fs->rootmnt->mnt_sb->s_dev;
+        rsbac_target_id.dir.inode  = current->fs->root->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = current->fs->root;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MOUNT,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            path_release(&old_nd);
+            path_release(&new_nd);
+            return -EPERM;
+          }
+
+        /* Make the new root's cached rsbac.dat dentry be put to free the old root's dcache */
+        rsbac_free_dat_dentries();
+        #endif
+
 	read_lock(&current->fs->lock);
 	user_nd.mnt = mntget(current->fs->rootmnt);
 	user_nd.dentry = dget(current->fs->root);
diff -urN -x rsbac trunk/fs/nfsd/nfsctl.c linux-2.4.32-rsbac-1.2.7/fs/nfsd/nfsctl.c
--- trunk/fs/nfsd/nfsctl.c	2006-06-01 10:30:54.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/nfsd/nfsctl.c	2006-06-01 10:32:30.000000000 +0200
@@ -34,6 +34,11 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 static int	nfsctl_svc(struct nfsctl_svc *data);
 static int	nfsctl_addclient(struct nfsctl_client *data);
 static int	nfsctl_delclient(struct nfsctl_client *data);
@@ -222,6 +227,13 @@
 	int			err;
 	int			argsize, respsize;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel ();
 
 	err = -EPERM;
@@ -251,6 +263,37 @@
 		goto done;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        switch(cmd)
+          {
+            case NFSCTL_GETFH:
+            case NFSCTL_GETFD:
+            case NFSCTL_GETFS:
+              rsbac_request = R_GET_STATUS_DATA;
+              break;
+            default:
+              rsbac_request = R_MODIFY_SYSTEM_DATA;
+          }
+        
+        rsbac_target_id.scd = ST_nfsd;
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "handle_sys_nfsservctl [sys_nfsservctl()]: calling ADF\n");
+#endif
+        if(!rsbac_adf_request(rsbac_request,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            err = -EPERM;
+            goto done;
+          }
+        #endif
+
 	switch(cmd) {
 	case NFSCTL_SVC:
 		err = nfsctl_svc(&arg->ca_svc);
diff -urN -x rsbac trunk/fs/open.c linux-2.4.32-rsbac-1.2.7/fs/open.c
--- trunk/fs/open.c	2006-06-01 10:30:54.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/open.c	2006-06-01 10:32:30.000000000 +0200
@@ -20,6 +20,11 @@
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 int vfs_statfs(struct super_block *sb, struct statfs *buf)
 {
 	int retval = -ENODEV;
@@ -42,9 +47,38 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk(path, &nd);
 	if (!error) {
 		struct statfs tmp;
+
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+		if (rsbac_debug_aef)
+		  rsbac_printk(KERN_DEBUG "sys_statfs(): calling ADF\n");
+#endif
+                rsbac_target_id.dev.type = D_block;
+                rsbac_target_id.dev.major = RSBAC_MAJOR(nd.dentry->d_inode->i_sb->s_dev);
+                rsbac_target_id.dev.minor = RSBAC_MINOR(nd.dentry->d_inode->i_sb->s_dev);
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                       current->pid,
+                                       T_DEV,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+		  {
+		    path_release(&nd);
+		    return -EPERM;
+		  }
+		#endif
+
 		error = vfs_statfs(nd.dentry->d_inode->i_sb, &tmp);
 		if (!error && copy_to_user(buf, &tmp, sizeof(struct statfs)))
 			error = -EFAULT;
@@ -59,10 +93,39 @@
 	struct statfs tmp;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
 		goto out;
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "sys_fstatfs(): calling ADF\n");
+#endif
+        rsbac_target_id.dev.type = D_block;
+        rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_dev);
+        rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_dev);
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                               current->pid,
+                               T_DEV,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+	  {
+	    fput(file);
+	    return -EPERM;
+	  }
+	#endif
+
 	error = vfs_statfs(file->f_dentry->d_inode->i_sb, &tmp);
 	if (!error && copy_to_user(buf, &tmp, sizeof(struct statfs)))
 		error = -EFAULT;
@@ -101,10 +164,46 @@
 	int error;
 	struct iattr newattrs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #ifdef CONFIG_RSBAC_SECDEL
+        loff_t old_len = inode->i_size;
+        #endif
+        #endif
+
 	/* Not pretty: "inode->i_size" shouldn't really be signed. But it is. */
 	if (length < 0)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_truncate() [open_namei(), do_sys_truncate() [sys_truncate()]]: calling ADF\n");
+#endif
+        rsbac_target_id.file.device = inode->i_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_TRUNCATE,
+                               current->pid,
+                               T_FILE,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+
+        /* RSBAC: Overwrite truncated part, if asked by flag */
+        #ifdef CONFIG_RSBAC_SECDEL
+        rsbac_sec_trunc(dentry, length, old_len);
+        #endif
+        #endif
+
 	down_write(&inode->i_alloc_sem);
 	down(&inode->i_sem);
 	newattrs.ia_size = length;
@@ -112,6 +211,30 @@
 	error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
 	up_write(&inode->i_alloc_sem);
+
+        #ifdef CONFIG_RSBAC
+        if (!error)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "do_truncate() [open_namei(), do_sys_truncate() [sys_truncate()]]: notifying ADF\n");
+#endif
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_TRUNCATE,
+                                   current->pid,
+                                   T_FILE,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                printk(KERN_WARNING
+                       "do_truncate() [open_namei(), do_sys_truncate() [sys_truncate()]]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 	return error;
 }
 
@@ -139,6 +262,11 @@
 	if (!S_ISREG(inode->i_mode))
 		goto dput_and_out;
 
+        #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+        if(rsbac_dac_part_disabled(nd.dentry))
+          error = 0;
+        else
+        #endif
 	error = permission(inode,MAY_WRITE);
 	if (error)
 		goto dput_and_out;
@@ -262,6 +390,13 @@
 	struct inode * inode;
 	struct iattr newattrs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk(filename, &nd);
 	if (error)
 		goto out;
@@ -289,9 +424,41 @@
 		if (IS_IMMUTABLE(inode))
 			goto dput_and_out;
 		if (current->fsuid != inode->i_uid &&
+                    #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+                    !rsbac_dac_part_disabled(nd.dentry) &&
+                    #endif
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_utime(): calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+	  rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+	  rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = inode->i_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_ACCESS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto dput_and_out;
+          }
+        #endif
+
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
 	path_release(&nd);
@@ -312,6 +479,13 @@
 	struct inode * inode;
 	struct iattr newattrs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk(filename, &nd);
 
 	if (error)
@@ -340,10 +514,43 @@
 		if (IS_IMMUTABLE(inode))
 			goto dput_and_out;
 
+                #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+                if(!rsbac_dac_part_disabled(nd.dentry))
+                #endif
+
 		if (current->fsuid != inode->i_uid &&
 		    (error = permission(inode,MAY_WRITE)) != 0)
 			goto dput_and_out;
 	}
+	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_utimes(): calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+	else if (S_ISFIFO(inode->i_mode))
+	  rsbac_target = T_FIFO;
+	else if (S_ISLNK(inode->i_mode))
+	  rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = inode->i_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_ACCESS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto dput_and_out;
+          }
+        #endif
+
 	error = notify_change(nd.dentry, &newattrs);
 dput_and_out:
 	path_release(&nd);
@@ -363,6 +570,13 @@
 	kernel_cap_t old_cap;
 	int res;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
 
@@ -374,8 +588,12 @@
 	current->fsgid = current->gid;
 
 	/* Clear the capabilities if we switch to a non-root user */
-	if (current->uid)
+	if (current->uid) {
+                #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+                if(!rsbac_uid_faked())
+                #endif
 		cap_clear(current->cap_effective);
+	}
 	else
 		current->cap_effective = current->cap_permitted;
 
@@ -386,6 +604,36 @@
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!res)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_access(): calling ADF\n");
+#endif
+                    rsbac_target = T_FILE;
+                    if (S_ISDIR(nd.dentry->d_inode->i_mode))
+                      rsbac_target = T_DIR;
+                    else if (S_ISFIFO(nd.dentry->d_inode->i_mode))
+                      rsbac_target = T_FIFO;
+                    else if (S_ISLNK(nd.dentry->d_inode->i_mode))
+                      rsbac_target = T_SYMLINK;
+                    rsbac_target_id.file.device = nd.dentry->d_inode->i_dev;
+                    rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+                    rsbac_target_id.file.dentry_p = nd.dentry;
+                    rsbac_attribute_value.dummy = 0;
+                    if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+                                           current->pid,
+                                           rsbac_target,
+                                           rsbac_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      res = -EPERM;
+                  }
+                #endif
+
 		path_release(&nd);
 	}
 
@@ -401,14 +649,46 @@
 	int error;
 	struct nameidata nd;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = __user_walk(filename,LOOKUP_POSITIVE|LOOKUP_FOLLOW|LOOKUP_DIRECTORY,&nd);
 	if (error)
 		goto out;
 
+        #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+        if(rsbac_dac_part_disabled(nd.dentry))
+          error = 0;
+        else
+        #endif
 	error = permission(nd.dentry->d_inode,MAY_EXEC);
 	if (error)
 		goto dput_and_out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_chdir(): calling ADF\n");
+#endif
+        rsbac_target_id.dir.device = nd.dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = nd.dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CHDIR,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto dput_and_out;
+          }
+        #endif
+
 	set_fs_pwd(current->fs, nd.mnt, nd.dentry);
 
 dput_and_out:
@@ -425,6 +705,12 @@
 	struct vfsmount *mnt;
 	int error;
 
+	/* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -438,7 +724,37 @@
 	if (!S_ISDIR(inode->i_mode))
 		goto out_putf;
 
+        #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+        if(rsbac_dac_part_disabled(dentry))
+          error = 0;
+        else
+        #endif
 	error = permission(inode, MAY_EXEC);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(!error)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_fchdir(): calling ADF\n");
+#endif
+            rsbac_target_id.dir.device = inode->i_dev;
+            rsbac_target_id.dir.inode  = inode->i_ino;
+            rsbac_target_id.dir.dentry_p = dentry;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_CHDIR,
+                                   current->pid,
+                                   T_DIR,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                error = -EPERM;
+              }
+          }
+        #endif
+
 	if (!error)
 		set_fs_pwd(current->fs, mnt, dentry);
 out_putf:
@@ -452,11 +768,22 @@
 	int error;
 	struct nameidata nd;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = __user_walk(filename, LOOKUP_POSITIVE | LOOKUP_FOLLOW |
 		      LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
 	if (error)
 		goto out;
 
+        #ifdef CONFIG_RSBAC_ALLOW_DAC_DISABLE_PART
+        if(rsbac_dac_part_disabled(nd.dentry))
+          error = 0;
+        else
+        #endif
 	error = permission(nd.dentry->d_inode,MAY_EXEC);
 	if (error)
 		goto dput_and_out;
@@ -465,6 +792,28 @@
 	if (!capable(CAP_SYS_CHROOT))
 		goto dput_and_out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_chroot(): calling ADF\n");
+#endif
+        rsbac_target_id.dir.device = nd.dentry->d_inode->i_dev;
+        rsbac_target_id.dir.inode  = nd.dentry->d_inode->i_ino;
+        rsbac_target_id.dir.dentry_p = nd.dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CHDIR,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto dput_and_out;
+          }
+        #endif
+
 	set_fs_root(current->fs, nd.mnt, nd.dentry);
 	set_fs_altroot();
 	error = 0;
@@ -482,6 +831,13 @@
 	int err = -EBADF;
 	struct iattr newattrs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	file = fget(fd);
 	if (!file)
 		goto out;
@@ -495,6 +851,35 @@
 	err = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out_putf;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_fchmod(): calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = inode->i_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = dentry;
+        rsbac_attribute_value.mode = mode;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            err = -EPERM;
+            goto out_putf;
+          }
+        #endif
+        
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
@@ -514,6 +899,13 @@
 	int error;
 	struct iattr newattrs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk(filename, &nd);
 	if (error)
 		goto out;
@@ -527,6 +919,34 @@
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_chmod(): calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = inode->i_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = nd.dentry;
+        rsbac_attribute_value.mode = mode;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_mode,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto dput_and_out;
+          }
+        #endif
+
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
@@ -545,6 +965,13 @@
 	int error;
 	struct iattr newattrs;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = -ENOENT;
 	if (!(inode = dentry->d_inode)) {
 		printk(KERN_ERR "chown_common: NULL inode\n");
@@ -556,6 +983,35 @@
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "chown_common() [sys_*chown]: calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = inode->i_dev;
+        rsbac_target_id.file.inode  = inode->i_ino;
+        rsbac_target_id.file.dentry_p = dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CHANGE_OWNER,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto out;
+          }
+        #endif
+
 	if (user == (uid_t) -1)
 		user = inode->i_uid;
 	if (group == (gid_t) -1)
@@ -846,10 +1302,130 @@
 {
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        int                           rsbac_is_socket = 0;
+        #endif
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!file_count(filp)) {
 		printk(KERN_ERR "VFS: Close: file count is 0\n");
 		return 0;
 	}
+
+        /* RSBAC: calling adf */
+        #ifdef CONFIG_RSBAC
+        if (   filp
+            && filp->f_dentry
+            && filp->f_dentry->d_inode
+            && !S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "filp_close() [sys_close]: calling ADF\n");
+#endif
+            if(   S_ISBLK(filp->f_dentry->d_inode->i_mode)
+               || S_ISCHR(filp->f_dentry->d_inode->i_mode))
+              {
+                rsbac_target = T_DEV;
+                if(S_ISBLK(filp->f_dentry->d_inode->i_mode))
+                  {
+                    rsbac_target_id.dev.type = D_block;
+                  }
+                else
+                  {
+                    rsbac_target_id.dev.type = D_char;
+                  }
+                rsbac_target_id.dev.major = RSBAC_MAJOR(filp->f_dentry->d_inode->i_rdev);
+                rsbac_target_id.dev.minor = RSBAC_MINOR(filp->f_dentry->d_inode->i_rdev);
+              }
+            else
+            if(S_ISFIFO(filp->f_dentry->d_inode->i_mode))
+              {
+                if(filp->f_dentry->d_inode->i_sb->s_magic != PIPEFS_MAGIC)
+                  {
+                    rsbac_target = T_FIFO;
+                    rsbac_target_id.dir.device = filp->f_dentry->d_inode->i_dev;
+                    rsbac_target_id.dir.inode  = filp->f_dentry->d_inode->i_ino;
+                    rsbac_target_id.dir.dentry_p = filp->f_dentry;
+                  }
+                else
+                  {
+                    rsbac_target = T_IPC;
+                    rsbac_target_id.ipc.type = I_anonpipe;
+                    rsbac_target_id.ipc.id.id_nr = filp->f_dentry->d_inode->i_ino;
+                  }
+              }
+            else
+              {
+                if(S_ISDIR(filp->f_dentry->d_inode->i_mode))
+                  rsbac_target = T_DIR;
+                else
+                  rsbac_target = T_FILE;
+                rsbac_target_id.file.device = filp->f_dentry->d_inode->i_dev;
+                rsbac_target_id.file.inode  = filp->f_dentry->d_inode->i_ino;
+                rsbac_target_id.file.dentry_p = filp->f_dentry;
+              }
+            rsbac_attribute_value.f_mode = filp->f_mode;
+            if (!rsbac_adf_request(R_CLOSE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   A_f_mode,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING "filp_close() [sys_close]: ADF-call returned NOT_GRANTED\n");
+                return -EPERM;
+              }
+          }
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        /* RSBAC: remember, whether it was a socket, and request ADF
+         * This is special, because closing a socket means deleting it.
+         * The real close might have been done via sys_shutdown, then
+         * here is nothing more to do.
+         */
+        else if (   filp
+                 && filp->f_dentry
+                 && filp->f_dentry->d_inode
+                 && S_ISSOCK(filp->f_dentry->d_inode->i_mode)
+                 && filp->f_dentry->d_inode->u.socket_i.sk
+                 #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                 && filp->f_dentry->d_inode->u.socket_i.ops
+                 && (filp->f_dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                 #endif
+                )
+          {
+            rsbac_is_socket = 1;
+            rsbac_target_id.netobj.sock_p = &filp->f_dentry->d_inode->u.socket_i;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = NULL;
+            rsbac_target_id.netobj.remote_len = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "filp_close() [sys_close()]: calling ADF for CLOSE on NETOBJ\n");
+#endif
+            rsbac_attribute_value.f_mode = filp->f_mode;
+            if (!rsbac_adf_request(R_CLOSE,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_f_mode,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "filp_close() [sys_close()]: ADF-call for CLOSE on NETOBJ returned NOT_GRANTED\n");
+                return -EPERM;
+              }
+          }
+        #endif /* NET_OBJ */
+        #endif /* RSBAC */
+
 	retval = 0;
 	if (filp->f_op && filp->f_op->flush) {
 		lock_kernel();
@@ -858,6 +1434,60 @@
 	}
 	dnotify_flush(filp, id);
 	locks_remove_posix(filp, id);
+
+        /* RSBAC: notifying adf */
+        #ifdef CONFIG_RSBAC
+        if (   filp->f_dentry
+            && filp->f_dentry->d_inode
+            && !S_ISSOCK(filp->f_dentry->d_inode->i_mode))
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "filp_close() [sys_close]: notifying ADF\n");
+#endif
+            rsbac_new_target_id.dummy = 0;
+            rsbac_attribute_value.f_mode = filp->f_mode;
+            if (rsbac_adf_set_attr(R_CLOSE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_f_mode,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "filp_close() [sys_close]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        else
+        /* RSBAC: notifying adf / network */
+        if (!retval && rsbac_is_socket)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG
+                     "filp_close [sys_close]: notifying ADF for CLOSE on NETOBJ\n");
+#endif
+            rsbac_new_target_id.dummy = 0;
+            rsbac_attribute_value.f_mode = filp->f_mode;
+            if (rsbac_adf_set_attr(R_CLOSE,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_f_mode,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING 
+                       "filp_close [sys_close()]: rsbac_adf_set_attr() for CLOSE on netobj returned error\n");
+              }
+          }
+        #endif /* CONFIG_RSBAC_NET_OBJ */
+        #endif /* RSBAC */
+
 	fput(filp);
 	return retval;
 }
diff -urN -x rsbac trunk/fs/pipe.c linux-2.4.32-rsbac-1.2.7/fs/pipe.c
--- trunk/fs/pipe.c	2006-06-01 10:30:54.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/pipe.c	2006-06-01 10:32:30.000000000 +0200
@@ -14,6 +14,12 @@
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+/* RSBAC: including rsbac_mount/umount declaration and adf-calls*/
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#include <rsbac/aci.h>
+#endif
+
 /*
  * We use a start+len construction, which provides full use of the 
  * allocated memory.
@@ -42,6 +48,13 @@
 	struct inode *inode = filp->f_dentry->d_inode;
 	ssize_t size, read, ret;
 
+	/* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* Seeks are not allowed on pipes.  */
 	ret = -ESPIPE;
 	read = 0;
@@ -53,6 +66,27 @@
 	if (count == 0)
 		goto out_nolock;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_RW
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+		rsbac_printk(KERN_DEBUG "pipe_readv(): calling ADF\n");
+#endif
+        rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_READ,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		ret = -EPERM;
+		goto out_nolock;
+	}
+	#endif /* CONFIG_RSBAC_RW */
+
 	/* Get the pipe semaphore */
 	ret = -ERESTARTSYS;
 	if (down_interruptible(PIPE_SEM(*inode)))
@@ -127,9 +161,27 @@
 out:
 	up(PIPE_SEM(*inode));
 out_nolock:
-	if (read)
+	if (read) {
 		ret = read;
 
+                /* RSBAC: notify adf of read from pipe */
+                #ifdef CONFIG_RSBAC_RW
+                rsbac_new_target_id.dummy = 0;
+  
+		if (rsbac_adf_set_attr(R_READ,
+					current->pid,
+					T_IPC,
+					rsbac_target_id,
+					T_NONE,
+					rsbac_new_target_id,
+					A_none,
+					rsbac_attribute_value))
+		{
+			rsbac_printk(KERN_WARNING "pipe_readv(): rsbac_adf_set_attr() returned error\n");
+		}
+		#endif
+	}					
+
 	UPDATE_ATIME(inode);
 	return ret;
 }
@@ -140,6 +192,13 @@
 	struct inode *inode = filp->f_dentry->d_inode;
 	ssize_t free, written, ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* Seeks are not allowed on pipes.  */
 	ret = -ESPIPE;
 	written = 0;
@@ -151,6 +210,29 @@
 	if (count == 0)
 		goto out_nolock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+	    rsbac_printk(KERN_DEBUG "pipe_writev(): calling ADF\n");
+#endif
+    
+        rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE,
+				current->pid,
+				T_IPC,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	{
+		ret = -EPERM;
+		goto out_nolock;
+	}
+	#endif /* CONFIG_RSBAC_RW */
+
 	ret = -ERESTARTSYS;
 	if (down_interruptible(PIPE_SEM(*inode)))
 		goto out_nolock;
@@ -235,8 +317,28 @@
 out:
 	up(PIPE_SEM(*inode));
 out_nolock:
-	if (written)
+	if (written) {
 		ret = written;
+		
+		/* RSBAC: notify adf of write to pipe */
+                #ifdef CONFIG_RSBAC_RW
+		rsbac_new_target_id.dummy = 0;
+		
+		if (rsbac_adf_set_attr(R_WRITE,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "pipe_writev(): rsbac_adf_set_attr() returned error\n");
+                      }
+                #endif
+	}
+
 	return ret;
 
 sigpipe:
@@ -303,9 +405,25 @@
 	PIPE_WRITERS(*inode) -= decw;
 	if (!PIPE_READERS(*inode) && !PIPE_WRITERS(*inode)) {
 		struct pipe_inode_info *info = inode->i_pipe;
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC
+		union rsbac_target_id_t rsbac_target_id;
+		#endif
+
 		inode->i_pipe = NULL;
 		free_page((unsigned long) info->base);
 		kfree(info);
+
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+		if (rsbac_debug_aef)
+		  rsbac_printk(KERN_DEBUG "pipe_release: calling ACI remove_target()\n");
+#endif
+		rsbac_target_id.ipc.type   = I_anonpipe;
+		rsbac_target_id.ipc.id.id_nr  = inode->i_ino;
+		rsbac_remove_target(T_IPC, rsbac_target_id);
+		#endif
 	} else {
 		wake_up_interruptible(PIPE_WAIT(*inode));
 	}
@@ -339,28 +457,144 @@
 static int
 pipe_read_open(struct inode *inode, struct file *filp)
 {
+
+	#ifdef CONFIG_RSBAC
+	/* RSBAC */
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "pipe_read_open(): calling ADF\n");
+#endif
+
+	rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ_OPEN,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+	#endif
+
 	/* We could have perhaps used atomic_t, but this and friends
 	   below are the only places.  So it doesn't seem worthwhile.  */
 	down(PIPE_SEM(*inode));
 	PIPE_READERS(*inode)++;
 	up(PIPE_SEM(*inode));
 
+        #ifdef CONFIG_RSBAC
+	/* RSBAC: notify adf of read_open on pipe */
+	rsbac_new_target_id.dummy = 0;
+		
+	if (rsbac_adf_set_attr(R_READ_OPEN,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING "pipe_read_open(): rsbac_adf_set_attr() returned error\n");
+              }
+        #endif
+
 	return 0;
 }
 
 static int
 pipe_write_open(struct inode *inode, struct file *filp)
 {
+
+	#ifdef CONFIG_RSBAC
+	/* RSBAC */
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "pipe_write_open(): calling ADF\n");
+#endif
+
+	rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_WRITE_OPEN,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+	#endif
+
 	down(PIPE_SEM(*inode));
 	PIPE_WRITERS(*inode)++;
 	up(PIPE_SEM(*inode));
 
+        #ifdef CONFIG_RSBAC
+	/* RSBAC: notify adf of write_open on pipe */
+	rsbac_new_target_id.dummy = 0;
+		
+	if (rsbac_adf_set_attr(R_WRITE_OPEN,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING "pipe_write_open(): rsbac_adf_set_attr() returned error\n");
+              }
+        #endif
+
 	return 0;
 }
 
 static int
 pipe_rdwr_open(struct inode *inode, struct file *filp)
 {
+
+	#ifdef CONFIG_RSBAC
+	/* RSBAC */
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "pipe_rdwr_open(): calling ADF\n");
+#endif
+
+	rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+	rsbac_attribute_value.dummy = 0;
+
+	if (!rsbac_adf_request(R_READ_WRITE_OPEN,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+	
+	#endif
+
 	down(PIPE_SEM(*inode));
 	if (filp->f_mode & FMODE_READ)
 		PIPE_READERS(*inode)++;
@@ -368,6 +602,23 @@
 		PIPE_WRITERS(*inode)++;
 	up(PIPE_SEM(*inode));
 
+        #ifdef CONFIG_RSBAC
+	/* RSBAC: notify adf of read_write_open on pipe */
+	rsbac_new_target_id.dummy = 0;
+		
+	if (rsbac_adf_set_attr(R_READ_WRITE_OPEN,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING "pipe_rdwr_open(): rsbac_adf_set_attr() returned error\n");
+              }
+        #endif
+
 	return 0;
 }
 
@@ -511,6 +762,32 @@
 	int error;
 	int i,j;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "do_pipe() [sys_pipe()]: calling ADF\n");
+#endif
+        rsbac_target_id.ipc.type = I_anonpipe;
+        rsbac_target_id.ipc.id.id_nr = 0;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	error = -ENFILE;
 	f1 = get_empty_filp();
 	if (!f1)
@@ -564,6 +841,25 @@
 	fd_install(j, f2);
 	fd[0] = i;
 	fd[1] = j;
+
+        /* RSBAC: notify ADF of new anonpipe */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.ipc.id.id_nr = inode->i_ino;
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "do_pipe() [sys_pipe()]: rsbac_adf_set_attr() returned error");
+          }
+        #endif
+
 	return 0;
 
 close_f12_inode_i_j:
@@ -634,9 +930,10 @@
 		err = PTR_ERR(pipe_mnt);
 		if (IS_ERR(pipe_mnt))
 			unregister_filesystem(&pipe_fs_type);
-		else
+		else {
 			err = 0;
 	}
+	}
 	return err;
 }
 
diff -urN -x rsbac trunk/fs/proc/array.c linux-2.4.32-rsbac-1.2.7/fs/proc/array.c
--- trunk/fs/proc/array.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/proc/array.c	2006-06-01 10:32:28.000000000 +0200
@@ -77,6 +77,11 @@
 #include <asm/io.h>
 #include <asm/processor.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /* Gcc optimizes away "strlen(x)" for constant x */
 #define ADDBUF(buffer, string) \
 do { memcpy(buffer, string, strlen(string)); \
@@ -282,6 +287,31 @@
 	char * orig = buffer;
 	struct mm_struct *mm;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_pid_status(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	buffer = task_name(task, buffer);
 	buffer = task_state(task, buffer);
 	task_lock(task);
@@ -313,6 +343,31 @@
 	struct mm_struct *mm;
 	char tcomm[sizeof(task->comm)];
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_pid_stat(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+	rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
 	task_lock(task);
@@ -483,6 +538,31 @@
 	struct mm_struct *mm;
 	int size=0, resident=0, share=0, trs=0, lrs=0, drs=0, dt=0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_pid_statm(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+	if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	task_lock(task);
 	mm = task->mm;
 	if(mm)
@@ -613,6 +693,31 @@
 {
 	int i, len;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          printk(KERN_DEBUG "proc_pid_cpu(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	len = sprintf(buffer,
 		"cpu  %lu %lu\n",
 		task->times.tms_utime,
diff -urN -x rsbac trunk/fs/proc/base.c linux-2.4.32-rsbac-1.2.7/fs/proc/base.c
--- trunk/fs/proc/base.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/proc/base.c	2006-06-01 10:32:28.000000000 +0200
@@ -26,6 +26,11 @@
 #include <linux/seq_file.h>
 #include <linux/namespace.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
  * Feel free to change the macro below - just keep the range distinct from
@@ -43,6 +48,31 @@
 
 static int proc_fd_link(struct inode *inode, struct dentry **dentry, struct vfsmount **mnt)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_fd_link(): calling ADF\n");
+#endif
+        rsbac_target_id.process = inode->u.proc_i.task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	if (inode->u.proc_i.file) {
 		*mnt = mntget(inode->u.proc_i.file->f_vfsmnt);
 		*dentry = dget(inode->u.proc_i.file->f_dentry);
@@ -58,6 +88,31 @@
 	int result = -ENOENT;
 	struct task_struct *task = inode->u.proc_i.task;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_exe_link(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	task_lock(task);
 	mm = task->mm;
 	if (mm)
@@ -87,6 +142,32 @@
 {
 	struct fs_struct *fs;
 	int result = -ENOENT;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_cwd_link(): calling ADF\n");
+#endif
+        rsbac_target_id.process = inode->u.proc_i.task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	task_lock(inode->u.proc_i.task);
 	fs = inode->u.proc_i.task->fs;
 	if(fs)
@@ -107,6 +188,32 @@
 {
 	struct fs_struct *fs;
 	int result = -ENOENT;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_root_link(): calling ADF\n");
+#endif
+        rsbac_target_id.process = inode->u.proc_i.task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	task_lock(inode->u.proc_i.task);
 	fs = inode->u.proc_i.task->fs;
 	if(fs)
@@ -158,9 +265,34 @@
 	struct mm_struct *mm;
 	int res = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!may_ptrace_attach(task))
 		return -ESRCH;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_pid_environ(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	task_lock(task);
 	mm = task->mm;
 	if (mm)
@@ -183,6 +315,32 @@
 {
 	struct mm_struct *mm;
 	int res = 0;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_pid_cmdline(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	task_lock(task);
 	mm = task->mm;
 	if (mm)
@@ -272,7 +430,34 @@
 static int maps_open(struct inode *inode, struct file *file)
 {
 	struct task_struct *task = inode->u.proc_i.task;
-	int ret = seq_open(file, &proc_pid_maps_op);
+	int ret;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "maps_open(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
+	ret = seq_open(file, &proc_pid_maps_op);
 	if (!ret) {
 		struct seq_file *m = file->private_data;
 		m->private = task;
@@ -291,7 +476,34 @@
 static int mounts_open(struct inode *inode, struct file *file)
 {
 	struct task_struct *task = inode->u.proc_i.task;
-	int ret = seq_open(file, &mounts_op);
+	int ret;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "mounts_open(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
+	ret = seq_open(file, &mounts_op);
 
 	if (!ret) {
 		struct seq_file *m = file->private_data;
@@ -383,9 +595,34 @@
 	int copied = 0;
 	struct mm_struct *mm;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!MAY_PTRACE(task) || !may_ptrace_attach(task))
 		return -ESRCH;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "mem_read(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	page = (char *)__get_free_page(GFP_USER);
 	if (!page)
 		return -ENOMEM;
@@ -445,9 +682,34 @@
 	struct task_struct *task = file->f_dentry->d_inode->u.proc_i.task;
 	unsigned long dst = *ppos;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!MAY_PTRACE(task) || !may_ptrace_attach(task))
 		return -ESRCH;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "mem_write(): calling ADF\n");
+#endif
+        rsbac_target_id.process = task->pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	page = (char *)__get_free_page(GFP_USER);
 	if (!page)
 		return -ENOMEM;
@@ -697,9 +959,31 @@
 	struct inode *inode = filp->f_dentry->d_inode;
 	struct pid_entry *p;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_PROC_HIDE
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	pid = inode->u.proc_i.task->pid;
 	if (!pid)
 		return -ENOENT;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_PROC_HIDE
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.dummy = 0;
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -ENOENT;
+          }
+        #endif
+
 	i = filp->f_pos;
 	switch (i) {
 		case 0:
@@ -1120,12 +1404,34 @@
 	struct task_struct *p;
 	int nr_pids = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_PROC_HIDE
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	index--;
 	read_lock(&tasklist_lock);
 	for_each_task(p) {
 		int pid = p->pid;
 		if (!pid)
 			continue;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_PROC_HIDE
+                rsbac_target_id.process = pid;
+                rsbac_attribute_value.dummy = 0;
+                if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_none,
+                                      rsbac_attribute_value))
+                  {
+                    continue;
+                  }
+                #endif
+
 		if (--index >= 0)
 			continue;
 		pids[nr_pids] = pid;
diff -urN -x rsbac trunk/fs/proc/kcore.c linux-2.4.32-rsbac-1.2.7/fs/proc/kcore.c
--- trunk/fs/proc/kcore.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/proc/kcore.c	2006-06-01 10:32:28.000000000 +0200
@@ -21,10 +21,39 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
 
 static int open_kcore(struct inode * inode, struct file * filp)
 {
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+
+	if(!capable(CAP_SYS_RAWIO))
+	  return -EPERM;
+
+        rsbac_target_id.scd = ST_kmem;
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "open_kcore(): calling ADF\n");
+#endif
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          return -EPERM;
+        else
+          return 0;
+#else
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
+#endif
 }
 
 static loff_t lseek_kcore(struct file * file, loff_t offset, int origin);
diff -urN -x rsbac trunk/fs/proc/proc_misc.c linux-2.4.32-rsbac-1.2.7/fs/proc/proc_misc.c
--- trunk/fs/proc/proc_misc.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/proc/proc_misc.c	2006-06-01 10:32:28.000000000 +0200
@@ -42,6 +42,11 @@
 #include <asm/pgtable.h>
 #include <asm/io.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #define LOAD_INT(x) ((x) >> FSHIFT)
 #define LOAD_FRAC(x) LOAD_INT(((x) & (FIXED_1-1)) * 100)
 /*
@@ -279,6 +284,31 @@
 extern struct seq_operations ksyms_op;
 static int ksyms_open(struct inode *inode, struct file *file)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.scd = ST_ksyms;
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "ksyms_open(): calling ADF\n");
+#endif
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	return seq_open(file, &ksyms_op);
 }
 static struct file_operations proc_ksyms_operations = {
diff -urN -x rsbac trunk/fs/quota.c linux-2.4.32-rsbac-1.2.7/fs/quota.c
--- trunk/fs/quota.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/quota.c	2006-06-01 10:32:29.000000000 +0200
@@ -14,11 +14,22 @@
 #include <linux/quotaops.h>
 #include <linux/quotacompat.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 struct dqstats dqstats;
 
 /* Check validity of quotactl */
 static int check_quotactl_valid(struct super_block *sb, int type, int cmd, qid_t id)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (type >= MAXQUOTAS)
 		return -EINVAL;
 	if (!sb && cmd != Q_SYNC)
@@ -97,10 +108,49 @@
 		     (type == GRPQUOTA && !in_egroup_p(id))) &&
 		    !capable(CAP_SYS_ADMIN))
 			return -EPERM;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.scd = ST_quota;
+                rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "check_quotactl_valid() [sys_quotactl()]: calling ADF\n");
+#endif
+                if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                                      current->pid,
+                                      T_SCD,
+                                      rsbac_target_id,
+                                      A_none,
+                                      rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
 	}
-	else if (cmd != Q_GETFMT && cmd != Q_SYNC && cmd != Q_GETINFO && cmd != Q_XGETQSTAT)
+	else if (cmd != Q_GETFMT && cmd != Q_SYNC && cmd != Q_GETINFO && cmd != Q_XGETQSTAT) {
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.scd = ST_quota;
+                rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "check_quotactl_valid() [sys_quotactl()]: calling ADF\n");
+#endif
+                if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                      current->pid,
+                                      T_SCD,
+                                      rsbac_target_id,
+                                      A_none,
+                                      rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
+	}
 	return 0;
 }
 
diff -urN -x rsbac trunk/fs/readdir.c linux-2.4.32-rsbac-1.2.7/fs/readdir.c
--- trunk/fs/readdir.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/readdir.c	2006-06-01 10:32:29.000000000 +0200
@@ -13,12 +13,47 @@
 
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 int vfs_readdir(struct file *file, filldir_t filler, void *buf)
 {
 	struct inode *inode = file->f_dentry->d_inode;
 	int res = -ENOTDIR;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!file->f_op || !file->f_op->readdir)
 		goto out;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "vfs_readdir() [old_readdir(), sys_getdents()]: calling ADF\n");
+#endif
+        rsbac_target_id.dir.device = inode->i_dev;
+        rsbac_target_id.dir.inode  = inode->i_ino;
+        rsbac_target_id.dir.dentry_p = file->f_dentry;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_READ,
+                               current->pid,
+                               T_DIR,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            res = -EPERM;
+            goto out;
+          }
+        #endif
+
 	down(&inode->i_sem);
 	down(&inode->i_zombie);
 	res = -ENOENT;
diff -urN -x rsbac trunk/fs/read_write.c linux-2.4.32-rsbac-1.2.7/fs/read_write.c
--- trunk/fs/read_write.c	2006-06-01 10:31:00.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/read_write.c	2006-06-01 10:32:32.000000000 +0200
@@ -29,6 +29,11 @@
 
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_RW
+#include <rsbac/adf.h>
+#endif
+
 struct file_operations generic_ro_fops = {
 	llseek:		generic_file_llseek,
 	read:		generic_file_read,
@@ -186,6 +191,14 @@
 	ssize_t ret;
 	struct file * file;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	ret = -EBADF;
 	file = fget(fd);
 	if (file) {
@@ -194,13 +207,120 @@
 
 			if (!ret) {
 				ssize_t (*read)(struct file *, char *, size_t, loff_t *);
+
 				ret = -EINVAL;
+
+                                /* RSBAC */
+                                #ifdef CONFIG_RSBAC_RW
+#ifdef CONFIG_RSBAC_DEBUG
+                                if (rsbac_debug_aef)
+                                  rsbac_printk(KERN_DEBUG "sys_read(): calling ADF\n");
+#endif
+                                /* get target type and id clear */
+                                #ifdef CONFIG_RSBAC_NET_OBJ_RW
+                                if(S_ISSOCK(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                                    if(   file->f_dentry->d_inode->u.socket_i.ops
+                                       && (file->f_dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                                      )
+                                    #endif
+                                      {
+                                        rsbac_target = T_NETOBJ;
+                                        rsbac_target_id.netobj.sock_p
+                                         = &file->f_dentry->d_inode->u.socket_i;
+                                        rsbac_target_id.netobj.local_addr = NULL;
+                                        rsbac_target_id.netobj.local_len = 0;
+                                        rsbac_target_id.netobj.remote_addr = NULL;
+                                        rsbac_target_id.netobj.remote_len = 0;
+                                      }
+                                  }
+                                else
+                                #endif
+                                if(S_ISFIFO(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    if(file->f_dentry->d_inode->i_sb->s_magic != PIPEFS_MAGIC)
+                                      {
+                                        rsbac_target = T_FIFO;
+                                        rsbac_target_id.dir.device = file->f_dentry->d_inode->i_dev;
+                                        rsbac_target_id.dir.inode  = file->f_dentry->d_inode->i_ino;
+                                        rsbac_target_id.dir.dentry_p = file->f_dentry;
+                                      }
+                                    else
+                                      {
+                                        rsbac_target = T_IPC;
+                                        rsbac_target_id.ipc.type = I_anonpipe;
+                                        rsbac_target_id.ipc.id.id_nr = file->f_dentry->d_inode->i_ino;
+                                      }
+                                  }
+                                else
+                                if(S_ISREG(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    rsbac_target = T_FILE;
+                                    rsbac_target_id.file.device = file->f_dentry->d_inode->i_dev;
+                                    rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+                                    rsbac_target_id.file.dentry_p = file->f_dentry;
+                                  }
+                                else
+                                if(S_ISBLK(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    rsbac_target = T_DEV;
+                                    rsbac_target_id.dev.type = D_block;
+                                    rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                                    rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                                  }
+                                else
+                                if(S_ISCHR(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    rsbac_target = T_DEV;
+                                    rsbac_target_id.dev.type = D_char;
+                                    rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                                    rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                                  }
+                                rsbac_attribute_value.dummy = 0;
+                                if (   (rsbac_target != T_NONE)
+                                    && !rsbac_adf_request(R_READ,
+                                                          current->pid,
+                                                          rsbac_target,
+                                                          rsbac_target_id,
+                                                          A_none,
+                                                          rsbac_attribute_value)
+                                   )
+                                  {
+                                    ret = -EPERM;
+                                  }
+                                else
+                                #endif /* CONFIG_RSBAC_RW */
+
 				if (file->f_op && (read = file->f_op->read) != NULL)
 					ret = read(file, buf, count, &file->f_pos);
 			}
 		}
 		if (ret > 0)
 			dnotify_parent(file->f_dentry, DN_ACCESS);
+
+                /* RSBAC: notify adf of read file etc. */
+                #ifdef CONFIG_RSBAC_RW
+                if (   (ret > 0)
+                    && (rsbac_target != T_NONE)
+                   )
+                  {
+                    rsbac_new_target_id.dummy = 0;
+                    if (rsbac_adf_set_attr(R_READ,
+                                           current->pid,
+                                           rsbac_target,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "sys_read: rsbac_adf_set_attr() returned error\n");
+                      }
+                  }
+                #endif
+
 		fput(file);
 	}
 	return ret;
@@ -211,6 +331,14 @@
 	ssize_t ret;
 	struct file * file;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	ret = -EBADF;
 	file = fget(fd);
 	if (file) {
@@ -219,12 +347,118 @@
 			if (!ret) {
 				ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
 				ret = -EINVAL;
+
+                                /* RSBAC */
+                                #ifdef CONFIG_RSBAC_RW
+#ifdef CONFIG_RSBAC_DEBUG
+                                if (rsbac_debug_aef)
+                                  rsbac_printk(KERN_DEBUG "sys_write(): calling ADF\n");
+#endif
+                                /* get target type and id clear */
+                                #ifdef CONFIG_RSBAC_NET_OBJ_RW
+                                if(S_ISSOCK(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                                    if(   file->f_dentry->d_inode->u.socket_i.ops
+                                       && (file->f_dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                                      )
+                                    #endif
+                                      {
+                                        rsbac_target = T_NETOBJ;
+                                        rsbac_target_id.netobj.sock_p
+                                         = &file->f_dentry->d_inode->u.socket_i;
+                                        rsbac_target_id.netobj.local_addr = NULL;
+                                        rsbac_target_id.netobj.local_len = 0;
+                                        rsbac_target_id.netobj.remote_addr = NULL;
+                                        rsbac_target_id.netobj.remote_len = 0;
+                                      }
+                                  }
+                                else
+                                #endif
+                                if(S_ISFIFO(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    if(file->f_dentry->d_inode->i_sb->s_magic != PIPEFS_MAGIC)
+                                      {
+                                        rsbac_target = T_FIFO;
+                                        rsbac_target_id.dir.device = file->f_dentry->d_inode->i_dev;
+                                        rsbac_target_id.dir.inode  = file->f_dentry->d_inode->i_ino;
+                                        rsbac_target_id.dir.dentry_p = file->f_dentry;
+                                      }
+                                    else
+                                      {
+                                        rsbac_target = T_IPC;
+                                        rsbac_target_id.ipc.type = I_anonpipe;
+                                        rsbac_target_id.ipc.id.id_nr = file->f_dentry->d_inode->i_ino;
+                                      }
+                                  }
+                                else
+                                if(S_ISREG(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    rsbac_target = T_FILE;
+                                    rsbac_target_id.file.device = file->f_dentry->d_inode->i_dev;
+                                    rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+                                    rsbac_target_id.file.dentry_p = file->f_dentry;
+                                  }
+                                else
+                                if(S_ISBLK(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    rsbac_target = T_DEV;
+                                    rsbac_target_id.dev.type = D_block;
+                                    rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                                    rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                                  }
+                                else
+                                if(S_ISCHR(file->f_dentry->d_inode->i_mode))
+                                  {
+                                    rsbac_target = T_DEV;
+                                    rsbac_target_id.dev.type = D_char;
+                                    rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                                    rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                                  }
+                                rsbac_attribute_value.dummy = 0;
+                                if (   (rsbac_target != T_NONE)
+                                    && !rsbac_adf_request(R_WRITE,
+                                                          current->pid,
+                                                          rsbac_target,
+                                                          rsbac_target_id,
+                                                          A_none,
+                                                          rsbac_attribute_value)
+                                   )
+                                  {
+                                    ret = -EPERM;
+                                  }
+                                else
+                                #endif /* CONFIG_RSBAC_RW */
+
 				if (file->f_op && (write = file->f_op->write) != NULL)
 					ret = write(file, buf, count, &file->f_pos);
 			}
 		}
 		if (ret > 0)
 			dnotify_parent(file->f_dentry, DN_MODIFY);
+
+                /* RSBAC: notify adf of written file etc. */
+                #ifdef CONFIG_RSBAC_RW
+                if (   (ret > 0)
+                    && (rsbac_target != T_NONE)
+                   )
+                  {
+                    rsbac_new_target_id.dummy = 0;
+                    if (rsbac_adf_set_attr(R_WRITE,
+                                           current->pid,
+                                           rsbac_target,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "sys_write: rsbac_adf_set_attr() returned error\n");
+                      }
+                  }
+                #endif
+
 		fput(file);
 	}
 	return ret;
@@ -245,6 +479,15 @@
 	io_fn_t fn;
 	iov_fn_t fnv;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_adf_request_t     rsbac_request;
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/*
 	 * First get the "struct iovec" from user memory and
 	 * verify all the pointers
@@ -302,7 +545,115 @@
 
 	fnv = (type == VERIFY_WRITE ? file->f_op->readv : file->f_op->writev);
 	if (fnv) {
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_RW
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "do_readv_writev() [sys_vread(), sys_vwrite()]: calling ADF\n");
+#endif
+                /* get target type and id clear */
+                #ifdef CONFIG_RSBAC_NET_OBJ_RW
+                if(S_ISSOCK(file->f_dentry->d_inode->i_mode))
+                  {
+                    #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                    if(   file->f_dentry->d_inode->u.socket_i.ops
+                       && (file->f_dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                      )
+                    #endif
+                      {
+                        rsbac_target = T_NETOBJ;
+                        rsbac_target_id.netobj.sock_p = &file->f_dentry->d_inode->u.socket_i;
+                        rsbac_target_id.netobj.local_addr = NULL;
+                        rsbac_target_id.netobj.local_len = 0;
+                        rsbac_target_id.netobj.remote_addr = NULL;
+                        rsbac_target_id.netobj.remote_len = 0;
+                      }
+                  }
+                else
+                #endif
+                if(S_ISFIFO(file->f_dentry->d_inode->i_mode))
+                  {
+                    if(file->f_dentry->d_inode->i_sb->s_magic != PIPEFS_MAGIC)
+                      {
+                        rsbac_target = T_FIFO;
+                        rsbac_target_id.dir.device = file->f_dentry->d_inode->i_dev;
+                        rsbac_target_id.dir.inode  = file->f_dentry->d_inode->i_ino;
+                        rsbac_target_id.dir.dentry_p = file->f_dentry;
+                      }
+                    else
+                      {
+                        rsbac_target = T_IPC;
+                        rsbac_target_id.ipc.type = I_anonpipe;
+                        rsbac_target_id.ipc.id.id_nr = file->f_dentry->d_inode->i_ino;
+                      }
+                  }
+                else
+                if(S_ISREG(file->f_dentry->d_inode->i_mode))
+                  {
+                    rsbac_target = T_FILE;
+                    rsbac_target_id.file.device = file->f_dentry->d_inode->i_dev;
+                    rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+                    rsbac_target_id.file.dentry_p = file->f_dentry;
+                  }
+                else
+                if(S_ISBLK(file->f_dentry->d_inode->i_mode))
+                  {
+                    rsbac_target = T_DEV;
+                    rsbac_target_id.dev.type = D_block;
+                    rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                    rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                  }
+                else
+                if(S_ISCHR(file->f_dentry->d_inode->i_mode))
+                  {
+                    rsbac_target = T_DEV;
+                    rsbac_target_id.dev.type = D_char;
+                    rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+                    rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+                  }
+                if(type == VERIFY_WRITE)
+                  rsbac_request = R_READ;
+                else
+                  rsbac_request = R_WRITE;
+                rsbac_attribute_value.dummy = 0;
+                if (   (rsbac_target != T_NONE)
+                    && !rsbac_adf_request(rsbac_request,
+                                          current->pid,
+                                          rsbac_target,
+                                          rsbac_target_id,
+                                          A_none,
+                                          rsbac_attribute_value)
+                   )
+                  {
+                    ret = -EPERM;
+                  }
+                else
+                #endif /* CONFIG_RSBAC_RW */
+
 		ret = fnv(file, iov, count, &file->f_pos);
+
+                /* RSBAC: notify adf of read or written file etc. */
+                #ifdef CONFIG_RSBAC_RW
+                if (   (ret > 0)
+                    && (rsbac_target != T_NONE)
+                   )
+                  {
+                    rsbac_new_target_id.dummy = 0;
+                    if (rsbac_adf_set_attr(rsbac_request,
+                                           current->pid,
+                                           rsbac_target,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "do_readv_writev() [sys_vread(), sys_vwrite()]: rsbac_adf_set_attr() returned error\n");
+                      }
+                  }
+                #endif
+
 		goto out;
 	}
 
@@ -395,6 +746,14 @@
 	struct file * file;
 	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	ret = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -410,9 +769,78 @@
 		goto out;
 	if (pos < 0)
 		goto out;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_pread(): calling ADF\n");
+#endif
+        /* get target type and id clear */
+        if(S_ISREG(file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.file.device = file->f_dentry->d_inode->i_dev;
+            rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+            rsbac_target_id.file.dentry_p = file->f_dentry;
+          }
+        else
+        if(S_ISBLK(file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+          }
+        else
+        if(S_ISCHR(file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_char;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (   (rsbac_target != T_NONE)
+            && !rsbac_adf_request(R_READ,
+                                  current->pid,
+                                  rsbac_target,
+                                  rsbac_target_id,
+                                  A_none,
+                                  rsbac_attribute_value)
+           )
+          {
+            ret = -EPERM;
+            goto out;
+          }
+        #endif /* CONFIG_RSBAC_RW */
+
 	ret = read(file, buf, count, &pos);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_ACCESS);
+
+        /* RSBAC: notify adf of read file etc. */
+        #ifdef CONFIG_RSBAC_RW
+        if (   (ret > 0)
+            && (rsbac_target != T_NONE)
+           )
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_READ,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                        "sys_pread(): rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 out:
 	fput(file);
 bad_file:
@@ -426,6 +854,14 @@
 	struct file * file;
 	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	ret = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -442,9 +878,77 @@
 	if (pos < 0)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_pwrite(): calling ADF\n");
+#endif
+        /* get target type and id clear */
+        if(S_ISREG(file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_FILE;
+            rsbac_target_id.file.device = file->f_dentry->d_inode->i_dev;
+            rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+            rsbac_target_id.file.dentry_p = file->f_dentry;
+          }
+        else
+        if(S_ISBLK(file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_block;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+          }
+        else
+        if(S_ISCHR(file->f_dentry->d_inode->i_mode))
+          {
+            rsbac_target = T_DEV;
+            rsbac_target_id.dev.type = D_char;
+            rsbac_target_id.dev.major = RSBAC_MAJOR(file->f_dentry->d_inode->i_rdev);
+            rsbac_target_id.dev.minor = RSBAC_MINOR(file->f_dentry->d_inode->i_rdev);
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (   (rsbac_target != T_NONE)
+            && !rsbac_adf_request(R_WRITE,
+                                  current->pid,
+                                  rsbac_target,
+                                  rsbac_target_id,
+                                  A_none,
+                                  rsbac_attribute_value)
+           )
+          {
+            ret = -EPERM;
+            goto out;
+          }
+        #endif /* CONFIG_RSBAC_RW */
+
 	ret = write(file, buf, count, &pos);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_MODIFY);
+
+        /* RSBAC: notify adf of written file etc. */
+        #ifdef CONFIG_RSBAC_RW
+        if (   (ret > 0)
+            && (rsbac_target != T_NONE)
+           )
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_WRITE,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_pwrite(): rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 out:
 	fput(file);
 bad_file:
diff -urN -x rsbac trunk/fs/reiserfs/namei.c linux-2.4.32-rsbac-1.2.7/fs/reiserfs/namei.c
--- trunk/fs/reiserfs/namei.c	2006-06-01 10:30:53.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/reiserfs/namei.c	2006-06-01 10:32:29.000000000 +0200
@@ -8,6 +8,11 @@
 #include <linux/reiserfs_fs.h>
 #include <linux/smp_lock.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_SECDEL
+#include <rsbac/adf.h>
+#endif
+
 #define INC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) { i->i_nlink++; if (i->i_nlink >= REISERFS_LINK_MAX) i->i_nlink=1; }
 #define DEC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) i->i_nlink--;
 
@@ -826,6 +831,14 @@
     savelink = inode->i_nlink;
 
 
+    /* RSBAC */
+    #ifdef CONFIG_RSBAC_SECDEL
+    if(inode->i_nlink == 1)
+      {
+        rsbac_sec_del(dentry);
+      }
+    #endif
+
     retval = reiserfs_cut_from_item (&th, &path, &(de.de_entry_key), dir, NULL, 0);
     if (retval < 0) {
 	inode->i_nlink++;
@@ -1106,6 +1119,12 @@
 	    reiserfs_panic (old_dir->i_sb,
 			    "vs-7050: new entry is found, new inode == 0\n");
 	}
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+        if(new_dentry_inode->i_nlink == 1)
+          rsbac_sec_del(new_dentry);
+        #endif
+
     } else if (retval) {
 	pop_journal_writer(windex) ;
 	journal_end(&th, old_dir->i_sb, jbegin_count) ;
diff -urN -x rsbac trunk/fs/stat.c linux-2.4.32-rsbac-1.2.7/fs/stat.c
--- trunk/fs/stat.c	2006-06-01 10:30:55.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/stat.c	2006-06-01 10:32:31.000000000 +0200
@@ -13,6 +13,11 @@
 
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Revalidate the inode. This is required for proper NFS attribute caching.
  */
@@ -143,9 +148,72 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk(filename, &nd);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!error)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_stat(): calling ADF\n");
+#endif
+                    if(S_ISSOCK(nd.dentry->d_inode->i_mode))
+                      {
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+                        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                        if(   nd.dentry->d_inode->u.socket_i.ops
+                           && (nd.dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                          )
+                        #endif
+                          {
+                            rsbac_target = T_NETOBJ;
+                            rsbac_target_id.netobj.sock_p
+                              = &nd.dentry->d_inode->u.socket_i;
+                            rsbac_target_id.netobj.local_addr = NULL;
+                            rsbac_target_id.netobj.local_len = 0;
+                            rsbac_target_id.netobj.remote_addr = NULL;
+                            rsbac_target_id.netobj.remote_len = 0;
+                          }
+                        #endif
+                      }
+                    else
+                      {
+                        if (S_ISDIR(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_DIR;
+                        else if (S_ISFIFO(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_FIFO;
+                        else if (S_ISLNK(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_SYMLINK;
+                        else
+                          rsbac_target = T_FILE;
+                        rsbac_target_id.file.device = nd.dentry->d_inode->i_dev;
+                        rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+                        rsbac_target_id.file.dentry_p = nd.dentry;
+		      }
+                    rsbac_attribute_value.dummy = 0;
+                    if(   (rsbac_target != T_NONE)
+                       && !rsbac_adf_request(R_GET_STATUS_DATA,
+                                             current->pid,
+                                             rsbac_target,
+                                             rsbac_target_id,
+                                             A_none,
+                                             rsbac_attribute_value)
+                      )
+                      {
+                        error = -EPERM;
+                      }
+                  }
+                #endif
+
 		if (!error)
 			error = cp_old_stat(nd.dentry->d_inode, statbuf);
 		path_release(&nd);
@@ -159,9 +227,72 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk(filename, &nd);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!error)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_newstat(): calling ADF\n");
+#endif
+                    if(S_ISSOCK(nd.dentry->d_inode->i_mode))
+                      {
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+                        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                        if(   nd.dentry->d_inode->u.socket_i.ops
+                           && (nd.dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                          )
+                        #endif
+                          {
+                            rsbac_target = T_NETOBJ;
+                            rsbac_target_id.netobj.sock_p
+                              = &nd.dentry->d_inode->u.socket_i;
+                            rsbac_target_id.netobj.local_addr = NULL;
+                            rsbac_target_id.netobj.local_len = 0;
+                            rsbac_target_id.netobj.remote_addr = NULL;
+                            rsbac_target_id.netobj.remote_len = 0;
+                          }
+                        #endif
+                      }
+                    else
+                      {
+                        if (S_ISDIR(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_DIR;
+                        else if (S_ISFIFO(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_FIFO;
+                        else if (S_ISLNK(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_SYMLINK;
+                        else
+                          rsbac_target = T_FILE;
+                        rsbac_target_id.file.device = nd.dentry->d_inode->i_dev;
+                        rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+                        rsbac_target_id.file.dentry_p = nd.dentry;
+		      }
+                    rsbac_attribute_value.dummy = 0;
+                    if(   (rsbac_target != T_NONE)
+                       && !rsbac_adf_request(R_GET_STATUS_DATA,
+                                             current->pid,
+                                             rsbac_target,
+                                             rsbac_target_id,
+                                             A_none,
+                                             rsbac_attribute_value)
+                      )
+                      {
+                        error = -EPERM;
+                      }
+                  }
+                #endif
+
 		if (!error)
 			error = cp_new_stat(nd.dentry->d_inode, statbuf);
 		path_release(&nd);
@@ -180,9 +311,72 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk_link(filename, &nd);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!error)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_lstat(): calling ADF\n");
+#endif
+                    if(S_ISSOCK(nd.dentry->d_inode->i_mode))
+                      {
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+                        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                        if(   nd.dentry->d_inode->u.socket_i.ops
+                           && (nd.dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                          )
+                        #endif
+                          {
+                            rsbac_target = T_NETOBJ;
+                            rsbac_target_id.netobj.sock_p
+                              = &nd.dentry->d_inode->u.socket_i;
+                            rsbac_target_id.netobj.local_addr = NULL;
+                            rsbac_target_id.netobj.local_len = 0;
+                            rsbac_target_id.netobj.remote_addr = NULL;
+                            rsbac_target_id.netobj.remote_len = 0;
+                          }
+                        #endif
+                      }
+                    else
+                      {
+                        if (S_ISDIR(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_DIR;
+                        else if (S_ISFIFO(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_FIFO;
+                        else if (S_ISLNK(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_SYMLINK;
+                        else
+                          rsbac_target = T_FILE;
+                        rsbac_target_id.file.device = nd.dentry->d_inode->i_dev;
+                        rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+                        rsbac_target_id.file.dentry_p = nd.dentry;
+		      }
+                    rsbac_attribute_value.dummy = 0;
+                    if(   (rsbac_target != T_NONE)
+                       && !rsbac_adf_request(R_GET_STATUS_DATA,
+                                             current->pid,
+                                             rsbac_target,
+                                             rsbac_target_id,
+                                             A_none,
+                                             rsbac_attribute_value)
+                      )
+                      {
+                        error = -EPERM;
+                      }
+                  }
+                #endif
+
 		if (!error)
 			error = cp_old_stat(nd.dentry->d_inode, statbuf);
 		path_release(&nd);
@@ -197,9 +391,72 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk_link(filename, &nd);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!error)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_newlstat(): calling ADF\n");
+#endif
+                    if(S_ISSOCK(nd.dentry->d_inode->i_mode))
+                      {
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+                        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                        if(   nd.dentry->d_inode->u.socket_i.ops
+                           && (nd.dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                          )
+                        #endif
+                          {
+                            rsbac_target = T_NETOBJ;
+                            rsbac_target_id.netobj.sock_p
+                              = &nd.dentry->d_inode->u.socket_i;
+                            rsbac_target_id.netobj.local_addr = NULL;
+                            rsbac_target_id.netobj.local_len = 0;
+                            rsbac_target_id.netobj.remote_addr = NULL;
+                            rsbac_target_id.netobj.remote_len = 0;
+                          }
+                        #endif
+                      }
+                    else
+                      {
+                        if (S_ISDIR(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_DIR;
+                        else if (S_ISFIFO(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_FIFO;
+                        else if (S_ISLNK(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_SYMLINK;
+                        else
+                          rsbac_target = T_FILE;
+                        rsbac_target_id.file.device = nd.dentry->d_inode->i_dev;
+                        rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+                        rsbac_target_id.file.dentry_p = nd.dentry;
+		      }
+                    rsbac_attribute_value.dummy = 0;
+                    if(   (rsbac_target != T_NONE)
+                       && !rsbac_adf_request(R_GET_STATUS_DATA,
+                                             current->pid,
+                                             rsbac_target,
+                                             rsbac_target_id,
+                                             A_none,
+                                             rsbac_attribute_value)
+                      )
+                      {
+                        error = -EPERM;
+                      }
+                  }
+                #endif
+
 		if (!error)
 			error = cp_new_stat(nd.dentry->d_inode, statbuf);
 		path_release(&nd);
@@ -218,11 +475,49 @@
 	struct file * f;
 	int err = -EBADF;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	f = fget(fd);
 	if (f) {
 		struct dentry * dentry = f->f_dentry;
 
 		err = do_revalidate(dentry);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!err)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_fstat(): calling ADF\n");
+#endif
+                    rsbac_target = T_FILE;
+                    if (S_ISDIR(dentry->d_inode->i_mode))
+                      rsbac_target = T_DIR;
+                    else if (S_ISFIFO(dentry->d_inode->i_mode))
+                      rsbac_target = T_FIFO;
+                    else if (S_ISLNK(dentry->d_inode->i_mode))
+                       rsbac_target = T_SYMLINK;
+                    rsbac_target_id.file.device = dentry->d_inode->i_dev;
+                    rsbac_target_id.file.inode  = dentry->d_inode->i_ino;
+                    rsbac_target_id.file.dentry_p = dentry;
+                    rsbac_attribute_value.dummy = 0;
+                    if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                           current->pid,
+                                           rsbac_target,
+                                           rsbac_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                      }
+                  }
+                #endif
+
 		if (!err)
 			err = cp_old_stat(dentry->d_inode, statbuf);
 		fput(f);
@@ -237,11 +532,63 @@
 	struct file * f;
 	int err = -EBADF;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	f = fget(fd);
 	if (f) {
 		struct dentry * dentry = f->f_dentry;
 
 		err = do_revalidate(dentry);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!err)
+                  {
+                    rsbac_target = T_NONE;
+                    if (S_ISDIR(dentry->d_inode->i_mode))
+                      rsbac_target = T_DIR;
+                    else
+                    if (S_ISFIFO(dentry->d_inode->i_mode))
+                      rsbac_target = T_FIFO;
+                    else
+                    if (S_ISLNK(dentry->d_inode->i_mode))
+                      rsbac_target = T_SYMLINK;
+                    else
+                    if (   S_ISREG(dentry->d_inode->i_mode)
+                        || S_ISCHR(dentry->d_inode->i_mode)
+                        || S_ISBLK(dentry->d_inode->i_mode)
+                       )
+                      rsbac_target = T_FILE;
+                    if(rsbac_target != T_NONE)
+                      {
+#ifdef CONFIG_RSBAC_DEBUG
+                        if (rsbac_debug_aef)
+                          rsbac_printk(KERN_DEBUG
+                                 "sys_newfstat(): calling ADF for mode %o target\n",
+                                 dentry->d_inode->i_mode);
+#endif
+                        rsbac_target_id.file.device = dentry->d_inode->i_dev;
+                        rsbac_target_id.file.inode  = dentry->d_inode->i_ino;
+                        rsbac_target_id.file.dentry_p = dentry;
+                        rsbac_attribute_value.dummy = 0;
+                        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                               current->pid,
+                                               rsbac_target,
+                                               rsbac_target_id,
+                                               A_none,
+                                               rsbac_attribute_value))
+                          {
+                            err = -EPERM;
+                          }
+                      }
+                  }
+                #endif
+
 		if (!err)
 			err = cp_new_stat(dentry->d_inode, statbuf);
 		fput(f);
@@ -254,6 +601,12 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (bufsiz <= 0)
 		return -EINVAL;
 
@@ -264,6 +617,28 @@
 		error = -EINVAL;
 		if (inode->i_op && inode->i_op->readlink &&
 		    !(error = do_revalidate(nd.dentry))) {
+                        /* RSBAC */
+                        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                        if (rsbac_debug_aef)
+                          rsbac_printk(KERN_DEBUG "sys_readlink(): calling ADF\n");
+#endif
+                        rsbac_target_id.file.device = inode->i_dev;
+                        rsbac_target_id.file.inode  = inode->i_ino;
+                        rsbac_target_id.file.dentry_p = nd.dentry;
+                        rsbac_attribute_value.dummy = 0;
+                        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                               current->pid,
+                                               T_SYMLINK,
+                                               rsbac_target_id,
+                                               A_none,
+                                               rsbac_attribute_value))
+                          {
+                            path_release(&nd);
+                            return -EPERM;
+                          }
+                        #endif /* CONFIG_RSBAC */
+
 			UPDATE_ATIME(inode);
 			error = inode->i_op->readlink(nd.dentry, buf, bufsiz);
 		}
@@ -340,9 +715,72 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk(filename, &nd);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!error && nd.dentry->d_inode)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_stat64(): calling ADF\n");
+#endif
+                    if(S_ISSOCK(nd.dentry->d_inode->i_mode))
+                      {
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+                        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                        if(   nd.dentry->d_inode->u.socket_i.ops
+                           && (nd.dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                          )
+                        #endif
+                          {
+                            rsbac_target = T_NETOBJ;
+                            rsbac_target_id.netobj.sock_p
+                              = &nd.dentry->d_inode->u.socket_i;
+                            rsbac_target_id.netobj.local_addr = NULL;
+                            rsbac_target_id.netobj.local_len = 0;
+                            rsbac_target_id.netobj.remote_addr = NULL;
+                            rsbac_target_id.netobj.remote_len = 0;
+                          }
+                        #endif
+                      }
+                    else
+                      {
+                        if (S_ISDIR(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_DIR;
+                        else if (S_ISFIFO(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_FIFO;
+                        else if (S_ISLNK(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_SYMLINK;
+                        else
+                          rsbac_target = T_FILE;
+                        rsbac_target_id.file.device = nd.dentry->d_inode->i_dev;
+                        rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+                        rsbac_target_id.file.dentry_p = nd.dentry;
+		      }
+                    rsbac_attribute_value.dummy = 0;
+                    if(   (rsbac_target != T_NONE)
+                       && !rsbac_adf_request(R_GET_STATUS_DATA,
+                                             current->pid,
+                                             rsbac_target,
+                                             rsbac_target_id,
+                                             A_none,
+                                             rsbac_attribute_value)
+                      )
+                      {
+                        error = -EPERM;
+                      }
+                   }
+                #endif
+
 		if (!error)
 			error = cp_new_stat64(nd.dentry->d_inode, statbuf);
 		path_release(&nd);
@@ -355,9 +793,72 @@
 	struct nameidata nd;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	error = user_path_walk_link(filename, &nd);
 	if (!error) {
 		error = do_revalidate(nd.dentry);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!error && nd.dentry->d_inode)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_lstat64(): calling ADF\n");
+#endif
+                    if(S_ISSOCK(nd.dentry->d_inode->i_mode))
+                      {
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+                        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                        if(   nd.dentry->d_inode->u.socket_i.ops
+                           && (nd.dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                          )
+                        #endif
+                          {
+                            rsbac_target = T_NETOBJ;
+                            rsbac_target_id.netobj.sock_p
+                              = &nd.dentry->d_inode->u.socket_i;
+                            rsbac_target_id.netobj.local_addr = NULL;
+                            rsbac_target_id.netobj.local_len = 0;
+                            rsbac_target_id.netobj.remote_addr = NULL;
+                            rsbac_target_id.netobj.remote_len = 0;
+                          }
+                        #endif
+                      }
+                    else
+                      {
+                        if (S_ISDIR(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_DIR;
+                        else if (S_ISFIFO(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_FIFO;
+                        else if (S_ISLNK(nd.dentry->d_inode->i_mode))
+                          rsbac_target = T_SYMLINK;
+                        else
+                          rsbac_target = T_FILE;
+                        rsbac_target_id.file.device = nd.dentry->d_inode->i_dev;
+                        rsbac_target_id.file.inode  = nd.dentry->d_inode->i_ino;
+                        rsbac_target_id.file.dentry_p = nd.dentry;
+		      }
+                    rsbac_attribute_value.dummy = 0;
+                    if(   (rsbac_target != T_NONE)
+                       && !rsbac_adf_request(R_GET_STATUS_DATA,
+                                             current->pid,
+                                             rsbac_target,
+                                             rsbac_target_id,
+                                             A_none,
+                                             rsbac_attribute_value)
+                      )
+                      {
+                        error = -EPERM;
+                      }
+                  }
+                #endif
+
 		if (!error)
 			error = cp_new_stat64(nd.dentry->d_inode, statbuf);
 		path_release(&nd);
@@ -370,11 +871,84 @@
 	struct file * f;
 	int err = -EBADF;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	f = fget(fd);
 	if (f) {
 		struct dentry * dentry = f->f_dentry;
 
 		err = do_revalidate(dentry);
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                if(!err && dentry->d_inode)
+                  {
+                    if(S_ISSOCK(dentry->d_inode->i_mode))
+                      {
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+                        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                        if(   dentry->d_inode->u.socket_i.ops
+                           && (dentry->d_inode->u.socket_i.ops->family != AF_UNIX)
+                          )
+                        #endif
+                          {
+                            rsbac_target = T_NETOBJ;
+                            rsbac_target_id.netobj.sock_p
+                              = &dentry->d_inode->u.socket_i;
+                            rsbac_target_id.netobj.local_addr = NULL;
+                            rsbac_target_id.netobj.local_len = 0;
+                            rsbac_target_id.netobj.remote_addr = NULL;
+                            rsbac_target_id.netobj.remote_len = 0;
+                          }
+                        #endif
+                      }
+                    else
+                      {
+                        if (S_ISDIR(dentry->d_inode->i_mode))
+                          rsbac_target = T_DIR;
+                        else
+                        if (S_ISFIFO(dentry->d_inode->i_mode))
+                          rsbac_target = T_FIFO;
+                        else
+                        if (S_ISLNK(dentry->d_inode->i_mode))
+                          rsbac_target = T_SYMLINK;
+                        else
+                        if (   S_ISREG(dentry->d_inode->i_mode)
+                            || S_ISCHR(dentry->d_inode->i_mode)
+                            || S_ISBLK(dentry->d_inode->i_mode)
+                           )
+                          rsbac_target = T_FILE;
+                        rsbac_target_id.file.device = dentry->d_inode->i_dev;
+                        rsbac_target_id.file.inode  = dentry->d_inode->i_ino;
+                        rsbac_target_id.file.dentry_p = dentry;
+		      }
+                    if(rsbac_target != T_NONE)
+                      {
+#ifdef CONFIG_RSBAC_DEBUG
+                        if (rsbac_debug_aef)
+                          rsbac_printk(KERN_DEBUG
+                                 "sys_fstat64(): calling ADF for mode %o target\n",
+                                 dentry->d_inode->i_mode);
+#endif
+                        rsbac_attribute_value.dummy = 0;
+                        if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                               current->pid,
+                                               rsbac_target,
+                                               rsbac_target_id,
+                                               A_none,
+                                               rsbac_attribute_value))
+                          {
+                            err = -EPERM;
+                          }
+                      }
+                  }
+                #endif
+
 		if (!err)
 			err = cp_new_stat64(dentry->d_inode, statbuf);
 		fput(f);
diff -urN -x rsbac trunk/fs/vfat/namei.c linux-2.4.32-rsbac-1.2.7/fs/vfat/namei.c
--- trunk/fs/vfat/namei.c	2006-06-01 10:30:51.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/fs/vfat/namei.c	2006-06-01 10:32:27.000000000 +0200
@@ -28,6 +28,11 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_SECDEL
+#include <rsbac/adf.h>
+#endif
+
 #define DEBUG_LEVEL 0
 #if (DEBUG_LEVEL >= 1)
 #  define PRINTK1(x) printk x
@@ -1110,6 +1115,11 @@
 	res = vfat_find(dir,&dentry->d_name,&sinfo,&bh,&de);
 	if (res < 0)
 		return res;
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SECDEL
+        rsbac_sec_del(dentry);
+        #endif
+
 	dentry->d_inode->i_nlink = 0;
 	dentry->d_inode->i_mtime = CURRENT_TIME;
 	dentry->d_inode->i_atime = CURRENT_TIME;
@@ -1203,6 +1213,13 @@
 			if (res)
 				goto rename_done;
 		}
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_SECDEL
+                else
+                  if(new_inode->i_nlink == 1)
+                    rsbac_sec_del(new_dentry);
+                #endif
+
 		fat_detach(new_inode);
 	} else {
 		res = vfat_add_entry(new_dir,&new_dentry->d_name,is_dir,&sinfo,
--- linux-2.4.32.avx/fs/xattr.c	2006-06-07 11:01:47.000000000 -0600
+++ linux-2.4.32/fs/xattr.c	2006-06-07 11:12:25.000000000 -0600
@@ -14,6 +14,11 @@
 #include <linux/xattr.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Extended attribute memory allocation wrappers, originally
  * based on the Intermezzo PRESTO_ALLOC/PRESTO_FREE macros.
@@ -64,6 +69,13 @@
 	void *kvalue;
 	char kname[XATTR_NAME_MAX + 1];
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (flags & ~(XATTR_CREATE|XATTR_REPLACE))
 		return -EINVAL;
 
@@ -76,6 +88,32 @@
 	if (strncmp(kname, "security.", 9) == 0 && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "setxattr() [sys_*setxattr()]: calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(d->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(d->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(d->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = d->d_inode->i_dev;
+        rsbac_target_id.file.inode  = d->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = d;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          return -EPERM;
+        #endif
+
 	kvalue = xattr_alloc(size, XATTR_SIZE_MAX);
 	if (IS_ERR(kvalue))
 		return PTR_ERR(kvalue);
@@ -150,12 +188,45 @@
 	void *kvalue;
 	char kname[XATTR_NAME_MAX + 1];
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+	enum  rsbac_target_t          rsbac_target;
+	union rsbac_target_id_t       rsbac_target_id;
+	union rsbac_attribute_value_t rsbac_attribute_value;
+	#endif
+
 	error = strncpy_from_user(kname, name, sizeof(kname));
 	if (error == 0 || error == sizeof(kname))
 		error = -ERANGE;
 	if (error < 0)
 		return error;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "getxattr() [sys_*getxattr()]: calling ADF\n");
+#endif
+	rsbac_target = T_FILE;
+	if (S_ISDIR(d->d_inode->i_mode))
+	  rsbac_target = T_DIR;   
+	else if (S_ISFIFO(d->d_inode->i_mode))
+	  rsbac_target = T_FIFO;  
+	else if (S_ISLNK(d->d_inode->i_mode))
+	  rsbac_target = T_SYMLINK;
+	rsbac_target_id.file.device = d->d_inode->i_dev;
+	rsbac_target_id.file.inode  = d->d_inode->i_ino;
+	rsbac_target_id.file.dentry_p = d;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+       	  return -EPERM;
+	#endif
+
 	kvalue = xattr_alloc(size, XATTR_SIZE_MAX);
 	if (IS_ERR(kvalue))
 		return PTR_ERR(kvalue);
@@ -225,6 +296,39 @@
 	ssize_t error;
 	char *klist;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "listxattr() [sys_*listxattr()]: calling ADF\n");
+#endif
+        rsbac_target = T_FILE;
+        if (S_ISDIR(d->d_inode->i_mode))
+          rsbac_target = T_DIR;
+        else if (S_ISFIFO(d->d_inode->i_mode))
+          rsbac_target = T_FIFO;
+        else if (S_ISLNK(d->d_inode->i_mode))
+          rsbac_target = T_SYMLINK;
+        rsbac_target_id.file.device = d->d_inode->i_dev;
+        rsbac_target_id.file.inode  = d->d_inode->i_ino;
+        rsbac_target_id.file.dentry_p = d;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_GET_PERMISSIONS_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          return -EPERM;
+        #endif
+
 	klist = (char *)xattr_alloc(size, XATTR_LIST_MAX);
 	if (IS_ERR(klist))
 		return PTR_ERR(klist);
diff -urN -x rsbac trunk/include/asm-alpha/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-alpha/unistd.h
--- trunk/include/asm-alpha/unistd.h	2006-06-01 10:30:43.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-alpha/unistd.h	2006-06-01 10:32:19.000000000 +0200
@@ -333,6 +333,11 @@
 #define __NR_fremovexattr		393
 
 
+/* RSBAC - we start at 400 */
+#ifdef CONFIG_RSBAC
+#include <rsbac/unistd-alpha.h>
+#endif
+
 #if defined(__GNUC__)
 
 #define _syscall_return(type)						\
diff -urN -x rsbac trunk/include/asm-arm/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-arm/unistd.h
--- trunk/include/asm-arm/unistd.h	2006-06-01 10:30:35.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-arm/unistd.h	2006-06-01 10:32:11.000000000 +0200
@@ -286,6 +286,11 @@
                                         /* 256 for set_tid_address */
 #endif
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac __NR_security
+#endif
+
 /*
  * The following SWIs are ARM private.
  */
diff -urN -x rsbac trunk/include/asm-cris/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-cris/unistd.h
--- trunk/include/asm-cris/unistd.h	2006-06-01 10:30:45.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-cris/unistd.h	2006-06-01 10:32:21.000000000 +0200
@@ -258,6 +258,11 @@
 #define __NR_free_hugepages	251
 #define __NR_exit_group		252
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac __NR_security
+#endif
+
 /* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
 /*
  * Don't remove the .ifnc tests; they are an insurance against
diff -urN -x rsbac trunk/include/asm-i386/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-i386/unistd.h
--- trunk/include/asm-i386/unistd.h	2006-06-01 10:30:44.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-i386/unistd.h	2006-06-01 10:32:19.000000000 +0200
@@ -258,7 +258,13 @@
 #define __NR_free_hugepages	251
 #define __NR_exit_group		252
 
+/* RSBAC - we use 223 / security */
+#ifdef CONFIG_RSBAC
+#include <rsbac/unistd-i386.h>
+#endif
+
 /* user-visible error numbers are in the range -1 - -124: see <asm-i386/errno.h> */
+/* RSBAC errors are -1001 - -1024, so they are directly returned - AO */
 
 #define __syscall_return(type, res) \
 do { \
diff -urN -x rsbac trunk/include/asm-ia64/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-ia64/unistd.h
--- trunk/include/asm-ia64/unistd.h	2006-06-01 10:30:31.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-ia64/unistd.h	2006-06-01 10:32:06.000000000 +0200
@@ -225,6 +225,11 @@
 /* 1238-1242: reserved for io_{setup,destroy,getevents,submit,cancel} */
 #define __NR_semtimedop			1247
 
+/* RSBAC - we use 1270 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac			1270
+#endif
+
 #if !defined(__ASSEMBLY__) && !defined(ASSEMBLER)
 
 extern long __ia64_syscall (long a0, long a1, long a2, long a3, long a4, long nr);
diff -urN -x rsbac trunk/include/asm-m68k/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-m68k/unistd.h
--- trunk/include/asm-m68k/unistd.h	2006-06-01 10:30:43.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-m68k/unistd.h	2006-06-01 10:32:18.000000000 +0200
@@ -238,6 +238,11 @@
 #define __NR_lremovexattr	233
 #define __NR_fremovexattr	234
 
+/* RSBAC - we use 240 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		240
+#endif
+
 /* user-visible error numbers are in the range -1 - -122: see
    <asm-m68k/errno.h> */
 
diff -urN -x rsbac trunk/include/asm-mips/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-mips/unistd.h
--- trunk/include/asm-mips/unistd.h	2006-06-01 10:30:32.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-mips/unistd.h	2006-06-01 10:32:07.000000000 +0200
@@ -258,6 +258,11 @@
 #define __NR_sched_setaffinity		(__NR_Linux + 239)
 #define __NR_sched_getaffinity		(__NR_Linux + 240)
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac __NR_security
+#endif
+
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
diff -urN -x rsbac trunk/include/asm-mips64/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-mips64/unistd.h
--- trunk/include/asm-mips64/unistd.h	2006-06-01 10:30:40.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-mips64/unistd.h	2006-06-01 10:32:17.000000000 +0200
@@ -258,6 +258,11 @@
 #define __NR_sched_setaffinity		(__NR_Linux + 239)
 #define __NR_sched_getaffinity		(__NR_Linux + 240)
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR_Linux32_rsbac __NR_Linux32_security
+#endif
+
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
@@ -490,6 +495,11 @@
 #define __NR_unused213			(__NR_Linux + 213)
 #define __NR_semtimedop			(__NR_Linux + 214)
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR__rsbac __NR__security
+#endif
+
 /*
  * Offset of the last Linux 64-bit flavoured syscall
  */
diff -urN -x rsbac trunk/include/asm-ppc/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-ppc/unistd.h
--- trunk/include/asm-ppc/unistd.h	2006-06-01 10:30:39.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-ppc/unistd.h	2006-06-01 10:32:16.000000000 +0200
@@ -257,6 +257,11 @@
 #endif
 #define __NR_swapcontext	249
 
+/* RSBAC - we use 220 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		220
+#endif
+
 #define __NR(n)	#n
 
 /* On powerpc a system call basically clobbers the same registers like a
diff -urN -x rsbac trunk/include/asm-s390/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-s390/unistd.h
--- trunk/include/asm-s390/unistd.h	2006-06-01 10:30:45.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-s390/unistd.h	2006-06-01 10:32:20.000000000 +0200
@@ -219,6 +219,11 @@
 #define __NR_gettid		236
 #define __NR_tkill		237
 
+/* RSBAC - we use 250 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		250
+#endif
+
 /* user-visible error numbers are in the range -1 - -122: see <asm-s390/errno.h> */
 
 #define __syscall_return(type, res)                          \
diff -urN -x rsbac trunk/include/asm-s390x/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-s390x/unistd.h
--- trunk/include/asm-s390x/unistd.h	2006-06-01 10:30:44.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-s390x/unistd.h	2006-06-01 10:32:19.000000000 +0200
@@ -187,6 +187,11 @@
 #define __NR_gettid		236
 #define __NR_tkill		237
 
+/* RSBAC - we use 250 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		250
+#endif
+
 
 /* user-visible error numbers are in the range -1 - -122: see <asm-s390/errno.h> */
 
diff -urN -x rsbac trunk/include/asm-sh/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-sh/unistd.h
--- trunk/include/asm-sh/unistd.h	2006-06-01 10:30:34.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-sh/unistd.h	2006-06-01 10:32:09.000000000 +0200
@@ -235,6 +235,11 @@
 #define __NR_tkill		223
 #define __NR_readahead		225
 
+/* RSBAC - we use 250 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		250
+#endif
+
 /* user-visible error numbers are in the range -1 - -125: see <asm-sh/errno.h> */
 
 #define __syscall_return(type, res) \
diff -urN -x rsbac trunk/include/asm-sparc/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-sparc/unistd.h
--- trunk/include/asm-sparc/unistd.h	2006-06-01 10:30:33.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-sparc/unistd.h	2006-06-01 10:32:08.000000000 +0200
@@ -272,6 +272,12 @@
 #define __NR_nfsservctl         254
 #define __NR_aplib              255
 
+/* RSBAC - we use 270 */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		270
+#endif
+
+
 #define _syscall0(type,name) \
 type name(void) \
 { \
diff -urN -x rsbac trunk/include/asm-sparc64/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-sparc64/unistd.h
--- trunk/include/asm-sparc64/unistd.h	2006-06-01 10:30:41.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-sparc64/unistd.h	2006-06-01 10:32:18.000000000 +0200
@@ -274,6 +274,11 @@
 #define __NR_nfsservctl         254
 #define __NR_aplib              255
 
+/* RSBAC - we just use 235, which seems to be unused */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac		235
+#endif
+
 #define _syscall0(type,name) \
 type name(void) \
 { \
diff -urN -x rsbac trunk/include/asm-x86_64/ia32_unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-x86_64/ia32_unistd.h
--- trunk/include/asm-x86_64/ia32_unistd.h	2006-06-01 10:30:45.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-x86_64/ia32_unistd.h	2006-06-01 10:32:20.000000000 +0200
@@ -250,6 +250,11 @@
 #define __NR_ia32_sched_setaffinity	241
 #define __NR_ia32_sched_getaffinity	242
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR_ia32_rsbac __NR_ia32_security
+#endif
+
 #define IA32_NR_syscalls 245
 
 #endif /* _ASM_X86_64_IA32_UNISTD_H_ */
diff -urN -x rsbac trunk/include/asm-x86_64/unistd.h linux-2.4.32-rsbac-1.2.7/include/asm-x86_64/unistd.h
--- trunk/include/asm-x86_64/unistd.h	2006-06-01 10:30:45.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/asm-x86_64/unistd.h	2006-06-01 10:32:20.000000000 +0200
@@ -427,7 +427,13 @@
 __SYSCALL(__NR_tuxcall, sys_ni_syscall)
 
 #define __NR_security			185 /* reserved for security */
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#define __NR_rsbac			185 /* reserved for security */
+__SYSCALL(__NR_rsbac, sys_rsbac)
+#else
 __SYSCALL(__NR_security, sys_ni_syscall)
+#endif
 
 #define __NR_gettid		186
 __SYSCALL(__NR_gettid, sys_gettid)
diff -urN -x rsbac trunk/include/linux/sched.h linux-2.4.32-rsbac-1.2.7/include/linux/sched.h
--- trunk/include/linux/sched.h	2006-06-01 10:30:39.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/include/linux/sched.h	2006-06-01 10:32:15.000000000 +0200
@@ -27,6 +27,10 @@
 #include <linux/securebits.h>
 #include <linux/fs_struct.h>
 
+#if defined(CONFIG_RSBAC_CAP_LOG_MISSING) || defined(CONFIG_RSBAC_JAIL_LOG_MISSING)
+#include <rsbac/log_cap.h>
+#endif
+
 struct exec_domain;
 
 /*
@@ -45,6 +49,7 @@
 #define CLONE_NEWNS	0x00020000	/* New namespace group? */
 
 #define CLONE_SIGNAL	(CLONE_SIGHAND | CLONE_THREAD)
+#define CLONE_KTHREAD   0x10000000      /* clone a kernel thread */
 
 /*
  * These are the constant used to fake the fixed-point load-average
@@ -751,6 +756,10 @@
 		current->flags |= PF_SUPERPRIV;
 		return 1;
 	}
+#if defined(CONFIG_RSBAC_CAP_LOG_MISSING) || defined(CONFIG_RSBAC_JAIL_LOG_MISSING)
+	else
+		rsbac_log_missing_cap(cap);
+#endif
 	return 0;
 }
 
diff -urN -x rsbac trunk/init/main.c linux-2.4.32-rsbac-1.2.7/init/main.c
--- trunk/init/main.c	2006-06-01 10:30:50.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/init/main.c	2006-06-01 10:32:26.000000000 +0200
@@ -41,6 +41,12 @@
 #include <linux/acpi.h>
 #endif
 
+/* RSBAC: including rsbac_init declaration */
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#include <rsbac/debug.h>
+#endif
+
 #ifdef CONFIG_PCI
 #include <linux/pci.h>
 #endif
@@ -275,6 +281,11 @@
 		if (checksetup(line))
 			continue;
 		
+#ifdef CONFIG_RSBAC
+		if(rsbac_parse_koptions(line))
+		  continue;
+#endif /* CONFIG_RSBAC */
+
 		/*
 		 * Then check if it's an environment variable or
 		 * an option.
@@ -420,6 +431,9 @@
   
 	fork_init(num_mappedpages);
 	proc_caches_init();
+#ifdef CONFIG_RSBAC
+	rsbac_kthreads_init();
+#endif
 	vfs_caches_init(num_physpages);
 	buffer_init(num_physpages);
 	page_cache_init(num_physpages);
@@ -567,6 +581,31 @@
 
 	prepare_namespace();
 
+#ifdef CONFIG_RSBAC
+        /* RSBAC: OK, most stuff initialized and root mounted: Init RSBAC. */
+#ifdef CONFIG_BLK_DEV_INITRD
+#ifdef CONFIG_RSBAC_INIT_DELAY
+        if(rsbac_no_delay_init)
+#endif
+        rsbac_init(real_root_dev);
+          {
+            struct super_block * sb_p = get_super(MKDEV(RAMDISK_MAJOR,0));
+
+            if(sb_p)
+              {
+                rsbac_mount(sb_p,NULL);
+                drop_super(sb_p);
+              }
+          }
+#else
+#ifdef CONFIG_RSBAC_INIT_DELAY
+        if(rsbac_no_delay_init)
+#endif
+        rsbac_init(ROOT_DEV);
+#endif
+
+#endif
+
 	/*
 	 * Ok, we have completed the initial bootup, and
 	 * we're essentially up and running. Get rid of the
diff -urN -x rsbac trunk/ipc/msg.c linux-2.4.32-rsbac-1.2.7/ipc/msg.c
--- trunk/ipc/msg.c	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/ipc/msg.c	2006-06-01 10:32:36.000000000 +0200
@@ -25,6 +25,11 @@
 #include <asm/uaccess.h>
 #include "util.h"
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /* sysctl: */
 int msg_ctlmax = MSGMAX;
 int msg_ctlmnb = MSGMNB;
@@ -119,9 +124,36 @@
 	int id;
 	struct msg_queue *msq;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	msq  = (struct msg_queue *) kmalloc (sizeof (*msq), GFP_KERNEL);
 	if (!msq) 
 		return -ENOMEM;
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "newque() [sys_msgget()]: calling ADF\n");
+#endif
+        rsbac_target_id.ipc.type = I_msg;
+        rsbac_target_id.ipc.id.id_nr = 0;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            kfree(msq);
+            return -EPERM;
+          }
+        #endif
+
 	id = ipc_addid(&msg_ids, &msq->q_perm, msg_ctlmni);
 	if(id == -1) {
 		kfree(msq);
@@ -138,6 +170,25 @@
 	INIT_LIST_HEAD(&msq->q_messages);
 	INIT_LIST_HEAD(&msq->q_receivers);
 	INIT_LIST_HEAD(&msq->q_senders);
+
+        /* RSBAC: notify ADF of new message queue */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.ipc.id.id_nr = id;
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "newque() [sys_msgget()]: rsbac_adf_set_attr() returned error");
+          }
+        #endif
+
 	msg_unlock(id);
 
 	return msg_buildid(id,msq->q_perm.seq);
@@ -427,6 +478,13 @@
 	struct msq_setbuf setbuf;
 	struct kern_ipc_perm *ipcp;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (msqid < 0 || cmd < 0)
 		return -EINVAL;
 
@@ -541,6 +599,68 @@
 	{
 		if (setbuf.qbytes > msg_ctlmnb && !capable(CAP_SYS_RESOURCE))
 			goto out_unlock_up;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.ipc.type = I_msg;
+                rsbac_target_id.ipc.id.id_nr = msqid;
+                if (ipcp->uid != setbuf.uid)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_msgctl(): calling ADF\n");
+#endif
+                    rsbac_attribute_value.owner = setbuf.uid;
+                    if (!rsbac_adf_request(R_CHANGE_OWNER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_owner,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                if (ipcp->gid != setbuf.gid)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_msgctl(): calling ADF\n");
+#endif
+                    rsbac_attribute_value.group = setbuf.gid;
+                    if (!rsbac_adf_request(R_CHANGE_GROUP,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_group,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                if (ipcp->mode != ((ipcp->mode & ~S_IRWXUGO) | 
+                                  (S_IRWXUGO & setbuf.mode)) )
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_msgctl(): calling ADF\n");
+#endif
+                    rsbac_attribute_value.mode = (S_IRWXUGO & setbuf.mode);
+                    if (!rsbac_adf_request(R_ALTER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_mode,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                #endif
+
 		msq->q_qbytes = setbuf.qbytes;
 
 		ipcp->uid = setbuf.uid;
@@ -560,7 +680,46 @@
 		break;
 	}
 	case IPC_RMID:
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.ipc.type = I_msg;
+                rsbac_target_id.ipc.id.id_nr = msqid;
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_msgctl(): calling ADF\n");
+#endif
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_DELETE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    goto out_up;
+                  }
+                #endif
+
 		freeque (msqid); 
+
+                /* RSBAC: notify ADF of deleted message queue */
+                #ifdef CONFIG_RSBAC
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_DELETE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "sys_msgctl(): rsbac_adf_set_attr() returned error");
+                  }
+                #endif
+
 		break;
 	}
 	err = 0;
@@ -630,6 +789,13 @@
 	long mtype;
 	int err;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+	
 	if (msgsz > msg_ctlmax || (long) msgsz < 0 || msqid < 0)
 		return -EINVAL;
 	if (get_user(mtype, &msgp->mtype))
@@ -637,6 +803,25 @@
 	if (mtype < 1)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "real_msgsnd() [sys_msgsnd()]: calling ADF\n");
+#endif
+        rsbac_target_id.ipc.type   = I_msg;
+        rsbac_target_id.ipc.id.id_nr  = msqid;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_APPEND_OPEN,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	msg = load_msg(msgp->mtext, msgsz);
 	if(IS_ERR(msg))
 		return PTR_ERR(msg);
@@ -644,6 +829,23 @@
 	msg->m_type = mtype;
 	msg->m_ts = msgsz;
 
+        /* RSBAC: notify ADF of opened ipc */
+        #ifdef CONFIG_RSBAC
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_APPEND_OPEN,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_msgsnd(): rsbac_adf_set_attr() returned error");
+          }
+        #endif
+
 	msq = msg_lock(msqid);
 	err=-EINVAL;
 	if(msq==NULL)
@@ -701,6 +903,32 @@
 out_unlock_free:
 	msg_unlock(msqid);
 out_free:
+        /* RSBAC: notify ADF of closed ipc and set attributes */
+        #ifdef CONFIG_RSBAC
+        if (!rsbac_adf_request(R_CLOSE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_msgsnd(): rsbac_adf_request() for CLOSE returned NOT_GRANTED");
+          }
+        if (rsbac_adf_set_attr(R_CLOSE,
+                                current->pid,
+                                T_IPC,
+                                rsbac_target_id,
+                                T_NONE,
+                                rsbac_new_target_id,
+                                A_none,
+                                rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_msgsnd(): rsbac_adf_set_attr() for CLOSE returned error");
+          }
+        #endif
+
 	if(msg!=NULL)
 		free_msg(msg);
 	return err;
@@ -735,10 +963,37 @@
 	int err;
 	int mode;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (msqid < 0 || (long) msgsz < 0)
 		return -EINVAL;
 	mode = convert_mode(&msgtyp,msgflg);
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_msgrcv(): calling ADF\n");
+#endif
+        rsbac_target_id.ipc.type   = I_msg;
+        rsbac_target_id.ipc.id.id_nr  = msqid;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_READ_OPEN,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	msq = msg_lock(msqid);
 	if(msq==NULL)
 		return -EINVAL;
@@ -773,6 +1028,23 @@
 			err=-E2BIG;
 			goto out_unlock;
 		}
+                /* RSBAC: notify ADF of opened ipc */
+                #ifdef CONFIG_RSBAC
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_READ_OPEN,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "sys_msgrcv(): rsbac_adf_set_attr() returned error");
+                  }
+                #endif
+
 		list_del(&msg->m_list);
 		msq->q_qnum--;
 		msq->q_rtime = CURRENT_TIME;
@@ -789,6 +1061,33 @@
 			    msgsz = -EFAULT;
 		}
 		free_msg(msg);
+
+                /* RSBAC: notify ADF of closed ipc */
+                #ifdef CONFIG_RSBAC
+                if (!rsbac_adf_request(R_CLOSE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "sys_msgrcv(): rsbac_adf_request() for CLOSE returned NOT_GRANTED");
+                  }
+                if (rsbac_adf_set_attr(R_CLOSE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "sys_msgrcv(): rsbac_adf_set_attr() for CLOSE returned error");
+                  }
+                #endif
+
 		return msgsz;
 	} else
 	{
diff -urN -x rsbac trunk/ipc/sem.c linux-2.4.32-rsbac-1.2.7/ipc/sem.c
--- trunk/ipc/sem.c	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/ipc/sem.c	2006-06-01 10:32:36.000000000 +0200
@@ -66,6 +66,10 @@
 #include <asm/uaccess.h>
 #include "util.h"
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_IPC_SEM
+#include <rsbac/adf.h>
+#endif
 
 #define sem_lock(id)	((struct sem_array*)ipc_lock(&sem_ids,id))
 #define sem_unlock(id)	ipc_unlock(&sem_ids,id)
@@ -118,6 +122,13 @@
 	struct sem_array *sma;
 	int size;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_IPC_SEM
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!nsems)
 		return -EINVAL;
 	if (used_sems + nsems > sc_semmns)
@@ -129,6 +140,27 @@
 		return -ENOMEM;
 	}
 	memset (sma, 0, size);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_IPC_SEM
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "newary() [sys_semget()]: calling ADF\n");
+#endif
+        rsbac_target_id.ipc.type = I_sem;
+        rsbac_target_id.ipc.id.id_nr = 0;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            ipc_free(sma, size);
+            return -EPERM;
+          }
+        #endif
+
 	id = ipc_addid(&sem_ids, &sma->sem_perm, sc_semmni);
 	if(id == -1) {
 		ipc_free(sma, size);
@@ -145,6 +177,25 @@
 	/* sma->undo = NULL; */
 	sma->sem_nsems = nsems;
 	sma->sem_ctime = CURRENT_TIME;
+
+        /* RSBAC: notify ADF of new shm */
+        #ifdef CONFIG_RSBAC_IPC_SEM
+        rsbac_target_id.ipc.id.id_nr = id;
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CREATE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "newary() [sys_semget()]: rsbac_adf_set_attr() returned error");
+          }
+        #endif
+
 	sem_unlock(id);
 
 	return sem_buildid(id, sma->sem_perm.seq);
@@ -517,6 +568,13 @@
 	ushort* sem_io = fast_sem_io;
 	int nsems;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_IPC_SEM
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	sma = sem_lock(semid);
 	if(sma==NULL)
 		return -EINVAL;
@@ -547,12 +605,51 @@
 				goto out_free;
 		}
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_target_id.ipc.type = I_sem;
+                rsbac_target_id.ipc.id.id_nr = semid;
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "semctl_main() [sys_semctl()]: calling ADF\n");
+#endif
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_READ,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    sem_unlock(semid);
+                    goto out_free;
+                  }
+                #endif
+
 		for (i = 0; i < sma->sem_nsems; i++)
 			sem_io[i] = sma->sem_base[i].semval;
 		sem_unlock(semid);
 		err = 0;
 		if(copy_to_user(array, sem_io, nsems*sizeof(ushort)))
 			err = -EFAULT;
+
+                /* RSBAC: notify ADF of read sem */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_READ,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "semctl_main() [sys_semctl()]: rsbac_adf_set_attr() returned error");
+                  }
+                #endif
+
 		goto out_free;
 	}
 	case SETALL:
@@ -583,12 +680,50 @@
 		if(err)
 			goto out_free;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_target_id.ipc.type = I_sem;
+                rsbac_target_id.ipc.id.id_nr = semid;
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "semctl_main() [sys_semctl()]: calling ADF\n");
+#endif
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_WRITE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    goto out_free;
+                  }
+                #endif
+
 		for (i = 0; i < nsems; i++)
 			sma->sem_base[i].semval = sem_io[i];
 		for (un = sma->undo; un; un = un->id_next)
 			for (i = 0; i < nsems; i++)
 				un->semadj[i] = 0;
 		sma->sem_ctime = CURRENT_TIME;
+
+                /* RSBAC: notify ADF of written sem */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_WRITE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "semctl_main() [sys_semctl()]: rsbac_adf_set_attr() returned error");
+                  }
+                #endif
+
 		/* maybe some queued-up processes were waiting for this */
 		update_queue(sma);
 		err = 0;
@@ -636,6 +771,26 @@
 		if (val > SEMVMX || val < 0)
 			goto out_unlock;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_target_id.ipc.type = I_sem;
+                rsbac_target_id.ipc.id.id_nr = semid;
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "semctl_main() [sys_semctl()]: calling ADF\n");
+#endif
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_WRITE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    goto out_free;
+                  }
+                #endif
+
 		for (un = sma->undo; un; un = un->id_next)
 			un->semadj[semnum] = 0;
 		curr->semval = val;
@@ -702,6 +857,13 @@
 	struct sem_setbuf setbuf;
 	struct kern_ipc_perm *ipcp;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_IPC_SEM
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if(cmd == IPC_SET) {
 		if(copy_semid_from_user (&setbuf, arg.buf, version))
 			return -EFAULT;
@@ -724,10 +886,109 @@
 
 	switch(cmd){
 	case IPC_RMID:
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_target_id.ipc.type = I_sem;
+                rsbac_target_id.ipc.id.id_nr = semid;
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "semctl_down() [sys_semctl()]: calling ADF\n");
+#endif
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_DELETE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    goto out_unlock;
+                  }
+                #endif
+
 		freeary(semid);
+
+                /* RSBAC: notify ADF of deleted sem */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_DELETE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "semctl_down() [sys_semctl()]: rsbac_adf_set_attr() returned error");
+                  }
+                #endif
+
 		err = 0;
 		break;
 	case IPC_SET:
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_IPC_SEM
+                rsbac_target_id.ipc.type = I_sem;
+                rsbac_target_id.ipc.id.id_nr = semid;
+                if (ipcp->uid != setbuf.uid)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_shmctl(): calling ADF\n");
+#endif
+                    rsbac_attribute_value.owner = setbuf.uid;
+                    if (!rsbac_adf_request(R_CHANGE_OWNER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_owner,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock;
+                      }
+                  }
+                if (ipcp->gid != setbuf.gid)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_shmctl(): calling ADF\n");
+#endif
+                    rsbac_attribute_value.group = setbuf.gid;
+                    if (!rsbac_adf_request(R_CHANGE_GROUP,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_group,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock;
+                      }
+                  }
+                if (ipcp->mode != ((ipcp->mode & ~S_IRWXUGO) | 
+                                           (S_IRWXUGO & setbuf.mode)) )
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_shmctl(): calling ADF\n");
+#endif
+                    rsbac_attribute_value.mode = (S_IRWXUGO & setbuf.mode);
+                    if (!rsbac_adf_request(R_ALTER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_mode,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock;
+                      }
+                  }
+                #endif
+
 		ipcp->uid = setbuf.uid;
 		ipcp->gid = setbuf.gid;
 		ipcp->mode = (ipcp->mode & ~S_IRWXUGO)
diff -urN -x rsbac trunk/ipc/shm.c linux-2.4.32-rsbac-1.2.7/ipc/shm.c
--- trunk/ipc/shm.c	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/ipc/shm.c	2006-06-01 10:32:36.000000000 +0200
@@ -26,6 +26,12 @@
 
 #include "util.h"
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#include <rsbac/aci.h>
+#endif
+
 struct shmid_kernel /* private to the kernel */
 {	
 	struct kern_ipc_perm	shm_perm;
@@ -122,9 +128,26 @@
  */
 static void shm_destroy (struct shmid_kernel *shp)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        #endif
+
 	shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid (shp->id);
 	shm_unlock(shp->id);
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "shm_destroy: calling ACI remove_target()\n");
+#endif
+        rsbac_target_id.ipc.type   = I_shm;
+        rsbac_target_id.ipc.id.id_nr  = shp->id;
+        rsbac_remove_target(T_IPC, rsbac_target_id);
+        #endif
+
 	shmem_lock(shp->shm_file, 0);
 	fput (shp->shm_file);
 	kfree (shp);
@@ -142,6 +165,32 @@
 	int id = file->f_dentry->d_inode->i_ino;
 	struct shmid_kernel *shp;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "shm_close() [sys_shmdt() et al.]: calling ADF\n");
+#endif
+        rsbac_target_id.ipc.type   = I_shm;
+        rsbac_target_id.ipc.id.id_nr  = id;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_CLOSE,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "shm_close() [sys_shmdt() et al.]: rsbac_adf_request() for CLOSE returned NOT_GRANTED\n");
+          }
+        #endif
+
 	down (&shm_ids.sem);
 	/* remove from the list of attaches of the shm segment */
 	if(!(shp = shm_lock(id)))
@@ -231,14 +280,109 @@
 	struct shmid_kernel *shp;
 	int err, id = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	down(&shm_ids.sem);
 	if (key == IPC_PRIVATE) {
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_shmget(): calling ADF\n");
+#endif
+                rsbac_target_id.ipc.type = I_shm;
+                rsbac_target_id.ipc.id.id_nr = 0;
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_CREATE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                  }
+                else
+                #endif
+
 		err = newseg(key, shmflg, size);
+
+                /* RSBAC: notify ADF of new shared memory */
+                #ifdef CONFIG_RSBAC
+                if(err>=0)
+                  {
+                    rsbac_target_id.ipc.id.id_nr = err;
+                    rsbac_new_target_id.ipc.type = I_shm;
+                    rsbac_new_target_id.ipc.id.id_nr = err;
+                    if (rsbac_adf_set_attr(R_CREATE,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           T_IPC,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "sys_shmget(): rsbac_adf_set_attr() returned error");
+                      }
+                  }
+                #endif
+
 	} else if ((id = ipc_findkey(&shm_ids, key)) == -1) {
 		if (!(shmflg & IPC_CREAT))
 			err = -ENOENT;
 		else
+                  /* RSBAC */
+                  #ifdef CONFIG_RSBAC
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_shmget(): calling ADF\n");
+#endif
+                    rsbac_target_id.ipc.type = I_shm;
+                    rsbac_target_id.ipc.id.id_nr = 0;
+                    rsbac_attribute_value.dummy = 0;
+                    if (!rsbac_adf_request(R_CREATE,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                      }
+                    else
+                      {
+                  #endif
 			err = newseg(key, shmflg, size);
+                  #ifdef CONFIG_RSBAC
+                        if(err>=0)
+                          {
+                            rsbac_target_id.ipc.id.id_nr = err;
+                            rsbac_new_target_id.ipc.type = I_shm;
+                            rsbac_new_target_id.ipc.id.id_nr = err;
+                            if (rsbac_adf_set_attr(R_CREATE,
+                                                   current->pid,
+                                                   T_IPC,
+                                                   rsbac_target_id,
+                                                   T_IPC,
+                                                   rsbac_new_target_id,
+                                                   A_none,
+                                                   rsbac_attribute_value))
+                              {
+                                rsbac_printk(KERN_WARNING
+                                       "sys_shmget(): rsbac_adf_set_attr() returned error");
+                              }
+                          }
+                      }
+                  }
+                  #endif
 	} else if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL)) {
 		err = -EEXIST;
 	} else {
@@ -378,6 +522,13 @@
 	struct shmid_kernel *shp;
 	int err, version;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (cmd < 0 || shmid < 0)
 		return -EINVAL;
 
@@ -509,13 +660,51 @@
 			err=-EPERM;
 			goto out_unlock_up;
 		}
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.ipc.type = I_shm;
+                rsbac_target_id.ipc.id.id_nr = shmid;
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_shmctl(): calling ADF\n");
+#endif
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_DELETE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    err = -EPERM;
+                    goto out_unlock_up;
+                  }
+                #endif
+
 		if (shp->shm_nattch){
 			shp->shm_flags |= SHM_DEST;
 			/* Do not find it any more */
 			shp->shm_perm.key = IPC_PRIVATE;
 			shm_unlock(shmid);
-		} else
+		} else {
 			shm_destroy (shp);
+
+                /* RSBAC: notify ADF of deleted shm */
+                #ifdef CONFIG_RSBAC
+                rsbac_new_target_id.dummy = 0;
+                if (rsbac_adf_set_attr(R_DELETE,
+                                       current->pid,
+                                       T_IPC,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "sys_shmctl(): rsbac_adf_set_attr() returned error");
+                  }
+                #endif
+		}
 		up(&shm_ids.sem);
 		return err;
 	}
@@ -539,6 +728,67 @@
 			goto out_unlock_up;
 		}
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                rsbac_target_id.ipc.type = I_shm;
+                rsbac_target_id.ipc.id.id_nr = shmid;
+                if (shp->shm_perm.uid != setbuf.uid)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_shmctl(): calling ADF\n");
+#endif
+                    rsbac_attribute_value.owner = setbuf.uid;
+                    if (!rsbac_adf_request(R_CHANGE_OWNER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_owner,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                if (shp->shm_perm.gid != setbuf.gid)
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_shmctl(): calling ADF\n");
+#endif
+                    rsbac_attribute_value.group = setbuf.gid;
+                    if (!rsbac_adf_request(R_CHANGE_GROUP,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_group,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                if (shp->shm_perm.mode != ((shp->shm_perm.mode & ~S_IRWXUGO) | 
+                                           (S_IRWXUGO & setbuf.mode)) )
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG "sys_shmctl(): calling ADF\n");
+#endif
+                    rsbac_attribute_value.mode = (S_IRWXUGO & setbuf.mode);
+                    if (!rsbac_adf_request(R_ALTER,
+                                           current->pid,
+                                           T_IPC,
+                                           rsbac_target_id,
+                                           A_mode,
+                                           rsbac_attribute_value))
+                      {
+                        err = -EPERM;
+                        goto out_unlock_up;
+                      }
+                  }
+                #endif
+
 		shp->shm_perm.uid = setbuf.uid;
 		shp->shm_perm.gid = setbuf.gid;
 		shp->shm_flags = (shp->shm_flags & ~S_IRWXUGO)
@@ -578,6 +828,14 @@
 	int acc_mode;
 	void *user_addr;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (shmid < 0)
 		return -EINVAL;
 
@@ -622,6 +880,31 @@
 		shm_unlock(shmid);
 		return -EACCES;
 	}
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_shmat(): calling ADF\n");
+#endif
+        if ((shmflg & SHM_RDONLY))
+          rsbac_request = R_READ_OPEN;
+        else
+          rsbac_request = R_READ_WRITE_OPEN;
+        rsbac_target_id.ipc.type   = I_shm;
+        rsbac_target_id.ipc.id.id_nr  = shmid;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(rsbac_request,
+                               current->pid,
+                               T_IPC,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            shm_unlock(shmid);
+            return -EPERM;
+          }
+        #endif
+
 	file = shp->shm_file;
 	size = file->f_dentry->d_inode->i_size;
 	shp->shm_nattch++;
@@ -661,6 +944,27 @@
 	err = 0;
 	if (IS_ERR(user_addr))
 		err = PTR_ERR(user_addr);
+
+        /* RSBAC: notify ADF of attached shm */
+        #ifdef CONFIG_RSBAC
+        if(!err)
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(rsbac_request,
+                                   current->pid,
+                                   T_IPC,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_shmat(): rsbac_adf_set_attr() returned error");
+              }
+          }
+        #endif
+
 	return err;
 
 }
diff -urN -x rsbac trunk/kernel/capability.c linux-2.4.32-rsbac-1.2.7/kernel/capability.c
--- trunk/kernel/capability.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/capability.c	2006-06-01 10:32:05.000000000 +0200
@@ -8,6 +8,11 @@
 #include <linux/mm.h>
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 kernel_cap_t cap_bset = CAP_INIT_EFF_SET;
 
 /* Note: never hold tasklist_lock while spinning for this one */
@@ -26,6 +31,12 @@
      struct task_struct *target;
      struct __user_cap_data_struct data;
 
+     /* RSBAC */
+     #ifdef CONFIG_RSBAC
+     union rsbac_target_id_t       rsbac_target_id;
+     union rsbac_attribute_value_t rsbac_attribute_value;
+     #endif
+
      if (get_user(version, &header->version))
 	     return -EFAULT;
 	     
@@ -45,6 +56,25 @@
 
      error = 0;
 
+     /* RSBAC */
+#ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+		  if (rsbac_debug_aef)
+			  rsbac_printk(KERN_DEBUG "sys_capget(): calling ADF\n");
+#endif
+		  rsbac_target_id.process = pid;
+		  rsbac_attribute_value.dummy = 0;
+		  if(!rsbac_adf_request(R_GET_STATUS_DATA,
+					  current->pid,
+					  T_PROCESS,
+					  rsbac_target_id,
+					  A_none,
+					  rsbac_attribute_value))
+		  {
+			  error = -EPERM;
+		  }
+#endif
+     
      spin_lock(&task_capability_lock);
 
      if (pid && pid != current->pid) {
@@ -133,6 +163,12 @@
      struct task_struct *target;
      int error, pid;
 
+     /* RSBAC */
+     #ifdef CONFIG_RSBAC
+     union rsbac_target_id_t       rsbac_target_id;
+     union rsbac_attribute_value_t rsbac_attribute_value;
+     #endif
+
      if (get_user(version, &header->version))
 	     return -EFAULT; 
 
@@ -154,6 +190,25 @@
 	 copy_from_user(&permitted, &data->permitted, sizeof(permitted)))
 	     return -EFAULT; 
 
+     /* RSBAC */
+     #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+     if (rsbac_debug_aef)
+       rsbac_printk(KERN_DEBUG "sys_capset(): calling ADF\n");
+#endif
+     rsbac_target_id.scd = ST_capability;
+     rsbac_attribute_value.dummy = 0;
+     if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                           current->pid,
+                           T_SCD,
+                           rsbac_target_id,
+                           A_none,
+                           rsbac_attribute_value))
+       {
+         return -EPERM;
+       }
+     #endif
+
      error = -EPERM;
      spin_lock(&task_capability_lock);
 
diff -urN -x rsbac trunk/kernel/exit.c linux-2.4.32-rsbac-1.2.7/kernel/exit.c
--- trunk/kernel/exit.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/exit.c	2006-06-01 10:32:05.000000000 +0200
@@ -21,6 +21,11 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 extern void sem_exit (void);
 extern struct task_struct *child_reaper;
 
@@ -426,6 +431,12 @@
 {
 	struct task_struct *tsk = current;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (in_interrupt())
 		panic("Aiee, killing interrupt handler!");
 	if (!tsk->pid)
@@ -435,6 +446,28 @@
 	tsk->flags |= PF_EXITING;
 	del_timer_sync(&tsk->real_timer);
 
+        /* RSBAC: notifying ADF */
+        #ifdef CONFIG_RSBAC
+        if (current->pid)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "do_exit() [sys_exit()]: calling ADF\n");
+#endif
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_TERMINATE,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING "do_exit() [sys_exit()]: ADF request for TERMINATE returned error!\n");
+              }
+          }
+        #endif
+
 fake_volatile:
 #ifdef CONFIG_BSD_PROCESS_ACCT
 	acct_process(code);
diff -urN -x rsbac trunk/kernel/fork.c linux-2.4.32-rsbac-1.2.7/kernel/fork.c
--- trunk/kernel/fork.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/fork.c	2006-06-01 10:32:05.000000000 +0200
@@ -29,6 +29,12 @@
 #include <asm/mmu_context.h>
 #include <asm/processor.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#include <rsbac/aci.h>
+#endif
+
 /* The idle threads do not count.. */
 int nr_threads;
 int nr_running;
@@ -632,6 +638,12 @@
 	/* never reached in child process, only in parent */
 	current->task_dumpable = old_task_dumpable;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(ret > 0)
+          rsbac_kthread_notify(ret);
+        #endif
+
 	return ret;
 }
 
@@ -651,6 +663,14 @@
 	struct task_struct *p;
 	struct completion vfork;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+	enum  rsbac_attribute_t       rsbac_attribute;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
 		return -EINVAL;
 
@@ -665,6 +685,29 @@
 			goto fork_out;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+	rsbac_attribute = A_none;
+	rsbac_attribute_value.dummy = 0;
+        if(current->pid)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "do_fork() [sys_fork(),sys_clone(),sys_vfork]: calling ADF\n");
+#endif
+            rsbac_target_id.process = current->pid;
+            if (!rsbac_adf_request(R_CLONE,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   rsbac_attribute,
+                                   rsbac_attribute_value))
+              {
+                return -EPERM;
+              }
+          }
+        #endif
+
 	retval = -ENOMEM;
 	p = alloc_task_struct();
 	if (!p)
@@ -823,6 +866,36 @@
 	if (p->ptrace & PT_PTRACED)
 		send_sig(SIGSTOP, p, 1);
 
+        /* RSBAC: notify ADF of forked process */
+        #ifdef CONFIG_RSBAC
+	if (clone_flags & CLONE_KTHREAD) {
+		rsbac_attribute = A_kernel_thread;
+		rsbac_attribute_value.kernel_thread = 1;
+		rsbac_mark_kthread(p->pid);
+		rsbac_kthread_notify(p->pid);
+	}
+        if(current->pid)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "do_fork() [sys_fork(),sys_clone(),sys_vfork()]: calling ADF_set_attr\n");
+#endif
+            rsbac_new_target_id.process = p->pid;
+            if (rsbac_adf_set_attr(R_CLONE,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_PROCESS,
+                                   rsbac_new_target_id,
+                                   rsbac_attribute,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "do_fork() [sys_fork(), sys_clone()]: rsbac_adf_set_attr() returned error!\n");
+              }
+          }
+        #endif
+
 	wake_up_process(p);		/* do this last */
 	++total_forks;
 	if (clone_flags & CLONE_VFORK)
diff -urN -x rsbac trunk/kernel/kmod.c linux-2.4.32-rsbac-1.2.7/kernel/kmod.c
--- trunk/kernel/kmod.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/kmod.c	2006-06-01 10:32:05.000000000 +0200
@@ -30,6 +30,10 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_RSBAC
+#include <rsbac/aci.h>
+#endif
+
 extern int max_threads;
 
 static inline void
@@ -304,6 +308,9 @@
 	 * We need the data structures to stay around until that is done.
 	 */
 	pid = kernel_thread(____call_usermodehelper, sub_info, CLONE_VFORK | SIGCHLD);
+#ifdef CONFIG_RSBAC
+	rsbac_kthread_notify(pid);
+#endif		
 	if (pid < 0)
 		sub_info->retval = pid;
 	complete(sub_info->complete);
diff -urN -x rsbac trunk/kernel/module.c linux-2.4.32-rsbac-1.2.7/kernel/module.c
--- trunk/kernel/module.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/module.c	2006-06-01 10:32:05.000000000 +0200
@@ -11,6 +11,11 @@
 #include <linux/kmod.h>
 #include <linux/seq_file.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Originally by Anonymous (as far as I know...)
  * Linux version by Bas Laarhoven <bas@vimec.nl>
@@ -296,6 +301,12 @@
 	struct module *mod;
 	unsigned long flags;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_MODULE))
 		return -EPERM;
 	lock_kernel();
@@ -311,6 +322,26 @@
 		error = -EEXIST;
 		goto err1;
 	}
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_create_module(): calling ADF\n");
+#endif
+        rsbac_target_id.dummy = 0;
+        rsbac_attribute_value.mod_name = name;
+        if (!rsbac_adf_request(R_ADD_TO_KERNEL,
+                               current->pid,
+                               T_NONE,
+                               rsbac_target_id,
+                               A_mod_name,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto err1;
+          }
+        #endif
+
 	if ((mod = (struct module *)module_map(size)) == NULL) {
 		error = -ENOMEM;
 		goto err1;
@@ -351,6 +382,12 @@
 	unsigned long mod_user_size, flags;
 	struct module_ref *dep;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_MODULE))
 		return -EPERM;
 	lock_kernel();
@@ -501,6 +538,25 @@
 		goto err3;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_init_module(): calling ADF\n");
+#endif
+        rsbac_target_id.dummy = 0;
+        rsbac_attribute_value.mod_name = n_name;
+        if (!rsbac_adf_request(R_ADD_TO_KERNEL,
+                               current->pid,
+                               T_NONE,
+                               rsbac_target_id,
+                               A_mod_name,
+                               rsbac_attribute_value))
+          {
+            error = -EPERM;
+            goto err3;
+          }
+        #endif
+
 	/* Ok, that's about all the sanity we can stomach; copy the rest.  */
 
 	if (copy_from_user((char *)mod+mod_user_size,
@@ -612,6 +668,12 @@
 	long error;
 	int something_changed;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_MODULE))
 		return -EPERM;
 
@@ -624,6 +686,26 @@
 			put_mod_name(name);
 			goto out;
 		}
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_delete_module(): calling ADF\n");
+#endif
+                rsbac_target_id.dummy = 0;
+                rsbac_attribute_value.mod_name = name;
+                if (!rsbac_adf_request(R_REMOVE_FROM_KERNEL,
+                                       current->pid,
+                                       T_NONE,
+                                       rsbac_target_id,
+                                       A_mod_name,
+                                       rsbac_attribute_value))
+                  {
+                    error = -EPERM;
+                    put_mod_name(name);
+                    goto out;
+                  }
+                #endif
+
 		put_mod_name(name);
 		error = -EBUSY;
 		if (mod->refs != NULL)
@@ -900,6 +982,12 @@
 	struct module *mod;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	lock_kernel();
 	if (name_user == NULL)
 		mod = &kernel_module;
@@ -919,6 +1007,26 @@
 		put_mod_name(name);
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.scd = ST_ksyms;
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_query_module: calling ADF\n");
+#endif
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            err = -EPERM;
+            goto out;
+          }
+        #endif
+
 	/* __MOD_ touches the flags. We must avoid that */
 	
 	atomic_inc(&mod->uc.usecount);
@@ -969,6 +1077,31 @@
 	int i;
 	struct kernel_sym ksym;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.scd = ST_kmem;
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_get_kernel_syms(): calling ADF\n");
+#endif
+        if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	lock_kernel();
 	for (mod = module_list, i = 0; mod; mod = mod->next) {
 		/* include the count for the module name! */
diff -urN -x rsbac trunk/kernel/printk.c linux-2.4.32-rsbac-1.2.7/kernel/printk.c
--- trunk/kernel/printk.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/printk.c	2006-06-01 10:32:05.000000000 +0200
@@ -27,6 +27,11 @@
 #include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/config.h>
 
+/* RSBAC - for sys_syslog only */
+#ifdef CONFIG_RSBAC_SYSLOG
+#include <rsbac/adf.h>
+#endif
+
 #include <asm/uaccess.h>
 
 #if !defined(CONFIG_LOG_BUF_SHIFT) || (CONFIG_LOG_BUF_SHIFT == 0)
@@ -177,6 +182,57 @@
 	char c;
 	int error = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SYSLOG
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_SYSLOG
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_syslog() [sys_syslog()]: calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_syslog;
+        rsbac_attribute_value.dummy = 0;
+        switch(type)
+          {
+            case 2:
+            case 3:
+              if(!rsbac_adf_request(R_GET_STATUS_DATA,
+                                    current->pid,
+                                    T_SCD,
+                                    rsbac_target_id,
+                                    A_none,
+                                    rsbac_attribute_value))
+                {
+                  error = -EPERM;
+                  goto out;
+                }
+              break;
+            case 4:
+            case 5:
+            case 6:
+            case 7:
+            case 8:
+              if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                    current->pid,
+                                    T_SCD,
+                                    rsbac_target_id,
+                                    A_none,
+                                    rsbac_attribute_value))
+                {
+                  error = -EPERM;
+                  goto out;
+                }
+              break;
+
+            default:
+              break;
+          }
+        #endif
+
 	switch (type) {
 	case 0:		/* Close log */
 		break;
diff -urN -x rsbac trunk/kernel/sched.c linux-2.4.32-rsbac-1.2.7/kernel/sched.c
--- trunk/kernel/sched.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/sched.c	2006-06-01 10:32:05.000000000 +0200
@@ -30,6 +30,11 @@
 #include <linux/prefetch.h>
 #include <linux/compiler.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 
@@ -906,10 +911,34 @@
 	 *	and we have a single winner.
 	 */
 	if (increment < 0) {
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                union rsbac_target_id_t       rsbac_target_id;
+                union rsbac_attribute_value_t rsbac_attribute_value;
+                #endif
+
 		if (!capable(CAP_SYS_NICE))
 			return -EPERM;
 		if (increment < -40)
 			increment = -40;
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_nice(): calling ADF\n");
+#endif
+                rsbac_target_id.scd = ST_priority;
+                rsbac_attribute_value.priority = current->nice + increment;
+                if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                       current->pid,
+                                       T_SCD,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
 	}
 	if (increment > 40)
 		increment = 40;
@@ -941,6 +970,13 @@
 	struct task_struct *p;
 	int retval;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	retval = -EINVAL;
 	if (!param || pid < 0)
 		goto out_nounlock;
@@ -949,6 +985,35 @@
 	if (copy_from_user(&lp, param, sizeof(struct sched_param)))
 		goto out_nounlock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "setscheduler() [sys_sched_setscheduler, sys_sched_setparam]: calling ADF\n");
+#endif
+        if(!pid || (pid == current->pid))
+          {
+            rsbac_target = T_SCD;
+            rsbac_target_id.scd = ST_priority;
+          }
+        else
+          {
+            rsbac_target = T_PROCESS;
+            rsbac_target_id.process = pid;
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               rsbac_target,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            retval = -EPERM;
+            goto out_nounlock;
+          }
+        #endif
+
 	/*
 	 * We play safe to avoid deadlocks.
 	 */
diff -urN -x rsbac trunk/kernel/signal.c linux-2.4.32-rsbac-1.2.7/kernel/signal.c
--- trunk/kernel/signal.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/signal.c	2006-06-01 10:32:05.000000000 +0200
@@ -16,6 +16,11 @@
 
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /*
  * SLAB caches for signal bits.
  */
@@ -336,11 +341,45 @@
  */
 int bad_signal(int sig, struct siginfo *info, struct task_struct *t)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        enum  rsbac_attribute_t       rsbac_attribute;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "bad_signal() [send_sig_info() [sys_kill etc.]]: calling ADF\n");
+#endif
+        rsbac_target_id.process = t->pid;
+        if(!t->mm)
+          {
+            rsbac_attribute = A_kernel_thread;
+            rsbac_attribute_value.kernel_thread = TRUE;
+          }
+        else
+          {
+            rsbac_attribute = A_signal;
+            rsbac_attribute_value.signal = sig;
+          }
+	#endif
+
 	return (!info || ((unsigned long)info != 1 && SI_FROMUSER(info)))
 	    && ((sig != SIGCONT) || (current->session != t->session))
-	    && (current->euid ^ t->suid) && (current->euid ^ t->uid)
+	    && (   (   (current->euid ^ t->suid) && (current->euid ^ t->uid)
 	    && (current->uid ^ t->suid) && (current->uid ^ t->uid)
-	    && !capable(CAP_KILL);
+	            && !capable(CAP_KILL)
+	           )
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+	        || !rsbac_adf_request(R_SEND_SIGNAL,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              rsbac_attribute,
+                              rsbac_attribute_value)
+                #endif
+	       );
 }
 
 /*
diff -urN -x rsbac trunk/kernel/sys.c linux-2.4.32-rsbac-1.2.7/kernel/sys.c
--- trunk/kernel/sys.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/sys.c	2006-06-01 10:32:05.000000000 +0200
@@ -37,6 +37,12 @@
 # define GET_FPEXC_CTL(a,b)	(-EINVAL)
 #endif
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <linux/slab.h>
+#include <rsbac/adf.h>
+#endif
+
 /*
  * this is where the system-wide overflow UID and GID are defined, for
  * architectures that now have 32-bit UID/GID but didn't in the past
@@ -218,6 +224,13 @@
 	struct task_struct *p;
 	int error;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (which > 2 || which < 0)
 		return -EINVAL;
 
@@ -228,6 +241,45 @@
 	if (niceval > 19)
 		niceval = 19;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(   (niceval < current->nice)
+           || (   (which == PRIO_PROCESS)
+               && (who != 0)
+               && (who != current->pid)
+              )
+           || (   (which == PRIO_PGRP)
+               && (who != 0)
+               && (who != current->pgrp)
+              )
+          )
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_setpriority(): calling ADF\n");
+#endif
+            if(niceval < current->nice)
+              {
+                rsbac_target = T_SCD;
+                rsbac_target_id.scd = ST_priority;
+              }
+            else
+              {
+                rsbac_target = T_PROCESS;
+                rsbac_target_id.process = who;
+              }
+            rsbac_attribute_value.priority = niceval;
+            if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   A_priority,
+                                   rsbac_attribute_value))
+              {
+                return -EPERM;
+              }
+          }
+        #endif
+
 	read_lock(&tasklist_lock);
 	for_each_task(p) {
 		if (!proc_sel(p, which, who))
@@ -290,6 +342,12 @@
 {
 	char buffer[256];
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!capable(CAP_SYS_BOOT))
 		return -EPERM;
@@ -301,6 +359,26 @@
 		return -EINVAL;
 
 	lock_kernel();
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_reboot(): calling ADF\n");
+#endif
+        rsbac_target_id.dummy = 0;
+        rsbac_attribute_value.reboot_cmd = cmd;
+        if (!rsbac_adf_request(R_SHUTDOWN,
+                               current->pid,
+                               T_NONE,
+                               rsbac_target_id,
+                               A_reboot_cmd,
+                               rsbac_attribute_value))
+          {
+            unlock_kernel();
+            return -EPERM;
+          }
+        #endif
+
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
 		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, NULL);
@@ -400,18 +478,71 @@
 	int new_egid = old_egid;
 
 	if (rgid != (gid_t) -1) {
-		if ((old_rgid == rgid) ||
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                union rsbac_target_id_t       rsbac_target_id;
+                union rsbac_attribute_value_t rsbac_attribute_value;
+
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_setregid(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.long_dummy = 0;
+                rsbac_attribute_value.group = rgid;
+                #endif
+
+		if (((old_rgid == rgid) ||
 		    (current->egid==rgid) ||
 		    capable(CAP_SETGID))
+                    /* RSBAC */
+                    #ifdef CONFIG_RSBAC
+                    && rsbac_adf_request(R_CHANGE_GROUP,
+                                         current->pid,
+                                         T_PROCESS,
+                                         rsbac_target_id,
+                                         A_group,
+                                         rsbac_attribute_value)
+                    #endif
+                   )
 			new_rgid = rgid;
 		else
 			return -EPERM;
 	}
 	if (egid != (gid_t) -1) {
-		if ((old_rgid == egid) ||
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_DAC_GROUP
+                union rsbac_target_id_t       rsbac_target_id;
+                union rsbac_attribute_value_t rsbac_attribute_value;
+
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_setregid(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.long_dummy = 0;
+                rsbac_attribute_value.group = egid;
+                #endif
+
+		if (((old_rgid == egid) ||
 		    (current->egid == egid) ||
 		    (current->sgid == egid) ||
 		    capable(CAP_SETGID))
+                    #ifdef CONFIG_RSBAC_DAC_GROUP
+                    && rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+                                         current->pid,
+                                         T_PROCESS,
+                                         rsbac_target_id,
+                                         A_group,
+                                         rsbac_attribute_value)
+                    && rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                                         current->pid,
+                                         T_PROCESS,
+                                         rsbac_target_id,
+                                         A_group,
+                                         rsbac_attribute_value)
+                    #endif
+                   )
 			new_egid = egid;
 		else {
 			return -EPERM;
@@ -440,7 +571,47 @@
 {
 	int old_egid = current->egid;
 
-	if (capable(CAP_SETGID))
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_setgid(): calling ADF\n");
+#endif
+        rsbac_target_id.process = current->pid;
+        rsbac_attribute_value.group = gid;
+        #endif
+
+	if ((capable(CAP_SETGID))
+            /* RSBAC */
+            #ifdef CONFIG_RSBAC
+            && rsbac_adf_request(R_CHANGE_GROUP,
+                                 current->pid,
+                                 T_PROCESS,
+                                 rsbac_target_id,
+                                 A_group,
+                                 rsbac_attribute_value)
+            #ifdef CONFIG_RSBAC_DAC_GROUP
+            && rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+                                 current->pid,
+                                 T_PROCESS,
+                                 rsbac_target_id,
+                                 A_group,
+                                 rsbac_attribute_value)
+            && rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                                 current->pid,
+                                 T_PROCESS,
+                                 rsbac_target_id,
+                                 A_group,
+                                 rsbac_attribute_value)
+            #endif
+            #endif
+           )
 	{
 		if(old_egid != gid)
 		{
@@ -449,7 +620,23 @@
 		}
 		current->gid = current->egid = current->sgid = current->fsgid = gid;
 	}
-	else if ((gid == current->gid) || (gid == current->sgid))
+	else if (((gid == current->gid) || (gid == current->sgid))
+                 /* RSBAC */
+                 #ifdef CONFIG_RSBAC_DAC_GROUP
+                 && rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_group,
+                                      rsbac_attribute_value)
+                 && rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_group,
+                                      rsbac_attribute_value)
+                 #endif
+                )
 	{
 		if(old_egid != gid)
 		{
@@ -546,6 +733,13 @@
 {
 	int old_ruid, old_euid, old_suid, new_ruid, new_euid;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	new_ruid = old_ruid = current->uid;
 	new_euid = old_euid = current->euid;
 	old_suid = current->suid;
@@ -567,6 +761,58 @@
 			return -EPERM;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(ruid != (uid_t) -1)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_setreuid(): calling ADF\n");
+#endif
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.owner = ruid;
+            if(!rsbac_adf_request(R_CHANGE_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        if(euid != (uid_t) -1)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_setreuid(): calling ADF for euid\n");
+#endif
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.owner = euid;
+            if(!rsbac_adf_request(R_CHANGE_DAC_EFF_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+            if(!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+            if(!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+          }
+        #endif
+        #endif
+
 	if (new_ruid != old_ruid && set_user(new_ruid, new_euid != old_euid) < 0)
 		return -EAGAIN;
 
@@ -585,6 +831,59 @@
 		cap_emulate_setxuid(old_ruid, old_euid, old_suid);
 	}
 
+        /* RSBAC: notify ADF of changed process owner */
+        #ifdef CONFIG_RSBAC
+        if(ruid != (uid_t) -1)
+	  {
+	    rsbac_set_audit_uid(old_ruid);
+            rsbac_attribute_value.owner = current->uid;
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_CHANGE_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() returned error");
+              }
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        if(euid != (uid_t) -1)
+	  {
+            rsbac_attribute_value.owner = current->euid;
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_CHANGE_DAC_EFF_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() for euid returned error");
+              }
+            if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() for fsuid returned error");
+              }
+          }
+        #endif
+        #endif
+
 	return 0;
 }
 
@@ -606,6 +905,62 @@
 	int old_euid = current->euid;
 	int old_ruid, old_suid, new_ruid, new_suid;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        if(!uid && rsbac_uid_faked())
+          return 0;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_setuid(): calling ADF\n");
+#endif
+        rsbac_target_id.process = current->pid;
+        rsbac_attribute_value.long_dummy = 0;
+        rsbac_attribute_value.owner = uid;
+        if(!rsbac_adf_request(R_CHANGE_OWNER,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_owner,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_setuid(): calling ADF for euid\n");
+#endif
+        if(!rsbac_adf_request(R_CHANGE_DAC_EFF_OWNER,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_owner,
+                              rsbac_attribute_value))
+           return -EPERM;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_setuid(): calling ADF for fsuid\n");
+#endif
+        if(!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+                              current->pid,
+                              T_PROCESS,
+                              rsbac_target_id,
+                              A_owner,
+                              rsbac_attribute_value))
+           return -EPERM;
+        #endif
+        #endif
+
 	old_ruid = new_ruid = current->uid;
 	old_suid = current->suid;
 	new_suid = old_suid;
@@ -629,6 +984,52 @@
 		cap_emulate_setxuid(old_ruid, old_euid, old_suid);
 	}
 
+        /* RSBAC: notify ADF of changed process owner */
+        #ifdef CONFIG_RSBAC
+        rsbac_set_audit_uid(old_ruid);
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CHANGE_OWNER,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_owner,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_setuid(): rsbac_adf_set_attr() returned error\n");
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CHANGE_DAC_EFF_OWNER,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_owner,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_setuid(): rsbac_adf_set_attr() for euid returned error\n");
+          }
+        rsbac_new_target_id.dummy = 0;
+        if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               T_NONE,
+                               rsbac_new_target_id,
+                               A_owner,
+                               rsbac_attribute_value))
+          {
+            rsbac_printk(KERN_WARNING
+                   "sys_setuid(): rsbac_adf_set_attr() for fsuid returned error\n");
+          }
+        #endif
+        #endif
+
 	return 0;
 }
 
@@ -643,6 +1044,12 @@
 	int old_euid = current->euid;
 	int old_suid = current->suid;
 
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SETUID)) {
 		if ((ruid != (uid_t) -1) && (ruid != current->uid) &&
 		    (ruid != current->euid) && (ruid != current->suid))
@@ -654,6 +1061,58 @@
 		    (suid != current->euid) && (suid != current->suid))
 			return -EPERM;
 	}
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(ruid != (uid_t) -1)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_setresuid(): calling ADF\n");
+#endif
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.long_dummy = 0;
+            rsbac_attribute_value.owner = ruid;
+            if(!rsbac_adf_request(R_CHANGE_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        if(euid != (uid_t) -1)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_setresuid(): calling ADF for euid\n");
+#endif
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.long_dummy = 0;
+            rsbac_attribute_value.owner = euid;
+            if(!rsbac_adf_request(R_CHANGE_DAC_EFF_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_setresuid(): calling ADF for fsuid\n");
+#endif
+            if(!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_owner,
+                                  rsbac_attribute_value))
+              return -EPERM;
+          }
+        #endif
+        #endif
+
 	if (ruid != (uid_t) -1) {
 		if (ruid != current->uid && set_user(ruid, euid != current->euid) < 0)
 			return -EAGAIN;
@@ -674,6 +1133,59 @@
 		cap_emulate_setxuid(old_ruid, old_euid, old_suid);
 	}
 
+        /* RSBAC: notify ADF of changed process owner */
+        #ifdef CONFIG_RSBAC
+        if(ruid != (uid_t) -1)
+	  {
+            rsbac_set_audit_uid(old_ruid);
+            rsbac_new_target_id.dummy = 0;
+            rsbac_attribute_value.owner = current->uid;
+            if (rsbac_adf_set_attr(R_CHANGE_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setresuid(): rsbac_adf_set_attr() returned error");
+              }
+          }
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        if(euid != (uid_t) -1)
+	  {
+            rsbac_new_target_id.dummy = 0;
+            rsbac_attribute_value.owner = current->euid;
+            if (rsbac_adf_set_attr(R_CHANGE_DAC_EFF_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() for euid returned error\n");
+              }
+            if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+                                   current->pid,
+                                   T_PROCESS,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_owner,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_setreuid(): rsbac_adf_set_attr() for fsuid returned error\n");
+              }
+          }
+        #endif
+        #endif
+
 	return 0;
 }
 
@@ -693,6 +1205,12 @@
  */
 asmlinkage long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SETGID)) {
 		if ((rgid != (gid_t) -1) && (rgid != current->gid) &&
 		    (rgid != current->egid) && (rgid != current->sgid))
@@ -704,6 +1222,52 @@
 		    (sgid != current->egid) && (sgid != current->sgid))
 			return -EPERM;
 	}
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(rgid != (gid_t) -1)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_setresgid(): calling ADF\n");
+#endif
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.group = rgid;
+            if(!rsbac_adf_request(R_CHANGE_GROUP,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_group,
+                                  rsbac_attribute_value))
+               return -EPERM;
+          }
+        #ifdef CONFIG_RSBAC_DAC_GROUP
+        if(egid != (gid_t) -1)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              printk(KERN_DEBUG "sys_setresgid(): calling ADF\n");
+#endif
+            rsbac_target_id.process = current->pid;
+            rsbac_attribute_value.group = egid;
+            if(!rsbac_adf_request(R_CHANGE_DAC_EFF_GROUP,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_group,
+                                  rsbac_attribute_value))
+               return -EPERM;
+            if(!rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                                  current->pid,
+                                  T_PROCESS,
+                                  rsbac_target_id,
+                                  A_group,
+                                  rsbac_attribute_value))
+               return -EPERM;
+          }
+        #endif
+        #endif
+
 	if (egid != (gid_t) -1) {
 		if (egid != current->egid)
 		{
@@ -742,17 +1306,59 @@
 {
 	int old_fsuid;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_DAC_OWNER
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	old_fsuid = current->fsuid;
 	if (uid == current->uid || uid == current->euid ||
 	    uid == current->suid || uid == current->fsuid || 
 	    capable(CAP_SETUID))
 	{
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_DAC_OWNER
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  printk(KERN_DEBUG "sys_setfsuid(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.owner = uid;
+                if(!rsbac_adf_request(R_CHANGE_DAC_FS_OWNER,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_owner,
+                                      rsbac_attribute_value))
+                  return -EPERM;
+                #endif
+
 		if (uid != old_fsuid)
 		{
 			current->mm->dumpable = 0;
 			wmb();
 		}
 		current->fsuid = uid;
+
+                /* RSBAC: notify ADF of changed process owner */
+                #ifdef CONFIG_RSBAC_DAC_OWNER
+                rsbac_new_target_id.dummy = 0;
+                rsbac_attribute_value.owner = current->fsuid;
+                if (rsbac_adf_set_attr(R_CHANGE_DAC_FS_OWNER,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       T_NONE,
+                                       rsbac_new_target_id,
+                                       A_owner,
+                                       rsbac_attribute_value))
+                  {
+                    rsbac_printk(KERN_WARNING
+                           "sys_setresuid(): rsbac_adf_set_attr() returned error");
+                  }
+                #endif
 	}
 
 	/* We emulate fsuid by essentially doing a scaled-down version
@@ -784,11 +1390,34 @@
 {
 	int old_fsgid;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_DAC_GROUP
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	old_fsgid = current->fsgid;
 	if (gid == current->gid || gid == current->egid ||
 	    gid == current->sgid || gid == current->fsgid || 
 	    capable(CAP_SETGID))
 	{
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_DAC_GROUP
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_setfsgid(): calling ADF\n");
+#endif
+                rsbac_target_id.process = current->pid;
+                rsbac_attribute_value.group = gid;
+                if(!rsbac_adf_request(R_CHANGE_DAC_FS_GROUP,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_group,
+                                      rsbac_attribute_value))
+                  return -EPERM;
+                #endif
+
 		if (gid != old_fsgid)
 		{
 			current->mm->dumpable = 0;
@@ -831,6 +1460,12 @@
 	struct task_struct * p;
 	int err = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!pid)
 		pid = current->pid;
 	if (!pgid)
@@ -838,6 +1473,25 @@
 	if (pgid < 0)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_setpgid(): calling ADF\n");
+#endif
+        rsbac_target_id.process = pid;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_PROCESS,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	/* From this point forward we keep holding onto the tasklist lock
 	 * so that our parent does not change from under us. -DaveM
 	 */
@@ -887,12 +1541,38 @@
 		int retval;
 		struct task_struct *p;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                union rsbac_target_id_t       rsbac_target_id;
+                union rsbac_attribute_value_t rsbac_attribute_value;
+                #endif
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_getpgid(): calling ADF\n");
+#endif
+                rsbac_target_id.process = pid;
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
+
 		read_lock(&tasklist_lock);
 		p = find_task_by_pid(pid);
 
 		retval = -ESRCH;
 		if (p)
 			retval = p->pgrp;
+
 		read_unlock(&tasklist_lock);
 		return retval;
 	}
@@ -912,12 +1592,38 @@
 		int retval;
 		struct task_struct *p;
 
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+                union rsbac_target_id_t       rsbac_target_id;
+                union rsbac_attribute_value_t rsbac_attribute_value;
+                #endif
+
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_getsid(): calling ADF\n");
+#endif
+                rsbac_target_id.process = pid;
+                rsbac_attribute_value.dummy = 0;
+                if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                       current->pid,
+                                       T_PROCESS,
+                                       rsbac_target_id,
+                                       A_none,
+                                       rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
+
 		read_lock(&tasklist_lock);
 		p = find_task_by_pid(pid);
 
 		retval = -ESRCH;
 		if(p)
 			retval = p->session;
+
 		read_unlock(&tasklist_lock);
 		return retval;
 	}
@@ -975,13 +1681,60 @@
  
 asmlinkage long sys_setgroups(int gidsetsize, gid_t *grouplist)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        int i;
+        gid_t * rsbac_group_list;
+        #endif
+
 	if (!capable(CAP_SETGID))
 		return -EPERM;
 	if ((unsigned) gidsetsize > NGROUPS)
 		return -EINVAL;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(gidsetsize > 0)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_setgroups(): calling ADF\n");
+#endif
+            rsbac_group_list = kmalloc(gidsetsize * sizeof(gid_t), GFP_KERNEL);
+            if(!rsbac_group_list)
+              return -ENOMEM;
+            if(copy_from_user(rsbac_group_list, grouplist, gidsetsize * sizeof(gid_t)))
+              {
+                kfree(rsbac_group_list);
+                return -EFAULT;
+              }
+            rsbac_target_id.process = current->pid;
+            for(i=0; i < gidsetsize; i++)
+              {
+                rsbac_attribute_value.group = rsbac_group_list[i];
+                if(!rsbac_adf_request(R_CHANGE_GROUP,
+                                      current->pid,
+                                      T_PROCESS,
+                                      rsbac_target_id,
+                                      A_group,
+                                      rsbac_attribute_value))
+                  {
+                    kfree(rsbac_group_list);
+                    return -EPERM;
+                  }
+	      }
+	    memcpy(current->groups, rsbac_group_list, gidsetsize * sizeof(gid_t));
+            kfree(rsbac_group_list);
+          }
+        current->ngroups = gidsetsize;
+        #else
 	if(copy_from_user(current->groups, grouplist, gidsetsize * sizeof(gid_t)))
 		return -EFAULT;
 	current->ngroups = gidsetsize;
+        #endif
+
 	return 0;
 }
 
@@ -1038,10 +1791,36 @@
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+	
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_sethostname(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_host_id;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&uts_sem);
 	errno = -EFAULT;
 	if (!copy_from_user(tmp, name, len)) {
@@ -1079,11 +1858,35 @@
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+	
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_setdomainname(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_net_id;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&uts_sem);
 	errno = -EFAULT;
 	if (!copy_from_user(tmp, name, len)) {
@@ -1130,6 +1933,12 @@
 {
 	struct rlimit new_rlim, *old_rlim;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
 	if(copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
@@ -1145,6 +1954,25 @@
 		if (new_rlim.rlim_cur > NR_OPEN || new_rlim.rlim_max > NR_OPEN)
 			return -EPERM;
 	}
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_setrlimit(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_rlimit;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	*old_rlim = new_rlim;
 	return 0;
 }
diff -urN -x rsbac trunk/kernel/sysctl.c linux-2.4.32-rsbac-1.2.7/kernel/sysctl.c
--- trunk/kernel/sysctl.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/sysctl.c	2006-06-01 10:32:05.000000000 +0200
@@ -38,6 +38,11 @@
 #include <linux/nfs_fs.h>
 #endif
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 #if defined(CONFIG_SYSCTL)
 
 /* External variables not in a header file. */
@@ -372,6 +377,15 @@
 	       void *newval, size_t newlen)
 {
 	struct list_head *tmp;
+	int error = -ENOTDIR;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        int   n[2];
+        #endif
 
 	if (nlen <= 0 || nlen >= CTL_MAXNAME)
 		return -ENOTDIR;
@@ -383,11 +397,53 @@
 		if ((ssize_t)old_len < 0)
 			return -EINVAL;
 	}
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(newval)
+          rsbac_request = R_MODIFY_SYSTEM_DATA;
+        else
+          rsbac_request = R_GET_STATUS_DATA;
+        
+        if(   (nlen > 1)
+           && !copy_from_user(n, name, 2*sizeof(*n))
+           && (n[0] == CTL_KERN))
+          {
+            switch(n[1])
+              {
+                case KERN_NODENAME:
+                  rsbac_target_id.scd = ST_host_id;
+                  break;
+                case KERN_DOMAINNAME:
+                  rsbac_target_id.scd = ST_net_id;
+                  break;
+                default:
+                  rsbac_target_id.scd = ST_sysctl;
+              }
+          }
+        else
+          rsbac_target_id.scd = ST_sysctl;
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_sysctl() [sys_sysctl()]: calling ADF\n");
+#endif
+        if(!rsbac_adf_request(rsbac_request,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	tmp = &root_table_header.ctl_entry;
 	do {
 		struct ctl_table_header *head =
 			list_entry(tmp, struct ctl_table_header, ctl_entry);
 		void *context = NULL;
+
 		int error = parse_table(name, nlen, oldval, oldlenp, 
 					newval, newlen, head->ctl_table,
 					&context);
@@ -786,12 +842,53 @@
 	size_t len;
 	char *p, c;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!table->data || !table->maxlen || !*lenp ||
 	    (filp->f_pos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(write)
+          rsbac_request = R_MODIFY_SYSTEM_DATA;
+        else
+          rsbac_request = R_GET_STATUS_DATA;
+        switch(table->ctl_name)
+          {
+            case KERN_NODENAME:
+              rsbac_target_id.scd = ST_host_id;
+              break;
+            case KERN_DOMAINNAME:
+              rsbac_target_id.scd = ST_net_id;
+              break;
+            default:
+              rsbac_target_id.scd = ST_sysctl;
+          }
+        /* Call adf only, if controlled param */
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "proc_dostring() [... proc_writesys()]: calling ADF\n");
+#endif
+        if(!rsbac_adf_request(rsbac_request,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	if (write) {
 		len = 0;
 		p = buffer;
@@ -865,6 +962,13 @@
 	#define TMPBUFLEN 20
 	char buf[TMPBUFLEN], *p;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!table->data || !table->maxlen || !*lenp ||
 	    (filp->f_pos && !write)) {
 		*lenp = 0;
@@ -876,6 +980,29 @@
 	left = *lenp;
 	
 	for (; left && vleft--; i++, first=0) {
+                /* RSBAC */
+	        #ifdef CONFIG_RSBAC
+	        if(write)
+                  rsbac_request = R_MODIFY_SYSTEM_DATA;
+                else
+                  rsbac_request = R_GET_STATUS_DATA;
+                rsbac_target_id.scd = ST_sysctl;
+                rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+	        if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "do_proc_dointvec() [... proc_writesys()]: calling ADF\n");
+#endif
+                if(!rsbac_adf_request(rsbac_request,
+                                      current->pid,
+                                      T_SCD,
+                                      rsbac_target_id,
+                                      A_none,
+                                      rsbac_attribute_value))
+                  {
+                    return -EPERM;
+                  }
+                #endif
+
 		if (write) {
 			while (left) {
 				char c;
diff -urN -x rsbac trunk/kernel/time.c linux-2.4.32-rsbac-1.2.7/kernel/time.c
--- trunk/kernel/time.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/time.c	2006-06-01 10:32:05.000000000 +0200
@@ -30,6 +30,11 @@
 
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /* 
  * The timezone where the local system is located.  Used as a default by some
  * programs who obtain this value by using gettimeofday.
@@ -75,10 +80,34 @@
 {
 	int value;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_TIME))
 		return -EPERM;
 	if (get_user(value, tptr))
 		return -EFAULT;
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_stime(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_clock;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	write_lock_irq(&xtime_lock);
 	vxtime_lock();
 	xtime.tv_sec = value;
@@ -149,9 +178,34 @@
 {
 	static int firsttime = 1;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_TIME))
 		return -EPERM;
 		
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "do_sys_settimeofday() [sys_settimeofday()]: calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_clock;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	if (tz) {
 		/* SMP safe, global irq locking makes it work. */
 		sys_tz = *tz;
@@ -214,10 +268,33 @@
         long ltemp, mtemp, save_adjust;
 	int result;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* In order to modify anything, you gotta be super-user! */
 	if (txc->modes && !capable(CAP_SYS_TIME))
 		return -EPERM;
 		
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_adjtimex(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_time_strucs;
+        rsbac_attribute_value.dummy = 0;
+        if (   txc->modes
+            && !rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                                  current->pid,
+                                  T_SCD,
+                                  rsbac_target_id,
+                                  A_none,
+                                  rsbac_attribute_value))
+		return -EPERM;
+        #endif
+
 	/* Now we validate the data before disabling interrupts */
 
 	if ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT)
diff -urN -x rsbac trunk/kernel/timer.c linux-2.4.32-rsbac-1.2.7/kernel/timer.c
--- trunk/kernel/timer.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/timer.c	2006-06-01 10:32:05.000000000 +0200
@@ -25,6 +25,11 @@
 
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Timekeeping variables
  */
@@ -803,14 +808,22 @@
 
 asmlinkage long sys_getuid(void)
 {
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        return rsbac_fake_uid();
+        #else
 	/* Only we change this so SMP safe */
 	return current->uid;
+	#endif
 }
 
 asmlinkage long sys_geteuid(void)
 {
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        return rsbac_fake_euid();
+        #else
 	/* Only we change this so SMP safe */
 	return current->euid;
+	#endif
 }
 
 asmlinkage long sys_getgid(void)
diff -urN -x rsbac trunk/kernel/uid16.c linux-2.4.32-rsbac-1.2.7/kernel/uid16.c
--- trunk/kernel/uid16.c	2006-06-01 10:30:30.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/kernel/uid16.c	2006-06-01 10:32:05.000000000 +0200
@@ -15,6 +15,11 @@
 
 #include <asm/uaccess.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+#include <rsbac/adf.h>
+#endif
+
 extern asmlinkage long sys_chown(const char *, uid_t,gid_t);
 extern asmlinkage long sys_lchown(const char *, uid_t,gid_t);
 extern asmlinkage long sys_fchown(unsigned int, uid_t,gid_t);
@@ -144,12 +149,20 @@
 
 asmlinkage long sys_getuid16(void)
 {
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        return high2lowuid(rsbac_fake_uid());
+        #else
 	return high2lowuid(current->uid);
+	#endif
 }
 
 asmlinkage long sys_geteuid16(void)
 {
+        #ifdef CONFIG_RSBAC_FAKE_ROOT_UID
+        return high2lowuid(rsbac_fake_euid());
+        #else
 	return high2lowuid(current->euid);
+	#endif
 }
 
 asmlinkage long sys_getgid16(void)
diff -urN -x rsbac trunk/MAINTAINERS linux-2.4.32-rsbac-1.2.7/MAINTAINERS
--- trunk/MAINTAINERS	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/MAINTAINERS	2006-06-01 10:32:36.000000000 +0200
@@ -1612,6 +1612,13 @@
 W:	http://oss.software.ibm.com/developerworks/opensource/linux390
 S:	Supported
 
+RSBAC
+P:	Amon Ott
+M:	ao@rsbac.org
+L:	rsbac@rsbac.org
+W:	http://www.rsbac.org
+S:	Maintained
+
 SA1100 SUPPORT
 P:	Nicolas Pitre
 M:	nico@cam.org
diff -urN -x rsbac trunk/Makefile linux-2.4.32-rsbac-1.2.7/Makefile
--- trunk/Makefile	2006-06-01 10:31:29.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/Makefile	2006-06-01 10:32:55.000000000 +0200
@@ -14,7 +14,7 @@
 TOPDIR	:= $(shell /bin/pwd)
 
 HPATH   	= $(TOPDIR)/include
-FINDHPATH	= $(HPATH)/asm $(HPATH)/linux $(HPATH)/scsi $(HPATH)/net $(HPATH)/math-emu
+FINDHPATH	= $(HPATH)/asm $(HPATH)/linux $(HPATH)/scsi $(HPATH)/net $(HPATH)/math-emu $(HPATH)/rsbac
 
 HOSTCC  	= gcc
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
@@ -70,6 +70,13 @@
 endif
 
 #
+# Add RSBAC version
+#
+ifeq ($(CONFIG_RSBAC),y)
+EXTRAVERSION:=$(EXTRAVERSION)-rsbac
+endif
+
+#
 # INSTALL_PATH specifies where to place the updated kernel and system map
 # images.  Uncomment if you want to place them anywhere other than root.
 #
@@ -130,6 +137,14 @@
 LIBS		=$(TOPDIR)/lib/lib.a
 SUBDIRS		=kernel drivers mm fs net ipc lib crypto
 
+#
+# Add RSBAC
+#
+ifeq ($(CONFIG_RSBAC),y)
+CORE_FILES := $(CORE_FILES) rsbac/rsbac.o
+SUBDIRS    := $(SUBDIRS) rsbac
+endif
+
 DRIVERS-n :=
 DRIVERS-y :=
 DRIVERS-m :=
diff -urN -x rsbac trunk/mm/filemap.c linux-2.4.32-rsbac-1.2.7/mm/filemap.c
--- trunk/mm/filemap.c	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/mm/filemap.c	2006-06-01 10:32:36.000000000 +0200
@@ -30,6 +30,11 @@
 
 #include <linux/highmem.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_RW
+#include <rsbac/adf.h>
+#endif
+
 /*
  * Shared mappings implemented 30.11.1994. It's not fully working yet,
  * though.
@@ -1855,6 +1860,16 @@
 	struct file * in_file, * out_file;
 	struct inode * in_inode, * out_inode;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+        enum  rsbac_target_t          rsbac_in_target = T_NONE;
+        union rsbac_target_id_t       rsbac_in_target_id;
+        enum  rsbac_target_t          rsbac_out_target = T_NONE;
+        union rsbac_target_id_t       rsbac_out_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/*
 	 * Get input file, and verify that it is ok..
 	 */
@@ -1891,6 +1906,154 @@
 	if (retval)
 		goto fput_out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_RW
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "common_sendfile() [sys_sendfile()]: calling ADF for infile\n");
+#endif
+        /* get target type and id of infile clear */
+        #ifdef CONFIG_RSBAC_NET_OBJ_RW
+        if(S_ISSOCK(in_inode->i_mode))
+          {
+            #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+            if(   in_inode->u.socket_i.ops
+               && (in_inode->u.socket_i.ops->family != AF_UNIX)
+              )
+            #endif
+              {
+                rsbac_in_target = T_NETOBJ;
+                rsbac_in_target_id.netobj.sock_p
+                  = &in_inode->u.socket_i;
+                rsbac_in_target_id.netobj.local_addr = NULL;
+                rsbac_in_target_id.netobj.local_len = 0;
+                rsbac_in_target_id.netobj.remote_addr = NULL;
+                rsbac_in_target_id.netobj.remote_len = 0;
+              }
+          }
+        else
+        #endif
+        if(   S_ISFIFO(in_inode->i_mode)
+           /* named FIFO only */
+           && (in_file->f_dentry->d_sb->s_magic != PIPEFS_MAGIC)
+          )
+          {
+            rsbac_in_target = T_FIFO;
+            rsbac_in_target_id.fifo.device = in_inode->i_dev;
+            rsbac_in_target_id.fifo.inode  = in_inode->i_ino;
+            rsbac_in_target_id.fifo.dentry_p = in_file->f_dentry;
+          }
+        else
+        if(S_ISREG(in_inode->i_mode))
+          {
+            rsbac_in_target = T_FILE;
+            rsbac_in_target_id.file.device = in_inode->i_dev;
+            rsbac_in_target_id.file.inode  = in_inode->i_ino;
+            rsbac_in_target_id.file.dentry_p = in_file->f_dentry;
+          }
+        else
+        if(S_ISBLK(in_inode->i_mode))
+          {
+            rsbac_in_target = T_DEV;
+            rsbac_in_target_id.dev.type = D_block;
+            rsbac_in_target_id.dev.major = RSBAC_MAJOR(in_inode->i_rdev);
+            rsbac_in_target_id.dev.minor = RSBAC_MINOR(in_inode->i_rdev);
+          }
+        else
+        if(S_ISCHR(in_inode->i_mode))
+          {
+            rsbac_in_target = T_DEV;
+            rsbac_in_target_id.dev.type = D_char;
+            rsbac_in_target_id.dev.major = RSBAC_MAJOR(in_inode->i_rdev);
+            rsbac_in_target_id.dev.minor = RSBAC_MINOR(in_inode->i_rdev);
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (   (rsbac_in_target != T_NONE)
+            && !rsbac_adf_request(R_READ,
+                                  current->pid,
+                                  rsbac_in_target,
+                                  rsbac_in_target_id,
+                                  A_none,
+                                  rsbac_attribute_value)
+           )
+          {
+            retval = -EPERM;
+            goto fput_out;
+          }
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "common_sendfile() [sys_sendfile()]: calling ADF for outfile\n");
+#endif
+        /* get target type and id of infile clear */
+        #ifdef CONFIG_RSBAC_NET_OBJ_RW
+        if(S_ISSOCK(out_inode->i_mode))
+          {
+            #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+            if(   out_inode->u.socket_i.ops
+               && (out_inode->u.socket_i.ops->family != AF_UNIX)
+              )
+            #endif
+              {
+                rsbac_out_target = T_NETOBJ;
+                rsbac_out_target_id.netobj.sock_p
+                  = &out_inode->u.socket_i;
+                rsbac_out_target_id.netobj.local_addr = NULL;
+                rsbac_out_target_id.netobj.local_len = 0;
+                rsbac_out_target_id.netobj.remote_addr = NULL;
+                rsbac_out_target_id.netobj.remote_len = 0;
+              }
+          }
+        else
+        #endif
+        if(   S_ISFIFO(out_inode->i_mode)
+           /* named FIFO only */
+           && (out_file->f_dentry->d_sb->s_magic != PIPEFS_MAGIC)
+          )
+          {
+            rsbac_out_target = T_FIFO;
+            rsbac_out_target_id.fifo.device = out_inode->i_dev;
+            rsbac_out_target_id.fifo.inode  = out_inode->i_ino;
+            rsbac_out_target_id.fifo.dentry_p = out_file->f_dentry;
+          }
+        else
+        if(S_ISREG(out_inode->i_mode))
+          {
+            rsbac_out_target = T_FILE;
+            rsbac_out_target_id.file.device = out_inode->i_dev;
+            rsbac_out_target_id.file.inode  = out_inode->i_ino;
+            rsbac_out_target_id.file.dentry_p = out_file->f_dentry;
+          }
+        else
+        if(S_ISBLK(out_inode->i_mode))
+          {
+            rsbac_out_target = T_DEV;
+            rsbac_out_target_id.dev.type = D_block;
+            rsbac_out_target_id.dev.major = RSBAC_MAJOR(out_inode->i_rdev);
+            rsbac_out_target_id.dev.minor = RSBAC_MINOR(out_inode->i_rdev);
+          }
+        else
+        if(S_ISCHR(out_inode->i_mode))
+          {
+            rsbac_out_target = T_DEV;
+            rsbac_out_target_id.dev.type = D_char;
+            rsbac_out_target_id.dev.major = RSBAC_MAJOR(out_inode->i_rdev);
+            rsbac_out_target_id.dev.minor = RSBAC_MINOR(out_inode->i_rdev);
+          }
+        rsbac_attribute_value.dummy = 0;
+        if (   (rsbac_out_target != T_NONE)
+            && !rsbac_adf_request(R_WRITE,
+                                  current->pid,
+                                  rsbac_out_target,
+                                  rsbac_out_target_id,
+                                  A_none,
+                                  rsbac_attribute_value)
+           )
+          {
+            retval = -EPERM;
+            goto fput_out;
+          }
+        #endif /* CONFIG_RSBAC_RW */
+
 	retval = 0;
 	if (count) {
 		read_descriptor_t desc;
@@ -1907,6 +2070,45 @@
 		retval = desc.written;
 		if (!retval)
 			retval = desc.error;
+
+                /* RSBAC: notify adf of read and written files etc. */
+                #ifdef CONFIG_RSBAC_RW
+                else
+                  {
+                    if (rsbac_in_target != T_NONE)
+                      {
+                        rsbac_new_target_id.dummy = 0;
+                        if (rsbac_adf_set_attr(R_READ,
+                                               current->pid,
+                                               rsbac_in_target,
+                                               rsbac_in_target_id,
+                                               T_NONE,
+                                               rsbac_new_target_id,
+                                               A_none,
+                                               rsbac_attribute_value))
+                          {
+                            rsbac_printk(KERN_WARNING
+                                   "common_sendfile() [sys_sendfile()]: rsbac_adf_set_attr() for infile returned error\n");
+                          }
+		      }
+                    if (rsbac_out_target != T_NONE)
+                      {
+                        rsbac_new_target_id.dummy = 0;
+                        if (rsbac_adf_set_attr(R_WRITE,
+                                               current->pid,
+                                               rsbac_out_target,
+                                               rsbac_out_target_id,
+                                               T_NONE,
+                                               rsbac_new_target_id,
+                                               A_none,
+                                               rsbac_attribute_value))
+                          {
+                            rsbac_printk(KERN_WARNING
+                                   "common_sendfile() [sys_sendfile()]: rsbac_adf_set_attr() for outfile returned error\n");
+                          }
+		      }
+                  }
+                #endif
 	}
 
 fput_out:
diff -urN -x rsbac trunk/mm/mlock.c linux-2.4.32-rsbac-1.2.7/mm/mlock.c
--- trunk/mm/mlock.c	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/mm/mlock.c	2006-06-01 10:32:36.000000000 +0200
@@ -12,6 +12,11 @@
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 static inline int mlock_fixup_all(struct vm_area_struct * vma, int newflags)
 {
 	spin_lock(&vma->vm_mm->page_table_lock);
@@ -198,6 +203,31 @@
 	unsigned long lock_limit;
 	int error = -ENOMEM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.scd = ST_mlock;
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_mlock(): calling ADF\n");
+#endif
+        if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&current->mm->mmap_sem);
 	len = PAGE_ALIGN(len + (start & ~PAGE_MASK));
 	start &= PAGE_MASK;
@@ -268,6 +298,31 @@
 	unsigned long lock_limit;
 	int ret = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        rsbac_target_id.scd = ST_mlock;
+        rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_mlockall(): calling ADF\n");
+#endif
+        if(!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                              current->pid,
+                              T_SCD,
+                              rsbac_target_id,
+                              A_none,
+                              rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	down_write(&current->mm->mmap_sem);
 	if (!flags || (flags & ~(MCL_CURRENT | MCL_FUTURE)))
 		goto out;
diff -urN -x rsbac trunk/mm/mmap.c linux-2.4.32-rsbac-1.2.7/mm/mmap.c
--- trunk/mm/mmap.c	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/mm/mmap.c	2006-06-01 10:32:36.000000000 +0200
@@ -25,6 +25,11 @@
  */
 #undef DEBUG_MM_RB
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 /* description of effects of mapping type and prot in current implementation.
  * this is due to the limited x86 page protection hardware.  The expected
  * behavior is in parens:
@@ -401,6 +406,13 @@
 	int error;
 	rb_node_t ** rb_link, * rb_parent;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (file) {
 		if (!file->f_op || !file->f_op->mmap)
 			return -ENODEV;
@@ -446,6 +458,44 @@
 			return -EAGAIN;
 	}
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        if(prot & PROT_EXEC)
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "do_mmap_pgoff() [do_mmap() [sys_mmap()]]: calling ADF\n");
+#endif
+            if(file)
+              {
+                rsbac_target = T_FILE;
+                rsbac_target_id.file.device = file->f_dentry->d_inode->i_dev;
+                rsbac_target_id.file.inode  = file->f_dentry->d_inode->i_ino;
+                rsbac_target_id.file.dentry_p = file->f_dentry;
+              }
+            else
+              {
+                rsbac_target = T_NONE;
+                rsbac_target_id.dummy = 0;
+              }
+            rsbac_attribute_value.prot_bits = prot;
+            if (!rsbac_adf_request(R_MAP_EXEC,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   A_prot_bits,
+                                   rsbac_attribute_value))
+              {
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "do_mmap_pgoff() [do_mmap() [sys_mmap()]]: request not granted, my PID: %i\n",
+                         current->pid);
+#endif
+                return -EPERM;
+              }
+          }
+        #endif
+
 	if (file) {
 		switch (flags & MAP_TYPE) {
 		case MAP_SHARED:
@@ -591,6 +641,33 @@
 		mm->locked_vm += len >> PAGE_SHIFT;
 		make_pages_present(addr, addr + len);
 	}
+
+        /* RSBAC: notify ADF of mapped segment */
+        #ifdef CONFIG_RSBAC
+        if(prot & PROT_EXEC)
+          {
+            union rsbac_target_id_t rsbac_new_target_id;
+
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "do_mmap_pgoff() [do_mmap() [sys_mmap()]]: calling ADF_set_attr\n");
+#endif
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_MAP_EXEC,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "do_mmap_pgoff() [do_mmap() [sys_mmap()]]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 	return addr;
 
 unmap_and_free_vma:
diff -urN -x rsbac trunk/mm/mprotect.c linux-2.4.32-rsbac-1.2.7/mm/mprotect.c
--- trunk/mm/mprotect.c	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/mm/mprotect.c	2006-06-01 10:32:36.000000000 +0200
@@ -12,6 +12,11 @@
 #include <asm/pgalloc.h>
 #include <asm/pgtable.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 static inline void change_pte_range(pmd_t * pmd, unsigned long address,
 	unsigned long size, pgprot_t newprot)
 {
@@ -270,6 +275,14 @@
 	struct vm_area_struct * vma, * next, * prev;
 	int error = -EINVAL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        enum  rsbac_target_t          rsbac_target = T_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        int need_notify = FALSE;
+        #endif
+
 	if (start & ~PAGE_MASK)
 		return -EINVAL;
 	len = PAGE_ALIGN(len);
@@ -300,6 +313,45 @@
 			goto out;
 		}
 
+#ifdef CONFIG_RSBAC
+		if(   (prot & PROT_EXEC)
+		   && !(vma->vm_flags & PROT_EXEC)
+		  )
+		{
+#ifdef CONFIG_RSBAC_DEBUG
+			if(rsbac_debug_aef)
+				rsbac_printk(KERN_DEBUG "sys_mprotect: calling ADF\n");
+#endif
+			if(vma->vm_file) {
+		                rsbac_target = T_FILE;
+				rsbac_target_id.file.device = vma->vm_file->f_dentry->d_inode->i_dev;
+				rsbac_target_id.file.inode = vma->vm_file->f_dentry->d_inode->i_ino;
+				rsbac_target_id.file.dentry_p = vma->vm_file->f_dentry;
+			}
+			else {
+				rsbac_target = T_NONE;
+				rsbac_target_id.dummy = 0;
+			}
+			rsbac_attribute_value.prot_bits = prot;
+			if(!rsbac_adf_request(R_MAP_EXEC,
+						  current->pid,
+						  rsbac_target,
+						  rsbac_target_id,
+						  A_prot_bits,
+						  rsbac_attribute_value)) 
+			{
+#ifdef CONFIG_RSBAC_DEBUG
+				if(rsbac_debug_aef)
+					rsbac_printk(KERN_DEBUG "sys_mprotect: request NOT_GRANTED\n");
+#endif
+				error = -EPERM;
+				break;
+			}
+			else
+			  need_notify = TRUE;
+		}
+#endif
+
 		if (vma->vm_end > end) {
 			error = mprotect_fixup(vma, &prev, nstart, end, newflags);
 			goto out;
@@ -333,5 +385,32 @@
 	}
 out:
 	up_write(&current->mm->mmap_sem);
+
+        /* RSBAC: notify ADF of mapped segment */
+        #ifdef CONFIG_RSBAC
+        if(need_notify && !error)
+          {
+            union rsbac_target_id_t rsbac_new_target_id;
+
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_mprotect(): calling ADF_set_attr\n");
+#endif
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_MAP_EXEC,
+                                   current->pid,
+                                   rsbac_target,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                printk(KERN_WARNING
+                       "sys_mprotect: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 	return error;
 }
diff -urN -x rsbac trunk/mm/swapfile.c linux-2.4.32-rsbac-1.2.7/mm/swapfile.c
--- trunk/mm/swapfile.c	2006-06-01 10:31:04.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/mm/swapfile.c	2006-06-01 10:32:36.000000000 +0200
@@ -17,6 +17,11 @@
 
 #include <asm/pgtable.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#endif
+
 spinlock_t swaplock = SPIN_LOCK_UNLOCKED;
 unsigned int nr_swapfiles;
 int total_swap_pages;
@@ -725,9 +730,34 @@
 	int i, type, prev;
 	int err;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG "sys_swapoff(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_swap;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	err = user_path_walk(specialfile, &nd);
 	if (err)
 		goto out;
@@ -884,9 +914,37 @@
 	struct block_device *bdev = NULL;
 	unsigned short *swap_map;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC
+#ifdef CONFIG_RSBAC_DEBUG
+        if (rsbac_debug_aef)
+          rsbac_printk(KERN_DEBUG
+                 "sys_swapon(): calling ADF\n");
+#endif
+        rsbac_target_id.scd = ST_swap;
+        rsbac_attribute_value.dummy = 0;
+        if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+                               current->pid,
+                               T_SCD,
+                               rsbac_target_id,
+                               A_none,
+                               rsbac_attribute_value))
+          {
+            return -EPERM;
+          }
+        #endif
+
 	lock_kernel();
+
 	swap_list_lock();
 	p = swap_info;
 	for (type = 0 ; type < nr_swapfiles ; type++,p++)
diff -urN -x rsbac trunk/net/bridge/br_ioctl.c linux-2.4.32-rsbac-1.2.7/net/bridge/br_ioctl.c
--- trunk/net/bridge/br_ioctl.c	2006-06-01 10:30:49.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/bridge/br_ioctl.c	2006-06-01 10:32:24.000000000 +0200
@@ -20,12 +20,24 @@
 #include <asm/uaccess.h>
 #include "br_private.h"
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 static int br_ioctl_device(struct net_bridge *br,
 			   unsigned int cmd,
 			   unsigned long arg0,
 			   unsigned long arg1,
 			   unsigned long arg2)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        enum  rsbac_adf_request_t     rsbac_request = R_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (br == NULL)
 		return -EINVAL;
 
@@ -41,6 +53,42 @@
 		if (dev == NULL)
 			return -EINVAL;
 
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET_DEV
+		#ifdef CONFIG_RSBAC_DEBUG
+		if (rsbac_debug_aef)
+		  rsbac_printk(KERN_DEBUG "dev_ioctl(): calling ADF\n");
+		#endif
+		strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+		rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+		#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+		{
+		  char * p = rsbac_target_id.netdev;
+
+		  while(*p)
+		    {
+		      if(*p == ':')
+		        {
+		          *p=' ';
+		          break;
+		        }
+		      p++;
+		    }
+		}
+		#endif
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					current->pid,
+					T_NETDEV,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		  {
+		    dev_put(dev);
+		    return -EPERM;
+		  }
+		#endif
+
 		if (cmd == BRCTL_ADD_IF)
 			ret = br_add_if(br, dev);
 		else
@@ -189,6 +237,12 @@
 			       unsigned long arg0,
 			       unsigned long arg1)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	switch (cmd)
 	{
 	case BRCTL_GET_VERSION:
@@ -219,6 +273,25 @@
 		if (copy_from_user(buf, (void *)arg0, IFNAMSIZ))
 			return -EFAULT;
 
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET
+		#ifdef CONFIG_RSBAC_DEBUG
+		if (rsbac_debug_aef)
+		  rsbac_printk(KERN_DEBUG "br_ioctl_deviceless(): calling ADF\n");
+		#endif
+		rsbac_target_id.scd = ST_network;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					current->pid,
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		  {
+		    return -EPERM;
+		  }
+		#endif
+
 		buf[IFNAMSIZ-1] = 0;
 
 		if (cmd == BRCTL_ADD_BRIDGE)
diff -urN -x rsbac trunk/net/core/dev.c linux-2.4.32-rsbac-1.2.7/net/core/dev.c
--- trunk/net/core/dev.c	2006-06-01 10:30:47.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/core/dev.c	2006-06-01 10:32:21.000000000 +0200
@@ -109,6 +109,11 @@
 #endif
 
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET_DEV
+#include <rsbac/adf.h>
+#endif
+
 /* This define, if set, will randomly drop a packet when congestion
  * is more than moderate.  It helps fairness in the multi-interface
  * case when one of them is a hog, but it kills performance for the
@@ -2254,6 +2259,12 @@
 	int ret;
 	char *colon;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/* One special case: SIOCGIFCONF takes ifconf argument
 	   and requires shared lock, because it sleeps writing
 	   to user space.
@@ -2274,10 +2285,20 @@
 
 	ifr.ifr_name[IFNAMSIZ-1] = 0;
 
+	#ifdef CONFIG_RSBAC_NET_DEV_VIRT
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#endif
+
 	colon = strchr(ifr.ifr_name, ':');
 	if (colon)
 		*colon = 0;
 
+	#if defined(CONFIG_RSBAC_NET_DEV) && !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#endif
+
 	/*
 	 *	See which interface the caller is talking about. 
 	 */
@@ -2299,6 +2320,24 @@
 		case SIOCGIFMAP:
 		case SIOCGIFINDEX:
 		case SIOCGIFTXQLEN:
+			/* RSBAC */
+			#ifdef CONFIG_RSBAC_NET_DEV
+			#ifdef CONFIG_RSBAC_DEBUG
+			if (rsbac_debug_aef)
+			  rsbac_printk(KERN_DEBUG "dev_ioctl(): calling ADF\n");
+			#endif
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_GET_STATUS_DATA,
+						current->pid,
+						T_NETDEV,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			  {
+			    return -EPERM;
+			  }
+			#endif
+
 			dev_load(ifr.ifr_name);
 			read_lock(&dev_base_lock);
 			ret = dev_ifsioc(&ifr, cmd);
@@ -2337,6 +2376,25 @@
 		case SIOCGMIIREG:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
+
+			/* RSBAC */
+			#ifdef CONFIG_RSBAC_NET_DEV
+			#ifdef CONFIG_RSBAC_DEBUG
+			if (rsbac_debug_aef)
+			  rsbac_printk(KERN_DEBUG "dev_ioctl(): calling ADF\n");
+			#endif
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+						current->pid,
+						T_NETDEV,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			  {
+			    return -EPERM;
+			  }
+			#endif
+
 			dev_load(ifr.ifr_name);
 			dev_probe_lock();
 			rtnl_lock();
@@ -2377,6 +2435,25 @@
 		case SIOCBONDCHANGEACTIVE:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
+
+			/* RSBAC */
+			#ifdef CONFIG_RSBAC_NET_DEV
+			#ifdef CONFIG_RSBAC_DEBUG
+			if (rsbac_debug_aef)
+			  rsbac_printk(KERN_DEBUG "dev_ioctl(): calling ADF\n");
+			#endif
+			rsbac_attribute_value.dummy = 0;
+			if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+						current->pid,
+						T_NETDEV,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			  {
+			    return -EPERM;
+			  }
+			#endif
+
 			dev_load(ifr.ifr_name);
 			dev_probe_lock();
 			rtnl_lock();
@@ -2420,6 +2497,25 @@
 				if (IW_IS_SET(cmd) || (cmd == SIOCGIWENCODE)) {
 					if(!capable(CAP_NET_ADMIN))
 						return -EPERM;
+
+					/* RSBAC */
+					#ifdef CONFIG_RSBAC_NET_DEV
+					#ifdef CONFIG_RSBAC_DEBUG
+					if (rsbac_debug_aef)
+					  rsbac_printk(KERN_DEBUG "dev_ioctl(): calling ADF\n");
+					#endif
+					rsbac_attribute_value.dummy = 0;
+					if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					    current->pid,
+					    T_NETDEV,
+					    rsbac_target_id,
+					    A_none,
+					    rsbac_attribute_value))
+					  {
+					    return -EPERM;
+					  }
+					#endif
+
 				}
 				dev_load(ifr.ifr_name);
 				rtnl_lock();
diff -urN -x rsbac trunk/net/ipv4/arp.c linux-2.4.32-rsbac-1.2.7/net/ipv4/arp.c
--- trunk/net/ipv4/arp.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/arp.c	2006-06-01 10:32:23.000000000 +0200
@@ -219,6 +219,10 @@
 	return -EINVAL;
 }
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET_DEV
+#include <rsbac/adf.h>
+#endif
 
 static u32 arp_hash(const void *pkey, const struct net_device *dev)
 {
@@ -1141,15 +1145,29 @@
 	struct arpreq r;
 	struct net_device * dev = NULL;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        enum  rsbac_adf_request_t     rsbac_request = R_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	switch(cmd) {
 		case SIOCDARP:
 		case SIOCSARP:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
+			#ifdef CONFIG_RSBAC_NET_DEV
+			rsbac_request = R_MODIFY_SYSTEM_DATA;
+			#endif
 		case SIOCGARP:
 			err = copy_from_user(&r, arg, sizeof(struct arpreq));
 			if (err)
 				return -EFAULT;
+			#ifdef CONFIG_RSBAC_NET_DEV
+			if(rsbac_request == R_NONE)
+				rsbac_request = R_GET_STATUS_DATA;
+			#endif
 			break;
 		default:
 			return -EINVAL;
@@ -1176,6 +1194,27 @@
 		err = -EINVAL;
 		if ((r.arp_flags & ATF_COM) && r.arp_ha.sa_family != dev->type)
 			goto out;
+
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET_DEV
+#ifdef CONFIG_RSBAC_DEBUG
+		if (rsbac_debug_aef)
+		  rsbac_printk(KERN_DEBUG "arp_ioctl(): calling ADF\n");
+#endif
+		strncpy(rsbac_target_id.netdev, r.arp_dev, RSBAC_IFNAMSIZ);
+		rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(rsbac_request,
+				    current->pid,
+				    T_NETDEV,
+				    rsbac_target_id,
+				    A_none,
+				    rsbac_attribute_value))
+		  {
+		    err = -EPERM;
+		    goto out;
+		  }
+		#endif
 	} else if (cmd == SIOCGARP) {
 		err = -ENODEV;
 		goto out;
diff -urN -x rsbac trunk/net/ipv4/devinet.c linux-2.4.32-rsbac-1.2.7/net/ipv4/devinet.c
--- trunk/net/ipv4/devinet.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/devinet.c	2006-06-01 10:32:24.000000000 +0200
@@ -60,6 +60,11 @@
 #include <net/route.h>
 #include <net/ip_fib.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET_DEV
+#include <rsbac/adf.h>
+#endif
+
 struct ipv4_devconf ipv4_devconf = { 1, 1, 1, 1, 0, };
 static struct ipv4_devconf ipv4_devconf_dflt = { 1, 1, 1, 1, 1, };
 
@@ -364,10 +369,51 @@
 	struct ifaddrmsg *ifm = NLMSG_DATA(nlh);
 	struct in_ifaddr *ifa, **ifap;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	ASSERT_RTNL();
 
 	if ((in_dev = inetdev_by_index(ifm->ifa_index)) == NULL)
 		return -EADDRNOTAVAIL;
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "inet_rtm_deladdr(): calling ADF\n");
+	#endif
+	strncpy(rsbac_target_id.netdev, in_dev->dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+	  char * p = rsbac_target_id.netdev;
+		  while(*p)
+	    {
+	      if(*p == ':')
+	        {
+	          *p=' ';
+	          break;
+	        }
+	      p++;
+	    }
+	}
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_BIND,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	__in_dev_put(in_dev);
 
 	for (ifap=&in_dev->ifa_list; (ifa=*ifap)!=NULL; ifap=&ifa->ifa_next) {
@@ -393,6 +439,12 @@
 	struct ifaddrmsg *ifm = NLMSG_DATA(nlh);
 	struct in_ifaddr *ifa;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	ASSERT_RTNL();
 
 	if (ifm->ifa_prefixlen > 32 || rta[IFA_LOCAL-1] == NULL)
@@ -407,6 +459,40 @@
 			return -ENOBUFS;
 	}
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "inet_rtm_newaddr(): calling ADF\n");
+	#endif
+	strncpy(rsbac_target_id.netdev, in_dev->dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#ifndef CONFIG_RSBAC_NET_DEV_VIRT
+	{
+	  char * p = rsbac_target_id.netdev;
+		  while(*p)
+	    {
+	      if(*p == ':')
+	        {
+	          *p=' ';
+	          break;
+	        }
+	      p++;
+	    }
+	}
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_BIND,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	if ((ifa = inet_alloc_ifa()) == NULL)
 		return -ENOBUFS;
 
@@ -470,6 +556,13 @@
 	int ret = 0;
 	int tryaddrmatch = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        enum  rsbac_adf_request_t     rsbac_request = R_NONE;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/*
 	 *	Fetch the caller's info block into kernel space
 	 */
@@ -478,6 +571,11 @@
 		return -EFAULT;
 	ifr.ifr_name[IFNAMSIZ-1] = 0;
 
+	#ifdef CONFIG_RSBAC_NET_DEV_VIRT
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#endif
+
 	/* save original address for comparison */
 	memcpy(&sin_orig, sin, sizeof(*sin));
 
@@ -485,6 +583,11 @@
 	if (colon)
 		*colon = 0;
 
+	#if defined(CONFIG_RSBAC_NET_DEV) && !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	strncpy(rsbac_target_id.netdev, ifr.ifr_name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#endif
+
 #ifdef CONFIG_KMOD
 	dev_load(ifr.ifr_name);
 #endif
@@ -501,11 +604,18 @@
 		tryaddrmatch = (sin_orig.sin_family == AF_INET);
 		memset(sin, 0, sizeof(*sin));
 		sin->sin_family = AF_INET;
+
+		#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_request = R_GET_STATUS_DATA;
+		#endif
 		break;
 
 	case SIOCSIFFLAGS:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
+		#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_request = R_MODIFY_SYSTEM_DATA;
+		#endif
 		break;
 	case SIOCSIFADDR:	/* Set interface address (and family) */
 	case SIOCSIFBRDADDR:	/* Set the broadcast address */
@@ -515,6 +625,9 @@
 			return -EACCES;
 		if (sin->sin_family != AF_INET)
 			return -EINVAL;
+		#ifdef CONFIG_RSBAC_NET_DEV
+		rsbac_request = R_BIND;
+		#endif
 		break;
 	default:
 		return -EINVAL;
@@ -528,6 +641,25 @@
 		goto done;
 	}
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "dev_ioctl(): calling ADF\n");
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    ret = -EPERM;
+	    goto done;
+	  }
+	#endif
+
 	if (colon)
 		*colon = ':';
 
diff -urN -x rsbac trunk/net/ipv4/fib_frontend.c linux-2.4.32-rsbac-1.2.7/net/ipv4/fib_frontend.c
--- trunk/net/ipv4/fib_frontend.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/fib_frontend.c	2006-06-01 10:32:24.000000000 +0200
@@ -45,6 +45,11 @@
 #include <net/arp.h>
 #include <net/ip_fib.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 #define FFprint(a...) printk(KERN_DEBUG a)
 
 #ifndef CONFIG_IP_MULTIPLE_TABLES
@@ -293,6 +298,12 @@
 		struct rtmsg	rtm;
 	} req;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	switch (cmd) {
 	case SIOCADDRT:		/* Add a route */
 	case SIOCDELRT:		/* Delete a route */
@@ -300,6 +311,26 @@
 			return -EPERM;
 		if (copy_from_user(&r, arg, sizeof(struct rtentry)))
 			return -EFAULT;
+
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET
+		#ifdef CONFIG_RSBAC_DEBUG
+		if (rsbac_debug_aef)
+		  rsbac_printk(KERN_DEBUG "dev_ioctl(): calling ADF\n");
+		#endif
+		rsbac_target_id.scd = ST_network;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					current->pid,
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		  {
+		    return -EPERM;
+		  }
+		#endif
+
 		rtnl_lock();
 		err = fib_convert_rtentry(cmd, &req.nlh, &req.rtm, &rta, &r);
 		if (err == 0) {
@@ -354,9 +385,34 @@
 	struct rtattr **rta = arg;
 	struct rtmsg *r = NLMSG_DATA(nlh);
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (inet_check_attr(r, rta))
 		return -EINVAL;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "inet_rtm_delroute(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	tb = fib_get_table(r->rtm_table);
 	if (tb)
 		return tb->tb_delete(tb, r, (struct kern_rta*)rta, nlh, &NETLINK_CB(skb));
@@ -369,9 +425,34 @@
 	struct rtattr **rta = arg;
 	struct rtmsg *r = NLMSG_DATA(nlh);
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (inet_check_attr(r, rta))
 		return -EINVAL;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "inet_rtm_newroute(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	tb = fib_new_table(r->rtm_table);
 	if (tb)
 		return tb->tb_insert(tb, r, (struct kern_rta*)rta, nlh, &NETLINK_CB(skb));
diff -urN -x rsbac trunk/net/ipv4/fib_rules.c linux-2.4.32-rsbac-1.2.7/net/ipv4/fib_rules.c
--- trunk/net/ipv4/fib_rules.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/fib_rules.c	2006-06-01 10:32:23.000000000 +0200
@@ -47,6 +47,11 @@
 #include <net/sock.h>
 #include <net/ip_fib.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 #define FRprintk(a...)
 
 struct fib_rule
@@ -108,6 +113,31 @@
 	struct fib_rule *r, **rp;
 	int err = -ESRCH;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "inet_rtm_delrule(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	for (rp=&fib_rules; (r=*rp) != NULL; rp=&r->r_next) {
 		if ((!rta[RTA_SRC-1] || memcmp(RTA_DATA(rta[RTA_SRC-1]), &r->r_src, 4) == 0) &&
 		    rtm->rtm_src_len == r->r_src_len &&
@@ -166,6 +196,12 @@
 	struct fib_rule *r, *new_r, **rp;
 	unsigned char table_id;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (rtm->rtm_src_len > 32 || rtm->rtm_dst_len > 32 ||
 	    (rtm->rtm_tos & ~IPTOS_TOS_MASK))
 		return -EINVAL;
@@ -183,6 +219,25 @@
 		}
 	}
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "inet_rtm_newrule(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	new_r = kmalloc(sizeof(*new_r), GFP_KERNEL);
 	if (!new_r)
 		return -ENOMEM;
@@ -403,6 +458,31 @@
 	struct nlmsghdr  *nlh;
 	unsigned char	 *b = skb->tail;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "inet_fill_rule() [inet_dump_rules()]: calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	nlh = NLMSG_PUT(skb, NETLINK_CREDS(cb->skb)->pid, cb->nlh->nlmsg_seq, RTM_NEWRULE, sizeof(*rtm));
 	rtm = NLMSG_DATA(nlh);
 	rtm->rtm_family = AF_INET;
diff -urN -x rsbac trunk/net/ipv4/ipmr.c linux-2.4.32-rsbac-1.2.7/net/ipv4/ipmr.c
--- trunk/net/ipv4/ipmr.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/ipmr.c	2006-06-01 10:32:23.000000000 +0200
@@ -61,6 +61,11 @@
 #include <net/ipip.h>
 #include <net/checksum.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 #if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
 #define CONFIG_IP_PIMSM	1
 #endif
@@ -848,8 +853,33 @@
 	
 	if(optname!=MRT_INIT)
 	{
+	        /* RSBAC */
+        	#ifdef CONFIG_RSBAC_NET_DEV
+	        union rsbac_target_id_t       rsbac_target_id;
+        	union rsbac_attribute_value_t rsbac_attribute_value;
+	        #endif
+
 		if(sk!=mroute_socket && !capable(CAP_NET_ADMIN))
 			return -EACCES;
+
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET_DEV
+		#ifdef CONFIG_RSBAC_DEBUG
+		if (rsbac_debug_aef)
+		  rsbac_printk(KERN_DEBUG "ip_mroute_setsockopt(): calling ADF\n");
+		#endif
+		rsbac_target_id.scd = ST_network;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					current->pid,
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		  {
+		    return -EPERM;
+		  }
+		#endif
 	}
 
 	switch(optname)
diff -urN -x rsbac trunk/net/ipv4/netfilter/ipchains_core.c linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ipchains_core.c
--- trunk/net/ipv4/netfilter/ipchains_core.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ipchains_core.c	2006-06-01 10:32:23.000000000 +0200
@@ -99,6 +99,11 @@
 #include <linux/proc_fs.h>
 #include <linux/stat.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 /* Understanding locking in this code: (thanks to Alan Cox for using
  * little words to explain this to me). -- PR
  *
@@ -1575,6 +1580,31 @@
 	int last_len = 0;
 	off_t upto = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "ip_chain_procinfo(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	duprintf("Offset starts at %lu\n", offset);
 	duprintf("ip_fw_chains is 0x%0lX\n", (unsigned long int)ip_fw_chains);
 
@@ -1625,6 +1655,31 @@
 	off_t pos = 0,begin = 0;
 	unsigned long flags;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "ip_chain_name_procinfo(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	/* Need a write lock to lock out ``readers'' which update counters. */
 	FWC_WRITE_LOCK_IRQ(&ip_fw_lock, flags);
 
diff -urN -x rsbac trunk/net/ipv4/netfilter/ipfwadm_core.c linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ipfwadm_core.c
--- trunk/net/ipv4/netfilter/ipfwadm_core.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ipfwadm_core.c	2006-06-01 10:32:23.000000000 +0200
@@ -130,6 +130,11 @@
 #include <linux/stat.h>
 #include <linux/version.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 /*
  *	Implement IP packet firewall
  */
@@ -1113,6 +1118,31 @@
 	int len, p;
 	int last_len = 0;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "ip_chain_procinfo(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 
 	switch(stage)
 	{
diff -urN -x rsbac trunk/net/ipv4/netfilter/ip_fw_compat.c linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ip_fw_compat.c
--- trunk/net/ipv4/netfilter/ip_fw_compat.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ip_fw_compat.c	2006-06-01 10:32:23.000000000 +0200
@@ -16,6 +16,11 @@
 #include <linux/netfilter_ipv4/ip_conntrack.h>
 #include <linux/netfilter_ipv4/ip_conntrack_core.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 /* Theoretically, we could one day use 2.4 helpers, but for now it
    just confuses depmod --RR */
 EXPORT_NO_SYMBOLS;
@@ -220,6 +225,13 @@
 	   We can't include both 2.0 and 2.2 headers, they conflict.
 	   Hence, 200 is a good number. --RR */
 	char tmp_fw[200];
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
@@ -229,6 +241,25 @@
 	if (copy_from_user(&tmp_fw, user, len))
 		return -EFAULT;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "sock_fd(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	return -ip_fw_ctl(optval, &tmp_fw, len);
 }
 
diff -urN -x rsbac trunk/net/ipv4/netfilter/ip_fw_compat_masq.c linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ip_fw_compat_masq.c
--- trunk/net/ipv4/netfilter/ip_fw_compat_masq.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ip_fw_compat_masq.c	2006-06-01 10:32:23.000000000 +0200
@@ -27,6 +27,11 @@
 #include <linux/netfilter_ipv4/ip_nat_core.h>
 #include <linux/netfilter_ipv4/listhelp.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 #if 0
 #define DEBUGP printk
 #else
@@ -273,6 +278,31 @@
 	int len = 0;
 	off_t upto = 1;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "masq_procinfo(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	/* Header: first record */
 	if (offset == 0) {
 		char temp[128];
diff -urN -x rsbac trunk/net/ipv4/netfilter/ip_queue.c linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ip_queue.c
--- trunk/net/ipv4/netfilter/ip_queue.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ip_queue.c	2006-06-01 10:32:23.000000000 +0200
@@ -29,6 +29,11 @@
 #include <net/sock.h>
 #include <net/route.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 #define IPQ_QMAX_DEFAULT 1024
 #define IPQ_PROC_FS_NAME "ip_queue"
 #define NET_IPQ_QMAX 2088
@@ -477,6 +482,12 @@
 	int status, type, pid, flags, nlmsglen, skblen;
 	struct nlmsghdr *nlh;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	skblen = skb->len;
 	if (skblen < sizeof(*nlh))
 		return;
@@ -505,6 +516,25 @@
 	if(!cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN))
 		RCV_SKB_FAIL(-EPERM);
 	
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "ipq_rcv_skb(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+            RCV_SKB_FAIL(-EPERM);
+	  }
+	#endif
+
 	write_lock_bh(&queue_lock);
 	
 	if (peer_pid) {
diff -urN -x rsbac trunk/net/ipv4/netfilter/ip_tables.c linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ip_tables.c
--- trunk/net/ipv4/netfilter/ip_tables.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/netfilter/ip_tables.c	2006-06-01 10:32:23.000000000 +0200
@@ -25,6 +25,11 @@
 
 #include <linux/netfilter_ipv4/ip_tables.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 /*#define DEBUG_IP_FIREWALL*/
 /*#define DEBUG_ALLOW_ALL*/ /* Useful for remote debugging */
 /*#define DEBUG_IP_FIREWALL_USER*/
@@ -1220,9 +1225,34 @@
 {
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "do_ipt_set_ctl(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	switch (cmd) {
 	case IPT_SO_SET_REPLACE:
 		ret = do_replace(user, len);
@@ -1245,9 +1275,34 @@
 {
 	int ret;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "do_ipt_get_ctl(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_firewall;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	switch (cmd) {
 	case IPT_SO_GET_INFO: {
 		char name[IPT_TABLE_MAXNAMELEN];
diff -urN -x rsbac trunk/net/ipv4/route.c linux-2.4.32-rsbac-1.2.7/net/ipv4/route.c
--- trunk/net/ipv4/route.c	2006-06-01 10:30:48.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/route.c	2006-06-01 10:32:24.000000000 +0200
@@ -99,6 +99,11 @@
 #include <linux/sysctl.h>
 #endif
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 #define IP_MAX_MTU	0xFFF0
 
 #define RT_GC_TIMEOUT (300*HZ)
@@ -2207,6 +2212,31 @@
 	int err = -ENOBUFS;
 	struct sk_buff *skb;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "inet_rtm_getroute(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
 	if (!skb)
 		goto out;
diff -urN -x rsbac trunk/net/ipv4/tcp_diag.c linux-2.4.32-rsbac-1.2.7/net/ipv4/tcp_diag.c
--- trunk/net/ipv4/tcp_diag.c	2006-06-01 10:30:49.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv4/tcp_diag.c	2006-06-01 10:32:24.000000000 +0200
@@ -29,6 +29,11 @@
 
 #include <linux/tcp_diag.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 static struct sock *tcpnl;
 
 
@@ -566,6 +571,12 @@
 static __inline__ int
 tcpdiag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (!(nlh->nlmsg_flags&NLM_F_REQUEST))
 		return 0;
 
@@ -575,6 +586,25 @@
 	if (NLMSG_LENGTH(sizeof(struct tcpdiagreq)) > skb->len)
 		goto err_inval;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "tcpdiag_rcv_msg(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	if (nlh->nlmsg_flags&NLM_F_DUMP) {
 		if (nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(struct tcpdiagreq))) {
 			struct rtattr *rta = (struct rtattr*)(NLMSG_DATA(nlh) + sizeof(struct tcpdiagreq));
diff -urN -x rsbac trunk/net/ipv6/mcast.c linux-2.4.32-rsbac-1.2.7/net/ipv6/mcast.c
--- trunk/net/ipv6/mcast.c	2006-06-01 10:30:49.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv6/mcast.c	2006-06-01 10:32:24.000000000 +0200
@@ -1142,6 +1142,11 @@
 	if (skb->pkt_type == PACKET_LOOPBACK)
 		return 0;
 
+	/* send our report if the MC router may not have heard this report */
+	if (skb->pkt_type != PACKET_MULTICAST &&
+	    skb->pkt_type != PACKET_BROADCAST)
+		return 0;
+
 	if (!pskb_may_pull(skb, sizeof(struct in6_addr)))
 		return -EINVAL;
 
diff -urN -x rsbac trunk/net/ipv6/route.c linux-2.4.32-rsbac-1.2.7/net/ipv6/route.c
--- trunk/net/ipv6/route.c	2006-06-01 10:30:49.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/ipv6/route.c	2006-06-01 10:32:24.000000000 +0200
@@ -56,6 +56,11 @@
 #include <linux/sysctl.h>
 #endif
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 #undef CONFIG_RT6_POLICY
 
 /* Set to 3 to get tracing. */
@@ -1224,6 +1229,12 @@
 	struct in6_rtmsg rtmsg;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	switch(cmd) {
 	case SIOCADDRT:		/* Add a route */
 	case SIOCDELRT:		/* Delete a route */
@@ -1234,6 +1245,25 @@
 		if (err)
 			return -EFAULT;
 			
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET
+		#ifdef CONFIG_RSBAC_DEBUG
+		if (rsbac_debug_aef)
+		  rsbac_printk(KERN_DEBUG "ipv6_route_ioctl(): calling ADF\n");
+		#endif
+		rsbac_target_id.scd = ST_network;
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+					current->pid,
+					T_SCD,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		  {
+		    return -EPERM;
+		  }
+		#endif
+
 		rtnl_lock();
 		switch (cmd) {
 		case SIOCADDRT:
diff -urN -x rsbac trunk/net/sched/cls_api.c linux-2.4.32-rsbac-1.2.7/net/sched/cls_api.c
--- trunk/net/sched/cls_api.c	2006-06-01 10:30:46.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/sched/cls_api.c	2006-06-01 10:32:21.000000000 +0200
@@ -35,6 +35,11 @@
 #include <net/sock.h>
 #include <net/pkt_sched.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET
+#include <rsbac/adf.h>
+#endif
+
 /* The list of all installed classifier types */
 
 static struct tcf_proto_ops *tcf_proto_base;
@@ -133,6 +138,36 @@
 	unsigned long fh;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "tc_ctl_tfilter(): calling ADF\n");
+	#endif
+	if(n->nlmsg_type == RTM_GETTFILTER)
+	  rsbac_request = R_GET_STATUS_DATA;
+	else
+	  rsbac_request = R_MODIFY_SYSTEM_DATA;
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	if (prio == 0) {
 		/* If no priority is given, user wants we allocated it. */
 		if (n->nlmsg_type != RTM_NEWTFILTER || !(n->nlmsg_flags&NLM_F_CREATE))
@@ -356,6 +391,31 @@
 	struct Qdisc_class_ops *cops;
 	struct tcf_dump_args arg;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "tc_ctl_tfilter(): calling ADF\n");
+	#endif
+	rsbac_target_id.scd = ST_network;
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_SCD,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	if (cb->nlh->nlmsg_len < NLMSG_LENGTH(sizeof(*tcm)))
 		return skb->len;
 	if ((dev = dev_get_by_index(tcm->tcm_ifindex)) == NULL)
diff -urN -x rsbac trunk/net/sched/sch_api.c linux-2.4.32-rsbac-1.2.7/net/sched/sch_api.c
--- trunk/net/sched/sch_api.c	2006-06-01 10:30:46.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/sched/sch_api.c	2006-06-01 10:32:21.000000000 +0200
@@ -34,6 +34,11 @@
 #include <linux/kmod.h>
 #include <linux/list.h>
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC_NET_DEV
+#include <rsbac/adf.h>
+#endif
+
 #include <net/sock.h>
 #include <net/pkt_sched.h>
 
@@ -543,9 +548,48 @@
 	struct Qdisc *p = NULL;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        enum  rsbac_adf_request_t     rsbac_request;
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+	#endif
+        #endif
+
 	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "tc_get_qdisc(): calling ADF\n");
+	#endif
+	if(n->nlmsg_type == RTM_DELQDISC)
+	  rsbac_request = R_MODIFY_SYSTEM_DATA;
+	else
+	  rsbac_request = R_GET_STATUS_DATA;
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if(rsbac_colon)
+	  *rsbac_colon = 0;
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(rsbac_request,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	if (clid) {
 		if (clid != TC_H_ROOT) {
 			if (TC_H_MAJ(clid) != TC_H_MAJ(TC_H_INGRESS)) {
@@ -604,9 +648,43 @@
 	struct Qdisc *p = NULL;
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+	#endif
+        #endif
+
 	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "tc_modify_qdisc(): calling ADF\n");
+	#endif
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if(rsbac_colon)
+	  *rsbac_colon = 0;
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	if (clid) {
 		if (clid != TC_H_ROOT) {
 			if (clid != TC_H_INGRESS) {
@@ -799,6 +877,15 @@
 	struct net_device *dev;
 	struct Qdisc *q;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+	#endif
+        #endif
+
 	s_idx = cb->args[0];
 	s_q_idx = q_idx = cb->args[1];
 	read_lock(&dev_base_lock);
@@ -807,6 +894,32 @@
 			continue;
 		if (idx > s_idx)
 			s_q_idx = 0;
+
+		/* RSBAC */
+		#ifdef CONFIG_RSBAC_NET_DEV
+		#ifdef CONFIG_RSBAC_DEBUG
+		if (rsbac_debug_aef)
+		  rsbac_printk(KERN_DEBUG "tc_dump_qdisc(): calling ADF\n");
+		#endif
+		strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+		rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+		#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+		rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+		if(rsbac_colon)
+		  *rsbac_colon = 0;
+		#endif
+		rsbac_attribute_value.dummy = 0;
+		if (!rsbac_adf_request(R_GET_STATUS_DATA,
+					current->pid,
+					T_NETDEV,
+					rsbac_target_id,
+					A_none,
+					rsbac_attribute_value))
+		  {
+		    continue;
+		  }
+		#endif
+
 		read_lock(&qdisc_tree_lock);
 		q_idx = 0;
 		list_for_each_entry(q, &dev->qdisc_list, list) {
@@ -855,9 +968,43 @@
 	u32 qid = TC_H_MAJ(clid);
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+	#endif
+        #endif
+
 	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "tc_ctl_tclass(): calling ADF\n");
+	#endif
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if(rsbac_colon)
+	  *rsbac_colon = 0;
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	/*
 	   parent == TC_H_UNSPEC - unspecified parent.
 	   parent == TC_H_ROOT   - class is root, which has no parent.
@@ -1024,11 +1171,45 @@
 	struct tcmsg *tcm = (struct tcmsg*)NLMSG_DATA(cb->nlh);
 	struct qdisc_dump_args arg;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_DEV
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	char * rsbac_colon;
+	#endif
+        #endif
+
 	if (cb->nlh->nlmsg_len < NLMSG_LENGTH(sizeof(*tcm)))
 		return 0;
 	if ((dev = dev_get_by_index(tcm->tcm_ifindex)) == NULL)
 		return 0;
 
+	/* RSBAC */
+	#ifdef CONFIG_RSBAC_NET_DEV
+	#ifdef CONFIG_RSBAC_DEBUG
+	if (rsbac_debug_aef)
+	  rsbac_printk(KERN_DEBUG "tc_dump_tclass(): calling ADF\n");
+	#endif
+	strncpy(rsbac_target_id.netdev, dev->name, RSBAC_IFNAMSIZ);
+	rsbac_target_id.netdev[RSBAC_IFNAMSIZ] = 0;
+	#if !defined(CONFIG_RSBAC_NET_DEV_VIRT)
+	rsbac_colon = strchr(rsbac_target_id.netdev, ':');
+	if(rsbac_colon)
+	  *rsbac_colon = 0;
+	#endif
+	rsbac_attribute_value.dummy = 0;
+	if (!rsbac_adf_request(R_GET_STATUS_DATA,
+				current->pid,
+				T_NETDEV,
+				rsbac_target_id,
+				A_none,
+				rsbac_attribute_value))
+	  {
+	    return -EPERM;
+	  }
+	#endif
+
 	s_t = cb->args[0];
 	t = 0;
 
diff -urN -x rsbac trunk/net/socket.c linux-2.4.32-rsbac-1.2.7/net/socket.c
--- trunk/net/socket.c	2006-06-01 10:30:49.000000000 +0200
+++ linux-2.4.32-rsbac-1.2.7/net/socket.c	2006-06-01 10:32:24.000000000 +0200
@@ -105,6 +105,13 @@
 static ssize_t sock_sendpage(struct file *file, struct page *page,
 			     int offset, size_t size, loff_t *ppos, int more);
 
+/* RSBAC */
+#ifdef CONFIG_RSBAC
+#include <rsbac/adf.h>
+#include <rsbac/aci.h>
+#include <rsbac/helpers.h>
+#endif
+
 
 /*
  *	Socket files have a set of 'special' operations as well as the generic file ones. These don't appear
@@ -502,9 +509,79 @@
 	int err;
 	struct scm_cookie scm;
 
+        /* RSBAC  */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
+        /* RSBAC */
+        #if defined(CONFIG_RSBAC_NET_OBJ)
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+        if(   sock->ops
+           && (sock->ops->family != AF_UNIX)
+          )
+        #endif
+        #if !defined(CONFIG_RSBAC_NET_OBJ_RW)
+        if(sock->type != SOCK_STREAM)
+        #endif
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG
+                     "sock_sendmsg() [sys_send(), sys_sendto(), sys_sendmsg()]: calling ADF\n");
+#endif
+            rsbac_target_id.netobj.sock_p = sock;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = msg->msg_name;
+            rsbac_target_id.netobj.remote_len = msg->msg_namelen;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_SEND,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                return -EPERM;
+              }
+          }
+        #endif
+
 	err = scm_send(sock, msg, &scm);
 	if (err >= 0) {
 		err = sock->ops->sendmsg(sock, msg, size, &scm);
+
+                /* RSBAC: notify ADF of sent msg */
+                #ifdef CONFIG_RSBAC_NET_OBJ
+                if(   !err
+                #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                   && sock->ops
+                   && (sock->ops->family != AF_UNIX)
+                #endif
+                #if !defined(CONFIG_RSBAC_NET_OBJ_RW)
+                   && (sock->type != SOCK_STREAM)
+                #endif
+                  )
+                  {
+                    rsbac_new_target_id.dummy = 0;
+                    if (rsbac_adf_set_attr(R_SEND,
+                                           current->pid,
+                                           T_NETOBJ,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "sock_sendmsg() [sys_send(), sys_sendto(), sys_sendmsg()]: rsbac_adf_set_attr() returned error");
+                      }
+                  }
+                #endif
+
 		scm_destroy(&scm);
 	}
 	return err;
@@ -514,12 +591,84 @@
 {
 	struct scm_cookie scm;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	memset(&scm, 0, sizeof(scm));
 
 	size = sock->ops->recvmsg(sock, msg, size, flags, &scm);
 	if (size >= 0)
 		scm_recv(sock, msg, &scm, flags);
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+        if(   sock->ops
+           && (sock->ops->family != AF_UNIX)
+          )
+        #endif
+        #if !defined(CONFIG_RSBAC_NET_OBJ_RW)
+        if(sock->type != SOCK_STREAM)
+        #endif
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG
+                     "sock_recvmsg() [sys_recv(), sys_recvfrom(), sys_recvmsg()]: calling ADF\n");
+#endif
+            rsbac_target_id.netobj.sock_p = sock;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = NULL;
+            rsbac_target_id.netobj.remote_len = 0;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_RECEIVE,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                /* clear buffer */
+                if(size > 0)
+                  memset(msg->msg_iov->iov_base - size, 0, size);
+                return -EPERM;
+              }
+          }
+        #endif
+
+        /* RSBAC: notify ADF of received message */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        if((size >= 0)
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+           && sock->ops
+           && (sock->ops->family != AF_UNIX)
+        #endif
+           #if !defined(CONFIG_RSBAC_NET_OBJ_RW)
+           && (sock->type != SOCK_STREAM)
+           #endif
+          )
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_RECEIVE,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sock_recvmsg() [sys_recv(), sys_recvfrom(), sys_recvmsg()]: rsbac_adf_set_attr() for RECEIVE returned error\n");
+              }
+          }
+        #endif
+
 	return size;
 }
 
@@ -903,10 +1052,63 @@
 	int retval;
 	struct socket *sock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union  rsbac_target_id_t       rsbac_target_id;
+        union  rsbac_target_id_t       rsbac_new_target_id;
+        union  rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	retval = sock_create(family, type, protocol, &sock);
 	if (retval < 0)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+        if(family != AF_UNIX)
+        #endif
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_socket() [sys_socketcall()]: calling ADF\n");
+#endif
+            rsbac_target_id.netobj.sock_p = sock;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = NULL;
+            rsbac_target_id.netobj.remote_len = 0;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_CREATE,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_socket() [sys_socketcall()]: ADF returned NOT_GRANTED\n");
+#endif
+                retval = -EPERM;
+                goto out_release;
+              }
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_CREATE,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_socket() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 	retval = sock_map_fd(sock);
 	if (retval < 0)
 		goto out_release;
@@ -929,6 +1131,13 @@
 	struct socket *sock1, *sock2;
 	int fd1, fd2, err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union  rsbac_target_id_t       rsbac_target_id;
+        union  rsbac_target_id_t       rsbac_new_target_id;
+        union  rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	/*
 	 * Obtain the first socket and check if the underlying protocol
 	 * supports the socketpair call.
@@ -938,10 +1147,76 @@
 	if (err < 0)
 		goto out;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+        if(family != AF_UNIX)
+        #endif
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_socketpair() [sys_socketcall()]: calling ADF\n");
+#endif
+            rsbac_target_id.netobj.sock_p = sock1;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = NULL;
+            rsbac_target_id.netobj.remote_len = 0;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_CREATE,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_socketpair() [sys_socketcall()]: ADF returned NOT_GRANTED\n");
+#endif
+                err = -EPERM;
+                goto out_release_1;
+              }
+          }
+        #endif
+
 	err = sock_create(family, type, protocol, &sock2);
 	if (err < 0)
 		goto out_release_1;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+        if(family != AF_UNIX)
+        #endif
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_socketpair() [sys_socketcall()]: calling ADF\n");
+#endif
+            rsbac_target_id.netobj.sock_p = sock2;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = NULL;
+            rsbac_target_id.netobj.remote_len = 0;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_CREATE,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_socketpair() [sys_socketcall()]: ADF returned NOT_GRANTED\n");
+#endif
+                err = -EPERM;
+                goto out_release_both;
+              }
+          }
+        #endif
+
 	err = sock1->ops->socketpair(sock1, sock2);
 	if (err < 0) 
 		goto out_release_both;
@@ -965,8 +1240,45 @@
 	err = put_user(fd1, &usockvec[0]); 
 	if (!err)
 		err = put_user(fd2, &usockvec[1]);
-	if (!err)
+	if (!err) {
+	        /* RSBAC */
+	        #ifdef CONFIG_RSBAC_NET_OBJ
+	        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+	        if(family != AF_UNIX)
+	        #endif
+	          {
+	            rsbac_target_id.netobj.sock_p = sock1;
+	            rsbac_new_target_id.dummy = 0;
+	            if (rsbac_adf_set_attr(R_CREATE,
+	                                   current->pid,
+	                                   T_NETOBJ,
+	                                   rsbac_target_id,
+	                                   T_NONE,
+	                                   rsbac_new_target_id,
+	                                   A_none,
+	                                   rsbac_attribute_value))
+        	      {
+	                rsbac_printk(KERN_WARNING
+	                       "sys_socketpair() [sys_socketcall()]: rsbac_adf_set_attr() for sock1 returned error\n");
+	              }
+	            rsbac_target_id.netobj.sock_p = sock2;
+	            if (rsbac_adf_set_attr(R_CREATE,
+	                                   current->pid,
+	                                   T_NETOBJ,
+	                                   rsbac_target_id,
+	                                   T_NONE,
+	                                   rsbac_new_target_id,
+	                                   A_none,
+	                                   rsbac_attribute_value))
+        	      {
+	                rsbac_printk(KERN_WARNING
+	                       "sys_socketpair() [sys_socketcall()]: rsbac_adf_set_attr() for sock2 returned error\n");
+	              }
+	          }
+	        #endif
+
 		return 0;
+	}
 
 	sys_close(fd2);
 	sys_close(fd1);
@@ -1002,8 +1314,73 @@
 
 	if((sock = sockfd_lookup(fd,&err))!=NULL)
 	{
-		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0)
+		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+			union rsbac_target_id_t		rsbac_target_id;
+			union rsbac_target_id_t		rsbac_new_target_id;
+			union rsbac_attribute_value_t   rsbac_attribute_value;
+
+                        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                        if(   sock->ops
+                           && (sock->ops->family != AF_UNIX)
+                          )
+                        #endif
+                          {
+                            rsbac_target_id.netobj.sock_p = sock;
+                            rsbac_target_id.netobj.local_addr = address;
+                            rsbac_target_id.netobj.local_len = addrlen;
+                            rsbac_target_id.netobj.remote_addr = NULL;
+                            rsbac_target_id.netobj.remote_len = 0;
+			    rsbac_attribute_value.dummy = 0;
+#ifdef CONFIG_RSBAC_DEBUG
+			    if (rsbac_debug_aef)
+				rsbac_printk(KERN_DEBUG
+					"sys_bind() [sys_socketcall()]: calling ADF");
+#endif
+			    if(!rsbac_adf_request(R_BIND,
+						current->pid,
+						T_NETOBJ,
+						rsbac_target_id,
+						A_none,
+						rsbac_attribute_value))
+			      {
+#ifdef CONFIG_RSBAC_DEBUG
+				   if (rsbac_debug_aef)
+					   rsbac_printk(KERN_DEBUG "sys_bind() [sys_socketcall()]: ADF returned NOT_GRANTED\n");
+#endif
+				   sockfd_put(sock);
+				   return -EPERM;
+			      }
+			  }
+                        #endif
+
 			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
+
+                        /* RSBAC: notify ADF of binding */
+                        #ifdef CONFIG_RSBAC_NET_OBJ
+                        if(!err
+                        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                           && sock->ops
+                           && (sock->ops->family != AF_UNIX)
+                        #endif
+                          )
+                          {
+                            rsbac_new_target_id.dummy = 0;
+                            if (rsbac_adf_set_attr(R_BIND,
+                                                   current->pid,
+                                                   T_NETOBJ,
+                                                   rsbac_target_id,
+                                                   T_NONE,
+                                                   rsbac_new_target_id,
+                                                   A_none,
+                                                   rsbac_attribute_value))
+                              {
+                                rsbac_printk(KERN_WARNING
+                                       "sys_bind() [sys_socketcall()]: rsbac_adf_set_attr() returned error");
+                              }
+                          }
+                        #endif
+		}
 		sockfd_put(sock);
 	}			
 	return err;
@@ -1023,10 +1400,79 @@
 	struct socket *sock;
 	int err;
 	
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+	
 	if ((sock = sockfd_lookup(fd, &err)) != NULL) {
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_NET_OBJ
+                #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                if(   sock->ops
+                   && (sock->ops->family != AF_UNIX)
+                  )
+                #endif
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG
+                             "sys_listen() [sys_socketcall()]: calling ADF\n");
+#endif
+                    rsbac_target_id.netobj.sock_p = sock;
+                    rsbac_target_id.netobj.local_addr = NULL;
+                    rsbac_target_id.netobj.local_len = 0;
+                    rsbac_target_id.netobj.remote_addr = NULL;
+                    rsbac_target_id.netobj.remote_len = 0;
+                    rsbac_attribute_value.dummy = 0;
+                    if (!rsbac_adf_request(R_LISTEN,
+                                           current->pid,
+                                           T_NETOBJ,
+                                           rsbac_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+#ifdef CONFIG_RSBAC_DEBUG
+                        if (rsbac_debug_aef)
+                          rsbac_printk(KERN_DEBUG "sys_listen() [sys_socketcall()]: ADF returned NOT_GRANTED\n");
+#endif
+                        sockfd_put(sock);
+                        return -EPERM;
+                      }
+                  }
+                #endif
+
 		if ((unsigned) backlog > sysctl_somaxconn)
 			backlog = sysctl_somaxconn;
 		err=sock->ops->listen(sock, backlog);
+
+                /* RSBAC: notify ADF of listened socket */
+                #ifdef CONFIG_RSBAC_NET_OBJ
+                if(!err
+                #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                   && sock->ops
+                   && (sock->ops->family != AF_UNIX)
+                #endif
+                  )
+                  {
+                    rsbac_new_target_id.dummy = 0;
+                    if (rsbac_adf_set_attr(R_LISTEN,
+                                           current->pid,
+                                           T_NETOBJ,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING
+                               "sys_listen() [sys_socketcall()]: rsbac_adf_set_attr() returned error");
+                      }
+		  }
+                #endif
+
 		sockfd_put(sock);
 	}
 	return err;
@@ -1051,6 +1497,13 @@
 	int err, len;
 	char address[MAX_SOCK_ADDR];
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	sock = sockfd_lookup(fd, &err);
 	if (!sock)
 		goto out;
@@ -1066,6 +1519,41 @@
 	if (err < 0)
 		goto out_release;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+        if(   sock->ops
+           && (sock->ops->family != AF_UNIX)
+          )
+        #endif
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG "sys_accept() [sys_socketcall()]: calling ADF\n");
+#endif
+            rsbac_target_id.netobj.sock_p = newsock;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = NULL;
+            rsbac_target_id.netobj.remote_len = 0;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_ACCEPT,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_accept() [sys_socketcall()]: ADF returned NOT_GRANTED\n");
+#endif
+                err = -EPERM;
+                goto out_release;
+              }
+          }
+        #endif
+
 	if (upeer_sockaddr) {
 		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
 			err = -ECONNABORTED;
@@ -1081,6 +1569,30 @@
 	if ((err = sock_map_fd(newsock)) < 0)
 		goto out_release;
 
+        /* RSBAC: notify ADF of accepted connection */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+        if(   sock->ops
+           && (sock->ops->family != AF_UNIX)
+          )
+        #endif
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_ACCEPT,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_accept() [sys_socketcall()]: rsbac_adf_set_attr() returned error\n");
+              }
+          }
+        #endif
+
 out_put:
 	sockfd_put(sock);
 out:
@@ -1110,14 +1622,82 @@
 	char address[MAX_SOCK_ADDR];
 	int err;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	sock = sockfd_lookup(fd, &err);
 	if (!sock)
 		goto out;
 	err = move_addr_to_kernel(uservaddr, addrlen, address);
 	if (err < 0)
 		goto out_put;
+
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+        if(   sock->ops
+           && (sock->ops->family != AF_UNIX)
+          )
+        #endif
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef) rsbac_printk(KERN_DEBUG "sys_connect() [sys_socketcall()]: calling ADF\n");
+#endif
+            rsbac_target_id.netobj.sock_p = sock;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = address;
+            rsbac_target_id.netobj.remote_len = addrlen;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_CONNECT,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+#ifdef CONFIG_RSBAC_DEBUG
+                if (rsbac_debug_aef)
+                  rsbac_printk(KERN_DEBUG "sys_connect() [sys_socketcall()]: ADF returned NOT_GRANTED\n");
+#endif
+                err = -EPERM;
+                goto out_put;
+              }
+          }
+        #endif
+
 	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
 				 sock->file->f_flags);
+
+        /* RSBAC: notify ADF of opened socket connection */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        if(!err
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+           && sock->ops
+           && (sock->ops->family != AF_UNIX)
+        #endif
+          )
+          {
+            rsbac_new_target_id.dummy = 0;
+            if (rsbac_adf_set_attr(R_CONNECT,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   T_NONE,
+                                   rsbac_new_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+                rsbac_printk(KERN_WARNING
+                       "sys_connect() [sys_socketcall()]: rsbac_adf_set_attr() returned error");
+              }
+          }
+        #endif
+
 out_put:
 	sockfd_put(sock);
 out:
@@ -1135,9 +1715,48 @@
 	char address[MAX_SOCK_ADDR];
 	int len, err;
 	
+        /* RSBAC  */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	sock = sockfd_lookup(fd, &err);
 	if (!sock)
 		goto out;
+
+        /* RSBAC */
+        #if defined(CONFIG_RSBAC_NET_OBJ)
+        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+        if(   sock->ops
+           && (sock->ops->family != AF_UNIX)
+          )
+        #endif
+          {
+#ifdef CONFIG_RSBAC_DEBUG
+            if (rsbac_debug_aef)
+              rsbac_printk(KERN_DEBUG
+                     "sys_getsockname(): calling ADF\n");
+#endif
+            rsbac_target_id.netobj.sock_p = sock;
+            rsbac_target_id.netobj.local_addr = NULL;
+            rsbac_target_id.netobj.local_len = 0;
+            rsbac_target_id.netobj.remote_addr = NULL;
+            rsbac_target_id.netobj.remote_len = 0;
+            rsbac_attribute_value.dummy = 0;
+            if (!rsbac_adf_request(R_GET_STATUS_DATA,
+                                   current->pid,
+                                   T_NETOBJ,
+                                   rsbac_target_id,
+                                   A_none,
+                                   rsbac_attribute_value))
+              {
+		sockfd_put(sock);
+                return -EPERM;
+              }
+          }
+        #endif
+
 	err = sock->ops->getname(sock, (struct sockaddr *)address, &len, 0);
 	if (err)
 		goto out_put;
@@ -1160,8 +1779,46 @@
 	char address[MAX_SOCK_ADDR];
 	int len, err;
 
+        /* RSBAC  */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+	        /* RSBAC */
+	        #if defined(CONFIG_RSBAC_NET_OBJ)
+	        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+	        if(   sock->ops
+	           && (sock->ops->family != AF_UNIX)
+	          )
+	        #endif
+	          {
+#ifdef CONFIG_RSBAC_DEBUG
+	            if (rsbac_debug_aef)
+	              rsbac_printk(KERN_DEBUG
+	                     "sys_getpeername(): calling ADF\n");
+#endif
+	            rsbac_target_id.netobj.sock_p = sock;
+	            rsbac_target_id.netobj.local_addr = NULL;
+	            rsbac_target_id.netobj.local_len = 0;
+	            rsbac_target_id.netobj.remote_addr = NULL;
+	            rsbac_target_id.netobj.remote_len = 0;
+	            rsbac_attribute_value.dummy = 0;
+	            if (!rsbac_adf_request(R_GET_STATUS_DATA,
+	                                   current->pid,
+	                                   T_NETOBJ,
+	                                   rsbac_target_id,
+	                                   A_none,
+	                                   rsbac_attribute_value))
+	              {
+			sockfd_put(sock);
+	                return -EPERM;
+	              }
+	          }
+	        #endif
+
 		err = sock->ops->getname(sock, (struct sockaddr *)address, &len, 1);
 		if (!err)
 			err=move_addr_to_user(address,len, usockaddr, usockaddr_len);
@@ -1285,11 +1942,49 @@
 	int err;
 	struct socket *sock;
 
+        /* RSBAC  */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if (optlen < 0)
 		return -EINVAL;
 			
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+	        /* RSBAC */
+	        #if defined(CONFIG_RSBAC_NET_OBJ)
+	        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+	        if(   sock->ops
+	           && (sock->ops->family != AF_UNIX)
+	          )
+	        #endif
+	          {
+#ifdef CONFIG_RSBAC_DEBUG
+	            if (rsbac_debug_aef)
+	              rsbac_printk(KERN_DEBUG
+	                     "sys_setsockopt()]: calling ADF\n");
+#endif
+	            rsbac_target_id.netobj.sock_p = sock;
+	            rsbac_target_id.netobj.local_addr = NULL;
+	            rsbac_target_id.netobj.local_len = 0;
+	            rsbac_target_id.netobj.remote_addr = NULL;
+	            rsbac_target_id.netobj.remote_len = 0;
+	            rsbac_attribute_value.setsockopt_level = level;
+	            if (!rsbac_adf_request(R_MODIFY_SYSTEM_DATA,
+	                                   current->pid,
+	                                   T_NETOBJ,
+	                                   rsbac_target_id,
+	                                   A_setsockopt_level,
+	                                   rsbac_attribute_value))
+	              {
+			sockfd_put(sock);
+	                return -EPERM;
+	              }
+	          }
+	        #endif
+
 		if (level == SOL_SOCKET)
 			err=sock_setsockopt(sock,level,optname,optval,optlen);
 		else
@@ -1309,8 +2004,46 @@
 	int err;
 	struct socket *sock;
 
+        /* RSBAC  */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+	        /* RSBAC */
+	        #if defined(CONFIG_RSBAC_NET_OBJ)
+	        #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+	        if(   sock->ops
+	           && (sock->ops->family != AF_UNIX)
+	          )
+	        #endif
+	          {
+#ifdef CONFIG_RSBAC_DEBUG
+	            if (rsbac_debug_aef)
+	              rsbac_printk(KERN_DEBUG
+	                     "sys_getsockopt(): calling ADF\n");
+#endif
+	            rsbac_target_id.netobj.sock_p = sock;
+	            rsbac_target_id.netobj.local_addr = NULL;
+	            rsbac_target_id.netobj.local_len = 0;
+	            rsbac_target_id.netobj.remote_addr = NULL;
+	            rsbac_target_id.netobj.remote_len = 0;
+	            rsbac_attribute_value.dummy = 0;
+	            if (!rsbac_adf_request(R_GET_STATUS_DATA,
+	                                   current->pid,
+	                                   T_NETOBJ,
+	                                   rsbac_target_id,
+	                                   A_none,
+	                                   rsbac_attribute_value))
+	              {
+			sockfd_put(sock);
+	                return -EPERM;
+	              }
+	          }
+	        #endif
+
 		if (level == SOL_SOCKET)
 			err=sock_getsockopt(sock,level,optname,optval,optlen);
 		else
@@ -1330,9 +2063,80 @@
 	int err;
 	struct socket *sock;
 
+        /* RSBAC */
+        #ifdef CONFIG_RSBAC_NET_OBJ
+        union rsbac_target_id_t       rsbac_target_id;
+        union rsbac_target_id_t       rsbac_new_target_id;
+        union rsbac_attribute_value_t rsbac_attribute_value;
+        #endif
+
 	if ((sock = sockfd_lookup(fd, &err))!=NULL)
 	{
+                /* RSBAC */
+                #ifdef CONFIG_RSBAC_NET_OBJ
+                #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                if(   sock->ops
+                   && (sock->ops->family != AF_UNIX)
+                  )
+                #endif
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG
+                             "sys_shutdown() [sys_socketcall()]: calling ADF\n");
+#endif
+                    rsbac_target_id.netobj.sock_p = sock;
+                    rsbac_target_id.netobj.local_addr = NULL;
+                    rsbac_target_id.netobj.local_len = 0;
+                    rsbac_target_id.netobj.remote_addr = NULL;
+                    rsbac_target_id.netobj.remote_len = 0;
+                    rsbac_attribute_value.dummy = 0;
+                    if (!rsbac_adf_request(R_NET_SHUTDOWN,
+                                           current->pid,
+                                           T_NETOBJ,
+                                           rsbac_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        sockfd_put(sock);
+                        return -EPERM;
+                      }
+                  }
+                #endif
+
 		err=sock->ops->shutdown(sock, how);
+
+                /* RSBAC: notifying adf / socket */
+                #ifdef CONFIG_RSBAC_NET_OBJ
+                if(!err
+                #if !defined(CONFIG_RSBAC_NET_OBJ_UNIX)
+                   && sock->ops
+                   && (sock->ops->family != AF_UNIX)
+                #endif
+                  )
+                  {
+#ifdef CONFIG_RSBAC_DEBUG
+                    if (rsbac_debug_aef)
+                      rsbac_printk(KERN_DEBUG
+                             "sys_shutdown: calling rsbac_adf_set_attr() for NET_SHUTDOWN on netobj\n");
+#endif
+                    rsbac_new_target_id.dummy = 0;
+                    rsbac_attribute_value.dummy = 0;
+                    if (rsbac_adf_set_attr(R_NET_SHUTDOWN,
+                                           current->pid,
+                                           T_NETOBJ,
+                                           rsbac_target_id,
+                                           T_NONE,
+                                           rsbac_new_target_id,
+                                           A_none,
+                                           rsbac_attribute_value))
+                      {
+                        rsbac_printk(KERN_WARNING 
+                               "sys_shutdown(): rsbac_adf_set_attr() for NET_SHUTDOWN on socket returned error\n");
+                      }
+                  }
+                #endif
+
 		sockfd_put(sock);
 	}
 	return err;
@@ -1710,6 +2514,17 @@
 	 *  do_initcalls is run.  
 	 */
 
+	#ifdef CONFIG_RSBAC
+	if(sock_mnt && !IS_ERR(sock_mnt))
+	  {
+	    #ifdef CONFIG_RSBAC_DEBUG
+	    if (rsbac_debug_ds)
+	      rsbac_printk(KERN_DEBUG "sock_init(): calling rsbac_mount for Device %02u:%02u\n",
+		     MAJOR(sock_mnt->mnt_sb->s_dev), MINOR(sock_mnt->mnt_sb->s_dev));
+	    #endif
+	    rsbac_mount(sock_mnt->mnt_sb, NULL);
+	  }
+	#endif
 
 	/*
 	 * The netlink device handler may be needed early.
