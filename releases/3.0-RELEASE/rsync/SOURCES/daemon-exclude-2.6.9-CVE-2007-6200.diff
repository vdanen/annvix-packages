--- rsync-2.6.9/main.c	2006-10-13 16:46:32.000000000 -0700
+++ ./main.c	2007-12-16 14:02:52.000000000 -0800
@@ -61,6 +61,7 @@ extern int batch_fd;
 extern int batch_gen_fd;
 extern int filesfrom_fd;
 extern pid_t cleanup_child_pid;
+extern unsigned int module_dirlen;
 extern struct stats stats;
 extern char *filesfrom_host;
 extern char *partial_dir;
@@ -852,15 +853,18 @@ static void do_server_recv(int f_in, int
 	fix_basis_dirs();
 
 	if (server_filter_list.head) {
-		char **dir;
+		char **dir_p;
 		struct filter_list_struct *elp = &server_filter_list;
 
-		for (dir = basis_dir; *dir; dir++) {
-			if (check_filter(elp, *dir, 1) < 0)
+		for (dir_p = basis_dir; *dir_p; dir_p++) {
+			char *dir = *dir_p;
+			if (*dir == '/')
+				dir += module_dirlen;
+			if (check_filter(elp, dir, 1) < 0)
 				goto options_rejected;
 		}
 		if (partial_dir && *partial_dir == '/'
-		 && check_filter(elp, partial_dir, 1) < 0) {
+		 && check_filter(elp, partial_dir + module_dirlen, 1) < 0) {
 		    options_rejected:
 			rprintf(FERROR,
 				"Your options have been rejected by the server.\n");
--- rsync-2.6.9/options.c	2006-10-23 17:36:38.000000000 -0700
+++ ./options.c	2007-12-16 14:06:30.000000000 -0800
@@ -26,6 +26,7 @@
 
 extern int module_id;
 extern int sanitize_paths;
+extern unsigned int module_dirlen;
 extern struct filter_list_struct filter_list;
 extern struct filter_list_struct server_filter_list;
 
@@ -912,13 +913,14 @@ int parse_arguments(int *argc, const cha
 			if (sanitize_paths)
 				arg = sanitize_path(NULL, arg, NULL, 0, NULL);
 			if (server_filter_list.head) {
-				char *cp = strdup(arg);
+				char *dir, *cp = strdup(arg);
 				if (!cp)
 					out_of_memory("parse_arguments");
 				if (!*cp)
 					goto options_rejected;
-				clean_fname(cp, 1);
-				if (check_filter(&server_filter_list, cp, 0) < 0)
+				dir = cp + (*cp == '/' ? module_dirlen : 0);
+				clean_fname(dir, 1);
+				if (check_filter(&server_filter_list, dir, 0) < 0)
 					goto options_rejected;
 				free(cp);
 			}
@@ -1236,17 +1238,21 @@ int parse_arguments(int *argc, const cha
 	if (server_filter_list.head && !am_sender) {
 		struct filter_list_struct *elp = &server_filter_list;
 		if (tmpdir) {
+			char *dir;
 			if (!*tmpdir)
 				goto options_rejected;
-			clean_fname(tmpdir, 1);
-			if (check_filter(elp, tmpdir, 1) < 0)
+			dir = tmpdir + (*tmpdir == '/' ? module_dirlen : 0);
+			clean_fname(dir, 1);
+			if (check_filter(elp, dir, 1) < 0)
 				goto options_rejected;
 		}
 		if (backup_dir) {
+			char *dir;
 			if (!*backup_dir)
 				goto options_rejected;
-			clean_fname(backup_dir, 1);
-			if (check_filter(elp, backup_dir, 1) < 0) {
+			dir = backup_dir + (*backup_dir == '/' ? module_dirlen : 0);
+			clean_fname(dir, 1);
+			if (check_filter(elp, dir, 1) < 0) {
 			    options_rejected:
 				snprintf(err_buf, sizeof err_buf,
 				    "Your options have been rejected by the server.\n");
@@ -1438,10 +1444,12 @@ int parse_arguments(int *argc, const cha
 			if (sanitize_paths)
 				files_from = sanitize_path(NULL, files_from, NULL, 0, NULL);
 			if (server_filter_list.head) {
+				char *dir;
 				if (!*files_from)
 					goto options_rejected;
-				clean_fname(files_from, 1);
-				if (check_filter(&server_filter_list, files_from, 0) < 0)
+				dir = files_from + (*files_from == '/' ? module_dirlen : 0);
+				clean_fname(dir, 1);
+				if (check_filter(&server_filter_list, dir, 0) < 0)
 					goto options_rejected;
 			}
 			filesfrom_fd = open(files_from, O_RDONLY|O_BINARY);
