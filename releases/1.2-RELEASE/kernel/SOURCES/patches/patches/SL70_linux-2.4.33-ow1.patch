diff -urpPX nopatch linux-2.4.33/Documentation/Configure.help linux/Documentation/Configure.help
--- linux-2.4.33/Documentation/Configure.help	Sat Aug 12 08:48:38 2006
+++ linux/Documentation/Configure.help	Sat Aug 12 08:51:47 2006
@@ -4690,6 +4690,12 @@ CONFIG_BINFMT_ELF
   ld.so (check the file <file:Documentation/Changes> for location and
   latest version).
 
+ELF binaries with a.out format interpreters or a.out libraries
+CONFIG_BINFMT_ELF_AOUT
+  The kernel may support ELF executables which use an a.out format
+  interpreter (dynamic linker) and/or a.out shared libraries, in
+  addition to the usual ELF-ELF setups. You shouldn't need this.
+
 Kernel support for a.out binaries
 CONFIG_BINFMT_AOUT
   A.out (Assembler.OUTput) is a set of formats for libraries and
@@ -4703,13 +4709,11 @@ CONFIG_BINFMT_AOUT
   warrant removing support. However its removal is a good idea if you
   wish to ensure that absolutely none of your programs will use this
   older executable format. If you don't know what to answer at this
-  point then answer Y. If someone told you "You need a kernel with
+  point then answer N. If someone told you "You need a kernel with
   QMAGIC support" then you'll have to say Y here. You may answer M to
   compile a.out support as a module and later load the module when you
   want to use a program or library in a.out format. The module will be
-  called binfmt_aout.o. Saying M or N here is dangerous though,
-  because some crucial programs on your system might still be in A.OUT
-  format.
+  called binfmt_aout.o.
 
 OSF/1 v4 readv/writev compatibility
 CONFIG_OSF4_COMPAT
@@ -29074,6 +29078,96 @@ CONFIG_SOUND_WM97XX
   say M here.  The module will be called ac97_plugin_wm97xx.o.
   
   If unsure, say N.
+
+Non-executable user stack area
+CONFIG_HARDEN_STACK
+  Most buffer overflow exploits are based on overwriting a function's
+  return address on the stack to point to some arbitrary code, which is
+  also put onto the stack. If the stack area is non-executable, buffer
+  overflow vulnerabilities become harder to exploit. However, a few
+  programs depend on the stack being executable, and might stop working
+  unless you also enable GCC trampolines autodetection and emulation
+  below, or enable the stack area execution permission for every such
+  program separately using chstk.c. If you don't know what all this is
+  about, or don't care about security that much, say N.
+
+Autodetect and emulate GCC trampolines
+CONFIG_HARDEN_STACK_SMART
+  GCC generates trampolines on the stack to correctly pass control to
+  nested functions when calling from outside. Normally, this requires
+  the stack being executable. When this option is enabled, the kernel
+  will trap faults resulting from trampoline calls, and will emulate the
+  trampolines. However, in some cases this autodetection can be fooled
+  in a buffer overflow exploit, so, if you've got no programs that use
+  GCC trampolines, it is more secure to disable this option. If you're
+  too lazy to find that out, answer Y. Note: if you're using glibc 2.0.x
+  (and not libc 5 or glibc 2.1+), you have to say Y here, or the system
+  won't even boot.
+
+Restricted links in /tmp
+CONFIG_HARDEN_LINK
+  There's a very common attack that involves a malicious user creating
+  a symbolic link in /tmp, with a carefully chosen name, pointing at
+  another user's file. When the victim then writes to that file name,
+  without the required precautions, they inadvertently write to the
+  wrong file. Enabling this option reduces the impact of this class of
+  holes (some get fixed, many others allow for DoS attacks only, most
+  of the rest become harder to exploit) by preventing a process from
+  following a link which is in a +t directory, unless the link owner
+  is trusted (that is, it's the user we're running as or the directory
+  owner). To prevent from using a hard link in an attack instead, this
+  option does not allow users to create hard links to files they don't
+  own, unless they could read and write the file. This might break
+  things. Say Y if security is more important.
+
+Restricted FIFOs in /tmp
+CONFIG_HARDEN_FIFO
+  In addition to restricting links, you might also want to restrict
+  writes into untrusted FIFOs (named pipes), to make data spoofing
+  attacks harder. Enabling this option disallows writing into FIFOs
+  not owned by the user in +t directories, unless the owner is the
+  same as that of the directory or the FIFO is opened without the
+  O_CREAT flag.
+
+Restricted /proc
+CONFIG_HARDEN_PROC
+  This option restricts the permissions on directories in /proc so
+  that non-root users can see their own processes only, and nothing
+  about active network connections, unless they're in a special group.
+  This group's id is specified via the gid= mount option, and is 0 by
+  default. (Note: if you're using identd, you will need to edit the
+  inetd.conf line to run identd as this special group.) Also, this
+  disables dmesg(8) for the users. You might want to use this on an ISP
+  shell server where privacy is an issue.
+
+Enforce RLIMIT_NPROC on execve(2)
+CONFIG_HARDEN_RLIMIT_NPROC
+  Linux lets you set a limit on how many processes a user can have, via
+  a setrlimit(2) call with RLIMIT_NPROC. Unfortunately, this limit is
+  only looked at when a new process is created on fork(2). If a process
+  changes its UID, it might exceed the limit for its new UID. This is
+  not a security issue by itself, as changing the UID is a privileged
+  operation. However, there're privileged programs that want to switch
+  to a user's context, including setting up some resource limits. The
+  only fork(2) required (if at all) is done before switching the UID,
+  and thus doesn't result in a check against RLIMIT_NPROC. Enable this
+  option to enforce RLIMIT_NPROC on execve(2) calls.
+
+Destroy shared memory segments not in use
+CONFIG_HARDEN_SHM
+  Linux lets you set resource limits, including on how much memory one
+  process can consume, via setrlimit(2). Unfortunately, shared memory
+  segments are allowed to exist without association with any process,
+  and thus might not be counted against any resource limits. This option
+  automatically destroys shared memory segments when their attach count
+  becomes zero after a detach or a process termination. It will also
+  destroy segments that were created, but never attached to, on exit from
+  the process. (In case you're curious, the only use left for IPC_RMID is
+  to immediately destroy an unattached segment.) Of course, this breaks
+  the way things are defined, so some applications might stop working.
+  Note that this feature will do you no good unless you also configure
+  your resource limits (in particular, RLIMIT_AS and RLIMIT_NPROC). Most
+  systems don't need this.
 
 #
 # A couple of things I keep forgetting:
diff -urpPX nopatch linux-2.4.33/arch/alpha/config.in linux/arch/alpha/config.in
--- linux-2.4.33/arch/alpha/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/alpha/config.in	Sat Aug 12 08:51:47 2006
@@ -315,6 +315,9 @@ if [ "$CONFIG_BINFMT_AOUT" != "n" ]; the
 fi
 
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 tristate 'Kernel support for Linux/Intel ELF binaries' CONFIG_BINFMT_EM86
 source drivers/parport/Config.in
@@ -435,6 +438,8 @@ endmenu
 source drivers/usb/Config.in
 
 source net/bluetooth/Config.in
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/alpha/defconfig linux/arch/alpha/defconfig
--- linux-2.4.33/arch/alpha/defconfig	Wed Feb 18 16:36:30 2004
+++ linux/arch/alpha/defconfig	Sat Aug 12 08:51:47 2006
@@ -72,6 +72,7 @@ CONFIG_KCORE_ELF=y
 # CONFIG_KCORE_AOUT is not set
 # CONFIG_BINFMT_AOUT is not set
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_BINFMT_EM86 is not set
 
@@ -786,6 +787,15 @@ CONFIG_VGA_CONSOLE=y
 # Bluetooth support
 #
 # CONFIG_BLUEZ is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/alpha/kernel/osf_sys.c linux/arch/alpha/kernel/osf_sys.c
--- linux-2.4.33/arch/alpha/kernel/osf_sys.c	Fri Jun 13 18:51:29 2003
+++ linux/arch/alpha/kernel/osf_sys.c	Sat Aug 12 08:51:47 2006
@@ -1346,6 +1346,8 @@ arch_get_unmapped_area(struct file *filp
 
 	if (len > limit)
 		return -ENOMEM;
+	if (addr >= limit)
+		return -ENOMEM;
 
 	/* First, see if the given suggestion fits.
 
diff -urpPX nopatch linux-2.4.33/arch/arm/config.in linux/arch/arm/config.in
--- linux-2.4.33/arch/arm/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/arm/config.in	Sat Aug 12 08:51:47 2006
@@ -499,6 +499,9 @@ choice 'Kernel core (/proc/kcore) format
 	 A.OUT		CONFIG_KCORE_AOUT" ELF
 tristate 'Kernel support for a.out binaries' CONFIG_BINFMT_AOUT
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 dep_bool 'Power Management support (experimental)' CONFIG_PM $CONFIG_EXPERIMENTAL
 dep_tristate 'RISC OS personality' CONFIG_ARTHUR $CONFIG_CPU_32
@@ -696,6 +699,8 @@ source drivers/usb/Config.in
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
    source net/bluetooth/Config.in
 fi
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/arm/defconfig linux/arch/arm/defconfig
--- linux-2.4.33/arch/arm/defconfig	Wed Feb 18 16:36:30 2004
+++ linux/arch/arm/defconfig	Sat Aug 12 08:51:47 2006
@@ -83,8 +83,9 @@ CONFIG_SYSCTL=y
 CONFIG_NWFPE=y
 CONFIG_KCORE_ELF=y
 # CONFIG_KCORE_AOUT is not set
-CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_PM is not set
 # CONFIG_ARTHUR is not set
@@ -498,6 +499,15 @@ CONFIG_VGA_CONSOLE=y
 # USB support
 #
 # CONFIG_USB is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/cris/config.in linux/arch/cris/config.in
--- linux-2.4.33/arch/cris/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/cris/config.in	Sat Aug 12 08:51:47 2006
@@ -31,6 +31,9 @@ bool 'BSD Process Accounting' CONFIG_BSD
 bool 'Sysctl support' CONFIG_SYSCTL
 
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 
 string 'Kernel command line' CONFIG_ETRAX_CMDLINE "root=/dev/mtdblock3"
 
@@ -261,6 +264,8 @@ fi
 endmenu
 
 source drivers/usb/Config.in
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/cris/defconfig linux/arch/cris/defconfig
--- linux-2.4.33/arch/cris/defconfig	Wed Feb 18 16:36:30 2004
+++ linux/arch/cris/defconfig	Sat Aug 12 08:51:47 2006
@@ -18,6 +18,7 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_SYSCTL is not set
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_ETRAX_KGDB is not set
 # CONFIG_ETRAX_WATCHDOG is not set
 
@@ -512,6 +513,15 @@ CONFIG_MSDOS_PARTITION=y
 # USB support
 #
 # CONFIG_USB is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/i386/config.in linux/arch/i386/config.in
--- linux-2.4.33/arch/i386/config.in	Sat Aug 12 08:48:37 2006
+++ linux/arch/i386/config.in	Sat Aug 12 08:51:47 2006
@@ -329,6 +329,9 @@ if [ "$CONFIG_PROC_FS" = "y" ]; then
 fi
 tristate 'Kernel support for a.out binaries' CONFIG_BINFMT_AOUT
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'Select task to kill on out of memory condition' CONFIG_OOM_KILLER
 
@@ -468,6 +471,18 @@ endmenu
 source drivers/usb/Config.in
 
 source net/bluetooth/Config.in
+
+mainmenu_option next_comment
+comment 'Security options'
+
+bool 'Non-executable user stack area' CONFIG_HARDEN_STACK
+if [ "$CONFIG_HARDEN_STACK" = "y" ]; then
+   bool '  Autodetect and emulate GCC trampolines' CONFIG_HARDEN_STACK_SMART
+fi
+
+source security/Common.in
+
+endmenu
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/i386/defconfig linux/arch/i386/defconfig
--- linux-2.4.33/arch/i386/defconfig	Wed Jan 19 17:09:25 2005
+++ linux/arch/i386/defconfig	Sat Aug 12 08:51:47 2006
@@ -115,9 +115,10 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_KCORE_ELF=y
 # CONFIG_KCORE_AOUT is not set
-CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
 CONFIG_BINFMT_ELF=y
-CONFIG_BINFMT_MISC=y
+# CONFIG_BINFMT_ELF_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
 CONFIG_PM=y
 # CONFIG_APM is not set
@@ -930,6 +931,17 @@ CONFIG_USB_STORAGE=y
 # Bluetooth support
 #
 # CONFIG_BLUEZ is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_STACK=y
+CONFIG_HARDEN_STACK_SMART=y
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/i386/kernel/head.S linux/arch/i386/kernel/head.S
--- linux-2.4.33/arch/i386/kernel/head.S	Fri Nov 28 21:26:19 2003
+++ linux/arch/i386/kernel/head.S	Sat Aug 12 08:51:47 2006
@@ -433,7 +433,11 @@ ENTRY(gdt_table)
 	.quad 0x0000000000000000	/* not used */
 	.quad 0x00cf9a000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
 	.quad 0x00cf92000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
+#ifdef CONFIG_HARDEN_STACK
+	.quad 0x00cbfa000000f7ff	/* 0x23 user   3GB-8MB code at 0 */
+#else
 	.quad 0x00cffa000000ffff	/* 0x23 user   4GB code at 0x00000000 */
+#endif
 	.quad 0x00cff2000000ffff	/* 0x2b user   4GB data at 0x00000000 */
 	.quad 0x0000000000000000	/* not used */
 	.quad 0x0000000000000000	/* not used */
diff -urpPX nopatch linux-2.4.33/arch/i386/kernel/signal.c linux/arch/i386/kernel/signal.c
--- linux-2.4.33/arch/i386/kernel/signal.c	Wed Nov 17 14:54:21 2004
+++ linux/arch/i386/kernel/signal.c	Sat Aug 12 08:51:47 2006
@@ -421,11 +421,15 @@ static void setup_frame(int sig, struct 
 	if (ka->sa.sa_flags & SA_RESTORER) {
 		err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);
 	} else {
+#ifdef CONFIG_HARDEN_STACK
+		err |= __put_user(MAGIC_SIGRETURN, &frame->pretcode);
+#else
 		err |= __put_user(frame->retcode, &frame->pretcode);
 		/* This is popl %eax ; movl $,%eax ; int $0x80 */
 		err |= __put_user(0xb858, (short *)(frame->retcode+0));
 		err |= __put_user(__NR_sigreturn, (int *)(frame->retcode+2));
 		err |= __put_user(0x80cd, (short *)(frame->retcode+6));
+#endif
 	}
 
 	if (err)
@@ -496,11 +500,15 @@ static void setup_rt_frame(int sig, stru
 	if (ka->sa.sa_flags & SA_RESTORER) {
 		err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);
 	} else {
+#ifdef CONFIG_HARDEN_STACK
+		err |= __put_user(MAGIC_RT_SIGRETURN, &frame->pretcode);
+#else
 		err |= __put_user(frame->retcode, &frame->pretcode);
 		/* This is movl $,%eax ; int $0x80 */
 		err |= __put_user(0xb8, (char *)(frame->retcode+0));
 		err |= __put_user(__NR_rt_sigreturn, (int *)(frame->retcode+1));
 		err |= __put_user(0x80cd, (short *)(frame->retcode+5));
+#endif
 	}
 
 	if (err)
diff -urpPX nopatch linux-2.4.33/arch/i386/kernel/traps.c linux/arch/i386/kernel/traps.c
--- linux-2.4.33/arch/i386/kernel/traps.c	Sat Nov 26 09:02:41 2005
+++ linux/arch/i386/kernel/traps.c	Sat Aug 12 08:51:47 2006
@@ -397,13 +397,209 @@ DO_ERROR(11, SIGBUS,  "segment not prese
 DO_ERROR(12, SIGBUS,  "stack segment", stack_segment)
 DO_ERROR_INFO(17, SIGBUS, "alignment check", alignment_check, BUS_ADRALN, get_cr2())
 
+#if defined(CONFIG_HARDEN_STACK) && defined(CONFIG_HARDEN_STACK_SMART)
+/*
+ * These two functions aren't performance critical (trampolines are
+ * extremely rare and slow even without emulation).
+ */
+static unsigned long *get_reg(struct pt_regs *regs, unsigned char regnum)
+{
+	switch (regnum) {
+		case 0: return &regs->eax;
+		case 1: return &regs->ecx;
+		case 2: return &regs->edx;
+		case 3: return &regs->ebx;
+		case 4: return &regs->esp;
+		case 5: return &regs->ebp;
+		case 6: return &regs->esi;
+		case 7: return &regs->edi;
+	}
+
+	return NULL;
+}
+
+static unsigned long get_modrm(struct pt_regs *regs, int *err)
+{
+	unsigned char modrm, sib;
+	signed char rel8;
+	unsigned long rel32;
+	int size, regnum, scale;
+	unsigned long index, base, addr, value;
+
+	*err |= __get_user(modrm, (unsigned char *)(regs->eip + 1));
+	size = 2;
+	regnum = modrm & 7;
+	index = 0;
+	addr = *get_reg(regs, regnum);
+	if (regnum == 4 && (modrm & 0xC0) != 0xC0) {
+		*err |= __get_user(sib, (unsigned char *)(regs->eip + 2));
+		size = 3;
+		scale = sib >> 6;
+		regnum = (sib >> 3) & 7;
+		if (regnum != 4)
+			index = *get_reg(regs, regnum) << scale;
+		regnum = sib & 7;
+		base = *get_reg(regs, regnum);
+		addr = base + index;
+	}
+
+	switch (modrm & 0xC0) {
+	case 0x00:
+		if (regnum == 5) {
+			*err |= __get_user(base,
+				(unsigned long *)(regs->eip + size));
+			size += 4;
+			addr = base + index;
+		}
+		*err |= get_user(value, (unsigned long *)addr);
+		break;
+
+	case 0x40:
+		*err |= __get_user(rel8, (signed char *)(regs->eip + size));
+		size++;
+		addr += rel8;
+		*err |= get_user(value, (unsigned long *)addr);
+		break;
+
+	case 0x80:
+		*err |= __get_user(rel32, (unsigned long *)(regs->eip + size));
+		size += 4;
+		addr += rel32;
+		*err |= get_user(value, (unsigned long *)addr);
+		break;
+
+	case 0xC0:
+	default:
+		value = addr;
+	}
+
+	if (*err) return 0;
+	regs->eip += size;
+	return value;
+}
+#endif
+
 asmlinkage void do_general_protection(struct pt_regs * regs, long error_code)
 {
+#ifdef CONFIG_HARDEN_STACK
+	unsigned long addr;
+	unsigned char insn;
+#ifdef CONFIG_HARDEN_STACK_SMART
+	int err, count;
+#endif
+#endif
+
 	if (regs->eflags & VM_MASK)
 		goto gp_in_vm86;
 
 	if (!(regs->xcs & 3))
 		goto gp_in_kernel;
+
+#ifdef CONFIG_HARDEN_STACK
+	if ((regs->xcs & 0xFFFF) != __USER_CS ||
+	    __get_user(insn, (unsigned char *)regs->eip))
+		goto gp_in_user;
+
+/* Check if it was a return instruction */
+	if (insn == 0xC3) {
+		if (get_user(addr, (unsigned long *)regs->esp))
+			goto gp_in_user;
+
+/* Check if it was return from a signal handler */
+		if ((addr & ~4UL) == MAGIC_RT_SIGRETURN) {
+/* Call sys_sigreturn() or sys_rt_sigreturn() to restore the context */
+			regs->esp += addr - (MAGIC_RT_SIGRETURN - 4);
+			__asm__("movl %3,%%esi\n\t"
+				"subl %1,%%esp\n\t"
+				"movl %2,%%ecx\n\t"
+				"movl %%esp,%%edi\n\t"
+				"rep; movsl\n\t"
+				"testl $4,%4\n\t"
+				"jz 1f\n\t"
+				"call sys_sigreturn\n\t"
+				"leal %3,%%edi\n\t"
+				"jmp 2f\n\t"
+				"1:\n\t"
+				"call sys_rt_sigreturn\n\t"
+				"leal %3,%%edi\n\t"
+				"2:\n\t"
+				"addl %1,%%edi\n\t"
+				"movl %%esp,%%esi\n\t"
+				"movl %2,%%ecx\n\t"
+				"movl (%%edi),%%edi\n\t"
+				"rep; movsl\n\t"
+				"movl %%esi,%%esp"
+			:
+/* %eax is returned separately */
+			"=a" (regs->eax)
+			:
+			"i" (sizeof(*regs)),
+			"i" (sizeof(*regs) >> 2),
+			"m" (regs),
+			"r" (addr)
+			:
+			"cx", "dx", "si", "di", "cc", "memory");
+			return;
+		}
+
+/*
+ * Check if we're returning to the stack area, which is only likely to happen
+ * when attempting to exploit a buffer overflow.
+ */
+		if (addr >= PAGE_OFFSET - _STK_LIM && addr < PAGE_OFFSET)
+			security_alert("return onto stack "
+				"from 0x%08lx to 0x%08lx running as "
+				"UID %d, EUID %d, process %s:%d",
+				"returns onto stack",
+				regs->eip, addr,
+				current->uid, current->euid,
+				current->comm, current->pid);
+	}
+
+#ifdef CONFIG_HARDEN_STACK_SMART
+/* Check if it could have been a trampoline call */
+	else
+	if (insn == 0xFF &&
+	    !__get_user(insn, (unsigned char *)(regs->eip + 1)) &&
+	    (insn & 0x38) == 0x10 && insn != 0xD4) {	/* call mod r/m */
+/* First, emulate the call */
+		err = 0;
+		addr = get_modrm(regs, &err);
+		if (!err) {
+			regs->esp -= 4;
+			err = put_user(regs->eip, (unsigned long *)regs->esp);
+			regs->eip = addr;
+		}
+/* Then, start emulating the trampoline itself */
+		count = 0;
+		while (!err && !__get_user(insn, (unsigned char *)regs->eip++))
+		if ((insn & 0xF8) == 0xB8) {		/* movl imm32,%reg */
+/* We only have 8 GP registers, no reason to initialize one twice */
+			if (count++ >= 8) break;
+			err |= __get_user(addr, (unsigned long *)regs->eip);
+			regs->eip += 4;
+			*get_reg(regs, insn & 7) = addr;
+		} else
+		if (insn == 0xFF) {
+			err |= __get_user(insn, (unsigned char *)regs->eip);
+			if ((insn & 0xF8) == 0xE0) {	/* jmp *%reg */
+				regs->eip = *get_reg(regs, insn & 7);
+				if (err) break; else return;
+			}
+			break;
+		} else
+		if (insn == 0xE9) {			/* jmp rel32 */
+			err |= __get_user(addr, (unsigned long *)regs->eip);
+			if (err) break;
+			regs->eip += 4 + addr;
+			return;
+		} else
+			break;
+	}
+#endif
+
+gp_in_user:
+#endif
 
 	current->thread.error_code = error_code;
 	current->thread.trap_no = 13;
diff -urpPX nopatch linux-2.4.33/arch/ia64/config.in linux/arch/ia64/config.in
--- linux-2.4.33/arch/ia64/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/ia64/config.in	Sat Aug 12 08:51:47 2006
@@ -124,6 +124,9 @@ bool 'System V IPC' CONFIG_SYSVIPC
 bool 'BSD Process Accounting' CONFIG_BSD_PROCESS_ACCT
 bool 'Sysctl support' CONFIG_SYSCTL
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 
 if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
@@ -288,6 +291,7 @@ if [ "$CONFIG_IA64_HP_SIM" != "n" -o "$C
   endmenu
 fi
 
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/ia64/defconfig linux/arch/ia64/defconfig
--- linux-2.4.33/arch/ia64/defconfig	Mon Apr  4 05:42:19 2005
+++ linux/arch/ia64/defconfig	Sat Aug 12 08:51:47 2006
@@ -60,6 +60,7 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
 CONFIG_ACPI=y
 CONFIG_ACPI_EFI=y
@@ -1016,6 +1017,15 @@ CONFIG_USB_HIDDEV=y
 # CONFIG_HP_SIMETH is not set
 # CONFIG_HP_SIMSERIAL is not set
 # CONFIG_HP_SIMSCSI is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/m68k/config.in linux/arch/m68k/config.in
--- linux-2.4.33/arch/m68k/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/m68k/config.in	Sat Aug 12 08:51:47 2006
@@ -99,6 +99,9 @@ if [ "$CONFIG_PROC_FS" = "y" ]; then
 fi
 tristate 'Kernel support for a.out binaries' CONFIG_BINFMT_AOUT
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 
 if [ "$CONFIG_AMIGA" = "y" ]; then
@@ -540,6 +543,8 @@ if [ "$CONFIG_VT" = "y" ]; then
    source drivers/video/Config.in
    endmenu
 fi
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/m68k/defconfig linux/arch/m68k/defconfig
--- linux-2.4.33/arch/m68k/defconfig	Wed Feb 18 16:36:30 2004
+++ linux/arch/m68k/defconfig	Sat Aug 12 08:51:47 2006
@@ -44,8 +44,9 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_KCORE_ELF=y
 # CONFIG_KCORE_AOUT is not set
-CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
 CONFIG_ZORRO=y
 # CONFIG_AMIGA_PCMCIA is not set
@@ -321,6 +322,15 @@ CONFIG_FBCON_ILBM=y
 CONFIG_FONT_8x8=y
 CONFIG_FONT_8x16=y
 CONFIG_FONT_PEARL_8x8=y
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/mips/config-shared.in linux/arch/mips/config-shared.in
--- linux-2.4.33/arch/mips/config-shared.in	Wed Jan 19 17:09:27 2005
+++ linux/arch/mips/config-shared.in	Sat Aug 12 08:51:47 2006
@@ -845,6 +845,9 @@ define_bool CONFIG_KCORE_ELF y
 define_bool CONFIG_KCORE_AOUT n
 define_bool CONFIG_BINFMT_AOUT n
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 dep_bool 'Kernel support for Linux/MIPS 32-bit binary compatibility' CONFIG_MIPS32_COMPAT $CONFIG_MIPS64
 dep_bool 'Kernel support for o32 binaries' CONFIG_MIPS32_O32 $CONFIG_MIPS32_COMPAT
 dep_bool 'Kernel support for n32 binaries' CONFIG_MIPS32_N32 $CONFIG_MIPS32_COMPAT
@@ -1005,6 +1008,8 @@ endmenu
 source drivers/usb/Config.in
 
 source net/bluetooth/Config.in
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/mips/defconfig linux/arch/mips/defconfig
--- linux-2.4.33/arch/mips/defconfig	Wed Jan 19 17:09:27 2005
+++ linux/arch/mips/defconfig	Sat Aug 12 08:51:47 2006
@@ -143,6 +143,7 @@ CONFIG_KCORE_ELF=y
 # CONFIG_KCORE_AOUT is not set
 # CONFIG_BINFMT_AOUT is not set
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_MIPS32_COMPAT is not set
 # CONFIG_MIPS32_O32 is not set
 # CONFIG_MIPS32_N32 is not set
@@ -723,6 +724,15 @@ CONFIG_SOUND_HAL2=y
 # Bluetooth support
 #
 # CONFIG_BLUEZ is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/mips/kernel/irixelf.c linux/arch/mips/kernel/irixelf.c
--- linux-2.4.33/arch/mips/kernel/irixelf.c	Wed Jan 19 17:09:29 2005
+++ linux/arch/mips/kernel/irixelf.c	Sat Aug 12 08:51:47 2006
@@ -8,6 +8,7 @@
  * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 
 #include <linux/fs.h>
@@ -48,7 +49,12 @@ static int irix_core_dump(long signr, st
 extern int dump_fpu (elf_fpregset_t *);
 
 static struct linux_binfmt irix_format = {
-	NULL, THIS_MODULE, load_irix_binary, load_irix_library,
+	NULL, THIS_MODULE, load_irix_binary,
+#ifdef CONFIG_BINFMT_ELF_AOUT
+	load_irix_library,
+#else
+	NULL,
+#endif
 	irix_core_dump, PAGE_SIZE
 };
 
@@ -794,6 +800,7 @@ out_free_ph:
 	goto out;
 }
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 /* This is really simpleminded and specialized - we are loading an
  * a.out library that is given an ELF header.
  */
@@ -873,6 +880,7 @@ static int load_irix_library(struct file
 	kfree(elf_phdata);
 	return 0;
 }
+#endif
 
 /* Called through irix_syssgi() to map an elf image given an FD,
  * a phdr ptr USER_PHDRP in userspace, and a count CNT telling how many
diff -urpPX nopatch linux-2.4.33/arch/mips64/defconfig linux/arch/mips64/defconfig
--- linux-2.4.33/arch/mips64/defconfig	Wed Jan 19 17:09:30 2005
+++ linux/arch/mips64/defconfig	Sat Aug 12 08:51:47 2006
@@ -147,6 +147,7 @@ CONFIG_KCORE_ELF=y
 # CONFIG_KCORE_AOUT is not set
 # CONFIG_BINFMT_AOUT is not set
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 CONFIG_MIPS32_COMPAT=y
 CONFIG_MIPS32_O32=y
 # CONFIG_MIPS32_N32 is not set
@@ -896,6 +897,15 @@ CONFIG_NLS_UTF8=m
 # Bluetooth support
 #
 # CONFIG_BLUEZ is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/mips64/kernel/linux32.c linux/arch/mips64/kernel/linux32.c
--- linux-2.4.33/arch/mips64/kernel/linux32.c	Mon Apr  4 05:42:19 2005
+++ linux/arch/mips64/kernel/linux32.c	Sat Aug 12 08:51:47 2006
@@ -398,6 +398,22 @@ int do_execve32(char * filename, u32 * a
 	if (IS_ERR(dentry))
 		return retval;
 
+#ifdef CONFIG_HARDEN_RLIMIT_NPROC
+/*
+ * This check is similar to that done in kernel/fork.c, except that we
+ * are not going to allocate a new task slot here.
+ *
+ * Note that we can only exceed the limit if our UID has changed.
+ */
+	if (current->user)
+	if (atomic_read(&current->user->processes) >
+	    current->rlim[RLIMIT_NPROC].rlim_cur &&
+	    !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE)) {
+		dput(dentry);
+		return -EAGAIN;
+	}
+#endif
+
 	bprm.dentry = dentry;
 	bprm.filename = filename;
 	bprm.sh_bang = 0;
@@ -1155,8 +1171,11 @@ sys32_readv(int fd, struct iovec32 *vect
 	if (!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_READ) &&
-	    (file->f_op->readv || file->f_op->read))
+	    (file->f_op->readv || file->f_op->read)) {
+		file_pos_lock(file);
 		ret = do_readv_writev32(VERIFY_WRITE, file, vector, count);
+		file_pos_unlock(file);
+	}
 
 	fput(file);
 
@@ -1175,8 +1194,11 @@ sys32_writev(int fd, struct iovec32 *vec
 	if(!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_WRITE) &&
-	    (file->f_op->writev || file->f_op->write))
+	    (file->f_op->writev || file->f_op->write)) {
+		file_pos_lock(file);
 	        ret = do_readv_writev32(VERIFY_READ, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
@@ -1201,17 +1223,20 @@ asmlinkage ssize_t sys32_pread(unsigned 
 		goto bad_file;
 	if (!(file->f_mode & FMODE_READ))
 		goto out;
-	pos = merge_64(a4, a5);
-	ret = locks_verify_area(FLOCK_VERIFY_READ, file->f_dentry->d_inode,
-				file, pos, count);
-	if (ret)
-		goto out;
 	ret = -EINVAL;
 	if (!file->f_op || !(read = file->f_op->read))
 		goto out;
+	pos = merge_64(a4, a5);
 	if (pos < 0)
 		goto out;
+	ret = locks_verify_area(FLOCK_VERIFY_READ, file->f_dentry->d_inode,
+				file, pos, count);
+	if (ret)
+		goto out;
+	/* XXX: for broken drivers which use file->f_pos instead of *ppos */
+	file_pos_lock(file);
 	ret = read(file, buf, count, &pos);
+	file_pos_unlock(file);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_ACCESS);
 out:
@@ -1234,18 +1259,21 @@ asmlinkage ssize_t sys32_pwrite(unsigned
 		goto bad_file;
 	if (!(file->f_mode & FMODE_WRITE))
 		goto out;
-	pos = merge_64(a4, a5);
-	ret = locks_verify_area(FLOCK_VERIFY_WRITE, file->f_dentry->d_inode,
-				file, pos, count);
-	if (ret)
-		goto out;
 	ret = -EINVAL;
 	if (!file->f_op || !(write = file->f_op->write))
 		goto out;
+	pos = merge_64(a4, a5);
 	if (pos < 0)
 		goto out;
+	ret = locks_verify_area(FLOCK_VERIFY_WRITE, file->f_dentry->d_inode,
+				file, pos, count);
+	if (ret)
+		goto out;
 
+	/* XXX: for broken drivers which use file->f_pos instead of *ppos */
+	file_pos_lock(file);
 	ret = write(file, buf, count, &pos);
+	file_pos_unlock(file);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_MODIFY);
 out:
diff -urpPX nopatch linux-2.4.33/arch/parisc/config.in linux/arch/parisc/config.in
--- linux-2.4.33/arch/parisc/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/parisc/config.in	Sat Aug 12 08:51:47 2006
@@ -89,6 +89,9 @@ bool 'BSD Process Accounting' CONFIG_BSD
 bool 'Sysctl support' CONFIG_SYSCTL
 define_bool CONFIG_KCORE_ELF y
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for SOM binaries' CONFIG_BINFMT_SOM
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 
@@ -191,6 +194,8 @@ endmenu
 if [ "$CONFIG_SUPERIO" = "y" ]; then
     source drivers/usb/Config.in
 fi
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/parisc/defconfig linux/arch/parisc/defconfig
--- linux-2.4.33/arch/parisc/defconfig	Wed Feb 18 16:36:30 2004
+++ linux/arch/parisc/defconfig	Sat Aug 12 08:51:47 2006
@@ -56,6 +56,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_KCORE_ELF=y
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 CONFIG_BINFMT_SOM=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_PM is not set
@@ -781,6 +782,15 @@ CONFIG_SOUND_HARMONY=y
 # USB support
 #
 # CONFIG_USB is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/parisc/kernel/sys_parisc32.c linux/arch/parisc/kernel/sys_parisc32.c
--- linux-2.4.33/arch/parisc/kernel/sys_parisc32.c	Sat Aug 12 08:48:37 2006
+++ linux/arch/parisc/kernel/sys_parisc32.c	Sat Aug 12 08:51:47 2006
@@ -189,6 +189,23 @@ do_execve32(char * filename, u32 * argv,
 
 	DBG(("do_execve32(%s, %p, %p, %p)\n", filename, argv, envp, regs));
 
+#ifdef CONFIG_HARDEN_RLIMIT_NPROC
+/*
+ * This check is similar to that done in kernel/fork.c, except that we
+ * are not going to allocate a new task slot here.
+ *
+ * Note that we can only exceed the limit if our UID has changed.
+ */
+	if (current->user)
+	if (atomic_read(&current->user->processes) >
+	    current->rlim[RLIMIT_NPROC].rlim_cur &&
+	    !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE)) {
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+#endif
+
 	bprm.file = file;
 	bprm.filename = filename;
 	bprm.sh_bang = 0;
@@ -1738,8 +1755,11 @@ sys32_readv(int fd, struct iovec32 *vect
 	if (!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_READ) &&
-	    (file->f_op->readv || file->f_op->read))
+	    (file->f_op->readv || file->f_op->read)) {
+		file_pos_lock(file);
 		ret = do_readv_writev32(VERIFY_WRITE, file, vector, count);
+		file_pos_unlock(file);
+	}
 
 	fput(file);
 
@@ -1758,8 +1778,11 @@ sys32_writev(int fd, struct iovec32 *vec
 	if(!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_WRITE) &&
-	    (file->f_op->writev || file->f_op->write))
+	    (file->f_op->writev || file->f_op->write)) {
+		file_pos_lock(file);
 	        ret = do_readv_writev32(VERIFY_READ, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
diff -urpPX nopatch linux-2.4.33/arch/ppc/config.in linux/arch/ppc/config.in
--- linux-2.4.33/arch/ppc/config.in	Sun Aug  8 03:26:04 2004
+++ linux/arch/ppc/config.in	Sat Aug 12 08:51:47 2006
@@ -384,6 +384,7 @@ if [ "$CONFIG_PROC_FS" = "y" ]; then
 fi
 define_bool CONFIG_BINFMT_ELF y
 define_bool CONFIG_KERNEL_ELF y
+bool 'ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'Select task to kill on out of memory condition' CONFIG_OOM_KILLER
 
@@ -614,6 +615,8 @@ source net/bluetooth/Config.in
 
 source crypto/Config.in
 source lib/Config.in
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/ppc/defconfig linux/arch/ppc/defconfig
--- linux-2.4.33/arch/ppc/defconfig	Wed Jan 19 17:09:36 2005
+++ linux/arch/ppc/defconfig	Sat Aug 12 08:51:47 2006
@@ -59,7 +59,8 @@ CONFIG_SYSVIPC=y
 CONFIG_KCORE_ELF=y
 CONFIG_BINFMT_ELF=y
 CONFIG_KERNEL_ELF=y
-CONFIG_BINFMT_MISC=m
+# CONFIG_BINFMT_ELF_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
 CONFIG_PCI_NAMES=y
 CONFIG_HOTPLUG=y
@@ -1050,6 +1051,15 @@ CONFIG_USB_SERIAL_VISOR=m
 #
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/ppc64/config.in linux/arch/ppc64/config.in
--- linux-2.4.33/arch/ppc64/config.in	Wed Feb 18 16:36:30 2004
+++ linux/arch/ppc64/config.in	Sat Aug 12 08:51:47 2006
@@ -82,6 +82,9 @@ if [ "$CONFIG_PROC_FS" = "y" ]; then
 fi
 
 bool 'Kernel support for 64 bit ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 
 tristate 'Kernel support for 32 bit ELF binaries' CONFIG_BINFMT_ELF32
 
@@ -239,6 +242,8 @@ fi
 source lib/Config.in
 
 source crypto/Config.in
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/ppc64/defconfig linux/arch/ppc64/defconfig
--- linux-2.4.33/arch/ppc64/defconfig	Wed Nov 17 14:54:21 2004
+++ linux/arch/ppc64/defconfig	Sat Aug 12 08:51:47 2006
@@ -56,6 +56,7 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_KCORE_ELF=y
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_PCI_NAMES=y
@@ -766,6 +767,15 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # Cryptographic options
 #
 # CONFIG_CRYPTO is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/ppc64/kernel/sys_ppc32.c linux/arch/ppc64/kernel/sys_ppc32.c
--- linux-2.4.33/arch/ppc64/kernel/sys_ppc32.c	Sat Aug 12 08:48:37 2006
+++ linux/arch/ppc64/kernel/sys_ppc32.c	Sat Aug 12 08:51:47 2006
@@ -250,8 +250,11 @@ asmlinkage long sys32_readv(u32 fd, stru
 		goto bad_file;
 
 	if (file->f_op && (file->f_mode & FMODE_READ) &&
-     (file->f_op->readv || file->f_op->read))
+     (file->f_op->readv || file->f_op->read)) {
+		file_pos_lock(file);
 		ret = do_readv_writev32(VERIFY_WRITE, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
@@ -270,8 +273,11 @@ asmlinkage long sys32_writev(u32 fd, str
 	if(!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_WRITE) &&
-	   (file->f_op->writev || file->f_op->write))
+	   (file->f_op->writev || file->f_op->write)) {
+		file_pos_lock(file);
 		ret = do_readv_writev32(VERIFY_READ, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
@@ -3947,6 +3953,23 @@ static int do_execve32(char * filename, 
 	retval = PTR_ERR(file);
 	if (IS_ERR(file))
 		return retval;
+
+#ifdef CONFIG_HARDEN_RLIMIT_NPROC
+/*
+ * This check is similar to that done in kernel/fork.c, except that we
+ * are not going to allocate a new task slot here.
+ *
+ * Note that we can only exceed the limit if our UID has changed.
+ */
+	if (current->user)
+	if (atomic_read(&current->user->processes) >
+	    current->rlim[RLIMIT_NPROC].rlim_cur &&
+	    !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE)) {
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+#endif
 
 	bprm.file = file;
 	bprm.filename = filename;
diff -urpPX nopatch linux-2.4.33/arch/s390/config.in linux/arch/s390/config.in
--- linux-2.4.33/arch/s390/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/s390/config.in	Sat Aug 12 08:51:47 2006
@@ -58,6 +58,9 @@ bool 'BSD Process Accounting' CONFIG_BSD
 bool 'Sysctl support' CONFIG_SYSCTL
 define_bool CONFIG_KCORE_ELF y
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'Show crashed user process info' CONFIG_PROCESS_DEBUG
 bool 'Pseudo page fault support' CONFIG_PFAULT
@@ -71,6 +74,8 @@ if [ "$CONFIG_NET" = "y" ]; then
 fi
 
 source fs/Config.in
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/s390/defconfig linux/arch/s390/defconfig
--- linux-2.4.33/arch/s390/defconfig	Wed Jan 19 17:09:37 2005
+++ linux/arch/s390/defconfig	Sat Aug 12 08:51:47 2006
@@ -46,6 +46,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_KCORE_ELF=y
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_PROCESS_DEBUG is not set
 CONFIG_PFAULT=y
@@ -438,6 +439,15 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
 # CONFIG_NLS_UTF8 is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/s390x/config.in linux/arch/s390x/config.in
--- linux-2.4.33/arch/s390x/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/s390x/config.in	Sat Aug 12 08:51:47 2006
@@ -61,6 +61,9 @@ bool 'BSD Process Accounting' CONFIG_BSD
 bool 'Sysctl support' CONFIG_SYSCTL
 define_bool CONFIG_KCORE_ELF y
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'Show crashed user process info' CONFIG_PROCESS_DEBUG
 bool 'Pseudo page fault support' CONFIG_PFAULT
@@ -75,6 +78,8 @@ if [ "$CONFIG_NET" = "y" ]; then
 fi
 
 source fs/Config.in
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/s390x/defconfig linux/arch/s390x/defconfig
--- linux-2.4.33/arch/s390x/defconfig	Wed Nov 17 14:54:21 2004
+++ linux/arch/s390x/defconfig	Sat Aug 12 08:51:47 2006
@@ -47,6 +47,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_KCORE_ELF=y
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_PROCESS_DEBUG is not set
 CONFIG_PFAULT=y
@@ -382,6 +383,15 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
 # CONFIG_NLS_UTF8 is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/s390x/kernel/linux32.c linux/arch/s390x/kernel/linux32.c
--- linux-2.4.33/arch/s390x/kernel/linux32.c	Sat Aug 12 08:48:37 2006
+++ linux/arch/s390x/kernel/linux32.c	Sat Aug 12 08:51:47 2006
@@ -1196,8 +1196,11 @@ asmlinkage long sys32_readv(int fd, stru
 		goto bad_file;
 
 	if (file->f_op && (file->f_mode & FMODE_READ) &&
-	    (file->f_op->readv || file->f_op->read))
+	    (file->f_op->readv || file->f_op->read)) {
+		file_pos_lock(file);
 		ret = do_readv_writev32(VERIFY_WRITE, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
@@ -1213,8 +1216,11 @@ asmlinkage long sys32_writev(int fd, str
 	if(!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_WRITE) &&
-	    (file->f_op->writev || file->f_op->write))
+	    (file->f_op->writev || file->f_op->write)) {
+		file_pos_lock(file);
 		ret = do_readv_writev32(VERIFY_READ, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
@@ -3236,6 +3242,23 @@ do_execve32(char * filename, u32 * argv,
 	retval = PTR_ERR(file);
 	if (IS_ERR(file))
 		return retval;
+
+#ifdef CONFIG_HARDEN_RLIMIT_NPROC
+/*
+ * This check is similar to that done in kernel/fork.c, except that we
+ * are not going to allocate a new task slot here.
+ *
+ * Note that we can only exceed the limit if our UID has changed.
+ */
+	if (current->user)
+	if (atomic_read(&current->user->processes) >
+	    current->rlim[RLIMIT_NPROC].rlim_cur &&
+	    !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE)) {
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+#endif
 
 	bprm.file = file;
 	bprm.filename = filename;
diff -urpPX nopatch linux-2.4.33/arch/sh/config.in linux/arch/sh/config.in
--- linux-2.4.33/arch/sh/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/sh/config.in	Sat Aug 12 08:51:47 2006
@@ -283,6 +283,9 @@ if [ "$CONFIG_PROC_FS" = "y" ]; then
 	 A.OUT		CONFIG_KCORE_AOUT" ELF
 fi
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 
 bool 'Select task to kill on out of memory condition' CONFIG_OOM_KILLER
@@ -450,6 +453,8 @@ if [ "$CONFIG_SOUND" != "n" ]; then
    source drivers/sound/Config.in
 fi
 endmenu
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/sh/defconfig linux/arch/sh/defconfig
--- linux-2.4.33/arch/sh/defconfig	Wed Feb 18 16:36:30 2004
+++ linux/arch/sh/defconfig	Sat Aug 12 08:51:47 2006
@@ -48,6 +48,7 @@ CONFIG_CF_ENABLER=y
 CONFIG_KCORE_ELF=y
 # CONFIG_KCORE_AOUT is not set
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
 
 #
@@ -194,6 +195,15 @@ CONFIG_MSDOS_PARTITION=y
 # Sound
 #
 # CONFIG_SOUND is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/sparc/config.in linux/arch/sparc/config.in
--- linux-2.4.33/arch/sparc/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/sparc/config.in	Sat Aug 12 08:51:47 2006
@@ -74,6 +74,9 @@ if [ "$CONFIG_PROC_FS" = "y" ]; then
 fi
 tristate 'Kernel support for a.out binaries' CONFIG_BINFMT_AOUT
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'SunOS binary emulation' CONFIG_SUNOS_EMUL
 bool 'Select task to kill on out of memory condition' CONFIG_OOM_KILLER
@@ -263,6 +266,8 @@ comment 'Watchdog'
 
 tristate 'Software watchdog' CONFIG_SOFT_WATCHDOG
 endmenu
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/sparc/defconfig linux/arch/sparc/defconfig
--- linux-2.4.33/arch/sparc/defconfig	Wed Apr 14 17:05:27 2004
+++ linux/arch/sparc/defconfig	Sat Aug 12 08:51:47 2006
@@ -49,9 +49,10 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 CONFIG_KCORE_ELF=y
-CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
 CONFIG_BINFMT_ELF=y
-CONFIG_BINFMT_MISC=m
+# CONFIG_BINFMT_ELF_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
 CONFIG_SUNOS_EMUL=y
 # CONFIG_OOM_KILLER is not set
 
@@ -436,6 +437,15 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # Watchdog
 #
 # CONFIG_SOFT_WATCHDOG is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/sparc/kernel/sys_sparc.c linux/arch/sparc/kernel/sys_sparc.c
--- linux-2.4.33/arch/sparc/kernel/sys_sparc.c	Mon Aug 25 15:44:40 2003
+++ linux/arch/sparc/kernel/sys_sparc.c	Sat Aug 12 08:51:47 2006
@@ -52,6 +52,8 @@ unsigned long arch_get_unmapped_area(str
 	/* See asm-sparc/uaccess.h */
 	if (len > TASK_SIZE - PAGE_SIZE)
 		return -ENOMEM;
+	if (addr >= TASK_SIZE - PAGE_SIZE)
+		return -ENOMEM;
 	if (ARCH_SUN4C_SUN4 && len > 0x20000000)
 		return -ENOMEM;
 	if (!addr)
diff -urpPX nopatch linux-2.4.33/arch/sparc64/config.in linux/arch/sparc64/config.in
--- linux-2.4.33/arch/sparc64/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/sparc64/config.in	Sat Aug 12 08:51:47 2006
@@ -79,6 +79,9 @@ if [ "$CONFIG_SPARC32_COMPAT" != "n" ]; 
    bool '  Kernel support for 32-bit (ie. SunOS) a.out binaries' CONFIG_BINFMT_AOUT32
 fi
 bool 'Kernel support for 64-bit ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'SunOS binary emulation' CONFIG_SUNOS_EMUL
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
@@ -296,6 +299,8 @@ comment 'Watchdog'
 
 tristate 'Software watchdog' CONFIG_SOFT_WATCHDOG
 endmenu
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/sparc64/defconfig linux/arch/sparc64/defconfig
--- linux-2.4.33/arch/sparc64/defconfig	Wed Jan 19 17:09:38 2005
+++ linux/arch/sparc64/defconfig	Sat Aug 12 08:51:47 2006
@@ -70,7 +70,8 @@ CONFIG_SPARC32_COMPAT=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_AOUT32 is not set
 CONFIG_BINFMT_ELF=y
-CONFIG_BINFMT_MISC=m
+# CONFIG_BINFMT_ELF_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
 # CONFIG_SUNOS_EMUL is not set
 CONFIG_SOLARIS_EMUL=m
 # CONFIG_OOM_KILLER is not set
@@ -1103,6 +1104,15 @@ CONFIG_BLUEZ_HCIVHCI=m
 # Watchdog
 #
 # CONFIG_SOFT_WATCHDOG is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/sparc64/kernel/sys_sparc.c linux/arch/sparc64/kernel/sys_sparc.c
--- linux-2.4.33/arch/sparc64/kernel/sys_sparc.c	Mon Aug 25 15:44:40 2003
+++ linux/arch/sparc64/kernel/sys_sparc.c	Sat Aug 12 08:51:47 2006
@@ -63,6 +63,8 @@ unsigned long arch_get_unmapped_area(str
 		task_size = 0xf0000000UL;
 	if (len > task_size || len > -PAGE_OFFSET)
 		return -ENOMEM;
+	if (addr >= task_size)
+		return -ENOMEM;
 	if (!addr)
 		addr = TASK_UNMAPPED_BASE;
 
diff -urpPX nopatch linux-2.4.33/arch/sparc64/kernel/sys_sparc32.c linux/arch/sparc64/kernel/sys_sparc32.c
--- linux-2.4.33/arch/sparc64/kernel/sys_sparc32.c	Sat Aug 12 08:48:37 2006
+++ linux/arch/sparc64/kernel/sys_sparc32.c	Sat Aug 12 08:51:47 2006
@@ -1223,8 +1223,11 @@ asmlinkage long sys32_readv(int fd, stru
 		goto bad_file;
 
 	if (file->f_op && (file->f_mode & FMODE_READ) &&
-	    (file->f_op->readv || file->f_op->read))
+	    (file->f_op->readv || file->f_op->read)) {
+		file_pos_lock(file);
 		ret = do_readv_writev32(VERIFY_WRITE, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
@@ -1240,8 +1243,11 @@ asmlinkage long sys32_writev(int fd, str
 	if(!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_WRITE) &&
-	    (file->f_op->writev || file->f_op->write))
+	    (file->f_op->writev || file->f_op->write)) {
+		file_pos_lock(file);
 		ret = do_readv_writev32(VERIFY_READ, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
@@ -3283,6 +3289,23 @@ do_execve32(char * filename, u32 * argv,
 	retval = PTR_ERR(file);
 	if (IS_ERR(file))
 		return retval;
+
+#ifdef CONFIG_HARDEN_RLIMIT_NPROC
+/*
+ * This check is similar to that done in kernel/fork.c, except that we
+ * are not going to allocate a new task slot here.
+ *
+ * Note that we can only exceed the limit if our UID has changed.
+ */
+	if (current->user)
+	if (atomic_read(&current->user->processes) >
+	    current->rlim[RLIMIT_NPROC].rlim_cur &&
+	    !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE)) {
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+#endif
 
 	bprm.file = file;
 	bprm.filename = filename;
diff -urpPX nopatch linux-2.4.33/arch/x86_64/config.in linux/arch/x86_64/config.in
--- linux-2.4.33/arch/x86_64/config.in	Wed Nov 17 14:54:21 2004
+++ linux/arch/x86_64/config.in	Sat Aug 12 08:51:47 2006
@@ -118,6 +118,9 @@ if [ "$CONFIG_PROC_FS" = "y" ]; then
 fi
 #tristate 'Kernel support for a.out binaries' CONFIG_BINFMT_AOUT
 bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 
 bool 'Power Management support' CONFIG_PM
@@ -240,6 +243,8 @@ source drivers/usb/Config.in
 source net/bluetooth/Config.in
 
 source crypto/Config.in
+
+source security/Config.in
 
 mainmenu_option next_comment
 comment 'Kernel hacking'
diff -urpPX nopatch linux-2.4.33/arch/x86_64/defconfig linux/arch/x86_64/defconfig
--- linux-2.4.33/arch/x86_64/defconfig	Wed Apr 14 17:05:28 2004
+++ linux/arch/x86_64/defconfig	Sat Aug 12 08:51:47 2006
@@ -67,6 +67,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_KCORE_ELF=y
 CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
 CONFIG_PM=y
 CONFIG_IA32_EMULATION=y
@@ -748,6 +749,15 @@ CONFIG_VGA_CONSOLE=y
 # Cryptographic options
 #
 # CONFIG_CRYPTO is not set
+
+#
+# Security
+#
+CONFIG_HARDEN_LINK=y
+CONFIG_HARDEN_FIFO=y
+# CONFIG_HARDEN_PROC is not set
+CONFIG_HARDEN_RLIMIT_NPROC=y
+# CONFIG_HARDEN_SHM is not set
 
 #
 # Kernel hacking
diff -urpPX nopatch linux-2.4.33/arch/x86_64/kernel/sys_x86_64.c linux/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.4.33/arch/x86_64/kernel/sys_x86_64.c	Fri Nov 28 21:26:19 2003
+++ linux/arch/x86_64/kernel/sys_x86_64.c	Sat Aug 12 08:51:47 2006
@@ -94,6 +94,8 @@ unsigned long arch_get_unmapped_area(str
 	if (len > end)
 		return -ENOMEM;
 	addr = PAGE_ALIGN(addr);
+	if (addr >= end)
+		return -ENOMEM;
 
 	for (vma = find_vma(current->mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
diff -urpPX nopatch linux-2.4.33/fs/binfmt_aout.c linux/fs/binfmt_aout.c
--- linux-2.4.33/fs/binfmt_aout.c	Wed Jan 19 17:10:10 2005
+++ linux/fs/binfmt_aout.c	Sat Aug 12 08:51:47 2006
@@ -4,6 +4,7 @@
  *  Copyright (C) 1991, 1992, 1996  Linus Torvalds
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 
 #include <linux/sched.h>
@@ -315,6 +316,9 @@ static int load_aout_binary(struct linux
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
+#ifdef CONFIG_HARDEN_STACK
+	if (N_FLAGS(ex) & F_STACKEXEC) current->flags |= PF_STACKEXEC;
+#endif
 #ifdef __sparc__
 	if (N_MAGIC(ex) == NMAGIC) {
 		loff_t pos = fd_offset;
--- linux-2.4.33.3/fs/binfmt_elf.c.sl70.orig	2006-08-31 11:03:20.000000000 -0600
+++ linux-2.4.33.3/fs/binfmt_elf.c	2006-09-24 15:20:41.000000000 -0600
@@ -9,6 +9,7 @@
  * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 
 #include <linux/fs.h>
@@ -43,7 +44,9 @@
 #include <linux/elf.h>
 
 static int load_elf_binary(struct linux_binprm * bprm, struct pt_regs * regs);
+#ifdef CONFIG_BINFMT_ELF_AOUT
 static int load_elf_library(struct file*);
+#endif
 static unsigned long elf_map (struct file *, unsigned long, struct elf_phdr *, int, int);
 extern int dump_fpu (struct pt_regs *, elf_fpregset_t *);
 extern void dump_thread(struct pt_regs *, struct user *);
@@ -73,8 +76,17 @@ static int elf_core_dump(long signr, str
 #define ELF_PAGEOFFSET(_v) ((_v) & (ELF_MIN_ALIGN-1))
 #define ELF_PAGEALIGN(_v) (((_v) + ELF_MIN_ALIGN - 1) & ~(ELF_MIN_ALIGN - 1))
 
-static struct linux_binfmt elf_format = {
-	NULL, THIS_MODULE, load_elf_binary, load_elf_library, elf_core_dump, ELF_EXEC_PAGESIZE
+#ifndef CONFIG_HARDEN_STACK
+static
+#endif
+struct linux_binfmt elf_format = {
+       NULL, THIS_MODULE, load_elf_binary,   
+#ifdef CONFIG_BINFMT_ELF_AOUT
+       load_elf_library,
+#else
+       NULL,
+#endif
+       elf_core_dump, ELF_EXEC_PAGESIZE
 };
 
 #define BAD_ADDR(x)	((unsigned long)(x) >= TASK_SIZE)
@@ -232,6 +244,7 @@ create_elf_tables(char *p, int argc, int
 	}
 	__put_user(NULL, argv);
 	current->mm->arg_end = current->mm->env_start = (unsigned long) p;
+	current->mm->env_end = (unsigned long) p;
 	while (envc-->0) {
 		__put_user((elf_caddr_t)(unsigned long)p,envp++);
 		len = strnlen_user(p, PAGE_SIZE*MAX_ARG_PAGES);
@@ -404,6 +417,7 @@ out:
 	return error;
 }
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 static unsigned long load_aout_interp(struct exec * interp_ex,
 			     struct file * interpreter)
 {
@@ -451,6 +465,7 @@ static unsigned long load_aout_interp(st
 out:
 	return elf_entry;
 }
+#endif
 
 /*
  * These are the functions used to load ELF style executables and shared
@@ -458,7 +473,9 @@ out:
  */
 
 #define INTERPRETER_NONE 0
+#ifdef CONFIG_BINFMT_ELF_AOUT
 #define INTERPRETER_AOUT 1
+#endif
 #define INTERPRETER_ELF 2
 
 
@@ -482,7 +499,9 @@ static int load_elf_binary(struct linux_
 	struct elfhdr elf_ex;
 	struct elfhdr interp_elf_ex;
   	struct exec interp_ex;
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	char passed_fileno[6];
+#endif
 	struct files_struct *files;
 	
 	/* Get the exec-header */
@@ -612,6 +631,7 @@ static int load_elf_binary(struct linux_
 
 	/* Some simple consistency checks for the interpreter */
 	if (elf_interpreter) {
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		interpreter_type = INTERPRETER_ELF | INTERPRETER_AOUT;
 
 		/* Now figure out which format our binary is */
@@ -619,6 +639,9 @@ static int load_elf_binary(struct linux_
 		    (N_MAGIC(interp_ex) != ZMAGIC) &&
 		    (N_MAGIC(interp_ex) != QMAGIC))
 			interpreter_type = INTERPRETER_ELF;
+#else
+		interpreter_type = INTERPRETER_ELF;
+#endif
 
 		if (memcmp(interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
 			interpreter_type &= ~INTERPRETER_ELF;
@@ -627,6 +650,7 @@ static int load_elf_binary(struct linux_
 		if (!interpreter_type)
 			goto out_free_dentry;
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		/* Make sure only one type was selected */
 		if ((interpreter_type & INTERPRETER_ELF) &&
 		     interpreter_type != INTERPRETER_ELF) {
@@ -634,6 +658,7 @@ static int load_elf_binary(struct linux_
 			// printk(KERN_WARNING "ELF: Ambiguous type, using ELF\n");
 			interpreter_type = INTERPRETER_ELF;
 		}
+#endif
 		/* Verify the interpreter has a valid arch */
 		if ((interpreter_type == INTERPRETER_ELF) &&
 		    !elf_check_arch(&interp_elf_ex))
@@ -651,6 +676,7 @@ static int load_elf_binary(struct linux_
 	/* OK, we are done with that, now set up the arg stuff,
 	   and then start this sucker up */
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	if (!bprm->sh_bang) {
 		char * passed_p;
 
@@ -666,6 +692,7 @@ static int load_elf_binary(struct linux_
 		  }
 		}
 	}
+#endif
 
 	/* Flush all traces of the currently running executable */
 	retval = flush_old_exec(bprm);
@@ -685,6 +712,9 @@ static int load_elf_binary(struct linux_
 	current->mm->end_code = 0;
 	current->mm->mmap = NULL;
 	current->flags &= ~PF_FORKNOEXEC;
+#ifdef CONFIG_HARDEN_STACK
+	if (elf_ex.e_flags & EF_STACKEXEC) current->flags |= PF_STACKEXEC;
+#endif
 	elf_entry = (unsigned long) elf_ex.e_entry;
 
 	/* Do this so that we can load the interpreter, if need be.  We will
@@ -814,10 +844,12 @@ static int load_elf_binary(struct linux_
 	padzero(elf_bss);
 
 	if (elf_interpreter) {
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		if (interpreter_type == INTERPRETER_AOUT)
 			elf_entry = load_aout_interp(&interp_ex,
 						     interpreter);
 		else
+#endif
 			elf_entry = load_elf_interp(&interp_elf_ex,
 						    interpreter,
 						    &interp_load_addr);
@@ -846,7 +878,9 @@ static int load_elf_binary(struct linux_
 
 	kfree(elf_phdata);
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	if (interpreter_type != INTERPRETER_AOUT)
+#endif
 		sys_close(elf_exec_fileno);
 
 	set_binfmt(&elf_format);
@@ -860,10 +894,14 @@ static int load_elf_binary(struct linux_
 			&elf_ex,
 			load_addr, load_bias,
 			interp_load_addr,
+#ifdef CONFIG_BINFMT_ELF_AOUT
 			(interpreter_type == INTERPRETER_AOUT ? 0 : 1));
 	/* N.B. passed_fileno might not be initialized? */
 	if (interpreter_type == INTERPRETER_AOUT)
 		current->mm->arg_start += strlen(passed_fileno) + 1;
+#else
+			1);
+#endif
 	current->mm->start_brk = current->mm->brk = elf_brk;
 	current->mm->end_code = end_code;
 	current->mm->start_code = start_code;
@@ -934,9 +972,9 @@ out_free_ph:
 	goto out;
 }
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 /* This is really simpleminded and specialized - we are loading an
    a.out library that is given an ELF header. */
-
 static int load_elf_library(struct file *file)
 {
 	struct elf_phdr *elf_phdata;
@@ -954,8 +992,9 @@ static int load_elf_library(struct file 
 		goto out;
 
 	/* First of all, some simple consistency checks */
-	if (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||
-	   !elf_check_arch(&elf_ex) || !file->f_op || !file->f_op->mmap)
+	if (elf_ex.e_type != ET_EXEC ||
+	    elf_ex.e_phnum < 1 || elf_ex.e_phnum > 2 ||
+	    !elf_check_arch(&elf_ex) || !file->f_op || !file->f_op->mmap)
 		goto out;
 
 	/* Now read in all of the header information */
@@ -1013,6 +1052,7 @@ out_free_ph:
 out:
 	return error;
 }
+#endif
 
 /*
  * Note that some platforms still use traditional core dumps and not
@@ -1175,9 +1215,12 @@ static int elf_core_dump(long signr, str
 	{
 		unsigned int i, len;
 
-		len = current->mm->arg_end - current->mm->arg_start;
-		if (len >= ELF_PRARGSZ)
-			len = ELF_PRARGSZ-1;
+		if (current->mm->arg_end > current->mm->arg_start) {
+			len = current->mm->arg_end - current->mm->arg_start;
+			if (len >= ELF_PRARGSZ)
+				len = ELF_PRARGSZ-1;
+		} else
+			len = 0;
 		copy_from_user(&psinfo.pr_psargs,
 			      (const char *)current->mm->arg_start, len);
 		for(i = 0; i < len; i++)
diff -urpPX nopatch linux-2.4.33/fs/exec.c linux/fs/exec.c
--- linux-2.4.33/fs/exec.c	Wed Jan 19 17:10:10 2005
+++ linux/fs/exec.c	Sat Aug 12 08:51:47 2006
@@ -109,6 +109,7 @@ static inline void put_binfmt(struct lin
  */
 asmlinkage long sys_uselib(const char * library)
 {
+#if defined(CONFIG_BINFMT_AOUT) || defined(CONFIG_BINFMT_ELF_AOUT)
 	struct file * file;
 	struct nameidata nd;
 	int error;
@@ -155,6 +156,9 @@ out:
 exit:
 	path_release(&nd);
 	goto out;
+#else
+	return -ENOSYS;
+#endif
 }
 
 /*
@@ -637,6 +641,10 @@ int flush_old_exec(struct linux_binprm *
 	tcomm[i] = '\0';
 	set_task_comm(current, tcomm);
 
+#ifdef CONFIG_HARDEN_STACK
+	current->flags &= ~PF_STACKEXEC;
+#endif
+
 	flush_thread();
 
 	de_thread(current);
@@ -774,6 +782,8 @@ void compute_creds(struct linux_binprm *
 		    || atomic_read(&current->fs->count) > 1
 		    || atomic_read(&current->files->count) > 1
 		    || atomic_read(&current->sig->count) > 1) {
+			/* XXX: should fail rather than execute with no raised
+			 * effective privileges */
 			if(!capable(CAP_SETUID)) {
 				bprm->e_uid = current->uid;
 				bprm->e_gid = current->gid;
@@ -940,6 +950,23 @@ int do_execve(char * filename, char ** a
 	retval = PTR_ERR(file);
 	if (IS_ERR(file))
 		return retval;
+
+#ifdef CONFIG_HARDEN_RLIMIT_NPROC
+/*
+ * This check is similar to that done in kernel/fork.c, except that we
+ * are not going to allocate a new task slot here.
+ *
+ * Note that we can only exceed the limit if our UID has changed.
+ */
+	if (current->user)
+	if (atomic_read(&current->user->processes) >
+	    current->rlim[RLIMIT_NPROC].rlim_cur &&
+	    !capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE)) {
+		allow_write_access(file);
+		fput(file);
+		return -EAGAIN;
+	}
+#endif
 
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
 	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0])); 
diff -urpPX nopatch linux-2.4.33/fs/file_table.c linux/fs/file_table.c
--- linux-2.4.33/fs/file_table.c	Mon Apr  4 05:42:20 2005
+++ linux/fs/file_table.c	Sat Aug 12 08:51:47 2006
@@ -43,6 +43,7 @@ struct file * get_empty_filp(void)
 	new_one:
 		memset(f, 0, sizeof(*f));
 		atomic_set(&f->f_count,1);
+		init_MUTEX(&f->f_pos_lock);
 		f->f_version = ++event;
 		f->f_uid = current->fsuid;
 		f->f_gid = current->fsgid;
@@ -88,6 +89,7 @@ int init_private_file(struct file *filp,
 	memset(filp, 0, sizeof(*filp));
 	filp->f_mode   = mode;
 	atomic_set(&filp->f_count, 1);
+	init_MUTEX(&filp->f_pos_lock);
 	filp->f_dentry = dentry;
 	filp->f_uid    = current->fsuid;
 	filp->f_gid    = current->fsgid;
--- linux-2.4.33.3/fs/namei.c.sl70.orig	2006-09-24 14:59:34.000000000 -0600
+++ linux-2.4.33.3/fs/namei.c	2006-09-24 15:16:33.000000000 -0600
@@ -14,6 +14,7 @@
 /* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.
  */
 
+#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
@@ -339,6 +340,40 @@ static struct dentry * real_lookup(struc
 	return result;
 }
 
+#ifdef CONFIG_HARDEN_LINK
+/* Keep this code separately (non-inline) */
+static void security_alert_symlink(struct inode *inode)
+{
+	security_alert("not followed symlink of %d.%d "
+		"by UID %d, EUID %d, process %s:%d",
+		"symlinks not followed",
+		inode->i_uid, inode->i_gid,
+		current->uid, current->euid, current->comm, current->pid);
+}
+
+static inline int check_link(struct dentry *dentry)
+{
+	struct inode *inode, *dir;
+
+	inode = dentry->d_inode;
+	/* XXX: no locking, races possible */
+	dir = dentry->d_parent->d_inode;
+
+	/*
+	 * Don't follow links that we don't own in +t directories,
+	 * unless the link is owned by the owner of the directory.
+	 */
+	if ((dir->i_mode & S_ISVTX) &&
+	    inode->i_uid != dir->i_uid &&
+	    current->fsuid != inode->i_uid) {
+		security_alert_symlink(inode);
+		return -EACCES;
+	}
+
+	return 0;
+}
+#endif
+
 /*
  * This limits recursive symlink follows to 5, while
  * limiting consecutive symlinks to 40.
@@ -360,6 +395,11 @@ static inline int do_follow_link(struct 
 		goto loop;
 	if (current->total_link_count >= 40)
 		goto loop;
+#ifdef CONFIG_HARDEN_LINK
+	err = check_link(dentry);
+	if (err)
+		goto out;
+#endif
 	if (current->need_resched) {
 		current->state = TASK_RUNNING;
 		schedule();
@@ -395,8 +435,10 @@ static inline int do_follow_link(struct 
 	current->link_count--;
 	return err;
 loop:
+	err = -ELOOP;
+out:
 	path_release(nd);
-	return -ELOOP;
+	return err;
 }
 
 static inline int __follow_up(struct vfsmount **mnt, struct dentry **base)
@@ -1340,6 +1382,32 @@ do_last:
 	/*
 	 * It already exists.
 	 */
+
+#ifdef CONFIG_HARDEN_FIFO
+	/*
+	 * Don't write to FIFOs that we don't own in +t directories,
+	 * unless the FIFO is owned by the owner of the directory.
+	 *
+	 * Do this check early while we hold the directory.
+	 */
+	inode = dentry->d_inode;
+	if (S_ISFIFO(inode->i_mode) && !(flag & O_EXCL) &&
+	    (dir->d_inode->i_mode & S_ISVTX) &&
+	    inode->i_uid != dir->d_inode->i_uid &&
+	    current->fsuid != inode->i_uid) {
+		up(&dir->d_inode->i_sem);
+		if (!permission(inode, acc_mode))
+		security_alert("denied writing FIFO of %d.%d "
+			"by UID %d, EUID %d, process %s:%d",
+			"writes into a FIFO denied",
+			inode->i_uid, inode->i_gid,
+			current->uid, current->euid,
+			current->comm, current->pid);
+		error = -EACCES;
+		goto exit_dput;
+	}
+#endif
+
 	up(&dir->d_inode->i_sem);
 
 	error = -EEXIST;
@@ -1603,6 +1671,12 @@ do_link:
           }
         #endif
 
+#ifdef CONFIG_HARDEN_LINK
+       error = check_link(dentry);
+       if (error)
+               goto exit_dput;
+#endif
+
 	UPDATE_ATIME(dentry->d_inode);
 	mnt = mntget(nd->mnt);
 	error = dentry->d_inode->i_op->follow_link(dentry, nd);
@@ -2334,6 +2408,31 @@ int vfs_link(struct dentry *old_dentry, 
 		goto exit_lock;
 	if (!dir->i_op || !dir->i_op->link)
 		goto exit_lock;
+		
+#ifdef CONFIG_HARDEN_LINK
+	/*
+	 * Don't allow users to create hard links to files they don't own,
+	 * unless they could read and write the file or have CAP_FOWNER.
+	 *
+	 * The real UID check is here as a workaround for atd(8) only, to
+	 * be removed one day.
+	 */
+	if (current->fsuid != inode->i_uid &&
+	    (!S_ISREG(inode->i_mode) ||
+	    (inode->i_mode & S_ISUID) ||
+	    ((inode->i_mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) ||
+	    (error = permission(inode, MAY_READ | MAY_WRITE))) &&
+	    !capable(CAP_FOWNER) &&
+	    current->uid) {
+		security_alert("denied hard link to %d.%d "
+			"for UID %d, EUID %d, process %s:%d",
+			"hard links denied",
+			inode->i_uid, inode->i_gid,
+			current->uid, current->euid,
+			current->comm, current->pid);
+		goto exit_lock;
+	}
+#endif
 
         /* RSBAC */
         #ifdef CONFIG_RSBAC
diff -urpPX nopatch linux-2.4.33/fs/nfsd/vfs.c linux/fs/nfsd/vfs.c
--- linux-2.4.33/fs/nfsd/vfs.c	Sat Nov 26 09:02:42 2005
+++ linux/fs/nfsd/vfs.c	Sat Aug 12 08:51:47 2006
@@ -470,6 +470,9 @@ nfsd_open(struct svc_rqst *rqstp, struct
 	memset(filp, 0, sizeof(*filp));
 	filp->f_op    = fops_get(inode->i_fop);
 	atomic_set(&filp->f_count, 1);
+	/* This mutex shouldn't really be used because the filp is local to
+	 * the caller and thus the caller doesn't need any f_pos locking. */
+	init_MUTEX(&filp->f_pos_lock);
 	filp->f_dentry = dentry;
 	filp->f_vfsmnt = fhp->fh_export->ex_mnt;
 	filp->f_maxcount = INT_MAX;
diff -urpPX nopatch linux-2.4.33/fs/proc/base.c linux/fs/proc/base.c
--- linux-2.4.33/fs/proc/base.c	Sat Aug 12 08:48:39 2006
+++ linux/fs/proc/base.c	Sat Aug 12 08:51:47 2006
@@ -777,7 +777,12 @@ static struct inode *proc_pid_make_inode
 	inode->i_gid = 0;
 	if (ino == PROC_PID_INO || task_dumpable(task)) {
 		inode->i_uid = task->euid;
+#ifdef CONFIG_HARDEN_PROC
+		if (inode->i_sb->s_root)
+			inode->i_gid = inode->i_sb->s_root->d_inode->i_gid;
+#else
 		inode->i_gid = task->egid;
+#endif
 	}
 
 out:
@@ -1090,7 +1095,11 @@ struct dentry *proc_pid_lookup(struct in
 
 	if (!inode)
 		goto out;
+#ifdef CONFIG_HARDEN_PROC
+	inode->i_mode = S_IFDIR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP;
+#else
 	inode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
+#endif
 	inode->i_op = &proc_base_inode_operations;
 	inode->i_fop = &proc_base_operations;
 	inode->i_nlink = 3;
diff -urpPX nopatch linux-2.4.33/fs/proc/generic.c linux/fs/proc/generic.c
--- linux-2.4.33/fs/proc/generic.c	Wed Jan 19 17:10:11 2005
+++ linux/fs/proc/generic.c	Sun Aug 13 20:59:16 2006
@@ -62,11 +62,17 @@ proc_file_read(struct file * file, char 
 	if (!(page = (char*) __get_free_page(GFP_KERNEL)))
 		return -ENOMEM;
 
+	if (pos < 0 || pos >= MAX_NON_LFS)
+		eof = 1;
+	else if (nbytes > MAX_NON_LFS - pos)
+		nbytes = MAX_NON_LFS - pos;
+
 	while ((nbytes > 0) && !eof)
 	{
-		count = MIN(PROC_BLOCK_SIZE, nbytes);
-		if ((unsigned)pos > INT_MAX)
+		/* This is redundant, but better safe than sorry */
+		if (pos < 0 || pos >= MAX_NON_LFS)
 			break;
+		count = MIN(PROC_BLOCK_SIZE, nbytes);
 
 		start = NULL;
 		if (dp->get_info) {
@@ -396,7 +402,9 @@ static int proc_register(struct proc_dir
 static void proc_kill_inodes(struct proc_dir_entry *de)
 {
 	struct list_head *p;
-	struct super_block *sb = proc_mnt->mnt_sb;
+	struct super_block *sb = proc_super;
+
+	if (!sb) return;
 
 	/*
 	 * Actually it's a partial revoke().
diff -urpPX nopatch linux-2.4.33/fs/proc/inode.c linux/fs/proc/inode.c
--- linux-2.4.33/fs/proc/inode.c	Fri Nov 28 21:26:21 2003
+++ linux/fs/proc/inode.c	Wed Aug 16 04:54:57 2006
@@ -4,6 +4,7 @@
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
 
+#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/proc_fs.h>
 #include <linux/kernel.h>
@@ -73,8 +74,6 @@ static void proc_delete_inode(struct ino
 	}
 }
 
-struct vfsmount *proc_mnt;
-
 static void proc_read_inode(struct inode * inode)
 {
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
@@ -153,6 +152,10 @@ printk("proc_iget: using deleted entry %
 			inode->i_mode = de->mode;
 			inode->i_uid = de->uid;
 			inode->i_gid = de->gid;
+#ifdef CONFIG_HARDEN_PROC
+			if (sb->s_root)
+				inode->i_gid = sb->s_root->d_inode->i_gid;
+#endif
 		}
 		if (de->size)
 			inode->i_size = de->size;
@@ -176,12 +179,15 @@ out_fail:
 	goto out;
 }			
 
+struct super_block *proc_super = NULL;
+
 struct super_block *proc_read_super(struct super_block *s,void *data, 
 				    int silent)
 {
 	struct inode * root_inode;
 	struct task_struct *p;
 
+	s->s_flags |= MS_NOSUID | MS_NOEXEC | MS_NODEV;
 	s->s_blocksize = 1024;
 	s->s_blocksize_bits = 10;
 	s->s_magic = PROC_SUPER_MAGIC;
@@ -201,6 +207,10 @@ struct super_block *proc_read_super(stru
 	if (!s->s_root)
 		goto out_no_root;
 	parse_options(data, &root_inode->i_uid, &root_inode->i_gid);
+	if (!proc_super) {
+		s->s_count++;
+		proc_super = s;
+	}
 	return s;
 
 out_no_root:
diff -urpPX nopatch linux-2.4.33/fs/proc/root.c linux/fs/proc/root.c
--- linux-2.4.33/fs/proc/root.c	Wed Nov 17 14:54:21 2004
+++ linux/fs/proc/root.c	Sat Aug 12 08:51:47 2006
@@ -8,6 +8,7 @@
 
 #include <asm/uaccess.h>
 
+#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/proc_fs.h>
@@ -30,14 +31,12 @@ void __init proc_root_init(void)
 	int err = register_filesystem(&proc_fs_type);
 	if (err)
 		return;
-	proc_mnt = kern_mount(&proc_fs_type);
-	err = PTR_ERR(proc_mnt);
-	if (IS_ERR(proc_mnt)) {
-		unregister_filesystem(&proc_fs_type);
-		return;
-	}
 	proc_misc_init();
+#ifdef CONFIG_HARDEN_PROC
+	proc_net = proc_mkdir_mode("net", S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP, 0);
+#else
 	proc_net = proc_mkdir("net", 0);
+#endif
 	proc_net_stat = proc_mkdir("net/stat", NULL);
 
 #ifdef CONFIG_SYSVIPC
--- linux-2.4.33.3/fs/read_write.c.sl70.orig	2006-09-24 14:59:35.000000000 -0600
+++ linux-2.4.33.3/fs/read_write.c	2006-09-24 15:08:48.000000000 -0600
@@ -127,7 +127,9 @@ static inline loff_t llseek(struct file 
 	if (file->f_op && file->f_op->llseek)
 		fn = file->f_op->llseek;
 	lock_kernel();
+	_file_pos_lock(file);
 	retval = fn(file, offset, origin);
+	_file_pos_unlock(file);
 	unlock_kernel();
 	return retval;
 }
@@ -203,6 +205,7 @@ asmlinkage ssize_t sys_read(unsigned int
 	file = fget(fd);
 	if (file) {
 		if (file->f_mode & FMODE_READ) {
+			file_pos_lock(file);
 			ret = rw_verify_area(READ, file, &file->f_pos, count);
 
 			if (!ret) {
@@ -295,6 +298,7 @@ asmlinkage ssize_t sys_read(unsigned int
 				if (file->f_op && (read = file->f_op->read) != NULL)
 					ret = read(file, buf, count, &file->f_pos);
 			}
+			file_pos_unlock(file);
 		}
 		if (ret > 0)
 			dnotify_parent(file->f_dentry, DN_ACCESS);
@@ -343,6 +347,7 @@ asmlinkage ssize_t sys_write(unsigned in
 	file = fget(fd);
 	if (file) {
 		if (file->f_mode & FMODE_WRITE) {
+			file_pos_lock(file);
 			ret = rw_verify_area(WRITE, file, &file->f_pos, count);
 			if (!ret) {
 				ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
@@ -433,6 +438,7 @@ asmlinkage ssize_t sys_write(unsigned in
 				if (file->f_op && (write = file->f_op->write) != NULL)
 					ret = write(file, buf, count, &file->f_pos);
 			}
+			file_pos_unlock(file);
 		}
 		if (ret > 0)
 			dnotify_parent(file->f_dentry, DN_MODIFY);
@@ -707,8 +713,11 @@ asmlinkage ssize_t sys_readv(unsigned lo
 	if (!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_READ) &&
-	    (file->f_op->readv || file->f_op->read))
+	    (file->f_op->readv || file->f_op->read)) {
+		file_pos_lock(file);
 		ret = do_readv_writev(VERIFY_WRITE, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
@@ -727,8 +736,11 @@ asmlinkage ssize_t sys_writev(unsigned l
 	if (!file)
 		goto bad_file;
 	if (file->f_op && (file->f_mode & FMODE_WRITE) &&
-	    (file->f_op->writev || file->f_op->write))
+	    (file->f_op->writev || file->f_op->write)) {
+		file_pos_lock(file);
 		ret = do_readv_writev(VERIFY_READ, file, vector, count);
+		file_pos_unlock(file);
+	}
 	fput(file);
 
 bad_file:
@@ -760,15 +772,16 @@ asmlinkage ssize_t sys_pread(unsigned in
 		goto bad_file;
 	if (!(file->f_mode & FMODE_READ))
 		goto out;
-	ret = rw_verify_area(READ, file, &pos, count);
-
-	if (ret)
-		goto out;
 	ret = -EINVAL;
 	if (!file->f_op || !(read = file->f_op->read))
 		goto out;
 	if (pos < 0)
 		goto out;
+	ret = rw_verify_area(READ, file, &pos, count);
+	if (ret)
+		goto out;
+	/* XXX: for broken drivers which use file->f_pos instead of *ppos */
+	file_pos_lock(file);
 
         /* RSBAC */
         #ifdef CONFIG_RSBAC_RW
@@ -816,6 +829,7 @@ asmlinkage ssize_t sys_pread(unsigned in
         #endif /* CONFIG_RSBAC_RW */
 
 	ret = read(file, buf, count, &pos);
+	file_pos_unlock(file);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_ACCESS);
 
@@ -868,15 +882,17 @@ asmlinkage ssize_t sys_pwrite(unsigned i
 		goto bad_file;
 	if (!(file->f_mode & FMODE_WRITE))
 		goto out;
-	ret = rw_verify_area(WRITE, file, &pos, count);
-
-	if (ret)
-		goto out;
 	ret = -EINVAL;
 	if (!file->f_op || !(write = file->f_op->write))
 		goto out;
 	if (pos < 0)
 		goto out;
+	ret = rw_verify_area(WRITE, file, &pos, count);
+	if (ret)
+		goto out;
+	
+	/* XXX: for broken drivers which use file->f_pos instead of *ppos */
+	file_pos_lock(file);
 
         /* RSBAC */
         #ifdef CONFIG_RSBAC_RW
@@ -924,6 +940,7 @@ asmlinkage ssize_t sys_pwrite(unsigned i
         #endif /* CONFIG_RSBAC_RW */
 
 	ret = write(file, buf, count, &pos);
+	file_pos_unlock(file);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_MODIFY);
 
diff -urpPX nopatch linux-2.4.33/include/asm-i386/a.out.h linux/include/asm-i386/a.out.h
--- linux-2.4.33/include/asm-i386/a.out.h	Fri Jun 16 22:33:06 1995
+++ linux/include/asm-i386/a.out.h	Sat Aug 12 08:51:47 2006
@@ -19,7 +19,16 @@ struct exec
 
 #ifdef __KERNEL__
 
+#include <linux/config.h>
+
+#ifdef CONFIG_HARDEN_STACK
+#define STACK_TOP ( \
+	(current->flags & PF_STACKEXEC) \
+	? TASK_SIZE - _STK_LIM \
+	: TASK_SIZE )
+#else
 #define STACK_TOP	TASK_SIZE
+#endif
 
 #endif
 
diff -urpPX nopatch linux-2.4.33/include/asm-i386/processor.h linux/include/asm-i386/processor.h
--- linux-2.4.33/include/asm-i386/processor.h	Wed Feb 18 16:36:32 2004
+++ linux/include/asm-i386/processor.h	Sat Aug 12 08:51:47 2006
@@ -261,10 +261,28 @@ extern unsigned int mca_pentium_flag;
  */
 #define TASK_SIZE	(PAGE_OFFSET)
 
+/*
+ * Magic addresses to return to the kernel from signal handlers. These two
+ * must be beyond user code segment limit, differ only in bit 2, and
+ * MAGIC_RT_SIGRETURN must have the bit cleared.
+ */
+#define MAGIC_RT_SIGRETURN	(PAGE_OFFSET + 0xDE0000)
+#define MAGIC_SIGRETURN		(PAGE_OFFSET + 0xDE0004)
+
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
+#if defined(CONFIG_HARDEN_STACK) && defined(CONFIG_BINFMT_ELF)
+extern struct linux_binfmt elf_format;
+#define TASK_UNMAPPED_BASE(size) ( \
+	current->binfmt == &elf_format && \
+	!(current->flags & PF_STACKEXEC) && \
+	(size) < 0x00ef0000UL \
+	? 0x00110000UL \
+	: TASK_SIZE / 3 )
+#else
 #define TASK_UNMAPPED_BASE	(TASK_SIZE / 3)
+#endif
 
 /*
  * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
diff -urpPX nopatch linux-2.4.33/include/linux/a.out.h linux/include/linux/a.out.h
--- linux-2.4.33/include/linux/a.out.h	Thu Nov 22 22:46:18 2001
+++ linux/include/linux/a.out.h	Sat Aug 12 08:51:47 2006
@@ -37,6 +37,9 @@ enum machine_type {
   M_MIPS2 = 152		/* MIPS R6000/R4000 binary */
 };
 
+/* Constants for the N_FLAGS field */
+#define F_STACKEXEC	1	/* Executable stack area forced */
+
 #if !defined (N_MAGIC)
 #define N_MAGIC(exec) ((exec).a_info & 0xffff)
 #endif
diff -urpPX nopatch linux-2.4.33/include/linux/elf.h linux/include/linux/elf.h
--- linux-2.4.33/include/linux/elf.h	Wed Feb 18 16:36:32 2004
+++ linux/include/linux/elf.h	Sat Aug 12 08:51:47 2006
@@ -260,6 +260,8 @@ typedef struct {
 #define R_MIPS_LOVENDOR		100
 #define R_MIPS_HIVENDOR		127
 
+/* Constants for the e_flags field */
+#define EF_STACKEXEC	1	/* Executable stack area forced */
 
 /*
  * Sparc ELF relocation types
diff -urpPX nopatch linux-2.4.33/include/linux/fs.h linux/include/linux/fs.h
--- linux-2.4.33/include/linux/fs.h	Mon Apr  4 05:42:20 2005
+++ linux/include/linux/fs.h	Sat Aug 12 08:51:47 2006
@@ -585,7 +585,10 @@ struct file {
 	/* preallocated helper kiobuf to speedup O_DIRECT */
 	struct kiobuf		*f_iobuf;
 	long			f_iobuf_lock;
+
+	struct semaphore	f_pos_lock;
 };
+
 extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
 #define file_list_unlock() spin_unlock(&files_lock);
@@ -593,6 +596,12 @@ extern spinlock_t files_lock;
 #define get_file(x)	atomic_inc(&(x)->f_count)
 #define file_count(x)	atomic_read(&(x)->f_count)
 
+#define _file_pos_lock(x) \
+	down(&(x)->f_pos_lock);
+
+#define _file_pos_unlock(x) \
+	up(&(x)->f_pos_lock);
+
 extern int init_private_file(struct file *, struct dentry *, int);
 
 #define	MAX_NON_LFS	((1UL<<31) - 1)
@@ -1587,6 +1596,37 @@ extern int inode_setattr(struct inode *,
 
 /* kernel/fork.c */
 extern int unshare_files(void);
+
+static inline void file_pos_lock(struct file *file)
+{
+	/* XXX: This check is based on a correlation seen in current kernel
+	 * sources only.  It is known to be wrong for at least one driver
+	 * (for a tape device) where no_llseek is used yet reads/writes do
+	 * advance f_pos.  What this means is that some f_pos-aware drivers
+	 * may be left out of coverage of our added locking (and not benefit
+	 * from it) and also that some non-f_pos-aware drivers may be invoked
+	 * with the lock acquired if they happen to use a custom function
+	 * instead of the global no_llseek() (with the potential for added
+	 * deadlock scenarios in some weird user-space applications). */
+	if (file->f_op && file->f_op->llseek != no_llseek) {
+		_file_pos_lock(file);
+		/* XXX: Just in case of an otherwise undetected wraparound
+		 * in a previously invoked syscall. */
+		if (file->f_pos < 0)
+			file->f_pos = 0;
+	}
+}
+
+static inline void file_pos_unlock(struct file *file)
+{
+	if (file->f_op && file->f_op->llseek != no_llseek) {
+		/* XXX: Just in case of an otherwise undetected wraparound
+		 * in the underlying read/write routine we've just called. */
+		if (file->f_pos < 0)
+			file->f_pos = 0;
+		_file_pos_unlock(file);
+	}
+}
 
 /*
  * Common dentry functions for inclusion in the VFS
diff -urpPX nopatch linux-2.4.33/include/linux/kernel.h linux/include/linux/kernel.h
--- linux-2.4.33/include/linux/kernel.h	Mon Apr  4 05:42:20 2005
+++ linux/include/linux/kernel.h	Sat Aug 12 08:51:47 2006
@@ -176,6 +176,26 @@ extern void dump_stack(void);
 #define max_t(type,x,y) \
 	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
 
+#define security_alert(normal_msg, flood_msg, args...) \
+({ \
+	static unsigned long warning_time = 0, no_flood_yet = 0; \
+	static spinlock_t security_alert_lock = SPIN_LOCK_UNLOCKED; \
+\
+	spin_lock(&security_alert_lock); \
+\
+/* Make sure at least one minute passed since the last warning logged */ \
+	if (!warning_time || jiffies - warning_time > 60 * HZ) { \
+		warning_time = jiffies; no_flood_yet = 1; \
+		printk(KERN_ALERT "Security: " normal_msg "\n", ## args); \
+	} else if (no_flood_yet) { \
+		warning_time = jiffies; no_flood_yet = 0; \
+		printk(KERN_ALERT "Security: more " flood_msg \
+			", logging disabled for a minute\n"); \
+	} \
+\
+	spin_unlock(&security_alert_lock); \
+})
+
 extern void __out_of_line_bug(int line) ATTRIB_NORET;
 #define out_of_line_bug() __out_of_line_bug(__LINE__)
 
diff -urpPX nopatch linux-2.4.33/include/linux/proc_fs.h linux/include/linux/proc_fs.h
--- linux-2.4.33/include/linux/proc_fs.h	Sat Aug 12 08:48:39 2006
+++ linux/include/linux/proc_fs.h	Sat Aug 12 08:51:47 2006
@@ -96,7 +96,7 @@ extern struct proc_dir_entry *create_pro
 						struct proc_dir_entry *parent);
 extern void remove_proc_entry(const char *name, struct proc_dir_entry *parent);
 
-extern struct vfsmount *proc_mnt;
+extern struct super_block *proc_super;
 extern struct super_block *proc_read_super(struct super_block *,void *,int);
 extern struct inode * proc_get_inode(struct super_block *, int, struct proc_dir_entry *);
 
diff -urpPX nopatch linux-2.4.33/include/linux/sched.h linux/include/linux/sched.h
--- linux-2.4.33/include/linux/sched.h	Wed Jan 19 17:10:12 2005
+++ linux/include/linux/sched.h	Sat Aug 12 08:51:47 2006
@@ -436,6 +436,8 @@ struct task_struct {
 
 #define PF_USEDFPU	0x00100000	/* task used FPU this quantum (SMP) */
 
+#define PF_STACKEXEC	0x01000000	/* Executable stack area forced */
+
 /*
  * Ptrace flags
  */
diff -urpPX nopatch linux-2.4.33/init/do_mounts.c linux/init/do_mounts.c
--- linux-2.4.33/init/do_mounts.c	Fri Nov 28 21:26:21 2003
+++ linux/init/do_mounts.c	Sat Aug 12 08:51:47 2006
@@ -348,6 +348,7 @@ static void __init mount_block_root(char
 {
 	char *fs_names = __getname();
 	char *p;
+	int tries = 10;
 
 	get_fs_names(fs_names);
 retry:
@@ -367,11 +368,18 @@ retry:
 		 * Allow the user to distinguish between failed open
 		 * and bad superblock on root device.
 		 */
+		if (--tries) {
+			printk ("VFS: Cannot open root device \"%s\" or %s, "
+				"retrying in 1s.\n",
+				root_device_name, kdevname (ROOT_DEV));
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(HZ);
+			goto retry;
+		}
 		printk ("VFS: Cannot open root device \"%s\" or %s\n",
 			root_device_name, kdevname (ROOT_DEV));
 		printk ("Please append a correct \"root=\" boot option\n");
-		panic("VFS: Unable to mount root fs on %s",
-			kdevname(ROOT_DEV));
+		break;
 	}
 	panic("VFS: Unable to mount root fs on %s", kdevname(ROOT_DEV));
 out:
diff -urpPX nopatch linux-2.4.33/ipc/shm.c linux/ipc/shm.c
--- linux-2.4.33/ipc/shm.c	Sat Aug 12 08:48:39 2006
+++ linux/ipc/shm.c	Sat Aug 12 08:51:47 2006
@@ -149,13 +149,40 @@ static void shm_close (struct vm_area_st
 	shp->shm_lprid = current->pid;
 	shp->shm_dtim = CURRENT_TIME;
 	shp->shm_nattch--;
+#ifdef CONFIG_HARDEN_SHM
+	if(shp->shm_nattch == 0) {
+		shp->shm_flags |= SHM_DEST;
+		shm_destroy (shp);
+	}
+#else
 	if(shp->shm_nattch == 0 &&
 	   shp->shm_flags & SHM_DEST)
 		shm_destroy (shp);
+#endif
 	else
 		shm_unlock(id);
 	up (&shm_ids.sem);
 }
+
+#ifdef CONFIG_HARDEN_SHM
+void shm_exit (void)
+{
+	int i;
+	struct shmid_kernel *shp;
+
+	for (i = 0; i <= shm_ids.max_id; i++) {
+		shp = shm_get(i);
+		if (!shp) continue;
+
+		if (shp->shm_cprid != current->pid) continue;
+
+		if (shp->shm_nattch <= 0) {
+			shp->shm_flags |= SHM_DEST;
+			shm_destroy (shp);
+		}
+	}
+}
+#endif
 
 static int shm_mmap(struct file * file, struct vm_area_struct * vma)
 {
diff -urpPX nopatch linux-2.4.33/ipc/util.c linux/ipc/util.c
--- linux-2.4.33/ipc/util.c	Mon Aug 25 15:44:44 2003
+++ linux/ipc/util.c	Sat Aug 12 08:51:47 2006
@@ -346,8 +346,15 @@ int ipc_parse_version (int *cmd)
 
 void sem_exit (void)
 {
-    return;
+	return;
 }
+
+#ifdef CONFIG_HARDEN_SHM
+void shm_exit (void)
+{
+	return;
+}
+#endif
 
 asmlinkage long sys_semget (key_t key, int nsems, int semflg)
 {
diff -urpPX nopatch linux-2.4.33/kernel/exit.c linux/kernel/exit.c
--- linux-2.4.33/kernel/exit.c	Fri Nov 29 02:53:15 2002
+++ linux/kernel/exit.c	Sat Aug 12 08:51:47 2006
@@ -22,6 +22,9 @@
 #include <asm/mmu_context.h>
 
 extern void sem_exit (void);
+#ifdef CONFIG_HARDEN_SHM
+extern void shm_exit (void);
+#endif
 extern struct task_struct *child_reaper;
 
 int getrusage(struct task_struct *, int, struct rusage *);
@@ -443,6 +446,9 @@ fake_volatile:
 
 	lock_kernel();
 	sem_exit();
+#ifdef CONFIG_HARDEN_SHM
+	shm_exit();
+#endif
 	__exit_files(tsk);
 	__exit_fs(tsk);
 	exit_namespace(tsk);
diff -urpPX nopatch linux-2.4.33/kernel/printk.c linux/kernel/printk.c
--- linux-2.4.33/kernel/printk.c	Wed Nov 17 14:54:22 2004
+++ linux/kernel/printk.c	Sat Aug 12 08:51:47 2006
@@ -299,8 +299,13 @@ out:
 
 asmlinkage long sys_syslog(int type, char * buf, int len)
 {
+#ifdef CONFIG_HARDEN_PROC
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+#else
 	if ((type != 3) && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
+#endif
 	return do_syslog(type, buf, len);
 }
 
diff -urpPX nopatch linux-2.4.33/kernel/sys.c linux/kernel/sys.c
--- linux-2.4.33/kernel/sys.c	Fri Nov 28 21:26:21 2003
+++ linux/kernel/sys.c	Wed Aug 16 05:19:21 2006
@@ -514,8 +514,10 @@ static int set_user(uid_t new_ruid, int 
 	struct user_struct *new_user;
 
 	new_user = alloc_uid(new_ruid);
-	if (!new_user)
+	if (!new_user) {
+		force_sig(SIGSEGV, current);
 		return -EAGAIN;
+	}
 	switch_uid(new_user);
 
 	if(dumpclear)
diff -urpPX nopatch linux-2.4.33/mm/filemap.c linux/mm/filemap.c
--- linux-2.4.33/mm/filemap.c	Fri Jun  3 04:26:42 2005
+++ linux/mm/filemap.c	Sat Aug 12 08:51:47 2006
@@ -1824,6 +1824,7 @@ static int file_send_actor(read_descript
 	if (size > count)
 		size = count;
 
+	file_pos_lock(file);
  	if (file->f_op->sendpage) {
  		written = file->f_op->sendpage(file, page, offset,
 					       size, &file->f_pos, size<count);
@@ -1840,6 +1841,7 @@ static int file_send_actor(read_descript
 
 		set_fs(old_fs);
 	}
+	file_pos_unlock(file);
 	if (written < 0) {
 		desc->error = written;
 		written = 0;
@@ -1894,15 +1896,27 @@ static ssize_t common_sendfile(int out_f
 	retval = 0;
 	if (count) {
 		read_descriptor_t desc;
-		
-		if (!offset)
-			offset = &in_file->f_pos;
+		loff_t in_pos, *in_ppos;
+
+		in_ppos = offset;
+		if (!offset) {
+			file_pos_lock(in_file);
+			in_pos = in_file->f_pos;
+			file_pos_unlock(in_file);
+			in_ppos = &in_pos;
+		}
 
 		desc.written = 0;
 		desc.count = count;
 		desc.buf = (char *) out_file;
 		desc.error = 0;
-		do_generic_file_read(in_file, offset, &desc, file_send_actor);
+		do_generic_file_read(in_file, in_ppos, &desc, file_send_actor);
+
+		if (!offset) {
+			file_pos_lock(in_file);
+			in_file->f_pos = in_pos;
+			file_pos_unlock(in_file);
+		}
 
 		retval = desc.written;
 		if (!retval)
diff -urpPX nopatch linux-2.4.33/mm/mmap.c linux/mm/mmap.c
--- linux-2.4.33/mm/mmap.c	Wed Jan 19 17:10:13 2005
+++ linux/mm/mmap.c	Sat Aug 12 08:51:47 2006
@@ -3,6 +3,7 @@
  *
  * Written by obz.
  */
+#include <linux/config.h>
 #include <linux/slab.h>
 #include <linux/shm.h>
 #include <linux/mman.h>
@@ -632,7 +633,11 @@ static inline unsigned long arch_get_unm
 		    (!vma || addr + len <= vma->vm_start))
 			return addr;
 	}
+#if defined(CONFIG_HARDEN_STACK) && defined(CONFIG_BINFMT_ELF)
+	addr = PAGE_ALIGN(TASK_UNMAPPED_BASE(len));
+#else
 	addr = PAGE_ALIGN(TASK_UNMAPPED_BASE);
+#endif
 
 	for (vma = find_vma(current->mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
--- linux-2.4.33.3/net/socket.c.sl70.orig	2006-09-24 14:59:35.000000000 -0600
+++ linux-2.4.33.3/net/socket.c	2006-09-24 15:02:39.000000000 -0600
@@ -2002,6 +2002,7 @@
 asmlinkage long sys_getsockopt(int fd, int level, int optname, char *optval, int *optlen)
 {
 	int err;
+	int len;
 	struct socket *sock;
 
         /* RSBAC  */
@@ -2044,6 +2045,13 @@
 	          }
 	        #endif
 
+                /* XXX: insufficient for SMP, but should be redundant anyway */
+                if (get_user(len, optlen))
+                        err = -EFAULT;
+                else
+                if (len < 0)   
+                        err = -EINVAL;
+                else
 		if (level == SOL_SOCKET)
 			err=sock_getsockopt(sock,level,optname,optval,optlen);
 		else
diff -urpPX nopatch linux-2.4.33/security/Common.in linux/security/Common.in
--- linux-2.4.33/security/Common.in	Thu Jan  1 03:00:00 1970
+++ linux/security/Common.in	Sat Aug 12 08:51:47 2006
@@ -0,0 +1,11 @@
+#
+# Security options common to all architectures
+#
+
+bool 'Restricted links in /tmp' CONFIG_HARDEN_LINK
+bool 'Restricted FIFOs in /tmp' CONFIG_HARDEN_FIFO
+bool 'Restricted /proc' CONFIG_HARDEN_PROC
+bool 'Enforce RLIMIT_NPROC on execve(2)' CONFIG_HARDEN_RLIMIT_NPROC
+if [ "$CONFIG_SYSVIPC" = "y" ]; then
+   bool 'Destroy shared memory segments not in use' CONFIG_HARDEN_SHM
+fi
diff -urpPX nopatch linux-2.4.33/security/Config.in linux/security/Config.in
--- linux-2.4.33/security/Config.in	Thu Jan  1 03:00:00 1970
+++ linux/security/Config.in	Sat Aug 12 08:51:47 2006
@@ -0,0 +1,9 @@
+#
+# Security options
+#
+mainmenu_option next_comment
+comment 'Security options'
+
+source security/Common.in
+
+endmenu
